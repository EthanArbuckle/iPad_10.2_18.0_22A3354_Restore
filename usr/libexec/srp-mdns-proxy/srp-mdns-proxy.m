uint64_t compatibilityInitializeAvailabilityCheck()
{
  return _initializeAvailabilityCheck(1);
}

uint64_t __isPlatformVersionAtLeast(int a1, int a2, int a3, int a4)
{
  BOOL v9;
  _DWORD v10[2];

  if (qword_1000901E0 == -1)
  {
    if (qword_1000901E8)
    {
LABEL_3:
      v10[0] = a1;
      v10[1] = (a2 << 16) | (a3 << 8) | a4;
      return _availability_version_check(1, v10);
    }
  }
  else
  {
    dispatch_once_f(&qword_1000901E0, 0, (dispatch_function_t)initializeAvailabilityCheck);
    if (qword_1000901E8)
      goto LABEL_3;
  }
  if (qword_1000901D8 == -1)
  {
    v9 = _MergedGlobals < a2;
    if (_MergedGlobals > a2)
      return 1;
  }
  else
  {
    dispatch_once_f(&qword_1000901D8, 0, (dispatch_function_t)compatibilityInitializeAvailabilityCheck);
    v9 = _MergedGlobals < a2;
    if (_MergedGlobals > a2)
      return 1;
  }
  if (v9)
    return 0;
  if (dword_1000901CC > a3)
    return 1;
  return dword_1000901CC >= a3 && dword_1000901D0 >= a4;
}

uint64_t initializeAvailabilityCheck()
{
  return _initializeAvailabilityCheck(0);
}

uint64_t _initializeAvailabilityCheck(uint64_t result)
{
  void *v1;
  BOOL v2;
  unsigned __int8 *v4;
  uint64_t (*v5)(_QWORD);
  unint64_t v6;
  uint64_t (*v7)(_QWORD, uint64_t, _QWORD, _QWORD);
  uint64_t (*v8)(_QWORD, const char *, uint64_t, unsigned __int8 *);
  uint64_t (*v9)(uint64_t, uint64_t);
  uint64_t (*v10)(uint64_t);
  uint64_t (*v11)(void);
  FILE *v12;
  FILE *v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  FILE *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  FILE *v27;
  unsigned int (*v28)(uint64_t, char *, uint64_t, uint64_t);
  char v29[32];

  v1 = (void *)qword_1000901E8;
  if (qword_1000901E8)
    v2 = (_DWORD)result == 0;
  else
    v2 = 0;
  if (!v2)
  {
    if (&__availability_version_check)
    {
      qword_1000901E8 = (uint64_t)&__availability_version_check;
      v1 = &__availability_version_check;
    }
    if (!v1 || (_DWORD)result != 0)
    {
      result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "kCFAllocatorNull");
      if (result)
      {
        v4 = *(unsigned __int8 **)result;
        result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFDataCreateWithBytesNoCopy");
        if (result)
        {
          v5 = (uint64_t (*)(_QWORD))result;
          v6 = (unint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateWithData");
          result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateFromXMLData");
          if (v6 | result)
          {
            v7 = (uint64_t (*)(_QWORD, uint64_t, _QWORD, _QWORD))result;
            result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringCreateWithCStringNoCopy");
            if (result)
            {
              v8 = (uint64_t (*)(_QWORD, const char *, uint64_t, unsigned __int8 *))result;
              result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFDictionaryGetValue");
              if (result)
              {
                v9 = (uint64_t (*)(uint64_t, uint64_t))result;
                result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFGetTypeID");
                if (result)
                {
                  v10 = (uint64_t (*)(uint64_t))result;
                  result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringGetTypeID");
                  if (result)
                  {
                    v11 = (uint64_t (*)(void))result;
                    result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringGetCString");
                    v28 = (unsigned int (*)(uint64_t, char *, uint64_t, uint64_t))result;
                    if (result)
                    {
                      result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFRelease");
                      if (result)
                      {
                        v12 = (FILE *)result;
                        result = (uint64_t)fopen("/System/Library/CoreServices/SystemVersion.plist", "r");
                        if (result)
                        {
                          v13 = (FILE *)result;
                          v27 = v12;
                          fseek((FILE *)result, 0, 2);
                          v14 = ftell(v13);
                          if (v14 < 0)
                          {
                            v16 = 0;
                          }
                          else
                          {
                            v15 = v14;
                            rewind(v13);
                            v16 = malloc(v15);
                            if (v16)
                            {
                              v26 = v16;
                              if (fread(v16, 1uLL, v15, v13) == v15)
                              {
                                v17 = v5(0);
                                if (v17)
                                {
                                  v18 = v17;
                                  v19 = v13;
                                  if (v6)
                                    v20 = ((uint64_t (*)(_QWORD, uint64_t, _QWORD, _QWORD, _QWORD))v6)(0, v17, 0, 0, 0);
                                  else
                                    v20 = v7(0, v17, 0, 0);
                                  v21 = v20;
                                  if (v20)
                                  {
                                    v22 = v8(0, "ProductVersion", 1536, v4);
                                    if (v22)
                                    {
                                      v23 = v22;
                                      v24 = v9(v21, v22);
                                      ((void (*)(uint64_t))v27)(v23);
                                      if (v24)
                                      {
                                        v25 = v10(v24);
                                        if (v25 == v11())
                                        {
                                          if (v28(v24, v29, 32, 134217984))
                                            sscanf(v29, "%d.%d.%d", &_MergedGlobals, &dword_1000901CC, &dword_1000901D0);
                                        }
                                      }
                                    }
                                    ((void (*)(uint64_t))v27)(v21);
                                    v19 = v13;
                                  }
                                  ((void (*)(uint64_t))v27)(v18);
                                }
                                else
                                {
                                  v19 = v13;
                                }
                                v16 = v26;
                              }
                              else
                              {
                                v16 = v26;
                                v19 = v13;
                              }
                              goto LABEL_41;
                            }
                          }
                          v19 = v13;
LABEL_41:
                          free(v16);
                          return fclose(v19);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void node_type_tracker_callback(uint64_t a1, int a2, int a3)
{
  NSObject *v5;
  void (*v6)(void);
  int v8;
  NSObject *v9;
  char *v10;
  int v11;
  uint64_t **i;
  NSObject *v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  const char *v17;
  _BYTE v18[48];
  __int16 v19;
  int v20;

  if (a3 == -65569)
    goto LABEL_4;
  if (a3)
  {
    if (a3 != -65563)
    {
      v13 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v18 = 136446466;
        *(_QWORD *)&v18[4] = "node_type_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = a3;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: unexpected error %d", v18, 0x12u);
      }
LABEL_20:
      cti_events_discontinue(*(_QWORD *)(a1 + 40));
      *(_QWORD *)(a1 + 40) = 0;
      v14 = *(_DWORD *)a1;
      if (*(_DWORD *)a1)
      {
        v15 = global_os_log;
        if (v14 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v18 = 136447490;
            *(_QWORD *)&v18[4] = "node_type_tracker_callback";
            *(_WORD *)&v18[12] = 1024;
            *(_DWORD *)&v18[14] = v14;
            *(_WORD *)&v18[18] = 2048;
            *(_QWORD *)&v18[20] = a1;
            *(_WORD *)&v18[28] = 2080;
            *(_QWORD *)&v18[30] = "tracker";
            *(_WORD *)&v18[38] = 2080;
            *(_QWORD *)&v18[40] = "node-type-tracker.c";
            v19 = 1024;
            v20 = 116;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
            v14 = *(_DWORD *)a1;
          }
          *(_DWORD *)a1 = v14 - 1;
          if (v14 == 1)
          {
            v16 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v18 = 136447234;
              *(_QWORD *)&v18[4] = "node_type_tracker_callback";
              *(_WORD *)&v18[12] = 2048;
              *(_QWORD *)&v18[14] = a1;
              *(_WORD *)&v18[22] = 2080;
              *(_QWORD *)&v18[24] = "tracker";
              *(_WORD *)&v18[32] = 2080;
              *(_QWORD *)&v18[34] = "node-type-tracker.c";
              *(_WORD *)&v18[42] = 1024;
              *(_DWORD *)&v18[44] = 116;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v18, 0x30u);
            }
            ++node_type_tracker_finalized;
            free((void *)a1);
          }
          return;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_34:
          abort();
        *(_DWORD *)v18 = 136447490;
        *(_QWORD *)&v18[4] = "node_type_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = v14;
        *(_WORD *)&v18[18] = 2048;
        *(_QWORD *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(_QWORD *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(_QWORD *)&v18[40] = "node-type-tracker.c";
        v19 = 1024;
        v20 = 116;
        v17 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        v15 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_34;
        *(_DWORD *)v18 = 136447490;
        *(_QWORD *)&v18[4] = "node_type_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = 0;
        *(_WORD *)&v18[18] = 2048;
        *(_QWORD *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(_QWORD *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(_QWORD *)&v18[40] = "node-type-tracker.c";
        v19 = 1024;
        v20 = 116;
        v17 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, v17, v18, 0x36u);
      goto LABEL_34;
    }
LABEL_4:
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v18 = 136446210;
      *(_QWORD *)&v18[4] = "node_type_tracker_callback";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: disconnected", v18, 0xCu);
    }
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = *(void (**)(void))(a1 + 16);
      if (v6)
        v6();
    }
    goto LABEL_20;
  }
  if ((a2 - 1) >= 8)
    v8 = 0;
  else
    v8 = a2;
  *(_QWORD *)v18 = 0;
  *(_QWORD *)&v18[8] = 0;
  gettimeofday((timeval *)v18, 0);
  *(_QWORD *)(a1 + 56) = 1000 * *(_QWORD *)v18 + *(_DWORD *)&v18[8] / 1000;
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = off_10008CB10[v8];
    *(_DWORD *)v18 = 136446722;
    *(_QWORD *)&v18[4] = "node_type_tracker_callback";
    *(_WORD *)&v18[12] = 2082;
    *(_QWORD *)&v18[14] = v10;
    *(_WORD *)&v18[22] = 1024;
    *(_DWORD *)&v18[24] = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: node type is: %{public}s (%d)\n ", v18, 0x1Cu);
  }
  v11 = *(_DWORD *)(a1 + 64);
  if (v11 != v8)
  {
    *(_DWORD *)(a1 + 64) = v8;
    *(_DWORD *)(a1 + 68) = v11;
    for (i = *(uint64_t ***)(a1 + 48); i; i = (uint64_t **)*i)
      ((void (*)(uint64_t *))i[2])(i[3]);
  }
}

void dnssd_client_release_(int *a1, char *a2, int a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  if (!a1)
    return;
  v6 = *a1;
  if (!*a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "dnssd_client_release_";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "dnssd_client_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "dnssd_client_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      v11 = 136447234;
      v12 = "dnssd_client_release_";
      v13 = 2048;
      *(_QWORD *)v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "omw";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++dnssd_client_finalized;
    dnssd_client_finalize((uint64_t)a1);
  }
}

void dnssd_client_finalize(uint64_t a1)
{
  thread_service_release_(*(int **)(a1 + 136), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 129);
  ioloop_wakeup_release_(*(_QWORD **)(a1 + 88), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 130);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 72));
  free((void *)a1);
}

void dnssd_client_cancel(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = *(_QWORD *)(a1 + 80);
  v3 = *(_QWORD *)(v2 + 40);
  if (v3)
  {
    service_tracker_cancel_probes(v3);
    service_tracker_callback_cancel(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 40), a1);
    v2 = *(_QWORD *)(a1 + 80);
  }
  v4 = *(_QWORD *)(v2 + 56);
  if (v4)
    thread_tracker_callback_cancel(v4, a1);
  ioloop_cancel_wake_event(*(_QWORD *)(a1 + 88));
  v5 = *(_QWORD *)(a1 + 96);
  if (v5)
  {
    cti_events_discontinue(v5);
    v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136447490;
          v11 = "dnssd_client_cancel";
          v12 = 1024;
          *(_DWORD *)v13 = v6;
          *(_WORD *)&v13[4] = 2048;
          *(_QWORD *)&v13[6] = a1;
          *(_WORD *)&v13[14] = 2080;
          *(_QWORD *)&v13[16] = "client";
          *(_WORD *)&v13[24] = 2080;
          *(_QWORD *)&v13[26] = "dnssd-client.c";
          v14 = 1024;
          v15 = 612;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          v6 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v6 - 1;
        if (v6 == 1)
        {
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136447234;
            v11 = "dnssd_client_cancel";
            v12 = 2048;
            *(_QWORD *)v13 = a1;
            *(_WORD *)&v13[8] = 2080;
            *(_QWORD *)&v13[10] = "client";
            *(_WORD *)&v13[18] = 2080;
            *(_QWORD *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 612;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++dnssd_client_finalized;
          dnssd_client_finalize(a1);
        }
        *(_QWORD *)(a1 + 96) = 0;
        goto LABEL_15;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_21:
        abort();
      v10 = 136447490;
      v11 = "dnssd_client_cancel";
      v12 = 1024;
      *(_DWORD *)v13 = v6;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 612;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_21;
      v10 = 136447490;
      v11 = "dnssd_client_cancel";
      v12 = 1024;
      *(_DWORD *)v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 612;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_21;
  }
LABEL_15:
  dnssd_client_remove_published_service(a1);
  state_machine_cancel((uint64_t *)(a1 + 8));
}

uint64_t dnssd_client_remove_published_service(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 152);
  if (result)
  {
    mrc_dns_service_registration_invalidate();
    result = mrc_release(*(_QWORD *)(a1 + 152));
    *(_QWORD *)(a1 + 152) = 0;
  }
  return result;
}

void dnssd_client_service_tracker_callback(uint64_t a1)
{
  int *v2;
  int *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  void (*v7)(int *);
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = state_machine_event_create(4);
  if (v2)
  {
    v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    v4 = *v3;
    if (*v3)
    {
      v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136447490;
          v11 = "dnssd_client_service_tracker_callback";
          v12 = 1024;
          *(_DWORD *)v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(_QWORD *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(_QWORD *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(_QWORD *)&v13[26] = "dnssd-client.c";
          v14 = 1024;
          v15 = 169;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          v4 = *v3;
        }
        *v3 = v4 - 1;
        if (v4 == 1)
        {
          v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136447234;
            v11 = "dnssd_client_service_tracker_callback";
            v12 = 2048;
            *(_QWORD *)v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(_QWORD *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(_QWORD *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 169;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          v7 = (void (*)(int *))*((_QWORD *)v3 + 4);
          if (v7)
            v7(v3);
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_20:
        abort();
      v10 = 136447490;
      v11 = "dnssd_client_service_tracker_callback";
      v12 = 1024;
      *(_DWORD *)v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 169;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_20;
      v10 = 136447490;
      v11 = "dnssd_client_service_tracker_callback";
      v12 = 1024;
      *(_DWORD *)v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 169;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v10 = 136446210;
    v11 = "dnssd_client_service_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

void dnssd_client_context_release(int *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *a1;
  if (!*a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dnssd_client_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "client";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-client.c";
    v10 = 1024;
    v11 = 142;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dnssd_client_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "client";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-client.c";
    v10 = 1024;
    v11 = 142;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "dnssd_client_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "client";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-client.c";
    v10 = 1024;
    v11 = 142;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "dnssd_client_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "client";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "dnssd-client.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 142;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++dnssd_client_finalized;
    dnssd_client_finalize((uint64_t)a1);
  }
}

uint64_t dnssd_client_action_startup(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  uint64_t v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  NSObject *v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 == 3)
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = global_os_log;
    v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v6)
      {
        v7 = *(_QWORD *)(v4 + 40);
        v8 = *(_QWORD *)(v4 + 8);
        v9 = *(_QWORD *)(a2 + 8);
        v10 = *(_QWORD *)(v4 + 24);
        v19 = 136447491;
        v20 = "dnssd_client_action_startup";
        v21 = 2082;
        v22 = v7;
        v23 = 2160;
        v24 = 1752392040;
        v25 = 2081;
        v26 = v8;
        v27 = 2082;
        v28 = v9;
        v29 = 2082;
        v30 = v10;
        v11 = "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s";
        v12 = v5;
        v13 = 62;
LABEL_9:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v19, v13);
      }
    }
    else if (v6)
    {
      v16 = *(_QWORD *)(v4 + 40);
      v17 = *(_QWORD *)(v4 + 8);
      v18 = *(_QWORD *)(v4 + 24);
      v19 = 136447235;
      v20 = "dnssd_client_action_startup";
      v21 = 2082;
      v22 = v16;
      v23 = 2160;
      v24 = 1752392040;
      v25 = 2081;
      v26 = v17;
      v27 = 2082;
      v28 = v18;
      v11 = "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s";
      v12 = v5;
      v13 = 52;
      goto LABEL_9;
    }
    return 2 * *(unsigned __int8 *)(v4 + 120);
  }
  v14 = global_os_log;
  result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if ((_DWORD)result)
  {
    v19 = 136446466;
    v20 = "dnssd_client_action_startup";
    v21 = 1024;
    LODWORD(v22) = v2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't omr_client: %d", (uint8_t *)&v19, 0x12u);
    return 0;
  }
  return result;
}

uint64_t dnssd_client_action_not_client(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t *v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 3)
  {
    v12 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v16 = 136446466;
    v17 = "dnssd_client_action_not_client";
    v18 = 1024;
    LODWORD(v19) = v2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't omr_client: %d", (uint8_t *)&v16, 0x12u);
    return 0;
  }
  v4 = *(uint64_t **)(a1 + 8);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      v13 = v4[5];
      v14 = v4[1];
      v15 = v4[3];
      v16 = 136447235;
      v17 = "dnssd_client_action_not_client";
      v18 = 2082;
      v19 = v13;
      v20 = 2160;
      v21 = 1752392040;
      v22 = 2081;
      v23 = v14;
      v24 = 2082;
      v25 = v15;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", (uint8_t *)&v16, 0x34u);
    }
    if (v4[17])
      dnssd_client_service_unpublish(v4);
    return 0;
  }
  if (v6)
  {
    v7 = v4[5];
    v8 = v4[1];
    v9 = *(_QWORD *)(a2 + 8);
    v10 = v4[3];
    v16 = 136447491;
    v17 = "dnssd_client_action_not_client";
    v18 = 2082;
    v19 = v7;
    v20 = 2160;
    v21 = 1752392040;
    v22 = 2081;
    v23 = v8;
    v24 = 2082;
    v25 = v9;
    v26 = 2082;
    v27 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", (uint8_t *)&v16, 0x3Eu);
  }
  if (dnssd_client_should_be_client(v4[10]))
    return 3;
  else
    return 0;
}

uint64_t dnssd_client_action_probing(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t result;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint32_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  int v25;
  int v26;
  int v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _BOOL4 v35;
  int *v36;
  NSObject *v37;
  NSObject *v38;
  _BOOL4 v39;
  int v40;
  int v41;
  int v42;
  int *v43;
  int *v44;
  int v45;
  NSObject *v46;
  NSObject *v47;
  _BYTE buf[128];
  char __str[20];

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 3)
  {
    v15 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)buf = 136446466;
    *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v2;
    v17 = "%{public}s: state header type isn't omr_client: %d";
    v18 = v15;
    v19 = OS_LOG_TYPE_ERROR;
    v20 = 18;
    goto LABEL_51;
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v6)
    {
      v7 = *(_QWORD *)(v4 + 40);
      v8 = *(_QWORD *)(v4 + 8);
      v9 = *(_QWORD *)(a2 + 8);
      v10 = *(_QWORD *)(v4 + 24);
      *(_DWORD *)buf = 136447491;
      *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v7;
      *(_WORD *)&buf[22] = 2160;
      *(_QWORD *)&buf[24] = 1752392040;
      *(_WORD *)&buf[32] = 2081;
      *(_QWORD *)&buf[34] = v8;
      *(_WORD *)&buf[42] = 2082;
      *(_QWORD *)&buf[44] = v9;
      *(_WORD *)&buf[52] = 2082;
      *(_QWORD *)&buf[54] = v10;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
    }
    v12 = v4 + 80;
    v11 = *(_QWORD *)(v4 + 80);
    if (*(_DWORD *)(a2 + 16) == 1)
    {
      v13 = *(_QWORD *)(v11 + 48);
      if (v13)
      {
        v14 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: server probe startup timeout expired--publishing cached data.", buf, 0xCu);
          v13 = *(_QWORD *)(v11 + 48);
        }
        service_publisher_re_advertise_matching(v13);
      }
      return 0;
    }
    if ((dnssd_client_should_be_client(*(_QWORD *)(v4 + 80)) & 1) == 0)
    {
      ioloop_cancel_wake_event(*(_QWORD *)(v4 + 88));
      return 2;
    }
  }
  else
  {
    if (v6)
    {
      v21 = *(_QWORD *)(v4 + 40);
      v22 = *(_QWORD *)(v4 + 8);
      v23 = *(_QWORD *)(v4 + 24);
      *(_DWORD *)buf = 136447235;
      *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = v21;
      *(_WORD *)&buf[22] = 2160;
      *(_QWORD *)&buf[24] = 1752392040;
      *(_WORD *)&buf[32] = 2081;
      *(_QWORD *)&buf[34] = v22;
      *(_WORD *)&buf[42] = 2082;
      *(_QWORD *)&buf[44] = v23;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
    }
    v12 = v4 + 80;
    v11 = *(_QWORD *)(v4 + 80);
    ioloop_add_wake_event(*(_QWORD *)(v4 + 88), v4, (uint64_t)dnssd_client_wait_expired, (uint64_t)dnssd_client_context_release, 0x1388u);
    v24 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v25 = *(_DWORD *)v4;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v25;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "client";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "dnssd-client.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 488;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v26 = *(_DWORD *)v4;
    if (*(_DWORD *)v4)
    {
      v27 = v26 + 1;
      *(_DWORD *)v4 = v26 + 1;
      if (v26 + 1 >= 10001)
      {
        v28 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_21;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v27;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v4;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "client";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "dnssd-client.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 488;
        v29 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_20;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)v4 = 1;
    }
  }
  v30 = *(_QWORD *)(*(_QWORD *)v12 + 40);
  if (!v30)
    goto LABEL_49;
  v31 = *(_QWORD *)(v30 + 48);
  if (!v31)
    goto LABEL_49;
  do
  {
    if (!*(_BYTE *)(v31 + 27) && *(_BYTE *)(v31 + 48) && *(_BYTE *)(v31 + 49))
    {
      v36 = *(int **)(v4 + 136);
      if (v36)
        thread_service_release_(v36, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 513);
      *(_QWORD *)(v4 + 136) = v31;
      thread_service_retain_((int *)v31, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 516);
      v37 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: server probe succeeded--unpublishing cached data.", buf, 0xCu);
      }
      service_publisher_unadvertise_all(*(_QWORD *)(v11 + 48));
      ioloop_cancel_wake_event(*(_QWORD *)(v4 + 88));
      return 4;
    }
    v31 = *(_QWORD *)(v31 + 8);
  }
  while (v31);
  v32 = *(_QWORD *)(v30 + 48);
  if (!v32)
    goto LABEL_49;
  v33 = 0;
  do
  {
    if (*(_DWORD *)(v32 + 20) == 2 && !*(_BYTE *)(v32 + 27))
    {
      if (*(_BYTE *)(v32 + 28))
        goto LABEL_48;
      if (!v33)
      {
        if (*(_BYTE *)(v32 + 48) || *(_QWORD *)(v32 + 56))
        {
          v33 = 0;
        }
        else if (*(_BYTE *)(v32 + 24))
        {
          v33 = 0;
        }
        else
        {
          v33 = v32;
        }
      }
    }
    v32 = *(_QWORD *)(v32 + 8);
  }
  while (v32);
  if (!v33)
  {
LABEL_49:
    v34 = global_os_log;
    v35 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    result = 0;
    if (!v35)
      return result;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
    v17 = "%{public}s: no service to publish";
    v18 = v34;
    v19 = OS_LOG_TYPE_DEFAULT;
    v20 = 12;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, v20);
    return 0;
  }
  snprintf(buf, 0x80uLL, "service_tracker_unverified_service_get returning %p", (const void *)v33);
  snprintf(__str, 0x14uLL, "[ST%lld]", *(_QWORD *)(v30 + 8));
  thread_service_note((uint64_t)__str, v33, (uint64_t)buf);
  if (!*(_BYTE *)(v33 + 28))
  {
    if (*(_DWORD *)(v33 + 20) == 3)
    {
      *(_QWORD *)(v33 + 64) = *(_QWORD *)(v4 + 104);
      *(_DWORD *)(v33 + 72) = -16777216;
      *(_WORD *)(v33 + 76) = 254;
      *(_WORD *)(v33 + 78) = bswap32(*(unsigned __int16 *)(v33 + 16)) >> 16;
    }
    v38 = global_os_log;
    v39 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    v40 = *(_DWORD *)v4;
    if (v39)
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v40;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "client";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "dnssd-client.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 544;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v40 = *(_DWORD *)v4;
    }
    if (v40)
    {
      v41 = v40 + 1;
      *(_DWORD *)v4 = v40 + 1;
      if (v40 + 1 >= 10001)
      {
        v28 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "dnssd_client_action_probing";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v41;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v4;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "client";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "dnssd-client.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 544;
          v29 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_20:
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v29, buf, 0x36u);
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)v4 = 1;
    }
    v42 = *(_DWORD *)(v33 + 20);
    if (v42 == 3)
    {
      memset(&buf[8], 0, 20);
      *(_QWORD *)buf = 0;
      *(_OWORD *)&buf[8] = *(_OWORD *)(v33 + 64);
      *(_WORD *)&buf[2] = 13568;
      buf[1] = 30;
    }
    else
    {
      if (v42 != 2)
      {
        v47 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "probe_srp_service";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v42;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_FAULT, "%{public}s: bogus service type in probe_srp_service: %d", buf, 0x12u);
        }
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __probe_srp_service_block_invoke;
        *(_QWORD *)&buf[24] = &__block_descriptor_tmp_113;
        *(_QWORD *)&buf[32] = dnssd_client_probe_callback;
        *(_QWORD *)&buf[40] = v33;
        *(_QWORD *)&buf[48] = v4;
        *(_QWORD *)&buf[56] = dnssd_client_context_release;
        dispatch_async((dispatch_queue_t)&_dispatch_main_q, buf);
        return 0;
      }
      if (*(_BYTE *)(v33 + 28) || *(_BYTE *)(v33 + 24))
        return 0;
      memset(&buf[8], 0, 20);
      *(_QWORD *)buf = 7680;
      *(_OWORD *)&buf[8] = *(_OWORD *)(v33 + 64);
      *(_WORD *)&buf[2] = *(_WORD *)(v33 + 80);
    }
    v43 = probe_srp_create((uint64_t)buf, v33, v4);
    v44 = v43;
    if (!v43)
      return 0;
    v45 = *v43;
    if (*v43)
    {
      v28 = global_os_log;
      if (v45 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "probe_srp_service";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v45;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v44;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "probe_state";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "probe-srp.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 440;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v45 = *v44;
        }
        *v44 = v45 - 1;
        if (v45 == 1)
        {
          v46 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "probe_srp_service";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v44;
            *(_WORD *)&buf[22] = 2080;
            *(_QWORD *)&buf[24] = "probe_state";
            *(_WORD *)&buf[32] = 2080;
            *(_QWORD *)&buf[34] = "probe-srp.c";
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = 440;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++probe_state_finalized;
          probe_state_finalize(v44);
        }
        return 0;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "probe_srp_service";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v45;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v44;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "probe_state";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "probe-srp.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 440;
        v29 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_20;
      }
    }
    else
    {
      v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "probe_srp_service";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v44;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "probe_state";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "probe-srp.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 440;
        v29 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_20;
      }
    }
LABEL_21:
    abort();
  }
  v32 = v33;
LABEL_48:
  snprintf(buf, 0x14uLL, "[ST%lld]", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)v12 + 40) + 8));
  thread_service_note((uint64_t)buf, v32, (uint64_t)" is still being probed");
  return 0;
}

uint64_t dnssd_client_action_client(uint64_t a1, uint64_t a2)
{
  int v2;
  int *v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  unsigned __int8 *v20;
  uint64_t ipv6;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t push;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const char *v30;
  NSObject *v31;
  uint32_t v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v37;
  int v38;
  const char *v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  NSObject *v46;
  uint32_t v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  int v51;
  int v52;
  int v53;
  NSObject *v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t presentation;
  int v58;
  const char *v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD v62[5];
  int appended;
  uint8_t buf[4];
  const char *v65;
  __int16 v66;
  _BYTE v67[70];
  __int16 v68;
  _BYTE v69[18];
  __int16 v70;
  int v71;
  __int16 v72;
  uint64_t v73;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 3)
  {
    v13 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)buf = 136446466;
    v65 = "dnssd_client_action_client";
    v66 = 1024;
    *(_DWORD *)v67 = v2;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't omr_client: %d", buf, 0x12u);
    return 0;
  }
  v4 = *(int **)(a1 + 8);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      v14 = *((_QWORD *)v4 + 5);
      v15 = *((_QWORD *)v4 + 1);
      v16 = *((_QWORD *)v4 + 3);
      *(_DWORD *)buf = 136447235;
      v65 = "dnssd_client_action_client";
      v66 = 2082;
      *(_QWORD *)v67 = v14;
      *(_WORD *)&v67[8] = 2160;
      *(_QWORD *)&v67[10] = 1752392040;
      *(_WORD *)&v67[18] = 2081;
      *(_QWORD *)&v67[20] = v15;
      *(_WORD *)&v67[28] = 2082;
      *(_QWORD *)&v67[30] = v16;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
    }
    dnssd_client_service_unpublish((uint64_t *)v4);
    appended = 0;
    v17 = mdns_domain_name_create("default.service.arpa.", 0, &appended);
    v18 = appended;
    if (appended)
    {
      v60 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_60;
      *(_DWORD *)buf = 136446466;
      v65 = "dnssd_client_service_publish";
      v66 = 1024;
      *(_DWORD *)v67 = v18;
      v30 = "%{public}s: failed to create default.service.arpa.: %{darwin.errno}d";
      v31 = v60;
      v32 = 18;
      goto LABEL_59;
    }
    v19 = *((_QWORD *)v4 + 17);
    if ((*(_DWORD *)(v19 + 20) & 0xFFFFFFFE) == 2)
    {
      v20 = (unsigned __int8 *)(v19 + 64);
      ipv6 = mdns_address_create_ipv6(v19 + 64, *((unsigned __int16 *)v4 + 84), 0);
      if (ipv6)
      {
        v22 = ipv6;
        v23 = v4[40];
        if (v23 == 1)
        {
          v43 = mdns_dns_service_definition_create();
          if (v43)
          {
            v27 = v43;
            appended = mdns_dns_service_definition_add_domain(v43, v17);
            if (appended || (appended = mdns_dns_service_definition_append_server_address(v27, v22)) != 0)
            {
              v25 = 0;
LABEL_98:
              mdns_release(v27);
LABEL_99:
              if (v25)
                goto LABEL_100;
LABEL_61:
              if (v17)
                mdns_release(v17);
              if (v22)
                mdns_release(v22);
              return 0;
            }
            v28 = mrc_dns_service_registration_create(v27);
            v25 = 0;
            *((_QWORD *)v4 + 19) = v28;
            goto LABEL_77;
          }
          v61 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_61;
          *(_DWORD *)buf = 136446210;
          v65 = "dnssd_client_service_publish";
          v45 = "%{public}s: unable to allocate mdns_dns_service_definition object";
        }
        else
        {
          if (v23 != 2)
          {
            v44 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_61;
            *(_DWORD *)buf = 136446466;
            v65 = "dnssd_client_service_publish";
            v66 = 1024;
            *(_DWORD *)v67 = v23;
            v45 = "%{public}s: Unknown DNS service registration type: %d";
            v46 = v44;
            v47 = 18;
LABEL_51:
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, v45, buf, v47);
            goto LABEL_61;
          }
          v24 = mdns_dns_push_service_definition_create();
          if (v24)
          {
            v25 = v24;
            appended = mdns_dns_push_service_definition_add_domain(v24, v17);
            if (appended)
            {
LABEL_100:
              mdns_release(v25);
              goto LABEL_61;
            }
            mdns_dns_push_service_definition_append_server_address(v25, v22);
            push = mrc_dns_service_registration_create_push(v25);
            *((_QWORD *)v4 + 19) = push;
            if (!push)
            {
              v27 = 0;
              goto LABEL_74;
            }
            mrc_dns_service_registration_set_reports_connection_errors(push, 1);
            v27 = 0;
            v28 = *((_QWORD *)v4 + 19);
LABEL_77:
            if (v28)
            {
              mrc_dns_service_registration_set_queue(v28, &_dispatch_main_q);
              v50 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                v51 = *v4;
                *(_DWORD *)buf = 136447490;
                v65 = "dnssd_client_service_publish";
                v66 = 1024;
                *(_DWORD *)v67 = v51;
                *(_WORD *)&v67[4] = 2048;
                *(_QWORD *)&v67[6] = v4;
                *(_WORD *)&v67[14] = 2080;
                *(_QWORD *)&v67[16] = "client";
                *(_WORD *)&v67[24] = 2080;
                *(_QWORD *)&v67[26] = "dnssd-client.c";
                *(_WORD *)&v67[34] = 1024;
                *(_DWORD *)&v67[36] = 360;
                _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              }
              v52 = *v4;
              if (*v4)
              {
                v53 = v52 + 1;
                *v4 = v52 + 1;
                if (v52 + 1 >= 10001)
                {
                  v54 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 136447490;
                    v65 = "dnssd_client_service_publish";
                    v66 = 1024;
                    *(_DWORD *)v67 = v53;
                    *(_WORD *)&v67[4] = 2048;
                    *(_QWORD *)&v67[6] = v4;
                    *(_WORD *)&v67[14] = 2080;
                    *(_QWORD *)&v67[16] = "client";
                    *(_WORD *)&v67[24] = 2080;
                    *(_QWORD *)&v67[26] = "dnssd-client.c";
                    *(_WORD *)&v67[34] = 1024;
                    *(_DWORD *)&v67[36] = 360;
                    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  }
                  abort();
                }
              }
              else
              {
                ++dnssd_client_created;
                *v4 = 1;
              }
              v55 = *((_QWORD *)v4 + 19);
              v62[0] = _NSConcreteStackBlock;
              v62[1] = 3221225472;
              v62[2] = __dnssd_client_service_publish_block_invoke;
              v62[3] = &__block_descriptor_40_e11_v16__0i8i12l;
              v62[4] = v4;
              mrc_dns_service_registration_set_event_handler(v55, v62);
              v56 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                presentation = mdns_domain_name_get_presentation(v17);
                v58 = *v20;
                if ((v58 & 0xFE) == 0xFC)
                {
                  v59 = "ULA: ";
                }
                else if (v58 == 254 && (*(_BYTE *)(v19 + 65) & 0xC0) == 0x80)
                {
                  v59 = "LUA: ";
                }
                else if ((v58 & 0xE0) == 0x20)
                {
                  v59 = "GUA: ";
                }
                else
                {
                  v59 = (const char *)&unk_10007C3B5;
                }
                *(_DWORD *)buf = 136449283;
                v65 = "dnssd_client_service_publish";
                v66 = 2160;
                *(_QWORD *)v67 = 1752392040;
                *(_WORD *)&v67[8] = 2081;
                *(_QWORD *)&v67[10] = presentation;
                *(_WORD *)&v67[18] = 2082;
                *(_QWORD *)&v67[20] = v59;
                *(_WORD *)&v67[28] = 2160;
                *(_QWORD *)&v67[30] = 1752392040;
                *(_WORD *)&v67[38] = 1041;
                *(_DWORD *)&v67[40] = 6;
                *(_WORD *)&v67[44] = 2097;
                *(_QWORD *)&v67[46] = v19 + 64;
                *(_WORD *)&v67[54] = 2160;
                *(_QWORD *)&v67[56] = 1752392040;
                *(_WORD *)&v67[64] = 1042;
                *(_DWORD *)&v67[66] = 2;
                v68 = 2098;
                *(_QWORD *)v69 = v19 + 70;
                *(_WORD *)&v69[8] = 2160;
                *(_QWORD *)&v69[10] = 1752392040;
                v70 = 1041;
                v71 = 8;
                v72 = 2097;
                v73 = v19 + 72;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: Publishing dnssd client service -- domain: %{private, mask.hash}s, address: {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x78u);
              }
              mrc_dns_service_registration_activate(*((_QWORD *)v4 + 19));
              goto LABEL_97;
            }
LABEL_74:
            v49 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v65 = "dnssd_client_service_publish";
              _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%{public}s: failed to create DNS service registration", buf, 0xCu);
            }
LABEL_97:
            if (!v27)
              goto LABEL_99;
            goto LABEL_98;
          }
          v61 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_61;
          *(_DWORD *)buf = 136446210;
          v65 = "dnssd_client_service_publish";
          v45 = "%{public}s: unable to allocate mdns_dns_push_service_definition object";
        }
        v46 = v61;
        v47 = 12;
        goto LABEL_51;
      }
      v37 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v38 = *v20;
        if ((v38 & 0xFE) == 0xFC)
        {
          v39 = "ULA: ";
        }
        else if (v38 == 254 && (*(_BYTE *)(v19 + 65) & 0xC0) == 0x80)
        {
          v39 = "LUA: ";
        }
        else if ((v38 & 0xE0) == 0x20)
        {
          v39 = "GUA: ";
        }
        else
        {
          v39 = (const char *)&unk_10007C3B5;
        }
        *(_DWORD *)buf = 136448771;
        v65 = "dnssd_client_service_publish";
        v66 = 2082;
        *(_QWORD *)v67 = v39;
        *(_WORD *)&v67[8] = 2160;
        *(_QWORD *)&v67[10] = 1752392040;
        *(_WORD *)&v67[18] = 1041;
        *(_DWORD *)&v67[20] = 6;
        *(_WORD *)&v67[24] = 2097;
        *(_QWORD *)&v67[26] = v19 + 64;
        *(_WORD *)&v67[34] = 2160;
        *(_QWORD *)&v67[36] = 1752392040;
        *(_WORD *)&v67[44] = 1042;
        *(_DWORD *)&v67[46] = 2;
        *(_WORD *)&v67[50] = 2098;
        *(_QWORD *)&v67[52] = v19 + 70;
        *(_WORD *)&v67[60] = 2160;
        *(_QWORD *)&v67[62] = 1752392040;
        v68 = 1041;
        *(_DWORD *)v69 = 8;
        *(_WORD *)&v69[4] = 2097;
        *(_QWORD *)&v69[6] = v19 + 72;
        v30 = "%{public}s: failed to create address object -- address: {%{public}s%{private, mask.hash, srp:in6_addr_segm"
              "ent}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
        v31 = v37;
        v32 = 100;
        goto LABEL_59;
      }
    }
    else
    {
      v29 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v65 = "dnssd_client_service_publish";
        v30 = "%{public}s: failed to get service address";
        v31 = v29;
        v32 = 12;
LABEL_59:
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, v30, buf, v32);
      }
    }
LABEL_60:
    v22 = 0;
    goto LABEL_61;
  }
  if (v6)
  {
    v7 = *((_QWORD *)v4 + 5);
    v8 = *((_QWORD *)v4 + 1);
    v9 = *(_QWORD *)(a2 + 8);
    v10 = *((_QWORD *)v4 + 3);
    *(_DWORD *)buf = 136447491;
    v65 = "dnssd_client_action_client";
    v66 = 2082;
    *(_QWORD *)v67 = v7;
    *(_WORD *)&v67[8] = 2160;
    *(_QWORD *)&v67[10] = 1752392040;
    *(_WORD *)&v67[18] = 2081;
    *(_QWORD *)&v67[20] = v8;
    *(_WORD *)&v67[28] = 2082;
    *(_QWORD *)&v67[30] = v9;
    *(_WORD *)&v67[38] = 2082;
    *(_QWORD *)&v67[40] = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
  }
  if (*(_DWORD *)(a2 + 16) == 20)
  {
    v11 = *((_QWORD *)v4 + 17);
    if (v11)
    {
      *(_BYTE *)(v11 + 27) = 1;
      *(_BYTE *)(v11 + 49) = 0;
      thread_service_release_((int *)v11, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 574);
      *((_QWORD *)v4 + 17) = 0;
      return 3;
    }
    v33 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v65 = "dnssd_client_action_client";
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: bad service event received with no published service.", buf, 0xCu);
    }
  }
  if (!*((_QWORD *)v4 + 17) || !dnssd_client_should_be_client(*((_QWORD *)v4 + 10)))
    return 2;
  v34 = *(_QWORD *)(*((_QWORD *)v4 + 10) + 40);
  v35 = *((_QWORD *)v4 + 17);
  if (!v34 || v35 == 0)
    return 2;
  v40 = *(_QWORD *)(v34 + 48);
  if (v40)
  {
    while (1)
    {
      if (!*(_BYTE *)(v40 + 27))
      {
        if (*(_BYTE *)(v40 + 49))
        {
          v41 = *(_DWORD *)(v35 + 20);
          if (v41 == *(_DWORD *)(v40 + 20))
            break;
        }
      }
      v40 = *(_QWORD *)(v40 + 8);
      if (!v40)
        goto LABEL_41;
    }
    if (v41 == 3)
    {
      if (*(unsigned __int8 *)(v40 + 80) != *(unsigned __int8 *)(v35 + 80))
      {
LABEL_70:
        v48 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          v65 = "service_tracker_verified_service_still_exists";
          v66 = 1024;
          *(_DWORD *)v67 = v41;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_FAULT, "%{public}s: old_service type is bogus: %d", buf, 0x12u);
        }
        LODWORD(v40) = 0;
        v42 = 1;
        goto LABEL_42;
      }
    }
    else if (v41 != 2 || v40 != v35)
    {
      goto LABEL_70;
    }
    v42 = 1;
    LODWORD(v40) = 1;
  }
  else
  {
LABEL_41:
    v42 = 0;
  }
LABEL_42:
  if ((v42 & v40) != 0)
    return 0;
  else
    return 2;
}

uint64_t dnssd_client_service_unpublish(uint64_t *a1)
{
  if (a1[19])
    thread_service_note(a1[9], a1[17], (uint64_t)"unpublishing service");
  return dnssd_client_remove_published_service((uint64_t)a1);
}

void __dnssd_client_service_publish_block_invoke(uint64_t a1, int a2, int a3)
{
  int *v4;
  uint64_t v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  uint32_t v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  int v13;
  int *v14;
  int *v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  void (*v19)(int *);
  NSObject *v20;
  int v21;
  NSObject *v22;
  NSObject *v23;
  uint64_t v24;
  const char *v25;
  NSObject *v26;
  int v27;
  const char *v28;
  __int16 v29;
  _BYTE v30[34];
  __int16 v31;
  int v32;

  v4 = *(int **)(a1 + 32);
  switch(a2)
  {
    case -1:
      v5 = global_os_log;
      if (a3)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_16;
        v27 = 136446466;
        v28 = "dnssd_client_dns_service_event_handler";
        v29 = 1024;
        *(_DWORD *)v30 = a3;
        v6 = "%{public}s: DNS service registration invalidated with error: %d";
        v7 = v5;
        v8 = OS_LOG_TYPE_ERROR;
        v9 = 18;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_16;
        v27 = 136446210;
        v28 = "dnssd_client_dns_service_event_handler";
        v6 = "%{public}s: DNS service registration gracefully invalidated";
        v7 = v5;
        v8 = OS_LOG_TYPE_DEFAULT;
        v9 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v7, v8, v6, (uint8_t *)&v27, v9);
LABEL_16:
      v13 = 15;
LABEL_17:
      v14 = state_machine_event_create(v13);
      if (v14)
      {
        v15 = v14;
        state_machine_event_deliver((uint64_t)(v4 + 2), (uint64_t)v14);
        v16 = *v15;
        if (!*v15)
        {
          v24 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_50;
          v27 = 136447490;
          v28 = "dnssd_client_dns_service_event_handler";
          v29 = 1024;
          *(_DWORD *)v30 = 0;
          *(_WORD *)&v30[4] = 2048;
          *(_QWORD *)&v30[6] = v15;
          *(_WORD *)&v30[14] = 2080;
          *(_QWORD *)&v30[16] = "event";
          *(_WORD *)&v30[24] = 2080;
          *(_QWORD *)&v30[26] = "dnssd-client.c";
          v31 = 1024;
          v32 = 287;
          v25 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          v26 = v24;
          goto LABEL_49;
        }
        v17 = global_os_log;
        if (v16 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_50;
          v27 = 136447490;
          v28 = "dnssd_client_dns_service_event_handler";
          v29 = 1024;
          *(_DWORD *)v30 = v16;
          *(_WORD *)&v30[4] = 2048;
          *(_QWORD *)&v30[6] = v15;
          *(_WORD *)&v30[14] = 2080;
          *(_QWORD *)&v30[16] = "event";
          *(_WORD *)&v30[24] = 2080;
          *(_QWORD *)&v30[26] = "dnssd-client.c";
          v31 = 1024;
          v32 = 287;
          v25 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v26 = v17;
          goto LABEL_49;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v27 = 136447490;
          v28 = "dnssd_client_dns_service_event_handler";
          v29 = 1024;
          *(_DWORD *)v30 = v16;
          *(_WORD *)&v30[4] = 2048;
          *(_QWORD *)&v30[6] = v15;
          *(_WORD *)&v30[14] = 2080;
          *(_QWORD *)&v30[16] = "event";
          *(_WORD *)&v30[24] = 2080;
          *(_QWORD *)&v30[26] = "dnssd-client.c";
          v31 = 1024;
          v32 = 287;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
          v16 = *v15;
        }
        *v15 = v16 - 1;
        if (v16 == 1)
        {
          v18 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v27 = 136447234;
            v28 = "dnssd_client_dns_service_event_handler";
            v29 = 2048;
            *(_QWORD *)v30 = v15;
            *(_WORD *)&v30[8] = 2080;
            *(_QWORD *)&v30[10] = "event";
            *(_WORD *)&v30[18] = 2080;
            *(_QWORD *)&v30[20] = "dnssd-client.c";
            *(_WORD *)&v30[28] = 1024;
            *(_DWORD *)&v30[30] = 287;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v27, 0x30u);
          }
          ++state_machine_event_finalized;
          v19 = (void (*)(int *))*((_QWORD *)v15 + 4);
          if (v19)
            v19(v15);
          free(v15);
        }
      }
      else
      {
        v20 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v27 = 136446210;
          v28 = "dnssd_client_dns_service_event_handler";
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v27, 0xCu);
        }
      }
      if (!v4)
        return;
      v21 = *v4;
      if (!*v4)
      {
        v22 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_50;
        v27 = 136447490;
        v28 = "dnssd_client_dns_service_event_handler";
        v29 = 1024;
        *(_DWORD *)v30 = 0;
        *(_WORD *)&v30[4] = 2048;
        *(_QWORD *)&v30[6] = v4;
        *(_WORD *)&v30[14] = 2080;
        *(_QWORD *)&v30[16] = "client";
        *(_WORD *)&v30[24] = 2080;
        *(_QWORD *)&v30[26] = "dnssd-client.c";
        v31 = 1024;
        v32 = 290;
        v25 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_48:
        v26 = v22;
LABEL_49:
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v25, (uint8_t *)&v27, 0x36u);
LABEL_50:
        abort();
      }
      v22 = global_os_log;
      if (v21 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_50;
        v27 = 136447490;
        v28 = "dnssd_client_dns_service_event_handler";
        v29 = 1024;
        *(_DWORD *)v30 = v21;
        *(_WORD *)&v30[4] = 2048;
        *(_QWORD *)&v30[6] = v4;
        *(_WORD *)&v30[14] = 2080;
        *(_QWORD *)&v30[16] = "client";
        *(_WORD *)&v30[24] = 2080;
        *(_QWORD *)&v30[26] = "dnssd-client.c";
        v31 = 1024;
        v32 = 290;
        v25 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_48;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v27 = 136447490;
        v28 = "dnssd_client_dns_service_event_handler";
        v29 = 1024;
        *(_DWORD *)v30 = v21;
        *(_WORD *)&v30[4] = 2048;
        *(_QWORD *)&v30[6] = v4;
        *(_WORD *)&v30[14] = 2080;
        *(_QWORD *)&v30[16] = "client";
        *(_WORD *)&v30[24] = 2080;
        *(_QWORD *)&v30[26] = "dnssd-client.c";
        v31 = 1024;
        v32 = 290;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
        v21 = *v4;
      }
      *v4 = v21 - 1;
      if (v21 == 1)
      {
        v23 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v27 = 136447234;
          v28 = "dnssd_client_dns_service_event_handler";
          v29 = 2048;
          *(_QWORD *)v30 = v4;
          *(_WORD *)&v30[8] = 2080;
          *(_QWORD *)&v30[10] = "client";
          *(_WORD *)&v30[18] = 2080;
          *(_QWORD *)&v30[20] = "dnssd-client.c";
          *(_WORD *)&v30[28] = 1024;
          *(_DWORD *)&v30[30] = 290;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v27, 0x30u);
        }
        ++dnssd_client_finalized;
        dnssd_client_finalize((uint64_t)v4);
      }
      return;
    case 1:
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v27 = 136446210;
      v28 = "dnssd_client_dns_service_event_handler";
      v11 = "%{public}s: DNS service registration started";
      goto LABEL_9;
    case 2:
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v27 = 136446210;
      v28 = "dnssd_client_dns_service_event_handler";
      v11 = "%{public}s: DNS service registration interrupted";
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v27, 0xCu);
      return;
    case 3:
      v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v27 = 136446466;
        v28 = "dnssd_client_dns_service_event_handler";
        v29 = 1024;
        *(_DWORD *)v30 = a3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: Registered DNS Push connection failed on server with error: %d", (uint8_t *)&v27, 0x12u);
      }
      v13 = 20;
      goto LABEL_17;
    default:
      return;
  }
}

uint64_t dnssd_client_should_be_client(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  _BOOL4 v5;
  NSObject *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  int v11;
  const char *v12;
  __int16 v13;
  const char *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  const char *v18;

  v1 = *(_QWORD *)(a1 + 48);
  if (v1 && (v2 = *(_DWORD *)(v1 + 56), v2 <= 5))
    v3 = (0x36u >> v2) & 1;
  else
    v3 = 0;
  v4 = *(_QWORD *)(a1 + 56);
  if (v4)
    v5 = *(unsigned __int8 *)(v4 + 72) != 0;
  else
    v5 = 0;
  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = "can't be client";
    if ((v5 & (v3 ^ 1)) != 0)
      v7 = "could be client";
    v8 = " won't publish";
    if (!v3)
      v8 = " might publish";
    v11 = 136446978;
    v12 = "dnssd_client_should_be_client";
    v14 = v7;
    v13 = 2082;
    v15 = 2082;
    v16 = v8;
    if (v5)
      v9 = (const char *)&unk_10007C3B5;
    else
      v9 = " not associated ";
    v17 = 2082;
    v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s%{public}s%{public}s", (uint8_t *)&v11, 0x2Au);
  }
  return v5 & (v3 ^ 1);
}

void dnssd_client_wait_expired(uint64_t a1)
{
  int *v2;
  int *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  void (*v7)(int *);
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = state_machine_event_create(1);
  if (v2)
  {
    v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    v4 = *v3;
    if (*v3)
    {
      v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136447490;
          v11 = "dnssd_client_wait_expired";
          v12 = 1024;
          *(_DWORD *)v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(_QWORD *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(_QWORD *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(_QWORD *)&v13[26] = "dnssd-client.c";
          v14 = 1024;
          v15 = 155;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          v4 = *v3;
        }
        *v3 = v4 - 1;
        if (v4 == 1)
        {
          v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136447234;
            v11 = "dnssd_client_wait_expired";
            v12 = 2048;
            *(_QWORD *)v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(_QWORD *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(_QWORD *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 155;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          v7 = (void (*)(int *))*((_QWORD *)v3 + 4);
          if (v7)
            v7(v3);
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_20:
        abort();
      v10 = 136447490;
      v11 = "dnssd_client_wait_expired";
      v12 = 1024;
      *(_DWORD *)v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 155;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_20;
      v10 = 136447490;
      v11 = "dnssd_client_wait_expired";
      v12 = 1024;
      *(_DWORD *)v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 155;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v10 = 136446210;
    v11 = "dnssd_client_wait_expired";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

void dnssd_client_probe_callback(uint64_t a1, uint64_t a2)
{
  int *v3;
  int *v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  void (*v8)(int *);
  NSObject *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  v3 = state_machine_event_create(11);
  if (v3)
  {
    v4 = v3;
    state_machine_event_deliver(a2 + 8, (uint64_t)v3);
    v5 = *v4;
    if (*v4)
    {
      v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v11 = 136447490;
          v12 = "dnssd_client_probe_callback";
          v13 = 1024;
          *(_DWORD *)v14 = v5;
          *(_WORD *)&v14[4] = 2048;
          *(_QWORD *)&v14[6] = v4;
          *(_WORD *)&v14[14] = 2080;
          *(_QWORD *)&v14[16] = "event";
          *(_WORD *)&v14[24] = 2080;
          *(_QWORD *)&v14[26] = "dnssd-client.c";
          v15 = 1024;
          v16 = 182;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
          v5 = *v4;
        }
        *v4 = v5 - 1;
        if (v5 == 1)
        {
          v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v11 = 136447234;
            v12 = "dnssd_client_probe_callback";
            v13 = 2048;
            *(_QWORD *)v14 = v4;
            *(_WORD *)&v14[8] = 2080;
            *(_QWORD *)&v14[10] = "event";
            *(_WORD *)&v14[18] = 2080;
            *(_QWORD *)&v14[20] = "dnssd-client.c";
            *(_WORD *)&v14[28] = 1024;
            *(_DWORD *)&v14[30] = 182;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
          }
          ++state_machine_event_finalized;
          v8 = (void (*)(int *))*((_QWORD *)v4 + 4);
          if (v8)
            v8(v4);
          free(v4);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_20:
        abort();
      v11 = 136447490;
      v12 = "dnssd_client_probe_callback";
      v13 = 1024;
      *(_DWORD *)v14 = v5;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(_QWORD *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(_QWORD *)&v14[26] = "dnssd-client.c";
      v15 = 1024;
      v16 = 182;
      v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_20;
      v11 = 136447490;
      v12 = "dnssd_client_probe_callback";
      v13 = 1024;
      *(_DWORD *)v14 = 0;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(_QWORD *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(_QWORD *)&v14[26] = "dnssd-client.c";
      v15 = 1024;
      v16 = 182;
      v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
    goto LABEL_20;
  }
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v11 = 136446210;
    v12 = "dnssd_client_probe_callback";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v11, 0xCu);
  }
}

void dnssd_client_active_data_set_changed_callback(uint64_t a1, int a2)
{
  NSObject *v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  xpc_object_t v8;
  int v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  const char *v14;
  int tunnel_name;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint8_t buf[4];
  const char *v22;
  __int16 v23;
  _BYTE v24[34];
  __int16 v25;
  int v26;

  if (a2)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: error %d", buf, 0x12u);
    }
    if (!a1)
      goto LABEL_13;
    v5 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v22 = "dnssd_client_active_data_set_changed_callback";
          v23 = 1024;
          *(_DWORD *)v24 = v5;
          *(_WORD *)&v24[4] = 2048;
          *(_QWORD *)&v24[6] = a1;
          *(_WORD *)&v24[14] = 2080;
          *(_QWORD *)&v24[16] = "client";
          *(_WORD *)&v24[24] = 2080;
          *(_QWORD *)&v24[26] = "dnssd-client.c";
          v25 = 1024;
          v26 = 690;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v5 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v5 - 1;
        if (v5 == 1)
        {
          v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v22 = "dnssd_client_active_data_set_changed_callback";
            v23 = 2048;
            *(_QWORD *)v24 = a1;
            *(_WORD *)&v24[8] = 2080;
            *(_QWORD *)&v24[10] = "client";
            *(_WORD *)&v24[18] = 2080;
            *(_QWORD *)&v24[20] = "dnssd-client.c";
            *(_WORD *)&v24[28] = 1024;
            *(_DWORD *)&v24[30] = 690;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++dnssd_client_finalized;
          dnssd_client_finalize(a1);
        }
LABEL_13:
        cti_events_discontinue(*(_QWORD *)(a1 + 96));
        *(_QWORD *)(a1 + 96) = 0;
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_40:
        abort();
      *(_DWORD *)buf = 136447490;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = v5;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "dnssd-client.c";
      v25 = 1024;
      v26 = 690;
      v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_40;
      *(_DWORD *)buf = 136447490;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = 0;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "dnssd-client.c";
      v25 = 1024;
      v26 = 690;
      v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v14, buf, 0x36u);
    goto LABEL_40;
  }
  v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "PropGet");
  xpc_dictionary_set_string(v8, "property_name", "IPv6:MeshLocalPrefix");
  v9 = setup_for_command(0, (uint64_t)"get_mesh_local_prefix", 0, (uint64_t)"IPv6:MeshLocalPrefix", v8, a1, (uint64_t)dnssd_client_get_mesh_local_prefix_callback, (uint64_t)cti_internal_string_property_reply, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 696);
  xpc_release(v8);
  v10 = global_os_log;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: cti_get_mesh_local_prefix failed with status %d", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = v11;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "dnssd-client.c";
      v25 = 1024;
      v26 = 700;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v12 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v13 = v12 + 1;
      *(_DWORD *)a1 = v12 + 1;
      if (v12 + 1 >= 10001)
      {
        v6 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_40;
        *(_DWORD *)buf = 136447490;
        v22 = "dnssd_client_active_data_set_changed_callback";
        v23 = 1024;
        *(_DWORD *)v24 = v13;
        *(_WORD *)&v24[4] = 2048;
        *(_QWORD *)&v24[6] = a1;
        *(_WORD *)&v24[14] = 2080;
        *(_QWORD *)&v24[16] = "client";
        *(_WORD *)&v24[24] = 2080;
        *(_QWORD *)&v24[26] = "dnssd-client.c";
        v25 = 1024;
        v26 = 700;
        v14 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_39;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)a1 = 1;
    }
  }
  tunnel_name = cti_get_tunnel_name_(a1, (uint64_t)dnssd_client_get_tunnel_name_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 702);
  v16 = global_os_log;
  if (tunnel_name)
  {
    v17 = tunnel_name;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s: cti_get_tunnel_name failed with status %d", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v18 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = v18;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "dnssd-client.c";
      v25 = 1024;
      v26 = 706;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v19 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      ++dnssd_client_created;
      *(_DWORD *)a1 = 1;
      return;
    }
    v20 = v19 + 1;
    *(_DWORD *)a1 = v19 + 1;
    if (v19 + 1 >= 10001)
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_40;
      *(_DWORD *)buf = 136447490;
      v22 = "dnssd_client_active_data_set_changed_callback";
      v23 = 1024;
      *(_DWORD *)v24 = v20;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "dnssd-client.c";
      v25 = 1024;
      v26 = 706;
      v14 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_39;
    }
  }
}

void dnssd_client_get_mesh_local_prefix_callback(uint64_t a1, char *a2, int a3)
{
  NSObject *v6;
  const char *v7;
  char *v8;
  int64_t v9;
  NSObject *v10;
  const char *v11;
  int *v12;
  int *v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  void (*v17)(int *);
  int v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  const char *v22;
  NSObject *v23;
  uint64_t v24;
  int v25;
  const char *v26;
  __int16 v27;
  _BYTE v28[34];
  __int16 v29;
  int v30;
  _BYTE v31[46];

  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = "<null>";
    v25 = 136446722;
    v26 = "dnssd_client_get_mesh_local_prefix_callback";
    if (a2)
      v7 = a2;
    v27 = 2082;
    *(_QWORD *)v28 = v7;
    *(_WORD *)&v28[8] = 1024;
    *(_DWORD *)&v28[10] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s %d", (uint8_t *)&v25, 0x1Cu);
  }
  if (!a2 || a3)
  {
LABEL_30:
    if (!a1)
      return;
    goto LABEL_31;
  }
  v8 = strchr(a2, 47);
  if (v8)
  {
    v9 = v8 - a2;
    if (v8 == a2)
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_30;
      v25 = 136446723;
      v26 = "dnssd_client_get_mesh_local_prefix_callback";
      v27 = 2160;
      *(_QWORD *)v28 = 1752392040;
      *(_WORD *)&v28[8] = 2081;
      *(_QWORD *)&v28[10] = a2;
      v11 = "%{public}s: bogus prefix: %{private, mask.hash}s";
      goto LABEL_29;
    }
    if ((unint64_t)(v9 - 48) <= 0xFFFFFFFFFFFFFFD0)
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_30;
      v25 = 136446723;
      v26 = "dnssd_client_get_mesh_local_prefix_callback";
      v27 = 2160;
      *(_QWORD *)v28 = 1752392040;
      *(_WORD *)&v28[8] = 2081;
      *(_QWORD *)&v28[10] = a2;
      v11 = "%{public}s: prefix too long: %{private, mask.hash}s";
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v25, 0x20u);
      goto LABEL_30;
    }
    __memcpy_chk(v31, a2, v9, 46);
    v31[v9] = 0;
    a2 = v31;
  }
  if (!inet_pton(30, a2, (void *)(a1 + 104)))
  {
    v10 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_30;
    v25 = 136446723;
    v26 = "dnssd_client_get_mesh_local_prefix_callback";
    v27 = 2160;
    *(_QWORD *)v28 = 1752392040;
    *(_WORD *)&v28[8] = 2081;
    *(_QWORD *)&v28[10] = a2;
    v11 = "%{public}s: prefix syntax incorrect: %{private, mask.hash}s";
    goto LABEL_29;
  }
  *(_BYTE *)(a1 + 120) = 1;
  v12 = state_machine_event_create(12);
  if (v12)
  {
    v13 = v12;
    state_machine_event_deliver(a1 + 8, (uint64_t)v12);
    v14 = *v13;
    if (!*v13)
    {
      v24 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v25 = 136447490;
        v26 = "dnssd_client_get_mesh_local_prefix_callback";
        v27 = 1024;
        *(_DWORD *)v28 = 0;
        *(_WORD *)&v28[4] = 2048;
        *(_QWORD *)&v28[6] = v13;
        *(_WORD *)&v28[14] = 2080;
        *(_QWORD *)&v28[16] = "event";
        *(_WORD *)&v28[24] = 2080;
        *(_QWORD *)&v28[26] = "dnssd-client.c";
        v29 = 1024;
        v30 = 225;
        v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        v23 = v24;
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    v15 = global_os_log;
    if (v14 >= 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v25 = 136447490;
        v26 = "dnssd_client_get_mesh_local_prefix_callback";
        v27 = 1024;
        *(_DWORD *)v28 = v14;
        *(_WORD *)&v28[4] = 2048;
        *(_QWORD *)&v28[6] = v13;
        *(_WORD *)&v28[14] = 2080;
        *(_QWORD *)&v28[16] = "event";
        *(_WORD *)&v28[24] = 2080;
        *(_QWORD *)&v28[26] = "dnssd-client.c";
        v29 = 1024;
        v30 = 225;
        v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v23 = v15;
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v25 = 136447490;
      v26 = "dnssd_client_get_mesh_local_prefix_callback";
      v27 = 1024;
      *(_DWORD *)v28 = v14;
      *(_WORD *)&v28[4] = 2048;
      *(_QWORD *)&v28[6] = v13;
      *(_WORD *)&v28[14] = 2080;
      *(_QWORD *)&v28[16] = "event";
      *(_WORD *)&v28[24] = 2080;
      *(_QWORD *)&v28[26] = "dnssd-client.c";
      v29 = 1024;
      v30 = 225;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v25, 0x36u);
      v14 = *v13;
    }
    *v13 = v14 - 1;
    if (v14 == 1)
    {
      v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v25 = 136447234;
        v26 = "dnssd_client_get_mesh_local_prefix_callback";
        v27 = 2048;
        *(_QWORD *)v28 = v13;
        *(_WORD *)&v28[8] = 2080;
        *(_QWORD *)&v28[10] = "event";
        *(_WORD *)&v28[18] = 2080;
        *(_QWORD *)&v28[20] = "dnssd-client.c";
        *(_WORD *)&v28[28] = 1024;
        *(_DWORD *)&v28[30] = 225;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v25, 0x30u);
      }
      ++state_machine_event_finalized;
      v17 = (void (*)(int *))*((_QWORD *)v13 + 4);
      if (v17)
        v17(v13);
      free(v13);
    }
LABEL_31:
    v18 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_48;
      v25 = 136447490;
      v26 = "dnssd_client_get_mesh_local_prefix_callback";
      v27 = 1024;
      *(_DWORD *)v28 = 0;
      *(_WORD *)&v28[4] = 2048;
      *(_QWORD *)&v28[6] = a1;
      *(_WORD *)&v28[14] = 2080;
      *(_QWORD *)&v28[16] = "client";
      *(_WORD *)&v28[24] = 2080;
      *(_QWORD *)&v28[26] = "dnssd-client.c";
      v29 = 1024;
      v30 = 227;
      v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_46;
    }
    v19 = global_os_log;
    if (v18 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v25 = 136447490;
        v26 = "dnssd_client_get_mesh_local_prefix_callback";
        v27 = 1024;
        *(_DWORD *)v28 = v18;
        *(_WORD *)&v28[4] = 2048;
        *(_QWORD *)&v28[6] = a1;
        *(_WORD *)&v28[14] = 2080;
        *(_QWORD *)&v28[16] = "client";
        *(_WORD *)&v28[24] = 2080;
        *(_QWORD *)&v28[26] = "dnssd-client.c";
        v29 = 1024;
        v30 = 227;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v25, 0x36u);
        v18 = *(_DWORD *)a1;
      }
      *(_DWORD *)a1 = v18 - 1;
      if (v18 == 1)
      {
        v20 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v25 = 136447234;
          v26 = "dnssd_client_get_mesh_local_prefix_callback";
          v27 = 2048;
          *(_QWORD *)v28 = a1;
          *(_WORD *)&v28[8] = 2080;
          *(_QWORD *)&v28[10] = "client";
          *(_WORD *)&v28[18] = 2080;
          *(_QWORD *)&v28[20] = "dnssd-client.c";
          *(_WORD *)&v28[28] = 1024;
          *(_DWORD *)&v28[30] = 227;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v25, 0x30u);
        }
        ++dnssd_client_finalized;
        dnssd_client_finalize(a1);
      }
      return;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      v25 = 136447490;
      v26 = "dnssd_client_get_mesh_local_prefix_callback";
      v27 = 1024;
      *(_DWORD *)v28 = v18;
      *(_WORD *)&v28[4] = 2048;
      *(_QWORD *)&v28[6] = a1;
      *(_WORD *)&v28[14] = 2080;
      *(_QWORD *)&v28[16] = "client";
      *(_WORD *)&v28[24] = 2080;
      *(_QWORD *)&v28[26] = "dnssd-client.c";
      v29 = 1024;
      v30 = 227;
      v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_46:
      v23 = v19;
LABEL_47:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, v22, (uint8_t *)&v25, 0x36u);
    }
LABEL_48:
    abort();
  }
  v21 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v25 = 136446210;
    v26 = "dnssd_client_get_mesh_local_prefix_callback";
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v25, 0xCu);
  }
}

void dnssd_client_get_tunnel_name_callback(int *a1, char *a2, int a3)
{
  NSObject *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  if (!a3)
  {
    a1[41] = if_nametoindex(a2);
    goto LABEL_7;
  }
  v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136446466;
    v11 = "dnssd_client_get_tunnel_name_callback";
    v12 = 1024;
    *(_DWORD *)v13 = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: didn't get tunnel name, error code %d", (uint8_t *)&v10, 0x12u);
  }
  if (a1)
  {
LABEL_7:
    v6 = *a1;
    if (*a1)
    {
      v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136447490;
          v11 = "dnssd_client_get_tunnel_name_callback";
          v12 = 1024;
          *(_DWORD *)v13 = v6;
          *(_WORD *)&v13[4] = 2048;
          *(_QWORD *)&v13[6] = a1;
          *(_WORD *)&v13[14] = 2080;
          *(_QWORD *)&v13[16] = "client";
          *(_WORD *)&v13[24] = 2080;
          *(_QWORD *)&v13[26] = "dnssd-client.c";
          v14 = 1024;
          v15 = 680;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          v6 = *a1;
        }
        *a1 = v6 - 1;
        if (v6 == 1)
        {
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136447234;
            v11 = "dnssd_client_get_tunnel_name_callback";
            v12 = 2048;
            *(_QWORD *)v13 = a1;
            *(_WORD *)&v13[8] = 2080;
            *(_QWORD *)&v13[10] = "client";
            *(_WORD *)&v13[18] = 2080;
            *(_QWORD *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 680;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++dnssd_client_finalized;
          dnssd_client_finalize((uint64_t)a1);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_21:
        abort();
      v10 = 136447490;
      v11 = "dnssd_client_get_tunnel_name_callback";
      v12 = 1024;
      *(_DWORD *)v13 = v6;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 680;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_21;
      v10 = 136447490;
      v11 = "dnssd_client_get_tunnel_name_callback";
      v12 = 1024;
      *(_DWORD *)v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "dnssd-client.c";
      v14 = 1024;
      v15 = 680;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_21;
  }
}

uint64_t put_tlv_uint32(char a1, unsigned int a2, unint64_t *a3, unint64_t a4)
{
  unint64_t v4;

  if (a3)
  {
    v4 = *a3;
    if (*a3)
    {
      if (a4 >= v4 && a4 - v4 >= 8)
      {
        *(_BYTE *)v4 = 0;
        *(_BYTE *)(v4 + 1) = a1;
        *(_WORD *)(v4 + 2) = 1024;
        *(_DWORD *)(v4 + 4) = bswap32(a2);
        v4 += 8;
      }
    }
    *a3 = v4;
  }
  return 8;
}

void handle_query_response(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, unint64_t a4)
{
  _BYTE *v8;
  int v9;
  unsigned __int16 *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  BOOL v15;
  unsigned __int16 *v17;
  unsigned int *v18;
  BOOL v19;
  unsigned int v20;
  int v21;
  unsigned __int16 *v22;
  int64_t v23;
  unsigned __int16 *v24;
  int64_t v25;
  unsigned __int16 *v26;
  unsigned int v27;
  void *v29;
  unsigned __int16 *v30;
  size_t v31;
  const char *v32;
  int64_t v33;
  const char *v34;
  unsigned int v35;
  void *v36;
  unsigned __int16 *v37;
  _BYTE v38[1009];
  _BYTE v39[16];

  if (a2[9] != -65570)
    goto LABEL_5;
  if (_should_return_noauth_error_s_once != -1)
    dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
  if (_should_return_noauth_error_s_should)
  {
LABEL_5:
    if (!a3)
    {
      v11 = 0;
      v12 = 0;
      v10 = 0;
      v13 = 0;
      v38[0] = 0;
      goto LABEL_21;
    }
    v8 = v38;
    do
    {
      if ((unint64_t)a3 >= a4 || v8 >= v39)
      {
        v11 = 0;
        v12 = 0;
        v10 = 0;
        v13 = 0;
        v8[-(v8 == v39)] = 0;
        goto LABEL_21;
      }
      v9 = *(unsigned __int8 *)a3;
      a3 = (unsigned __int16 *)((char *)a3 + 1);
      *v8++ = v9;
    }
    while (v9);
    v10 = 0;
    v11 = 0;
    if (a3)
    {
      v12 = 0;
      v13 = 0;
      if ((unint64_t)(a3 + 1) > a4)
        goto LABEL_21;
      v10 = 0;
      v11 = 0;
      v12 = bswap32(*a3) >> 16;
      if (a3 != (unsigned __int16 *)-2 && (unint64_t)(a3 + 2) <= a4)
      {
        v13 = 0;
        v10 = 0;
        v11 = bswap32(a3[1]) >> 16;
        if (a3 != (unsigned __int16 *)-4 && (unint64_t)(a3 + 3) <= a4)
        {
          v13 = bswap32(a3[2]) >> 16;
          v10 = a3 + 3;
        }
LABEL_21:
        v14 = (unsigned int *)((char *)v10 + v13);
        if (v10)
          v15 = (unint64_t)v14 > a4;
        else
          v15 = 1;
        if (v15)
        {
          v14 = 0;
          v17 = 0;
        }
        else
        {
          v17 = v10;
        }
        v18 = v14 + 1;
        if (v14)
          v19 = (unint64_t)v18 > a4;
        else
          v19 = 1;
        if (v19)
        {
          v18 = 0;
          v20 = 0;
        }
        else
        {
          v20 = bswap32(*v14);
        }
        *(_QWORD *)(a1 + 104) = 0;
        *(_QWORD *)(a1 + 112) = 0;
        v21 = a2[2];
        if ((v21 & 2) != 0)
        {
          v22 = (unsigned __int16 *)v18;
          while (1)
          {
            if ((uint64_t)(a4 - (_QWORD)v22) < 4)
            {
              v23 = 0;
              v26 = 0;
              goto LABEL_45;
            }
            v23 = 0;
            v24 = v22 + 2;
            if (v22 == (unsigned __int16 *)-4)
              break;
            v25 = __rev16(v22[1]);
            v26 = 0;
            if ((uint64_t)(a4 - (_QWORD)v24) < v25)
              goto LABEL_45;
            v27 = __rev16(*v22);
            v22 = (unsigned __int16 *)((char *)v24 + v25);
            if (v27 == 7)
            {
              v23 = v25;
              v26 = v24;
              goto LABEL_45;
            }
          }
          v26 = 0;
LABEL_45:
          *(_QWORD *)(a1 + 104) = v26;
          *(_QWORD *)(a1 + 112) = v23;
        }
        if (!&_ne_tracker_check_is_hostname_blocked)
          goto LABEL_71;
        if ((_DWORD)v12 != 28 && (_DWORD)v12 != 1)
          goto LABEL_71;
        if ((_DWORD)v11 != 1)
          goto LABEL_71;
        v29 = *(void **)(a1 + 120);
        if (!v29)
          goto LABEL_71;
        if ((v21 & 2) == 0)
          goto LABEL_69;
        v37 = v17;
        v30 = (unsigned __int16 *)v18;
        while (1)
        {
          if ((uint64_t)(a4 - (_QWORD)v30) < 4)
          {
            v31 = 0;
            v34 = 0;
            goto LABEL_63;
          }
          v31 = 0;
          v32 = (const char *)(v30 + 2);
          if (v30 == (unsigned __int16 *)-4)
            break;
          v33 = __rev16(v30[1]);
          v34 = 0;
          if ((uint64_t)(a4 - (_QWORD)v32) < v33)
            goto LABEL_63;
          v35 = __rev16(*v30);
          v30 = (unsigned __int16 *)&v32[v33];
          if (v35 == 9)
          {
            v31 = v33;
            v34 = v32;
            goto LABEL_63;
          }
        }
        v34 = 0;
LABEL_63:
        v36 = *(void **)(a1 + 120);
        if (strnlen(v34, v31) == v31 - 1)
        {
          v17 = v37;
          if (v34)
          {
            ne_tracker_create_xcode_issue(v34, v36, *(_QWORD *)(a1 + 128));
            v29 = *(void **)(a1 + 120);
            goto LABEL_68;
          }
        }
        else
        {
          v17 = v37;
        }
        v29 = v36;
LABEL_68:
        if (!v29)
        {
LABEL_70:
          *(_QWORD *)(a1 + 128) = 0;
LABEL_71:
          if (v18)
            (*(void (**)(uint64_t, _QWORD, _QWORD, _QWORD, _BYTE *, uint64_t, uint64_t, uint64_t, unsigned __int16 *, unsigned int, _QWORD))(a1 + 64))(a1, a2[7], a2[8], a2[9], v38, v12, v11, v13, v17, v20, *(_QWORD *)(a1 + 72));
          else
            syslog(4, "dnssd_clientstub handle_query_response: error reading result from daemon");
          return;
        }
LABEL_69:
        free(v29);
        *(_QWORD *)(a1 + 120) = 0;
        goto LABEL_70;
      }
    }
    else
    {
      v12 = 0;
    }
    v13 = 0;
    goto LABEL_21;
  }
}

uint64_t ConnectToServer(uint64_t *a1, __int16 a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  _DWORD *v12;
  _DWORD *v13;
  char *v14;
  const char *v15;
  int v16;
  int v17;
  const char *v18;
  uint64_t v19;
  _QWORD *v20;
  int v21;
  int v22;
  BOOL v23;
  _QWORD *v24;
  _QWORD *v25;
  int v26;
  uint64_t v27;
  int v29;
  int *v30;
  char *v31;
  uint64_t v32;
  int *v33;
  char *v34;
  int v35;
  int *v36;
  char *v37;
  size_t v38;
  int v39;
  int *v40;
  char *v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int *v46;
  char *v47;
  int v48;
  uint64_t v49;
  sockaddr v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  _WORD v55[13];

  v54 = 0u;
  memset(v55, 0, sizeof(v55));
  v52 = 0u;
  v53 = 0u;
  v50 = (sockaddr)0;
  v51 = 0u;
  if (a1)
  {
    if ((a2 & 0x4000) != 0)
    {
      v20 = (_QWORD *)*a1;
      if (!*a1)
      {
        v19 = 4294901756;
        syslog(4, "dnssd_clientstub kDNSServiceFlagsShareConnection used with NULL DNSServiceRef");
        return v19;
      }
      if ((v21 = *((_DWORD *)v20 + 4), v22 = *((_DWORD *)v20 + 8), v21 < 0)
        || (*((_DWORD *)v20 + 5) ^ v21) != 0x12345678
        || (v22 != 19 ? (v23 = v22 == 1) : (v23 = 1), !v23 || v20[1]))
      {
        syslog(4, "dnssd_clientstub kDNSServiceFlagsShareConnection used with invalid DNSServiceRef %p %08X %08X op %d", v20, v21, *((_DWORD *)v20 + 5), v22);
        *a1 = 0;
        return 4294901755;
      }
    }
    v12 = malloc_type_malloc(0x90uLL, 0xA172743EuLL);
    if (!v12)
      __break(1u);
    v13 = v12;
    *(_QWORD *)v12 = 0;
    *((_QWORD *)v12 + 1) = 0;
    v12[9] = 0;
    v12[10] = 0;
    v12[8] = a3;
    *((_OWORD *)v12 + 1) = xmmword_10007C740;
    *((_QWORD *)v12 + 6) = 0;
    *((_QWORD *)v12 + 7) = a4;
    *((_QWORD *)v12 + 8) = a5;
    *((_QWORD *)v12 + 9) = a6;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 6) = 0u;
    *((_OWORD *)v12 + 7) = 0u;
    *((_OWORD *)v12 + 8) = 0u;
    ++sdref_created;
    if ((a2 & 0x4000) != 0)
    {
      v24 = (_QWORD *)*a1;
      do
      {
        v25 = v24;
        v24 = (_QWORD *)*v24;
      }
      while (v24);
      *v25 = v12;
      v26 = *(_DWORD *)(*a1 + 24);
      *(_DWORD *)(*a1 + 24) = v26 + 1;
      if (v26 == -1)
        ++*(_DWORD *)(*a1 + 28);
      v27 = *a1;
      *((_QWORD *)v12 + 1) = *a1;
      *((_QWORD *)v12 + 2) = *(_QWORD *)(v27 + 16);
      *((_QWORD *)v12 + 3) = *(_QWORD *)(*a1 + 24);
LABEL_29:
      v19 = 0;
      *a1 = (uint64_t)v13;
      return v19;
    }
    v49 = 1;
    v14 = getenv("DNSSD_UDS_PATH");
    if (v14)
    {
      v15 = v14;
      if (strlen(v14) < 0x68)
        goto LABEL_9;
      syslog(4, "dnssd_clientstub ConnectToServer: using default path since env len is invalid");
    }
    v15 = "/var/run/mDNSResponder";
LABEL_9:
    *a1 = 0;
    v16 = socket(1, 1, 0);
    v13[4] = v16;
    v13[5] = v16 ^ 0x12345678;
    if (v16 < 0)
    {
      v29 = *__error();
      v30 = __error();
      v31 = strerror(*v30);
      syslog(4, "dnssd_clientstub ConnectToServer: socket failed %d %s", v29, v31);
      FreeDNSServiceOp(v13);
      return 4294901757;
    }
    v17 = fcntl(v16, 1);
    if (v17 == -1)
    {
      v18 = "dnssd_clientstub ConnectToServer: Failed to get the file descriptor flags of socket %d %s";
    }
    else
    {
      if (fcntl(v13[4], 2, v17 | 1u) != -1)
        goto LABEL_35;
      v18 = "dnssd_clientstub ConnectToServer: Failed to set FD_CLOEXEC on socket %d %s";
    }
    v32 = *__error();
    v33 = __error();
    v34 = strerror(*v33);
    syslog(4, v18, v32, v34);
LABEL_35:
    if (setsockopt(v13[4], 0xFFFF, 4130, &v49, 8u) < 0)
    {
      v35 = *__error();
      v36 = __error();
      v37 = strerror(*v36);
      syslog(4, "dnssd_clientstub ConnectToServer: SO_NOSIGPIPE failed %d %s", v35, v37);
    }
    v50.sa_family = 1;
    v38 = strlen(v15);
    if (v38 > 0x67)
      v50.sa_data[0] = 0;
    else
      __memcpy_chk(v50.sa_data, v15, v38 + 1, 104);
    v48 = 1;
    if (setsockopt(v13[4], 0xFFFF, 4352, &v48, 4u) < 0)
    {
      v39 = *__error();
      v40 = __error();
      v41 = strerror(*v40);
      syslog(4, "dnssd_clientstub ConnectToServer: SO_DEFUNCTOK failed %d %s", v39, v41);
    }
    v42 = connect(v13[4], &v50, 0x6Au);
    if (v42)
    {
      v43 = v42;
      v44 = v13[4];
      v45 = *__error();
      v46 = __error();
      v47 = strerror(*v46);
      syslog(4, "dnssd_clientstub ConnectToServer: connect() failed path:%s Socket:%d Err:%d Errno:%d %s", v15, v44, v43, v45, v47);
      close(v13[4]);
      FreeDNSServiceOp(v13);
      return 4294901733;
    }
    goto LABEL_29;
  }
  v19 = 4294901756;
  syslog(4, "dnssd_clientstub DNSService operation with NULL DNSServiceRef");
  return v19;
}

uint64_t put_attribute_tlvs(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  unint64_t v11;

  v8 = put_tlv_uint32(3, *(_DWORD *)a1, a3, a4);
  v9 = put_tlv_uint32(4, *(_DWORD *)(a1 + 16), a3, a4) + v8;
  v10 = *(_OWORD **)(a1 + 40);
  if (v10)
  {
    if (a3)
    {
      v11 = *a3;
      if (*a3 && a4 >= v11 && a4 - v11 >= 0x14)
      {
        *(_DWORD *)v11 = 268438016;
        *(_OWORD *)(v11 + 4) = *v10;
        v11 += 20;
      }
      *a3 = v11;
    }
    v9 += 20;
  }
  if (*(_BYTE *)(a1 + 13))
    v9 += put_tlv_uint32(5, *(_DWORD *)(a1 + 8), a3, a4);
  if (*(_BYTE *)(a1 + 12))
    v9 += put_tlv_uint32(11, *(_DWORD *)(a1 + 4), a3, a4);
  if (a2)
    *(_DWORD *)(a2 + 8) |= 2u;
  return v9;
}

_DWORD *create_hdr(int a1, size_t *a2, _QWORD *a3, int a4, uint64_t a5)
{
  uint64_t v6;
  _DWORD *v11;
  _DWORD *v12;
  size_t v13;
  _OWORD v15[4];

  memset(v15, 0, sizeof(v15));
  if (a4)
    v6 = *a2 + 1;
  else
    v6 = *a2;
  *a2 = v6 + 28;
  if (v6 == -28 || (v11 = malloc_type_malloc(v6 + 28, 0xA172743EuLL)) == 0)
    __break(1u);
  v12 = v11;
  bzero(v11, *a2);
  *v12 = 1;
  v12[1] = v6;
  v12[2] = 0;
  v12[3] = a1;
  *((_QWORD *)v12 + 2) = *(_QWORD *)(a5 + 24);
  v12[6] = 0;
  *a3 = v12 + 7;
  if (a4)
  {
    v13 = strlen((const char *)v15) + 1;
    memcpy(v12 + 7, v15, v13);
    *a3 += v13;
  }
  return v12;
}

uint64_t deliver_request(int8x16_t *a1, uint64_t a2)
{
  _BOOL4 v4;
  int v5;
  __int32 v6;
  int v7;
  int v8;
  int v9;
  int *v10;
  char *v11;
  uint64_t v13;
  int v14;
  int v15;
  BOOL v16;
  int all;
  unsigned int v18;
  int v19;
  int *v20;
  char *v21;
  int v22;
  int *v23;
  char *v24;
  _QWORD v25[2];
  unsigned int v26;
  timeval v27;
  fd_set v28;

  v26 = -65537;
  if (*(_QWORD *)(a2 + 8))
    v4 = 1;
  else
    v4 = ((a1->i32[3] - 2) & 0xFFFFFFF6) == 0;
  v5 = *(_DWORD *)(a2 + 16);
  if (v5 < 0 || (*(_DWORD *)(a2 + 20) ^ v5) != 0x12345678)
  {
    free(a1);
    syslog(4, "dnssd_clientstub deliver_request: invalid DNSServiceRef %p %08X %08X", (const void *)a2, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20));
    return 4294901755;
  }
  v6 = a1->i32[1];
  if (v4)
  {
    if (socketpair(1, 1, 0, v28.fds_bits) < 0)
    {
      v19 = *__error();
      v20 = __error();
      v21 = strerror(*v20);
      syslog(4, "dnssd_clientstub deliver_request: %s failed %d (%s)", "socketpair", v19, v21);
      goto LABEL_34;
    }
    v7 = v28.fds_bits[0];
    v8 = v28.fds_bits[1];
    LODWORD(v27.tv_sec) = 1;
    if (setsockopt(v28.fds_bits[0], 0xFFFF, 4352, &v27, 4u) < 0)
    {
      v9 = *__error();
      v10 = __error();
      v11 = strerror(*v10);
      syslog(4, "dnssd_clientstub deliver_request: SO_DEFUNCTOK failed %d %s", v9, v11);
    }
  }
  else
  {
    v8 = -1;
    v7 = -1;
  }
  v13 = (v6 - v4);
  *a1 = vrev32q_s8(*a1);
  a1[1].i32[2] = bswap32(a1[1].u32[2]);
  v14 = write_all(*(_DWORD *)(a2 + 16), a1->i8, v13 + 28);
  if (v14 < 0)
  {
    v15 = v14;
    syslog(6, "dnssd_clientstub deliver_request ERROR: write_all(%d, %lu bytes) failed", *(_DWORD *)(a2 + 16), v13 + 28);
    v16 = v15 == -2;
  }
  else
  {
    if (v4)
    {
      v25[0] = (char *)a1 + v13 + 28;
      v25[1] = 1;
      *(_OWORD *)v28.fds_bits = 0u;
      v28.fds_bits[7] = 0;
      v28.fds_bits[2] = 0;
      *(_QWORD *)&v28.fds_bits[4] = v25;
      v28.fds_bits[6] = 1;
      *(_QWORD *)&v28.fds_bits[8] = &v27;
      *(_QWORD *)&v28.fds_bits[10] = 16;
      v27.tv_sec = 0xFFFF00000010;
      v27.tv_usec = 1;
      *(&v27.tv_usec + 1) = v8;
      if (sendmsg(*(_DWORD *)(a2 + 16), (const msghdr *)&v28, 0) < 0)
      {
        v22 = *__error();
        v23 = __error();
        v24 = strerror(*v23);
        syslog(4, "dnssd_clientstub deliver_request ERROR: sendmsg failed read sd=%d write sd=%d errno %d (%s)", v7, v8, v22, v24);
        v26 = -65551;
        if (v8 < 0)
        {
LABEL_32:
          if ((v7 & 0x80000000) == 0)
            close(v7);
          goto LABEL_34;
        }
LABEL_31:
        close(v8);
        goto LABEL_32;
      }
      close(v8);
      v8 = -1;
    }
    else
    {
      v7 = *(_DWORD *)(a2 + 16);
    }
    if (v7 <= 1023)
    {
      *(_QWORD *)&v27.tv_usec = 0;
      memset(&v28, 0, sizeof(v28));
      if (__darwin_check_fd_set_overflow(v7, &v28, 0))
        *(__int32_t *)((char *)v28.fds_bits + (((unint64_t)v7 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v7;
      v27.tv_sec = 60;
      if (!select(v7 + 1, &v28, 0, 0, &v27))
      {
        syslog(4, "dnssd_clientstub set_waitlimit:_daemon timed out (%d secs) without any response: Socket %d", 60, v7);
        v18 = -65568;
        goto LABEL_29;
      }
    }
    v26 = 0;
    all = read_all(v7, (char *)&v26, 4uLL);
    if ((all & 0x80000000) == 0)
    {
      v18 = bswap32(v26);
      goto LABEL_29;
    }
    v16 = all == -3;
  }
  if (v16)
    v18 = -65569;
  else
    v18 = -65563;
LABEL_29:
  v26 = v18;
  if (v4)
  {
    if (v8 < 0)
      goto LABEL_32;
    goto LABEL_31;
  }
LABEL_34:
  free(a1);
  return v26;
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
  DNSServiceRef v1;
  int v2;
  _DWORD *v3;
  DNSServiceRef v4;
  _QWORD *v5;
  BOOL v6;
  int8x16_t *v7;
  NSObject *v8;
  _DNSServiceRef_t *v9;
  _DWORD *v10;
  size_t v11;
  uint64_t v12;

  if (sdRef)
  {
    v1 = sdRef;
    v2 = *((_DWORD *)sdRef + 4);
    if (v2 < 0 || (*((_DWORD *)sdRef + 5) ^ v2) != 0x12345678)
    {
      syslog(4, "dnssd_clientstub DNSServiceRefDeallocate called with invalid DNSServiceRef %p %08X %08X");
    }
    else
    {
      v3 = (_DWORD *)*((_QWORD *)sdRef + 6);
      if (v3)
        *v3 = 0;
      v4 = (DNSServiceRef)*((_QWORD *)sdRef + 1);
      if (v4)
      {
        do
        {
          v5 = v4;
          v4 = *(DNSServiceRef *)v4;
          if (v4)
            v6 = v4 == sdRef;
          else
            v6 = 1;
        }
        while (!v6);
        if (v4)
        {
          v11 = 0;
          v12 = 0;
          v7 = (int8x16_t *)create_hdr(63, &v11, &v12, 0, (uint64_t)sdRef);
          *v7 = vrev32q_s8(*v7);
          v7[1].i32[2] = bswap32(v7[1].u32[2]);
          write_all(*((_DWORD *)v1 + 4), v7->i8, v11);
          free(v7);
          *v5 = *(_QWORD *)v1;
          FreeDNSServiceOp(v1);
        }
      }
      else
      {
        if (*((_QWORD *)sdRef + 11))
        {
          *((_QWORD *)sdRef + 7) = 0;
          shutdown(*((_DWORD *)sdRef + 4), 1);
          dispatch_source_cancel(*((dispatch_source_t *)v1 + 11));
          v8 = *((_QWORD *)v1 + 11);
          if (v8)
          {
            dispatch_release(v8);
            *((_QWORD *)v1 + 11) = 0;
          }
        }
        else if (!*((_QWORD *)sdRef + 12))
        {
          close(*((_DWORD *)sdRef + 4));
        }
        do
        {
          v9 = *(_DNSServiceRef_t **)v1;
          v10 = (_DWORD *)*((_QWORD *)v1 + 6);
          if (v10)
            *v10 = 0;
          FreeDNSServiceOp(v1);
          v1 = v9;
        }
        while (v9);
      }
    }
  }
  else
  {
    syslog(4, "dnssd_clientstub DNSServiceRefDeallocate called with NULL DNSServiceRef");
  }
}

uint64_t write_all(int a1, char *a2, size_t a3)
{
  size_t v3;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  int v10;
  int *v11;
  char *v12;
  int *v13;
  socklen_t v14;
  int v15;

  if (!a3)
    return 0;
  v3 = a3;
  while (1)
  {
    v6 = send(a1, a2, v3, 0);
    v7 = v6;
    if ((v6 & 0x8000000000000000) != 0)
      break;
    v8 = v3 == v6;
    if (v3 < v6)
      break;
    a2 += v6;
    v3 -= v6;
    if (v8)
      return 0;
  }
  v15 = 0;
  v14 = 4;
  if (getsockopt(a1, 0xFFFF, 4353, &v15, &v14) < 0)
  {
    v10 = *__error();
    v11 = __error();
    v12 = strerror(*v11);
    syslog(4, "dnssd_clientstub write_all: SO_ISDEFUNCT failed %d %s", v10, v12);
  }
  if (v15)
  {
    syslog(6, "dnssd_clientstub write_all(%d) DEFUNCT");
  }
  else
  {
    if ((v7 & 0x8000000000000000) != 0)
    {
      __error();
      v13 = __error();
      strerror(*v13);
    }
    syslog(4, "dnssd_clientstub write_all(%d) failed %ld/%ld %d %s");
  }
  if (v15)
    return 4294967294;
  else
    return 0xFFFFFFFFLL;
}

void FreeDNSServiceOp(_DWORD *a1)
{
  int v2;
  NSObject *v3;
  void *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  void *v8;

  if ((_DWORD *)dns_service_op_not_to_be_freed == a1)
  {
    syslog(3, "dnssd_clientstub attempt to dispose protected DNSServiceRef %p", a1);
    abort();
  }
  v2 = a1[5];
  if ((v2 ^ a1[4]) == 0x12345678)
  {
    *(_QWORD *)a1 = 0;
    *((_QWORD *)a1 + 1) = 0;
    *((_QWORD *)a1 + 2) = 0xDDDDDDDDFFFFFFFFLL;
    *((_QWORD *)a1 + 4) = 0;
    a1[10] = 0;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    v3 = *((_QWORD *)a1 + 11);
    if (v3)
    {
      dispatch_release(v3);
      *((_QWORD *)a1 + 11) = 0;
    }
    *((_QWORD *)a1 + 12) = 0;
    v4 = (void *)*((_QWORD *)a1 + 15);
    if (v4)
    {
      free(v4);
      *((_QWORD *)a1 + 15) = 0;
    }
    *((_QWORD *)a1 + 16) = 0;
    v5 = (_QWORD *)*((_QWORD *)a1 + 10);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)*v5;
        ++rref_finalized;
        v7 = (void *)v5[7];
        if (v7)
          free(v7);
        free(v5);
        v5 = v6;
      }
      while (v6);
    }
    v8 = (void *)*((_QWORD *)a1 + 17);
    if (v8)
      free(v8);
    free(a1);
    ++sdref_finalized;
  }
  else
  {
    syslog(4, "dnssd_clientstub attempt to dispose invalid DNSServiceRef %p %08X %08X", a1, a1[4], v2);
    FreeDNSServiceOp_op_were_not_going_to_free_but_we_need_to_fool_the_analyzer = (uint64_t)a1;
  }
}

void ___should_return_noauth_error_block_invoke(id a1)
{
  _should_return_noauth_error_s_should = dyld_program_sdk_at_least(0x7E40901FFFFFFFFLL);
}

uint64_t read_all(int a1, char *a2, size_t a3)
{
  size_t v3;
  ssize_t v6;
  ssize_t v7;
  int v9;
  int *v10;
  char *v11;
  int *v12;
  socklen_t v13;
  int v14;

  if (!a3)
    return 0;
  v3 = a3;
  while (1)
  {
    while (1)
    {
      v6 = recv(a1, a2, v3, 0);
      v7 = v6;
      if (v6 < 0)
        break;
      if (v6 - 1 >= v3)
        goto LABEL_10;
      a2 += v6;
      v3 -= v6;
      if (!v3)
        return 0;
    }
    if (*__error() != 4)
      break;
    syslog(6, "dnssd_clientstub read_all: EINTR continue");
  }
LABEL_10:
  v13 = 4;
  v14 = 0;
  if (getsockopt(a1, 0xFFFF, 4353, &v14, &v13) < 0)
  {
    v9 = *__error();
    v10 = __error();
    v11 = strerror(*v10);
    syslog(4, "dnssd_clientstub read_all: SO_ISDEFUNCT failed %d %s", v9, v11);
  }
  if (v14)
  {
    syslog(6, "dnssd_clientstub read_all(%d) DEFUNCT");
  }
  else
  {
    if (v7 < 0)
    {
      __error();
      v12 = __error();
      strerror(*v12);
    }
    syslog(4, "dnssd_clientstub read_all(%d) failed %ld/%ld %d %s");
  }
  if (v7 < 0 && *__error() == 35)
    return 4294967294;
  if (v14)
    return 4294967293;
  return 0xFFFFFFFFLL;
}

void DNSServiceAttributeDeallocate(DNSServiceAttributeRef attr)
{
  void *v2;
  void *v3;

  ++saref_finalized;
  v2 = (void *)*((_QWORD *)attr + 4);
  if (v2)
  {
    free(v2);
    *((_QWORD *)attr + 4) = 0;
  }
  v3 = (void *)*((_QWORD *)attr + 5);
  if (v3)
    free(v3);
  free(attr);
}

void CallbackWithError(uint64_t *a1, uint64_t a2)
{
  uint64_t *v4;
  _QWORD *v5;
  int v6;
  _QWORD *v7;
  void (*v8)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD);
  void (*v9)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, uint64_t);
  void (*v10)(uint64_t *, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t);
  void (*v11)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t);
  void (*v12)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t);
  void (*v13)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t);
  void (*v14)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, uint64_t);
  uint64_t v15;
  int v16;

  while (1)
  {
    v4 = (uint64_t *)*a1;
    v16 = 1;
    a1[6] = (uint64_t)&v16;
    switch(*((_DWORD *)a1 + 8))
    {
      case 1:
      case 0x13:
        v5 = (_QWORD *)a1[10];
        v6 = 1;
        do
        {
          if (!v5)
            goto LABEL_23;
          v7 = (_QWORD *)*v5;
          v8 = (void (*)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD))v5[2];
          if (v8)
          {
            v8(a1, 0, 0, a2, v5[1]);
            v6 = v16;
          }
          v5 = v7;
        }
        while (v6);
        syslog(4, "dnssd_clientstub:Record: CallbackwithError morebytes zero");
        return;
      case 4:
        v9 = (void (*)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, uint64_t))a1[8];
        if (v9)
          v9(a1, 0, 0, a2, 0, a1[9]);
        break;
      case 5:
        v10 = (void (*)(uint64_t *, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))a1[8];
        if (v10)
          v10(a1, 0, a2, 0, 0, 0, a1[9]);
        break;
      case 6:
        v11 = (void (*)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))a1[8];
        if (v11)
          goto LABEL_22;
        break;
      case 7:
        v12 = (void (*)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t))a1[8];
        if (v12)
          v12(a1, 0, 0, a2, 0, 0, 0, 0, 0, a1[9]);
        break;
      case 8:
        v13 = (void (*)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t))a1[8];
        if (v13)
        {
          LODWORD(v15) = 0;
          v13(a1, 0, 0, a2, 0, 0, 0, 0, 0, v15, a1[9]);
        }
        break;
      case 0xE:
        v14 = (void (*)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _DWORD, uint64_t))a1[8];
        if (v14)
          v14(a1, 0, 0, a2, 0, 0, 0, 0, 0, a1[9]);
        break;
      case 0xF:
        v11 = (void (*)(uint64_t *, _QWORD, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, uint64_t))a1[8];
        if (v11)
LABEL_22:
          v11(a1, 0, 0, a2, 0, 0, 0, a1[9]);
        break;
      default:
        syslog(4, "dnssd_clientstub CallbackWithError called with bad op %d", *((_DWORD *)a1 + 8));
        break;
    }
LABEL_23:
    if (!v16)
      break;
    a1[6] = 0;
    a1 = v4;
    if (!v4)
      return;
  }
  syslog(4, "dnssd_clientstub:sdRef: CallbackwithError morebytes zero sdr %p");
}

void handle_regservice_response(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE *v13;
  int v14;
  unsigned __int8 *v15;
  _BYTE *v16;
  int v17;
  _BYTE v18[1009];
  _BYTE v19[1009];
  _BYTE v20[256];
  uint64_t v21;

  if (*(_DWORD *)(a2 + 36) != -65570)
    goto LABEL_5;
  if (_should_return_noauth_error_s_once != -1)
    dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
  if (_should_return_noauth_error_s_should)
  {
LABEL_5:
    if (a3)
    {
      v8 = 0;
      do
      {
        v9 = (uint64_t *)&v20[v8];
        if (a3 + v8 >= a4 || v9 >= &v21)
        {
          *((_BYTE *)v9 - (v9 == &v21)) = 0;
          goto LABEL_24;
        }
        v10 = *(unsigned __int8 *)(a3 + v8);
        v20[v8++] = v10;
      }
      while (v10);
      if (!(a3 + v8))
        goto LABEL_24;
      v11 = 0;
      v12 = a3 + v8;
      do
      {
        v13 = &v19[v11];
        if (v12 + v11 >= a4 || v13 >= v20)
        {
          v13[-(v13 == v20)] = 0;
          goto LABEL_25;
        }
        v14 = *(unsigned __int8 *)(a3 + v11 + v8);
        v19[v11++] = v14;
      }
      while (v14);
      v15 = (unsigned __int8 *)(v12 + v11);
      if (!(v12 + v11))
        goto LABEL_25;
      v16 = v18;
      do
      {
        if ((unint64_t)v15 >= a4 || v16 >= v19)
        {
          v16[-(v16 == v19)] = 0;
          goto LABEL_26;
        }
        v17 = *v15++;
        *v16++ = v17;
      }
      while (v17);
      if (!v15)
        goto LABEL_26;
      (*(void (**)(uint64_t, _QWORD, _QWORD, _BYTE *, _BYTE *, _BYTE *, _QWORD))(a1 + 64))(a1, *(unsigned int *)(a2 + 28), *(unsigned int *)(a2 + 36), v20, v19, v18, *(_QWORD *)(a1 + 72));
    }
    else
    {
      v20[0] = 0;
LABEL_24:
      v19[0] = 0;
LABEL_25:
      v18[0] = 0;
LABEL_26:
      syslog(4, "dnssd_clientstub handle_regservice_response: error reading result from daemon");
    }
  }
}

DNSServiceErrorType DNSServiceRegisterWithAttribute(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, const char *host, uint16_t portInNetworkByteOrder, uint16_t txtLen, const void *txtRecord, DNSServiceAttributeRef attr, DNSServiceRegisterReply callBack, void *context)
{
  DNSServiceErrorType v13;
  const char *v19;
  const char *v20;
  const char *v21;
  void *v22;
  void (*v23)(uint64_t, uint64_t, uint64_t, unint64_t);
  DNSServiceRegisterReply v24;
  size_t v26;
  size_t v27;
  size_t v28;
  int8x16_t *v29;
  char *v30;
  int8x16_t *v31;
  size_t v32;
  char *v33;
  size_t v34;
  char *v35;
  size_t v36;
  char *v37;
  size_t v38;
  char *v39;
  DNSServiceErrorType v40;
  size_t v41;
  size_t v42;
  void *__src;
  char *__s;
  char *v45;
  uint64_t v46;
  char *v47;

  v13 = -65540;
  if (sdRef && regtype)
  {
    if (name)
      v19 = name;
    else
      v19 = (const char *)&unk_10007C3B5;
    if (domain)
      v20 = domain;
    else
      v20 = (const char *)&unk_10007C3B5;
    if (host)
      v21 = host;
    else
      v21 = (const char *)&unk_10007C3B5;
    __s = (char *)v20;
    v45 = (char *)v21;
    if (txtRecord)
      v22 = (void *)txtRecord;
    else
      v22 = &unk_10007C3B5;
    if (callBack)
    {
      __src = v22;
      v23 = handle_regservice_response;
      v24 = callBack;
    }
    else
    {
      if ((flags & 8) != 0)
        return v13;
      __src = v22;
      v23 = 0;
      v24 = 0;
    }
    v13 = ConnectToServer((uint64_t *)sdRef, flags, 5, (uint64_t)v23, (uint64_t)v24, (uint64_t)context);
    if (!v13)
    {
      v42 = strlen(v19);
      v26 = strlen(regtype);
      v27 = strlen(__s);
      v28 = strlen(v45);
      v13 = -65540;
      if (*((_BYTE *)attr + 13))
      {
        if (!*((_BYTE *)attr + 12))
          return v13;
      }
      else if (*((_BYTE *)attr + 12))
      {
        return v13;
      }
      v46 = put_attribute_tlvs((uint64_t)attr, 0, 0, 0) + v42 + txtLen + v26 + v27 + v28 + 16;
      v47 = 0;
      v29 = (int8x16_t *)create_hdr(5, (size_t *)&v46, &v47, *((_QWORD *)*sdRef + 1) != 0, (uint64_t)*sdRef);
      if (!callBack)
        v29->i32[2] |= 1u;
      v30 = v47;
      v41 = v46;
      *v47 = HIBYTE(flags);
      v30[1] = BYTE2(flags);
      v30[2] = BYTE1(flags);
      v30[3] = flags;
      v30[4] = HIBYTE(interfaceIndex);
      v30[5] = BYTE2(interfaceIndex);
      v30[6] = BYTE1(interfaceIndex);
      v30[7] = interfaceIndex;
      v31 = v29;
      v32 = strlen(v19) + 1;
      memcpy(v30 + 8, v19, v32);
      v33 = &v30[v32 + 8];
      v34 = strlen(regtype) + 1;
      memcpy(v33, regtype, v34);
      v35 = &v33[v34];
      v36 = strlen(__s) + 1;
      memcpy(v35, __s, v36);
      v37 = &v35[v36];
      v38 = strlen(v45) + 1;
      memcpy(v37, v45, v38);
      v39 = &v37[v38];
      *(_WORD *)v39 = portInNetworkByteOrder;
      v39[2] = HIBYTE(txtLen);
      v39[3] = txtLen;
      memcpy(&v37[v38 + 4], __src, txtLen);
      v47 = &v37[v38 + 4 + txtLen];
      put_attribute_tlvs((uint64_t)attr, (uint64_t)v31, (unint64_t *)&v47, (unint64_t)&v30[v41]);
      v40 = deliver_request(v31, (uint64_t)*sdRef);
      v13 = v40;
      if (v40)
      {
        if (v40 != -65555)
          goto LABEL_32;
        if (_should_return_noauth_error_s_once != -1)
          dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
        if (!_should_return_noauth_error_s_should)
        {
          return 0;
        }
        else
        {
LABEL_32:
          DNSServiceRefDeallocate(*sdRef);
          *sdRef = 0;
        }
      }
    }
  }
  return v13;
}

void ConnectionResponse(uint64_t **a1, _DWORD *a2)
{
  int v4;
  uint64_t *v5;
  uint64_t *v6;
  void (*v7)(void);
  int v8;
  uint64_t **v10;
  uint64_t v11;
  void (*v12)(uint64_t **, uint64_t *, uint64_t, uint64_t, uint64_t);
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;

  v4 = a2[3];
  if (v4 == 69 || v4 == 73)
  {
    if (a2[9] != -65570)
      goto LABEL_7;
    if (_should_return_noauth_error_s_once != -1)
      dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
    if (_should_return_noauth_error_s_should)
    {
LABEL_7:
      v5 = a1[10];
      if (v5)
      {
        while (*((_DWORD *)v5 + 9) != a2[4] || *((_DWORD *)v5 + 10) != a2[5])
        {
          v5 = (uint64_t *)*v5;
          if (!v5)
            goto LABEL_11;
        }
        if ((uint64_t **)v5[6] == a1)
        {
          v8 = *((_DWORD *)a1 + 8);
          if (v8 == 19 || v8 == 1)
          {
            v14 = a2[7];
            v15 = a2[9];
            v11 = v5[1];
            v12 = (void (*)(uint64_t **, uint64_t *, uint64_t, uint64_t, uint64_t))v5[2];
            v10 = a1;
            v13 = v5;
          }
          else
          {
            syslog(4, "dnssd_clientstub ConnectionResponse: sdr->op != connection_request");
            v10 = (uint64_t **)v5[6];
            v11 = v5[1];
            v12 = (void (*)(uint64_t **, uint64_t *, uint64_t, uint64_t, uint64_t))v5[2];
            v13 = v5;
            v14 = 0;
            v15 = 4294901759;
          }
          v12(v10, v13, v14, v15, v11);
        }
        else
        {
          syslog(4, "dnssd_clientstub ConnectionResponse: Record sdr mismatch: rec %p sdr %p");
        }
      }
      else
      {
LABEL_11:
        syslog(6, "dnssd_clientstub ConnectionResponse: Record not found");
      }
    }
  }
  else
  {
    v6 = *a1;
    if (*a1)
    {
      while (*((_DWORD *)v6 + 6) != a2[4] || *((_DWORD *)v6 + 7) != a2[5])
      {
        v6 = (uint64_t *)*v6;
        if (!v6)
          return;
      }
      v7 = (void (*)(void))v6[7];
      if (v7)
        v7();
    }
  }
}

DNSServiceErrorType DNSServiceRegisterRecordWithAttribute(DNSServiceRef sdRef, DNSRecordRef *recordRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, uint16_t rdlen, const void *rdata, uint32_t ttl, DNSServiceAttributeRef attr, DNSServiceRegisterRecordReply callBack, void *context)
{
  const char *v14;
  const void *v15;
  unsigned int v16;
  BOOL v17;
  DNSServiceRef v18;
  int v19;
  uint64_t v20;
  __int16 v21;
  int v23;
  DNSServiceErrorType v24;
  size_t v25;
  int v27;
  int8x16_t *v28;
  _BYTE *v29;
  size_t v30;
  const char *v31;
  size_t v32;
  _BYTE *v33;
  _BYTE *v34;
  _QWORD *v35;
  __int32 v36;
  _QWORD *v37;
  _QWORD *v38;
  DNSServiceErrorType v39;
  size_t v40;
  int8x16_t *v41;
  uint64_t v42;
  _DWORD *v43;

  v43 = 0;
  if (!sdRef
    || !recordRef
    || (v14 = *(const char **)&interfaceIndex) == 0
    || ((v15 = (const void *)rrclass, v16 = rrtype, !rrclass) ? (v17 = rrtype == 0) : (v17 = 1), !v17 || !rdata))
  {
    v24 = -65540;
    syslog(4, "dnssd_clientstub DNSServiceRegisterRecord called with NULL parameter", *(_QWORD *)&flags, *(_QWORD *)&interfaceIndex, fullname, rrtype, rrclass, rdlen);
    return v24;
  }
  v18 = sdRef;
  v19 = *((_DWORD *)sdRef + 4);
  if (v19 < 0 || (*((_DWORD *)sdRef + 5) ^ v19) != 0x12345678)
  {
    syslog(4, "dnssd_clientstub DNSServiceRegisterRecord called with invalid DNSServiceRef %p %08X %08X", *(_QWORD *)&flags);
    return -65541;
  }
  v20 = rdlen;
  v21 = (__int16)fullname;
  v23 = *((_DWORD *)sdRef + 8);
  if (v23 != 1 && v23 != 19)
  {
    syslog(4, "dnssd_clientstub DNSServiceRegisterRecord called with non-DNSServiceCreateConnection DNSServiceRef %p %d", *(_QWORD *)&flags);
    return -65541;
  }
  v24 = -65540;
  *recordRef = 0;
  v25 = strlen(*(const char **)&interfaceIndex);
  if (*(_BYTE *)(v20 + 13))
  {
    if (!*(_BYTE *)(v20 + 12))
      return v24;
  }
  else if (*(_BYTE *)(v20 + 12))
  {
    return v24;
  }
  v42 = put_attribute_tlvs(v20, 0, 0, 0) + v25 + v16 + 19;
  v27 = *((_DWORD *)v18 + 6);
  *((_DWORD *)v18 + 6) = v27 + 1;
  if (v27 == -1)
    ++*((_DWORD *)v18 + 7);
  v28 = (int8x16_t *)create_hdr(2, (size_t *)&v42, &v43, 1, (uint64_t)v18);
  v29 = v43;
  v40 = v42;
  v41 = v28;
  *v43 = 0x80000;
  v29[4] = HIBYTE(flags);
  v29[5] = BYTE2(flags);
  v29[6] = BYTE1(flags);
  v29[7] = flags;
  v30 = strlen(v14);
  v31 = v14;
  v32 = v30 + 1;
  memcpy(v29 + 8, v31, v30 + 1);
  v33 = &v29[v32 + 8];
  *v33 = HIBYTE(v21);
  v33[1] = v21;
  *((_WORD *)v33 + 1) = 256;
  v33[4] = BYTE1(v16);
  v34 = v33 + 6;
  v33[5] = v16;
  memcpy(v33 + 6, v15, v16);
  *(_DWORD *)&v34[v16] = -1810825216;
  v43 = &v34[v16 + 4];
  put_attribute_tlvs(v20, (uint64_t)v41, (unint64_t *)&v43, (unint64_t)&v29[v40]);
  v35 = malloc_type_calloc(1uLL, 0x40uLL, 0xF1748037uLL);
  if (!v35)
  {
    __break(1u);
LABEL_34:
    dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
LABEL_30:
    if (_should_return_noauth_error_s_should)
      return (int)v18;
    else
      return 0;
  }
  ++rref_created;
  v35[1] = *(_QWORD *)&ttl;
  v35[2] = rdata;
  v36 = *((_DWORD *)v18 + 9);
  *((_DWORD *)v18 + 9) = v36 + 1;
  *((_DWORD *)v35 + 8) = v36;
  v35[6] = v18;
  *recordRef = (DNSRecordRef)v35;
  *(_QWORD *)((char *)v35 + 36) = *((_QWORD *)v18 + 3);
  v41[1].i32[2] = v36;
  v37 = (_QWORD *)((char *)v18 + 80);
  do
  {
    v38 = v37;
    v37 = (_QWORD *)*v37;
  }
  while (v37);
  *v38 = v35;
  v39 = deliver_request(v41, (uint64_t)v18);
  LODWORD(v18) = -65555;
  v24 = v39;
  if (v39 == -65555)
  {
    if (_should_return_noauth_error_s_once == -1)
      goto LABEL_30;
    goto LABEL_34;
  }
  return v24;
}

uint64_t DNSServiceUpdateRecordInternal(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4, uint64_t a5)
{
  uint64_t v10;
  int v12;
  int v13;
  int8x16_t *v14;
  int8x16_t *v15;
  int v16;
  _BYTE *v17;
  size_t v18;
  _DWORD *v19;
  uint64_t v20;

  v19 = 0;
  if (!a1 || a3 && !a4)
  {
    v10 = 4294901756;
    syslog(4, "dnssd_clientstub DNSServiceUpdateRecord called with NULL parameter");
    return v10;
  }
  v12 = *(_DWORD *)(a1 + 16);
  v13 = *(_DWORD *)(a1 + 20);
  if (v12 < 0 || (v13 ^ v12) != 0x12345678)
  {
    syslog(4, "dnssd_clientstub DNSServiceUpdateRecord called with invalid DNSServiceRef %p %08X %08X", (const void *)a1, *(_DWORD *)(a1 + 16), v13);
    return 4294901755;
  }
  v20 = a3 + 10;
  if (a5)
  {
    v10 = 4294901756;
    if (*(_BYTE *)(a5 + 13))
    {
      if (!*(_BYTE *)(a5 + 12))
        return v10;
    }
    else if (*(_BYTE *)(a5 + 12))
    {
      return v10;
    }
    v20 = put_attribute_tlvs(a5, 0, 0, 0) + a3 + 10;
  }
  v14 = (int8x16_t *)create_hdr(11, (size_t *)&v20, &v19, 1, a1);
  v15 = v14;
  if (!*(_QWORD *)(a1 + 8))
  {
    v14[1].i64[0] = 0;
    if (a2)
      goto LABEL_17;
LABEL_19:
    v16 = -1;
    goto LABEL_20;
  }
  if (!a2)
    goto LABEL_19;
LABEL_17:
  v16 = *(_DWORD *)(a2 + 32);
LABEL_20:
  v14[1].i32[2] = v16;
  v17 = v19;
  v18 = v20;
  *v19 = 0;
  v17[4] = BYTE1(a3);
  v17[5] = a3;
  memcpy(v17 + 6, a4, a3);
  *(_DWORD *)&v17[a3 + 6] = 0;
  v19 = &v17[a3 + 10];
  if (a5)
    put_attribute_tlvs(a5, (uint64_t)v15, (unint64_t *)&v19, (unint64_t)&v17[v18]);
  return deliver_request(v15, a1);
}

DNSServiceErrorType DNSServiceReconfirmRecord(DNSServiceErrorType flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, uint16_t rdlen, const void *rdata)
{
  const void *v7;
  unsigned int v8;
  __int16 v10;
  const char *v11;
  DNSServiceErrorType v12;
  int8x16_t *v13;
  _BYTE *v14;
  char *v15;
  size_t v16;
  char *v17;
  DNSServiceRef sdRef;
  size_t v19;
  _DWORD *v20;

  sdRef = 0;
  if (*(_QWORD *)&interfaceIndex)
  {
    v7 = (const void *)rdlen;
    v8 = rrclass;
    v10 = (__int16)fullname;
    v11 = *(const char **)&interfaceIndex;
    v12 = flags;
    if (!rrclass || rdlen)
    {
      v20 = 0;
      flags = ConnectToServer((uint64_t *)&sdRef, 0, 9, 0, 0, 0);
      if (!flags)
      {
        v19 = strlen(v11) + v8 + 15;
        v13 = (int8x16_t *)create_hdr(9, &v19, &v20, 0, (uint64_t)sdRef);
        v14 = v20;
        *v20 = 0;
        v14[4] = HIBYTE(v12);
        v14[5] = BYTE2(v12);
        v14[6] = BYTE1(v12);
        v15 = v14 + 8;
        v14[7] = v12;
        v16 = strlen(v11) + 1;
        memcpy(v15, v11, v16);
        v17 = &v15[v16];
        *v17 = HIBYTE(v10);
        v17[1] = v10;
        v17[2] = HIBYTE(rrtype);
        v17[3] = rrtype;
        v17[4] = BYTE1(v8);
        v17[5] = v8;
        memcpy(&v15[v16 + 6], v7, v8);
        deliver_request(v13, (uint64_t)sdRef);
        DNSServiceRefDeallocate(sdRef);
      }
    }
  }
  return flags;
}

uint64_t dso_simple_response(uint64_t a1, uint64_t a2, _WORD *a3, int a4)
{
  int v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  size_t v11;
  void **v12;
  char *v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  _WORD *v18;
  _QWORD *v20;
  unsigned int v21;
  void *v22[2];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  iovec v26;
  _WORD v27[705];
  _WORD v28[12];

  memset(&v27[2], 0, 508);
  v6 = ((unsigned __int16)a3[1] << 8) & 0x7800 | a4;
  v27[0] = *a3;
  v27[1] = bswap32(v6 | 0x8000) >> 16;
  if (a2)
    v7 = *(unsigned __int16 *)(a2 + 64) - 12;
  else
    v7 = 1398;
  v24 = 0uLL;
  v25 = 0uLL;
  *(_OWORD *)v22 = 0uLL;
  v23 = 0uLL;
  v21 = 0;
  if (a3[2] == 256 && dns_rr_parse_((uint64_t)v22, (uint64_t)(a3 + 6), v7, &v21, 0))
  {
    v8 = v22[0];
    if (v22[0])
    {
      v9 = 0;
      v10 = 1398;
      v11 = 12;
      v12 = (void **)v22[0];
      v13 = (char *)&v27[6];
      while (1)
      {
        v14 = *((unsigned __int8 *)v12 + 8);
        if (v10 <= v14)
          break;
        *v13 = v14;
        v15 = v13 + 1;
        memcpy(v15, (char *)v12 + 9, *((unsigned __int8 *)v12 + 8));
        v16 = *((unsigned __int8 *)v12 + 8);
        v13 = &v15[v16];
        v10 += ~v16;
        v17 = v9 + v16;
        v9 = v17 + 1;
        v12 = (void **)*v12;
        if (!v12)
        {
          if (v17 != -1)
          {
            v18 = (_WORD *)((char *)&v27[7] + v9);
            if (v18 < v28)
            {
              *(_WORD *)((char *)&v27[6] + v9) = bswap32(LOWORD(v22[1])) >> 16;
              if ((_WORD *)((char *)&v27[8] + v9) < v28)
              {
                *v18 = __rev16(WORD1(v22[1]));
                v27[2] = 256;
                v11 = (char *)&v27[8] + v9 - (char *)&v27[6] + 12;
                goto LABEL_17;
              }
            }
          }
          goto LABEL_16;
        }
      }
    }
    else
    {
LABEL_16:
      v11 = 12;
    }
    do
    {
LABEL_17:
      if (!v8)
        break;
      v20 = (_QWORD *)*v8;
      free(v8);
      v8 = v20;
    }
    while (v20);
  }
  else
  {
    v11 = 12;
  }
  v26.iov_base = v27;
  v26.iov_len = v11;
  return ioloop_send_message(a1, a2, &v26);
}

uint64_t dso_retry_delay_response(uint64_t a1, uint64_t a2, __int16 a3, unsigned int a4)
{
  iovec v5;
  _WORD v6[2];
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  int v39;

  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v24 = 0u;
  v39 = 0;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v11 = 0u;
  v10 = 0u;
  v9 = 0u;
  v7 = 0;
  v6[0] = a3;
  v6[1] = __rev16((((a4 >> 3) & 0xF) << 11) | 0x8002);
  v8 = 0xE093040004000200;
  v5.iov_base = v6;
  v5.iov_len = 20;
  return ioloop_send_message(a1, a2, &v5);
}

void probe_state_finalize(_QWORD *a1)
{
  _QWORD *v2;
  int *v3;
  uint64_t v4;
  void (*v5)(_QWORD);

  v2 = (_QWORD *)a1[2];
  if (v2)
    ioloop_wakeup_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 79);
  v3 = (int *)a1[3];
  if (v3)
  {
    thread_service_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 82);
    a1[3] = 0;
  }
  v4 = a1[1];
  if (v4)
  {
    ioloop_comm_release_(v4, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 86);
    a1[1] = 0;
  }
  v5 = (void (*)(_QWORD))a1[6];
  if (v5)
    v5(a1[4]);
  free(a1);
}

int *probe_srp_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int *v6;
  NSObject *v7;
  _BOOL4 v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  const char *v13;
  int v14;
  const void *v15;
  _DWORD *v16;
  uint64_t v17;
  NSObject *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  NSObject *v23;
  nw_endpoint_t host;
  NSObject *v25;
  NSObject *secure_udp;
  NSObject *v27;
  nw_protocol_stack_t v28;
  NSObject *v29;
  int v30;
  int v31;
  int v32;
  NSObject *v33;
  int v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  int v38;
  NSObject *v39;
  int v40;
  NSObject *v41;
  _BOOL4 v42;
  int v43;
  int v44;
  int v45;
  NSObject *v46;
  NSObject *v47;
  int v48;
  NSObject *v49;
  NSObject *v50;
  int v51;
  const char *v52;
  unsigned int v53;
  NSObject *v54;
  int *v55;
  int v56;
  int v57;
  int v58;
  NSObject *v60;
  _QWORD block[8];
  _BYTE buf[48];
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  int v66;
  __int16 v67;
  uint64_t v68;
  __int16 v69;
  uint64_t v70;
  __int16 v71;
  int v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  unsigned int v76;
  char hostname[46];
  char __str[10];

  v6 = (int *)malloc_type_calloc(1uLL, 0x5D0uLL, 0x10A00406E7D634FuLL);
  v7 = global_os_log;
  v8 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v6)
  {
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: failed to create probe state", buf, 0xCu);
    }
LABEL_80:
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = __probe_srp_create_block_invoke;
    block[3] = &__block_descriptor_tmp_8;
    block[4] = dnssd_client_probe_callback;
    block[5] = a2;
    block[6] = a3;
    block[7] = dnssd_client_context_release;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
    return 0;
  }
  if (v8)
  {
    v9 = *v6;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v6;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "probe_state";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "probe-srp.c";
    v63 = 1024;
    LODWORD(v64) = 346;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v10 = *v6;
  if (*v6)
  {
    v11 = v10 + 1;
    *v6 = v10 + 1;
    if (v10 + 1 >= 10001)
    {
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v11;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "probe-srp.c";
      v63 = 1024;
      LODWORD(v64) = 346;
      v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_105:
      v47 = v12;
LABEL_122:
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_FAULT, v13, buf, 0x36u);
LABEL_123:
      abort();
    }
  }
  else
  {
    ++probe_state_created;
    *v6 = 1;
  }
  v14 = *(unsigned __int8 *)(a1 + 1);
  if (v14 == 2)
    v15 = (const void *)(a1 + 4);
  else
    v15 = (const void *)(a1 + 8);
  inet_ntop(v14, v15, hostname, 0x2Eu);
  snprintf(__str, 0xAuLL, "%d", bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16);
  v16 = malloc_type_calloc(1uLL, 0x1A8uLL, 0x10B00402743B0D3uLL);
  if (!v16)
  {
    v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%{public}s: No memory for connection", buf, 0xCu);
    }
    goto LABEL_62;
  }
  v17 = (uint64_t)v16;
  v16[45] = ++cur_connection_serial;
  v18 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v19 = *(_DWORD *)(v17 + 32);
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v19;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "macos-ioloop.c";
    v63 = 1024;
    LODWORD(v64) = 1759;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v20 = *(_DWORD *)(v17 + 32);
  if (v20)
  {
    v21 = v20 + 1;
    *(_DWORD *)(v17 + 32) = v20 + 1;
    if (v20 + 1 >= 10001)
    {
      v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v21;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v63 = 1024;
      LODWORD(v64) = 1759;
      v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_118:
      v47 = v22;
      goto LABEL_122;
    }
  }
  else
  {
    ++comm_created;
    *(_DWORD *)(v17 + 32) = 1;
  }
  host = nw_endpoint_create_host(hostname, __str);
  if (!host)
  {
    v33 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%{public}s: No memory for connection endpoint.", buf, 0xCu);
    }
    v34 = *(_DWORD *)(v17 + 32);
    if (!v34)
    {
      v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v63 = 1024;
      LODWORD(v64) = 1763;
      v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_118;
    }
    v35 = global_os_log;
    if (v34 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "ioloop_connection_create";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v34;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v17;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "connection";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "macos-ioloop.c";
        v63 = 1024;
        LODWORD(v64) = 1763;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v34 = *(_DWORD *)(v17 + 32);
      }
      *(_DWORD *)(v17 + 32) = v34 - 1;
      if (v34 != 1)
        goto LABEL_62;
      v36 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_61;
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = "connection";
      *(_WORD *)&buf[32] = 2080;
      *(_QWORD *)&buf[34] = "macos-ioloop.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1763;
      goto LABEL_60;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_123;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v34;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "macos-ioloop.c";
    v63 = 1024;
    LODWORD(v64) = 1763;
    v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_121;
  }
  v25 = host;
  secure_udp = nw_parameters_create_secure_udp(_nw_parameters_configure_protocol_disable, _nw_parameters_configure_protocol_default_configuration);
  if (!secure_udp)
  {
    v37 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%{public}s: No memory for connection parameters.", buf, 0xCu);
    }
    nw_release(v25);
    v38 = *(_DWORD *)(v17 + 32);
    if (!v38)
    {
      v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v63 = 1024;
      LODWORD(v64) = 1807;
      v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_118;
    }
    v35 = global_os_log;
    if (v38 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "ioloop_connection_create";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v38;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v17;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "connection";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "macos-ioloop.c";
        v63 = 1024;
        LODWORD(v64) = 1807;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v38 = *(_DWORD *)(v17 + 32);
      }
      *(_DWORD *)(v17 + 32) = v38 - 1;
      if (v38 != 1)
        goto LABEL_62;
      v36 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_61;
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = "connection";
      *(_WORD *)&buf[32] = 2080;
      *(_QWORD *)&buf[34] = "macos-ioloop.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1807;
      goto LABEL_60;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_123;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v38;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "macos-ioloop.c";
    v63 = 1024;
    LODWORD(v64) = 1807;
    v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_121:
    v47 = v35;
    goto LABEL_122;
  }
  v27 = secure_udp;
  v28 = nw_parameters_copy_default_protocol_stack(secure_udp);
  nw_release(v28);
  *(_QWORD *)(v17 + 192) = strdup(hostname);
  *(_QWORD *)v17 = nw_connection_create(v25, v27);
  ++nw_connection_created;
  nw_release(v25);
  nw_release(v27);
  if (!*(_QWORD *)v17)
  {
    v39 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%{public}s: no memory for nw_connection object", buf, 0xCu);
    }
    v40 = *(_DWORD *)(v17 + 32);
    if (!v40)
    {
      v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v63 = 1024;
      LODWORD(v64) = 1838;
      v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_118;
    }
    v35 = global_os_log;
    if (v40 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "ioloop_connection_create";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v40;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v17;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "connection";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "macos-ioloop.c";
        v63 = 1024;
        LODWORD(v64) = 1838;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v40 = *(_DWORD *)(v17 + 32);
      }
      *(_DWORD *)(v17 + 32) = v40 - 1;
      if (v40 != 1)
        goto LABEL_62;
      v36 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
LABEL_61:
        ++comm_finalized;
        comm_finalize(v17);
LABEL_62:
        v17 = 0;
        goto LABEL_63;
      }
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = "connection";
      *(_WORD *)&buf[32] = 2080;
      *(_QWORD *)&buf[34] = "macos-ioloop.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1838;
LABEL_60:
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      goto LABEL_61;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_123;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v40;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "macos-ioloop.c";
    v63 = 1024;
    LODWORD(v64) = 1838;
    v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_121;
  }
  *(_QWORD *)(v17 + 224) = probe_srp_connected;
  *(_QWORD *)(v17 + 232) = probe_srp_disconnected;
  *(_QWORD *)(v17 + 240) = probe_srp_probe_state_context_release;
  *(_WORD *)(v17 + 416) &= 0xFDDFu;
  *(_QWORD *)(v17 + 200) = v6;
  *(_QWORD *)(v17 + 208) = probe_srp_datagram;
  v29 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v30 = *(_DWORD *)(v17 + 32);
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v30;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "macos-ioloop.c";
    v63 = 1024;
    LODWORD(v64) = 1849;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v31 = *(_DWORD *)(v17 + 32);
  if (v31)
  {
    v32 = v31 + 1;
    *(_DWORD *)(v17 + 32) = v31 + 1;
    if (v31 + 1 >= 10001)
    {
      v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v32;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v63 = 1024;
      LODWORD(v64) = 1849;
      v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_118;
    }
  }
  else
  {
    ++comm_created;
    *(_DWORD *)(v17 + 32) = 1;
  }
  v60 = *(NSObject **)v17;
  *(_QWORD *)buf = _NSConcreteStackBlock;
  *(_QWORD *)&buf[8] = 0x40000000;
  *(_QWORD *)&buf[16] = __ioloop_connection_create_block_invoke_26;
  *(_QWORD *)&buf[24] = &__block_descriptor_tmp_27;
  *(_QWORD *)&buf[32] = v17;
  nw_connection_set_state_changed_handler(v60, buf);
  nw_connection_set_queue(*(nw_connection_t *)v17, (dispatch_queue_t)ioloop_main_queue);
  nw_connection_start(*(nw_connection_t *)v17);
LABEL_63:
  *((_QWORD *)v6 + 1) = v17;
  v41 = global_os_log;
  v42 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v17)
  {
    if (v42)
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: failed to create connection", buf, 0xCu);
    }
    v48 = *v6;
    if (!*v6)
    {
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "probe-srp.c";
      v63 = 1024;
      LODWORD(v64) = 374;
      v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_105;
    }
    v49 = global_os_log;
    if (v48 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v48;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "probe-srp.c";
      v63 = 1024;
      LODWORD(v64) = 374;
      v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v47 = v49;
      goto LABEL_122;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v48;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "probe-srp.c";
      v63 = 1024;
      LODWORD(v64) = 374;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v48 = *v6;
    }
    *v6 = v48 - 1;
    if (v48 == 1)
    {
      v50 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "probe_srp_create";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v6;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = "probe_state";
        *(_WORD *)&buf[32] = 2080;
        *(_QWORD *)&buf[34] = "probe-srp.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 374;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++probe_state_finalized;
      probe_state_finalize(v6);
    }
    goto LABEL_80;
  }
  if (v42)
  {
    v43 = *v6;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v43;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v6;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "probe_state";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "probe-srp.c";
    v63 = 1024;
    LODWORD(v64) = 355;
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v44 = *v6;
  if (*v6)
  {
    v45 = v44 + 1;
    *v6 = v44 + 1;
    v46 = global_os_log;
    if (v44 + 1 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v45;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "probe-srp.c";
      v63 = 1024;
      LODWORD(v64) = 355;
      v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      v47 = v46;
      goto LABEL_122;
    }
  }
  else
  {
    ++probe_state_created;
    *v6 = 1;
    v46 = global_os_log;
  }
  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
  {
    v51 = *(unsigned __int8 *)(a1 + 8);
    if ((v51 & 0xFE) == 0xFC)
    {
      v52 = "ULA: ";
    }
    else if (v51 == 254 && (*(_BYTE *)(a1 + 9) & 0xC0) == 0x80)
    {
      v52 = "LUA: ";
    }
    else if ((v51 & 0xE0) == 0x20)
    {
      v52 = "GUA: ";
    }
    else
    {
      v52 = (const char *)&unk_10007C3B5;
    }
    v53 = bswap32(*(unsigned __int16 *)(a1 + 2));
    *(_DWORD *)buf = 136449027;
    *(_QWORD *)&buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v52;
    *(_WORD *)&buf[22] = 2160;
    *(_QWORD *)&buf[24] = 1752392040;
    *(_WORD *)&buf[32] = 1041;
    *(_DWORD *)&buf[34] = 6;
    *(_WORD *)&buf[38] = 2097;
    *(_QWORD *)&buf[40] = a1 + 8;
    v63 = 2160;
    v64 = 1752392040;
    v65 = 1042;
    v66 = 2;
    v67 = 2098;
    v68 = a1 + 14;
    v69 = 2160;
    v70 = 1752392040;
    v71 = 1041;
    v72 = 8;
    v73 = 2097;
    v74 = a1 + 16;
    v75 = 1024;
    v76 = HIWORD(v53);
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: probing service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} on port %d", buf, 0x6Au);
  }
  *((_QWORD *)v6 + 4) = a3;
  *((_QWORD *)v6 + 5) = dnssd_client_probe_callback;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)buf;
  *(_QWORD *)(a2 + 56) = v6;
  v54 = global_os_log;
  v55 = v6;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v56 = *v6;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v56;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v6;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "service->probe_state";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "probe-srp.c";
    v63 = 1024;
    LODWORD(v64) = 364;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v55 = *(int **)(a2 + 56);
  }
  v57 = *v55;
  if (*v55)
  {
    v58 = v57 + 1;
    *v55 = v57 + 1;
    if (v57 + 1 >= 10001)
    {
      v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_123;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v58;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v55;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "service->probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "probe-srp.c";
      v63 = 1024;
      LODWORD(v64) = 364;
      v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_118;
    }
  }
  else
  {
    ++probe_state_created;
    *v55 = 1;
  }
  *((_QWORD *)v6 + 3) = a2;
  thread_service_retain_((int *)a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 367);
  return v6;
}

uint64_t __probe_srp_service_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v3)(_QWORD);

  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), 0);
  v3 = *(uint64_t (**)(_QWORD))(a1 + 56);
  if (v3)
    return v3(*(_QWORD *)(a1 + 48));
  return result;
}

void probe_srp_datagram(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  unsigned __int16 *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t v11;
  unsigned int v12;
  int v13;
  int v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  unsigned int v21;
  int v22;
  int v23;
  uint64_t v24;
  _BYTE v25[12];
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  int v31;
  __int16 v32;
  _BYTE v33[10];
  uint64_t v34;
  __int16 v35;
  int v36;
  __int16 v37;
  uint64_t v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t v44;
  __int16 v45;
  unsigned int v46;
  __int16 v47;
  int v48;
  __int16 v49;
  int v50;
  __int16 v51;
  int v52;

  v6 = (unsigned __int16 *)(a2 + 88);
  v7 = *(_BYTE *)(a2 + 91) & 0xF;
  v8 = *a1;
  v9 = global_os_log;
  v10 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v8)
  {
    if (v10)
    {
      v11 = a1[24];
      v12 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(a3 + 8) + 290));
      v13 = *v6;
      v14 = *(unsigned __int16 *)(a3 + 64);
      *(_DWORD *)v25 = 136447747;
      *(_QWORD *)&v25[4] = "probe_srp_datagram";
      v26 = 2160;
      v27 = 1752392040;
      v28 = 2081;
      v29 = v11;
      v30 = 1024;
      v31 = HIWORD(v12);
      v32 = 1024;
      *(_DWORD *)v33 = v13;
      *(_WORD *)&v33[4] = 1024;
      *(_DWORD *)&v33[6] = v14;
      LOWORD(v34) = 1024;
      *(_DWORD *)((char *)&v34 + 2) = v7;
      v15 = "%{public}s: datagram from %{private, mask.hash}s on port %d xid %x (question xid %x) rcode %d";
      v16 = v9;
      v17 = 56;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, v25, v17);
    }
  }
  else if (v10)
  {
    v18 = *(_QWORD *)(a3 + 8);
    v19 = *(unsigned __int8 *)(v18 + 296);
    if ((v19 & 0xFE) == 0xFC)
    {
      v20 = "ULA: ";
    }
    else if (v19 == 254 && (*(_BYTE *)(v18 + 297) & 0xC0) == 0x80)
    {
      v20 = "LUA: ";
    }
    else if ((v19 & 0xE0) == 0x20)
    {
      v20 = "GUA: ";
    }
    else
    {
      v20 = (const char *)&unk_10007C3B5;
    }
    v21 = bswap32(*(unsigned __int16 *)(v18 + 290));
    v22 = *v6;
    v23 = *(unsigned __int16 *)(a3 + 64);
    *(_DWORD *)v25 = 136449795;
    *(_QWORD *)&v25[4] = "probe_srp_datagram";
    v26 = 2082;
    v27 = (uint64_t)v20;
    v28 = 2160;
    v29 = 1752392040;
    v30 = 1041;
    v31 = 6;
    v32 = 2097;
    *(_QWORD *)v33 = v18 + 296;
    *(_WORD *)&v33[8] = 2160;
    v34 = 1752392040;
    v35 = 1042;
    v36 = 2;
    v37 = 2098;
    v38 = v18 + 302;
    v39 = 2160;
    v40 = 1752392040;
    v41 = 1041;
    v42 = 8;
    v43 = 2097;
    v44 = v18 + 304;
    v45 = 1024;
    v46 = HIWORD(v21);
    v47 = 1024;
    v48 = v22;
    v49 = 1024;
    v50 = v23;
    v51 = 1024;
    v52 = v7;
    v15 = "%{public}s: datagram from {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:i"
          "n6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} on port %d xid %x (question xid %x) rcode %d";
    v16 = v9;
    v17 = 124;
    goto LABEL_14;
  }
  if (*v6 == *(unsigned __int16 *)(a3 + 64))
  {
    *(_QWORD *)v25 = 0;
    if (dns_wire_parse_((uint64_t *)v25, v6, *(unsigned __int16 *)(a2 + 64)))
    {
      dns_message_free(*(_QWORD **)v25);
      if (v7 != 2)
      {
        probe_srp_done((_QWORD *)a3, v7 == 0);
        ioloop_comm_cancel(*(_QWORD *)(a3 + 8));
        v24 = *(_QWORD *)(a3 + 16);
        if (v24)
          ioloop_cancel_wake_event(v24);
      }
    }
  }
}

void probe_srp_connected(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  __int16 v4;
  _WORD *v5;
  NSObject *v6;
  __int128 v7;
  unint64_t v8;
  __int128 v9;
  __int128 v10;

  if (*(_QWORD *)(a2 + 8))
  {
    *(_QWORD *)(a2 + 64) = 0;
    v3 = a2 + 64;
    *(_DWORD *)(a2 + 72) = 0;
    v10 = 0u;
    v9 = 0u;
    *((_QWORD *)&v7 + 1) = a2 + 76;
    v8 = a2 + 1474;
    *(_QWORD *)&v7 = a2 + 64;
    *(_WORD *)(a2 + 64) = arc4random_uniform(0x10000u);
    *(_DWORD *)(v3 + 2) = 0x1000000;
    dns_full_name_to_wire_(0, (uint64_t)&v7, "default.service.arpa", 322);
    v4 = WORD4(v7);
    if (DWORD2(v10) <= 1)
    {
      v5 = (_WORD *)(*((_QWORD *)&v7 + 1) + 2);
      if (*((_QWORD *)&v7 + 1) + 2 < v8)
      {
        **((_WORD **)&v7 + 1) = 1536;
        v4 += 4;
        if ((unint64_t)(v5 + 1) >= v8)
          v4 = (__int16)v5;
        else
          *v5 = 256;
      }
    }
    *(_WORD *)(a2 + 1484) = v4 - v3;
    *(_QWORD *)(a2 + 1476) = 0x3E800000000;
    probe_srp_schedule_retransmission(a2);
  }
  else
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v7) = 136446210;
      *(_QWORD *)((char *)&v7 + 4) = "probe_srp_connected";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: canceled before connection was ready", (uint8_t *)&v7, 0xCu);
    }
  }
}

void probe_srp_disconnected(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;

  if (a2[3])
    probe_srp_done(a2, 0);
  v3 = a2[1];
  if (v3)
  {
    ioloop_comm_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 237);
    a2[1] = 0;
  }
}

void probe_srp_probe_state_context_release(_QWORD *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "probe_srp_probe_state_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "probe-srp.c";
    v10 = 1024;
    v11 = 221;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "probe_srp_probe_state_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "probe-srp.c";
    v10 = 1024;
    v11 = 221;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "probe_srp_probe_state_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "probe-srp.c";
    v10 = 1024;
    v11 = 221;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "probe_srp_probe_state_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "probe_state";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "probe-srp.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 221;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++probe_state_finalized;
    probe_state_finalize(a1);
  }
}

uint64_t __probe_srp_create_block_invoke(uint64_t a1)
{
  uint64_t result;
  uint64_t (*v3)(_QWORD);

  result = (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), 1);
  v3 = *(uint64_t (**)(_QWORD))(a1 + 56);
  if (v3)
    return v3(*(_QWORD *)(a1 + 48));
  return result;
}

void probe_srp_done(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  unsigned __int8 *v6;
  NSObject *v7;
  _BOOL4 v8;
  int v9;
  const char *v10;
  int v11;
  const char *v12;
  void (*v13)(_QWORD, _QWORD, uint64_t);
  void (*v14)(_QWORD);
  uint64_t v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  const char *v19;
  int v20;
  const char *v21;
  __int16 v22;
  _BYTE v23[34];
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  unsigned int v37;

  v4 = a1[3];
  a1[3] = 0;
  *(_QWORD *)(v4 + 56) = 0;
  if (*(_DWORD *)(v4 + 20) == 3 || *(_BYTE *)(v4 + 82))
    v5 = 53;
  else
    v5 = __rev16(*(unsigned __int16 *)(v4 + 80));
  v6 = (unsigned __int8 *)(v4 + 64);
  v7 = global_os_log;
  v8 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if ((a2 & 1) != 0)
  {
    if (v8)
    {
      v9 = *v6;
      if ((v9 & 0xFE) == 0xFC)
      {
        v10 = "ULA: ";
      }
      else if (v9 == 254 && (*(_BYTE *)(v4 + 65) & 0xC0) == 0x80)
      {
        v10 = "LUA: ";
      }
      else if ((v9 & 0xE0) == 0x20)
      {
        v10 = "GUA: ";
      }
      else
      {
        v10 = (const char *)&unk_10007C3B5;
      }
      v20 = 136449027;
      v21 = "probe_srp_done";
      v22 = 2082;
      *(_QWORD *)v23 = v10;
      *(_WORD *)&v23[8] = 2160;
      *(_QWORD *)&v23[10] = 1752392040;
      *(_WORD *)&v23[18] = 1041;
      *(_DWORD *)&v23[20] = 6;
      *(_WORD *)&v23[24] = 2097;
      *(_QWORD *)&v23[26] = v4 + 64;
      v24 = 2160;
      v25 = 1752392040;
      v26 = 1042;
      v27 = 2;
      v28 = 2098;
      v29 = v4 + 70;
      v30 = 2160;
      v31 = 1752392040;
      v32 = 1041;
      v33 = 8;
      v34 = 2097;
      v35 = v4 + 72;
      v36 = 1024;
      v37 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} responded on port %d", (uint8_t *)&v20, 0x6Au);
    }
    *(_WORD *)(v4 + 27) = 0;
    *(_BYTE *)(v4 + 48) = 1;
  }
  else
  {
    if (v8)
    {
      v11 = *v6;
      if ((v11 & 0xFE) == 0xFC)
      {
        v12 = "ULA: ";
      }
      else if (v11 == 254 && (*(_BYTE *)(v4 + 65) & 0xC0) == 0x80)
      {
        v12 = "LUA: ";
      }
      else if ((v11 & 0xE0) == 0x20)
      {
        v12 = "GUA: ";
      }
      else
      {
        v12 = (const char *)&unk_10007C3B5;
      }
      v20 = 136449027;
      v21 = "probe_srp_done";
      v22 = 2082;
      *(_QWORD *)v23 = v12;
      *(_WORD *)&v23[8] = 2160;
      *(_QWORD *)&v23[10] = 1752392040;
      *(_WORD *)&v23[18] = 1041;
      *(_DWORD *)&v23[20] = 6;
      *(_WORD *)&v23[24] = 2097;
      *(_QWORD *)&v23[26] = v4 + 64;
      v24 = 2160;
      v25 = 1752392040;
      v26 = 1042;
      v27 = 2;
      v28 = 2098;
      v29 = v4 + 70;
      v30 = 2160;
      v31 = 1752392040;
      v32 = 1041;
      v33 = 8;
      v34 = 2097;
      v35 = v4 + 72;
      v36 = 1024;
      v37 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} not responding on port %d", (uint8_t *)&v20, 0x6Au);
    }
    *(_WORD *)(v4 + 27) = 1;
  }
  *(_BYTE *)(v4 + 49) = 1;
  v13 = (void (*)(_QWORD, _QWORD, uint64_t))a1[5];
  if (v13)
  {
    v13(a1[3], a1[4], a2);
    a1[5] = 0;
  }
  v14 = (void (*)(_QWORD))a1[6];
  if (v14)
    v14(a1[4]);
  a1[4] = 0;
  thread_service_release_((int *)v4, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 169);
  v15 = a1[2];
  if (v15)
    ioloop_cancel_wake_event(v15);
  v16 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_48;
    v20 = 136447490;
    v21 = "probe_srp_done";
    v22 = 1024;
    *(_DWORD *)v23 = 0;
    *(_WORD *)&v23[4] = 2048;
    *(_QWORD *)&v23[6] = a1;
    *(_WORD *)&v23[14] = 2080;
    *(_QWORD *)&v23[16] = "probe_state";
    *(_WORD *)&v23[24] = 2080;
    *(_QWORD *)&v23[26] = "probe-srp.c";
    v24 = 1024;
    LODWORD(v25) = 173;
    v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_47;
  }
  v17 = global_os_log;
  if (v16 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_48;
    v20 = 136447490;
    v21 = "probe_srp_done";
    v22 = 1024;
    *(_DWORD *)v23 = v16;
    *(_WORD *)&v23[4] = 2048;
    *(_QWORD *)&v23[6] = a1;
    *(_WORD *)&v23[14] = 2080;
    *(_QWORD *)&v23[16] = "probe_state";
    *(_WORD *)&v23[24] = 2080;
    *(_QWORD *)&v23[26] = "probe-srp.c";
    v24 = 1024;
    LODWORD(v25) = 173;
    v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_47:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v19, (uint8_t *)&v20, 0x36u);
LABEL_48:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v20 = 136447490;
    v21 = "probe_srp_done";
    v22 = 1024;
    *(_DWORD *)v23 = v16;
    *(_WORD *)&v23[4] = 2048;
    *(_QWORD *)&v23[6] = a1;
    *(_WORD *)&v23[14] = 2080;
    *(_QWORD *)&v23[16] = "probe_state";
    *(_WORD *)&v23[24] = 2080;
    *(_QWORD *)&v23[26] = "probe-srp.c";
    v24 = 1024;
    LODWORD(v25) = 173;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
    v16 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v16 - 1;
  if (v16 == 1)
  {
    v18 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v20 = 136447234;
      v21 = "probe_srp_done";
      v22 = 2048;
      *(_QWORD *)v23 = a1;
      *(_WORD *)&v23[8] = 2080;
      *(_QWORD *)&v23[10] = "probe_state";
      *(_WORD *)&v23[18] = 2080;
      *(_QWORD *)&v23[20] = "probe-srp.c";
      *(_WORD *)&v23[28] = 1024;
      *(_DWORD *)&v23[30] = 173;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
    }
    ++probe_state_finalized;
    probe_state_finalize(a1);
  }
}

void probe_srp_schedule_retransmission(uint64_t a1)
{
  int *v2;
  int v3;
  unsigned __int16 v4;
  int v5;
  NSObject *v6;
  int v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  int v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  int v23;

  if (*(_QWORD *)(a1 + 16)
    || (v2 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 279), (*(_QWORD *)(a1 + 16) = v2) != 0))
  {
    v3 = *(_DWORD *)(a1 + 1480);
    v4 = arc4random_uniform(0x10000u);
    v5 = *(_DWORD *)(a1 + 1480);
    *(_DWORD *)(a1 + 1480) = 2 * v5;
    ioloop_add_wake_event(*(_QWORD *)(a1 + 16), a1, (uint64_t)probe_srp_retransmit, (uint64_t)probe_srp_context_release, v4 % v5 + v3);
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      v13 = "probe_srp_schedule_retransmission";
      v14 = 1024;
      v15 = v7;
      v16 = 2048;
      v17 = a1;
      v18 = 2080;
      v19 = "probe_state";
      v20 = 2080;
      v21 = "probe-srp.c";
      v22 = 1024;
      v23 = 290;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*(_DWORD *)a1)
    {
      v8 = *(_DWORD *)a1 + 1;
      *(_DWORD *)a1 = v8;
      if (v8 >= 10001)
      {
        v11 = v8;
        v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v13 = "probe_srp_schedule_retransmission";
          v14 = 1024;
          v15 = v11;
          v16 = 2048;
          v17 = a1;
          v18 = 2080;
          v19 = "probe_state";
          v20 = 2080;
          v21 = "probe-srp.c";
          v22 = 1024;
          v23 = 290;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++probe_state_created;
      *(_DWORD *)a1 = 1;
    }
  }
  else
  {
    v10 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v13 = "probe_srp_schedule_retransmission";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: can't allocate probe state wakeup", buf, 0xCu);
    }
    probe_srp_done((_QWORD *)a1, 0);
    ioloop_comm_cancel(*(_QWORD *)(a1 + 8));
  }
}

uint64_t probe_srp_retransmit(uint64_t a1)
{
  int v2;
  NSObject *v3;
  double v4;
  uint64_t v6;
  _BYTE v7[18];
  __int16 v8;
  double v9;

  v2 = *(_DWORD *)(a1 + 1476) + 1;
  *(_DWORD *)(a1 + 1476) = v2;
  v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v4 = (double)*(int *)(a1 + 1480);
    *(_DWORD *)v7 = 136446722;
    *(_QWORD *)&v7[4] = "probe_srp_retransmit";
    *(_WORD *)&v7[12] = 1024;
    *(_DWORD *)&v7[14] = v2;
    v8 = 2048;
    v9 = v4 / 1000.0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: num_retransmissions = %d, time = %lg", v7, 0x1Cu);
    v2 = *(_DWORD *)(a1 + 1476);
  }
  if (v2 < 4)
  {
    probe_srp_schedule_retransmission(a1);
    v6 = *(unsigned __int16 *)(a1 + 1484);
    *(_QWORD *)v7 = a1 + 64;
    *(_QWORD *)&v7[8] = v6;
    return ioloop_send_message(*(_QWORD *)(a1 + 8), 0, (iovec *)v7);
  }
  else
  {
    probe_srp_done((_QWORD *)a1, 0);
    return ioloop_comm_cancel(*(_QWORD *)(a1 + 8));
  }
}

void probe_srp_context_release(_QWORD *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "probe_srp_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "probe-srp.c";
    v10 = 1024;
    v11 = 272;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "probe_srp_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "probe-srp.c";
    v10 = 1024;
    v11 = 272;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "probe_srp_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "probe-srp.c";
    v10 = 1024;
    v11 = 272;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "probe_srp_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "probe_state";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "probe-srp.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 272;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++probe_state_finalized;
    probe_state_finalize(a1);
  }
}

void cti_internal_reply_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _xpc_connection_s *v4;
  NSObject *v5;
  int v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  _xpc_connection_s *v12;

  cti_internal_event_reply_callback(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = 0;
  v4 = *(_xpc_connection_s **)(a1 + 16);
  if (v4)
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(a1 + 80);
      v7 = 136446722;
      v8 = "cti_internal_reply_callback";
      v9 = 1024;
      v10 = v6;
      v11 = 2048;
      v12 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] canceling connection %p", (uint8_t *)&v7, 0x1Cu);
      v4 = *(_xpc_connection_s **)(a1 + 16);
    }
    xpc_connection_cancel(v4);
  }
  cti_connection_release_((_QWORD *)a1, 673);
}

uint64_t setup_for_command(_QWORD *a1, uint64_t a2, const char *a3, uint64_t a4, xpc_object_t xdict, uint64_t a6, uint64_t a7, uint64_t a8, char a9, char *a10, int a11)
{
  xpc_object_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  uint32_t v25;
  _DWORD *v26;
  _DWORD *v27;
  int v28;
  NSObject *v29;
  int v30;
  int v31;
  int v32;
  uint64_t v33;
  char *v34;
  const char *v35;
  NSObject *v36;
  xpc_connection_t mach_service;
  NSObject *v38;
  int v39;
  NSObject *v40;
  int v41;
  int v42;
  int v43;
  int v44;
  NSObject *v45;
  NSObject *v46;
  uint64_t v47;
  _xpc_connection_s *v48;
  xpc_object_t v49;
  NSObject *v50;
  int v51;
  uint64_t v52;
  _xpc_connection_s *v53;
  NSObject *v54;
  NSObject *v56;
  _QWORD *v57;
  uint64_t v58;
  _QWORD v59[5];
  _QWORD handler[5];
  uint8_t v61[4];
  const char *v62;
  __int16 v63;
  int v64;
  __int16 v65;
  uint64_t v66;
  char v67[16];
  uint8_t buf[4];
  const char *v69;
  __int16 v70;
  _BYTE v71[34];
  __int16 v72;
  int v73;

  if (!a7 || !a8)
  {
    v21 = global_os_log;
    v22 = 4294901756;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return v22;
    *(_DWORD *)buf = 136446466;
    v69 = "setup_for_command";
    v70 = 2082;
    *(_QWORD *)v71 = a2;
    v23 = "%{public}s: %{public}s: NULL cti_connection_t OR Callback OR Client_Queue parameter";
    v24 = v21;
    v25 = 22;
LABEL_40:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v23, buf, v25);
    return v22;
  }
  if (a9)
  {
    xpc_dictionary_set_string(xdict, "command", "eventsOn");
    v19 = xpc_array_create(0, 0);
    if (!v19)
      return 4294901757;
    v20 = v19;
    v58 = a2;
    xpc_array_set_string(v19, 0xFFFFFFFFFFFFFFFFLL, a3);
    xpc_dictionary_set_value(xdict, "eventList", v20);
    xpc_release(v20);
    a3 = 0;
  }
  else
  {
    v58 = a2;
    xpc_dictionary_set_string(xdict, "command", "WpanctlCmd");
  }
  v26 = malloc_type_calloc(1uLL, 0x58uLL, 0x10F00403C42241CuLL);
  if (!v26)
  {
    v36 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v69 = "init_connection";
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%{public}s: no memory to allocate!", buf, 0xCu);
    }
LABEL_38:
    v22 = 4294901757;
    v47 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return v22;
    *(_DWORD *)buf = 136446722;
    v69 = "setup_for_command";
    v70 = 2082;
    *(_QWORD *)v71 = v58;
    *(_WORD *)&v71[8] = 1024;
    *(_DWORD *)&v71[10] = -65539;
    v23 = "%{public}s: %{public}s: Since init_connection() returned %d error returning w/o sending msg";
    v24 = v47;
    v25 = 28;
    goto LABEL_40;
  }
  v27 = v26;
  v57 = a1;
  v28 = client_serial_number;
  v26[20] = client_serial_number;
  client_serial_number = v28 + 1;
  v29 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v30 = *v27;
    *(_DWORD *)buf = 136447490;
    v69 = "init_connection";
    v70 = 1024;
    *(_DWORD *)v71 = v30;
    *(_WORD *)&v71[4] = 2048;
    *(_QWORD *)&v71[6] = v27;
    *(_WORD *)&v71[14] = 2080;
    *(_QWORD *)&v71[16] = "conn_ref";
    *(_WORD *)&v71[24] = 2080;
    *(_QWORD *)&v71[26] = strrchr(a10, 47) + 1;
    v72 = 1024;
    v73 = a11;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v31 = *v27;
  if (*v27)
  {
    v32 = v31 + 1;
    *v27 = v31 + 1;
    if (v31 + 1 >= 10001)
    {
      v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_55;
      v34 = strrchr(a10, 47);
      *(_DWORD *)buf = 136447490;
      v69 = "init_connection";
      v70 = 1024;
      *(_DWORD *)v71 = v32;
      *(_WORD *)&v71[4] = 2048;
      *(_QWORD *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(_QWORD *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(_QWORD *)&v71[26] = v34 + 1;
      v72 = 1024;
      v73 = a11;
      v35 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_51:
      v56 = v33;
      goto LABEL_54;
    }
  }
  else
  {
    ++cti_connection_created;
    *v27 = 1;
  }
  dispatch_retain((dispatch_object_t)&_dispatch_main_q);
  *((_QWORD *)v27 + 8) = a6;
  *((_QWORD *)v27 + 9) = v58;
  *((_QWORD *)v27 + 4) = &_dispatch_main_q;
  *((_QWORD *)v27 + 5) = a3;
  *((_QWORD *)v27 + 1) = a7;
  *((_QWORD *)v27 + 6) = a4;
  *((_QWORD *)v27 + 7) = a8;
  mach_service = xpc_connection_create_mach_service("com.apple.wpantund.xpc", (dispatch_queue_t)&_dispatch_main_q, 2uLL);
  *((_QWORD *)v27 + 2) = mach_service;
  v38 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v39 = v27[20];
    *(_DWORD *)buf = 136446722;
    v69 = "init_connection";
    v70 = 1024;
    *(_DWORD *)v71 = v39;
    *(_WORD *)&v71[4] = 2048;
    *(_QWORD *)&v71[6] = mach_service;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] xpc connection: %p", buf, 0x1Cu);
  }
  *((_QWORD *)v27 + 3) = xdict;
  xpc_retain(xdict);
  cti_log_object((uint64_t)"init_connection/command", v27[20], *((_QWORD *)v27 + 9), (uint64_t)&unk_10007C3B5, (uint64_t)&unk_10007C3B5, xdict, (const char *)&unk_10007C3B5);
  v40 = global_os_log;
  if (!*((_QWORD *)v27 + 2))
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v69 = "init_connection";
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%{public}s: conn_ref/lib_q is NULL", buf, 0xCu);
    }
    v44 = *v27;
    if (!*v27)
    {
      v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_55;
      *(_DWORD *)buf = 136447490;
      v69 = "init_connection";
      v70 = 1024;
      *(_DWORD *)v71 = 0;
      *(_WORD *)&v71[4] = 2048;
      *(_QWORD *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(_QWORD *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(_QWORD *)&v71[26] = "cti-services.c";
      v72 = 1024;
      v73 = 579;
      v35 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_51;
    }
    v45 = global_os_log;
    if (v44 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_55;
      *(_DWORD *)buf = 136447490;
      v69 = "init_connection";
      v70 = 1024;
      *(_DWORD *)v71 = v44;
      *(_WORD *)&v71[4] = 2048;
      *(_QWORD *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(_QWORD *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(_QWORD *)&v71[26] = "cti-services.c";
      v72 = 1024;
      v73 = 579;
      v35 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v56 = v45;
LABEL_54:
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, v35, buf, 0x36u);
LABEL_55:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v69 = "init_connection";
      v70 = 1024;
      *(_DWORD *)v71 = v44;
      *(_WORD *)&v71[4] = 2048;
      *(_QWORD *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(_QWORD *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(_QWORD *)&v71[26] = "cti-services.c";
      v72 = 1024;
      v73 = 579;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v44 = *v27;
    }
    *v27 = v44 - 1;
    if (v44 == 1)
    {
      v46 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v69 = "init_connection";
        v70 = 2048;
        *(_QWORD *)v71 = v27;
        *(_WORD *)&v71[8] = 2080;
        *(_QWORD *)&v71[10] = "conn_ref";
        *(_WORD *)&v71[18] = 2080;
        *(_QWORD *)&v71[20] = "cti-services.c";
        *(_WORD *)&v71[28] = 1024;
        *(_DWORD *)&v71[30] = 579;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++cti_connection_finalized;
      cti_connection_finalize(v27);
    }
    goto LABEL_38;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v41 = *v27;
    *(_DWORD *)buf = 136447490;
    v69 = "init_connection";
    v70 = 1024;
    *(_DWORD *)v71 = v41;
    *(_WORD *)&v71[4] = 2048;
    *(_QWORD *)&v71[6] = v27;
    *(_WORD *)&v71[14] = 2080;
    *(_QWORD *)&v71[16] = "conn_ref";
    *(_WORD *)&v71[24] = 2080;
    *(_QWORD *)&v71[26] = "cti-services.c";
    v72 = 1024;
    v73 = 584;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v42 = *v27;
  if (*v27)
  {
    v43 = v42 + 1;
    *v27 = v42 + 1;
    if (v42 + 1 >= 10001)
    {
      v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_55;
      *(_DWORD *)buf = 136447490;
      v69 = "init_connection";
      v70 = 1024;
      *(_DWORD *)v71 = v43;
      *(_WORD *)&v71[4] = 2048;
      *(_QWORD *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(_QWORD *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(_QWORD *)&v71[26] = "cti-services.c";
      v72 = 1024;
      v73 = 584;
      v35 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_51;
    }
  }
  else
  {
    ++cti_connection_created;
    *v27 = 1;
  }
  v48 = (_xpc_connection_s *)*((_QWORD *)v27 + 2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = __init_connection_block_invoke;
  handler[3] = &__block_descriptor_tmp_190;
  handler[4] = v27;
  xpc_connection_set_event_handler(v48, handler);
  xpc_connection_set_finalizer_f(*((xpc_connection_t *)v27 + 2), (xpc_finalizer_t)cti_xpc_connection_finalize);
  xpc_connection_set_context(*((xpc_connection_t *)v27 + 2), v27);
  xpc_connection_resume(*((xpc_connection_t *)v27 + 2));
  strcpy(v67, "srp-mdns-proxy");
  snprintf((char *)buf, 0x23uLL, "%s-%d", v67, v27[20]);
  v49 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v49, "command", "checkIn");
  xpc_dictionary_set_string(v49, "clientName", (const char *)buf);
  cti_log_object((uint64_t)"init_connection/checkin", v27[20], *((_QWORD *)v27 + 9), (uint64_t)&unk_10007C3B5, (uint64_t)&unk_10007C3B5, v49, (const char *)&unk_10007C3B5);
  v50 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v51 = v27[20];
    v52 = *((_QWORD *)v27 + 2);
    *(_DWORD *)v61 = 136446722;
    v62 = "init_connection";
    v63 = 1024;
    v64 = v51;
    v65 = 2048;
    v66 = v52;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] sending message on connection %p", v61, 0x1Cu);
  }
  v53 = (_xpc_connection_s *)*((_QWORD *)v27 + 2);
  v54 = *((_QWORD *)v27 + 4);
  v59[0] = _NSConcreteStackBlock;
  v59[1] = 0x40000000;
  v59[2] = __init_connection_block_invoke_82;
  v59[3] = &__block_descriptor_tmp_83;
  v59[4] = v27;
  xpc_connection_send_message_with_reply(v53, v49, v54, v59);
  xpc_release(v49);
  if (v57)
    *v57 = v27;
  return 0;
}

void cti_log_object(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, xpc_object_t object, const char *a7)
{
  xpc_type_t type;
  const char *v13;
  const char *v14;
  xpc_type_t v16;
  void *v17;
  void *v18;
  const char *v19;
  char *v20;
  NSObject *v21;
  char *v23;
  void *v24;
  const char **v25;
  NSObject *v26;
  uint64_t v27;
  char *v28;
  char v29;
  size_t v30;
  const char *v31;
  size_t v32;
  unint64_t v33;
  uint8_t *v34;
  uint64_t v35;
  _BOOL4 v36;
  NSObject *v37;
  const char *v38;
  uint32_t v39;
  uint64_t v40;
  _BOOL4 v41;
  NSObject *v42;
  const char *v43;
  size_t v44;
  uint8_t *v45;
  uint32_t v46;
  uint8_t *v47;
  void *v48;
  uint64_t v49;
  _BOOL4 v50;
  const char *v51;
  NSObject *v52;
  uint32_t v53;
  size_t v54;
  char *v55;
  const char *v56;
  NSObject *v57;
  uint8_t *v58;
  uint64_t v59;
  int v60;
  uint64_t v61;
  const char *v62;
  const char *v63;
  const char **v66;
  size_t count;
  _QWORD v68[7];
  int v69;
  _QWORD v70[7];
  int v71;
  _QWORD v72[5];
  _QWORD v73[7];
  int v74;
  _QWORD applier[5];
  _QWORD v76[5];
  char v77;
  uint8_t v78[4];
  const char *v79;
  __int16 v80;
  int v81;
  __int16 v82;
  uint64_t v83;
  __int16 v84;
  uint64_t v85;
  __int16 v86;
  const char *v87;
  __int16 v88;
  uint64_t v89;
  __int16 v90;
  uint64_t v91;
  __int16 v92;
  uint8_t *v93;
  __int16 v94;
  uint8_t *v95;
  __int16 v96;
  const char *v97;
  __int16 v98;
  uint8_t *v99;
  uint8_t buf[4];
  const char *v101;
  __int16 v102;
  int v103;
  __int16 v104;
  uint64_t v105;
  __int16 v106;
  uint64_t v107;
  __int16 v108;
  const char *v109;
  __int16 v110;
  uint64_t v111;
  __int16 v112;
  uint64_t v113;
  __int16 v114;
  char *v115;

  type = xpc_get_type(object);
  if (a7)
    v13 = a7;
  else
    v13 = (const char *)&cti_log_object_no_indent;
  v14 = v13;
  if (type != (xpc_type_t)&_xpc_type_dictionary && type != (xpc_type_t)&_xpc_type_array)
  {
    v20 = cti_xpc_copy_description(object);
    v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136448002;
      v101 = "cti_log_object";
      v102 = 1024;
      v103 = a2;
      v104 = 2082;
      v105 = a1;
      v106 = 2082;
      v107 = a3;
      v108 = 2082;
      v109 = v13;
      v110 = 2082;
      v111 = a4;
      v112 = 2082;
      v113 = a5;
      v114 = 2082;
      v115 = v20;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s", buf, 0x4Eu);
    }
    v23 = v20;
    goto LABEL_16;
  }
  v16 = type;
  v77 = 1;
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    v76[0] = _NSConcreteStackBlock;
    v76[1] = 0x40000000;
    v76[2] = __cti_log_object_block_invoke;
    v76[3] = &__block_descriptor_tmp_89;
    v76[4] = &v77;
    xpc_dictionary_apply(object, v76);
    if (v77)
    {
      count = xpc_dictionary_get_count(object);
      v24 = malloc_type_malloc(8 * count, 0x10040436913F5uLL);
      if (v24)
      {
        v18 = v24;
        v59 = a3;
        v74 = 0;
        v25 = (const char **)malloc_type_malloc(8 * count, 0x50040EE9192B6uLL);
        if (!v25)
        {
          free(v18);
          v26 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v78 = 136446466;
            v79 = "cti_log_object";
            v80 = 1024;
            v81 = a2;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] no memory", v78, 0x12u);
          }
        }
        v60 = a2;
        v73[0] = _NSConcreteStackBlock;
        v73[1] = 0x40000000;
        v73[2] = __cti_log_object_block_invoke_93;
        v73[3] = &__block_descriptor_tmp_94;
        v73[4] = v18;
        v73[5] = &v74;
        v66 = v25;
        v73[6] = v25;
        xpc_dictionary_apply(object, v73);
        v63 = "}";
        v19 = "{";
        goto LABEL_24;
      }
LABEL_74:
      v57 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v78 = 136446466;
        v79 = "cti_log_object";
        v80 = 1024;
        v81 = a2;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] no memory", v78, 0x12u);
      }
      return;
    }
LABEL_70:
    v54 = strlen(v13);
    v55 = (char *)malloc_type_malloc(v54 + 3, 0x30358557uLL);
    if (v55)
    {
      v56 = v55;
      memset(v55, 32, v54 + 2);
      v56[v54 + 2] = 0;
      v14 = v56;
    }
    if (v16 == (xpc_type_t)&_xpc_type_dictionary)
    {
      v70[0] = _NSConcreteStackBlock;
      v70[1] = 0x40000000;
      v70[2] = __cti_log_object_block_invoke_102;
      v70[3] = &__block_descriptor_tmp_104;
      v71 = a2;
      v70[4] = a1;
      v70[5] = a3;
      v70[6] = v14;
      xpc_dictionary_apply(object, v70);
    }
    else
    {
      v68[0] = _NSConcreteStackBlock;
      v68[1] = 0x40000000;
      v68[2] = __cti_log_object_block_invoke_2_105;
      v68[3] = &__block_descriptor_tmp_107;
      v69 = a2;
      v68[4] = a1;
      v68[5] = a3;
      v68[6] = v14;
      xpc_array_apply(object, v68);
    }
    if (v14 == v13)
      return;
    v23 = (char *)v14;
LABEL_16:
    free(v23);
    return;
  }
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = __cti_log_object_block_invoke_3;
  applier[3] = &__block_descriptor_tmp_92;
  applier[4] = &v77;
  xpc_array_apply(object, applier);
  if (!v77)
    goto LABEL_70;
  count = xpc_array_get_count(object);
  v17 = malloc_type_malloc(8 * count, 0x10040436913F5uLL);
  if (!v17)
    goto LABEL_74;
  v18 = v17;
  v59 = a3;
  v60 = a2;
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 0x40000000;
  v72[2] = __cti_log_object_block_invoke_2_95;
  v72[3] = &__block_descriptor_tmp_96;
  v72[4] = v17;
  xpc_array_apply(object, v72);
  v66 = 0;
  v63 = "]";
  v19 = "[";
LABEL_24:
  v58 = (uint8_t *)v19;
  if (!count)
    goto LABEL_82;
  v61 = a5;
  v62 = v14;
  v27 = 0;
  v28 = (char *)buf;
  v29 = 1;
  v30 = 160;
  do
  {
    v31 = (const char *)*((_QWORD *)v18 + v27);
    if (v31)
    {
      v32 = strlen(*((const char **)v18 + v27)) + 2;
    }
    else
    {
      v31 = "NULL";
      v32 = 6;
    }
    if (v16 == (xpc_type_t)&_xpc_type_dictionary)
      v32 += strlen(v66[v27]) + 2;
    v33 = v32 + 1;
    if (v32 + 1 <= v30)
      goto LABEL_49;
    if (count - 1 == v27)
      v34 = (uint8_t *)v63;
    else
      v34 = (uint8_t *)&unk_10007C3B5;
    if (v30 != 160)
    {
      v35 = global_os_log;
      v36 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      v28 = (char *)buf;
      if ((v29 & 1) != 0)
      {
        if (v36)
        {
          *(_DWORD *)v78 = 136448514;
          v79 = "cti_log_object";
          v80 = 1024;
          v81 = v60;
          v82 = 2082;
          v83 = a1;
          v84 = 2082;
          v85 = v59;
          v86 = 2082;
          v87 = v62;
          v88 = 2082;
          v89 = a4;
          v90 = 2082;
          v91 = v61;
          v92 = 2082;
          v93 = v58;
          v94 = 2082;
          v95 = buf;
          v96 = 2082;
          v97 = (const char *)v34;
          v37 = v35;
          v38 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s%{public}s";
          v39 = 98;
LABEL_41:
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v38, v78, v39);
        }
      }
      else if (v36)
      {
        *(_DWORD *)v78 = 136448258;
        v79 = "cti_log_object";
        v80 = 1024;
        v81 = v60;
        v82 = 2082;
        v83 = a1;
        v84 = 2082;
        v85 = v59;
        v86 = 2082;
        v87 = v62;
        v88 = 2082;
        v89 = a4;
        v90 = 2082;
        v91 = v61;
        v92 = 2082;
        v93 = buf;
        v94 = 2082;
        v95 = v34;
        v37 = v35;
        v38 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s +%{public}s%{public}s";
        v39 = 88;
        goto LABEL_41;
      }
      v29 = 0;
    }
    if (v33 < 0xA1)
    {
      v30 = 160;
LABEL_49:
      if (v16 == (xpc_type_t)&_xpc_type_dictionary)
        snprintf(v28, v30, "%s%s: %s%s");
      else
        snprintf(v28, v30, "%s%s%s");
      v44 = strlen(v28);
      v28 += v44;
      v30 -= v44;
      goto LABEL_63;
    }
    v40 = global_os_log;
    v41 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v16 != (xpc_type_t)&_xpc_type_dictionary)
    {
      if ((v29 & 1) != 0)
      {
        if (v41)
        {
          *(_DWORD *)v78 = 136448514;
          v79 = "cti_log_object";
          v80 = 1024;
          v81 = v60;
          v82 = 2082;
          v83 = a1;
          v84 = 2082;
          v85 = v59;
          v86 = 2082;
          v87 = v62;
          v88 = 2082;
          v89 = a4;
          v90 = 2082;
          v91 = v61;
          v92 = 2082;
          v93 = v58;
          v94 = 2082;
          v95 = (uint8_t *)v31;
          v96 = 2082;
          v97 = (const char *)v34;
          v42 = v40;
          v43 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s%{public}s";
LABEL_60:
          v46 = 98;
          goto LABEL_61;
        }
        goto LABEL_62;
      }
      if (!v41)
        goto LABEL_62;
      *(_DWORD *)v78 = 136448258;
      v79 = "cti_log_object";
      v80 = 1024;
      v81 = v60;
      v82 = 2082;
      v83 = a1;
      v84 = 2082;
      v85 = v59;
      v86 = 2082;
      v87 = v62;
      v88 = 2082;
      v89 = a4;
      v90 = 2082;
      v91 = v61;
      v92 = 2082;
      v93 = (uint8_t *)v31;
      v94 = 2082;
      v95 = v34;
      v42 = v40;
      v43 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s +%{public}s%{public}s";
      v46 = 88;
LABEL_61:
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, v43, v78, v46);
      goto LABEL_62;
    }
    if ((v29 & 1) != 0)
    {
      if (!v41)
        goto LABEL_62;
      v45 = (uint8_t *)v66[v27];
      *(_DWORD *)v78 = 136448770;
      v79 = "cti_log_object";
      v80 = 1024;
      v81 = v60;
      v82 = 2082;
      v83 = a1;
      v84 = 2082;
      v85 = v59;
      v86 = 2082;
      v87 = v62;
      v88 = 2082;
      v89 = a4;
      v90 = 2082;
      v91 = v61;
      v92 = 2082;
      v93 = v58;
      v94 = 2082;
      v95 = v45;
      v96 = 2082;
      v97 = v31;
      v98 = 2082;
      v99 = v34;
      v42 = v40;
      v43 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s: %{public}s%{public}s";
      v46 = 108;
      goto LABEL_61;
    }
    if (v41)
    {
      v47 = (uint8_t *)v66[v27];
      *(_DWORD *)v78 = 136448514;
      v79 = "cti_log_object";
      v80 = 1024;
      v81 = v60;
      v82 = 2082;
      v83 = a1;
      v84 = 2082;
      v85 = v59;
      v86 = 2082;
      v87 = v62;
      v88 = 2082;
      v89 = a4;
      v90 = 2082;
      v91 = v61;
      v92 = 2082;
      v93 = v47;
      v94 = 2082;
      v95 = (uint8_t *)v31;
      v96 = 2082;
      v97 = (const char *)v34;
      v42 = v40;
      v43 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s +%{public}s: %{public}s%{public}s";
      goto LABEL_60;
    }
LABEL_62:
    v29 = 0;
    v30 = 160;
LABEL_63:
    v48 = (void *)*((_QWORD *)v18 + v27);
    if (v48)
    {
      free(v48);
      *((_QWORD *)v18 + v27) = 0;
    }
    ++v27;
  }
  while (count != v27);
  if (buf != (uint8_t *)v28)
  {
    v49 = global_os_log;
    v50 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if ((v29 & 1) != 0)
    {
      if (v50)
      {
        *(_DWORD *)v78 = 136448514;
        v79 = "cti_log_object";
        v80 = 1024;
        v81 = v60;
        v82 = 2082;
        v83 = a1;
        v84 = 2082;
        v85 = v59;
        v86 = 2082;
        v87 = v62;
        v88 = 2082;
        v89 = a4;
        v90 = 2082;
        v91 = v61;
        v92 = 2082;
        v93 = v58;
        v94 = 2082;
        v95 = buf;
        v96 = 2082;
        v97 = v63;
        v51 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s%{public}s";
        v52 = v49;
        v53 = 98;
        goto LABEL_81;
      }
    }
    else if (v50)
    {
      *(_DWORD *)v78 = 136448258;
      v79 = "cti_log_object";
      v80 = 1024;
      v81 = v60;
      v82 = 2082;
      v83 = a1;
      v84 = 2082;
      v85 = v59;
      v86 = 2082;
      v87 = v62;
      v88 = 2082;
      v89 = a4;
      v90 = 2082;
      v91 = v61;
      v92 = 2082;
      v93 = buf;
      v94 = 2082;
      v95 = (uint8_t *)v63;
      v51 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s + %{public}s%{public}s";
      v52 = v49;
      v53 = 88;
LABEL_81:
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v51, v78, v53);
    }
  }
LABEL_82:
  free(v18);
  v23 = (char *)v66;
  if (v66)
    goto LABEL_16;
}

void cti_connection_finalize(_QWORD *a1)
{
  void *v2;

  v2 = (void *)a1[3];
  if (v2)
    xpc_release(v2);
  free(a1);
}

void __init_connection_block_invoke(uint64_t a1, xpc_object_t object)
{
  cti_event_handler(object, *(_QWORD *)(a1 + 32));
}

void cti_xpc_connection_finalize(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  uint64_t v10;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_DWORD *)(a1 + 80);
    v4 = *(_QWORD *)(a1 + 72);
    v5 = 136446722;
    v6 = "cti_xpc_connection_finalize";
    v7 = 1024;
    v8 = v3;
    v9 = 2082;
    v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] %{public}s", (uint8_t *)&v5, 0x1Cu);
  }
  cti_connection_release_((_QWORD *)a1, 114);
}

void __init_connection_block_invoke_82(uint64_t a1, xpc_object_t object)
{
  cti_event_handler(object, *(_QWORD *)(a1 + 32));
}

void cti_event_handler(xpc_object_t object, uint64_t a2)
{
  xpc_type_t type;
  int v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  uint64_t v9;
  int v10;
  const char *v11;
  const char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint32_t v15;
  NSObject *v16;
  int v17;
  const char *v18;
  NSObject *v19;
  int v20;
  char *v21;
  NSObject *v22;
  int v23;
  xpc_object_t value;
  uint64_t v25;
  int v26;
  const char *v27;
  xpc_object_t v28;
  xpc_object_t v29;
  xpc_object_t v30;
  void *v31;
  xpc_object_t v32;
  void *v33;
  NSObject *v34;
  int v35;
  const char *v36;
  _xpc_connection_s *v37;
  NSObject *v38;
  NSObject *v39;
  int v40;
  const char *v41;
  _xpc_connection_s *v42;
  NSObject *v43;
  uint64_t v44;
  int v45;
  const char *v46;
  uint64_t v47;
  NSObject *v48;
  int v49;
  const char *v50;
  uint64_t v51;
  _QWORD v52[5];
  _QWORD handler[5];
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  int v57;
  __int16 v58;
  const char *string;
  __int16 v60;
  uint64_t v61;

  if (object == &_xpc_error_connection_invalid)
  {
    v16 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(_DWORD *)(a2 + 80);
      v18 = *(const char **)(a2 + 72);
      *(_DWORD *)buf = 136446722;
      v55 = "cti_event_handler";
      v56 = 1024;
      v57 = v17;
      v58 = 2082;
      string = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] (%{public}s): cleanup", buf, 0x1Cu);
    }
    if (*(_QWORD *)(a2 + 8))
    {
      (*(void (**)(uint64_t, void *, uint64_t))(a2 + 56))(a2, &_xpc_error_connection_invalid, 4294901727);
    }
    else
    {
      v19 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v20 = *(_DWORD *)(a2 + 80);
        *(_DWORD *)buf = 136446466;
        v55 = "cti_event_handler";
        v56 = 1024;
        v57 = v20;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] No callback", buf, 0x12u);
      }
    }
    v21 = *(char **)(a2 + 16);
    if (v21)
    {
      v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v23 = *(_DWORD *)(a2 + 80);
        *(_DWORD *)buf = 136446722;
        v55 = "cti_event_handler";
        v56 = 1024;
        v57 = v23;
        v58 = 2048;
        string = v21;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] releasing connection %p", buf, 0x1Cu);
        v21 = *(char **)(a2 + 16);
      }
      xpc_release(v21);
      *(_QWORD *)(a2 + 16) = 0;
    }
  }
  else if (*(_QWORD *)(a2 + 16))
  {
    type = xpc_get_type(object);
    v5 = *(_DWORD *)(a2 + 80);
    v6 = *(_QWORD *)(a2 + 72);
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      cti_log_object((uint64_t)"cti_event_handler", v5, v6, (uint64_t)&unk_10007C3B5, (uint64_t)&unk_10007C3B5, object, (const char *)&unk_10007C3B5);
      if (*(_BYTE *)(a2 + 84))
      {
        (*(void (**)(uint64_t, xpc_object_t, _QWORD))(a2 + 56))(a2, object, 0);
      }
      else
      {
        value = xpc_dictionary_get_value(object, "commandResult");
        if (value)
        {
          if (xpc_int64_get_value(value)
            || (v28 = xpc_dictionary_get_value(object, "commandData")) != 0
            && (v29 = xpc_dictionary_get_value(v28, "ret")) != 0
            && xpc_int64_get_value(v29))
          {
            (*(void (**)(uint64_t, xpc_object_t, uint64_t))(a2 + 56))(a2, object, 4294901759);
            v25 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              goto LABEL_11;
            v26 = *(_DWORD *)(a2 + 80);
            v27 = *(const char **)(a2 + 16);
            *(_DWORD *)buf = 136446722;
            v55 = "cti_event_handler";
            v56 = 1024;
            v57 = v26;
            v58 = 2048;
            string = v27;
            v12 = "%{public}s: [CX%d] canceling xpc connection %p";
            v13 = v25;
LABEL_9:
            v14 = OS_LOG_TYPE_DEFAULT;
            v15 = 28;
LABEL_10:
            _os_log_impl((void *)&_mh_execute_header, v13, v14, v12, buf, v15);
            goto LABEL_11;
          }
        }
        if (*(_QWORD *)(a2 + 40))
        {
          v30 = xpc_dictionary_create(0, 0, 0);
          if (!v30)
          {
            v44 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_11;
            v45 = *(_DWORD *)(a2 + 80);
            v46 = *(const char **)(a2 + 72);
            v47 = *(_QWORD *)(a2 + 16);
            *(_DWORD *)buf = 136446978;
            v55 = "cti_event_handler";
            v56 = 1024;
            v57 = v45;
            v58 = 2082;
            string = v46;
            v60 = 2048;
            v61 = v47;
            v12 = "%{public}s: [CX%d] cti_event_handler(%{public}s): no memory, canceling %p.";
            v13 = v44;
            v14 = OS_LOG_TYPE_ERROR;
            v15 = 38;
            goto LABEL_10;
          }
          v31 = v30;
          v32 = xpc_array_create(0, 0);
          if (v32)
          {
            v33 = v32;
            xpc_dictionary_set_string(v31, "command", "eventsOn");
            xpc_dictionary_set_string(v31, "clientName", "srp-mdns-proxy");
            xpc_dictionary_set_value(v31, "eventList", v33);
            xpc_array_set_string(v33, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a2 + 40));
            *(_QWORD *)(a2 + 40) = 0;
            cti_log_object((uint64_t)"cti_event_handler/events on", *(_DWORD *)(a2 + 80), *(_QWORD *)(a2 + 72), (uint64_t)&unk_10007C3B5, (uint64_t)&unk_10007C3B5, v31, (const char *)&unk_10007C3B5);
            v34 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v35 = *(_DWORD *)(a2 + 80);
              v36 = *(const char **)(a2 + 16);
              *(_DWORD *)buf = 136446722;
              v55 = "cti_event_handler";
              v56 = 1024;
              v57 = v35;
              v58 = 2048;
              string = v36;
              _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] sending message on connection %p", buf, 0x1Cu);
            }
            v37 = *(_xpc_connection_s **)(a2 + 16);
            v38 = *(NSObject **)(a2 + 32);
            handler[0] = _NSConcreteStackBlock;
            handler[1] = 0x40000000;
            handler[2] = __cti_event_handler_block_invoke;
            handler[3] = &__block_descriptor_tmp_120;
            handler[4] = a2;
            xpc_connection_send_message_with_reply(v37, v31, v38, handler);
            xpc_release(v33);
          }
          else
          {
            v48 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              v49 = *(_DWORD *)(a2 + 80);
              v50 = *(const char **)(a2 + 72);
              v51 = *(_QWORD *)(a2 + 16);
              *(_DWORD *)buf = 136446978;
              v55 = "cti_event_handler";
              v56 = 1024;
              v57 = v49;
              v58 = 2082;
              string = v50;
              v60 = 2048;
              v61 = v51;
              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] cti_event_handler(%{public}s): no memory, canceling %p.", buf, 0x26u);
            }
            xpc_connection_cancel(*(xpc_connection_t *)(a2 + 16));
          }
        }
        else
        {
          v31 = *(void **)(a2 + 24);
          *(_QWORD *)(a2 + 24) = 0;
          cti_log_object((uint64_t)"cti_event_handler/command is", *(_DWORD *)(a2 + 80), *(_QWORD *)(a2 + 72), (uint64_t)&unk_10007C3B5, (uint64_t)&unk_10007C3B5, v31, (const char *)&unk_10007C3B5);
          *(_BYTE *)(a2 + 84) = 1;
          v39 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v40 = *(_DWORD *)(a2 + 80);
            v41 = *(const char **)(a2 + 16);
            *(_DWORD *)buf = 136446722;
            v55 = "cti_event_handler";
            v56 = 1024;
            v57 = v40;
            v58 = 2048;
            string = v41;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] sending message on connection %p", buf, 0x1Cu);
          }
          v42 = *(_xpc_connection_s **)(a2 + 16);
          v43 = *(NSObject **)(a2 + 32);
          v52[0] = _NSConcreteStackBlock;
          v52[1] = 0x40000000;
          v52[2] = __cti_event_handler_block_invoke_122;
          v52[3] = &__block_descriptor_tmp_123;
          v52[4] = a2;
          xpc_connection_send_message_with_reply(v42, v31, v43, v52);
        }
        xpc_release(v31);
      }
    }
    else
    {
      cti_log_object((uint64_t)"cti_event_handler/other", v5, v6, (uint64_t)&unk_10007C3B5, (uint64_t)&unk_10007C3B5, object, (const char *)&unk_10007C3B5);
      v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v8 = *(_DWORD *)(a2 + 80);
        *(_DWORD *)buf = 136446722;
        v55 = "cti_event_handler";
        v56 = 1024;
        v57 = v8;
        v58 = 2082;
        string = xpc_dictionary_get_string(object, _xpc_error_key_description);
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] cti_event_handler: Unexpected Connection Error [%{public}s]", buf, 0x1Cu);
      }
      (*(void (**)(uint64_t, _QWORD, uint64_t))(a2 + 56))(a2, 0, 4294901733);
      if (object != &_xpc_error_connection_interrupted)
      {
        v9 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
LABEL_11:
          xpc_connection_cancel(*(xpc_connection_t *)(a2 + 16));
          return;
        }
        v10 = *(_DWORD *)(a2 + 80);
        v11 = *(const char **)(a2 + 16);
        *(_DWORD *)buf = 136446722;
        v55 = "cti_event_handler";
        v56 = 1024;
        v57 = v10;
        v58 = 2048;
        string = v11;
        v12 = "%{public}s: [CX%d] canceling xpc connection %p";
        v13 = v9;
        goto LABEL_9;
      }
    }
  }
  else
  {
    cti_log_object((uint64_t)"cti_event_handler NULL connection", *(_DWORD *)(a2 + 80), *(_QWORD *)(a2 + 72), (uint64_t)&unk_10007C3B5, (uint64_t)&unk_10007C3B5, object, (const char *)&unk_10007C3B5);
  }
}

uint64_t __cti_event_handler_block_invoke(int a1, xpc_object_t object)
{
  return cti_event_handler(object);
}

uint64_t __cti_event_handler_block_invoke_122(int a1, xpc_object_t object)
{
  return cti_event_handler(object);
}

void cti_connection_release_(_QWORD *a1, int a2)
{
  int v4;
  NSObject *v5;
  NSObject *v6;
  const char *v7;
  int v8;
  const char *v9;
  __int16 v10;
  _BYTE v11[34];
  __int16 v12;
  int v13;

  a1[1] = 0;
  v4 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_15;
    v8 = 136447490;
    v9 = "cti_connection_release_";
    v10 = 1024;
    *(_DWORD *)v11 = 0;
    *(_WORD *)&v11[4] = 2048;
    *(_QWORD *)&v11[6] = a1;
    *(_WORD *)&v11[14] = 2080;
    *(_QWORD *)&v11[16] = "ref";
    *(_WORD *)&v11[24] = 2080;
    *(_QWORD *)&v11[26] = "cti-services.c";
    v12 = 1024;
    v13 = a2;
    v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_14;
  }
  v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_15;
    v8 = 136447490;
    v9 = "cti_connection_release_";
    v10 = 1024;
    *(_DWORD *)v11 = v4;
    *(_WORD *)&v11[4] = 2048;
    *(_QWORD *)&v11[6] = a1;
    *(_WORD *)&v11[14] = 2080;
    *(_QWORD *)&v11[16] = "ref";
    *(_WORD *)&v11[24] = 2080;
    *(_QWORD *)&v11[26] = "cti-services.c";
    v12 = 1024;
    v13 = a2;
    v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v7, (uint8_t *)&v8, 0x36u);
LABEL_15:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v8 = 136447490;
    v9 = "cti_connection_release_";
    v10 = 1024;
    *(_DWORD *)v11 = v4;
    *(_WORD *)&v11[4] = 2048;
    *(_QWORD *)&v11[6] = a1;
    *(_WORD *)&v11[14] = 2080;
    *(_QWORD *)&v11[16] = "ref";
    *(_WORD *)&v11[24] = 2080;
    *(_QWORD *)&v11[26] = "cti-services.c";
    v12 = 1024;
    v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v8, 0x36u);
    v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 - 1;
  if (v4 == 1)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v8 = 136447234;
      v9 = "cti_connection_release_";
      v10 = 2048;
      *(_QWORD *)v11 = a1;
      *(_WORD *)&v11[8] = 2080;
      *(_QWORD *)&v11[10] = "ref";
      *(_WORD *)&v11[18] = 2080;
      *(_QWORD *)&v11[20] = "cti-services.c";
      *(_WORD *)&v11[28] = 1024;
      *(_DWORD *)&v11[30] = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v8, 0x30u);
    }
    ++cti_connection_finalized;
    cti_connection_finalize(a1);
  }
}

uint64_t __cti_log_object_block_invoke(uint64_t a1, int a2, xpc_object_t object)
{
  xpc_type_t type;
  _QWORD applier[5];

  type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    **(_BYTE **)(a1 + 32) = 0;
  }
  else if (type == (xpc_type_t)&_xpc_type_array)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = __cti_log_object_block_invoke_2;
    applier[3] = &__block_descriptor_tmp_87;
    applier[4] = *(_QWORD *)(a1 + 32);
    xpc_array_apply(object, applier);
  }
  return 1;
}

uint64_t __cti_log_object_block_invoke_3(uint64_t a1, int a2, xpc_object_t object)
{
  xpc_type_t type;

  type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary || type == (xpc_type_t)&_xpc_type_array)
    **(_BYTE **)(a1 + 32) = 0;
  return 1;
}

uint64_t __cti_log_object_block_invoke_93(uint64_t a1, uint64_t a2, void *a3)
{
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * **(int **)(a1 + 40)) = cti_xpc_copy_description(a3);
  *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8 * (int)(**(_DWORD **)(a1 + 40))++) = a2;
  return 1;
}

uint64_t __cti_log_object_block_invoke_2_95(uint64_t a1, uint64_t a2, void *a3)
{
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * a2) = cti_xpc_copy_description(a3);
  return 1;
}

uint64_t __cti_log_object_block_invoke_102(uint64_t a1, int a2, xpc_object_t object)
{
  cti_log_object(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 56), *(_QWORD *)(a1 + 40), a2, (int)": ", object);
  return 1;
}

uint64_t __cti_log_object_block_invoke_2_105(uint64_t a1, uint64_t a2, void *a3)
{
  char __str[23];

  snprintf(__str, 0x17uLL, "%zd", a2);
  cti_log_object(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 56), *(_QWORD *)(a1 + 40), (int)__str, (int)": ", a3);
  return 1;
}

char *cti_xpc_copy_description(void *a1)
{
  xpc_type_t type;
  size_t count;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  const char *v8;
  _BYTE *v9;
  uint64_t v10;
  char *v11;
  const char *v12;
  const char *v13;
  const char *v14;
  size_t v15;
  void *v16;
  const char *string_ptr;
  size_t length;
  _BYTE *v20;
  size_t v21;
  unsigned __int8 *bytes_ptr;
  size_t v23;
  _WORD *v24;
  char *v25;
  int v26;
  _QWORD applier[5];
  char __str[23];

  type = xpc_get_type(a1);
  if (type == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_uint64_get_value(a1);
    snprintf(__str, 0x17uLL, "%llu");
    return strdup(__str);
  }
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    xpc_int64_get_value(a1);
    snprintf(__str, 0x17uLL, "%lld");
    return strdup(__str);
  }
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    length = xpc_string_get_length(a1);
    v20 = malloc_type_malloc(length + 3, 0x198576CCuLL);
    if (!v20)
      return xpc_copy_description(a1);
    v9 = v20;
    *v20 = 34;
    v21 = length + 1;
    strlcpy(v20 + 1, string_ptr, v21);
    *(_WORD *)&v9[v21] = 34;
    return v9;
  }
  if (type == (xpc_type_t)&_xpc_type_data)
  {
    bytes_ptr = (unsigned __int8 *)xpc_data_get_bytes_ptr(a1);
    v23 = xpc_data_get_length(a1);
    v24 = malloc_type_malloc(2 * v23 + 3, 0xE248474CuLL);
    if (v24)
    {
      v9 = v24;
      *v24 = 30768;
      if (v23)
      {
        v25 = (char *)v24;
        do
        {
          v26 = *bytes_ptr++;
          snprintf(v25, 3uLL, "%02x", v26);
          v25 += 2;
          --v23;
        }
        while (v23);
      }
      return v9;
    }
    return xpc_copy_description(a1);
  }
  if (type != (xpc_type_t)&_xpc_type_BOOL)
  {
    if (type == (xpc_type_t)&_xpc_type_array)
    {
      count = xpc_array_get_count(a1);
      v4 = malloc_type_malloc(8 * count, 0x10040436913F5uLL);
      if (!v4)
        return 0;
      v5 = v4;
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = __cti_xpc_copy_description_block_invoke;
      applier[3] = &__block_descriptor_tmp_113_233;
      applier[4] = v4;
      xpc_array_apply(a1, applier);
      if (count)
      {
        v6 = 0;
        v7 = 0;
        do
        {
          v8 = (const char *)v5[v6];
          if (v8)
            v7 += strlen(v8) + 2;
          else
            v7 += 6;
          ++v6;
        }
        while (count != v6);
        v9 = malloc_type_malloc(v7 + 3, 0xFD0AE542uLL);
        v10 = 0;
        *v9 = 91;
        v11 = v9 + 1;
        do
        {
          if (v11)
          {
            v12 = " ";
            if (!v10)
              v12 = (const char *)&unk_10007C3B5;
            v13 = (const char *)v5[v10];
            if (!v13)
              v13 = "NULL";
            if (count - 1 == v10)
              v14 = (const char *)&unk_10007C3B5;
            else
              v14 = ",";
            snprintf(v11, v7, "%s%s%s", v12, v13, v14);
            v15 = strlen(v11);
            v11 += v15;
            v7 -= v15;
          }
          v16 = (void *)v5[v10];
          if (v16)
            free(v16);
          ++v10;
        }
        while (count != v10);
      }
      else
      {
        v9 = malloc_type_malloc(3uLL, 0xFD0AE542uLL);
        *v9 = 91;
        v11 = v9 + 1;
      }
      *(_WORD *)v11 = 93;
      free(v5);
      return v9;
    }
    return xpc_copy_description(a1);
  }
  if (xpc_BOOL_get_value(a1))
    return strdup("true");
  else
    return strdup("false");
}

uint64_t __cti_xpc_copy_description_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8 * a2) = cti_xpc_copy_description(a3);
  return 1;
}

uint64_t __cti_log_object_block_invoke_2(uint64_t a1, int a2, xpc_object_t object)
{
  xpc_type_t type;

  type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary || type == (xpc_type_t)&_xpc_type_array)
    **(_BYTE **)(a1 + 32) = 0;
  return 1;
}

void cti_internal_event_reply_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  NSObject *v5;
  int v6;
  void (*v7)(_QWORD, uint64_t);
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;

  v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a1)
      v6 = *(_DWORD *)(a1 + 80);
    else
      v6 = 0;
    v8 = 136446722;
    v9 = "cti_internal_event_reply_callback";
    v10 = 1024;
    v11 = v6;
    v12 = 2048;
    v13 = a1;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] conn_ref = %p", (uint8_t *)&v8, 0x1Cu);
  }
  v7 = *(void (**)(_QWORD, uint64_t))(a1 + 8);
  if (v7)
    v7(*(_QWORD *)(a1 + 64), a3);
}

uint64_t cti_get_tunnel_name_(uint64_t a1, uint64_t a2, char *a3, int a4)
{
  xpc_object_t v8;
  uint64_t v9;

  v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "PropGet");
  xpc_dictionary_set_string(v8, "property_name", "Config:TUN:InterfaceName");
  v9 = setup_for_command(0, (uint64_t)"get_tunnel_name", 0, (uint64_t)"Config:TUN:InterfaceName", v8, a1, a2, (uint64_t)cti_internal_string_property_reply, 0, a3, a4);
  xpc_release(v8);
  return v9;
}

void cti_internal_string_property_reply(uint64_t a1, void *a2, uint64_t a3)
{
  _xpc_connection_s *v4;
  NSObject *v5;
  int v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  cti_internal_string_event_reply(a1, a2, a3);
  *(_QWORD *)(a1 + 8) = 0;
  v4 = *(_xpc_connection_s **)(a1 + 16);
  if (v4)
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *(_DWORD *)(a1 + 80);
      v11 = 136446722;
      v12 = "cti_internal_string_property_reply";
      v13 = 1024;
      *(_DWORD *)v14 = v6;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] canceling connection %p", (uint8_t *)&v11, 0x1Cu);
      v4 = *(_xpc_connection_s **)(a1 + 16);
    }
    xpc_connection_cancel(v4);
  }
  v7 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_19;
    v11 = 136447490;
    v12 = "cti_internal_string_property_reply";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "conn_ref";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = "cti-services.c";
    v15 = 1024;
    v16 = 925;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_18;
  }
  v8 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_19;
    v11 = 136447490;
    v12 = "cti_internal_string_property_reply";
    v13 = 1024;
    *(_DWORD *)v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "conn_ref";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = "cti-services.c";
    v15 = 1024;
    v16 = 925;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_19:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "cti_internal_string_property_reply";
    v13 = 1024;
    *(_DWORD *)v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "conn_ref";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = "cti-services.c";
    v15 = 1024;
    v16 = 925;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v7 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v7 - 1;
  if (v7 == 1)
  {
    v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136447234;
      v12 = "cti_internal_string_property_reply";
      v13 = 2048;
      *(_QWORD *)v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "conn_ref";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = "cti-services.c";
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = 925;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++cti_connection_finalized;
    cti_connection_finalize((_QWORD *)a1);
  }
}

void cti_internal_string_event_reply(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  void (*v6)(_QWORD, const char *, uint64_t);
  const char *v7;
  xpc_object_t value;
  int64_t v9;
  int64_t v10;
  uint64_t v11;
  int v12;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  xpc_object_t dictionary;
  xpc_object_t array;
  void *v18;
  size_t count;
  size_t v20;
  uint64_t v21;
  int v22;
  xpc_object_t v23;
  void *v24;
  const char *v25;
  int v26;
  int v27;
  NSObject *v28;
  int v29;
  const char *string;
  int v31;
  int v32;
  const char *v33;
  __int16 v34;
  int v35;
  __int16 v36;
  size_t v37;

  v6 = *(void (**)(_QWORD, const char *, uint64_t))(a1 + 8);
  xpc_retain(object);
  if ((_DWORD)a3)
    goto LABEL_2;
  value = xpc_dictionary_get_value(object, "commandResult");
  if (!value)
  {
    dictionary = xpc_dictionary_get_dictionary(object, "eventData");
    if (dictionary)
    {
      array = xpc_dictionary_get_array(dictionary, "value");
      if (!array)
      {
        v21 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_31;
        v27 = *(_DWORD *)(a1 + 80);
        v32 = 136446466;
        v33 = "cti_internal_string_event_reply";
        v34 = 1024;
        v35 = v27;
        v13 = "%{public}s: [CX%d] eventData dictionary contains no 'value' key";
        goto LABEL_29;
      }
      v18 = array;
      count = xpc_array_get_count(array);
      if (count != 1)
      {
        v20 = count;
        if (!count)
        {
          v21 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_31;
          v22 = *(_DWORD *)(a1 + 80);
          v32 = 136446466;
          v33 = "cti_internal_string_event_reply";
          v34 = 1024;
          v35 = v22;
          v13 = "%{public}s: [CX%d] eventData value array has no elements";
LABEL_29:
          v14 = v21;
          v15 = 18;
          goto LABEL_30;
        }
        v28 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v29 = *(_DWORD *)(a1 + 80);
          v32 = 136446722;
          v33 = "cti_internal_string_event_reply";
          v34 = 1024;
          v35 = v29;
          v36 = 2048;
          v37 = v20;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] eventData value array has %zd elements", (uint8_t *)&v32, 0x1Cu);
        }
      }
      string = xpc_array_get_string(v18, 0);
      if (string)
      {
        v7 = string;
        a3 = 0;
        goto LABEL_32;
      }
      v21 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_31;
      v31 = *(_DWORD *)(a1 + 80);
      v32 = 136446466;
      v33 = "cti_internal_string_event_reply";
      v34 = 1024;
      v35 = v31;
      v13 = "%{public}s: [CX%d] eventData value array's first element is not a string";
      goto LABEL_29;
    }
    v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_31;
    v26 = *(_DWORD *)(a1 + 80);
    v32 = 136446466;
    v33 = "cti_internal_string_event_reply";
    v34 = 1024;
    v35 = v26;
    v13 = "%{public}s: [CX%d] no eventData dictionary";
    goto LABEL_29;
  }
  v9 = xpc_int64_get_value(value);
  if (v9)
  {
    v10 = v9;
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v12 = *(_DWORD *)(a1 + 80);
      v32 = 136446722;
      v33 = "cti_internal_string_event_reply";
      v34 = 1024;
      v35 = v12;
      v36 = 2048;
      v37 = v10;
      v13 = "%{public}s: [CX%d] nonzero result %llu";
      v14 = v11;
      v15 = 28;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v32, v15);
    }
LABEL_31:
    v7 = 0;
    a3 = 4294901759;
    goto LABEL_32;
  }
  v23 = xpc_dictionary_get_dictionary(object, "commandData");
  if (!v23)
    goto LABEL_31;
  v24 = v23;
  v25 = xpc_dictionary_get_string(v23, "property_name");
  if (!v25)
    goto LABEL_31;
  a3 = 4294901759;
  if (strcmp(v25, *(const char **)(a1 + 48)))
  {
LABEL_2:
    v7 = 0;
    goto LABEL_32;
  }
  v7 = xpc_dictionary_get_string(v24, "value");
  if (v7)
    a3 = 0;
  else
    a3 = 4294901759;
LABEL_32:
  if (v6)
    v6(*(_QWORD *)(a1 + 64), v7, a3);
  xpc_release(object);
}

uint64_t cti_track_active_data_set_(_QWORD *a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  xpc_object_t v10;
  uint64_t v11;

  v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v10, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v10, "path", "/org/wpantund/utun2");
  v11 = setup_for_command(a1, (uint64_t)"track_active_data_set", "ActiveDataSetChanged", 0, v10, a2, a3, (uint64_t)cti_internal_event_reply_callback, 1, a4, a5);
  xpc_release(v10);
  return v11;
}

uint64_t cti_internal_state_reply_callback(uint64_t result, void *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t (*v4)(_QWORD, uint64_t, uint64_t);
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  const char *v9;
  _BYTE xdict[12];
  __int16 v11;
  int v12;
  __int16 v13;
  uint64_t v14;

  v3 = result;
  v4 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t))(result + 8);
  if ((_DWORD)a3)
  {
    v5 = a3;
LABEL_5:
    v6 = 12;
    goto LABEL_6;
  }
  *(_QWORD *)xdict = 0;
  result = cti_event_or_response_extract(a2, xdict);
  if ((_DWORD)result)
  {
    v5 = result;
    goto LABEL_5;
  }
  result = (uint64_t)xpc_dictionary_get_string(*(xpc_object_t *)xdict, "value");
  if (!result)
  {
    v5 = 4294901759;
    goto LABEL_5;
  }
  v9 = (const char *)result;
  result = strcmp((const char *)result, "uninitialized");
  if ((_DWORD)result)
  {
    result = strcmp(v9, "uninitialized:fault");
    if ((_DWORD)result)
    {
      result = strcmp(v9, "uninitialized:upgrading");
      if ((_DWORD)result)
      {
        result = strcmp(v9, "offline:deep-sleep");
        if ((_DWORD)result)
        {
          result = strcmp(v9, "offline");
          if ((_DWORD)result)
          {
            result = strcmp(v9, "offline:commissioned");
            if ((_DWORD)result)
            {
              result = strcmp(v9, "associating");
              if ((_DWORD)result)
              {
                result = strcmp(v9, "associating:credentials-needed");
                if ((_DWORD)result)
                {
                  result = strcmp(v9, "associated");
                  if ((_DWORD)result)
                  {
                    result = strcmp(v9, "associated:no-parent");
                    if ((_DWORD)result)
                    {
                      result = strcmp(v9, "associated:netwake-asleep");
                      if ((_DWORD)result)
                      {
                        result = strcmp(v9, "associated:netwake-waking");
                        v5 = 0;
                        if ((_DWORD)result)
                          v6 = 12;
                        else
                          v6 = 11;
                      }
                      else
                      {
                        v5 = 0;
                        v6 = 10;
                      }
                    }
                    else
                    {
                      v5 = 0;
                      v6 = 9;
                    }
                  }
                  else
                  {
                    v5 = 0;
                    v6 = 8;
                  }
                }
                else
                {
                  v5 = 0;
                  v6 = 7;
                }
              }
              else
              {
                v5 = 0;
                v6 = 6;
              }
            }
            else
            {
              v5 = 0;
              v6 = 5;
            }
          }
          else
          {
            v5 = 0;
            v6 = 4;
          }
        }
        else
        {
          v5 = 0;
          v6 = 3;
        }
      }
      else
      {
        v5 = 0;
        v6 = 2;
      }
    }
    else
    {
      v5 = 0;
      v6 = 1;
    }
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }
LABEL_6:
  if (v4)
  {
    v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_DWORD *)(v3 + 80);
      *(_DWORD *)xdict = 136446722;
      *(_QWORD *)&xdict[4] = "cti_internal_state_reply_callback";
      v11 = 1024;
      v12 = v8;
      v13 = 2048;
      v14 = v3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", xdict, 0x1Cu);
    }
    return v4(*(_QWORD *)(v3 + 64), v6, v5);
  }
  return result;
}

uint64_t cti_event_or_response_extract(void *a1, _QWORD *a2)
{
  xpc_object_t dictionary;
  xpc_object_t v5;
  int int64;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  uint32_t v10;
  uint64_t result;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;

  dictionary = xpc_dictionary_get_dictionary(a1, "commandData");
  if (dictionary)
  {
    v5 = dictionary;
    int64 = xpc_dictionary_get_int64(a1, "commandResult");
    if (int64)
    {
      v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v13 = 136446466;
        v14 = "cti_event_or_response_extract";
        v15 = 1024;
        v16 = int64;
        v8 = "%{public}s: nonzero status %d";
        v9 = v7;
        v10 = 18;
LABEL_9:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v13, v10);
        return 4294901759;
      }
      return 4294901759;
    }
LABEL_6:
    result = 0;
    *a2 = v5;
    return result;
  }
  v5 = xpc_dictionary_get_dictionary(a1, "eventData");
  if (v5)
    goto LABEL_6;
  v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v13 = 136446210;
    v14 = "cti_event_or_response_extract";
    v8 = "%{public}s: null result";
    v9 = v12;
    v10 = 12;
    goto LABEL_9;
  }
  return 4294901759;
}

void cti_internal_network_node_type_callback(uint64_t a1, void *a2, uint64_t a3)
{
  void (*v4)(_QWORD, uint64_t, uint64_t);
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  int v8;
  xpc_object_t v9;
  xpc_object_t value;
  void *v11;
  char *v12;
  NSObject *v13;
  int v14;
  NSObject *v15;
  int v16;
  const char *string;
  xpc_object_t xdict;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  char *v24;

  v4 = *(void (**)(_QWORD, uint64_t, uint64_t))(a1 + 8);
  if ((_DWORD)a3)
  {
    v5 = a3;
    goto LABEL_4;
  }
  xdict = 0;
  v5 = cti_event_or_response_extract(a2, &xdict);
  if ((_DWORD)v5)
    goto LABEL_4;
  v9 = xdict;
  value = xpc_dictionary_get_value(xdict, "value");
  if (!value)
  {
    v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v16 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446466;
      v20 = "cti_internal_network_node_type_callback";
      v21 = 1024;
      v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] No node type returned.", buf, 0x12u);
    }
    goto LABEL_4;
  }
  v11 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string)
  {
    v12 = xpc_copy_description(v11);
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v14 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      v20 = "cti_internal_network_node_type_callback";
      v21 = 1024;
      v22 = v14;
      v23 = 2082;
      v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] node type type is %{public}s instead of string.", buf, 0x1Cu);
    }
    free(v12);
    goto LABEL_4;
  }
  string = xpc_dictionary_get_string(v9, "value");
  if (!strcmp(string, "unknown"))
  {
LABEL_4:
    v6 = 0;
    goto LABEL_5;
  }
  if (!strcmp(string, "router"))
  {
    v6 = 1;
  }
  else if (!strcmp(string, "end-device"))
  {
    v6 = 2;
  }
  else if (!strcmp(string, "sleepy-end-device"))
  {
    v6 = 3;
  }
  else if (!strcmp(string, "synchronized-sleepy-end-device"))
  {
    v6 = 4;
  }
  else if (!strcmp(string, "nl-lurker"))
  {
    v6 = 5;
  }
  else if (!strcmp(string, "commissioner"))
  {
    v6 = 6;
  }
  else if (!strcmp(string, "leader"))
  {
    v6 = 7;
  }
  else
  {
    v6 = 8 * (strcmp(string, "sleepy-router") == 0);
  }
LABEL_5:
  if (v4)
  {
    v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v8 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      v20 = "cti_internal_network_node_type_callback";
      v21 = 1024;
      v22 = v8;
      v23 = 2048;
      v24 = (char *)a1;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(_QWORD *)(a1 + 64), v6, v5);
  }
}

void cti_service_vec_finalize(unint64_t *a1)
{
  void *v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  _BYTE v16[34];
  __int16 v17;
  int v18;

  v2 = (void *)a1[2];
  if (!v2)
    goto LABEL_20;
  if (!*a1)
    goto LABEL_19;
  v3 = 0;
  do
  {
    v4 = *(_QWORD *)(a1[2] + 8 * v3);
    if (!v4)
      goto LABEL_17;
    v5 = *(_DWORD *)(v4 + 48);
    if (!v5)
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_26;
      *(_DWORD *)buf = 136447490;
      v14 = "cti_service_vec_finalize";
      v15 = 1024;
      *(_DWORD *)v16 = 0;
      *(_WORD *)&v16[4] = 2048;
      *(_QWORD *)&v16[6] = v4;
      *(_WORD *)&v16[14] = 2080;
      *(_QWORD *)&v16[16] = "services->services[i]";
      *(_WORD *)&v16[24] = 2080;
      *(_QWORD *)&v16[26] = "cti-services.c";
      v17 = 1024;
      v18 = 1280;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v12 = v10;
      goto LABEL_25;
    }
    v6 = global_os_log;
    if (v5 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_26;
      *(_DWORD *)buf = 136447490;
      v14 = "cti_service_vec_finalize";
      v15 = 1024;
      *(_DWORD *)v16 = v5;
      *(_WORD *)&v16[4] = 2048;
      *(_QWORD *)&v16[6] = v4;
      *(_WORD *)&v16[14] = 2080;
      *(_QWORD *)&v16[16] = "services->services[i]";
      *(_WORD *)&v16[24] = 2080;
      *(_QWORD *)&v16[26] = "cti-services.c";
      v17 = 1024;
      v18 = 1280;
      v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v12 = v6;
LABEL_25:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v11, buf, 0x36u);
LABEL_26:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v14 = "cti_service_vec_finalize";
      v15 = 1024;
      *(_DWORD *)v16 = v5;
      *(_WORD *)&v16[4] = 2048;
      *(_QWORD *)&v16[6] = v4;
      *(_WORD *)&v16[14] = 2080;
      *(_QWORD *)&v16[16] = "services->services[i]";
      *(_WORD *)&v16[24] = 2080;
      *(_QWORD *)&v16[26] = "cti-services.c";
      v17 = 1024;
      v18 = 1280;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v4 = *(_QWORD *)(a1[2] + 8 * v3);
      v5 = *(_DWORD *)(v4 + 48);
    }
    *(_DWORD *)(v4 + 48) = v5 - 1;
    if (v5 == 1)
    {
      v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v14 = "cti_service_vec_finalize";
        v15 = 2048;
        *(_QWORD *)v16 = v4;
        *(_WORD *)&v16[8] = 2080;
        *(_QWORD *)&v16[10] = "services->services[i]";
        *(_WORD *)&v16[18] = 2080;
        *(_QWORD *)&v16[20] = "cti-services.c";
        *(_WORD *)&v16[28] = 1024;
        *(_DWORD *)&v16[30] = 1280;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v4 = *(_QWORD *)(a1[2] + 8 * v3);
      }
      ++cti_service_finalized;
      v8 = *(void **)(v4 + 24);
      if (v8)
        free(v8);
      v9 = *(void **)(v4 + 16);
      if (v9)
        free(v9);
      free((void *)v4);
    }
LABEL_17:
    ++v3;
  }
  while (v3 < *a1);
  v2 = (void *)a1[2];
LABEL_19:
  free(v2);
LABEL_20:
  free(a1);
}

_WORD *cti_service_create_(uint64_t a1, __int16 a2, __int16 a3, __int16 a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9, int a10)
{
  _WORD *v18;
  _WORD *v19;
  NSObject *v20;
  int v21;
  int v22;
  int v23;
  NSObject *v24;
  int v26;
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  _WORD *v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  char *v35;
  __int16 v36;
  int v37;

  v18 = malloc_type_calloc(1uLL, 0x38uLL, 0x1010040270935CAuLL);
  v19 = v18;
  if (v18)
  {
    *(_QWORD *)v18 = a1;
    v18[4] = a3;
    v18[5] = a4;
    v18[6] = a2;
    *((_QWORD *)v18 + 2) = a5;
    *((_QWORD *)v18 + 3) = a7;
    *((_QWORD *)v18 + 4) = a6;
    *((_QWORD *)v18 + 5) = a8;
    v18[7] = a9;
    *((_DWORD *)v18 + 13) = a10;
    v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v21 = *((_DWORD *)v19 + 12);
      v26 = 136447490;
      v27 = "cti_service_create_";
      v28 = 1024;
      v29 = v21;
      v30 = 2048;
      v31 = v19;
      v32 = 2080;
      v33 = "service";
      v34 = 2080;
      v35 = "cti-services.c";
      v36 = 1024;
      v37 = 1512;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
    }
    v22 = *((_DWORD *)v19 + 12);
    if (v22)
    {
      v23 = v22 + 1;
      *((_DWORD *)v19 + 12) = v22 + 1;
      if (v22 + 1 >= 10001)
      {
        v24 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v26 = 136447490;
          v27 = "cti_service_create_";
          v28 = 1024;
          v29 = v23;
          v30 = 2048;
          v31 = v19;
          v32 = 2080;
          v33 = "service";
          v34 = 2080;
          v35 = "cti-services.c";
          v36 = 1024;
          v37 = 1512;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++cti_service_created;
      *((_DWORD *)v19 + 12) = 1;
    }
  }
  return v19;
}

void cti_internal_service_reply_callback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3;
  void (*v4)(_QWORD, _QWORD, _QWORD);
  void *v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  NSObject *v9;
  int v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  xpc_object_t array;
  void *v15;
  size_t count;
  void *v17;
  NSObject *v18;
  int v19;
  int v20;
  int v21;
  NSObject *v22;
  int v23;
  size_t v24;
  xpc_object_t value;
  void *v26;
  size_t v27;
  size_t v28;
  char v29;
  int v30;
  size_t v31;
  xpc_object_t v32;
  void *v33;
  const char *string;
  const char *v35;
  NSObject *v36;
  const char *v37;
  const char *v38;
  xpc_object_t v39;
  xpc_object_t v40;
  unsigned __int8 *v41;
  NSObject *v42;
  NSObject *v43;
  uint64_t v44;
  NSObject *v45;
  NSObject *v46;
  os_log_type_t v47;
  const char *v48;
  NSObject *v49;
  _WORD *v50;
  int v51;
  int v52;
  uint64_t v53;
  NSObject *v54;
  const char *v55;
  uint32_t v56;
  NSObject *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  NSObject *v63;
  uint64_t v64;
  int v65;
  NSObject *v66;
  const char *v67;
  void (*v68)(_QWORD, _QWORD, _QWORD);
  uint64_t v69;
  void *v70;
  char v71;
  size_t v72;
  char v73;
  __int16 int64;
  __int16 v75;
  uint64_t v76;
  unsigned __int8 *v77;
  uint64_t v78;
  _BYTE *v79;
  int v80;
  uint64_t uint64;
  xpc_object_t xdict;
  uint64_t v83;
  uint64_t v84;
  uint8_t buf[4];
  const char *v86;
  __int16 v87;
  _BYTE v88[34];
  __int16 v89;
  int v90;

  v3 = a1;
  v4 = *(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 8);
  v5 = &dnssd_client_states;
  if ((_DWORD)a3)
  {
    v6 = a3;
    goto LABEL_5;
  }
  xdict = 0;
  v7 = cti_event_or_response_extract(a2, &xdict);
  if ((_DWORD)v7)
  {
    v6 = v7;
    goto LABEL_5;
  }
  array = xpc_dictionary_get_array(xdict, "value");
  if (!array)
  {
    v22 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v23 = *(_DWORD *)(v3 + 80);
      *(_DWORD *)buf = 136446466;
      v86 = "cti_internal_service_reply_callback";
      v87 = 1024;
      *(_DWORD *)v88 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] services array not present in Thread:Services event.", buf, 0x12u);
    }
    v8 = 0;
    goto LABEL_33;
  }
  v15 = array;
  v6 = 4294901757;
  count = xpc_array_get_count(array);
  v8 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1080040216EE090uLL);
  if (!v8)
    goto LABEL_6;
  if (count)
  {
    v17 = malloc_type_calloc(count, 8uLL, 0x2004093837F09uLL);
    *((_QWORD *)v8 + 2) = v17;
    if (!v17)
    {
      free(v8);
      goto LABEL_5;
    }
  }
  *(_QWORD *)v8 = count;
  v18 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v19 = v8[2];
    *(_DWORD *)buf = 136447490;
    v86 = "cti_service_vec_create_";
    v87 = 1024;
    *(_DWORD *)v88 = v19;
    *(_WORD *)&v88[4] = 2048;
    *(_QWORD *)&v88[6] = v8;
    *(_WORD *)&v88[14] = 2080;
    *(_QWORD *)&v88[16] = "services";
    *(_WORD *)&v88[24] = 2080;
    *(_QWORD *)&v88[26] = "cti-services.c";
    v89 = 1024;
    v90 = 1370;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v20 = v8[2];
  if (v20)
  {
    v21 = v20 + 1;
    v8[2] = v20 + 1;
    if (v20 + 1 >= 10001)
    {
      v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v86 = "cti_service_vec_create_";
        v87 = 1024;
        *(_DWORD *)v88 = v21;
        *(_WORD *)&v88[4] = 2048;
        *(_QWORD *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(_QWORD *)&v88[16] = "services";
        *(_WORD *)&v88[24] = 2080;
        *(_QWORD *)&v88[26] = "cti-services.c";
        v89 = 1024;
        v90 = 1370;
        v67 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    if (!count)
    {
LABEL_33:
      v6 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    ++cti_service_vec_created;
    v8[2] = 1;
    if (!count)
      goto LABEL_33;
  }
  v68 = v4;
  v69 = v3;
  v6 = 0;
  v24 = 0;
  v70 = v15;
  v72 = count;
  do
  {
    value = xpc_array_get_value(v15, v24);
    v83 = 0;
    v84 = 0;
    if (value)
    {
      v26 = value;
      v27 = xpc_array_get_count(value);
      if (v27)
      {
        v28 = v27;
        int64 = 0;
        v75 = 0;
        v80 = 0;
        v76 = 0;
        v77 = 0;
        v78 = 0;
        v79 = 0;
        uint64 = 0;
        v73 = 0;
        v71 = 0;
        v29 = 0;
        v30 = 0;
        v31 = 0;
        while (1)
        {
          v32 = xpc_array_get_value(v26, v31);
          if (!v32)
          {
            v5 = &dnssd_client_states;
            v49 = global_os_log;
            count = v72;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              v86 = "cti_parse_services_array";
              v87 = 2048;
              *(_QWORD *)v88 = v24;
              *(_WORD *)&v88[8] = 2048;
              *(_QWORD *)&v88[10] = v31;
              _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%{public}s: can't get service_array %zd subdictionary %zd", buf, 0x20u);
            }
            v15 = v70;
            goto LABEL_119;
          }
          v33 = v32;
          string = xpc_dictionary_get_string(v32, "key");
          if (!string)
          {
            v5 = &dnssd_client_states;
            v53 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_118;
            *(_DWORD *)buf = 136446722;
            v86 = "cti_parse_services_array";
            v87 = 2048;
            *(_QWORD *)v88 = v24;
            *(_WORD *)&v88[8] = 2048;
            *(_QWORD *)&v88[10] = v31;
            v54 = v53;
            v55 = "%{public}s: Invalid services array %zd subdictionary %zd: no key";
            v56 = 32;
            goto LABEL_117;
          }
          v35 = string;
          if (!strcmp(string, "EnterpriseNumber"))
          {
            if ((v29 & 1) != 0)
            {
              v5 = &dnssd_client_states;
              v58 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_118;
              *(_DWORD *)buf = 136446466;
              v86 = "cti_parse_services_array";
              v87 = 2048;
              *(_QWORD *)v88 = v24;
              v54 = v58;
              v55 = "%{public}s: services array %zd: Enterprise number appears twice.";
              goto LABEL_116;
            }
            uint64 = xpc_dictionary_get_uint64(v33, "value");
            v29 = 1;
          }
          else if (!strcmp(v35, "Origin"))
          {
            if ((v78 & 0x100000000) != 0)
            {
              v5 = &dnssd_client_states;
              v59 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_118;
              *(_DWORD *)buf = 136446466;
              v86 = "cti_parse_services_array";
              v87 = 2048;
              *(_QWORD *)v88 = v24;
              v54 = v59;
              v55 = "%{public}s: Services array %zd: Origin appears twice.";
              goto LABEL_116;
            }
            v37 = xpc_dictionary_get_string(v33, "value");
            if (!v37)
            {
              v5 = &dnssd_client_states;
              v60 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_118;
              *(_DWORD *)buf = 136446466;
              v86 = "cti_parse_services_array";
              v87 = 2048;
              *(_QWORD *)v88 = v24;
              v54 = v60;
              v55 = "%{public}s: Unable to get origin string from services array %zd";
              goto LABEL_116;
            }
            v38 = v37;
            if (strcmp(v37, "user"))
            {
              if (strcmp(v38, "ncp"))
              {
                v5 = &dnssd_client_states;
                v62 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  goto LABEL_118;
                *(_DWORD *)buf = 136446466;
                v86 = "cti_parse_services_array";
                v87 = 2082;
                *(_QWORD *)v88 = v38;
                v54 = v62;
                v55 = "%{public}s: unknown origin %{public}s";
                goto LABEL_116;
              }
              v80 |= 2u;
            }
            BYTE4(v78) = 1;
          }
          else if (!strcmp(v35, "ServerData"))
          {
            if ((v78 & 1) != 0)
            {
              v5 = &dnssd_client_states;
              v61 = global_os_log;
              v15 = v70;
              count = v72;
              v41 = v77;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_120;
              *(_DWORD *)buf = 136446466;
              v86 = "cti_parse_services_array";
              v87 = 2048;
              *(_QWORD *)v88 = v24;
              v46 = v61;
              v47 = OS_LOG_TYPE_ERROR;
              v48 = "%{public}s: Services array %zd: Server data appears twice.";
LABEL_103:
              _os_log_impl((void *)&_mh_execute_header, v46, v47, v48, buf, 0x16u);
              goto LABEL_120;
            }
            v39 = xpc_dictionary_get_array(v33, "value");
            v79 = cti_array_to_bytes(v39, (size_t *)&v84, (uint64_t)"Server data");
            if (!v79)
            {
              v79 = 0;
              v5 = &dnssd_client_states;
              goto LABEL_118;
            }
            LOBYTE(v78) = 1;
          }
          else if (!strcmp(v35, "ServiceData"))
          {
            if ((v76 & 1) != 0)
            {
              v5 = &dnssd_client_states;
              v63 = global_os_log;
              v15 = v70;
              count = v72;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v86 = "cti_parse_services_array";
                v87 = 2048;
                *(_QWORD *)v88 = v24;
                _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%{public}s: Services array %zd: Service data appears twice.", buf, 0x16u);
              }
              goto LABEL_119;
            }
            v40 = xpc_dictionary_get_array(v33, "value");
            v77 = cti_array_to_bytes(v40, (size_t *)&v83, (uint64_t)"Service data");
            if (!v77)
            {
              v41 = 0;
              v5 = &dnssd_client_states;
              v15 = v70;
              count = v72;
              goto LABEL_120;
            }
            LOBYTE(v76) = 1;
          }
          else if (!strcmp(v35, "Stable"))
          {
            if ((v73 & 1) != 0)
            {
              v5 = &dnssd_client_states;
              v64 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_118;
              goto LABEL_115;
            }
            v80 |= xpc_dictionary_get_BOOL(v33, "value");
            v73 = 1;
          }
          else if (!strcmp(v35, "RLOC16"))
          {
            if ((v71 & 1) != 0)
            {
              v5 = &dnssd_client_states;
              v64 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_118;
LABEL_115:
              *(_DWORD *)buf = 136446466;
              v86 = "cti_parse_services_array";
              v87 = 2048;
              *(_QWORD *)v88 = v24;
              v54 = v64;
              v55 = "%{public}s: Services array %zd: Stable state appears twice.";
LABEL_116:
              v56 = 22;
LABEL_117:
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, v55, buf, v56);
              goto LABEL_118;
            }
            v75 = xpc_dictionary_get_uint64(v33, "value");
            v71 = 1;
          }
          else
          {
            if (strcmp(v35, "ServiceId"))
            {
              v36 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                v86 = "cti_parse_services_array";
                v87 = 2048;
                *(_QWORD *)v88 = v24;
                *(_WORD *)&v88[8] = 2048;
                *(_QWORD *)&v88[10] = v31;
                *(_WORD *)&v88[18] = 2082;
                *(_QWORD *)&v88[20] = v35;
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: Unknown key in service array %zd subdictionary %zd: %{public}s", buf, 0x2Au);
              }
              goto LABEL_71;
            }
            if ((v76 & 0x100000000) != 0)
            {
              v5 = &dnssd_client_states;
              v64 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_115;
LABEL_118:
              v15 = v70;
              count = v72;
LABEL_119:
              v41 = v77;
              goto LABEL_120;
            }
            int64 = xpc_dictionary_get_int64(v33, "value");
            BYTE4(v76) = 1;
          }
          ++v30;
LABEL_71:
          if (v28 == ++v31)
          {
            v5 = &dnssd_client_states;
            v15 = v70;
            count = v72;
            v41 = v77;
            if (v30 != 7)
              goto LABEL_77;
            goto LABEL_81;
          }
        }
      }
      int64 = 0;
      v75 = 0;
      v80 = 0;
      v41 = 0;
      v79 = 0;
      uint64 = 0;
      BYTE4(v76) = 0;
      v30 = 0;
      count = v72;
LABEL_77:
      v43 = *((_QWORD *)v5 + 306);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v86 = "cti_parse_services_array";
        v87 = 1024;
        *(_DWORD *)v88 = 7;
        *(_WORD *)&v88[4] = 2048;
        *(_QWORD *)&v88[6] = v24;
        *(_WORD *)&v88[14] = 1024;
        *(_DWORD *)&v88[16] = v30;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%{public}s: expecting %d sub-dictionaries to service array %zd, but got %d.", buf, 0x22u);
      }
      if (v30 < 6 || ((v30 == 6) & BYTE4(v76)) != 0)
        goto LABEL_120;
LABEL_81:
      v44 = v83;
      if (uint64 == 44970)
      {
        if ((unint64_t)(v83 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          v45 = *((_QWORD *)v5 + 306);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            v86 = "cti_parse_services_array";
            v87 = 2048;
            *(_QWORD *)v88 = v44;
            v46 = v45;
            v47 = OS_LOG_TYPE_DEFAULT;
            v48 = "%{public}s: Invalid service data: length = %zd";
            goto LABEL_103;
          }
LABEL_120:
          if ((_DWORD)v6)
            v6 = v6;
          else
            v6 = 4294901759;
          goto LABEL_123;
        }
        v51 = *v41;
        v52 = 1;
        v50 = cti_service_create_(44970, v75, *v41, 1, (uint64_t)v41, v83, (uint64_t)v79, v84, int64, v80);
        if (v50)
        {
LABEL_89:
          *(_QWORD *)(*((_QWORD *)v8 + 2) + 8 * v24) = v50;
          goto LABEL_127;
        }
      }
      else
      {
        v50 = cti_service_create_(uint64, v75, 0, 0, (uint64_t)v41, v83, (uint64_t)v79, v84, int64, v80);
        v51 = 0;
        v52 = 0;
        if (v50)
          goto LABEL_89;
      }
      v57 = *((_QWORD *)v5 + 306);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        v86 = "cti_parse_services_array";
        v87 = 2048;
        *(_QWORD *)v88 = uint64;
        *(_WORD *)&v88[8] = 1024;
        *(_DWORD *)&v88[10] = v51;
        *(_WORD *)&v88[14] = 1024;
        *(_DWORD *)&v88[16] = v52;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%{public}s: Unable to store service %lld %d %d: out of memory.", buf, 0x22u);
      }
LABEL_123:
      if (v79)
        free(v79);
      if (v41)
        free(v41);
      goto LABEL_127;
    }
    v42 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v86 = "cti_parse_services_array";
      v87 = 2048;
      *(_QWORD *)v88 = v24;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%{public}s: Unable to get service array %zd", buf, 0x16u);
    }
LABEL_127:
    ++v24;
  }
  while (v24 != count);
  if ((_DWORD)v6)
  {
    v65 = v8[2];
    v3 = v69;
    if (v65)
    {
      v12 = *((_QWORD *)v5 + 306);
      if (v65 < 10001)
      {
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v86 = "cti_parse_services_array";
          v87 = 1024;
          *(_DWORD *)v88 = v65;
          *(_WORD *)&v88[4] = 2048;
          *(_QWORD *)&v88[6] = v8;
          *(_WORD *)&v88[14] = 2080;
          *(_QWORD *)&v88[16] = "service_vec";
          *(_WORD *)&v88[24] = 2080;
          *(_QWORD *)&v88[26] = "cti-services.c";
          v89 = 1024;
          v90 = 1539;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v65 = v8[2];
        }
        v8[2] = v65 - 1;
        if (v65 != 1)
        {
          v8 = 0;
          v4 = v68;
          goto LABEL_6;
        }
        v66 = *((_QWORD *)v5 + 306);
        v4 = v68;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v86 = "cti_parse_services_array";
          v87 = 2048;
          *(_QWORD *)v88 = v8;
          *(_WORD *)&v88[8] = 2080;
          *(_QWORD *)&v88[10] = "service_vec";
          *(_WORD *)&v88[18] = 2080;
          *(_QWORD *)&v88[20] = "cti-services.c";
          *(_WORD *)&v88[28] = 1024;
          *(_DWORD *)&v88[30] = 1539;
          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++cti_service_vec_finalized;
        cti_service_vec_finalize((unint64_t *)v8);
LABEL_5:
        v8 = 0;
        goto LABEL_6;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v86 = "cti_parse_services_array";
        v87 = 1024;
        *(_DWORD *)v88 = v65;
        *(_WORD *)&v88[4] = 2048;
        *(_QWORD *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(_QWORD *)&v88[16] = "service_vec";
        *(_WORD *)&v88[24] = 2080;
        *(_QWORD *)&v88[26] = "cti-services.c";
        v89 = 1024;
        v90 = 1539;
        v67 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_144:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v67, buf, 0x36u);
      }
    }
    else
    {
      v12 = *((_QWORD *)v5 + 306);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v86 = "cti_parse_services_array";
        v87 = 1024;
        *(_DWORD *)v88 = 0;
        *(_WORD *)&v88[4] = 2048;
        *(_QWORD *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(_QWORD *)&v88[16] = "service_vec";
        *(_WORD *)&v88[24] = 2080;
        *(_QWORD *)&v88[26] = "cti-services.c";
        v89 = 1024;
        v90 = 1539;
        v67 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
    }
LABEL_145:
    abort();
  }
  v4 = v68;
  v3 = v69;
LABEL_6:
  if (v4)
  {
    v9 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      v10 = *(_DWORD *)(v3 + 80);
      *(_DWORD *)buf = 136446722;
      v86 = "cti_internal_service_reply_callback";
      v87 = 1024;
      *(_DWORD *)v88 = v10;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(_QWORD *)(v3 + 64), v8, v6);
  }
  if (v8)
  {
    v11 = v8[2];
    if (!v11)
    {
      v12 = *((_QWORD *)v5 + 306);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v86 = "cti_internal_service_reply_callback";
        v87 = 1024;
        *(_DWORD *)v88 = 0;
        *(_WORD *)&v88[4] = 2048;
        *(_QWORD *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(_QWORD *)&v88[16] = "vec";
        *(_WORD *)&v88[24] = 2080;
        *(_QWORD *)&v88[26] = "cti-services.c";
        v89 = 1024;
        v90 = 1568;
        v67 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    v12 = *((_QWORD *)v5 + 306);
    if (v11 >= 10001)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v86 = "cti_internal_service_reply_callback";
        v87 = 1024;
        *(_DWORD *)v88 = v11;
        *(_WORD *)&v88[4] = 2048;
        *(_QWORD *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(_QWORD *)&v88[16] = "vec";
        *(_WORD *)&v88[24] = 2080;
        *(_QWORD *)&v88[26] = "cti-services.c";
        v89 = 1024;
        v90 = 1568;
        v67 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v86 = "cti_internal_service_reply_callback";
      v87 = 1024;
      *(_DWORD *)v88 = v11;
      *(_WORD *)&v88[4] = 2048;
      *(_QWORD *)&v88[6] = v8;
      *(_WORD *)&v88[14] = 2080;
      *(_QWORD *)&v88[16] = "vec";
      *(_WORD *)&v88[24] = 2080;
      *(_QWORD *)&v88[26] = "cti-services.c";
      v89 = 1024;
      v90 = 1568;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v11 = v8[2];
    }
    v8[2] = v11 - 1;
    if (v11 == 1)
    {
      v13 = *((_QWORD *)v5 + 306);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v86 = "cti_internal_service_reply_callback";
        v87 = 2048;
        *(_QWORD *)v88 = v8;
        *(_WORD *)&v88[8] = 2080;
        *(_QWORD *)&v88[10] = "vec";
        *(_WORD *)&v88[18] = 2080;
        *(_QWORD *)&v88[20] = "cti-services.c";
        *(_WORD *)&v88[28] = 1024;
        *(_DWORD *)&v88[30] = 1568;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++cti_service_vec_finalized;
      cti_service_vec_finalize((unint64_t *)v8);
    }
  }
}

_BYTE *cti_array_to_bytes(void *a1, size_t *a2, uint64_t a3)
{
  size_t count;
  _BYTE *v7;
  size_t i;
  NSObject *v9;
  int v11;
  const char *v12;
  __int16 v13;
  uint64_t v14;

  count = xpc_array_get_count(a1);
  v7 = malloc_type_malloc(count, 0x88ECC842uLL);
  if (v7)
  {
    if (count)
    {
      for (i = 0; i != count; ++i)
        v7[i] = xpc_array_get_uint64(a1, i);
    }
    *a2 = count;
  }
  else
  {
    v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v11 = 136446466;
      v12 = "cti_array_to_bytes";
      v13 = 2082;
      v14 = a3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s: no memory for return buffer", (uint8_t *)&v11, 0x16u);
    }
  }
  return v7;
}

void cti_internal_rloc16_reply_callback(uint64_t a1, void *a2, uint64_t a3)
{
  void (*v4)(_QWORD, _QWORD, uint64_t);
  uint64_t v5;
  unsigned __int16 v6;
  NSObject *v7;
  _BOOL4 v8;
  int v9;
  int v10;
  const char *string;
  xpc_object_t xdict;
  _BYTE buf[12];
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;

  v4 = *(void (**)(_QWORD, _QWORD, uint64_t))(a1 + 8);
  xdict = 0;
  if ((_DWORD)a3)
  {
    v5 = a3;
LABEL_4:
    v6 = 0;
    goto LABEL_5;
  }
  v5 = cti_event_or_response_extract(a2, &xdict);
  if ((_DWORD)v5)
    goto LABEL_4;
  string = xpc_dictionary_get_string(xdict, "response");
  *(_QWORD *)buf = "\n";
  v6 = strtol(string + 2, (char **)buf, 16);
LABEL_5:
  v7 = global_os_log;
  v8 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v8)
    {
      v9 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "cti_internal_rloc16_reply_callback";
      v14 = 1024;
      v15 = v9;
      v16 = 2048;
      v17 = a1;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(_QWORD *)(a1 + 64), v6, v5);
  }
  else if (v8)
  {
    v10 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "cti_internal_rloc16_reply_callback";
    v14 = 1024;
    v15 = v10;
    v16 = 2048;
    v17 = a1;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] not calling callback for %p", buf, 0x1Cu);
  }
}

void cti_internal_wed_reply_callback(uint64_t a1, void *a2, uint64_t a3)
{
  void (*v4)(_QWORD, const char *, const char *, uint64_t, uint64_t);
  uint64_t v5;
  const char *v6;
  const char *v7;
  uint64_t v8;
  int v9;
  BOOL v10;
  unsigned int v11;
  NSObject *v12;
  int v13;
  xpc_object_t array;
  void *v15;
  size_t v16;
  xpc_object_t value;
  const char *string;
  const char *v19;
  const char *v20;
  uint64_t v21;
  _BOOL4 v22;
  NSObject *v23;
  const char *v24;
  uint32_t v25;
  NSObject *v26;
  int v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  uint64_t v32;
  int v33;
  size_t count;
  xpc_object_t xdict;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  _BYTE v39[18];
  __int16 v40;
  const char *v41;

  v4 = *(void (**)(_QWORD, const char *, const char *, uint64_t, uint64_t))(a1 + 8);
  if ((_DWORD)a3)
  {
    if (v4)
    {
      v5 = a3;
      v6 = 0;
      v7 = 0;
      v8 = 0;
      goto LABEL_16;
    }
    return;
  }
  xdict = 0;
  v5 = cti_event_or_response_extract(a2, &xdict);
  if ((_DWORD)v5)
    goto LABEL_5;
  array = xpc_dictionary_get_array(xdict, "value");
  if (!array)
  {
    v26 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446466;
      v37 = "cti_internal_wed_reply_callback";
      v38 = 1024;
      *(_DWORD *)v39 = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] wed status array not present in wed status event.", buf, 0x12u);
    }
    goto LABEL_5;
  }
  v15 = array;
  count = xpc_array_get_count(array);
  if (!count)
  {
LABEL_5:
    v6 = 0;
    v7 = 0;
    LOBYTE(v9) = 0;
    goto LABEL_6;
  }
  v16 = 0;
  v9 = 0;
  v7 = 0;
  v6 = 0;
  while (1)
  {
    value = xpc_array_get_value(v15, v16);
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    {
      v28 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_6;
      *(_DWORD *)buf = 136446210;
      v37 = "cti_internal_wed_reply_callback";
      v29 = "%{public}s: non-dictionary element of value array";
LABEL_49:
      v30 = v28;
      v31 = 12;
LABEL_50:
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      goto LABEL_6;
    }
    string = xpc_dictionary_get_string(value, "key");
    if (!string)
    {
      v28 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_6;
      *(_DWORD *)buf = 136446210;
      v37 = "cti_internal_wed_reply_callback";
      v29 = "%{public}s: no key in value array";
      goto LABEL_49;
    }
    v19 = string;
    v20 = xpc_dictionary_get_string(value, "value");
    if (strcmp(v19, "extendedMACAddress"))
      break;
    v6 = v20;
LABEL_40:
    if (count == ++v16)
      goto LABEL_6;
  }
  if (!strcmp(v19, "mleid"))
  {
    v7 = v20;
    goto LABEL_40;
  }
  if (strcmp(v19, "status"))
  {
    v33 = v9;
    v21 = global_os_log;
    v22 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446979;
        v37 = "cti_internal_wed_reply_callback";
        v38 = 2082;
        *(_QWORD *)v39 = v19;
        *(_WORD *)&v39[8] = 2160;
        *(_QWORD *)&v39[10] = 1752392040;
        v40 = 2081;
        v41 = v20;
        v23 = v21;
        v24 = "%{public}s: unknown key %{public}s with value %{private, mask.hash}s";
        v25 = 42;
LABEL_38:
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v24, buf, v25);
      }
    }
    else if (v22)
    {
      *(_DWORD *)buf = 136446466;
      v37 = "cti_internal_wed_reply_callback";
      v38 = 2082;
      *(_QWORD *)v39 = v19;
      v23 = v21;
      v24 = "%{public}s: unknown key in response: %{public}s";
      v25 = 22;
      goto LABEL_38;
    }
    v9 = v33;
    goto LABEL_40;
  }
  if (!strcmp(v20, "wed_added"))
  {
    v9 = 1;
    goto LABEL_40;
  }
  if (!strcmp(v20, "wed_removed"))
  {
    v9 = 0;
    goto LABEL_40;
  }
  v32 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v37 = "cti_internal_wed_reply_callback";
    v38 = 2082;
    *(_QWORD *)v39 = v20;
    v29 = "%{public}s: unknown wed status %{public}s";
    v30 = v32;
    v31 = 22;
    goto LABEL_50;
  }
LABEL_6:
  if (v4)
  {
    if (v7)
      v10 = v6 == 0;
    else
      v10 = 1;
    v11 = !v10;
    if ((v9 & 1) != 0)
      v8 = v11;
    else
      v8 = 0;
LABEL_16:
    v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      v37 = "cti_internal_wed_reply_callback";
      v38 = 1024;
      *(_DWORD *)v39 = v13;
      *(_WORD *)&v39[4] = 2048;
      *(_QWORD *)&v39[6] = a1;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(_QWORD *)(a1 + 64), v6, v7, v8, v5);
  }
}

uint64_t cti_add_ml_eid_mapping_(uint64_t a1, const void *a2, const void *a3, const char *a4)
{
  xpc_object_t v8;
  uint64_t v9;
  char string[46];

  v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "UpdateAccessoryData");
  inet_ntop(30, a2, string, 0x2Eu);
  xpc_dictionary_set_string(v8, "ipaddr_add", string);
  inet_ntop(30, a3, string, 0x2Eu);
  xpc_dictionary_set_string(v8, "ipaddr_lookup", string);
  xpc_dictionary_set_string(v8, "host_info", a4);
  v9 = setup_for_command(0, (uint64_t)"add_mle_mapping", 0, 0, v8, a1, (uint64_t)srp_ml_eid_mapping_callback, (uint64_t)cti_internal_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3618);
  xpc_release(v8);
  return v9;
}

void cti_events_discontinue(uint64_t a1)
{
  _xpc_connection_s *v2;
  NSObject *v3;
  int v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  _xpc_connection_s *v10;

  v2 = *(_xpc_connection_s **)(a1 + 16);
  if (v2)
  {
    v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_DWORD *)(a1 + 80);
      v5 = 136446722;
      v6 = "cti_events_discontinue";
      v7 = 1024;
      v8 = v4;
      v9 = 2048;
      v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] canceling connection %p", (uint8_t *)&v5, 0x1Cu);
      v2 = *(_xpc_connection_s **)(a1 + 16);
    }
    xpc_connection_cancel(v2);
  }
  cti_connection_release_((_QWORD *)a1, 2448);
}

uint64_t state_machine_next_state(uint64_t a1, unsigned int a2)
{
  uint64_t result;
  uint64_t (*v5)(uint64_t, _QWORD);
  NSObject *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  unsigned int v18;

  do
  {
    result = state_machine_state_get((uint64_t *)a1, a2);
    if (!result)
    {
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v7 = *(_QWORD *)(a1 + 32);
        v8 = *(_QWORD *)a1;
        v9 = 136447235;
        v10 = "state_machine_next_state";
        v11 = 2082;
        v12 = v7;
        v13 = 2160;
        v14 = 1752392040;
        v15 = 2081;
        v16 = v8;
        v17 = 1024;
        v18 = a2;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s/%{private, mask.hash}s next state is invalid: %d", (uint8_t *)&v9, 0x30u);
      }
      abort();
    }
    *(_DWORD *)(a1 + 48) = a2;
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(result + 8);
    v5 = *(uint64_t (**)(uint64_t, _QWORD))(result + 16);
    if (v5)
    {
      result = v5(a1, 0);
      a2 = result;
    }
  }
  while (a2);
  return result;
}

uint64_t state_machine_state_get(uint64_t *a1, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  int *v4;
  int *v5;
  int v6;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;

  v2 = a1[5];
  if (!*((_BYTE *)a1 + 56))
  {
    if (v2)
    {
      v3 = 0;
      v4 = (int *)a1[3];
      v5 = v4;
      while (1)
      {
        v6 = *v5;
        v5 += 6;
        if ((_DWORD)v3 != v6)
          break;
        if (v2 == ++v3)
          goto LABEL_6;
      }
      v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v10 = a1[4];
        v11 = *a1;
        v12 = *(_QWORD *)&v4[6 * v3 + 2];
        v13 = 136447491;
        v14 = "state_machine_state_get";
        v15 = 2082;
        v16 = v10;
        v17 = 2160;
        v18 = 1752392040;
        v19 = 2081;
        v20 = v11;
        v21 = 2048;
        v22 = v3;
        v23 = 2082;
        v24 = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s/%{private, mask.hash}s state %zu doesn't match %{public}s", (uint8_t *)&v13, 0x3Eu);
      }
LABEL_11:
      abort();
    }
LABEL_6:
    *((_BYTE *)a1 + 56) = 1;
  }
  if (v2 <= a2)
    goto LABEL_11;
  return a1[3] + 24 * a2;
}

void state_machine_event_deliver(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t (*v6)(uint64_t, uint64_t);
  unsigned int v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;

  v4 = state_machine_state_get((uint64_t *)a1, *(_DWORD *)(a1 + 48));
  if (!v4)
  {
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v14 = *(_QWORD *)(a1 + 32);
      v15 = *(_QWORD *)a1;
      v16 = *(_QWORD *)(a2 + 8);
      v17 = *(_DWORD *)(a1 + 48);
      v18 = 136447491;
      v19 = "state_machine_event_deliver";
      v20 = 2082;
      v21 = v14;
      v22 = 2160;
      v23 = 1752392040;
      v24 = 2081;
      v25 = v15;
      v26 = 2082;
      v27 = v16;
      v28 = 1024;
      LODWORD(v29) = v17;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in invalid state %d", (uint8_t *)&v18, 0x3Au);
    }
    abort();
  }
  v5 = v4;
  v6 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 16);
  if (v6)
  {
    v7 = v6(a1, a2);
    if (v7)
      state_machine_next_state(a1, v7);
  }
  else
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      v9 = *(_QWORD *)(a1 + 32);
      v10 = *(_QWORD *)a1;
      v11 = *(_QWORD *)(a2 + 8);
      v12 = *(_QWORD *)(v5 + 8);
      v18 = 136447491;
      v19 = "state_machine_event_deliver";
      v20 = 2082;
      v21 = v9;
      v22 = 2160;
      v23 = 1752392040;
      v24 = 2081;
      v25 = v10;
      v26 = 2082;
      v27 = v11;
      v28 = 2082;
      v29 = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s with NULL action", (uint8_t *)&v18, 0x3Eu);
    }
  }
}

_DWORD *state_machine_event_create(int a1)
{
  uint64_t v2;
  int *v3;
  int v4;
  _DWORD *v5;
  NSObject *v6;
  int v7;
  int v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  os_log_type_t v12;
  uint32_t v13;
  uint64_t v15;
  _DWORD *v16;
  uint64_t v17;
  int v18;
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  _DWORD *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  int v30;

  if ((state_machine_event_configuration_get_once & 1) == 0)
  {
    v2 = 0;
    v3 = state_machine_event_configurations;
    while (1)
    {
      v4 = *v3;
      v3 += 4;
      if (v2 != v4)
        break;
      if (++v2 == 21)
      {
        state_machine_event_configuration_get_once = 1;
        goto LABEL_6;
      }
    }
    v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v16 = *(_DWORD **)&state_machine_event_configurations[4 * v2 + 2];
      *(_DWORD *)buf = 136446722;
      v20 = "state_machine_event_configuration_get";
      v21 = 1024;
      v22 = v2;
      v23 = 2082;
      v24 = v16;
      v10 = "%{public}s: event %d doesn't match %{public}s";
      v11 = v15;
      v12 = OS_LOG_TYPE_ERROR;
      v13 = 28;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v11, v12, v10, buf, v13);
      goto LABEL_18;
    }
    goto LABEL_18;
  }
LABEL_6:
  if (!&state_machine_event_configurations[4 * a1])
  {
    v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v20 = "state_machine_event_create";
      v21 = 1024;
      v22 = a1;
      v10 = "%{public}s: invalid event type %d";
      v11 = v17;
      v12 = OS_LOG_TYPE_ERROR;
      v13 = 18;
      goto LABEL_17;
    }
LABEL_18:
    abort();
  }
  v5 = malloc_type_calloc(1uLL, 0x28uLL, 0x10F0040AC697359uLL);
  v5[4] = a1;
  *((_QWORD *)v5 + 1) = *(_QWORD *)&state_machine_event_configurations[4 * a1 + 2];
  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *v5;
    *(_DWORD *)buf = 136447490;
    v20 = "state_machine_event_create";
    v21 = 1024;
    v22 = v7;
    v23 = 2048;
    v24 = v5;
    v25 = 2080;
    v26 = "event";
    v27 = 2080;
    v28 = "state-machine.c";
    v29 = 1024;
    v30 = 211;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  if (*v5)
  {
    v8 = *v5 + 1;
    *v5 = v8;
    if (v8 >= 10001)
    {
      v18 = v8;
      v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_18;
      *(_DWORD *)buf = 136447490;
      v20 = "state_machine_event_create";
      v21 = 1024;
      v22 = v18;
      v23 = 2048;
      v24 = v5;
      v25 = 2080;
      v26 = "event";
      v27 = 2080;
      v28 = "state-machine.c";
      v29 = 1024;
      v30 = 211;
      v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      v11 = v9;
      v12 = OS_LOG_TYPE_FAULT;
      v13 = 54;
      goto LABEL_17;
    }
  }
  else
  {
    ++state_machine_event_created;
    *v5 = 1;
  }
  *((_QWORD *)v5 + 4) = 0;
  return v5;
}

uint64_t state_machine_header_setup(uint64_t a1, uint64_t a2, char *__s1, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  int *v11;
  int v12;
  uint64_t result;

  v10 = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  v11 = state_machine_types;
  while (1)
  {
    v12 = *v11;
    v11 += 4;
    if (v12 == a4)
      break;
    if (++v10 == 4)
      return 0;
  }
  *(_QWORD *)(a1 + 32) = *(_QWORD *)&state_machine_types[4 * v10 + 2];
  *(_QWORD *)(a1 + 8) = a2;
  result = (uint64_t)strdup(__s1);
  *(_QWORD *)a1 = result;
  if (result)
  {
    *(_DWORD *)(a1 + 52) = a4;
    *(_QWORD *)(a1 + 24) = a5;
    result = 1;
    *(_QWORD *)(a1 + 40) = a6;
  }
  return result;
}

void state_machine_cancel(uint64_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  int v4;
  const char *v5;
  __int16 v6;
  uint64_t v7;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *a1;
    v4 = 136446466;
    v5 = "state_machine_cancel";
    v6 = 2082;
    v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: canceling %{public}s", (uint8_t *)&v4, 0x16u);
  }
  *((_DWORD *)a1 + 12) = 0;
}

char *dns_name_to_wire_(char *result, uint64_t *a2, char *__s, int a4)
{
  int v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  int v11;
  char *v12;
  uint64_t v14;
  _BYTE *v15;
  char *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  char *v22;

  if (*((_DWORD *)a2 + 12) <= 1u)
  {
    v6 = 0;
    v7 = 0;
    v8 = a2[1];
    v20 = *a2;
    v21 = v8;
    v22 = result;
    while (1)
    {
      v9 = a2[2];
      result = strchr(__s, 46);
      if (result)
        break;
      result = (char *)strlen(__s);
      v10 = 0;
      if (result)
      {
        result = &result[(_QWORD)__s];
LABEL_8:
        v11 = 0;
        if (result > __s)
        {
          v12 = __s;
          do
          {
            if (*v12 != 92 || v12 + 4 > result)
              v14 = 0;
            else
              v14 = 3;
            ++v11;
            v12 += v14 + 1;
          }
          while (v12 < result);
        }
        if ((uint64_t)(v9 + ~v8) <= v11)
        {
          *((_DWORD *)a2 + 12) |= 1u;
          v19 = 110;
          goto LABEL_34;
        }
        if (result - __s > 63)
        {
          v19 = 126;
          goto LABEL_34;
        }
        *(_BYTE *)v8 = v11;
        if (result > __s)
        {
          v15 = (_BYTE *)(v8 + 1);
          v16 = __s;
          while (1)
          {
            v17 = *v16;
            if (v17 == 92)
            {
              if (v16 + 4 > result)
                goto LABEL_33;
              v18 = v16[3];
              v16 += 3;
              v17 = 100 * *(v16 - 2) + 10 * *(v16 - 1) + v18;
              if (v17 > 5582)
                goto LABEL_33;
              LOBYTE(v17) = v17 + 48;
            }
            *v15++ = v17;
            if (++v16 >= result)
              goto LABEL_28;
          }
        }
        goto LABEL_28;
      }
      *(_BYTE *)v8 = 0;
LABEL_28:
      v8 = a2[1];
      if (*(_BYTE *)v8)
      {
        ++v6;
        v7 += *(unsigned __int8 *)v8 + 1;
        v8 += *(unsigned __int8 *)v8 + 1;
        a2[1] = v8;
        __s = v10;
      }
      if (!v10)
      {
        if (v7 < 256)
        {
          if (v22)
          {
            *(_QWORD *)v22 = 0;
            *((_QWORD *)v22 + 1) = v20;
            *((_QWORD *)v22 + 2) = v21;
            *((_DWORD *)v22 + 6) = v6;
            *((_DWORD *)v22 + 7) = v7;
          }
        }
        else
        {
          *((_DWORD *)a2 + 12) = a2[6] & 1 | 0x7E;
          *((_DWORD *)a2 + 10) = a4;
        }
        return result;
      }
    }
    if (result == __s)
    {
LABEL_33:
      v19 = 44;
LABEL_34:
      *((_DWORD *)a2 + 12) = a2[6] & 1 | v19;
      *((_DWORD *)a2 + 10) = a4;
      return result;
    }
    v10 = result + 1;
    goto LABEL_8;
  }
  return result;
}

double dns_full_name_to_wire_(_OWORD *a1, uint64_t a2, char *a3, int a4)
{
  double result;
  _BYTE *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;

  if (*(_DWORD *)(a2 + 48) <= 1u)
  {
    v10 = 0u;
    v11 = 0u;
    dns_name_to_wire_((char *)&v10, (uint64_t *)a2, a3, 180);
    if (*(_DWORD *)(a2 + 48) <= 1u)
    {
      v8 = *(_BYTE **)(a2 + 8);
      if ((unint64_t)(v8 + 1) >= *(_QWORD *)(a2 + 16))
      {
        *(_DWORD *)(a2 + 48) = 111;
        goto LABEL_7;
      }
      *(_QWORD *)(a2 + 8) = v8 + 1;
      *v8 = 0;
      ++DWORD2(v11);
      ++HIDWORD(v11);
      if (SHIDWORD(v11) >= 256)
      {
        *(_DWORD *)(a2 + 48) = *(_DWORD *)(a2 + 48) & 1 | 0x7E;
LABEL_7:
        *(_DWORD *)(a2 + 40) = a4;
        return result;
      }
      if (a1)
      {
        result = *(double *)&v10;
        v9 = v11;
        *a1 = v10;
        a1[1] = v9;
      }
    }
  }
  return result;
}

uint64_t dns_pointer_to_wire_(uint64_t result, uint64_t a2, int a3)
{
  unsigned int v3;
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  int v7;

  v3 = *(_DWORD *)(result + 48);
  if (v3 <= 1)
  {
    v4 = *(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8);
    if ((v4 & 0x8000) != 0)
    {
      v7 = v3 | 0x76;
    }
    else
    {
      v5 = *(_BYTE **)(result + 8);
      if ((unint64_t)(v5 + 2) < *(_QWORD *)(result + 16))
      {
        *(_QWORD *)(result + 8) = v5 + 1;
        *v5 = BYTE1(v4) | 0xC0;
        v6 = *(_BYTE **)(result + 8);
        *(_QWORD *)(result + 8) = v6 + 1;
        *v6 = v4;
        return result;
      }
      v7 = 111;
    }
    *(_DWORD *)(result + 48) = v7;
    *(_DWORD *)(result + 40) = a3;
  }
  return result;
}

uint64_t dns_u32_to_wire_(uint64_t result, int a2, int a3)
{
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;

  if (*(_DWORD *)(result + 48) <= 1u)
  {
    v3 = *(_BYTE **)(result + 8);
    if ((unint64_t)(v3 + 4) >= *(_QWORD *)(result + 16))
    {
      *(_DWORD *)(result + 48) = 111;
      *(_DWORD *)(result + 40) = a3;
    }
    else
    {
      *(_QWORD *)(result + 8) = v3 + 1;
      *v3 = HIBYTE(a2);
      v4 = *(_BYTE **)(result + 8);
      *(_QWORD *)(result + 8) = v4 + 1;
      *v4 = BYTE2(a2);
      v5 = *(_BYTE **)(result + 8);
      *(_QWORD *)(result + 8) = v5 + 1;
      *v5 = BYTE1(a2);
      v6 = *(_BYTE **)(result + 8);
      *(_QWORD *)(result + 8) = v6 + 1;
      *v6 = a2;
    }
  }
  return result;
}

BOOL srp_tls_init()
{
  int v0;
  __CFArray *Mutable;
  __CFDictionary *v2;
  __CFDictionary *v3;
  int v4;
  uint64_t Count;
  CFIndex v6;
  CFIndex v7;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v10;
  const __CFString *Value;
  __CFArray *v12;
  CFIndex v13;
  double Current;
  double v15;
  CFIndex j;
  const __CFDictionary *v17;
  const __CFDictionary *v18;
  CFTypeID v19;
  const __CFDate *v20;
  CFIndex v21;
  CFIndex v22;
  CFIndex k;
  const void *v24;
  CFTypeID v25;
  CFMutableDictionaryRef v26;
  __CFDictionary *v27;
  const void *v28;
  const void *v29;
  const void *v30;
  void *v31;
  NSObject *v32;
  int v33;
  const __CFUUID *v34;
  const __CFUUID *v35;
  const __CFString *v36;
  uint64_t v37;
  const void *v38;
  SecKeyRef v39;
  uint64_t v40;
  const void *v41;
  const void *v42;
  const void *v43;
  uint64_t v44;
  uint64_t v45;
  __SecIdentity *v46;
  __CFString *v47;
  __CFString *v48;
  __CFString *v49;
  __CFString *v50;
  __CFDictionary *v51;
  __CFDictionary *v52;
  OSStatus v53;
  _BOOL8 v54;
  const __CFString *v55;
  NSObject *v56;
  uint64_t SelfSignedCertificate;
  NSObject *v58;
  NSObject *v59;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  NSObject *v63;
  NSObject *v64;
  CFErrorRef error;
  int v66;
  CFDictionaryRef parameters;
  _BYTE cf[12];
  __int16 v69;
  _BYTE *v70;
  _BYTE result[204];
  CFRange v72;

  v0 = -67672;
  *(_QWORD *)result = 0;
  *(_QWORD *)cf = 0;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v3 = 0;
    v4 = -6729;
    goto LABEL_21;
  }
  v2 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v3 = v2;
  v4 = -67672;
  if (v2)
  {
    CFDictionaryAddValue(v2, kSecClass, kSecClassCertificate);
    CFDictionaryAddValue(v3, kSecReturnRef, kCFBooleanTrue);
    CFDictionaryAddValue(v3, kSecMatchLimit, kSecMatchLimitAll);
    CFDictionaryAddValue(v3, kSecAttrAccessGroup, CFSTR("com.apple.srp-mdns-proxy"));
    CFDictionaryAddValue(v3, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
    CFDictionaryAddValue(v3, kSecUseDataProtectionKeychain, kCFBooleanTrue);
    CFDictionaryAddValue(v3, kSecAttrSynchronizable, kCFBooleanTrue);
    CFDictionaryAddValue(v3, kSecAttrSyncViewHint, kSecAttrViewHintLimitedPeersAllowed);
    CFDictionaryAddValue(v3, kSecReturnAttributes, kCFBooleanTrue);
    SecItemCopyMatching(v3, (CFTypeRef *)result);
    if (*(_QWORD *)result)
    {
      Count = CFArrayGetCount(*(CFArrayRef *)result);
      if (Count >= 1)
      {
        v72.length = Count;
        v72.location = 0;
        CFArrayAppendArray(Mutable, *(CFArrayRef *)result, v72);
      }
    }
    CFDictionaryRemoveValue(v3, kSecAttrAccessible);
    SecItemCopyMatching(v3, (CFTypeRef *)cf);
    if (*(_QWORD *)cf)
    {
      v6 = CFArrayGetCount(*(CFArrayRef *)cf);
      if (v6 >= 1)
      {
        v7 = v6;
        for (i = 0; i != v7; ++i)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)cf, i);
          if (ValueAtIndex)
          {
            v10 = ValueAtIndex;
            Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, kSecAttrAccessible);
            if (!Value || CFStringCompare(Value, kSecAttrAccessibleAfterFirstUnlock, 0))
              CFArrayAppendValue(Mutable, v10);
          }
        }
      }
    }
    if (CFArrayGetCount(Mutable) > 0)
    {
      v4 = 0;
      goto LABEL_19;
    }
    v4 = -25300;
  }
  CFRelease(Mutable);
  Mutable = 0;
LABEL_19:
  if (*(_QWORD *)cf)
  {
    CFRelease(*(CFTypeRef *)cf);
    *(_QWORD *)cf = 0;
  }
LABEL_21:
  if (*(_QWORD *)result)
  {
    CFRelease(*(CFTypeRef *)result);
    *(_QWORD *)result = 0;
  }
  if (v3)
    CFRelease(v3);
  if (v4)
  {
    v12 = 0;
  }
  else
  {
    if (Mutable)
      v13 = CFArrayGetCount(Mutable);
    else
      v13 = 0;
    v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v12)
    {
      Current = CFAbsoluteTimeGetCurrent();
      if (v13 >= 1)
      {
        v15 = Current;
        for (j = 0; j != v13; ++j)
        {
          v17 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, j);
          if (v17)
          {
            v18 = v17;
            v19 = CFGetTypeID(v17);
            if (v19 == CFDictionaryGetTypeID())
            {
              v20 = (const __CFDate *)CFDictionaryGetValue(v18, kSecAttrCreationDate);
              if (v20)
              {
                if (v15 - CFDateGetAbsoluteTime(v20) >= 2419200.0)
                  CFArrayAppendValue(v12, v18);
              }
            }
          }
        }
      }
      v21 = CFArrayGetCount(v12);
      if (v21 >= 1)
      {
        v22 = v21;
        for (k = 0; k != v22; ++k)
        {
          v24 = CFArrayGetValueAtIndex(v12, k);
          v25 = CFGetTypeID(v24);
          if (v25 == CFDictionaryGetTypeID())
          {
            v26 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (v26)
            {
              v27 = v26;
              v28 = CFDictionaryGetValue((CFDictionaryRef)v24, kSecValueRef);
              if (v28)
              {
                CFDictionaryAddValue(v27, kSecValueRef, v28);
                v29 = CFDictionaryGetValue((CFDictionaryRef)v24, kSecAttrAccessGroup);
                if (v29)
                {
                  CFDictionaryAddValue(v27, kSecAttrAccessGroup, v29);
                  v30 = CFDictionaryGetValue((CFDictionaryRef)v24, kSecAttrAccessible);
                  if (v30)
                  {
                    CFDictionaryAddValue(v27, kSecAttrAccessible, v30);
                    CFDictionaryAddValue(v27, kSecUseDataProtectionKeychain, kCFBooleanTrue);
                    CFDictionaryAddValue(v27, kSecAttrSynchronizable, kCFBooleanTrue);
                    SecItemDelete(v27);
                  }
                }
              }
              CFRelease(v27);
            }
          }
        }
        v0 = -67672;
      }
    }
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v12)
    CFRelease(v12);
  v31 = (void *)g_tls_identity;
  if (g_tls_identity)
  {
    v32 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)
      || (*(_DWORD *)result = 136446210,
          *(_QWORD *)&result[4] = "tls_identity_init",
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: Identity already initialized, reconfirming if it is still valid.", result, 0xCu), (v31 = (void *)g_tls_identity) != 0))
    {
      sec_release(v31);
      g_tls_identity = 0;
    }
  }
  if (!keychain_identity_query(0, &g_tls_identity, (double *)&g_tls_identity_creation_time))
    return 1;
  v33 = keychain_identity_query(1, 0, 0);
  if (!v33 || v33 == -25300)
  {
    v34 = CFUUIDCreate(kCFAllocatorDefault);
    if (!v34 || (v35 = v34, v36 = CFUUIDCreateString(kCFAllocatorDefault, v34), CFRelease(v35), !v36))
    {
      v58 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)result = 136446210;
        *(_QWORD *)&result[4] = "tls_identity_init";
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_FAULT, "%{public}s: Failed to generate an UUID.", result, 0xCu);
      }
      goto LABEL_124;
    }
    v66 = 0;
    parameters = 0;
    v37 = CFStringCreateF(&v66, "%s%@", "Key ", v36);
    v38 = (const void *)v37;
    v39 = 0;
    if (v66)
      goto LABEL_67;
    v66 = CFPropertyListCreateFormatted(kCFAllocatorDefault, &parameters, "{%kO=%O%kO=%i%kO=%O%kO=%O%kO=%O%kO=%O}", kSecAttrKeyClass, kSecAttrKeyClassPrivate, kSecAttrKeySizeInBits, 384, kSecAttrKeyType, kSecAttrKeyTypeECSECPrimeRandom, kSecUseDataProtectionKeychain, kCFBooleanTrue, kSecAttrSynchronizable, kCFBooleanTrue, kSecAttrLabel, v37);
    if (!v66)
    {
      error = 0;
      v39 = SecKeyCreateRandomKey(parameters, &error);
      if (v39)
      {
LABEL_67:
        if (parameters)
        {
          CFRelease(parameters);
          parameters = 0;
        }
        if (v38)
          CFRelease(v38);
        if (v39)
        {
          LODWORD(error) = 0;
          parameters = 0;
          *(_QWORD *)cf = 0;
          v40 = CFStringCreateF(&error, "%s%@", "Certificate ", v36);
          v41 = (const void *)v40;
          v42 = 0;
          v43 = 0;
          if (!(_DWORD)error)
          {
            v42 = 0;
            v43 = 0;
            LODWORD(error) = CFPropertyListCreateFormatted(kCFAllocatorDefault, cf, "{%kO=%lli%kO=%i%kO=%O%kO={%kO=%O}}", kSecCertificateKeyUsage, 0, kSecCSRBasicContraintsPathLen, 0, kSecAttrLabel, v40, kSecSubjectAltName, kSecSubjectAltNameDNSName, CFSTR("com.apple.dnssd-proxy"));
            if (!(_DWORD)error)
            {
              v44 = CFStringCreateF(&error, "%s %@", "com.apple.dnssd-proxy", v36);
              v43 = (const void *)v44;
              if ((_DWORD)error
                || (LODWORD(error) = CFPropertyListCreateFormatted(kCFAllocatorDefault, &parameters, "[[[%O%O]][[%O%O]][[%O%O]][[%O%O]][[%O%O]][[%O%O]]]", kSecOidCommonName, v44, kSecOidOrganizationalUnit, CFSTR("Networking"), kSecOidOrganization, CFSTR("Apple Inc."), kSecOidLocalityName, CFSTR("Cupertino"), kSecOidStateProvinceName, CFSTR("California"), kSecOidCountryName, CFSTR("US")), (_DWORD)error))
              {
                v42 = 0;
              }
              else
              {
                SelfSignedCertificate = SecGenerateSelfSignedCertificate(parameters, *(_QWORD *)cf, 0, v39);
                if (SelfSignedCertificate)
                {
                  v42 = (const void *)SelfSignedCertificate;
                }
                else
                {
                  v64 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)result = 136446210;
                    *(_QWORD *)&result[4] = "certificate_generate";
                    _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_FAULT, "%{public}s: SecGenerateSelfSignedCertificate failed.", result, 0xCu);
                  }
                  v42 = 0;
                  v0 = -67672;
                }
              }
            }
          }
          if (parameters)
          {
            CFRelease(parameters);
            parameters = 0;
          }
          if (v43)
            CFRelease(v43);
          if (*(_QWORD *)cf)
          {
            CFRelease(*(CFTypeRef *)cf);
            *(_QWORD *)cf = 0;
          }
          if (v41)
            CFRelease(v41);
          if (v42)
          {
            v45 = SecIdentityCreate(kCFAllocatorDefault, v42, v39);
            if (v45)
            {
              v46 = (__SecIdentity *)v45;
              *(_QWORD *)result = 0;
              *(_QWORD *)cf = 0;
              v47 = CFStringCreateMutable(kCFAllocatorDefault, 0);
              v48 = v47;
              if (v47)
              {
                CFStringAppend(v47, CFSTR("Key "));
                CFStringAppend(v48, v36);
                v49 = CFStringCreateMutable(kCFAllocatorDefault, 0);
                v50 = v49;
                if (v49)
                {
                  CFStringAppend(v49, CFSTR("Certificate "));
                  CFStringAppend(v50, v36);
                  v0 = SecIdentityCopyPrivateKey(v46, (SecKeyRef *)result);
                  if (!v0)
                  {
                    v0 = SecIdentityCopyCertificate(v46, (SecCertificateRef *)cf);
                    if (!v0)
                    {
                      v51 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      if (v51)
                      {
                        v52 = v51;
                        CFDictionaryAddValue(v51, kSecAttrLabel, v48);
                        CFDictionaryAddValue(v52, kSecAttrAccessGroup, CFSTR("com.apple.srp-mdns-proxy"));
                        CFDictionaryAddValue(v52, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
                        CFDictionaryAddValue(v52, kSecAttrSynchronizable, kCFBooleanFalse);
                        CFDictionaryAddValue(v52, kSecUseDataProtectionKeychain, kCFBooleanTrue);
                        CFDictionaryAddValue(v52, kSecValueRef, *(const void **)result);
                        v0 = SecItemAdd(v52, 0);
                        if (!v0)
                        {
                          CFDictionaryReplaceValue(v52, kSecAttrLabel, v50);
                          CFDictionaryReplaceValue(v52, kSecValueRef, *(const void **)cf);
                          CFDictionaryReplaceValue(v52, kSecAttrSynchronizable, kCFBooleanTrue);
                          CFDictionaryAddValue(v52, kSecAttrSyncViewHint, kSecAttrViewHintLimitedPeersAllowed);
                          v53 = SecItemAdd(v52, 0);
                          if (v53)
                          {
                            v0 = v53;
                            keychain_key_remove();
                          }
                          else
                          {
                            v0 = 0;
                          }
                        }
                        CFRelease(v52);
                      }
                      else
                      {
                        v0 = 0;
                      }
                    }
                  }
                }
                if (*(_QWORD *)cf)
                {
                  CFRelease(*(CFTypeRef *)cf);
                  *(_QWORD *)cf = 0;
                }
              }
              else
              {
                v50 = 0;
              }
              if (*(_QWORD *)result)
              {
                CFRelease(*(CFTypeRef *)result);
                *(_QWORD *)result = 0;
              }
              if (v50)
                CFRelease(v50);
              if (v48)
                CFRelease(v48);
              if (v0)
              {
                v63 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)result = 136446210;
                  *(_QWORD *)&result[4] = "tls_identity_init";
                  _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_FAULT, "%{public}s: Failed to add the identity into keychain.", result, 0xCu);
                }
              }
              else
              {
                v0 = keychain_identity_query(0, &g_tls_identity, (double *)&g_tls_identity_creation_time);
              }
              CFRelease(v46);
            }
            else
            {
              v62 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)result = 136446210;
                *(_QWORD *)&result[4] = "tls_identity_init";
                _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_FAULT, "%{public}s: Failed to create the identity with the given private key and certificate.", result, 0xCu);
              }
              v0 = -6728;
            }
            CFRelease(v42);
          }
          else
          {
            v61 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)result = 136446210;
              *(_QWORD *)&result[4] = "tls_identity_init";
              _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_FAULT, "%{public}s: Failed to generate a new TLS certificate.", result, 0xCu);
            }
            v0 = -6700;
          }
          CFRelease(v39);
          CFRelease(v36);
          if (!v0)
            return 1;
        }
        else
        {
          v59 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)result = 136446210;
            *(_QWORD *)&result[4] = "tls_identity_init";
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_FAULT, "%{public}s: Failed to generate a new TLS key.", result, 0xCu);
          }
          CFRelease(v36);
        }
        goto LABEL_124;
      }
      v55 = CFErrorCopyDescription(error);
      CFStringGetCString(v55, result, 200, 0x8000100u);
      v56 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)cf = 136446466;
        *(_QWORD *)&cf[4] = "private_key_generate";
        v69 = 2080;
        v70 = result;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, "%{public}s: SecKeyCreateRandomKey failed to create private key - error description: %s.", cf, 0x16u);
      }
      if (v55)
        CFRelease(v55);
      if (error)
      {
        CFRelease(error);
        error = 0;
      }
    }
    v39 = 0;
    goto LABEL_67;
  }
LABEL_124:
  v60 = global_os_log;
  v54 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (v54)
  {
    *(_DWORD *)result = 136446210;
    *(_QWORD *)&result[4] = "srp_tls_init";
    _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%{public}s: srp_tls_init: tls_identity_init failed.", result, 0xCu);
    return 0;
  }
  return v54;
}

void srp_tls_configure(nw_protocol_options_t *a1)
{
  NSObject *v2;
  sec_identity_t v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  const char *v7;

  v2 = nw_tls_copy_sec_protocol_options(*a1);
  v3 = sec_identity_create((SecIdentityRef)g_tls_identity);
  if (v3)
  {
    v4 = v3;
    sec_protocol_options_set_tls_server_name(v2, "com.apple.dnssd-proxy");
    sec_protocol_options_set_local_identity(v2, v4);
    sec_protocol_options_append_tls_ciphersuite_group(v2, tls_ciphersuite_group_default);
    sec_protocol_options_set_min_tls_protocol_version(v2, tls_protocol_version_TLSv12);
    sec_protocol_options_set_verify_block(v2, &__block_literal_global_498, a1[1]);
    sec_release(v4);
  }
  else
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v6 = 136446210;
      v7 = "srp_tls_configure";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: configure_tls: sec_identity_create failed", (uint8_t *)&v6, 0xCu);
    }
  }
  if (v2)
    nw_release(v2);
}

void __srp_tls_configure_block_invoke(id a1, sec_protocol_metadata *a2, sec_trust *a3, id a4)
{
  (*((void (**)(id, uint64_t))a4 + 2))(a4, 1);
}

void tls_certificate_rotate(uint64_t a1)
{
  CFDateRef v2;
  const __CFDate *v3;
  CFAbsoluteTime Current;
  CFDateRef v5;
  const __CFDate *v6;
  __CFDateFormatter *v7;
  __CFDateFormatter *v8;
  CFStringRef StringWithDate;
  CFStringRef v10;
  CFTimeInterval TimeIntervalSinceDate;
  NSObject *v12;
  const void *v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  const char *v17;
  __int16 v18;
  CFStringRef v19;
  __int16 v20;
  CFStringRef v21;
  __int16 v22;
  CFTimeInterval v23;

  if (g_tls_identity)
  {
    if (*(double *)&g_tls_identity_creation_time > 0.0)
    {
      v2 = CFDateCreate(kCFAllocatorDefault, *(CFAbsoluteTime *)&g_tls_identity_creation_time);
      if (v2)
      {
        v3 = v2;
        Current = CFAbsoluteTimeGetCurrent();
        v5 = CFDateCreate(kCFAllocatorDefault, Current);
        if (v5)
        {
          v6 = v5;
          v7 = CFDateFormatterCreate(0, 0, kCFDateFormatterShortStyle, kCFDateFormatterShortStyle);
          if (v7)
          {
            v8 = v7;
            StringWithDate = CFDateFormatterCreateStringWithDate(0, v7, v6);
            if (StringWithDate)
            {
              v10 = CFDateFormatterCreateStringWithDate(0, v8, v3);
              if (v10)
              {
                TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(v6, v3);
                v12 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  v16 = 136446978;
                  v17 = "srp_tls_dispose";
                  v18 = 2114;
                  v19 = StringWithDate;
                  v20 = 2114;
                  v21 = v10;
                  v22 = 2048;
                  v23 = TimeIntervalSinceDate;
                  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: Rotating the expired TLS certificate - creation date: %{public}@, now: %{public}@, elapsed: %lf.", (uint8_t *)&v16, 0x2Au);
                }
                if (g_tls_identity)
                {
                  sec_release((void *)g_tls_identity);
                  g_tls_identity = 0;
                }
                g_tls_identity_creation_time = 0xBFF0000000000000;
              }
            }
            else
            {
              v10 = 0;
            }
            CFRelease(v8);
            CFRelease(v6);
            if (StringWithDate)
              CFRelease(StringWithDate);
            if (!v10)
              goto LABEL_19;
            v13 = v10;
          }
          else
          {
            v13 = v6;
          }
          CFRelease(v13);
        }
LABEL_19:
        CFRelease(v3);
      }
    }
  }
  if (a1 && (v14 = *(NSObject **)(a1 + 8)) != 0)
  {
    *(_WORD *)(a1 + 416) |= 0x10u;
    nw_listener_cancel(v14);
  }
  else
  {
    v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      v16 = 136446210;
      v17 = "tls_certificate_rotate";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "%{public}s: TLS listener does not exist while the TLS certificate rotation timer is triggered.", (uint8_t *)&v16, 0xCu);
    }
  }
}

void thread_device_startup(uint64_t *a1)
{
  NSObject *v2;
  xpc_object_t v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  int v10;

  thread_device_shutdown(a1);
  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    v8 = "thread_device_startup";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: starting up", buf, 0xCu);
  }
  v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v3, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v3, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v3, "method", "OtCtlCmd");
  xpc_dictionary_set_string(v3, "otctl_cmd", "rloc16");
  v4 = setup_for_command(a1 + 23, (uint64_t)"get_rloc16", 0, 0, v3, (uint64_t)a1, (uint64_t)thread_device_rloc16_callback, (uint64_t)cti_internal_rloc16_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-device.c", 135);
  v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v8 = "cti_get_rloc16_";
    v9 = 1024;
    v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: get_rloc16 result %d", buf, 0x12u);
  }
  xpc_release(v3);
  if (v4)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446466;
      v8 = "thread_device_startup";
      v9 = 1024;
      v10 = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: can't get rloc16: %d", buf, 0x12u);
    }
  }
}

void thread_device_shutdown(uint64_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  const char *v6;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v5 = 136446210;
    v6 = "thread_device_shutdown";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: shutting down", (uint8_t *)&v5, 0xCu);
  }
  v3 = a1[23];
  if (v3)
  {
    cti_events_discontinue(v3);
    a1[23] = 0;
  }
  v4 = a1[24];
  if (v4)
  {
    cti_events_discontinue(v4);
    a1[24] = 0;
  }
  thread_device_stop(a1);
}

void thread_device_rloc16_callback(uint64_t a1, int a2, int a3)
{
  uint64_t v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  uint32_t v8;
  NSObject *v11;
  int v12;
  NSObject *v13;
  const char *v14;
  uint64_t v15;
  _BOOL4 v16;
  _QWORD *v17;
  NSObject *v18;
  _QWORD *v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  const char *v24;
  _QWORD *v25;
  _QWORD *v26;
  int v27;
  int v28;
  int v29;
  _QWORD *v30;
  _QWORD *v31;
  int v32;
  int v33;
  int v34;
  uint64_t *v35;
  uint64_t v36;
  xpc_object_t v37;
  int v38;
  NSObject *v39;
  uint64_t v40;
  int v41;
  int v42;
  int v43;
  void *v44;
  NSObject *v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  int *v50;
  char *v51;
  NSObject *v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  const char *v57;
  uint64_t v58;
  xpc_object_t v59;
  int v60;
  NSObject *v61;
  uint64_t v62;
  int v63;
  int v64;
  int v65;
  uint8_t *v66;
  uint64_t v67;
  int active;
  NSObject *v69;
  int v70;
  int v71;
  int v72;
  int v73;
  uint64_t v74;
  NSObject *v75;
  os_log_type_t v76;
  uint32_t v77;
  int v78;
  int tunnel_name;
  NSObject *v80;
  int v81;
  int v82;
  int v83;
  int v84;
  xpc_object_t v85;
  int v86;
  NSObject *v87;
  int v88;
  int v89;
  int v90;
  xpc_object_t v91;
  int v92;
  NSObject *v93;
  int v94;
  int v95;
  int v96;
  int *v97;
  NSObject *v98;
  int v99;
  int v100;
  int v101;
  NSObject *v102;
  int *v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  _QWORD *v108;
  _QWORD *v109;
  NSObject *v110;
  int v111;
  int v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  NSObject *v116;
  int v117;
  int v118;
  int v119;
  int *v120;
  _QWORD *v121;
  _QWORD *v122;
  uint64_t v123;
  _QWORD *v124;
  _QWORD *v125;
  NSObject *v126;
  int v127;
  int v128;
  int v129;
  uint64_t v130;
  NSObject *v131;
  int v132;
  int v133;
  int v134;
  uint64_t v135;
  void *v136;
  uint64_t v137;
  int v138;
  int v139;
  int v140;
  int *v141;
  char *v142;
  NSObject *v143;
  int v144;
  int v145;
  int v146;
  NSObject *v147;
  const char *v148;
  int v149;
  uint8_t buf[4];
  const char *v151;
  __int16 v152;
  _BYTE v153[14];
  __int16 v154;
  const char *v155;
  __int16 v156;
  char *v157;
  __int16 v158;
  int v159;
  uint8_t v160[4];
  const char *v161;
  __int16 v162;
  _BYTE v163[34];
  __int16 v164;
  int v165;

  if (a3)
  {
    v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446466;
    v151 = "thread_device_rloc16_callback";
    v152 = 1024;
    *(_DWORD *)v153 = a3;
    v5 = "%{public}s: rloc16 get failed with status %d";
    v6 = v4;
    v7 = OS_LOG_TYPE_ERROR;
    v8 = 18;
    goto LABEL_251;
  }
  *(_WORD *)(a1 + 276) = a2;
  v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v151 = "thread_device_rloc16_callback";
    v152 = 1024;
    *(_DWORD *)v153 = a2;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: server_state->rloc16 updated to %d", buf, 0x12u);
  }
  v12 = _os_feature_enabled_impl("mDNSResponder", "srp_on_demand");
  *(_BYTE *)(a1 + 287) = v12;
  v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v14 = "disabled";
    if (v12)
      v14 = "enabled";
    *(_DWORD *)buf = 136446466;
    v151 = "thread_device_rloc16_callback";
    v152 = 2082;
    *(_QWORD *)v153 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: srp on demand is %{public}s", buf, 0x16u);
  }
  v15 = *(_QWORD *)(a1 + 40);
  v16 = v15 == 0;
  if (!v15)
  {
    v17 = malloc_type_calloc(1uLL, 0x40uLL, 0x1020040A7794E27uLL);
    v18 = global_os_log;
    if (!v17)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        ++service_tracker_serial_number;
        *(_DWORD *)buf = 136446466;
        v151 = "service_tracker_create";
        v152 = 2048;
        *(_QWORD *)v153 = service_tracker_serial_number;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory", buf, 0x16u);
        v18 = global_os_log;
      }
      *(_QWORD *)(a1 + 40) = 0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        return;
      *(_DWORD *)buf = 136446210;
      v151 = "thread_device_rloc16_callback";
      v5 = "%{public}s: can't create service tracker.";
      goto LABEL_50;
    }
    v19 = v17;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(_DWORD *)v19;
      *(_DWORD *)buf = 136447490;
      v151 = "service_tracker_create";
      v152 = 1024;
      *(_DWORD *)v153 = v20;
      *(_WORD *)&v153[4] = 2048;
      *(_QWORD *)&v153[6] = v19;
      v154 = 2080;
      v155 = "tracker";
      v156 = 2080;
      v157 = "service-tracker.c";
      v158 = 1024;
      v159 = 361;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v21 = *(_DWORD *)v19;
    if (*(_DWORD *)v19)
    {
      v22 = v21 + 1;
      *(_DWORD *)v19 = v21 + 1;
      if (v21 + 1 >= 10001)
      {
        v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_DWORD *)buf = 136447490;
        v151 = "service_tracker_create";
        v152 = 1024;
        *(_DWORD *)v153 = v22;
        *(_WORD *)&v153[4] = 2048;
        *(_QWORD *)&v153[6] = v19;
        v154 = 2080;
        v155 = "tracker";
        v156 = 2080;
        v157 = "service-tracker.c";
        v158 = 1024;
        v159 = 361;
        v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_95:
        v66 = buf;
LABEL_262:
        v102 = v23;
        goto LABEL_263;
      }
    }
    else
    {
      ++service_tracker_created;
      *(_DWORD *)v19 = 1;
    }
    v19[1] = ++service_tracker_serial_number;
    v19[3] = a1;
    *(_QWORD *)(a1 + 40) = v19;
  }
  if (!*(_QWORD *)(a1 + 56))
  {
    v25 = malloc_type_calloc(1uLL, 0x50uLL, 0x10A004065551B19uLL);
    v18 = global_os_log;
    if (!v25)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        ++thread_tracker_serial_number;
        *(_DWORD *)buf = 136446466;
        v151 = "thread_tracker_create";
        v152 = 2048;
        *(_QWORD *)v153 = thread_tracker_serial_number;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory", buf, 0x16u);
        v18 = global_os_log;
      }
      *(_QWORD *)(a1 + 56) = 0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
        return;
      *(_DWORD *)buf = 136446210;
      v151 = "thread_device_rloc16_callback";
      v5 = "%{public}s: can't create thread tracker.";
      goto LABEL_50;
    }
    v26 = v25;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v27 = *(_DWORD *)v26;
      *(_DWORD *)buf = 136447490;
      v151 = "thread_tracker_create";
      v152 = 1024;
      *(_DWORD *)v153 = v27;
      *(_WORD *)&v153[4] = 2048;
      *(_QWORD *)&v153[6] = v26;
      v154 = 2080;
      v155 = "tracker";
      v156 = 2080;
      v157 = "thread-tracker.c";
      v158 = 1024;
      v159 = 201;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v28 = *(_DWORD *)v26;
    if (*(_DWORD *)v26)
    {
      v29 = v28 + 1;
      *(_DWORD *)v26 = v28 + 1;
      if (v28 + 1 >= 10001)
      {
        v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_DWORD *)buf = 136447490;
        v151 = "thread_tracker_create";
        v152 = 1024;
        *(_DWORD *)v153 = v29;
        *(_WORD *)&v153[4] = 2048;
        *(_QWORD *)&v153[6] = v26;
        v154 = 2080;
        v155 = "tracker";
        v156 = 2080;
        v157 = "thread-tracker.c";
        v158 = 1024;
        v159 = 201;
        v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_95;
      }
    }
    else
    {
      ++thread_tracker_created;
      *(_DWORD *)v26 = 1;
    }
    v26[1] = ++thread_tracker_serial_number;
    v26[4] = a1;
    v26[8] = 0;
    *((_WORD *)v26 + 36) = 0;
    *(_QWORD *)(a1 + 56) = v26;
    v16 = 1;
  }
  if (*(_QWORD *)(a1 + 64))
    goto LABEL_53;
  v30 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A0040209ECF46uLL);
  v18 = global_os_log;
  if (!v30)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      ++node_type_tracker_serial_number;
      *(_DWORD *)buf = 136446466;
      v151 = "node_type_tracker_create";
      v152 = 2048;
      *(_QWORD *)v153 = node_type_tracker_serial_number;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory", buf, 0x16u);
      v18 = global_os_log;
    }
    *(_QWORD *)(a1 + 64) = 0;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
      return;
    *(_DWORD *)buf = 136446210;
    v151 = "thread_device_rloc16_callback";
    v5 = "%{public}s: can't create node type tracker.";
LABEL_50:
    v6 = v18;
LABEL_250:
    v7 = OS_LOG_TYPE_FAULT;
    v8 = 12;
LABEL_251:
    _os_log_impl((void *)&_mh_execute_header, v6, v7, v5, buf, v8);
    return;
  }
  v31 = v30;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v32 = *(_DWORD *)v31;
    *(_DWORD *)buf = 136447490;
    v151 = "node_type_tracker_create";
    v152 = 1024;
    *(_DWORD *)v153 = v32;
    *(_WORD *)&v153[4] = 2048;
    *(_QWORD *)&v153[6] = v31;
    v154 = 2080;
    v155 = "tracker";
    v156 = 2080;
    v157 = "node-type-tracker.c";
    v158 = 1024;
    v159 = 174;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v33 = *(_DWORD *)v31;
  if (*(_DWORD *)v31)
  {
    v34 = v33 + 1;
    *(_DWORD *)v31 = v33 + 1;
    if (v33 + 1 >= 10001)
    {
      v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_264;
      *(_DWORD *)buf = 136447490;
      v151 = "node_type_tracker_create";
      v152 = 1024;
      *(_DWORD *)v153 = v34;
      *(_WORD *)&v153[4] = 2048;
      *(_QWORD *)&v153[6] = v31;
      v154 = 2080;
      v155 = "tracker";
      v156 = 2080;
      v157 = "node-type-tracker.c";
      v158 = 1024;
      v159 = 174;
      v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_95;
    }
  }
  else
  {
    ++node_type_tracker_created;
    *(_DWORD *)v31 = 1;
  }
  v31[1] = ++node_type_tracker_serial_number;
  v31[4] = a1;
  v31[8] = 0;
  *(_QWORD *)(a1 + 64) = v31;
  v16 = 1;
LABEL_53:
  if (*(_QWORD *)(a1 + 48))
  {
    v35 = (uint64_t *)(a1 + 128);
    if (*(_QWORD *)(a1 + 128))
    {
      if (!v16)
        return;
LABEL_56:
      v36 = *(_QWORD *)(a1 + 56);
      v37 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v37, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v37, "path", "/org/wpantund/utun2");
      xpc_dictionary_set_string(v37, "method", "PropGet");
      xpc_dictionary_set_string(v37, "property_name", "NCP:State");
      v38 = setup_for_command((_QWORD *)(v36 + 40), (uint64_t)"get_state", "NCP:State", 0, v37, v36, (uint64_t)thread_tracker_callback, (uint64_t)cti_internal_state_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-tracker.c", 219);
      xpc_release(v37);
      v39 = global_os_log;
      if (v38 && os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v40 = *(_QWORD *)(v36 + 8);
        *(_DWORD *)buf = 136446722;
        v151 = "thread_tracker_start";
        v152 = 2048;
        *(_QWORD *)v153 = v40;
        *(_WORD *)&v153[8] = 1024;
        *(_DWORD *)&v153[10] = v38;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: [TT%lld] service list get failed: %d", buf, 0x1Cu);
        v39 = global_os_log;
      }
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        v41 = *(_DWORD *)v36;
        *(_DWORD *)buf = 136447490;
        v151 = "thread_tracker_start";
        v152 = 1024;
        *(_DWORD *)v153 = v41;
        *(_WORD *)&v153[4] = 2048;
        *(_QWORD *)&v153[6] = v36;
        v154 = 2080;
        v155 = "tracker";
        v156 = 2080;
        v157 = "thread-tracker.c";
        v158 = 1024;
        v159 = 223;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      v42 = *(_DWORD *)v36;
      if (*(_DWORD *)v36)
      {
        v43 = v42 + 1;
        *(_DWORD *)v36 = v42 + 1;
        if (v42 + 1 >= 10001)
        {
          v23 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_264;
          *(_DWORD *)buf = 136447490;
          v151 = "thread_tracker_start";
          v152 = 1024;
          *(_DWORD *)v153 = v43;
          *(_WORD *)&v153[4] = 2048;
          *(_QWORD *)&v153[6] = v36;
          v154 = 2080;
          v155 = "tracker";
          v156 = 2080;
          v157 = "thread-tracker.c";
          v158 = 1024;
          v159 = 223;
          v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_95;
        }
      }
      else
      {
        ++thread_tracker_created;
        *(_DWORD *)v36 = 1;
      }
      v58 = *(_QWORD *)(a1 + 64);
      v59 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v59, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v59, "path", "/org/wpantund/utun2");
      xpc_dictionary_set_string(v59, "method", "PropGet");
      xpc_dictionary_set_string(v59, "property_name", "Network:NodeType");
      v60 = setup_for_command((_QWORD *)(v58 + 40), (uint64_t)"get_network_node_type", "Network:NodeType", 0, v59, v58, (uint64_t)node_type_tracker_callback, (uint64_t)cti_internal_network_node_type_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/node-type-tracker.c", 192);
      xpc_release(v59);
      v61 = global_os_log;
      if (v60 && os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v62 = *(_QWORD *)(v58 + 8);
        *(_DWORD *)buf = 136446722;
        v151 = "node_type_tracker_start";
        v152 = 2048;
        *(_QWORD *)v153 = v62;
        *(_WORD *)&v153[8] = 1024;
        *(_DWORD *)&v153[10] = v60;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: [TT%lld] service list get failed: %d", buf, 0x1Cu);
        v61 = global_os_log;
      }
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        v63 = *(_DWORD *)v58;
        *(_DWORD *)buf = 136447490;
        v151 = "node_type_tracker_start";
        v152 = 1024;
        *(_DWORD *)v153 = v63;
        *(_WORD *)&v153[4] = 2048;
        *(_QWORD *)&v153[6] = v58;
        v154 = 2080;
        v155 = "tracker";
        v156 = 2080;
        v157 = "node-type-tracker.c";
        v158 = 1024;
        v159 = 196;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      v64 = *(_DWORD *)v58;
      if (*(_DWORD *)v58)
      {
        v65 = v64 + 1;
        *(_DWORD *)v58 = v64 + 1;
        if (v64 + 1 >= 10001)
        {
          v23 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_264;
          *(_DWORD *)buf = 136447490;
          v151 = "node_type_tracker_start";
          v152 = 1024;
          *(_DWORD *)v153 = v65;
          *(_WORD *)&v153[4] = 2048;
          *(_QWORD *)&v153[6] = v58;
          v154 = 2080;
          v155 = "tracker";
          v156 = 2080;
          v157 = "node-type-tracker.c";
          v158 = 1024;
          v159 = 196;
          v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_95;
        }
      }
      else
      {
        ++node_type_tracker_created;
        *(_DWORD *)v58 = 1;
      }
      v67 = *(_QWORD *)(a1 + 48);
      active = cti_track_active_data_set_((_QWORD *)(v67 + 152), v67, (uint64_t)service_publisher_active_data_set_changed_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1815);
      v69 = global_os_log;
      if (active)
      {
        v70 = active;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          v152 = 1024;
          *(_DWORD *)v153 = v70;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%{public}s: unable to start tracking active dataset: %d", buf, 0x12u);
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v71 = *(_DWORD *)v67;
          *(_DWORD *)buf = 136447490;
          v151 = "service_publisher_start";
          v152 = 1024;
          *(_DWORD *)v153 = v71;
          *(_WORD *)&v153[4] = 2048;
          *(_QWORD *)&v153[6] = v67;
          v154 = 2080;
          v155 = "publisher";
          v156 = 2080;
          v157 = "service-publisher.c";
          v158 = 1024;
          v159 = 1819;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        v72 = *(_DWORD *)v67;
        if (*(_DWORD *)v67)
        {
          v73 = v72 + 1;
          *(_DWORD *)v67 = v72 + 1;
          if (v72 + 1 >= 10001)
          {
            v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_264;
            *(_DWORD *)buf = 136447490;
            v151 = "service_publisher_start";
            v152 = 1024;
            *(_DWORD *)v153 = v73;
            *(_WORD *)&v153[4] = 2048;
            *(_QWORD *)&v153[6] = v67;
            v154 = 2080;
            v155 = "publisher";
            v156 = 2080;
            v157 = "service-publisher.c";
            v158 = 1024;
            v159 = 1819;
            v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)v67 = 1;
        }
      }
      tunnel_name = cti_get_tunnel_name_(v67, (uint64_t)service_publisher_tunnel_name_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1822);
      v80 = global_os_log;
      if (tunnel_name)
      {
        v81 = tunnel_name;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          v152 = 1024;
          *(_DWORD *)v153 = v81;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%{public}s: unable to get tunnel name: %d", buf, 0x12u);
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v82 = *(_DWORD *)v67;
          *(_DWORD *)buf = 136447490;
          v151 = "service_publisher_start";
          v152 = 1024;
          *(_DWORD *)v153 = v82;
          *(_WORD *)&v153[4] = 2048;
          *(_QWORD *)&v153[6] = v67;
          v154 = 2080;
          v155 = "publisher";
          v156 = 2080;
          v157 = "service-publisher.c";
          v158 = 1024;
          v159 = 1826;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        v83 = *(_DWORD *)v67;
        if (*(_DWORD *)v67)
        {
          v84 = v83 + 1;
          *(_DWORD *)v67 = v83 + 1;
          if (v83 + 1 >= 10001)
          {
            v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_264;
            *(_DWORD *)buf = 136447490;
            v151 = "service_publisher_start";
            v152 = 1024;
            *(_DWORD *)v153 = v84;
            *(_WORD *)&v153[4] = 2048;
            *(_QWORD *)&v153[6] = v67;
            v154 = 2080;
            v155 = "publisher";
            v156 = 2080;
            v157 = "service-publisher.c";
            v158 = 1024;
            v159 = 1826;
            v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)v67 = 1;
        }
      }
      v85 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v85, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v85, "path", "/org/wpantund/utun2");
      xpc_dictionary_set_string(v85, "method", "PropGet");
      xpc_dictionary_set_string(v85, "property_name", "WakeOnDeviceConnectionStatus");
      v86 = setup_for_command((_QWORD *)(v67 + 160), (uint64_t)"get_wed_status", "WakeOnDeviceConnectionStatus", 0, v85, v67, (uint64_t)service_publisher_wed_callback, (uint64_t)cti_internal_wed_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1831);
      xpc_release(v85);
      v87 = global_os_log;
      if (v86)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          v152 = 1024;
          *(_DWORD *)v153 = v86;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_FAULT, "%{public}s: can't track WED status: %d", buf, 0x12u);
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v88 = *(_DWORD *)v67;
          *(_DWORD *)buf = 136447490;
          v151 = "service_publisher_start";
          v152 = 1024;
          *(_DWORD *)v153 = v88;
          *(_WORD *)&v153[4] = 2048;
          *(_QWORD *)&v153[6] = v67;
          v154 = 2080;
          v155 = "publisher";
          v156 = 2080;
          v157 = "service-publisher.c";
          v158 = 1024;
          v159 = 1835;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        v89 = *(_DWORD *)v67;
        if (*(_DWORD *)v67)
        {
          v90 = v89 + 1;
          *(_DWORD *)v67 = v89 + 1;
          if (v89 + 1 >= 10001)
          {
            v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_264;
            *(_DWORD *)buf = 136447490;
            v151 = "service_publisher_start";
            v152 = 1024;
            *(_DWORD *)v153 = v90;
            *(_WORD *)&v153[4] = 2048;
            *(_QWORD *)&v153[6] = v67;
            v154 = 2080;
            v155 = "publisher";
            v156 = 2080;
            v157 = "service-publisher.c";
            v158 = 1024;
            v159 = 1835;
            v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)v67 = 1;
        }
      }
      v91 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v91, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v91, "path", "/org/wpantund/utun2");
      xpc_dictionary_set_string(v91, "method", "PropGet");
      xpc_dictionary_set_string(v91, "property_name", "ThreadNeighborMeshLocalAddress");
      v92 = setup_for_command((_QWORD *)(v67 + 168), (uint64_t)"get_neighbor_ml_eid", "ThreadNeighborMeshLocalAddress", (uint64_t)"ThreadNeighborMeshLocalAddress", v91, v67, (uint64_t)service_publisher_neighbor_callback, (uint64_t)cti_internal_string_event_reply, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1839);
      xpc_release(v91);
      v93 = global_os_log;
      if (v92)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          v152 = 1024;
          *(_DWORD *)v153 = v92;
          _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_FAULT, "%{public}s: can't track WED status: %d", buf, 0x12u);
        }
LABEL_153:
        service_publisher_active_data_set_changed_callback(v67, 0);
        state_machine_next_state(v67 + 8, 1u);
        v97 = (int *)*v35;
        cti_track_active_data_set_((_QWORD *)(*v35 + 96), *v35, (uint64_t)dnssd_client_active_data_set_changed_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 714);
        v98 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v99 = *v97;
          *(_DWORD *)buf = 136447490;
          v151 = "dnssd_client_start";
          v152 = 1024;
          *(_DWORD *)v153 = v99;
          *(_WORD *)&v153[4] = 2048;
          *(_QWORD *)&v153[6] = v97;
          v154 = 2080;
          v155 = "client";
          v156 = 2080;
          v157 = "dnssd-client.c";
          v158 = 1024;
          v159 = 715;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        v100 = *v97;
        if (*v97)
        {
          v101 = v100 + 1;
          *v97 = v100 + 1;
          if (v100 + 1 >= 10001)
          {
            v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_264;
            *(_DWORD *)buf = 136447490;
            v151 = "dnssd_client_start";
            v152 = 1024;
            *(_DWORD *)v153 = v101;
            *(_WORD *)&v153[4] = 2048;
            *(_QWORD *)&v153[6] = v97;
            v154 = 2080;
            v155 = "client";
            v156 = 2080;
            v157 = "dnssd-client.c";
            v158 = 1024;
            v159 = 715;
            v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++dnssd_client_created;
          *v97 = 1;
        }
        dnssd_client_active_data_set_changed_callback((uint64_t)v97, 0);
        state_machine_next_state((uint64_t)(v97 + 2), 1u);
        return;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v94 = *(_DWORD *)v67;
        *(_DWORD *)buf = 136447490;
        v151 = "service_publisher_start";
        v152 = 1024;
        *(_DWORD *)v153 = v94;
        *(_WORD *)&v153[4] = 2048;
        *(_QWORD *)&v153[6] = v67;
        v154 = 2080;
        v155 = "publisher";
        v156 = 2080;
        v157 = "service-publisher.c";
        v158 = 1024;
        v159 = 1843;
        _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      v95 = *(_DWORD *)v67;
      if (!*(_DWORD *)v67)
      {
        ++service_publisher_created;
        *(_DWORD *)v67 = 1;
        goto LABEL_153;
      }
      v96 = v95 + 1;
      *(_DWORD *)v67 = v95 + 1;
      if (v95 + 1 < 10001)
        goto LABEL_153;
      v74 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_264;
      *(_DWORD *)buf = 136447490;
      v151 = "service_publisher_start";
      v152 = 1024;
      *(_DWORD *)v153 = v96;
      *(_WORD *)&v153[4] = 2048;
      *(_QWORD *)&v153[6] = v67;
      v154 = 2080;
      v155 = "publisher";
      v156 = 2080;
      v157 = "service-publisher.c";
      v158 = 1024;
      v159 = 1843;
      v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_159:
      v66 = buf;
      v102 = v74;
LABEL_263:
      _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_FAULT, v24, v66, 0x36u);
      goto LABEL_264;
    }
LABEL_214:
    v136 = malloc_type_calloc(1uLL, 0xB0uLL, 0x10F004009DEA24DuLL);
    v45 = global_os_log;
    if (!v136)
    {
LABEL_247:
      *v35 = 0;
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
        return;
      *(_DWORD *)buf = 136446210;
      v151 = "thread_device_rloc16_callback";
      v5 = "%{public}s: can't create dnssd client";
LABEL_249:
      v6 = v45;
      goto LABEL_250;
    }
    v137 = (uint64_t)v136;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v138 = *(_DWORD *)v137;
      *(_DWORD *)v160 = 136447490;
      v161 = "dnssd_client_create";
      v162 = 1024;
      *(_DWORD *)v163 = v138;
      *(_WORD *)&v163[4] = 2048;
      *(_QWORD *)&v163[6] = v137;
      *(_WORD *)&v163[14] = 2080;
      *(_QWORD *)&v163[16] = "client";
      *(_WORD *)&v163[24] = 2080;
      *(_QWORD *)&v163[26] = "dnssd-client.c";
      v164 = 1024;
      v165 = 626;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
    }
    v139 = *(_DWORD *)v137;
    if (*(_DWORD *)v137)
    {
      v140 = v139 + 1;
      *(_DWORD *)v137 = v139 + 1;
      if (v139 + 1 >= 10001)
      {
        v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_DWORD *)v160 = 136447490;
        v161 = "dnssd_client_create";
        v162 = 1024;
        *(_DWORD *)v163 = v140;
        *(_WORD *)&v163[4] = 2048;
        *(_QWORD *)&v163[6] = v137;
        *(_WORD *)&v163[14] = 2080;
        *(_QWORD *)&v163[16] = "client";
        *(_WORD *)&v163[24] = 2080;
        *(_QWORD *)&v163[26] = "dnssd-client.c";
        v164 = 1024;
        v165 = 626;
        v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_261;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)v137 = 1;
    }
    v141 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 627);
    *(_QWORD *)(v137 + 88) = v141;
    if (v141)
    {
      snprintf((char *)buf, 0x64uLL, "[DC%lld]", ++dnssd_client_serial_number);
      v142 = strdup((const char *)buf);
      *(_QWORD *)(v137 + 72) = v142;
      if (v142)
      {
        *(_QWORD *)(v137 + 160) = 0xFFFFFFFF00000002;
        *(_WORD *)(v137 + 168) = 853;
        if ((state_machine_header_setup(v137 + 8, v137, v142, 3, (uint64_t)&dnssd_client_states, 5) & 1) != 0)
        {
          *(_QWORD *)(v137 + 80) = a1;
          if (service_tracker_callback_add(*(int **)(a1 + 40), (uint64_t)dnssd_client_service_tracker_callback, (uint64_t)dnssd_client_context_release, v137))
          {
            v143 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v144 = *(_DWORD *)v137;
              *(_DWORD *)v160 = 136447490;
              v161 = "dnssd_client_create";
              v162 = 1024;
              *(_DWORD *)v163 = v144;
              *(_WORD *)&v163[4] = 2048;
              *(_QWORD *)&v163[6] = v137;
              *(_WORD *)&v163[14] = 2080;
              *(_QWORD *)&v163[16] = "client";
              *(_WORD *)&v163[24] = 2080;
              *(_QWORD *)&v163[26] = "dnssd-client.c";
              v164 = 1024;
              v165 = 659;
              _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
            }
            v145 = *(_DWORD *)v137;
            if (*(_DWORD *)v137)
            {
              v146 = v145 + 1;
              *(_DWORD *)v137 = v145 + 1;
              if (v145 + 1 >= 10001)
              {
                v23 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  goto LABEL_264;
                *(_DWORD *)v160 = 136447490;
                v161 = "dnssd_client_create";
                v162 = 1024;
                *(_DWORD *)v163 = v146;
                *(_WORD *)&v163[4] = 2048;
                *(_QWORD *)&v163[6] = v137;
                *(_WORD *)&v163[14] = 2080;
                *(_QWORD *)&v163[16] = "client";
                *(_WORD *)&v163[24] = 2080;
                *(_QWORD *)&v163[26] = "dnssd-client.c";
                v164 = 1024;
                v165 = 659;
                v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_261;
              }
            }
            else
            {
              ++dnssd_client_created;
              *(_DWORD *)v137 = 1;
            }
            *v35 = v137;
            goto LABEL_56;
          }
          goto LABEL_239;
        }
        v147 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v160 = 136446210;
          v161 = "dnssd_client_create";
          v148 = "%{public}s: header setup failed";
          goto LABEL_238;
        }
LABEL_239:
        v149 = *(_DWORD *)v137;
        if (!*(_DWORD *)v137)
        {
          v23 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_264;
          *(_DWORD *)v160 = 136447490;
          v161 = "dnssd_client_create";
          v162 = 1024;
          *(_DWORD *)v163 = 0;
          *(_WORD *)&v163[4] = 2048;
          *(_QWORD *)&v163[6] = v137;
          *(_WORD *)&v163[14] = 2080;
          *(_QWORD *)&v163[16] = "client";
          *(_WORD *)&v163[24] = 2080;
          *(_QWORD *)&v163[26] = "dnssd-client.c";
          v164 = 1024;
          v165 = 665;
          v24 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_261;
        }
        v45 = global_os_log;
        if (v149 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v160 = 136447490;
            v161 = "dnssd_client_create";
            v162 = 1024;
            *(_DWORD *)v163 = v149;
            *(_WORD *)&v163[4] = 2048;
            *(_QWORD *)&v163[6] = v137;
            *(_WORD *)&v163[14] = 2080;
            *(_QWORD *)&v163[16] = "client";
            *(_WORD *)&v163[24] = 2080;
            *(_QWORD *)&v163[26] = "dnssd-client.c";
            v164 = 1024;
            v165 = 665;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
            v149 = *(_DWORD *)v137;
            v45 = global_os_log;
          }
          *(_DWORD *)v137 = v149 - 1;
          if (v149 == 1)
          {
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v160 = 136447234;
              v161 = "dnssd_client_create";
              v162 = 2048;
              *(_QWORD *)v163 = v137;
              *(_WORD *)&v163[8] = 2080;
              *(_QWORD *)&v163[10] = "client";
              *(_WORD *)&v163[18] = 2080;
              *(_QWORD *)&v163[20] = "dnssd-client.c";
              *(_WORD *)&v163[28] = 1024;
              *(_DWORD *)&v163[30] = 665;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v160, 0x30u);
            }
            ++dnssd_client_finalized;
            dnssd_client_finalize(v137);
            v45 = global_os_log;
          }
          goto LABEL_247;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_264:
          abort();
        *(_DWORD *)v160 = 136447490;
        v161 = "dnssd_client_create";
        v162 = 1024;
        *(_DWORD *)v163 = v149;
        *(_WORD *)&v163[4] = 2048;
        *(_QWORD *)&v163[6] = v137;
        *(_WORD *)&v163[14] = 2080;
        *(_QWORD *)&v163[16] = "client";
        *(_WORD *)&v163[24] = 2080;
        *(_QWORD *)&v163[26] = "dnssd-client.c";
        v164 = 1024;
        v165 = 665;
        v24 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_267:
        v66 = v160;
        v102 = v45;
        goto LABEL_263;
      }
      v147 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_239;
      *(_DWORD *)v160 = 136446210;
      v161 = "dnssd_client_create";
      v148 = "%{public}s: no memory for client ID";
    }
    else
    {
      v147 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_239;
      *(_DWORD *)v160 = 136446210;
      v161 = "dnssd_client_create";
      v148 = "%{public}s: wakeup timer alloc failed";
    }
LABEL_238:
    _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_ERROR, v148, v160, 0xCu);
    goto LABEL_239;
  }
  v44 = malloc_type_calloc(1uLL, 0x110uLL, 0x10F00405A5F544EuLL);
  v45 = global_os_log;
  if (!v44)
    goto LABEL_120;
  v46 = (uint64_t)v44;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v47 = *(_DWORD *)v46;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    v162 = 1024;
    *(_DWORD *)v163 = v47;
    *(_WORD *)&v163[4] = 2048;
    *(_QWORD *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(_QWORD *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(_QWORD *)&v163[26] = "service-publisher.c";
    v164 = 1024;
    v165 = 1482;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
  }
  v48 = *(_DWORD *)v46;
  if (*(_DWORD *)v46)
  {
    v49 = v48 + 1;
    *(_DWORD *)v46 = v48 + 1;
    if (v48 + 1 >= 10001)
    {
      v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_264;
      *(_DWORD *)v160 = 136447490;
      v161 = "service_publisher_create";
      v162 = 1024;
      *(_DWORD *)v163 = v49;
      *(_WORD *)&v163[4] = 2048;
      *(_QWORD *)&v163[6] = v46;
      *(_WORD *)&v163[14] = 2080;
      *(_QWORD *)&v163[16] = "publisher";
      *(_WORD *)&v163[24] = 2080;
      *(_QWORD *)&v163[26] = "service-publisher.c";
      v164 = 1024;
      v165 = 1482;
      v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_261:
      v66 = v160;
      goto LABEL_262;
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)v46 = 1;
  }
  v50 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1483);
  *(_QWORD *)(v46 + 96) = v50;
  if (!v50)
  {
    v56 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_112;
    *(_DWORD *)v160 = 136446210;
    v161 = "service_publisher_create";
    v57 = "%{public}s: wakeup timer alloc failed";
    goto LABEL_110;
  }
  snprintf((char *)buf, 0x64uLL, "[SP%lld]", ++service_publisher_serial_number);
  v51 = strdup((const char *)buf);
  *(_QWORD *)(v46 + 72) = v51;
  if (!v51)
  {
    v56 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_112;
    *(_DWORD *)v160 = 136446210;
    v161 = "service_publisher_create";
    v57 = "%{public}s: no memory for server ID";
    goto LABEL_110;
  }
  if ((state_machine_header_setup(v46 + 8, v46, v51, 2, (uint64_t)&service_publisher_states, 6) & 1) == 0)
  {
    v56 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_112;
    *(_DWORD *)v160 = 136446210;
    v161 = "service_publisher_create";
    v57 = "%{public}s: header setup failed";
LABEL_110:
    v75 = v56;
    v76 = OS_LOG_TYPE_ERROR;
    v77 = 12;
    goto LABEL_111;
  }
  *(_QWORD *)(v46 + 88) = a1;
  if (!service_tracker_callback_add(*(int **)(a1 + 40), (uint64_t)service_publisher_service_tracker_callback, (uint64_t)service_publisher_context_release, v46))goto LABEL_112;
  v52 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v53 = *(_DWORD *)v46;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    v162 = 1024;
    *(_DWORD *)v163 = v53;
    *(_WORD *)&v163[4] = 2048;
    *(_QWORD *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(_QWORD *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(_QWORD *)&v163[26] = "service-publisher.c";
    v164 = 1024;
    v165 = 1512;
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
  }
  v54 = *(_DWORD *)v46;
  if (*(_DWORD *)v46)
  {
    v55 = v54 + 1;
    *(_DWORD *)v46 = v54 + 1;
    if (v54 + 1 >= 10001)
    {
      v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_264;
      *(_DWORD *)v160 = 136447490;
      v161 = "service_publisher_create";
      v162 = 1024;
      *(_DWORD *)v163 = v55;
      *(_WORD *)&v163[4] = 2048;
      *(_QWORD *)&v163[6] = v46;
      *(_WORD *)&v163[14] = 2080;
      *(_QWORD *)&v163[16] = "publisher";
      *(_WORD *)&v163[24] = 2080;
      *(_QWORD *)&v163[26] = "service-publisher.c";
      v164 = 1024;
      v165 = 1512;
      v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_261;
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)v46 = 1;
  }
  v103 = *(int **)(a1 + 56);
  v104 = v103 + 12;
  while (1)
  {
    v105 = (_QWORD *)*v104;
    if (!*v104)
      break;
    v104 = (_QWORD *)*v104;
    if (v105[3] == v46)
    {
      v106 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v107 = *((_QWORD *)v103 + 1);
        *(_DWORD *)v160 = 136446722;
        v161 = "thread_tracker_callback_add";
        v162 = 2048;
        *(_QWORD *)v163 = v107;
        *(_WORD *)&v163[8] = 2048;
        *(_QWORD *)&v163[10] = v46;
        v57 = "%{public}s: [TT%lld] duplicate context %p";
        goto LABEL_192;
      }
      goto LABEL_112;
    }
  }
  v108 = malloc_type_calloc(1uLL, 0x20uLL, 0xA00403705585FuLL);
  if (!v108)
  {
    v114 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_112;
    v115 = *((_QWORD *)v103 + 1);
    *(_DWORD *)v160 = 136446466;
    v161 = "thread_tracker_callback_add";
    v162 = 2048;
    *(_QWORD *)v163 = v115;
    v57 = "%{public}s: [TT%lld] no memory";
    goto LABEL_204;
  }
  v109 = v108;
  v108[1] = service_publisher_context_release;
  v108[2] = service_publisher_thread_tracker_callback;
  v108[3] = v46;
  if (v103 && !*((_QWORD *)v103 + 6))
  {
    v110 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v111 = *v103;
      *(_DWORD *)v160 = 136447490;
      v161 = "thread_tracker_callback_add";
      v162 = 1024;
      *(_DWORD *)v163 = v111;
      *(_WORD *)&v163[4] = 2048;
      *(_QWORD *)&v163[6] = v103;
      *(_WORD *)&v163[14] = 2080;
      *(_QWORD *)&v163[16] = "tracker";
      *(_WORD *)&v163[24] = 2080;
      *(_QWORD *)&v163[26] = "thread-tracker.c";
      v164 = 1024;
      v165 = 252;
      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
    }
    v112 = *v103;
    if (*v103)
    {
      v113 = v112 + 1;
      *v103 = v112 + 1;
      if (v112 + 1 >= 10001)
      {
        v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_264;
        *(_DWORD *)v160 = 136447490;
        v161 = "thread_tracker_callback_add";
        v162 = 1024;
        *(_DWORD *)v163 = v113;
        *(_WORD *)&v163[4] = 2048;
        *(_QWORD *)&v163[6] = v103;
        *(_WORD *)&v163[14] = 2080;
        *(_QWORD *)&v163[16] = "tracker";
        *(_WORD *)&v163[24] = 2080;
        *(_QWORD *)&v163[26] = "thread-tracker.c";
        v164 = 1024;
        v165 = 252;
        v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_261;
      }
    }
    else
    {
      ++thread_tracker_created;
      *v103 = 1;
    }
  }
  *v104 = v109;
  v116 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v117 = *(_DWORD *)v46;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    v162 = 1024;
    *(_DWORD *)v163 = v117;
    *(_WORD *)&v163[4] = 2048;
    *(_QWORD *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(_QWORD *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(_QWORD *)&v163[26] = "service-publisher.c";
    v164 = 1024;
    v165 = 1519;
    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
  }
  v118 = *(_DWORD *)v46;
  if (*(_DWORD *)v46)
  {
    v119 = v118 + 1;
    *(_DWORD *)v46 = v118 + 1;
    if (v118 + 1 >= 10001)
    {
      v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_264;
      *(_DWORD *)v160 = 136447490;
      v161 = "service_publisher_create";
      v162 = 1024;
      *(_DWORD *)v163 = v119;
      *(_WORD *)&v163[4] = 2048;
      *(_QWORD *)&v163[6] = v46;
      *(_WORD *)&v163[14] = 2080;
      *(_QWORD *)&v163[16] = "publisher";
      *(_WORD *)&v163[24] = 2080;
      *(_QWORD *)&v163[26] = "service-publisher.c";
      v164 = 1024;
      v165 = 1519;
      v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_261;
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)v46 = 1;
  }
  v120 = *(int **)(a1 + 64);
  v121 = v120 + 12;
  do
  {
    v122 = (_QWORD *)*v121;
    if (!*v121)
    {
      v124 = malloc_type_calloc(1uLL, 0x20uLL, 0xA00403705585FuLL);
      if (v124)
      {
        v125 = v124;
        v124[1] = service_publisher_context_release;
        v124[2] = service_publisher_node_type_tracker_callback;
        v124[3] = v46;
        if (v120 && !*((_QWORD *)v120 + 6))
        {
          v126 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v127 = *v120;
            *(_DWORD *)v160 = 136447490;
            v161 = "node_type_tracker_callback_add";
            v162 = 1024;
            *(_DWORD *)v163 = v127;
            *(_WORD *)&v163[4] = 2048;
            *(_QWORD *)&v163[6] = v120;
            *(_WORD *)&v163[14] = 2080;
            *(_QWORD *)&v163[16] = "tracker";
            *(_WORD *)&v163[24] = 2080;
            *(_QWORD *)&v163[26] = "node-type-tracker.c";
            v164 = 1024;
            v165 = 225;
            _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
          }
          v128 = *v120;
          if (*v120)
          {
            v129 = v128 + 1;
            *v120 = v128 + 1;
            if (v128 + 1 >= 10001)
            {
              v23 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_264;
              *(_DWORD *)v160 = 136447490;
              v161 = "node_type_tracker_callback_add";
              v162 = 1024;
              *(_DWORD *)v163 = v129;
              *(_WORD *)&v163[4] = 2048;
              *(_QWORD *)&v163[6] = v120;
              *(_WORD *)&v163[14] = 2080;
              *(_QWORD *)&v163[16] = "tracker";
              *(_WORD *)&v163[24] = 2080;
              *(_QWORD *)&v163[26] = "node-type-tracker.c";
              v164 = 1024;
              v165 = 225;
              v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_261;
            }
          }
          else
          {
            ++node_type_tracker_created;
            *v120 = 1;
          }
        }
        *v121 = v125;
        v131 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v132 = *(_DWORD *)v46;
          *(_DWORD *)v160 = 136447490;
          v161 = "service_publisher_create";
          v162 = 1024;
          *(_DWORD *)v163 = v132;
          *(_WORD *)&v163[4] = 2048;
          *(_QWORD *)&v163[6] = v46;
          *(_WORD *)&v163[14] = 2080;
          *(_QWORD *)&v163[16] = "publisher";
          *(_WORD *)&v163[24] = 2080;
          *(_QWORD *)&v163[26] = "service-publisher.c";
          v164 = 1024;
          v165 = 1526;
          _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
        }
        v133 = *(_DWORD *)v46;
        if (*(_DWORD *)v46)
        {
          v134 = v133 + 1;
          *(_DWORD *)v46 = v133 + 1;
          if (v133 + 1 >= 10001)
          {
            v23 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_264;
            *(_DWORD *)v160 = 136447490;
            v161 = "service_publisher_create";
            v162 = 1024;
            *(_DWORD *)v163 = v134;
            *(_WORD *)&v163[4] = 2048;
            *(_QWORD *)&v163[6] = v46;
            *(_WORD *)&v163[14] = 2080;
            *(_QWORD *)&v163[16] = "publisher";
            *(_WORD *)&v163[24] = 2080;
            *(_QWORD *)&v163[26] = "service-publisher.c";
            v164 = 1024;
            v165 = 1526;
            v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_261;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)v46 = 1;
        }
        *(_BYTE *)(v46 + 259) = 1;
        *(_DWORD *)(v46 + 248) = 750;
        v35 = (uint64_t *)(a1 + 128);
        v135 = *(_QWORD *)(a1 + 128);
        *(_QWORD *)(a1 + 48) = v46;
        if (v135)
          goto LABEL_56;
        goto LABEL_214;
      }
      v114 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_112;
      v130 = *((_QWORD *)v120 + 1);
      *(_DWORD *)v160 = 136446466;
      v161 = "node_type_tracker_callback_add";
      v162 = 2048;
      *(_QWORD *)v163 = v130;
      v57 = "%{public}s: [TT%lld] no memory";
LABEL_204:
      v75 = v114;
      v76 = OS_LOG_TYPE_ERROR;
      v77 = 22;
      goto LABEL_111;
    }
    v121 = (_QWORD *)*v121;
  }
  while (v122[3] != v46);
  v106 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    v123 = *((_QWORD *)v120 + 1);
    *(_DWORD *)v160 = 136446722;
    v161 = "node_type_tracker_callback_add";
    v162 = 2048;
    *(_QWORD *)v163 = v123;
    *(_WORD *)&v163[8] = 2048;
    *(_QWORD *)&v163[10] = v46;
    v57 = "%{public}s: [TT%lld] duplicate context %p";
LABEL_192:
    v75 = v106;
    v76 = OS_LOG_TYPE_FAULT;
    v77 = 32;
LABEL_111:
    _os_log_impl((void *)&_mh_execute_header, v75, v76, v57, v160, v77);
  }
LABEL_112:
  v78 = *(_DWORD *)v46;
  if (!*(_DWORD *)v46)
  {
    v23 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_264;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    v162 = 1024;
    *(_DWORD *)v163 = 0;
    *(_WORD *)&v163[4] = 2048;
    *(_QWORD *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(_QWORD *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(_QWORD *)&v163[26] = "service-publisher.c";
    v164 = 1024;
    v165 = 1535;
    v24 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_261;
  }
  v45 = global_os_log;
  if (v78 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_264;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    v162 = 1024;
    *(_DWORD *)v163 = v78;
    *(_WORD *)&v163[4] = 2048;
    *(_QWORD *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(_QWORD *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(_QWORD *)&v163[26] = "service-publisher.c";
    v164 = 1024;
    v165 = 1535;
    v24 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_267;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    v162 = 1024;
    *(_DWORD *)v163 = v78;
    *(_WORD *)&v163[4] = 2048;
    *(_QWORD *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(_QWORD *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(_QWORD *)&v163[26] = "service-publisher.c";
    v164 = 1024;
    v165 = 1535;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
    v78 = *(_DWORD *)v46;
    v45 = global_os_log;
  }
  *(_DWORD *)v46 = v78 - 1;
  if (v78 == 1)
  {
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v160 = 136447234;
      v161 = "service_publisher_create";
      v162 = 2048;
      *(_QWORD *)v163 = v46;
      *(_WORD *)&v163[8] = 2080;
      *(_QWORD *)&v163[10] = "publisher";
      *(_WORD *)&v163[18] = 2080;
      *(_QWORD *)&v163[20] = "service-publisher.c";
      *(_WORD *)&v163[28] = 1024;
      *(_DWORD *)&v163[30] = 1535;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v160, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(v46);
    v45 = global_os_log;
  }
LABEL_120:
  *(_QWORD *)(a1 + 48) = 0;
  if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446210;
    v151 = "thread_device_rloc16_callback";
    v5 = "%{public}s: can't create service publisher.";
    goto LABEL_249;
  }
}

void thread_device_stop(uint64_t *a1)
{
  NSObject *v2;
  uint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  void (*v6)(_QWORD);
  _QWORD *v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  _QWORD *v11;
  int v12;
  NSObject *v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  NSObject *v17;
  _QWORD *v18;
  void (*v19)(_QWORD);
  _QWORD *v20;
  int v21;
  NSObject *v22;
  int *v23;
  int v24;
  NSObject *v25;
  _QWORD *v26;
  uint64_t v27;
  int v28;
  NSObject *v29;
  _QWORD *v30;
  void (*v31)(_QWORD);
  _QWORD *v32;
  int v33;
  NSObject *v34;
  int *v35;
  int v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  NSObject *v42;
  int v43;
  const char *v44;
  __int16 v45;
  _BYTE v46[34];
  __int16 v47;
  int v48;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v43 = 136446210;
    v44 = "thread_device_stop";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: stopping", (uint8_t *)&v43, 0xCu);
  }
  v3 = a1[5];
  if (v3)
  {
    service_tracker_cancel_probes(v3);
    v4 = (_QWORD *)a1[5];
    if (v4)
    {
      service_tracker_stop((_QWORD *)a1[5]);
      v5 = (_QWORD *)v4[5];
      if (v5)
      {
        do
        {
          v7 = (_QWORD *)*v5;
          v6 = (void (*)(_QWORD))v5[1];
          if (v6)
            v6(v5[3]);
          free(v5);
          v5 = v7;
        }
        while (v7);
        v4[5] = 0;
        v8 = *(_DWORD *)v4;
        if (!*(_DWORD *)v4)
        {
          v40 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_131;
          v43 = 136447490;
          v44 = "service_tracker_cancel";
          v45 = 1024;
          *(_DWORD *)v46 = 0;
          *(_WORD *)&v46[4] = 2048;
          *(_QWORD *)&v46[6] = v4;
          *(_WORD *)&v46[14] = 2080;
          *(_QWORD *)&v46[16] = "tracker";
          *(_WORD *)&v46[24] = 2080;
          *(_QWORD *)&v46[26] = "service-tracker.c";
          v47 = 1024;
          v48 = 473;
          v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_126;
        }
        v9 = global_os_log;
        if (v8 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_131;
          v43 = 136447490;
          v44 = "service_tracker_cancel";
          v45 = 1024;
          *(_DWORD *)v46 = v8;
          *(_WORD *)&v46[4] = 2048;
          *(_QWORD *)&v46[6] = v4;
          *(_WORD *)&v46[14] = 2080;
          *(_QWORD *)&v46[16] = "tracker";
          *(_WORD *)&v46[24] = 2080;
          *(_QWORD *)&v46[26] = "service-tracker.c";
          v47 = 1024;
          v48 = 473;
          v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_129;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136447490;
          v44 = "service_tracker_cancel";
          v45 = 1024;
          *(_DWORD *)v46 = v8;
          *(_WORD *)&v46[4] = 2048;
          *(_QWORD *)&v46[6] = v4;
          *(_WORD *)&v46[14] = 2080;
          *(_QWORD *)&v46[16] = "tracker";
          *(_WORD *)&v46[24] = 2080;
          *(_QWORD *)&v46[26] = "service-tracker.c";
          v47 = 1024;
          v48 = 473;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
          v8 = *(_DWORD *)v4;
        }
        *(_DWORD *)v4 = v8 - 1;
        if (v8 == 1)
        {
          v10 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v43 = 136447234;
            v44 = "service_tracker_cancel";
            v45 = 2048;
            *(_QWORD *)v46 = v4;
            *(_WORD *)&v46[8] = 2080;
            *(_QWORD *)&v46[10] = "tracker";
            *(_WORD *)&v46[18] = 2080;
            *(_QWORD *)&v46[20] = "service-tracker.c";
            *(_WORD *)&v46[28] = 1024;
            *(_DWORD *)&v46[30] = 473;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
          }
          ++service_tracker_finalized;
          service_tracker_finalize(v4);
        }
      }
      v11 = (_QWORD *)a1[5];
      if (v11)
      {
        v12 = *(_DWORD *)v11;
        if (!*(_DWORD *)v11)
        {
          v40 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_131;
          v43 = 136447490;
          v44 = "service_tracker_release_";
          v45 = 1024;
          *(_DWORD *)v46 = 0;
          *(_WORD *)&v46[4] = 2048;
          *(_QWORD *)&v46[6] = v11;
          *(_WORD *)&v46[14] = 2080;
          *(_QWORD *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(_QWORD *)&v46[26] = "thread-device.c";
          v47 = 1024;
          v48 = 148;
          v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_126;
        }
        v9 = global_os_log;
        if (v12 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_131;
          v43 = 136447490;
          v44 = "service_tracker_release_";
          v45 = 1024;
          *(_DWORD *)v46 = v12;
          *(_WORD *)&v46[4] = 2048;
          *(_QWORD *)&v46[6] = v11;
          *(_WORD *)&v46[14] = 2080;
          *(_QWORD *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(_QWORD *)&v46[26] = "thread-device.c";
          v47 = 1024;
          v48 = 148;
          v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_129;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136447490;
          v44 = "service_tracker_release_";
          v45 = 1024;
          *(_DWORD *)v46 = v12;
          *(_WORD *)&v46[4] = 2048;
          *(_QWORD *)&v46[6] = v11;
          *(_WORD *)&v46[14] = 2080;
          *(_QWORD *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(_QWORD *)&v46[26] = "thread-device.c";
          v47 = 1024;
          v48 = 148;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
          v12 = *(_DWORD *)v11;
        }
        *(_DWORD *)v11 = v12 - 1;
        if (v12 == 1)
        {
          v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v43 = 136447234;
            v44 = "service_tracker_release_";
            v45 = 2048;
            *(_QWORD *)v46 = v11;
            *(_WORD *)&v46[8] = 2080;
            *(_QWORD *)&v46[10] = "omw";
            *(_WORD *)&v46[18] = 2080;
            *(_QWORD *)&v46[20] = "thread-device.c";
            *(_WORD *)&v46[28] = 1024;
            *(_DWORD *)&v46[30] = 148;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
          }
          ++service_tracker_finalized;
          service_tracker_finalize(v11);
        }
      }
    }
    a1[5] = 0;
  }
  v14 = (_QWORD *)a1[7];
  if (v14)
  {
    v15 = v14[5];
    if (v15)
    {
      cti_events_discontinue(v15);
      v14[5] = 0;
      v16 = *(_DWORD *)v14;
      if (!*(_DWORD *)v14)
      {
        v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_131;
        v43 = 136447490;
        v44 = "thread_tracker_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = 0;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-tracker.c";
        v47 = 1024;
        v48 = 282;
        v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_126;
      }
      v9 = global_os_log;
      if (v16 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_131;
        v43 = 136447490;
        v44 = "thread_tracker_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = v16;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-tracker.c";
        v47 = 1024;
        v48 = 282;
        v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_129;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v43 = 136447490;
        v44 = "thread_tracker_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = v16;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-tracker.c";
        v47 = 1024;
        v48 = 282;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        v16 = *(_DWORD *)v14;
      }
      *(_DWORD *)v14 = v16 - 1;
      if (v16 == 1)
      {
        v17 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136447234;
          v44 = "thread_tracker_cancel";
          v45 = 2048;
          *(_QWORD *)v46 = v14;
          *(_WORD *)&v46[8] = 2080;
          *(_QWORD *)&v46[10] = "tracker";
          *(_WORD *)&v46[18] = 2080;
          *(_QWORD *)&v46[20] = "thread-tracker.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 282;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++thread_tracker_finalized;
        free(v14);
      }
    }
    v18 = (_QWORD *)v14[6];
    if (v18)
    {
      do
      {
        v20 = (_QWORD *)*v18;
        v19 = (void (*)(_QWORD))v18[1];
        if (v19)
          v19(v18[3]);
        free(v18);
        v18 = v20;
      }
      while (v20);
      v14[6] = 0;
      v21 = *(_DWORD *)v14;
      if (!*(_DWORD *)v14)
      {
        v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_131;
        v43 = 136447490;
        v44 = "thread_tracker_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = 0;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-tracker.c";
        v47 = 1024;
        v48 = 292;
        v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_126;
      }
      v9 = global_os_log;
      if (v21 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_131;
        v43 = 136447490;
        v44 = "thread_tracker_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = v21;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-tracker.c";
        v47 = 1024;
        v48 = 292;
        v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_129;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v43 = 136447490;
        v44 = "thread_tracker_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = v21;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-tracker.c";
        v47 = 1024;
        v48 = 292;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        v21 = *(_DWORD *)v14;
      }
      *(_DWORD *)v14 = v21 - 1;
      if (v21 == 1)
      {
        v22 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136447234;
          v44 = "thread_tracker_cancel";
          v45 = 2048;
          *(_QWORD *)v46 = v14;
          *(_WORD *)&v46[8] = 2080;
          *(_QWORD *)&v46[10] = "tracker";
          *(_WORD *)&v46[18] = 2080;
          *(_QWORD *)&v46[20] = "thread-tracker.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 292;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++thread_tracker_finalized;
        free(v14);
      }
    }
    v23 = (int *)a1[7];
    if (v23)
    {
      v24 = *v23;
      if (!*v23)
      {
        v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_131;
        v43 = 136447490;
        v44 = "thread_tracker_release_";
        v45 = 1024;
        *(_DWORD *)v46 = 0;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v23;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "omw";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-device.c";
        v47 = 1024;
        v48 = 153;
        v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_126;
      }
      v9 = global_os_log;
      if (v24 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_131;
        v43 = 136447490;
        v44 = "thread_tracker_release_";
        v45 = 1024;
        *(_DWORD *)v46 = v24;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v23;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "omw";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-device.c";
        v47 = 1024;
        v48 = 153;
        v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_129;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v43 = 136447490;
        v44 = "thread_tracker_release_";
        v45 = 1024;
        *(_DWORD *)v46 = v24;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v23;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "omw";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "thread-device.c";
        v47 = 1024;
        v48 = 153;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        v24 = *v23;
      }
      *v23 = v24 - 1;
      if (v24 == 1)
      {
        v25 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136447234;
          v44 = "thread_tracker_release_";
          v45 = 2048;
          *(_QWORD *)v46 = v23;
          *(_WORD *)&v46[8] = 2080;
          *(_QWORD *)&v46[10] = "omw";
          *(_WORD *)&v46[18] = 2080;
          *(_QWORD *)&v46[20] = "thread-device.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 153;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++thread_tracker_finalized;
        free(v23);
      }
    }
    a1[7] = 0;
  }
  v26 = (_QWORD *)a1[8];
  if (!v26)
    goto LABEL_91;
  v27 = v26[5];
  if (v27)
  {
    cti_events_discontinue(v27);
    v26[5] = 0;
    v28 = *(_DWORD *)v26;
    if (!*(_DWORD *)v26)
    {
      v40 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_131;
      v43 = 136447490;
      v44 = "node_type_tracker_cancel";
      v45 = 1024;
      *(_DWORD *)v46 = 0;
      *(_WORD *)&v46[4] = 2048;
      *(_QWORD *)&v46[6] = v26;
      *(_WORD *)&v46[14] = 2080;
      *(_QWORD *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(_QWORD *)&v46[26] = "node-type-tracker.c";
      v47 = 1024;
      v48 = 255;
      v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_126;
    }
    v9 = global_os_log;
    if (v28 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v43 = 136447490;
        v44 = "node_type_tracker_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = v28;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v26;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "node-type-tracker.c";
        v47 = 1024;
        v48 = 255;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        v28 = *(_DWORD *)v26;
      }
      *(_DWORD *)v26 = v28 - 1;
      if (v28 == 1)
      {
        v29 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136447234;
          v44 = "node_type_tracker_cancel";
          v45 = 2048;
          *(_QWORD *)v46 = v26;
          *(_WORD *)&v46[8] = 2080;
          *(_QWORD *)&v46[10] = "tracker";
          *(_WORD *)&v46[18] = 2080;
          *(_QWORD *)&v46[20] = "node-type-tracker.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 255;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++node_type_tracker_finalized;
        free(v26);
      }
      goto LABEL_69;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_131;
    v43 = 136447490;
    v44 = "node_type_tracker_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v28;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "node-type-tracker.c";
    v47 = 1024;
    v48 = 255;
    v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_129:
    v42 = v9;
    goto LABEL_130;
  }
LABEL_69:
  v30 = (_QWORD *)v26[6];
  if (!v30)
    goto LABEL_81;
  do
  {
    v32 = (_QWORD *)*v30;
    v31 = (void (*)(_QWORD))v30[1];
    if (v31)
      v31(v30[3]);
    free(v30);
    v30 = v32;
  }
  while (v32);
  v26[6] = 0;
  v33 = *(_DWORD *)v26;
  if (!*(_DWORD *)v26)
  {
    v40 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_131;
    v43 = 136447490;
    v44 = "node_type_tracker_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "node-type-tracker.c";
    v47 = 1024;
    v48 = 265;
    v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_126;
  }
  v9 = global_os_log;
  if (v33 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_131;
    v43 = 136447490;
    v44 = "node_type_tracker_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v33;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "node-type-tracker.c";
    v47 = 1024;
    v48 = 265;
    v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_129;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v43 = 136447490;
    v44 = "node_type_tracker_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v33;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "node-type-tracker.c";
    v47 = 1024;
    v48 = 265;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
    v33 = *(_DWORD *)v26;
  }
  *(_DWORD *)v26 = v33 - 1;
  if (v33 == 1)
  {
    v34 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v43 = 136447234;
      v44 = "node_type_tracker_cancel";
      v45 = 2048;
      *(_QWORD *)v46 = v26;
      *(_WORD *)&v46[8] = 2080;
      *(_QWORD *)&v46[10] = "tracker";
      *(_WORD *)&v46[18] = 2080;
      *(_QWORD *)&v46[20] = "node-type-tracker.c";
      *(_WORD *)&v46[28] = 1024;
      *(_DWORD *)&v46[30] = 265;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
    }
    ++node_type_tracker_finalized;
    free(v26);
  }
LABEL_81:
  v35 = (int *)a1[8];
  if (v35)
  {
    v36 = *v35;
    if (*v35)
    {
      v9 = global_os_log;
      if (v36 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v43 = 136447490;
          v44 = "node_type_tracker_release_";
          v45 = 1024;
          *(_DWORD *)v46 = v36;
          *(_WORD *)&v46[4] = 2048;
          *(_QWORD *)&v46[6] = v35;
          *(_WORD *)&v46[14] = 2080;
          *(_QWORD *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(_QWORD *)&v46[26] = "thread-device.c";
          v47 = 1024;
          v48 = 158;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
          v36 = *v35;
        }
        *v35 = v36 - 1;
        if (v36 == 1)
        {
          v37 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v43 = 136447234;
            v44 = "node_type_tracker_release_";
            v45 = 2048;
            *(_QWORD *)v46 = v35;
            *(_WORD *)&v46[8] = 2080;
            *(_QWORD *)&v46[10] = "omw";
            *(_WORD *)&v46[18] = 2080;
            *(_QWORD *)&v46[20] = "thread-device.c";
            *(_WORD *)&v46[28] = 1024;
            *(_DWORD *)&v46[30] = 158;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
          }
          ++node_type_tracker_finalized;
          free(v35);
        }
        goto LABEL_90;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_131:
        abort();
      v43 = 136447490;
      v44 = "node_type_tracker_release_";
      v45 = 1024;
      *(_DWORD *)v46 = v36;
      *(_WORD *)&v46[4] = 2048;
      *(_QWORD *)&v46[6] = v35;
      *(_WORD *)&v46[14] = 2080;
      *(_QWORD *)&v46[16] = "omw";
      *(_WORD *)&v46[24] = 2080;
      *(_QWORD *)&v46[26] = "thread-device.c";
      v47 = 1024;
      v48 = 158;
      v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_129;
    }
    v40 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_131;
    v43 = 136447490;
    v44 = "node_type_tracker_release_";
    v45 = 1024;
    *(_DWORD *)v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v35;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "omw";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "thread-device.c";
    v47 = 1024;
    v48 = 158;
    v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_126:
    v42 = v40;
LABEL_130:
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_FAULT, v41, (uint8_t *)&v43, 0x36u);
    goto LABEL_131;
  }
LABEL_90:
  a1[8] = 0;
LABEL_91:
  v38 = a1[6];
  if (v38)
  {
    service_publisher_cancel(v38);
    service_publisher_release_((int *)a1[6], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-device.c", 163);
    a1[6] = 0;
  }
  v39 = a1[16];
  if (v39)
  {
    dnssd_client_cancel(v39);
    dnssd_client_release_((int *)a1[16], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-device.c", 168);
    a1[16] = 0;
  }
}

void ifpermit_list_add(uint64_t a1, char *__s1)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  const char *v6;
  _QWORD *v7;
  char *v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  os_log_type_t v14;
  uint32_t v15;
  NSObject *v16;
  int v17;
  const char *v18;
  __int16 v19;
  _BYTE v20[14];
  __int16 v21;
  int v22;

  if (a1 == 1)
  {
    v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v17 = 136446466;
    v18 = "ifpermit_list_add";
    v19 = 2082;
    *(_QWORD *)v20 = __s1;
    v6 = "%{public}s: blocked permit list when adding %{public}s";
  }
  else
  {
    v3 = (_QWORD *)(a1 + 8);
    while (1)
    {
      v4 = (_QWORD *)*v3;
      if (!*v3)
        break;
      v3 = (_QWORD *)*v3;
      if (!strcmp(__s1, (const char *)v4[1]))
        goto LABEL_12;
    }
    v7 = malloc_type_calloc(1uLL, 0x18uLL, 0x103004013764637uLL);
    if (v7)
    {
      v4 = v7;
      v8 = strdup(__s1);
      v4[1] = v8;
      if (v8)
      {
        v9 = if_nametoindex(__s1);
        *((_DWORD *)v4 + 4) = v9;
        if (!v9)
        {
          v16 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            v17 = 136446466;
            v18 = "ifpermit_list_add";
            v19 = 2082;
            *(_QWORD *)v20 = __s1;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s: if_nametoindex for interface %{public}s returned 0.", (uint8_t *)&v17, 0x16u);
          }
          free((void *)v4[1]);
          free(v4);
          return;
        }
        *v3 = v4;
LABEL_12:
        v10 = *((_DWORD *)v4 + 5) + 1;
        *((_DWORD *)v4 + 5) = v10;
        v11 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          return;
        v12 = *((_DWORD *)v4 + 4);
        v17 = 136446978;
        v18 = "ifpermit_list_add";
        v19 = 1024;
        *(_DWORD *)v20 = v10;
        *(_WORD *)&v20[4] = 2082;
        *(_QWORD *)&v20[6] = __s1;
        v21 = 1024;
        v22 = v12;
        v6 = "%{public}s: %d permits for interface %{public}s with index %d";
        v13 = v11;
        v14 = OS_LOG_TYPE_DEFAULT;
        v15 = 34;
        goto LABEL_18;
      }
      free(v4);
    }
    v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v17 = 136446466;
    v18 = "ifpermit_list_add";
    v19 = 2082;
    *(_QWORD *)v20 = __s1;
    v6 = "%{public}s: no memory to add permit for %{public}s";
  }
  v13 = v5;
  v14 = OS_LOG_TYPE_ERROR;
  v15 = 22;
LABEL_18:
  _os_log_impl((void *)&_mh_execute_header, v13, v14, v6, (uint8_t *)&v17, v15);
}

void ifpermit_list_remove(uint64_t a1, char *__s1)
{
  const char **v3;
  const char **v4;
  int v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  os_log_type_t v11;
  uint64_t v12;
  int v13;
  const char *v14;
  __int16 v15;
  _BYTE v16[14];
  __int16 v17;
  int v18;

  if (a1 == 1)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v13 = 136446466;
    v14 = "ifpermit_list_remove";
    v15 = 2082;
    *(_QWORD *)v16 = __s1;
    v9 = "%{public}s: blocked permit list when removing %{public}s";
    v10 = v8;
    v11 = OS_LOG_TYPE_ERROR;
  }
  else
  {
    v3 = (const char **)(a1 + 8);
    while (1)
    {
      v4 = v3;
      v3 = (const char **)*v3;
      if (!v3)
        break;
      if (!strcmp(__s1, v3[1]))
      {
        v5 = *((_DWORD *)v3 + 5) - 1;
        *((_DWORD *)v3 + 5) = v5;
        v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v7 = *((_DWORD *)v3 + 4);
          v13 = 136446978;
          v14 = "ifpermit_list_remove";
          v15 = 1024;
          *(_DWORD *)v16 = v5;
          *(_WORD *)&v16[4] = 2082;
          *(_QWORD *)&v16[6] = __s1;
          v17 = 1024;
          v18 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %d permits for interface %{public}s with index %d", (uint8_t *)&v13, 0x22u);
          v5 = *((_DWORD *)v3 + 5);
        }
        if (!v5)
        {
          *v4 = *v3;
          free((void *)v3[1]);
          free(v3);
        }
        return;
      }
    }
    v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      return;
    v13 = 136446466;
    v14 = "ifpermit_list_remove";
    v15 = 2082;
    *(_QWORD *)v16 = __s1;
    v9 = "%{public}s: permit remove for interface %{public}s which does not exist";
    v10 = v12;
    v11 = OS_LOG_TYPE_FAULT;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, v11, v9, (uint8_t *)&v13, 0x16u);
}

void ifpermit_list_retain_(int *a1, int a2)
{
  NSObject *v4;
  int v5;
  int v6;
  NSObject *v7;
  int v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int *v14;
  __int16 v15;
  const char *v16;
  __int16 v17;
  char *v18;
  __int16 v19;
  int v20;

  if ((unint64_t)a1 >= 2)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *a1;
      *(_DWORD *)buf = 136447490;
      v10 = "ifpermit_list_retain_";
      v11 = 1024;
      v12 = v5;
      v13 = 2048;
      v14 = a1;
      v15 = 2080;
      v16 = "list";
      v17 = 2080;
      v18 = "macos-ioloop.c";
      v19 = 1024;
      v20 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      v6 = *a1 + 1;
      *a1 = v6;
      if (v6 >= 10001)
      {
        v8 = v6;
        v7 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v10 = "ifpermit_list_retain_";
          v11 = 1024;
          v12 = v8;
          v13 = 2048;
          v14 = a1;
          v15 = 2080;
          v16 = "list";
          v17 = 2080;
          v18 = "macos-ioloop.c";
          v19 = 1024;
          v20 = a2;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++ifpermit_list_created;
      *a1 = 1;
    }
  }
}

void ifpermit_list_release_(int *a1, int a2)
{
  int v4;
  NSObject *v5;
  NSObject *v6;
  void **v7;
  void **v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  if ((unint64_t)a1 < 2)
    return;
  v4 = *a1;
  if (!*a1)
  {
    v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_18;
    v10 = 136447490;
    v11 = "ifpermit_list_release_";
    v12 = 1024;
    *(_DWORD *)v13 = 0;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = a1;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "list";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = a2;
    v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_17;
  }
  v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_18;
    v10 = 136447490;
    v11 = "ifpermit_list_release_";
    v12 = 1024;
    *(_DWORD *)v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = a1;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "list";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = a2;
    v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
LABEL_18:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136447490;
    v11 = "ifpermit_list_release_";
    v12 = 1024;
    *(_DWORD *)v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = a1;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "list";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
    v4 = *a1;
  }
  *a1 = v4 - 1;
  if (v4 == 1)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136447234;
      v11 = "ifpermit_list_release_";
      v12 = 2048;
      *(_QWORD *)v13 = a1;
      *(_WORD *)&v13[8] = 2080;
      *(_QWORD *)&v13[10] = "list";
      *(_WORD *)&v13[18] = 2080;
      *(_QWORD *)&v13[20] = "macos-ioloop.c";
      *(_WORD *)&v13[28] = 1024;
      *(_DWORD *)&v13[30] = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
    }
    ++ifpermit_list_finalized;
    v7 = (void **)*((_QWORD *)a1 + 1);
    if (v7)
    {
      do
      {
        v8 = (void **)*v7;
        free(v7[1]);
        free(v7);
        v7 = v8;
      }
      while (v8);
    }
    free(a1);
  }
}

void ifpermit_add_permitted_interface_to_server_(uint64_t a1, char *__s1, char *a3, int a4)
{
  uint64_t v5;
  _DWORD *v9;
  _DWORD *v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  char *v16;
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  _DWORD *v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  char *v26;
  __int16 v27;
  int v28;

  v5 = *(_QWORD *)(a1 + 72);
  if (!v5)
  {
    v5 = 1;
    v9 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    if (v9)
    {
      v10 = v9;
      v11 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v12 = *v10;
        v17 = 136447490;
        v18 = "ifpermit_list_create_";
        v19 = 1024;
        v20 = v12;
        v21 = 2048;
        v22 = v10;
        v23 = 2080;
        v24 = "permits";
        v25 = 2080;
        v26 = strrchr(a3, 47) + 1;
        v27 = 1024;
        v28 = a4;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
      }
      v13 = *v10;
      if (*v10)
      {
        v14 = v13 + 1;
        *v10 = v13 + 1;
        if (v13 + 1 >= 10001)
        {
          v15 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            v16 = strrchr(a3, 47);
            v17 = 136447490;
            v18 = "ifpermit_list_create_";
            v19 = 1024;
            v20 = v14;
            v21 = 2048;
            v22 = v10;
            v23 = 2080;
            v24 = "permits";
            v25 = 2080;
            v26 = v16 + 1;
            v27 = 1024;
            v28 = a4;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++ifpermit_list_created;
        *v10 = 1;
      }
      v5 = (uint64_t)v10;
    }
    *(_QWORD *)(a1 + 72) = v5;
  }
  ifpermit_list_add(v5, __s1);
}

void thread_service_retain_(int *a1, char *a2, int a3)
{
  NSObject *v6;
  int v7;
  int v8;
  NSObject *v9;
  char *v10;
  int v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  int v23;

  if (a1)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *a1;
      *(_DWORD *)buf = 136447490;
      v13 = "thread_service_retain_";
      v14 = 1024;
      v15 = v7;
      v16 = 2048;
      v17 = a1;
      v18 = 2080;
      v19 = "omw";
      v20 = 2080;
      v21 = strrchr(a2, 47) + 1;
      v22 = 1024;
      v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      v8 = *a1 + 1;
      *a1 = v8;
      if (v8 >= 10001)
      {
        v11 = v8;
        v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v10 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          v13 = "thread_service_retain_";
          v14 = 1024;
          v15 = v11;
          v16 = 2048;
          v17 = a1;
          v18 = 2080;
          v19 = "omw";
          v20 = 2080;
          v21 = v10 + 1;
          v22 = 1024;
          v23 = a3;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      *a1 = 1;
    }
  }
}

void thread_service_release_(int *a1, char *a2, int a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  if (!a1)
    return;
  v6 = *a1;
  if (!*a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "thread_service_release_";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "thread_service_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "thread_service_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      v11 = 136447234;
      v12 = "thread_service_release_";
      v13 = 2048;
      *(_QWORD *)v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "omw";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++thread_service_finalized;
    free(a1);
  }
}

_DWORD *thread_service_unicast_create_(__int16 a1, _OWORD *a2, _WORD *a3, char a4, char *a5, int a6)
{
  _DWORD *v12;
  _DWORD *v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  NSObject *v18;
  char *v19;
  int v21;
  const char *v22;
  __int16 v23;
  int v24;
  __int16 v25;
  _DWORD *v26;
  __int16 v27;
  const char *v28;
  __int16 v29;
  char *v30;
  __int16 v31;
  int v32;

  v12 = malloc_type_calloc(1uLL, 0x58uLL, 0x1020040B24B9CA0uLL);
  v13 = v12;
  if (v12)
  {
    *((_OWORD *)v12 + 4) = *a2;
    *((_WORD *)v12 + 40) = *a3;
    *((_WORD *)v12 + 8) = a1;
    v12[5] = 2;
    *((_BYTE *)v12 + 18) = a4;
    v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *v13;
      v21 = 136447490;
      v22 = "thread_service_unicast_create_";
      v23 = 1024;
      v24 = v15;
      v25 = 2048;
      v26 = v13;
      v27 = 2080;
      v28 = "service";
      v29 = 2080;
      v30 = strrchr(a5, 47) + 1;
      v31 = 1024;
      v32 = a6;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
    }
    v16 = *v13;
    if (*v13)
    {
      v17 = v16 + 1;
      *v13 = v16 + 1;
      if (v16 + 1 >= 10001)
      {
        v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v19 = strrchr(a5, 47);
          v21 = 136447490;
          v22 = "thread_service_unicast_create_";
          v23 = 1024;
          v24 = v17;
          v25 = 2048;
          v26 = v13;
          v27 = 2080;
          v28 = "service";
          v29 = 2080;
          v30 = v19 + 1;
          v31 = 1024;
          v32 = a6;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      *v13 = 1;
    }
  }
  return v13;
}

_DWORD *thread_service_anycast_create_(__int16 a1, char a2, char a3, char *a4, int a5)
{
  _DWORD *v10;
  _DWORD *v11;
  NSObject *v12;
  int v13;
  int v14;
  int v15;
  NSObject *v16;
  char *v17;
  int v19;
  const char *v20;
  __int16 v21;
  int v22;
  __int16 v23;
  _DWORD *v24;
  __int16 v25;
  const char *v26;
  __int16 v27;
  char *v28;
  __int16 v29;
  int v30;

  v10 = malloc_type_calloc(1uLL, 0x58uLL, 0x1020040B24B9CA0uLL);
  v11 = v10;
  if (v10)
  {
    *((_WORD *)v10 + 8) = a1;
    *((_BYTE *)v10 + 80) = a2;
    v10[5] = 3;
    *((_BYTE *)v10 + 18) = a3;
    v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v13 = *v11;
      v19 = 136447490;
      v20 = "thread_service_anycast_create_";
      v21 = 1024;
      v22 = v13;
      v23 = 2048;
      v24 = v11;
      v25 = 2080;
      v26 = "service";
      v27 = 2080;
      v28 = strrchr(a4, 47) + 1;
      v29 = 1024;
      v30 = a5;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
    }
    v14 = *v11;
    if (*v11)
    {
      v15 = v14 + 1;
      *v11 = v14 + 1;
      if (v14 + 1 >= 10001)
      {
        v16 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v17 = strrchr(a4, 47);
          v19 = 136447490;
          v20 = "thread_service_anycast_create_";
          v21 = 1024;
          v22 = v15;
          v23 = 2048;
          v24 = v11;
          v25 = 2080;
          v26 = "service";
          v27 = 2080;
          v28 = v17 + 1;
          v29 = 1024;
          v30 = a5;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      *v11 = 1;
    }
  }
  return v11;
}

_DWORD *thread_service_pref_id_create_(__int16 a1, _DWORD *a2, int *a3, char a4, char *a5, int a6)
{
  _DWORD *v12;
  _DWORD *v13;
  int v14;
  NSObject *v15;
  int v16;
  int v17;
  int v18;
  NSObject *v19;
  char *v20;
  int v22;
  const char *v23;
  __int16 v24;
  int v25;
  __int16 v26;
  _DWORD *v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  char *v31;
  __int16 v32;
  int v33;

  v12 = malloc_type_calloc(1uLL, 0x58uLL, 0x1020040B24B9CA0uLL);
  v13 = v12;
  if (v12)
  {
    *((_WORD *)v12 + 8) = a1;
    v12[16] = *a2;
    v14 = *a3;
    *((_BYTE *)v12 + 72) = *((_BYTE *)a3 + 4);
    v12[17] = v14;
    v12[5] = 1;
    *((_BYTE *)v12 + 18) = a4;
    v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *v13;
      v22 = 136447490;
      v23 = "thread_service_pref_id_create_";
      v24 = 1024;
      v25 = v16;
      v26 = 2048;
      v27 = v13;
      v28 = 2080;
      v29 = "service";
      v30 = 2080;
      v31 = strrchr(a5, 47) + 1;
      v32 = 1024;
      v33 = a6;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
    }
    v17 = *v13;
    if (*v13)
    {
      v18 = v17 + 1;
      *v13 = v17 + 1;
      if (v17 + 1 >= 10001)
      {
        v19 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v20 = strrchr(a5, 47);
          v22 = 136447490;
          v23 = "thread_service_pref_id_create_";
          v24 = 1024;
          v25 = v18;
          v26 = 2048;
          v27 = v13;
          v28 = 2080;
          v29 = "service";
          v30 = 2080;
          v31 = v20 + 1;
          v32 = 1024;
          v33 = a6;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      *v13 = 1;
    }
  }
  return v13;
}

void thread_service_note(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6;
  uint64_t v7;
  int v8;
  int v9;
  const char *v10;
  NSObject *v11;
  uint32_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  const char *v23;
  uint64_t v24;
  int v25;
  char v26;
  int v27;
  char v28;
  uint64_t v29;
  __int16 v30;
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  _BYTE v34[20];
  _BYTE v35[10];
  int v36;
  __int16 v37;
  char *v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  int v42;
  __int16 v43;
  uint64_t *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  int v48;
  __int16 v49;
  char *v50;
  __int16 v51;
  unsigned int v52;
  __int16 v53;
  int v54;
  __int16 v55;
  _BYTE v56[10];
  __int16 v57;
  int v58;
  __int16 v59;
  uint64_t v60;

  v6 = *(_DWORD *)(a2 + 20);
  switch(v6)
  {
    case 1:
      v26 = -3;
      v27 = *(_DWORD *)(a2 + 68);
      v28 = *(_BYTE *)(a2 + 72);
      v29 = 0;
      v30 = 0;
      v13 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v14 = *(unsigned __int8 *)(a2 + 64);
      v15 = *(unsigned __int8 *)(a2 + 65);
      v16 = *(unsigned __int8 *)(a2 + 66);
      v17 = *(unsigned __int8 *)(a2 + 67);
      v18 = *(unsigned __int16 *)(a2 + 16);
      *(_DWORD *)buf = 136450563;
      v32 = "thread_service_note";
      v33 = 2082;
      *(_QWORD *)v34 = a1;
      *(_WORD *)&v34[8] = 2082;
      *(_QWORD *)&v34[10] = "ULA: ";
      *(_WORD *)&v34[18] = 2160;
      *(_QWORD *)v35 = 1752392040;
      *(_WORD *)&v35[8] = 1041;
      v36 = 6;
      v37 = 2097;
      v38 = &v26;
      v39 = 2160;
      v40 = 1752392040;
      v41 = 1042;
      v42 = 2;
      v43 = 2098;
      v44 = &v29;
      v45 = 2160;
      v46 = 1752392040;
      v47 = 1041;
      v48 = 8;
      v49 = 2097;
      v50 = (char *)&v29 + 2;
      v51 = 1024;
      v52 = v14;
      v53 = 1024;
      v54 = v15;
      v55 = 1024;
      *(_DWORD *)v56 = v16;
      *(_WORD *)&v56[4] = 1024;
      *(_DWORD *)&v56[6] = v17;
      v57 = 1024;
      v58 = v18;
      v59 = 2082;
      v60 = a3;
      v10 = "%{public}s: %{public}s pref:id {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash"
            ", srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}:%02x%02x%02x%02x rloc %x %{public}s";
      v11 = v13;
      v12 = 150;
      break;
    case 2:
      v19 = *(unsigned __int16 *)(a2 + 80);
      v20 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v21 = __rev16(v19);
      v22 = *(unsigned __int8 *)(a2 + 64);
      if ((v22 & 0xFE) == 0xFC)
      {
        v23 = "ULA: ";
      }
      else if (v22 == 254 && (*(_BYTE *)(a2 + 65) & 0xC0) == 0x80)
      {
        v23 = "LUA: ";
      }
      else if ((v22 & 0xE0) == 0x20)
      {
        v23 = "GUA: ";
      }
      else
      {
        v23 = (const char *)&unk_10007C3B5;
      }
      v25 = *(unsigned __int16 *)(a2 + 16);
      *(_DWORD *)buf = 136449795;
      v32 = "thread_service_note";
      v33 = 2082;
      *(_QWORD *)v34 = a1;
      *(_WORD *)&v34[8] = 2082;
      *(_QWORD *)&v34[10] = v23;
      *(_WORD *)&v34[18] = 2160;
      *(_QWORD *)v35 = 1752392040;
      *(_WORD *)&v35[8] = 1041;
      v36 = 6;
      v37 = 2097;
      v38 = (char *)(a2 + 64);
      v39 = 2160;
      v40 = 1752392040;
      v41 = 1042;
      v42 = 2;
      v43 = 2098;
      v44 = (uint64_t *)(a2 + 70);
      v45 = 2160;
      v46 = 1752392040;
      v47 = 1041;
      v48 = 8;
      v49 = 2097;
      v50 = (char *)(a2 + 72);
      v51 = 1024;
      v52 = v21;
      v53 = 1024;
      v54 = v25;
      v55 = 2082;
      *(_QWORD *)v56 = a3;
      v10 = "%{public}s: %{public}s SRP service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask."
            "hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}%%%d, rloc16 %x %{public}s";
      v11 = v20;
      v12 = 132;
      break;
    case 3:
      v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v8 = *(unsigned __int16 *)(a2 + 16);
      v9 = *(unsigned __int8 *)(a2 + 80);
      *(_DWORD *)buf = 136447234;
      v32 = "thread_service_note";
      v33 = 2082;
      *(_QWORD *)v34 = a1;
      *(_WORD *)&v34[8] = 1024;
      *(_DWORD *)&v34[10] = v8;
      *(_WORD *)&v34[14] = 1024;
      *(_DWORD *)&v34[16] = v9;
      *(_WORD *)v35 = 2082;
      *(_QWORD *)&v35[2] = a3;
      v10 = "%{public}s: %{public}s SRP service on RLOC16 %x with sequence number %02x %{public}s";
      v11 = v7;
      v12 = 44;
      break;
    default:
      v24 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 136446722;
      v32 = "thread_service_note";
      v33 = 1024;
      *(_DWORD *)v34 = v6;
      *(_WORD *)&v34[4] = 2048;
      *(_QWORD *)&v34[6] = a2;
      v10 = "%{public}s: invalid service type %d on service %p";
      v11 = v24;
      v12 = 28;
      break;
  }
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
}

void ioloop_dump_object_allocation_stats()
{
  int v0;
  char *v1;
  NSObject *v2;
  char *v3;
  NSObject *v4;
  char *v5;
  NSObject *v6;
  char *v7;
  NSObject *v8;
  char *v9;
  NSObject *v10;
  char *v11;
  NSObject *v12;
  char *v13;
  NSObject *v14;
  char *v15;
  NSObject *v16;
  char *v17;
  NSObject *v18;
  char *v19;
  NSObject *v20;
  char *v21;
  NSObject *v22;
  char *v23;
  NSObject *v24;
  char *v25;
  NSObject *v26;
  char *v27;
  NSObject *v28;
  char *v29;
  NSObject *v30;
  char *v31;
  NSObject *v32;
  char *v33;
  NSObject *v34;
  char *v35;
  NSObject *v36;
  char *v37;
  NSObject *v38;
  char *v39;
  NSObject *v40;
  char *v41;
  NSObject *v42;
  char *v43;
  NSObject *v44;
  char *v45;
  NSObject *v46;
  char *v47;
  NSObject *v48;
  char *v49;
  NSObject *v50;
  char *v51;
  NSObject *v52;
  char *v53;
  NSObject *v54;
  char *v55;
  NSObject *v56;
  char *v57;
  NSObject *v58;
  char *v59;
  NSObject *v60;
  char *v61;
  NSObject *v62;
  char *v63;
  NSObject *v64;
  char *v65;
  NSObject *v66;
  char *v67;
  NSObject *v68;
  char *v69;
  NSObject *v70;
  char *v71;
  NSObject *v72;
  char *v73;
  NSObject *v74;
  char *v75;
  NSObject *v76;
  char *v77;
  NSObject *v78;
  char *v79;
  NSObject *v80;
  char *v81;
  NSObject *v82;
  char *v83;
  NSObject *v84;
  char *v85;
  NSObject *v86;
  char *v87;
  NSObject *v88;
  char *v89;
  NSObject *v90;
  char *v91;
  NSObject *v92;
  char *v93;
  NSObject *v94;
  char *v95;
  NSObject *v96;
  char *v97;
  NSObject *v98;
  char *v99;
  NSObject *v100;
  char *v101;
  NSObject *v102;
  char *v103;
  NSObject *v104;
  char *v105;
  NSObject *v106;
  char *v107;
  NSObject *v108;
  char *v109;
  NSObject *v110;
  char *v111;
  NSObject *v112;
  char *v113;
  NSObject *v114;
  char *v115;
  NSObject *v116;
  int v117;
  NSObject *v118;
  DIR *v119;
  DIR *v120;
  int v121;
  NSObject *v122;
  int v123;
  int v124;
  int *v125;
  char *v126;
  const char *v127;
  uint8_t buf[4];
  const char *v129;
  __int16 v130;
  char *v131;
  char __str[4];
  const char *v133;
  __int16 v134;
  int v135;
  __int16 v136;
  char *v137;
  uint64_t v138;

  if (adv_host_created != old_adv_host_created
    || adv_host_finalized != old_adv_host_finalized
    || adv_instance_created != old_adv_instance_created
    || adv_instance_finalized != old_adv_instance_finalized
    || adv_instance_vec_created != old_adv_instance_vec_created
    || adv_instance_vec_finalized != old_adv_instance_vec_finalized
    || adv_record_created != old_adv_record_created
    || adv_record_finalized != old_adv_record_finalized
    || adv_record_vec_created != old_adv_record_vec_created
    || adv_record_vec_finalized != old_adv_record_vec_finalized
    || adv_update_created != old_adv_update_created
    || adv_update_finalized != old_adv_update_finalized
    || comm_created != old_comm_created
    || comm_finalized != old_comm_finalized
    || cti_connection_created != old_cti_connection_created
    || cti_connection_finalized != old_cti_connection_finalized
    || cti_service_created != old_cti_service_created
    || cti_service_finalized != old_cti_service_finalized
    || cti_service_vec_created != old_cti_service_vec_created
    || cti_service_vec_finalized != old_cti_service_vec_finalized
    || dnssd_client_created != old_dnssd_client_created
    || dnssd_client_finalized != old_dnssd_client_finalized
    || dnssd_query_created != old_dnssd_query_created
    || dnssd_query_finalized != old_dnssd_query_finalized
    || dnssd_txn_created != old_dnssd_txn_created
    || dnssd_txn_finalized != old_dnssd_txn_finalized
    || dp_tracker_created != old_dp_tracker_created
    || dp_tracker_finalized != old_dp_tracker_finalized
    || file_descriptor_created != old_file_descriptor_created
    || file_descriptor_finalized != old_file_descriptor_finalized
    || ifpermit_list_created != old_ifpermit_list_created
    || ifpermit_list_finalized != old_ifpermit_list_finalized
    || listener_created != old_listener_created
    || listener_finalized != old_listener_finalized
    || message_created != old_message_created
    || message_finalized != old_message_finalized
    || node_type_tracker_created != old_node_type_tracker_created
    || node_type_tracker_finalized != old_node_type_tracker_finalized
    || nw_connection_created != old_nw_connection_created
    || nw_connection_finalized != old_nw_connection_finalized
    || nw_listener_created != old_nw_listener_created
    || nw_listener_finalized != old_nw_listener_finalized
    || probe_state_created != old_probe_state_created
    || probe_state_finalized != old_probe_state_finalized
    || question_created != old_question_created
    || question_finalized != old_question_finalized
    || rref_created != old_rref_created
    || rref_finalized != old_rref_finalized
    || sdref_created != old_sdref_created
    || sdref_finalized != old_sdref_finalized
    || saref_created != old_saref_created
    || saref_finalized != old_saref_finalized
    || service_publisher_created != old_service_publisher_created
    || service_publisher_finalized != old_service_publisher_finalized
    || service_tracker_created != old_service_tracker_created
    || service_tracker_finalized != old_service_tracker_finalized
    || srp_xpc_client_created != old_srp_xpc_client_created
    || srp_xpc_client_finalized != old_srp_xpc_client_finalized
    || state_machine_event_created != old_state_machine_event_created
    || state_machine_event_finalized != old_state_machine_event_finalized
    || thread_service_created != old_thread_service_created
    || thread_service_finalized != old_thread_service_finalized
    || thread_tracker_created != old_thread_tracker_created
    || thread_tracker_finalized != old_thread_tracker_finalized
    || wakeup_created != old_wakeup_created
    || wakeup_finalized != old_wakeup_finalized)
  {
    v0 = snprintf(__str, 0x3E8uLL, "address_query %d %d %d %d|", 0, 0, 0, 0);
    if (v0 <= 900)
    {
      v1 = &__str[v0];
    }
    else
    {
      v1 = __str;
      v2 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v3 = &v1[snprintf(v1, (char *)&v138 - v1, "adv_host %d %d %d %d|", old_adv_host_created, adv_host_created, old_adv_host_finalized, adv_host_finalized)];
    old_adv_host_created = adv_host_created;
    old_adv_host_finalized = adv_host_finalized;
    if (v3 - __str >= 901)
    {
      v3 = __str;
      v4 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v5 = &v3[snprintf(v3, (char *)&v138 - v3, "adv_instance %d %d %d %d|", old_adv_instance_created, adv_instance_created, old_adv_instance_finalized, adv_instance_finalized)];
    old_adv_instance_created = adv_instance_created;
    old_adv_instance_finalized = adv_instance_finalized;
    if (v5 - __str >= 901)
    {
      v5 = __str;
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v7 = &v5[snprintf(v5, (char *)&v138 - v5, "adv_instance_vec %d %d %d %d|", old_adv_instance_vec_created, adv_instance_vec_created, old_adv_instance_vec_finalized, adv_instance_vec_finalized)];
    old_adv_instance_vec_created = adv_instance_vec_created;
    old_adv_instance_vec_finalized = adv_instance_vec_finalized;
    if (v7 - __str >= 901)
    {
      v7 = __str;
      v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v9 = &v7[snprintf(v7, (char *)&v138 - v7, "adv_record %d %d %d %d|", old_adv_record_created, adv_record_created, old_adv_record_finalized, adv_record_finalized)];
    old_adv_record_created = adv_record_created;
    old_adv_record_finalized = adv_record_finalized;
    if (v9 - __str >= 901)
    {
      v9 = __str;
      v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v11 = &v9[snprintf(v9, (char *)&v138 - v9, "adv_record_vec %d %d %d %d|", old_adv_record_vec_created, adv_record_vec_created, old_adv_record_vec_finalized, adv_record_vec_finalized)];
    old_adv_record_vec_created = adv_record_vec_created;
    old_adv_record_vec_finalized = adv_record_vec_finalized;
    if (v11 - __str >= 901)
    {
      v11 = __str;
      v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v13 = &v11[snprintf(v11, (char *)&v138 - v11, "adv_update %d %d %d %d|", old_adv_update_created, adv_update_created, old_adv_update_finalized, adv_update_finalized)];
    old_adv_update_created = adv_update_created;
    old_adv_update_finalized = adv_update_finalized;
    if (v13 - __str >= 901)
    {
      v13 = __str;
      v14 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v15 = &v13[snprintf(v13, (char *)&v138 - v13, "advertising_proxy_conn_ref %d %d %d %d|", 0, 0, 0, 0)];
    if (v15 - __str >= 901)
    {
      v15 = __str;
      v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v17 = &v15[snprintf(v15, (char *)&v138 - v15, "comm %d %d %d %d|", old_comm_created, comm_created, old_comm_finalized, comm_finalized)];
    old_comm_created = comm_created;
    old_comm_finalized = comm_finalized;
    if (v17 - __str >= 901)
    {
      v17 = __str;
      v18 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v19 = &v17[snprintf(v17, (char *)&v138 - v17, "cti_connection %d %d %d %d|", old_cti_connection_created, cti_connection_created, old_cti_connection_finalized, cti_connection_finalized)];
    old_cti_connection_created = cti_connection_created;
    old_cti_connection_finalized = cti_connection_finalized;
    if (v19 - __str >= 901)
    {
      v19 = __str;
      v20 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v21 = &v19[snprintf(v19, (char *)&v138 - v19, "cti_prefix %d %d %d %d|", 0, 0, 0, 0)];
    if (v21 - __str >= 901)
    {
      v21 = __str;
      v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v23 = &v21[snprintf(v21, (char *)&v138 - v21, "cti_prefix_vec %d %d %d %d|", 0, 0, 0, 0)];
    if (v23 - __str >= 901)
    {
      v23 = __str;
      v24 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v25 = &v23[snprintf(v23, (char *)&v138 - v23, "cti_route %d %d %d %d|", 0, 0, 0, 0)];
    if (v25 - __str >= 901)
    {
      v25 = __str;
      v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v27 = &v25[snprintf(v25, (char *)&v138 - v25, "cti_route_vec %d %d %d %d|", 0, 0, 0, 0)];
    if (v27 - __str >= 901)
    {
      v27 = __str;
      v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v29 = &v27[snprintf(v27, (char *)&v138 - v27, "cti_service %d %d %d %d|", old_cti_service_created, cti_service_created, old_cti_service_finalized, cti_service_finalized)];
    old_cti_service_created = cti_service_created;
    old_cti_service_finalized = cti_service_finalized;
    if (v29 - __str >= 901)
    {
      v29 = __str;
      v30 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v31 = &v29[snprintf(v29, (char *)&v138 - v29, "cti_service_vec %d %d %d %d|", old_cti_service_vec_created, cti_service_vec_created, old_cti_service_vec_finalized, cti_service_vec_finalized)];
    old_cti_service_vec_created = cti_service_vec_created;
    old_cti_service_vec_finalized = cti_service_vec_finalized;
    if (v31 - __str >= 901)
    {
      v31 = __str;
      v32 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v33 = &v31[snprintf(v31, (char *)&v138 - v31, "dnssd_client %d %d %d %d|", old_dnssd_client_created, dnssd_client_created, old_dnssd_client_finalized, dnssd_client_finalized)];
    old_dnssd_client_created = dnssd_client_created;
    old_dnssd_client_finalized = dnssd_client_finalized;
    if (v33 - __str >= 901)
    {
      v33 = __str;
      v34 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v35 = &v33[snprintf(v33, (char *)&v138 - v33, "dnssd_query %d %d %d %d|", old_dnssd_query_created, dnssd_query_created, old_dnssd_query_finalized, dnssd_query_finalized)];
    old_dnssd_query_created = dnssd_query_created;
    old_dnssd_query_finalized = dnssd_query_finalized;
    if (v35 - __str >= 901)
    {
      v35 = __str;
      v36 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v37 = &v35[snprintf(v35, (char *)&v138 - v35, "dnssd_txn %d %d %d %d|", old_dnssd_txn_created, dnssd_txn_created, old_dnssd_txn_finalized, dnssd_txn_finalized)];
    old_dnssd_txn_created = dnssd_txn_created;
    old_dnssd_txn_finalized = dnssd_txn_finalized;
    if (v37 - __str >= 901)
    {
      v37 = __str;
      v38 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v39 = &v37[snprintf(v37, (char *)&v138 - v37, "dp_tracker %d %d %d %d|", old_dp_tracker_created, dp_tracker_created, old_dp_tracker_finalized, dp_tracker_finalized)];
    old_dp_tracker_created = dp_tracker_created;
    old_dp_tracker_finalized = dp_tracker_finalized;
    if (v39 - __str >= 901)
    {
      v39 = __str;
      v40 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v41 = &v39[snprintf(v39, (char *)&v138 - v39, "file_descriptor %d %d %d %d|", old_file_descriptor_created, file_descriptor_created, old_file_descriptor_finalized, file_descriptor_finalized)];
    old_file_descriptor_created = file_descriptor_created;
    old_file_descriptor_finalized = file_descriptor_finalized;
    if (v41 - __str >= 901)
    {
      v41 = __str;
      v42 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v43 = &v41[snprintf(v41, (char *)&v138 - v41, "interface %d %d %d %d|", 0, 0, 0, 0)];
    if (v43 - __str >= 901)
    {
      v43 = __str;
      v44 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v45 = &v43[snprintf(v43, (char *)&v138 - v43, "ifpermit_list %d %d %d %d|", old_ifpermit_list_created, ifpermit_list_created, old_ifpermit_list_finalized, ifpermit_list_finalized)];
    old_ifpermit_list_created = ifpermit_list_created;
    old_ifpermit_list_finalized = ifpermit_list_finalized;
    if (v45 - __str >= 901)
    {
      v45 = __str;
      v46 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v47 = &v45[snprintf(v45, (char *)&v138 - v45, "io %d %d %d %d|", 0, 0, 0, 0)];
    if (v47 - __str >= 901)
    {
      v47 = __str;
      v48 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v49 = &v47[snprintf(v47, (char *)&v138 - v47, "listener %d %d %d %d|", old_listener_created, listener_created, old_listener_finalized, listener_finalized)];
    old_listener_created = listener_created;
    old_listener_finalized = listener_finalized;
    if (v49 - __str >= 901)
    {
      v49 = __str;
      v50 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v51 = &v49[snprintf(v49, (char *)&v138 - v49, "message %d %d %d %d|", old_message_created, message_created, old_message_finalized, message_finalized)];
    old_message_created = message_created;
    old_message_finalized = message_finalized;
    if (v51 - __str >= 901)
    {
      v51 = __str;
      v52 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v53 = &v51[snprintf(v51, (char *)&v138 - v51, "nat64 %d %d %d %d|", 0, 0, 0, 0)];
    if (v53 - __str >= 901)
    {
      v53 = __str;
      v54 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v55 = &v53[snprintf(v53, (char *)&v138 - v53, "nat64_prefix %d %d %d %d|", 0, 0, 0, 0)];
    if (v55 - __str >= 901)
    {
      v55 = __str;
      v56 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v57 = &v55[snprintf(v55, (char *)&v138 - v55, "nat64_ipv4_default_route_monitor %d %d %d %d|", 0, 0, 0, 0)];
    if (v57 - __str >= 901)
    {
      v57 = __str;
      v58 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v59 = &v57[snprintf(v57, (char *)&v138 - v57, "nat64_infra_prefix_monitor %d %d %d %d|", 0, 0, 0, 0)];
    if (v59 - __str >= 901)
    {
      v59 = __str;
      v60 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v61 = &v59[snprintf(v59, (char *)&v138 - v59, "nat64_thread_prefix_monitor %d %d %d %d|", 0, 0, 0, 0)];
    if (v61 - __str >= 901)
    {
      v61 = __str;
      v62 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v63 = &v61[snprintf(v61, (char *)&v138 - v61, "nat64_infra_prefix_publisher %d %d %d %d|", 0, 0, 0, 0)];
    if (v63 - __str >= 901)
    {
      v63 = __str;
      v64 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v65 = &v63[snprintf(v63, (char *)&v138 - v63, "nat64_br_prefix_publisher %d %d %d %d|", 0, 0, 0, 0)];
    if (v65 - __str >= 901)
    {
      v65 = __str;
      v66 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v67 = &v65[snprintf(v65, (char *)&v138 - v65, "node_type_tracker %d %d %d %d|", old_node_type_tracker_created, node_type_tracker_created, old_node_type_tracker_finalized, node_type_tracker_finalized)];
    old_node_type_tracker_created = node_type_tracker_created;
    old_node_type_tracker_finalized = node_type_tracker_finalized;
    if (v67 - __str >= 901)
    {
      v67 = __str;
      v68 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v69 = &v67[snprintf(v67, (char *)&v138 - v67, "nw_connection %d %d %d %d|", old_nw_connection_created, nw_connection_created, old_nw_connection_finalized, nw_connection_finalized)];
    old_nw_connection_created = nw_connection_created;
    old_nw_connection_finalized = nw_connection_finalized;
    if (v69 - __str >= 901)
    {
      v69 = __str;
      v70 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v71 = &v69[snprintf(v69, (char *)&v138 - v69, "nw_listener %d %d %d %d|", old_nw_listener_created, nw_listener_created, old_nw_listener_finalized, nw_listener_finalized)];
    old_nw_listener_created = nw_listener_created;
    old_nw_listener_finalized = nw_listener_finalized;
    if (v71 - __str >= 901)
    {
      v71 = __str;
      v72 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v73 = &v71[snprintf(v71, (char *)&v138 - v71, "nw_path_evaluator %d %d %d %d|", 0, 0, 0, 0)];
    if (v73 - __str >= 901)
    {
      v73 = __str;
      v74 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v75 = &v73[snprintf(v73, (char *)&v138 - v73, "omr_prefix %d %d %d %d|", 0, 0, 0, 0)];
    if (v75 - __str >= 901)
    {
      v75 = __str;
      v76 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v77 = &v75[snprintf(v75, (char *)&v138 - v75, "omr_publisher %d %d %d %d|", 0, 0, 0, 0)];
    if (v77 - __str >= 901)
    {
      v77 = __str;
      v78 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v79 = &v77[snprintf(v77, (char *)&v138 - v77, "omr_watcher %d %d %d %d|", 0, 0, 0, 0)];
    if (v79 - __str >= 901)
    {
      v79 = __str;
      v80 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v81 = &v79[snprintf(v79, (char *)&v138 - v79, "prefix_tracker %d %d %d %d|", 0, 0, 0, 0)];
    if (v81 - __str >= 901)
    {
      v81 = __str;
      v82 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v83 = &v81[snprintf(v81, (char *)&v138 - v81, "probe_state %d %d %d %d|", old_probe_state_created, probe_state_created, old_probe_state_finalized, probe_state_finalized)];
    old_probe_state_created = probe_state_created;
    old_probe_state_finalized = probe_state_finalized;
    if (v83 - __str >= 901)
    {
      v83 = __str;
      v84 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v85 = &v83[snprintf(v83, (char *)&v138 - v83, "question %d %d %d %d|", old_question_created, question_created, old_question_finalized, question_finalized)];
    old_question_created = question_created;
    old_question_finalized = question_finalized;
    if (v85 - __str >= 901)
    {
      v85 = __str;
      v86 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v87 = &v85[snprintf(v85, (char *)&v138 - v85, "route_tracker %d %d %d %d|", 0, 0, 0, 0)];
    if (v87 - __str >= 901)
    {
      v87 = __str;
      v88 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v89 = &v87[snprintf(v87, (char *)&v138 - v87, "rref %d %d %d %d|", old_rref_created, rref_created, old_rref_finalized, rref_finalized)];
    old_rref_created = rref_created;
    old_rref_finalized = rref_finalized;
    if (v89 - __str >= 901)
    {
      v89 = __str;
      v90 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v91 = &v89[snprintf(v89, (char *)&v138 - v89, "sdref %d %d %d %d|", old_sdref_created, sdref_created, old_sdref_finalized, sdref_finalized)];
    old_sdref_created = sdref_created;
    old_sdref_finalized = sdref_finalized;
    if (v91 - __str >= 901)
    {
      v91 = __str;
      v92 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v93 = &v91[snprintf(v91, (char *)&v138 - v91, "saref %d %d %d %d|", old_saref_created, saref_created, old_saref_finalized, saref_finalized)];
    old_saref_created = saref_created;
    old_saref_finalized = saref_finalized;
    if (v93 - __str >= 901)
    {
      v93 = __str;
      v94 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v95 = &v93[snprintf(v93, (char *)&v138 - v93, "service_publisher %d %d %d %d|", old_service_publisher_created, service_publisher_created, old_service_publisher_finalized, service_publisher_finalized)];
    old_service_publisher_created = service_publisher_created;
    old_service_publisher_finalized = service_publisher_finalized;
    if (v95 - __str >= 901)
    {
      v95 = __str;
      v96 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v97 = &v95[snprintf(v95, (char *)&v138 - v95, "service_tracker %d %d %d %d|", old_service_tracker_created, service_tracker_created, old_service_tracker_finalized, service_tracker_finalized)];
    old_service_tracker_created = service_tracker_created;
    old_service_tracker_finalized = service_tracker_finalized;
    if (v97 - __str >= 901)
    {
      v97 = __str;
      v98 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v99 = &v97[snprintf(v97, (char *)&v138 - v97, "srp_xpc_client %d %d %d %d|", old_srp_xpc_client_created, srp_xpc_client_created, old_srp_xpc_client_finalized, srp_xpc_client_finalized)];
    old_srp_xpc_client_created = srp_xpc_client_created;
    old_srp_xpc_client_finalized = srp_xpc_client_finalized;
    if (v99 - __str >= 901)
    {
      v99 = __str;
      v100 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v101 = &v99[snprintf(v99, (char *)&v138 - v99, "srpl_connection %d %d %d %d|", 0, 0, 0, 0)];
    if (v101 - __str >= 901)
    {
      v101 = __str;
      v102 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v103 = &v101[snprintf(v101, (char *)&v138 - v101, "srpl_domain %d %d %d %d|", 0, 0, 0, 0)];
    if (v103 - __str >= 901)
    {
      v103 = __str;
      v104 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v105 = &v103[snprintf(v103, (char *)&v138 - v103, "srpl_instance %d %d %d %d|", 0, 0, 0, 0)];
    if (v105 - __str >= 901)
    {
      v105 = __str;
      v106 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v107 = &v105[snprintf(v105, (char *)&v138 - v105, "srpl_instance_service %d %d %d %d|", 0, 0, 0, 0)];
    if (v107 - __str >= 901)
    {
      v107 = __str;
      v108 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v109 = &v107[snprintf(v107, (char *)&v138 - v107, "state_machine_event %d %d %d %d|", old_state_machine_event_created, state_machine_event_created, old_state_machine_event_finalized, state_machine_event_finalized)];
    old_state_machine_event_created = state_machine_event_created;
    old_state_machine_event_finalized = state_machine_event_finalized;
    if (v109 - __str >= 901)
    {
      v109 = __str;
      v110 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v111 = &v109[snprintf(v109, (char *)&v138 - v109, "subproc %d %d %d %d|", 0, 0, 0, 0)];
    if (v111 - __str >= 901)
    {
      v111 = __str;
      v112 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v113 = &v111[snprintf(v111, (char *)&v138 - v111, "thread_service %d %d %d %d|", old_thread_service_created, thread_service_created, old_thread_service_finalized, thread_service_finalized)];
    old_thread_service_created = thread_service_created;
    old_thread_service_finalized = thread_service_finalized;
    if (v113 - __str >= 901)
    {
      v113 = __str;
      v114 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v115 = &v113[snprintf(v113, (char *)&v138 - v113, "thread_tracker %d %d %d %d|", old_thread_tracker_created, thread_tracker_created, old_thread_tracker_finalized, thread_tracker_finalized)];
    old_thread_tracker_created = thread_tracker_created;
    old_thread_tracker_finalized = thread_tracker_finalized;
    if (v115 - __str >= 901)
    {
      v115 = __str;
      v116 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v117 = snprintf(v115, (char *)&v138 - v115, "wakeup %d %d %d %d|", old_wakeup_created, wakeup_created, old_wakeup_finalized, wakeup_finalized);
    old_wakeup_created = wakeup_created;
    old_wakeup_finalized = wakeup_finalized;
    if (&v115[v117] - __str >= 901)
    {
      v118 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_248;
      goto LABEL_247;
    }
    if (v117)
    {
      v118 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
LABEL_247:
        *(_DWORD *)buf = 136446466;
        v129 = "ioloop_dump_object_allocation_stats";
        v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
  }
LABEL_248:
  v119 = opendir("/dev/fd");
  if (!v119)
  {
    if (*__error() == 24)
    {
      v122 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__str = 136446210;
        v133 = "get_num_fds";
        v127 = "%{public}s: per-process open file limit reached.";
LABEL_265:
        _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_FAULT, v127, (uint8_t *)__str, 0xCu);
      }
    }
    else
    {
      v123 = *__error();
      v122 = global_os_log;
      if (v123 != 23)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v124 = *__error();
          v125 = __error();
          v126 = strerror(*v125);
          *(_DWORD *)__str = 136446722;
          v133 = "get_num_fds";
          v134 = 1024;
          v135 = v124;
          v136 = 2082;
          v137 = v126;
          _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "%{public}s: errno %d %{public}s", (uint8_t *)__str, 0x1Cu);
          v121 = 0;
          v122 = global_os_log;
        }
        else
        {
          v121 = 0;
        }
        goto LABEL_258;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__str = 136446210;
        v133 = "get_num_fds";
        v127 = "%{public}s: per-system open file limit reached.";
        goto LABEL_265;
      }
    }
    v122 = global_os_log;
LABEL_267:
    if (os_log_type_enabled(v122, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__str = 136446210;
      v133 = "ioloop_dump_object_allocation_stats";
      _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_FAULT, "%{public}s: out of file descriptors!!", (uint8_t *)__str, 0xCu);
    }
    abort();
  }
  v120 = v119;
  v121 = -1;
  do
    ++v121;
  while (readdir(v120));
  closedir(v120);
  v122 = global_os_log;
  if (v121 < 0)
    goto LABEL_267;
LABEL_258:
  if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__str = 136446466;
    v133 = "ioloop_dump_object_allocation_stats";
    v134 = 1024;
    v135 = v121;
    _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "%{public}s: %d file descriptors in use", (uint8_t *)__str, 0x12u);
  }
}

_OWORD *ioloop_message_create_(uint64_t a1, char *a2, int a3)
{
  _OWORD *v3;
  __int16 v6;
  _OWORD *v7;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  char *v12;
  uint8_t buf[4];
  const char *v15;
  __int16 v16;
  int v17;
  __int16 v18;
  _OWORD *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  char *v23;
  __int16 v24;
  int v25;

  if ((unint64_t)(a1 - 0x10000) < 0xFFFFFFFFFFFF000CLL)
    return 0;
  v6 = a1;
  v7 = malloc_type_malloc(a1 + 94, 0xFD9DA76EuLL);
  v3 = v7;
  if (v7)
  {
    *(_OWORD *)((char *)v7 + 78) = 0u;
    v7[3] = 0u;
    v7[4] = 0u;
    v7[1] = 0u;
    v7[2] = 0u;
    *v7 = 0u;
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_10;
    *(_DWORD *)buf = 136447490;
    v15 = "ioloop_message_create_";
    v16 = 1024;
    v17 = 0;
    v18 = 2048;
    v19 = v3;
    v20 = 2080;
    v21 = "message";
    v22 = 2080;
    v23 = strrchr(a2, 47) + 1;
    v24 = 1024;
    v25 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v9 = *(_DWORD *)v3;
    if (*(_DWORD *)v3)
    {
      v10 = v9 + 1;
      *(_DWORD *)v3 = v9 + 1;
      if (v9 + 1 >= 10001)
      {
        v11 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v12 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          v15 = "ioloop_message_create_";
          v16 = 1024;
          v17 = v10;
          v18 = 2048;
          v19 = v3;
          v20 = 2080;
          v21 = "message";
          v22 = 2080;
          v23 = v12 + 1;
          v24 = 1024;
          v25 = a3;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
LABEL_10:
      ++message_created;
      *(_DWORD *)v3 = 1;
    }
    *((_WORD *)v3 + 32) = v6;
  }
  return v3;
}

void adv_ctl_set_int(uint64_t a1, unint64_t *a2, char *__str)
{
  unint64_t v3;
  uint64_t v4;
  const char *v5;
  NSObject *v6;
  const char *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v16;
  unint64_t v17;
  NSObject *v18;
  unint64_t v19;
  int v20;
  char *__endptr;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  unint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;

  v3 = a2[3];
  if (v3 >= 0x129)
  {
    v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446722;
    v23 = "adv_ctl_set_int";
    v24 = 2048;
    v25 = v3;
    v26 = 2048;
    v27 = 296;
    v5 = "%{public}s: which->offset out of range: %zu vs %zu";
    v6 = v4;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v5, buf, 0x20u);
    return;
  }
  __endptr = 0;
  if (*__str == 48 && __str[1] == 120)
  {
    v10 = __str + 2;
    v11 = 16;
  }
  else
  {
    v10 = __str;
    v11 = 10;
  }
  v12 = strtol(v10, &__endptr, v11);
  v13 = v12;
  if (__endptr == __str)
    goto LABEL_17;
  if (!__endptr)
  {
    if (v12 == (int)v12)
      goto LABEL_21;
LABEL_17:
    v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v17 = *a2;
    *(_DWORD *)buf = 136446722;
    v23 = "adv_ctl_set_int";
    v24 = 2082;
    v25 = v17;
    v26 = 2082;
    v27 = (uint64_t)__str;
    v5 = "%{public}s: invalid int for %{public}s: %{public}s";
    v6 = v16;
    goto LABEL_19;
  }
  if (*__endptr)
    v14 = 1;
  else
    v14 = v12 < (uint64_t)0xFFFFFFFF80000000;
  if (v14 || v12 > 0x7FFFFFFF)
    goto LABEL_17;
LABEL_21:
  v18 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v19 = *a2;
    v20 = *(_DWORD *)(a1 + v3);
    *(_DWORD *)buf = 136447746;
    v23 = "adv_ctl_set_int";
    v24 = 2082;
    v25 = v19;
    v26 = 2082;
    v27 = (uint64_t)__str;
    v28 = 2048;
    v29 = v13;
    v30 = 2048;
    v31 = v13;
    v32 = 1024;
    v33 = v20;
    v34 = 1024;
    v35 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: setting %{public}s to '%{public}s' %ld (%lx), originally %d (%x)", buf, 0x40u);
  }
  *(_DWORD *)(a1 + v3) = v13;
}

void adv_ctl_thread_shutdown_continue(uint64_t a1)
{
  uint64_t v2;
  xpc_object_t reply;
  void *v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;

  v2 = *(_QWORD *)(a1 + 176);
  if (v2)
  {
    ioloop_cancel_wake_event(v2);
    ioloop_wakeup_release_(*(_QWORD **)(a1 + 176), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 371);
    *(_QWORD *)(a1 + 176) = 0;
  }
  reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 168));
  if (reply)
  {
    v4 = reply;
    xpc_dictionary_set_uint64(reply, "status", 0);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 160), v4);
    xpc_release(v4);
    xpc_release(*(xpc_object_t *)(a1 + 168));
    *(_QWORD *)(a1 + 168) = 0;
    xpc_release(*(xpc_object_t *)(a1 + 160));
    *(_QWORD *)(a1 + 160) = 0;
    *(_WORD *)(a1 + 284) = 0;
    v5 = *(_QWORD *)(a1 + 144);
    if (v5)
    {
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v8 = 136446466;
        v9 = "adv_ctl_thread_shutdown_continue";
        v10 = 2048;
        v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: clearing server_state->wanted (%p) unconditionally.", (uint8_t *)&v8, 0x16u);
        v5 = *(_QWORD *)(a1 + 144);
      }
      srp_xpc_client_finalize(v5);
    }
  }
  else
  {
    v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v8 = 136446210;
      v9 = "adv_ctl_thread_shutdown_continue";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s: adv_xpc_message: Unable to create reply dictionary.", (uint8_t *)&v8, 0xCu);
    }
  }
}

void srp_xpc_client_finalize(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  void **v4;
  void **v5;
  int v6;
  const char *v7;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136446210;
    v7 = "srp_xpc_client_finalize";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: No longer wanted.", (uint8_t *)&v6, 0xCu);
  }
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
  {
    *(_QWORD *)(v3 + 144) = 0;
    os_release(*(void **)(a1 + 8));
    free((void *)a1);
    thread_device_shutdown((uint64_t *)v3);
    *(_BYTE *)(v3 + 288) = 0;
    v4 = *(void ***)(v3 + 80);
    if (v4)
    {
      do
      {
        v5 = (void **)*v4;
        adv_ctl_wanted_service_free(v4);
        v4 = v5;
      }
      while (v5);
    }
    *(_QWORD *)(v3 + 80) = 0;
  }
  else
  {
    os_release(*(void **)(a1 + 8));
    free((void *)a1);
  }
}

void adv_ctl_wanted_service_free(void **a1)
{
  NSObject *v2;
  const char *v3;
  const char *v4;
  int v5;
  const char *v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  const char *v12;
  __int16 v13;
  void **v14;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = "<null>";
    v4 = (const char *)a1[1];
    if (!v4)
      v4 = "<null>";
    if (a1[2])
      v3 = (const char *)a1[2];
    v5 = 136447235;
    v6 = "adv_ctl_wanted_service_free";
    v7 = 2160;
    v8 = 1752392040;
    v9 = 2081;
    v10 = v4;
    v11 = 2082;
    v12 = v3;
    v13 = 2048;
    v14 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s%{public}s: %p", (uint8_t *)&v5, 0x34u);
  }
  free(a1[1]);
  free(a1[2]);
  free(a1);
}

BOOL adv_xpc_message(xpc_connection_t connection, unint64_t a2, uint64_t a3)
{
  int *v4;
  pid_t pid;
  uid_t euid;
  const char *string;
  int v10;
  NSObject *v11;
  const char *v12;
  NSObject *v13;
  os_log_type_t v14;
  uint32_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  NSObject *v20;
  xpc_object_t reply;
  void *v22;
  void **v23;
  void **v24;
  xpc_object_t array;
  void *v26;
  NSObject *v27;
  size_t count;
  size_t v29;
  void *v30;
  size_t v31;
  const char *v32;
  char *v33;
  char *v34;
  uint64_t v35;
  uint64_t v36;
  char *v37;
  xpc_object_t value;
  char *v39;
  NSObject *v40;
  const char *v41;
  NSObject *v42;
  os_log_type_t v43;
  NSObject *v44;
  int v45;
  NSObject *v46;
  xpc_object_t v47;
  uint64_t v48;
  int v49;
  xpc_object_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  int i;
  uint64_t v55;
  uint64_t v56;
  xpc_object_t v57;
  void *v58;
  const char *v59;
  uint64_t v60;
  xpc_object_t empty;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  xpc_object_t v68;
  void *v69;
  uint64_t v70;
  BOOL v71;
  int64_t v72;
  int64_t v73;
  uint64_t v74;
  uint64_t v75;
  NSObject *v76;
  const char *v77;
  _QWORD *v78;
  NSObject *v79;
  NSObject *v80;
  NSObject *v81;
  uint64_t v82;
  void *v83;
  NSObject *v84;
  void *v85;
  int *v86;
  NSObject *v87;
  int v88;
  int v89;
  int v90;
  NSObject *v91;
  NSObject *v92;
  uint64_t *v93;
  uint64_t *v94;
  NSObject *v95;
  uint64_t v96;
  xpc_object_t v97;
  void *v98;
  NSObject *v100;
  int v101;
  NSObject *v102;
  NSObject *v103;
  NSObject *v104;
  NSObject *v105;
  NSObject *v106;
  NSObject *v107;
  NSObject *v108;
  xpc_object_t xdict;
  uint64_t v110;
  xpc_object_t v111;
  _BYTE buf[38];
  __int16 v113;
  char *v114;
  __int16 v115;
  int v116;
  char __str[4];
  const char *v118;
  __int16 v119;
  uint64_t v120;
  __int16 v121;
  uint64_t v122;

  if (!((unint64_t)connection | a2))
  {
    if (adv_xpc_wakeup)
    {
      ioloop_cancel_wake_event(adv_xpc_wakeup);
      v4 = (int *)adv_xpc_wakeup;
LABEL_38:
      ioloop_add_wake_event((uint64_t)v4, a3, (uint64_t)adv_xpc_restart, 0, 0x2710u);
      return 0;
    }
    v4 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 1022);
    adv_xpc_wakeup = (uint64_t)v4;
    if (v4)
      goto LABEL_38;
    v16 = global_os_log;
    v17 = 0;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return v17;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "adv_xpc_message";
    v18 = "%{public}s: can't create a wakeup to try to recover.";
    goto LABEL_69;
  }
  if (!connection)
  {
    v16 = global_os_log;
    v17 = 0;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return v17;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "adv_xpc_message";
    v18 = "%{public}s: disconnected.";
LABEL_69:
    v42 = v16;
    v43 = OS_LOG_TYPE_DEFAULT;
LABEL_183:
    _os_log_impl((void *)&_mh_execute_header, v42, v43, v18, buf, 0xCu);
    return 0;
  }
  pid = xpc_connection_get_pid(connection);
  euid = xpc_connection_get_euid(connection);
  if (!a2)
  {
    v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "adv_xpc_message";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = euid;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = pid;
      v12 = "%{public}s: Client uid %d pid %d disconnected.";
      v13 = v19;
      v14 = OS_LOG_TYPE_DEFAULT;
      v15 = 24;
      goto LABEL_43;
    }
LABEL_44:
    adv_xpc_connection_delete(connection);
    return 0;
  }
  string = xpc_dictionary_get_string((xpc_object_t)a2, "xpc-command");
  if (!strcmp(string, "enable"))
  {
    v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "adv_xpc_message";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = euid;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = pid;
      *(_WORD *)&buf[24] = 2082;
      *(_QWORD *)&buf[26] = string;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
    }
    reply = xpc_dictionary_create_reply((xpc_object_t)a2);
    if (!reply)
    {
      v74 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "adv_proxy_enable";
      v18 = "%{public}s: Unable to create reply dictionary.";
      goto LABEL_182;
    }
    v22 = reply;
    v23 = (void **)malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040CB5CB6FCuLL);
    if (!v23)
    {
      v75 = -65539;
      v76 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "adv_proxy_enable";
        v77 = "%{public}s: unable to allocate client state structure.";
LABEL_153:
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, v77, buf, 0xCu);
      }
LABEL_154:
      v17 = 0;
LABEL_161:
      xpc_dictionary_set_uint64(v22, "status", v75);
      xpc_connection_send_message(connection, v22);
      xpc_release(v22);
      return v17;
    }
    v24 = v23;
    if (!*(_QWORD *)(a3 + 144))
    {
      v78 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040F89CB87BuLL);
      *(_QWORD *)(a3 + 144) = v78;
      if (!v78)
      {
        v75 = -65539;
        free(v24);
        v76 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "adv_proxy_enable";
          v77 = "%{public}s: unable to allocate srp_wanted structure.";
          goto LABEL_153;
        }
        goto LABEL_154;
      }
      v78[2] = a3;
      *(_QWORD *)(*(_QWORD *)(a3 + 144) + 8) = os_transaction_create("com.apple.srp-mdns-proxy.ostransaction");
      v79 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "adv_proxy_enable";
        _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "%{public}s: Wanted.", buf, 0xCu);
      }
    }
    array = xpc_dictionary_get_array((xpc_object_t)a2, "permitted-interfaces");
    if (array)
    {
      v26 = array;
      if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array)
      {
        v27 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "adv_proxy_enable";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = "permitted-interfaces";
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s type is not array", buf, 0x16u);
        }
      }
      count = xpc_array_get_count(v26);
      if (count)
      {
        v29 = count;
        v30 = malloc_type_calloc(count, 8uLL, 0x10040436913F5uLL);
        v24[4] = v30;
        if (v30)
        {
          v31 = 0;
          while (1)
          {
            v32 = xpc_array_get_string(v26, v31);
            if (v32)
            {
              v33 = (char *)v32;
              v34 = strdup(v32);
              v35 = *((int *)v24 + 10);
              *((_QWORD *)v24[4] + v35) = v34;
              if (!*((_QWORD *)v24[4] + v35))
              {
                v95 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446466;
                  *(_QWORD *)&buf[4] = "adv_proxy_enable";
                  *(_WORD *)&buf[12] = 2082;
                  *(_QWORD *)&buf[14] = v33;
                  _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "%{public}s: no memory for client permitted interface list entry for %{public}s", buf, 0x16u);
                  LODWORD(v35) = *((_DWORD *)v24 + 10);
                }
                if ((int)v35 >= 1)
                {
                  v96 = 0;
                  do
                    free(*((void **)v24[4] + v96++));
                  while (v96 < *((int *)v24 + 10));
                }
                v75 = -65539;
                free(v24[4]);
                v17 = 0;
                v24[4] = 0;
                goto LABEL_161;
              }
              *((_DWORD *)v24 + 10) = v35 + 1;
              v36 = a3;
              v37 = v33;
            }
            else
            {
              value = xpc_array_get_value(v26, v31);
              v39 = xpc_copy_description(value);
              v40 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                v41 = "<null>";
                if (v39)
                  v41 = v39;
                *(_QWORD *)&buf[4] = "adv_proxy_enable";
                *(_WORD *)&buf[12] = 2082;
                *(_QWORD *)&buf[14] = v41;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%{public}s: non-string interface %{public}s specified", buf, 0x16u);
              }
              free(v39);
              v36 = a3;
              v37 = 0;
            }
            ifpermit_add_permitted_interface_to_server_(v36, v37, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 763);
            if (v29 == ++v31)
              goto LABEL_139;
          }
        }
LABEL_147:
        v75 = -65539;
        v76 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "adv_proxy_enable";
          v77 = "%{public}s: no memory for client permitted interface list.";
          goto LABEL_153;
        }
        goto LABEL_154;
      }
      v84 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "adv_proxy_enable";
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "%{public}s: empty permitted interface array.", buf, 0xCu);
      }
      v85 = malloc_type_calloc(0, 8uLL, 0x10040436913F5uLL);
      v24[4] = v85;
      if (!v85)
        goto LABEL_147;
    }
LABEL_139:
    thread_device_startup((uint64_t *)a3);
    v86 = *(int **)(a3 + 144);
    if (v86)
    {
      v87 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v88 = *v86;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "adv_proxy_enable";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v88;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v86;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "server_state->wanted";
        v113 = 2080;
        v114 = "adv-ctl-server.c";
        v115 = 1024;
        v116 = 768;
        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v86 = *(int **)(a3 + 144);
      }
      v89 = *v86;
      if (*v86)
      {
        v90 = v89 + 1;
        *v86 = v89 + 1;
        if (v89 + 1 >= 10001)
        {
          v91 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "adv_proxy_enable";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v90;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v86;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "server_state->wanted";
            v113 = 2080;
            v114 = "adv-ctl-server.c";
            v115 = 1024;
            v116 = 768;
            _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++srp_xpc_client_created;
        *v86 = 1;
      }
    }
    v24[1] = connection;
    v24[2] = (void *)a3;
    xpc_retain(connection);
    *((_BYTE *)v24 + 25) = 1;
    v92 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "adv_proxy_enable";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v24;
      _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "%{public}s: connection from client: %p", buf, 0x16u);
    }
    v93 = &srp_xpc_clients;
    do
    {
      v94 = v93;
      v93 = (uint64_t *)*v93;
    }
    while (v93);
    v75 = 0;
    *v94 = (uint64_t)v24;
    v17 = 1;
    goto LABEL_161;
  }
  if (!strcmp(string, "list service types"))
  {
    v44 = global_os_log;
    v45 = 0;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_175;
    goto LABEL_177;
  }
  if (strcmp(string, "list services"))
  {
    if (!strcmp(string, "list hosts"))
    {
      v44 = global_os_log;
      v45 = 0;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_175;
    }
    else if (!strcmp(string, "get host"))
    {
      v44 = global_os_log;
      v45 = 0;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_175;
    }
    else
    {
      if (!strcmp(string, "flush entries"))
      {
        v80 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "adv_xpc_message";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = euid;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = pid;
          *(_WORD *)&buf[24] = 2082;
          *(_QWORD *)&buf[26] = string;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
        }
        srp_mdns_flush(a3);
        goto LABEL_176;
      }
      if (!strcmp(string, "block service"))
      {
        v44 = global_os_log;
        v45 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_175;
      }
      else if (!strcmp(string, "unblock service"))
      {
        v44 = global_os_log;
        v45 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_175;
      }
      else if (!strcmp(string, "regenerate ULA"))
      {
        v44 = global_os_log;
        v45 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_175;
      }
      else if (!strcmp(string, "advertise prefix"))
      {
        v44 = global_os_log;
        v45 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_175;
      }
      else
      {
        if (strcmp(string, "advertise prefix high priority"))
        {
          if (!strcmp(string, "add prefix"))
          {
            v100 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
LABEL_189:
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "adv_xpc_message";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = euid;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = pid;
              *(_WORD *)&buf[24] = 2082;
              *(_QWORD *)&buf[26] = string;
              _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
            }
          }
          else
          {
            if (strcmp(string, "remove prefix"))
            {
              if (!strcmp(string, "add nat64 prefix"))
              {
                v102 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
LABEL_195:
                  v101 = adv_ctl_nat64_prefix_add_remove((void *)a2);
                  goto LABEL_196;
                }
              }
              else
              {
                if (strcmp(string, "remove nat64 prefix"))
                {
                  if (!strcmp(string, "stop"))
                  {
                    v103 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(_QWORD *)&buf[4] = "adv_xpc_message";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = euid;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = pid;
                      *(_WORD *)&buf[24] = 2082;
                      *(_QWORD *)&buf[26] = string;
                      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                    }
                    thread_device_stop((uint64_t *)a3);
                    goto LABEL_176;
                  }
                  if (!strcmp(string, "get ula"))
                  {
                    v104 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(_QWORD *)&buf[4] = "adv_xpc_message";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = euid;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = pid;
                      *(_WORD *)&buf[24] = 2082;
                      *(_QWORD *)&buf[26] = string;
                      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                    }
                    return adv_xpc_get_ula((void *)a2, connection, a3);
                  }
                  if (!strcmp(string, "disable SRP replication"))
                  {
                    v44 = global_os_log;
                    v45 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_177;
                  }
                  else if (!strcmp(string, "drop srpl connection"))
                  {
                    v44 = global_os_log;
                    v45 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_177;
                  }
                  else if (!strcmp(string, "undrop srpl connection"))
                  {
                    v44 = global_os_log;
                    v45 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_177;
                  }
                  else if (!strcmp(string, "drop srpl advertisement"))
                  {
                    v44 = global_os_log;
                    v45 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_177;
                  }
                  else if (!strcmp(string, "undrop srpl advertisement"))
                  {
                    v44 = global_os_log;
                    v45 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      goto LABEL_177;
                  }
                  else
                  {
                    if (!strcmp(string, "start dropping push connections"))
                    {
                      v105 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(_QWORD *)&buf[4] = "adv_xpc_message";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = euid;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = pid;
                        *(_WORD *)&buf[24] = 2082;
                        *(_QWORD *)&buf[26] = string;
                        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                      }
                      dp_start_dropping();
                      goto LABEL_176;
                    }
                    if (!strcmp(string, "start breaking time validation"))
                    {
                      v106 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(_QWORD *)&buf[4] = "adv_xpc_message";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = euid;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = pid;
                        *(_WORD *)&buf[24] = 2082;
                        *(_QWORD *)&buf[26] = string;
                        _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                      }
                      v45 = 0;
                      *(_BYTE *)(a3 + 281) = 1;
                      goto LABEL_177;
                    }
                    if (!strcmp(string, "set variable"))
                    {
                      v107 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(_QWORD *)&buf[4] = "adv_xpc_message";
                        *(_WORD *)&buf[12] = 1024;
                        *(_DWORD *)&buf[14] = euid;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = pid;
                        *(_WORD *)&buf[24] = 2082;
                        *(_QWORD *)&buf[26] = string;
                        _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                      }
                      adv_ctl_xpc_set_variable(a3, (xpc_object_t)a2);
                      goto LABEL_176;
                    }
                    if (!strcmp(string, "block anycast service"))
                    {
                      v44 = global_os_log;
                      v45 = 0;
                      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_177;
                    }
                    else
                    {
                      if (strcmp(string, "unblock anycast service"))
                      {
                        if (!strcmp(string, "start thread shutdown"))
                        {
                          v108 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136446978;
                            *(_QWORD *)&buf[4] = "adv_xpc_message";
                            *(_WORD *)&buf[12] = 1024;
                            *(_DWORD *)&buf[14] = euid;
                            *(_WORD *)&buf[18] = 1024;
                            *(_DWORD *)&buf[20] = pid;
                            *(_WORD *)&buf[24] = 2082;
                            *(_QWORD *)&buf[26] = string;
                            _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                          }
                          adv_ctl_start_thread_shutdown((void *)a2, connection, a3);
                          return 1;
                        }
                        v10 = strcmp(string, "need service instance");
                        v11 = global_os_log;
                        if (v10)
                        {
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 136446978;
                            *(_QWORD *)&buf[4] = "adv_xpc_message";
                            *(_WORD *)&buf[12] = 1024;
                            *(_DWORD *)&buf[14] = euid;
                            *(_WORD *)&buf[18] = 1024;
                            *(_DWORD *)&buf[20] = pid;
                            *(_WORD *)&buf[24] = 2082;
                            *(_QWORD *)&buf[26] = string;
                            v12 = "%{public}s: Client uid %d pid %d sent a request with unknown message type %{public}s.";
                            v13 = v11;
                            v14 = OS_LOG_TYPE_ERROR;
                            v15 = 34;
LABEL_43:
                            _os_log_impl((void *)&_mh_execute_header, v13, v14, v12, buf, v15);
                            goto LABEL_44;
                          }
                          goto LABEL_44;
                        }
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 136446722;
                          *(_QWORD *)&buf[4] = "adv_xpc_message";
                          *(_WORD *)&buf[12] = 1024;
                          *(_DWORD *)&buf[14] = euid;
                          *(_WORD *)&buf[18] = 1024;
                          *(_DWORD *)&buf[20] = pid;
                          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a kDNSSDAdvertisingProxyNeedServiceInstance request.", buf, 0x18u);
                        }
                        adv_ctl_need_service_instance((void *)a2, a3);
                        goto LABEL_176;
                      }
                      v44 = global_os_log;
                      v45 = 0;
                      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        goto LABEL_177;
                    }
                  }
LABEL_175:
                  *(_DWORD *)buf = 136446978;
                  *(_QWORD *)&buf[4] = "adv_xpc_message";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = euid;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = pid;
                  *(_WORD *)&buf[24] = 2082;
                  *(_QWORD *)&buf[26] = string;
                  _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
LABEL_176:
                  v45 = 0;
                  goto LABEL_177;
                }
                v102 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_195;
              }
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "adv_xpc_message";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = euid;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = pid;
              *(_WORD *)&buf[24] = 2082;
              *(_QWORD *)&buf[26] = string;
              _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
              goto LABEL_195;
            }
            v100 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              goto LABEL_189;
          }
          v101 = adv_ctl_prefix_add_remove((void *)a2);
LABEL_196:
          v45 = v101;
          goto LABEL_177;
        }
        v44 = global_os_log;
        v45 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_175;
      }
    }
LABEL_177:
    v97 = xpc_dictionary_create_reply((xpc_object_t)a2);
    if (v97)
    {
      v98 = v97;
      xpc_dictionary_set_uint64(v97, "status", v45);
      xpc_connection_send_message(connection, v98);
      v83 = v98;
LABEL_179:
      xpc_release(v83);
      return 0;
    }
    v74 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "adv_xpc_message";
    v18 = "%{public}s: adv_xpc_message: Unable to create reply dictionary.";
    goto LABEL_182;
  }
  v46 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "adv_xpc_message";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = euid;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = pid;
    *(_WORD *)&buf[24] = 2082;
    *(_QWORD *)&buf[26] = string;
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
  }
  v47 = xpc_array_create(0, 0);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  gettimeofday((timeval *)buf, 0);
  if (!v47)
  {
    v74 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "adv_xpc_list_services";
    v18 = "%{public}s: adv_xpc_list_services: Unable to create service array";
    goto LABEL_182;
  }
  v48 = *(_QWORD *)buf;
  v49 = *(_DWORD *)&buf[8];
  v50 = xpc_dictionary_create_reply((xpc_object_t)a2);
  if (!v50)
  {
    v74 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "adv_xpc_list_services";
    v18 = "%{public}s: adv_xpc_list_services: Unable to create reply dictionary.";
LABEL_182:
    v42 = v74;
    v43 = OS_LOG_TYPE_ERROR;
    goto LABEL_183;
  }
  xdict = v50;
  xpc_dictionary_set_uint64(v50, "status", 0);
  v51 = *(_QWORD *)(a3 + 8);
  if (!v51)
    goto LABEL_113;
  v52 = 1000 * v48 + v49 / 1000;
  v110 = v52;
  v111 = v47;
  while (2)
  {
    v53 = 0;
    for (i = 0; ; ++i)
    {
      v55 = *(_QWORD *)(v51 + 112);
      if (v55 && i < *(_DWORD *)(v55 + 4))
      {
        v56 = *(_QWORD *)(*(_QWORD *)(v55 + 8) + 8 * i);
        if (!v56)
          continue;
        goto LABEL_85;
      }
      if ((v53 & 1) != 0)
        break;
      v56 = 0;
LABEL_85:
      v57 = xpc_dictionary_create(0, 0, 0);
      if (!v57)
      {
        v81 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v82 = *(_QWORD *)(v51 + 56);
          *(_DWORD *)__str = 136446723;
          v118 = "adv_xpc_list_services";
          v119 = 2160;
          v120 = 1752392040;
          v121 = 2081;
          v122 = v82;
          _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%{public}s: adv_xpc_list_services: failed to allocate instance dictionary for %{private, mask.hash}s", (uint8_t *)__str, 0x20u);
        }
        xpc_release(v47);
        v83 = xdict;
        goto LABEL_179;
      }
      v58 = v57;
      xpc_dictionary_set_string(v57, "hostname", *(const char **)(v51 + 56));
      xpc_dictionary_set_string(v58, "regname", *(const char **)(v51 + 64));
      if (v56)
      {
        xpc_dictionary_set_string(v58, "name", *(const char **)(v56 + 48));
        xpc_dictionary_set_string(v58, "type", *(const char **)(v56 + 56));
        snprintf(__str, 6uLL, "%u", *(_DWORD *)(v56 + 64));
        xpc_dictionary_set_string(v58, "port", __str);
        xpc_dictionary_set_data(v58, "txt", *(const void **)(v56 + 72), *(unsigned __int16 *)(v56 + 80));
        v59 = "replicated";
        if (*(_QWORD *)(v51 + 224) == *(_QWORD *)(a3 + 224))
        {
          if (*(_BYTE *)(v56 + 118))
            v59 = "anycast";
          else
            v59 = "unicast";
        }
        xpc_dictionary_set_string(v58, "regtype", v59);
      }
      v60 = *(_QWORD *)(v51 + 96);
      if (v60)
      {
        if (*(int *)(v60 + 4) >= 1)
        {
          empty = xpc_array_create_empty();
          if (empty)
          {
            v62 = empty;
            v63 = *(_QWORD *)(v51 + 96);
            if (*(int *)(v63 + 4) >= 1)
            {
              v64 = 0;
              v65 = 0;
              do
              {
                v66 = *(_QWORD *)(*(_QWORD *)(v63 + 8) + 8 * v64);
                if (v66)
                {
                  v67 = *(_WORD *)(v66 + 48) == 1 ? 2 : 30;
                  inet_ntop(v67, *(const void **)(v66 + 40), buf, 0x2Eu);
                  v68 = xpc_string_create(buf);
                  if (v68)
                  {
                    v69 = v68;
                    xpc_array_append_value(v62, v68);
                    xpc_release(v69);
                    ++v65;
                  }
                }
                ++v64;
                v63 = *(_QWORD *)(v51 + 96);
              }
              while (v64 < *(int *)(v63 + 4));
              v52 = v110;
              if (v65)
                xpc_dictionary_set_value(v58, "addresses", v62);
            }
            xpc_release(v62);
            v47 = v111;
          }
        }
      }
      v70 = *(_QWORD *)(v51 + 256);
      v71 = v70 < v52;
      v72 = v70 - v52;
      if (v71)
        v73 = -1;
      else
        v73 = v72;
      xpc_dictionary_set_int64(v58, "lease", v73);
      xpc_dictionary_set_BOOL(v58, "removed", *(_BYTE *)(v51 + 264));
      xpc_dictionary_set_int64(v58, "update-server-id", *(_QWORD *)(v51 + 224));
      xpc_array_append_value(v47, v58);
      xpc_release(v58);
      v53 = 1;
    }
    v51 = *(_QWORD *)(v51 + 40);
    if (v51)
      continue;
    break;
  }
LABEL_113:
  xpc_dictionary_set_value(xdict, "instances", v47);
  xpc_release(v47);
  xpc_connection_send_message(connection, xdict);
  xpc_release(xdict);
  return 1;
}

uint64_t adv_xpc_restart(uint64_t a1)
{
  uint64_t result;

  result = ioloop_create_xpc_service();
  *(_QWORD *)(a1 + 136) = result;
  if (!result)
    return ioloop_add_wake_event(adv_xpc_wakeup, a1, (uint64_t)adv_xpc_restart, 0, 0x2710u);
  return result;
}

void adv_xpc_connection_delete(void *a1)
{
  uint64_t *v1;
  uint64_t *v2;
  int *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  v1 = &srp_xpc_clients;
  do
  {
    v2 = v1;
    v1 = (uint64_t *)*v1;
    if (!v1)
      return;
  }
  while ((void *)v1[1] != a1);
  xpc_release(a1);
  if (*((_BYTE *)v1 + 25))
  {
    v3 = *(int **)(v1[2] + 144);
    if (v3)
    {
      v4 = *v3;
      if (*v3)
      {
        v5 = global_os_log;
        if (v4 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v12 = 136447490;
            v13 = "adv_xpc_connection_delete";
            v14 = 1024;
            *(_DWORD *)v15 = v4;
            *(_WORD *)&v15[4] = 2048;
            *(_QWORD *)&v15[6] = v3;
            *(_WORD *)&v15[14] = 2080;
            *(_QWORD *)&v15[16] = "client->server_state->wanted";
            *(_WORD *)&v15[24] = 2080;
            *(_QWORD *)&v15[26] = "adv-ctl-server.c";
            v16 = 1024;
            v17 = 831;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
            v3 = *(int **)(v1[2] + 144);
            v4 = *v3;
          }
          *v3 = v4 - 1;
          if (v4 == 1)
          {
            v6 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v12 = 136447234;
              v13 = "adv_xpc_connection_delete";
              v14 = 2048;
              *(_QWORD *)v15 = v3;
              *(_WORD *)&v15[8] = 2080;
              *(_QWORD *)&v15[10] = "client->server_state->wanted";
              *(_WORD *)&v15[18] = 2080;
              *(_QWORD *)&v15[20] = "adv-ctl-server.c";
              *(_WORD *)&v15[28] = 1024;
              *(_DWORD *)&v15[30] = 831;
              _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
              v3 = *(int **)(v1[2] + 144);
            }
            ++srp_xpc_client_finalized;
            srp_xpc_client_finalize((uint64_t)v3);
          }
          goto LABEL_14;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_26:
          abort();
        v12 = 136447490;
        v13 = "adv_xpc_connection_delete";
        v14 = 1024;
        *(_DWORD *)v15 = v4;
        *(_WORD *)&v15[4] = 2048;
        *(_QWORD *)&v15[6] = v3;
        *(_WORD *)&v15[14] = 2080;
        *(_QWORD *)&v15[16] = "client->server_state->wanted";
        *(_WORD *)&v15[24] = 2080;
        *(_QWORD *)&v15[26] = "adv-ctl-server.c";
        v16 = 1024;
        v17 = 831;
        v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v11 = v5;
      }
      else
      {
        v9 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_26;
        v12 = 136447490;
        v13 = "adv_xpc_connection_delete";
        v14 = 1024;
        *(_DWORD *)v15 = 0;
        *(_WORD *)&v15[4] = 2048;
        *(_QWORD *)&v15[6] = v3;
        *(_WORD *)&v15[14] = 2080;
        *(_QWORD *)&v15[16] = "client->server_state->wanted";
        *(_WORD *)&v15[24] = 2080;
        *(_QWORD *)&v15[26] = "adv-ctl-server.c";
        v16 = 1024;
        v17 = 831;
        v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        v11 = v9;
      }
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v12, 0x36u);
      goto LABEL_26;
    }
  }
LABEL_14:
  if (*((int *)v1 + 10) >= 1)
  {
    v7 = 0;
    do
    {
      ifpermit_list_remove(*(_QWORD *)(v1[2] + 72), *(char **)(v1[4] + 8 * v7));
      free(*(void **)(v1[4] + 8 * v7++));
    }
    while (v7 < *((int *)v1 + 10));
  }
  free((void *)v1[4]);
  *v2 = *v1;
  v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 136446466;
    v13 = "adv_xpc_connection_delete";
    v14 = 2048;
    *(_QWORD *)v15 = v1;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: deleting client: %p", (uint8_t *)&v12, 0x16u);
  }
  free(v1);
}

uint64_t adv_ctl_prefix_add_remove(void *a1)
{
  unsigned __int8 *data;
  size_t v2;
  NSObject *v3;
  BOOL v4;
  uint64_t v5;
  int v6;
  const char *v7;
  size_t length;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unsigned __int8 *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unsigned __int8 *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unsigned __int8 *v31;

  length = 0;
  data = (unsigned __int8 *)xpc_dictionary_get_data(a1, "data", &length);
  v2 = length;
  v3 = global_os_log;
  if (data)
    v4 = length == 16;
  else
    v4 = 0;
  if (v4)
  {
    v5 = 0;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *data;
      if ((v6 & 0xFE) == 0xFC)
      {
        v7 = "ULA: ";
      }
      else if (v6 == 254 && (data[1] & 0xC0) == 0x80)
      {
        v7 = "LUA: ";
      }
      else if ((v6 & 0xE0) == 0x20)
      {
        v7 = "GUA: ";
      }
      else
      {
        v7 = (const char *)&unk_10007C3B5;
      }
      *(_DWORD *)buf = 136448771;
      v11 = "adv_ctl_prefix_add_remove";
      v12 = 2082;
      v13 = v7;
      v14 = 2160;
      v15 = 1752392040;
      v16 = 1041;
      v17 = 6;
      v18 = 2097;
      v19 = data;
      v20 = 2160;
      v21 = 1752392040;
      v22 = 1042;
      v23 = 2;
      v24 = 2098;
      v25 = data + 6;
      v26 = 2160;
      v27 = 1752392040;
      v28 = 1041;
      v29 = 8;
      v30 = 2097;
      v31 = data + 8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: got prefix {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x64u);
      return 0;
    }
  }
  else
  {
    v5 = 4294901756;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v11 = "adv_ctl_prefix_add_remove";
      v12 = 2048;
      v13 = (const char *)data;
      v14 = 2048;
      v15 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s: invalid request, data[%p], data_len[%ld]", buf, 0x20u);
    }
  }
  return v5;
}

uint64_t adv_ctl_nat64_prefix_add_remove(void *a1)
{
  unsigned __int8 *data;
  size_t v2;
  NSObject *v3;
  BOOL v4;
  uint64_t v5;
  int v6;
  const char *v7;
  size_t length;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  int v17;
  __int16 v18;
  unsigned __int8 *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  unsigned __int8 *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unsigned __int8 *v31;

  length = 0;
  data = (unsigned __int8 *)xpc_dictionary_get_data(a1, "data", &length);
  v2 = length;
  v3 = global_os_log;
  if (data)
    v4 = length == 16;
  else
    v4 = 0;
  if (v4)
  {
    v5 = 0;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *data;
      if ((v6 & 0xFE) == 0xFC)
      {
        v7 = "ULA: ";
      }
      else if (v6 == 254 && (data[1] & 0xC0) == 0x80)
      {
        v7 = "LUA: ";
      }
      else if ((v6 & 0xE0) == 0x20)
      {
        v7 = "GUA: ";
      }
      else
      {
        v7 = (const char *)&unk_10007C3B5;
      }
      *(_DWORD *)buf = 136448771;
      v11 = "adv_ctl_nat64_prefix_add_remove";
      v12 = 2082;
      v13 = v7;
      v14 = 2160;
      v15 = 1752392040;
      v16 = 1041;
      v17 = 6;
      v18 = 2097;
      v19 = data;
      v20 = 2160;
      v21 = 1752392040;
      v22 = 1042;
      v23 = 2;
      v24 = 2098;
      v25 = data + 6;
      v26 = 2160;
      v27 = 1752392040;
      v28 = 1041;
      v29 = 8;
      v30 = 2097;
      v31 = data + 8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: got nat64 prefix {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x64u);
      return 0;
    }
  }
  else
  {
    v5 = 4294901756;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v11 = "adv_ctl_nat64_prefix_add_remove";
      v12 = 2048;
      v13 = (const char *)data;
      v14 = 2048;
      v15 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s: invalid request, data[%p], data_len[%ld]", buf, 0x20u);
    }
  }
  return v5;
}

BOOL adv_xpc_get_ula(void *a1, _xpc_connection_s *a2, uint64_t a3)
{
  xpc_object_t reply;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  NSObject *v9;
  int v11;
  const char *v12;

  reply = xpc_dictionary_create_reply(a1);
  v6 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "status", 0);
    v7 = 0;
    v8 = 0;
    do
      v8 = *(unsigned __int8 *)(a3 + 225 + v7++) | (v8 << 8);
    while (v7 != 5);
    xpc_dictionary_set_uint64(v6, "ula", v8);
    xpc_connection_send_message(a2, v6);
    xpc_release(v6);
  }
  else
  {
    v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v11 = 136446210;
      v12 = "adv_xpc_get_ula";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: Unable to create reply dictionary.", (uint8_t *)&v11, 0xCu);
    }
  }
  return v6 != 0;
}

void adv_ctl_xpc_set_variable(uint64_t a1, xpc_object_t xdict)
{
  unsigned __int8 *data;
  unsigned __int8 *v4;
  size_t v5;
  size_t v6;
  char *v7;
  size_t v8;
  int v9;
  NSObject *v10;
  char *v11;
  char *v12;
  size_t v13;
  _BYTE *v14;
  _BYTE *v15;
  char *v16;
  const char *v17;
  uint64_t v18;
  int v19;
  char **v20;
  uint64_t v21;
  const char *v22;
  uint8_t *v23;
  NSObject *v24;
  uint32_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  size_t length;
  uint8_t buf[4];
  const char *v31;
  __int16 v32;
  char *v33;
  __int16 v34;
  size_t v35;
  __int16 v36;
  unsigned __int8 *v37;
  __int16 v38;
  char *v39;
  __int16 v40;
  _BYTE *v41;
  __int16 v42;
  size_t v43;
  char __str[4];
  const char *v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  size_t v49;
  uint64_t v50;

  length = 0;
  data = (unsigned __int8 *)xpc_dictionary_get_data(xdict, "data", &length);
  if (!data)
  {
    v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)__str = 136446722;
    v45 = "adv_ctl_xpc_set_variable";
    v46 = 2048;
    v47 = 0;
    v48 = 2048;
    v49 = length;
    v22 = "%{public}s: invalid request, data %p, len %zu";
    v23 = (uint8_t *)__str;
    v24 = v21;
    v25 = 32;
    goto LABEL_26;
  }
  v4 = data;
  v5 = length;
  if (length)
  {
    v6 = 0;
    v7 = __str;
    do
    {
      v8 = v6 + 1;
      v9 = snprintf(v7, (char *)&v50 - v7, "%02x ", v4[v6]);
      if (v8 >= v5)
        break;
      v7 += v9;
      v6 = v8;
    }
    while (v7 < (char *)&v50);
  }
  v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v31 = "adv_ctl_set_variable";
    v32 = 2082;
    v33 = __str;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: hexbuf: %{public}s", buf, 0x16u);
  }
  v11 = (char *)memchr(v4, 0, v5);
  if (!v11)
  {
    v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    v31 = "adv_ctl_set_variable";
    v22 = "%{public}s: name not NUL-terminated";
LABEL_25:
    v23 = buf;
    v24 = v26;
    v25 = 12;
    goto LABEL_26;
  }
  v12 = v11 + 1;
  v13 = v11 + 1 - (char *)v4;
  if (v13 >= v5)
  {
    v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    v31 = "adv_ctl_set_variable";
    v22 = "%{public}s: no value";
    goto LABEL_25;
  }
  v14 = memchr(v11 + 1, 0, v13);
  if (!v14)
  {
    v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    v31 = "adv_ctl_set_variable";
    v22 = "%{public}s: value not NUL-terminated";
    goto LABEL_25;
  }
  v15 = v14;
  v16 = (char *)(v14 - v4);
  if (v14 - v4 != v5 - 1)
  {
    v27 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136447746;
    v31 = "adv_ctl_set_variable";
    v32 = 2048;
    v33 = v16;
    v34 = 2048;
    v35 = v5;
    v36 = 2048;
    v37 = v4;
    v38 = 2048;
    v39 = v12;
    v40 = 2048;
    v41 = v15;
    v42 = 2048;
    v43 = v13;
    v22 = "%{public}s: extra bytes at end of name/value buffer: %zd != %zd %p %p %p %zu";
    v23 = buf;
    v24 = v27;
    v25 = 72;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v22, v23, v25);
    return;
  }
  v17 = variables;
  if (variables)
  {
    v18 = 0;
    v19 = 1;
    v20 = &variables;
    while (strcmp((const char *)v4, v17))
    {
      v18 = v19;
      v20 = &(&variables)[4 * v19];
      v17 = *v20;
      ++v19;
      if (!*v20)
        return;
    }
    v28 = (&variables)[4 * v18 + 2];
    if (v28)
      ((void (*)(uint64_t, char **, char *))v28)(a1, v20, v12);
  }
}

void adv_ctl_start_thread_shutdown(void *a1, xpc_object_t object, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int *v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  void (*v13)(int *);
  NSObject *v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  const char *v18;
  NSObject *v19;
  int v20;
  const char *v21;
  __int16 v22;
  _BYTE v23[34];
  __int16 v24;
  int v25;

  *(_QWORD *)(a3 + 160) = object;
  xpc_retain(object);
  *(_QWORD *)(a3 + 168) = a1;
  xpc_retain(a1);
  v5 = *(_QWORD *)(a3 + 40);
  if (v5)
    service_tracker_cancel_probes(v5);
  v6 = *(_QWORD *)(a3 + 128);
  if (v6)
  {
    dnssd_client_cancel(v6);
    dnssd_client_release_(*(int **)(a3 + 128), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 458);
    *(_QWORD *)(a3 + 128) = 0;
  }
  v7 = *(_QWORD *)(a3 + 48);
  if (v7)
  {
    *(_BYTE *)(v7 + 264) = 1;
    v8 = state_machine_event_create(14);
    if (!v8)
    {
      v14 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v20 = 136446210;
        v21 = "service_publisher_stop_publishing";
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v20, 0xCu);
      }
      goto LABEL_19;
    }
    v9 = v8;
    state_machine_event_deliver(v7 + 8, (uint64_t)v8);
    v10 = *v9;
    if (*v9)
    {
      v11 = global_os_log;
      if (v10 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v20 = 136447490;
          v21 = "service_publisher_stop_publishing";
          v22 = 1024;
          *(_DWORD *)v23 = v10;
          *(_WORD *)&v23[4] = 2048;
          *(_QWORD *)&v23[6] = v9;
          *(_WORD *)&v23[14] = 2080;
          *(_QWORD *)&v23[16] = "event";
          *(_WORD *)&v23[24] = 2080;
          *(_QWORD *)&v23[26] = "service-publisher.c";
          v24 = 1024;
          v25 = 1119;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
          v10 = *v9;
        }
        *v9 = v10 - 1;
        if (v10 == 1)
        {
          v12 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v20 = 136447234;
            v21 = "service_publisher_stop_publishing";
            v22 = 2048;
            *(_QWORD *)v23 = v9;
            *(_WORD *)&v23[8] = 2080;
            *(_QWORD *)&v23[10] = "event";
            *(_WORD *)&v23[18] = 2080;
            *(_QWORD *)&v23[20] = "service-publisher.c";
            *(_WORD *)&v23[28] = 1024;
            *(_DWORD *)&v23[30] = 1119;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
          }
          ++state_machine_event_finalized;
          v13 = (void (*)(int *))*((_QWORD *)v9 + 4);
          if (v13)
            v13(v9);
          free(v9);
        }
LABEL_19:
        service_publisher_cancel(*(_QWORD *)(a3 + 48));
        service_publisher_release_(*(int **)(a3 + 48), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 464);
        *(_QWORD *)(a3 + 48) = 0;
        v15 = *(_QWORD *)(a3 + 40);
        if (v15 && *(_BYTE *)(v15 + 58))
          *(_BYTE *)(a3 + 284) = 1;
        goto LABEL_22;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_33:
        abort();
      v20 = 136447490;
      v21 = "service_publisher_stop_publishing";
      v22 = 1024;
      *(_DWORD *)v23 = v10;
      *(_WORD *)&v23[4] = 2048;
      *(_QWORD *)&v23[6] = v9;
      *(_WORD *)&v23[14] = 2080;
      *(_QWORD *)&v23[16] = "event";
      *(_WORD *)&v23[24] = 2080;
      *(_QWORD *)&v23[26] = "service-publisher.c";
      v24 = 1024;
      v25 = 1119;
      v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v19 = v11;
    }
    else
    {
      v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_33;
      v20 = 136447490;
      v21 = "service_publisher_stop_publishing";
      v22 = 1024;
      *(_DWORD *)v23 = 0;
      *(_WORD *)&v23[4] = 2048;
      *(_QWORD *)&v23[6] = v9;
      *(_WORD *)&v23[14] = 2080;
      *(_QWORD *)&v23[16] = "event";
      *(_WORD *)&v23[24] = 2080;
      *(_QWORD *)&v23[26] = "service-publisher.c";
      v24 = 1024;
      v25 = 1119;
      v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v19 = v17;
    }
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v20, 0x36u);
    goto LABEL_33;
  }
LABEL_22:
  if (!*(_BYTE *)(a3 + 284))
    adv_ctl_thread_shutdown_continue(a3);
  v16 = *(int **)(a3 + 176);
  if (v16
    || (v16 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 402), (*(_QWORD *)(a3 + 176) = v16) != 0))
  {
    ioloop_add_wake_event((uint64_t)v16, a3, (uint64_t)adv_ctl_thread_shutdown_continue, 0, 0x7D0u);
  }
  else
  {
    adv_ctl_thread_shutdown_continue(a3);
  }
}

void adv_ctl_need_service_instance(void *a1, uint64_t a2)
{
  const char *string;
  const char *v5;
  _BOOL4 v6;
  _BOOL4 v7;
  const char **v8;
  const char **v9;
  const char **v10;
  int v11;
  char v12;
  void **v13;
  char *v14;
  char *v15;
  NSObject *v16;
  uint64_t v17;
  int v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  const char *v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  void **v27;

  string = xpc_dictionary_get_string(a1, "name");
  v5 = xpc_dictionary_get_string(a1, "service-type");
  v6 = xpc_dictionary_get_BOOL(a1, "needed");
  v7 = v6;
  if (string && v5)
  {
    v9 = (const char **)(a2 + 80);
    v8 = *(const char ***)(a2 + 80);
    if (v8)
    {
      do
      {
        v10 = v8;
        if (!strcasecmp(v8[1], string))
        {
          v11 = strcasecmp(v10[2], v5);
          if (v11)
            v12 = 1;
          else
            v12 = v7;
          if ((v12 & 1) == 0)
          {
            *v9 = *v10;
            adv_ctl_wanted_service_free((void **)v10);
            return;
          }
          if (!v11)
            return;
        }
        v8 = (const char **)*v10;
        v9 = v10;
      }
      while (*v10);
      if (v7)
        goto LABEL_15;
    }
    else
    {
      v10 = (const char **)(a2 + 80);
      if (v6)
      {
LABEL_15:
        v13 = (void **)malloc_type_calloc(1uLL, 0x18uLL, 0x30040F310086FuLL);
        if (v13)
        {
          v14 = strdup(string);
          v13[1] = v14;
          v15 = strdup(v5);
          v13[2] = v15;
          if (!v14 || !v15)
          {
            adv_ctl_wanted_service_free(v13);
            v13 = 0;
          }
        }
        v16 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v18 = 136447235;
          v19 = "adv_ctl_wanted_service_allocate";
          v20 = 2160;
          v21 = 1752392040;
          v22 = 2081;
          v23 = string;
          v24 = 2082;
          v25 = v5;
          v26 = 2048;
          v27 = v13;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s%{public}s: %p", (uint8_t *)&v18, 0x34u);
        }
        *v10 = (const char *)v13;
        if (v13)
        {
          v17 = *(_QWORD *)(a2 + 48);
          if (v17)
            service_publisher_wanted_service_added(v17);
        }
      }
    }
  }
  else
  {
    *(_BYTE *)(a2 + 288) = v6;
    service_publisher_wanted_service_added(*(_QWORD *)(a2 + 48));
  }
}

void keychain_key_remove()
{
  __CFDictionary *Mutable;
  __CFDictionary *v1;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v1 = Mutable;
    CFDictionaryAddValue(Mutable, kSecClass, kSecClassKey);
    CFDictionaryAddValue(v1, kSecAttrAccessGroup, CFSTR("com.apple.srp-mdns-proxy"));
    CFDictionaryAddValue(v1, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
    CFDictionaryAddValue(v1, kSecUseDataProtectionKeychain, kCFBooleanTrue);
    CFDictionaryAddValue(v1, kSecAttrSynchronizable, kCFBooleanFalse);
    SecItemDelete(v1);
    CFDictionaryRemoveValue(v1, kSecAttrAccessible);
    SecItemDelete(v1);
    CFRelease(v1);
  }
}

uint64_t keychain_identity_query(int a1, uint64_t *a2, double *a3)
{
  __CFDictionary *Mutable;
  uint64_t v7;
  CFMutableArrayRef v8;
  __CFArray *v9;
  CFStringRef v10;
  CFStringRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t Count;
  NSObject *v15;
  double Current;
  double v17;
  CFIndex v18;
  double AbsoluteTime;
  const __CFDictionary *v20;
  const __CFDictionary *v21;
  CFTypeID v22;
  const __CFString *v23;
  CFStringRef v24;
  const void *v25;
  const void *v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFDate *v29;
  __CFString *MutableCopy;
  __CFString *v31;
  const __CFDictionary *v32;
  CFTypeID v33;
  CFIndex v34;
  const __CFDictionary *v35;
  CFTypeID v36;
  const __CFDate *v37;
  const __CFDate *v38;
  const __CFDictionary *v39;
  NSObject *v40;
  CFIndex v42;
  CFIndex v43;
  CFIndex i;
  const __CFDictionary *ValueAtIndex;
  const __CFString *Value;
  uint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  double *v50;
  CFIndex v51;
  CFTypeRef v52;
  CFTypeRef result;
  _BYTE cf[24];
  CFRange v55;

  v52 = 0;
  result = 0;
  if (a1 || (Mutable = 0, v7 = 4294967246, a2) && a3)
  {
    v7 = 4294899624;
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v8 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v8)
      {
        v9 = v8;
        v49 = a2;
        v50 = a3;
        v10 = kSecReturnRef;
        CFDictionaryAddValue(Mutable, kSecReturnRef, kCFBooleanTrue);
        v11 = kSecReturnAttributes;
        CFDictionaryAddValue(Mutable, kSecReturnAttributes, kCFBooleanTrue);
        CFDictionaryAddValue(Mutable, kSecUseDataProtectionKeychain, kCFBooleanTrue);
        CFDictionaryAddValue(Mutable, kSecMatchLimit, kSecMatchLimitAll);
        CFDictionaryAddValue(Mutable, kSecAttrAccessGroup, CFSTR("com.apple.srp-mdns-proxy"));
        CFDictionaryAddValue(Mutable, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
        CFDictionaryAddValue(Mutable, kSecClass, kSecClassKey);
        CFDictionaryAddValue(Mutable, kSecAttrSynchronizable, kCFBooleanFalse);
        v12 = SecItemCopyMatching(Mutable, &result);
        if (!a1)
        {
          v13 = v12;
          if ((_DWORD)v12)
            goto LABEL_60;
        }
        if (result)
        {
          Count = CFArrayGetCount((CFArrayRef)result);
          if (Count >= 1)
          {
            v55.length = Count;
            v55.location = 0;
            CFArrayAppendArray(v9, (CFArrayRef)result, v55);
          }
        }
        if (a1 == 1)
        {
          CFDictionaryRemoveValue(Mutable, kSecAttrAccessible);
          if (!SecItemCopyMatching(Mutable, &v52))
          {
            if (v52)
            {
              v42 = CFArrayGetCount((CFArrayRef)v52);
              if (v42 >= 1)
              {
                v43 = v42;
                for (i = 0; i != v43; ++i)
                {
                  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v52, i);
                  Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, kSecAttrAccessible);
                  if (!Value || CFStringCompare(Value, kSecAttrAccessibleAfterFirstUnlock, 0))
                    CFArrayAppendValue(v9, ValueAtIndex);
                }
              }
            }
          }
          v51 = CFArrayGetCount(v9);
          v11 = kSecReturnAttributes;
          v10 = kSecReturnRef;
          if (v51 < 1)
            goto LABEL_59;
        }
        else
        {
          v51 = CFArrayGetCount(v9);
          if (v51 == 1)
          {
            v51 = 1;
          }
          else
          {
            v15 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)cf = 134217984;
              *(_QWORD *)&cf[4] = v51;
              _os_log_fault_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "Have more than one TLS private keys -- count: %ld", cf, 0xCu);
            }
          }
        }
        CFDictionaryReplaceValue(Mutable, kSecClass, kSecClassCertificate);
        CFDictionaryReplaceValue(Mutable, kSecAttrSynchronizable, kCFBooleanTrue);
        CFDictionaryAddValue(Mutable, kSecAttrSyncViewHint, kSecAttrViewHintLimitedPeersAllowed);
        if (a1 == 1)
        {
          CFDictionaryRemoveValue(Mutable, v10);
          CFDictionaryRemoveValue(Mutable, v11);
          CFDictionaryRemoveValue(Mutable, kSecMatchLimit);
        }
        Current = CFAbsoluteTimeGetCurrent();
        if (v51 >= 1)
        {
          v17 = Current;
          v18 = 0;
          AbsoluteTime = -1.0;
          while (1)
          {
            v20 = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v18);
            if (!v20)
              goto LABEL_55;
            v21 = v20;
            v22 = CFGetTypeID(v20);
            if (v22 != CFDictionaryGetTypeID())
              goto LABEL_55;
            v23 = (const __CFString *)CFDictionaryGetValue(v21, kSecAttrAccessible);
            if (v23)
            {
              if (CFStringCompare(v23, kSecAttrAccessibleAfterFirstUnlock, 0))
                v24 = kSecAttrAccessibleAlways;
              else
                v24 = kSecAttrAccessibleAfterFirstUnlock;
              CFDictionarySetValue(Mutable, kSecAttrAccessible, v24);
            }
            v25 = CFDictionaryGetValue(v21, kSecValueRef);
            if (!v25)
              goto LABEL_55;
            v26 = v25;
            v27 = (const __CFString *)CFDictionaryGetValue(v21, kSecAttrLabel);
            if (!v27)
              goto LABEL_55;
            v28 = v27;
            if (!CFStringHasPrefix(v27, CFSTR("Key ")))
              goto LABEL_55;
            if (!a1)
            {
              v29 = (const __CFDate *)CFDictionaryGetValue(v21, kSecAttrCreationDate);
              if (!v29 || v17 - CFDateGetAbsoluteTime(v29) > 1088640.0)
                goto LABEL_55;
            }
            MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, v28);
            if (!MutableCopy)
              goto LABEL_55;
            v31 = MutableCopy;
            CFStringTrim(MutableCopy, CFSTR("Key "));
            CFStringInsert(v31, 0, CFSTR("Certificate "));
            CFDictionarySetValue(Mutable, kSecAttrLabel, v31);
            CFRelease(v31);
            if (a1)
            {
              if (a1 != 1)
              {
                v13 = 4294899625;
                goto LABEL_60;
              }
              SecItemDelete(Mutable);
              goto LABEL_55;
            }
            *(_QWORD *)cf = 0;
            if (SecItemCopyMatching(Mutable, (CFTypeRef *)cf))
              break;
            if (!*(_QWORD *)cf)
              goto LABEL_58;
            v33 = CFGetTypeID(*(CFTypeRef *)cf);
            if (v33 != CFArrayGetTypeID())
              goto LABEL_58;
            v34 = CFArrayGetCount(*(CFArrayRef *)cf);
            if (!v34)
              goto LABEL_58;
            if (v34 != 1)
              break;
            v35 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)cf, 0);
            v32 = v35;
            if (v35)
            {
              v36 = CFGetTypeID(v35);
              if (v36 != CFDictionaryGetTypeID())
                break;
              v37 = (const __CFDate *)CFDictionaryGetValue(v32, kSecAttrCreationDate);
              if (!v37)
                break;
              v38 = v37;
              v39 = (const __CFDictionary *)CFDictionaryGetValue(v32, kSecValueRef);
              v32 = v39;
              if (v39)
              {
                CFRetain(v39);
                AbsoluteTime = CFDateGetAbsoluteTime(v38);
              }
            }
LABEL_52:
            if (*(_QWORD *)cf)
              CFRelease(*(CFTypeRef *)cf);
            if (v32)
            {
              if (AbsoluteTime >= 0.0)
              {
                v48 = SecIdentityCreate(kCFAllocatorDefault, v32, v26);
                v47 = 4294899624;
                if (v48)
                {
                  v47 = 0;
                  *v49 = v48;
                  *v50 = AbsoluteTime;
                }
              }
              else
              {
                v47 = 4294941996;
              }
              CFRelease(v32);
              v13 = v47;
              goto LABEL_60;
            }
LABEL_55:
            if (v51 == ++v18)
              goto LABEL_56;
          }
          v32 = 0;
          goto LABEL_52;
        }
LABEL_56:
        if (!a1)
        {
LABEL_59:
          v13 = 4294941996;
          goto LABEL_60;
        }
        keychain_key_remove();
LABEL_58:
        v13 = 0;
LABEL_60:
        CFRelease(v9);
        if (v52)
        {
          CFRelease(v52);
          v52 = 0;
        }
        v7 = v13;
      }
      else
      {
        v7 = 4294960567;
      }
    }
  }
  if (result)
  {
    CFRelease(result);
    result = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  if ((_DWORD)v7 == -25308)
  {
    v40 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "The device has to be unlocked since the last reboot to access keychain.", cf, 2u);
    }
  }
  return v7;
}

uint64_t dns_opt_parse(_QWORD *a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  unsigned int v8;
  _WORD *v9;
  _QWORD *v10;
  int v11;
  unsigned int v12;

  result = 0;
  v12 = 0;
  if (*(_WORD *)(a2 + 8) == 41)
  {
    v4 = *(unsigned __int16 *)(a2 + 24);
    if (*(_WORD *)(a2 + 24))
    {
      v5 = *(_QWORD *)(a2 + 16);
      while (1)
      {
        v11 = 0;
        if (!dns_u16_parse(v5, v4, &v12, (_WORD *)&v11 + 1))
          break;
        if (!dns_u16_parse(v5, v4, &v12, &v11))
          break;
        v6 = v12;
        v7 = (unsigned __int16)v11;
        v8 = v12 + (unsigned __int16)v11;
        if (v8 > v4)
          break;
        v9 = malloc_type_calloc(1uLL, (unsigned __int16)v11 + 16, 0x8544971uLL);
        if (!v9)
          break;
        v10 = v9;
        v9[4] = v7;
        v9[5] = HIWORD(v11);
        memcpy(v9 + 6, (const void *)(v5 + v6), v7);
        *a1 = v10;
        v12 = v8;
        a1 = v10;
        if (v8 >= v4)
          return 1;
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

BOOL dns_u16_parse(uint64_t a1, unsigned int a2, unsigned int *a3, _WORD *a4)
{
  uint64_t v5;
  unsigned int v6;
  __int16 v7;
  NSObject *v8;
  int v10;
  const char *v11;
  __int16 v12;
  unsigned int v13;
  __int16 v14;
  unsigned int v15;

  v5 = *a3;
  v6 = v5 + 2;
  if ((int)v5 + 2 > a2)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
    {
      v10 = 136446722;
      v11 = "dns_u16_parse";
      v12 = 1024;
      v13 = v6;
      v14 = 1024;
      v15 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%{public}s: dns_u16_parse: not enough room: %u > %u.\n", (uint8_t *)&v10, 0x18u);
    }
  }
  else
  {
    v7 = *(unsigned __int8 *)(a1 + (v5 + 1)) | (*(unsigned __int8 *)(a1 + v5) << 8);
    *a3 = v6;
    *a4 = v7;
  }
  return v6 <= a2;
}

uint64_t dns_name_parse_(void **a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int a5)
{
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v10;

  v10 = 0;
  v6 = dns_name_parse_in(&v10, a2, a3, a4, a5);
  v7 = v10;
  if ((v6 & 1) != 0)
  {
    *a1 = v10;
  }
  else if (v10)
  {
    do
    {
      v8 = (_QWORD *)*v7;
      free(v7);
      v7 = v8;
    }
    while (v8);
  }
  return v6;
}

uint64_t dns_name_parse_in(_QWORD *a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int a5)
{
  unsigned int v10;
  uint64_t result;
  size_t v12;
  int v13;
  unsigned int v14;
  char *v15;
  _QWORD *v16;
  char *v17;
  unsigned int v18;
  uint64_t v19;
  const char *v20;
  uint64_t v21;
  NSObject *v22;
  uint32_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  uint64_t v32;
  uint64_t v33;
  int v34;
  unsigned int v35;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  unsigned int v39;
  __int16 v40;
  unsigned int v41;
  __int16 v42;
  uint64_t v43;

  v10 = *a4;
  while (1)
  {
    result = v10 != (_DWORD)a3;
    if (v10 == (_DWORD)a3)
      return result;
    v12 = *(unsigned __int8 *)(a2 + v10);
    if (v12 >= 0xC0)
      break;
    if (v12 >= 0x40)
    {
      v21 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result)
        return result;
      *(_DWORD *)buf = 136446466;
      v37 = "dns_name_parse_in";
      v38 = 1024;
      v39 = v12;
      v20 = "%{public}s: invalid label type: %x\n";
LABEL_23:
      v22 = v21;
      v23 = 18;
      goto LABEL_24;
    }
    v13 = v12 + 1;
    v14 = v12 + 1 + v10;
    if (v14 > a3)
    {
      v19 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result)
        return result;
      *(_DWORD *)buf = 136446722;
      v37 = "dns_label_parse_";
      v38 = 1024;
      v39 = v14;
      v40 = 1024;
      v41 = a3;
      v20 = "%{public}s: claimed length of label is too long: %u > %u.\n";
LABEL_16:
      v22 = v19;
LABEL_17:
      v23 = 24;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, v20, buf, v23);
      return 0;
    }
    v15 = (char *)malloc_type_calloc(1uLL, v12 + 10, 0x26EAE9F4uLL);
    if (!v15)
    {
      v24 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (!(_DWORD)result)
        return result;
      v25 = v13 + *a4;
      v26 = a2 + *a4 + 1;
      *(_DWORD *)buf = 136446978;
      v37 = "dns_label_parse_";
      v38 = 1024;
      v39 = v25;
      v40 = 1040;
      v41 = v25;
      v42 = 2080;
      v43 = v26;
      v20 = "%{public}s: memory allocation for %u byte label (%.*s) failed.\n";
      v22 = v24;
      v23 = 34;
      goto LABEL_24;
    }
    v16 = v15;
    v15[8] = v12;
    v17 = v15 + 9;
    memcpy(v15 + 9, (const void *)(a2 + *a4 + 1), v12);
    v17[v12] = 0;
    v10 = v13 + *a4;
    *a4 = v10;
    *a1 = v16;
    a1 = v16;
    if (!(_DWORD)v12)
      return 1;
  }
  v18 = v10 + 2;
  if (v10 + 2 > a3)
  {
    v19 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)buf = 136446722;
    v37 = "dns_name_parse_in";
    v38 = 1024;
    v39 = v18;
    v40 = 1024;
    v41 = a3;
    v20 = "%{public}s: incomplete compression pointer: %u > %u";
    goto LABEL_16;
  }
  v27 = *(unsigned __int8 *)(a2 + v10 + 1) | ((v12 & 0x3F) << 8);
  *a4 = v18;
  v28 = v27 - 11;
  if (v27 <= 0xB)
  {
    v21 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)buf = 136446466;
    v37 = "dns_name_parse_in";
    v38 = 1024;
    v39 = v27;
    v20 = "%{public}s: compression pointer points into header: %u.\n";
    goto LABEL_23;
  }
  v29 = v27 - 12;
  v35 = v27 - 12;
  if (v27 - 12 >= a5)
  {
    v32 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if ((_DWORD)result)
    {
      *(_DWORD *)buf = 136446722;
      v37 = "dns_name_parse_in";
      v38 = 1024;
      v39 = v27 - 12;
      v40 = 1024;
      v41 = a5;
      v20 = "%{public}s: compression pointer points forward: %u >= %u.\n";
      goto LABEL_37;
    }
  }
  else
  {
    v30 = *(unsigned __int8 *)(a2 + v29);
    if (v30 >= 0x40)
    {
      v33 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        if (v28 >= a3)
          v34 = 255;
        else
          v34 = *(unsigned __int8 *)(a2 + v28);
        *(_DWORD *)buf = 136446978;
        v37 = "dns_name_parse_in";
        v38 = 1024;
        v39 = v27 - 12;
        v40 = 1024;
        v41 = v30;
        v42 = 1024;
        LODWORD(v43) = v34;
        v20 = "%{public}s: compression pointer points into pointer: %u %02x%02x.\n";
        v22 = v33;
        v23 = 30;
        goto LABEL_24;
      }
    }
    else
    {
      if (v29 + v30 < a5 && v29 + v30 < v18)
        return dns_name_parse_in(a1, a2, a3, &v35, v27 - 12);
      v32 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if ((_DWORD)result)
      {
        *(_DWORD *)buf = 136446722;
        v37 = "dns_name_parse_in";
        v38 = 1024;
        v39 = v27 - 12;
        v40 = 1024;
        v41 = v30;
        v20 = "%{public}s: compression pointer points to something that goes past current position: %u %u\n";
LABEL_37:
        v22 = v32;
        goto LABEL_17;
      }
    }
  }
  return result;
}

BOOL dns_u8_parse(uint64_t a1, unsigned int a2, unsigned int *a3, _BYTE *a4)
{
  uint64_t v5;
  unsigned int v6;
  char v7;
  NSObject *v8;
  int v10;
  const char *v11;
  __int16 v12;
  unsigned int v13;
  __int16 v14;
  unsigned int v15;

  v5 = *a3;
  v6 = v5 + 1;
  if ((int)v5 + 1 > a2)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
    {
      v10 = 136446722;
      v11 = "dns_u8_parse";
      v12 = 1024;
      v13 = v6;
      v14 = 1024;
      v15 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%{public}s: dns_u8_parse: not enough room: %u > %u.\n", (uint8_t *)&v10, 0x18u);
    }
  }
  else
  {
    v7 = *(_BYTE *)(a1 + v5);
    *a3 = v6;
    *a4 = v7;
  }
  return v6 <= a2;
}

BOOL dns_u32_parse(uint64_t a1, unsigned int a2, unsigned int *a3, int *a4)
{
  uint64_t v5;
  unsigned int v6;
  int v7;
  NSObject *v8;
  int v10;
  const char *v11;
  __int16 v12;
  unsigned int v13;
  __int16 v14;
  unsigned int v15;

  v5 = *a3;
  v6 = v5 + 4;
  if ((int)v5 + 4 > a2)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
    {
      v10 = 136446722;
      v11 = "dns_u32_parse";
      v12 = 1024;
      v13 = v6;
      v14 = 1024;
      v15 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%{public}s: dns_u32_parse: not enough room: %u > %u.\n", (uint8_t *)&v10, 0x18u);
    }
  }
  else
  {
    v7 = (*(unsigned __int8 *)(a1 + v5) << 24) | (*(unsigned __int8 *)(a1 + (v5 + 1)) << 16) | (*(unsigned __int8 *)(a1 + (v5 + 2)) << 8) | *(unsigned __int8 *)(a1 + (v5 + 3));
    *a3 = v6;
    *a4 = v7;
  }
  return v6 <= a2;
}

uint64_t dns_rdata_parse_data_(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, size_t size, int a6)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t result;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  unsigned int v14;
  size_t v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  void *v22;
  size_t v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unsigned int v37;

  v7 = *a3;
  v8 = a4 - v7;
  if (a4 >= v7)
  {
    v14 = size;
    switch(*(_WORD *)(a1 + 8))
    {
      case 1:
        if ((_DWORD)size == 4)
        {
          *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + v7);
LABEL_53:
          v24 = a4;
LABEL_54:
          *a3 = v24;
LABEL_55:
          v25 = *a3;
          if (*a3 == (_DWORD)a4)
            return 1;
          v26 = global_os_log;
          result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
          if ((_DWORD)result)
          {
            v27 = *(unsigned __int16 *)(a1 + 8);
            v30 = 136446978;
            v31 = "dns_rdata_parse_data_";
            v32 = 1024;
            v33 = v27;
            v34 = 1024;
            v35 = a4;
            v36 = 1024;
            v37 = v25;
            v11 = "%{public}s: dns_rdata_parse: parse for rrtype %d not fully contained: %u %u";
            v12 = v26;
            v13 = 30;
            break;
          }
          return result;
        }
        v28 = global_os_log;
        result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
        if (!(_DWORD)result)
          return result;
        v30 = 136446466;
        v31 = "dns_rdata_parse_data_";
        v32 = 1024;
        v33 = v14;
        v11 = "%{public}s: dns_rdata_parse: A rdlen is not 4: %u";
LABEL_67:
        v12 = v28;
        v13 = 18;
        break;
      case 2:
      case 5:
      case 0xC:
LABEL_20:
        if ((dns_name_parse_((void **)(a1 + 16), a2, a4, a3, v7) & 1) == 0)
          return 0;
        goto LABEL_55;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
LABEL_31:
        if (!(_DWORD)size)
          goto LABEL_34;
        result = (uint64_t)malloc_type_malloc(size, 0x408B67A7uLL);
        *(_QWORD *)(a1 + 16) = result;
        if (!result)
          return result;
        memcpy((void *)result, (const void *)(a2 + *a3), v14);
LABEL_34:
        *(_WORD *)(a1 + 24) = v14;
        goto LABEL_53;
      case 6:
        result = dns_name_parse_((void **)(a1 + 16), a2, a4, a3, v7);
        if (!(_DWORD)result)
          return result;
        result = dns_name_parse_((void **)(a1 + 24), a2, a4, a3, *a3);
        if (!(_DWORD)result)
          return result;
        result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 32));
        if (!(_DWORD)result)
          return result;
        result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 36));
        if (!(_DWORD)result)
          return result;
        result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 40));
        if (!(_DWORD)result)
          return result;
        result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 44));
        if (!(_DWORD)result)
          return result;
        if (dns_u32_parse(a2, a4, a3, (int *)(a1 + 48)))
          goto LABEL_55;
        return 0;
      default:
        switch(*(_WORD *)(a1 + 8))
        {
          case 0x18:
            *(_DWORD *)(a1 + 48) = a6;
            result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 16));
            if (!(_DWORD)result)
              return result;
            result = dns_u8_parse(a2, a4, a3, (_BYTE *)(a1 + 18));
            if (!(_DWORD)result)
              return result;
            result = dns_u8_parse(a2, a4, a3, (_BYTE *)(a1 + 19));
            if (!(_DWORD)result)
              return result;
            result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 20));
            if (!(_DWORD)result)
              return result;
            result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 24));
            if (!(_DWORD)result)
              return result;
            result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 28));
            if (!(_DWORD)result)
              return result;
            result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 32));
            if (!(_DWORD)result)
              return result;
            result = dns_name_parse_((void **)(a1 + 40), a2, a4, a3, *a3);
            if (!(_DWORD)result)
              return result;
            v18 = a4 - *a3;
            *(_DWORD *)(a1 + 52) = v18;
            result = (uint64_t)malloc_type_malloc(v18, 0xA58364E2uLL);
            *(_QWORD *)(a1 + 56) = result;
            if (!result)
              return result;
            memcpy((void *)result, (const void *)(a2 + *a3), *(unsigned int *)(a1 + 52));
            v19 = *(_DWORD *)(a1 + 52);
            goto LABEL_50;
          case 0x19:
            result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 16));
            if (!(_DWORD)result)
              return result;
            result = dns_u8_parse(a2, a4, a3, (_BYTE *)(a1 + 18));
            if (!(_DWORD)result)
              return result;
            result = dns_u8_parse(a2, a4, a3, (_BYTE *)(a1 + 19));
            if (!(_DWORD)result)
              return result;
            v23 = a4 - *a3;
            *(_DWORD *)(a1 + 20) = v23;
            result = (uint64_t)malloc_type_malloc(v23, 0x89A5FE76uLL);
            *(_QWORD *)(a1 + 24) = result;
            if (!result)
              return result;
            memcpy((void *)result, (const void *)(a2 + *a3), *(unsigned int *)(a1 + 20));
            v19 = *(_DWORD *)(a1 + 20);
LABEL_50:
            v24 = *a3 + v19;
            goto LABEL_54;
          case 0x1A:
          case 0x1B:
          case 0x1D:
          case 0x1E:
          case 0x1F:
          case 0x20:
            goto LABEL_31;
          case 0x1C:
            if ((_DWORD)size == 16)
            {
              *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + v7);
              goto LABEL_53;
            }
            v28 = global_os_log;
            result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
            if (!(_DWORD)result)
              return result;
            v30 = 136446466;
            v31 = "dns_rdata_parse_data_";
            v32 = 1024;
            v33 = v14;
            v11 = "%{public}s: dns_rdata_parse: AAAA rdlen is not 16: %u";
            goto LABEL_67;
          case 0x21:
            result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 24));
            if (!(_DWORD)result)
              return result;
            result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 26));
            if (!(_DWORD)result)
              return result;
            result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 28));
            if (!(_DWORD)result)
              return result;
            LODWORD(v7) = *a3;
            goto LABEL_20;
          default:
            if (*(_WORD *)(a1 + 8) != 16)
              goto LABEL_31;
            if (v8 != (_DWORD)size)
            {
              v20 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                v30 = 136446722;
                v31 = "dns_rdata_parse_data_";
                v32 = 1024;
                v33 = v14;
                v34 = 1024;
                v35 = v8;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: TXT record length %u doesn't match remaining space %d", (uint8_t *)&v30, 0x18u);
              }
            }
            if (v8 >= 0x100)
            {
              v21 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                v30 = 136446466;
                v31 = "dns_rdata_parse_data_";
                v32 = 1024;
                v33 = v8;
                _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: TXT record length %u is longer than 255", (uint8_t *)&v30, 0x12u);
              }
            }
            *(_BYTE *)(a1 + 16) = v8;
            v22 = malloc_type_malloc(v8, 0xBF0E72CEuLL);
            *(_QWORD *)(a1 + 24) = v22;
            if (v22)
            {
              memcpy(v22, (const void *)(a2 + *a3), *(unsigned __int8 *)(a1 + 16));
              goto LABEL_53;
            }
            v29 = global_os_log;
            result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
            if (!(_DWORD)result)
              return result;
            v30 = 136446210;
            v31 = "dns_rdata_parse_data_";
            v11 = "%{public}s: dns_rdata_parse: no memory for TXT RR";
            v12 = v29;
            v13 = 12;
            break;
        }
        break;
    }
  }
  else
  {
    v9 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if (!(_DWORD)result)
      return result;
    v30 = 136446722;
    v31 = "dns_rdata_parse_data_";
    v32 = 1024;
    v33 = a4;
    v34 = 1024;
    v35 = v7;
    v11 = "%{public}s: target %u < *offp %u";
    v12 = v9;
    v13 = 24;
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, v11, (uint8_t *)&v30, v13);
  return 0;
}

uint64_t dns_rr_parse_(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int *a4, int a5)
{
  unsigned int v7;
  int v10;
  uint64_t result;
  unsigned __int16 *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  int v16;
  const char *v17;
  unsigned int v18;
  uint8_t *v19;
  size_t v20;
  size_t v21;
  unint64_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  unint64_t v26;
  int v27;
  size_t v28;
  size_t v29;
  size_t v30;
  unint64_t v31;
  size_t v32;
  unsigned int v33;
  size_t v34;
  unint64_t v35;
  size_t v36;
  __int16 v37;
  NSObject *v38;
  char v39[1012];
  uint8_t buf[12];
  __int16 v41;
  int v42;
  __int16 v43;
  int v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  char *v48;
  __int16 v49;
  const char *v50;
  uint8_t v51[4];
  const char *v52;
  __int16 v53;
  uint8_t *v54;

  v7 = a3;
  v10 = *a4;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  result = dns_name_parse_((void **)a1, a2, a3, a4, *a4);
  if ((_DWORD)result)
  {
    v12 = (unsigned __int16 *)(a1 + 8);
    result = dns_u16_parse(a2, v7, a4, (_WORD *)(a1 + 8));
    if ((_DWORD)result)
    {
      result = dns_u16_parse(a2, v7, a4, (_WORD *)(a1 + 10));
      if ((_DWORD)result)
      {
        if (!a5)
          goto LABEL_70;
        result = dns_u32_parse(a2, v7, a4, (int *)(a1 + 12));
        if ((_DWORD)result)
        {
          *(_WORD *)buf = 0;
          if (!dns_u16_parse(a2, v7, a4, buf))
            return 0;
          v13 = *a4 + *(unsigned __int16 *)buf;
          if (v13 > v7)
            return 0;
          result = dns_rdata_parse_data_(a1, a2, a4, v13, *(unsigned __int16 *)buf, v10);
          if ((_DWORD)result)
          {
LABEL_70:
            if (*(_QWORD *)a1)
              dns_name_print_to_limit(*(uint64_t **)a1, 0, (uint64_t)v39, 0x3F2uLL);
            else
              strcpy(v39, "<null>");
            v14 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
            {
              v15 = *v12;
              v16 = *(unsigned __int16 *)(a1 + 10);
              v17 = (const char *)&unk_10007C3B5;
              *(_QWORD *)&buf[4] = "dns_rr_parse_";
              *(_DWORD *)buf = 136447491;
              if (a5)
                v17 = "  rrdata:";
              v41 = 1024;
              v42 = v15;
              v43 = 1024;
              v44 = v16;
              v45 = 2160;
              v46 = 1752392040;
              v47 = 2081;
              v48 = v39;
              v49 = 2082;
              v50 = v17;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "%{public}s: rrtype: %u  qclass: %u  name: %{private, mask.hash}s%{public}s", buf, 0x36u);
            }
            if (!a5)
              return 1;
            v18 = *v12;
            if (v18 > 0xB)
            {
              switch(*v12)
              {
                case 0x18u:
                  dns_name_print_to_limit(*(uint64_t **)(a1 + 40), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "SIG %d %d %d %lu %lu %lu %d %s", *(unsigned __int16 *)(a1 + 16), *(unsigned __int8 *)(a1 + 18), *(unsigned __int8 *)(a1 + 19), *(unsigned int *)(a1 + 20), *(unsigned int *)(a1 + 24), *(unsigned int *)(a1 + 28), *(unsigned __int16 *)(a1 + 32), (const char *)v51);
                  v20 = strlen((const char *)buf);
                  v19 = &buf[v20];
                  v21 = 2048 - v20;
                  if (*(_DWORD *)(a1 + 52))
                  {
                    v22 = 0;
                    do
                    {
                      if (v22)
                        snprintf((char *)v19, v21, " %02x");
                      else
                        snprintf((char *)v19, v21, "%d [%02x");
                      v23 = strlen((const char *)v19);
                      v19 += v23;
                      v21 -= v23;
                      ++v22;
                    }
                    while (v22 < *(unsigned int *)(a1 + 52));
                  }
                  goto LABEL_54;
                case 0x19u:
                  v33 = *(unsigned __int16 *)(a1 + 16);
                  snprintf((char *)buf, 0x800uLL, "KEY <AC %d> <Z %d> <XT %d> <ZZ %d> <NAMTYPE %d> <ZZZZ %d> <ORY %d> %d %d ", v33 >> 14, (v33 >> 13) & 1, (v33 >> 12) & 1, (v33 >> 10) & 3, (v33 >> 8) & 3, v33 >> 4, v33 & 0xF, *(unsigned __int8 *)(a1 + 18), *(unsigned __int8 *)(a1 + 19));
                  v34 = strlen((const char *)buf);
                  v19 = &buf[v34];
                  v21 = 2048 - v34;
                  if (*(_DWORD *)(a1 + 20))
                  {
                    v35 = 0;
                    do
                    {
                      if (v35)
                        snprintf((char *)v19, v21, " %02x");
                      else
                        snprintf((char *)v19, v21, "%d [%02x");
                      v36 = strlen((const char *)v19);
                      v19 += v36;
                      v21 -= v36;
                      ++v35;
                    }
                    while (v35 < *(unsigned int *)(a1 + 20));
                  }
LABEL_54:
                  if (v21 <= 1)
                    goto LABEL_60;
                  v37 = 93;
                  goto LABEL_66;
                case 0x1Au:
                case 0x1Bu:
                case 0x1Du:
                case 0x1Eu:
                case 0x1Fu:
                case 0x20u:
                  goto LABEL_44;
                case 0x1Cu:
                  inet_ntop(30, (const void *)(a1 + 16), (char *)v51, 0x2Eu);
                  snprintf((char *)buf, 0x800uLL, "AAAA %s");
                  goto LABEL_59;
                case 0x21u:
                  dns_name_print_to_limit(*(uint64_t **)(a1 + 16), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "SRV %d %d %d %s");
                  goto LABEL_59;
                default:
                  if (v18 == 12)
                  {
                    dns_name_print_to_limit(*(uint64_t **)(a1 + 16), 0, (uint64_t)v51, 0x3F2uLL);
                    snprintf((char *)buf, 0x800uLL, "PTR %s");
                    goto LABEL_59;
                  }
                  if (v18 != 16)
                    goto LABEL_44;
                  strcpy((char *)buf, "TXT ");
                  v24 = strlen((const char *)buf);
                  v19 = &buf[v24];
                  v25 = 2048 - v24;
                  if (*(_BYTE *)(a1 + 16))
                  {
                    v26 = 0;
                    do
                    {
                      v27 = *(char *)(*(_QWORD *)(a1 + 24) + v26);
                      if ((v27 & 0x80000000) == 0
                        && (_DefaultRuneLocale.__runetype[*(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + v26)] & 0x40000) != 0)
                      {
                        if (v25 >= 2)
                        {
                          *(_WORD *)v19++ = v27;
                          --v25;
                        }
                      }
                      else
                      {
                        snprintf((char *)v19, v25, "<%x>", *(unsigned __int8 *)(*(_QWORD *)(a1 + 24) + v26));
                        v28 = strlen((const char *)v19);
                        v19 += v28;
                        v25 -= v28;
                      }
                      ++v26;
                    }
                    while (v26 < *(unsigned __int8 *)(a1 + 16));
                  }
                  if (v25 > 1)
                  {
                    v37 = 34;
LABEL_66:
                    *(_WORD *)v19++ = v37;
                  }
                  break;
              }
              goto LABEL_60;
            }
            if (v18 == 1)
            {
              inet_ntop(2, (const void *)(a1 + 16), (char *)v51, 0x2Eu);
              snprintf((char *)buf, 0x800uLL, "A %s");
            }
            else
            {
              if (v18 != 5)
              {
                if (v18 == 6)
                {
                  dns_name_print_to_limit(*(uint64_t **)(a1 + 16), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "SOA %s", (const char *)v51);
                  dns_name_print_to_limit(*(uint64_t **)(a1 + 24), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "%s %u %d %d %d %d", (const char *)v51, *(_DWORD *)(a1 + 32), *(_DWORD *)(a1 + 36), *(_DWORD *)(a1 + 40), *(_DWORD *)(a1 + 44), *(_DWORD *)(a1 + 48));
                  v19 = &buf[strlen((const char *)buf)];
                }
                else
                {
LABEL_44:
                  snprintf((char *)buf, 0x800uLL, "<rrtype %d>:", *v12);
                  v29 = strlen((const char *)buf);
                  v19 = &buf[v29];
                  v30 = 2048 - v29;
                  if (*(_WORD *)(a1 + 24))
                  {
                    v31 = 0;
                    do
                    {
                      snprintf((char *)v19, v30, " %02x", *(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + v31));
                      v32 = strlen((const char *)v19);
                      v19 += v32;
                      v30 -= v32;
                      ++v31;
                    }
                    while (v31 < *(unsigned __int16 *)(a1 + 24));
                  }
                  else
                  {
                    snprintf((char *)&buf[v29], v30, " <none>");
                    v19 += strlen((const char *)v19);
                  }
                }
                goto LABEL_60;
              }
              dns_name_print_to_limit(*(uint64_t **)(a1 + 16), 0, (uint64_t)v51, 0x3F2uLL);
              snprintf((char *)buf, 0x800uLL, "CNAME %s");
            }
LABEL_59:
            v19 = &buf[strlen((const char *)buf)];
LABEL_60:
            *v19 = 0;
            v38 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)v51 = 136446466;
              v52 = "dns_rrdata_dump";
              v53 = 2082;
              v54 = buf;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "%{public}s: %{public}s", v51, 0x16u);
            }
            return 1;
          }
        }
      }
    }
  }
  return result;
}

void dns_rrdata_free(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;
  _QWORD *v5;
  _QWORD *v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;

  if (a1)
  {
    switch(*(_WORD *)(a1 + 8))
    {
      case 1:
        return;
      case 2:
      case 5:
      case 0xC:
LABEL_9:
        v5 = *(_QWORD **)(a1 + 16);
        do
        {
          if (!v5)
            break;
          v6 = (_QWORD *)*v5;
          free(v5);
          v5 = v6;
        }
        while (v6);
        goto LABEL_18;
      case 3:
      case 4:
      case 7:
      case 8:
      case 9:
      case 0xA:
      case 0xB:
LABEL_15:
        if (*(_WORD *)(a1 + 24))
        {
          v7 = *(void **)(a1 + 16);
          if (v7)
            free(v7);
        }
LABEL_18:
        *(_QWORD *)(a1 + 16) = 0;
        break;
      case 6:
        v8 = *(_QWORD **)(a1 + 16);
        if (v8)
        {
          do
          {
            v9 = (_QWORD *)*v8;
            free(v8);
            v8 = v9;
          }
          while (v9);
        }
        v10 = *(_QWORD **)(a1 + 24);
        if (v10)
        {
          do
          {
            v11 = (_QWORD *)*v10;
            free(v10);
            v10 = v11;
          }
          while (v11);
        }
        break;
      default:
        switch(*(_WORD *)(a1 + 8))
        {
          case 0x18:
            v2 = *(_QWORD **)(a1 + 40);
            do
            {
              if (!v2)
                break;
              v3 = (_QWORD *)*v2;
              free(v2);
              v2 = v3;
            }
            while (v3);
            v4 = *(void **)(a1 + 56);
            goto LABEL_26;
          case 0x19:
            v4 = *(void **)(a1 + 24);
LABEL_26:
            free(v4);
            break;
          case 0x1A:
          case 0x1B:
          case 0x1D:
          case 0x1E:
          case 0x1F:
          case 0x20:
            goto LABEL_15;
          case 0x1C:
            return;
          case 0x21:
            goto LABEL_9;
          default:
            if (*(_WORD *)(a1 + 8) != 16)
              goto LABEL_15;
            free(*(void **)(a1 + 24));
            *(_QWORD *)(a1 + 24) = 0;
            break;
        }
        break;
    }
  }
}

void dns_message_free(_QWORD *a1)
{
  void *v2;
  unint64_t v3;
  unint64_t i;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  void *v8;
  unint64_t v9;
  unint64_t j;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  unint64_t v15;
  unint64_t k;
  uint64_t v17;
  _QWORD *v18;
  _QWORD *v19;
  void *v20;
  unint64_t v21;
  unint64_t m;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;

  v2 = (void *)a1[3];
  if (v2)
  {
    v3 = *((unsigned int *)a1 + 1);
    if ((_DWORD)v3)
    {
      for (i = 0; i < v3; ++i)
      {
        v5 = a1[3] + (i << 6);
        if (*(_WORD *)(v5 + 8))
        {
          v6 = *(_QWORD **)v5;
          if (*(_QWORD *)v5)
          {
            do
            {
              v7 = (_QWORD *)*v6;
              free(v6);
              v6 = v7;
            }
            while (v7);
          }
          dns_rrdata_free(v5);
          v3 = *((unsigned int *)a1 + 1);
        }
      }
      v2 = (void *)a1[3];
    }
    free(v2);
  }
  v8 = (void *)a1[4];
  if (v8)
  {
    v9 = *((unsigned int *)a1 + 2);
    if ((_DWORD)v9)
    {
      for (j = 0; j < v9; ++j)
      {
        v11 = a1[4] + (j << 6);
        if (*(_WORD *)(v11 + 8))
        {
          v12 = *(_QWORD **)v11;
          if (*(_QWORD *)v11)
          {
            do
            {
              v13 = (_QWORD *)*v12;
              free(v12);
              v12 = v13;
            }
            while (v13);
          }
          dns_rrdata_free(v11);
          v9 = *((unsigned int *)a1 + 2);
        }
      }
      v8 = (void *)a1[4];
    }
    free(v8);
  }
  v14 = (void *)a1[5];
  if (v14)
  {
    v15 = *((unsigned int *)a1 + 3);
    if ((_DWORD)v15)
    {
      for (k = 0; k < v15; ++k)
      {
        v17 = a1[5] + (k << 6);
        if (*(_WORD *)(v17 + 8))
        {
          v18 = *(_QWORD **)v17;
          if (*(_QWORD *)v17)
          {
            do
            {
              v19 = (_QWORD *)*v18;
              free(v18);
              v18 = v19;
            }
            while (v19);
          }
          dns_rrdata_free(v17);
          v15 = *((unsigned int *)a1 + 3);
        }
      }
      v14 = (void *)a1[5];
    }
    free(v14);
  }
  v20 = (void *)a1[6];
  if (v20)
  {
    v21 = *((unsigned int *)a1 + 4);
    if ((_DWORD)v21)
    {
      for (m = 0; m < v21; ++m)
      {
        v23 = a1[6] + (m << 6);
        if (*(_WORD *)(v23 + 8))
        {
          v24 = *(_QWORD **)v23;
          if (*(_QWORD *)v23)
          {
            do
            {
              v25 = (_QWORD *)*v24;
              free(v24);
              v24 = v25;
            }
            while (v25);
          }
          dns_rrdata_free(v23);
          v21 = *((unsigned int *)a1 + 4);
        }
      }
      v20 = (void *)a1[6];
    }
    free(v20);
  }
  v26 = (_QWORD *)a1[7];
  if (v26)
  {
    do
    {
      v27 = (_QWORD *)*v26;
      free(v26);
      v26 = v27;
    }
    while (v27);
  }
  free(a1);
}

uint64_t dns_wire_parse_(uint64_t *a1, unsigned __int16 *a2, unsigned int a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v7;
  unsigned int v8;
  NSObject *v9;
  void *v10;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  NSObject *v14;
  void *v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  void *v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  NSObject *v26;
  void *v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint8_t buf[4];
  const char *v37;
  __int16 v38;
  const char *v39;
  __int16 v40;
  unsigned int v41;

  result = 0;
  v35 = 0;
  v5 = a3 - 12;
  if (a3 >= 0xC)
  {
    result = (uint64_t)malloc_type_calloc(1uLL, 0x40uLL, 0x1020040822CA6C9uLL);
    if (result)
    {
      v7 = result;
      v8 = bswap32(a2[2]) >> 16;
      *(_DWORD *)(result + 4) = v8;
      if (v8 >= 0x33)
      {
        *(_DWORD *)(result + 4) = 0;
LABEL_37:
        dns_message_free((_QWORD *)v7);
        return 0;
      }
      v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v37 = "dns_wire_parse_";
        v38 = 2080;
        v39 = "question";
        v40 = 1024;
        v41 = v8;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
        v8 = *(_DWORD *)(v7 + 4);
      }
      if (!v8)
        goto LABEL_13;
      v10 = malloc_type_calloc(v8, 0x40uLL, 0x1032040A90C5805uLL);
      *(_QWORD *)(v7 + 24) = v10;
      if (!v10)
        goto LABEL_37;
      if (*(_DWORD *)(v7 + 4))
      {
        v11 = 0;
        v12 = 0;
        while ((dns_rr_parse_(*(_QWORD *)(v7 + 24) + v11, (uint64_t)(a2 + 6), v5, &v35, 0) & 1) != 0)
        {
          ++v12;
          v11 += 64;
          if (v12 >= *(unsigned int *)(v7 + 4))
            goto LABEL_13;
        }
        dns_message_free((_QWORD *)v7);
        v19 = global_os_log;
        result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if ((_DWORD)result)
        {
          *(_DWORD *)buf = 136446466;
          v37 = "dns_wire_parse_";
          v38 = 1024;
          LODWORD(v39) = v12;
          v20 = "%{public}s: question %d RR parse failed.\n";
          goto LABEL_61;
        }
      }
      else
      {
LABEL_13:
        v13 = bswap32(a2[3]) >> 16;
        *(_DWORD *)(v7 + 8) = v13;
        if (v13 >= 0x33)
        {
          *(_DWORD *)(v7 + 8) = 0;
          goto LABEL_37;
        }
        v14 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          v37 = "dns_wire_parse_";
          v38 = 2080;
          v39 = "answers";
          v40 = 1024;
          v41 = v13;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
          v13 = *(_DWORD *)(v7 + 8);
        }
        if (!v13)
          goto LABEL_23;
        v15 = malloc_type_calloc(v13, 0x40uLL, 0x1032040A90C5805uLL);
        *(_QWORD *)(v7 + 32) = v15;
        if (!v15)
          goto LABEL_37;
        if (*(_DWORD *)(v7 + 8))
        {
          v16 = 0;
          v17 = 0;
          while ((dns_rr_parse_(*(_QWORD *)(v7 + 32) + v16, (uint64_t)(a2 + 6), v5, &v35, 1) & 1) != 0)
          {
            ++v17;
            v16 += 64;
            if (v17 >= *(unsigned int *)(v7 + 8))
              goto LABEL_23;
          }
          dns_message_free((_QWORD *)v7);
          v19 = global_os_log;
          result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
          if ((_DWORD)result)
          {
            *(_DWORD *)buf = 136446466;
            v37 = "dns_wire_parse_";
            v38 = 1024;
            LODWORD(v39) = v17;
            v20 = "%{public}s: answers %d RR parse failed.\n";
            goto LABEL_61;
          }
        }
        else
        {
LABEL_23:
          v18 = bswap32(a2[4]) >> 16;
          *(_DWORD *)(v7 + 12) = v18;
          if (v18 >= 0x33)
          {
            *(_DWORD *)(v7 + 12) = 0;
            goto LABEL_37;
          }
          v21 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            v37 = "dns_wire_parse_";
            v38 = 2080;
            v39 = "authority";
            v40 = 1024;
            v41 = v18;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
            v18 = *(_DWORD *)(v7 + 12);
          }
          if (!v18)
            goto LABEL_35;
          v22 = malloc_type_calloc(v18, 0x40uLL, 0x1032040A90C5805uLL);
          *(_QWORD *)(v7 + 40) = v22;
          if (!v22)
            goto LABEL_37;
          if (!*(_DWORD *)(v7 + 12))
          {
LABEL_35:
            v25 = bswap32(a2[5]) >> 16;
            *(_DWORD *)(v7 + 16) = v25;
            if (v25 >= 0x33)
            {
              *(_DWORD *)(v7 + 16) = 0;
              goto LABEL_37;
            }
            v26 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              v37 = "dns_wire_parse_";
              v38 = 2080;
              v39 = "additional";
              v40 = 1024;
              v41 = v25;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
              v25 = *(_DWORD *)(v7 + 16);
            }
            if (!v25)
              goto LABEL_56;
            v27 = malloc_type_calloc(v25, 0x40uLL, 0x1032040A90C5805uLL);
            *(_QWORD *)(v7 + 48) = v27;
            if (!v27)
              goto LABEL_37;
            if (!*(_DWORD *)(v7 + 16))
            {
LABEL_56:
              *a1 = v7;
              return 1;
            }
            v28 = 0;
            v29 = 0;
            v30 = (uint64_t)(a2 + 6);
            while ((dns_rr_parse_(*(_QWORD *)(v7 + 48) + v28, v30, v5, &v35, 1) & 1) != 0)
            {
              ++v29;
              v31 = *(unsigned int *)(v7 + 16);
              v28 += 64;
              if (v29 >= v31)
              {
                if (*(_DWORD *)(v7 + 16))
                {
                  v32 = 0;
                  v33 = 0;
                  do
                  {
                    v34 = *(_QWORD *)(v7 + 48) + v32;
                    if (*(_WORD *)(v34 + 8) == 41)
                    {
                      if (!dns_opt_parse((_QWORD *)(v7 + 56), v34))
                        goto LABEL_37;
                      v31 = *(unsigned int *)(v7 + 16);
                    }
                    ++v33;
                    v32 += 64;
                  }
                  while (v33 < v31);
                }
                goto LABEL_56;
              }
            }
            dns_message_free((_QWORD *)v7);
            v19 = global_os_log;
            result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
            if (!(_DWORD)result)
              return result;
            *(_DWORD *)buf = 136446466;
            v37 = "dns_wire_parse_";
            v38 = 1024;
            LODWORD(v39) = v29;
            v20 = "%{public}s: additional %d RR parse failed.\n";
LABEL_61:
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, 0x12u);
            return 0;
          }
          v23 = 0;
          v24 = 0;
          while ((dns_rr_parse_(*(_QWORD *)(v7 + 40) + v23, (uint64_t)(a2 + 6), v5, &v35, 1) & 1) != 0)
          {
            ++v24;
            v23 += 64;
            if (v24 >= *(unsigned int *)(v7 + 12))
              goto LABEL_35;
          }
          dns_message_free((_QWORD *)v7);
          v19 = global_os_log;
          result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
          if ((_DWORD)result)
          {
            *(_DWORD *)buf = 136446466;
            v37 = "dns_wire_parse_";
            v38 = 1024;
            LODWORD(v39) = v24;
            v20 = "%{public}s: authority %d RR parse failed.\n";
            goto LABEL_61;
          }
        }
      }
    }
  }
  return result;
}

uint64_t getipaddr(char *a1, const char *a2)
{
  char v4;
  uint64_t result;
  char v6;

  v4 = 2;
  result = inet_pton(2, a2, a1 + 4);
  if ((_DWORD)result)
  {
    v6 = 16;
  }
  else
  {
    v4 = 30;
    result = inet_pton(30, a2, a1 + 8);
    if (!(_DWORD)result)
      return result;
    v6 = 28;
  }
  a1[1] = v4;
  *a1 = v6;
  return result;
}

void ioloop_wakeup_release_(_QWORD *a1, char *a2, int a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  if (!a1)
    return;
  v6 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "ioloop_wakeup_release_";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "wakeup";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "ioloop_wakeup_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "wakeup";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "ioloop_wakeup_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "wakeup";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v6 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v6 - 1;
  if (v6 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      v11 = 136447234;
      v12 = "ioloop_wakeup_release_";
      v13 = 2048;
      *(_QWORD *)v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "wakeup";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++wakeup_finalized;
    wakeup_finalize(a1);
  }
}

void wakeup_finalize(_QWORD *a1)
{
  NSObject *v2;
  uint64_t v3;
  void (*v4)(void);
  BOOL v5;

  if (!*(_DWORD *)a1)
  {
    v2 = a1[5];
    if (v2)
    {
      dispatch_release(v2);
      a1[5] = 0;
    }
    v3 = a1[2];
    v4 = (void (*)(void))a1[4];
    a1[4] = 0;
    a1[2] = 0;
    if (v4)
      v5 = v3 == 0;
    else
      v5 = 1;
    if (!v5)
      v4();
    free(a1);
  }
}

int *ioloop_wakeup_create_(char *a1, int a2)
{
  int *v4;
  NSObject *v5;
  int v6;
  int v7;
  NSObject *v8;
  char *v9;
  int v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  int v23;

  v4 = (int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A00405AB591E4uLL);
  if (v4)
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *v4;
      *(_DWORD *)buf = 136447490;
      v13 = "ioloop_wakeup_create_";
      v14 = 1024;
      v15 = v6;
      v16 = 2048;
      v17 = v4;
      v18 = 2080;
      v19 = "ret";
      v20 = 2080;
      v21 = strrchr(a1, 47) + 1;
      v22 = 1024;
      v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*v4)
    {
      v7 = *v4 + 1;
      *v4 = v7;
      if (v7 >= 10001)
      {
        v11 = v7;
        v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v9 = strrchr(a1, 47);
          *(_DWORD *)buf = 136447490;
          v13 = "ioloop_wakeup_create_";
          v14 = 1024;
          v15 = v11;
          v16 = 2048;
          v17 = v4;
          v18 = 2080;
          v19 = "ret";
          v20 = 2080;
          v21 = v9 + 1;
          v22 = 1024;
          v23 = a2;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++wakeup_created;
      *v4 = 1;
    }
  }
  return v4;
}

BOOL ioloop_add_wake_event(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  unsigned int v5;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  uint64_t v13;
  dispatch_time_t v14;
  _BOOL8 result;
  NSObject *v16;
  const char *v17;
  int v18;
  const char *v19;
  __int16 v20;
  int v21;

  if (!a3)
  {
    v16 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v18 = 136446210;
    v19 = "ioloop_add_wake_event";
    v17 = "%{public}s: ioloop_add_wake_event called with null callback";
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v18, 0xCu);
    return 0;
  }
  v5 = a5;
  if ((a5 & 0x80000000) != 0)
  {
    v16 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v18 = 136446210;
    v19 = "ioloop_add_wake_event";
    v17 = "%{public}s: ioloop_add_wake_event called with negative timeout";
    goto LABEL_17;
  }
  if (*(_QWORD *)(a1 + 40))
    ioloop_cancel_wake_event(a1);
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = a4;
  v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)ioloop_main_queue);
  *(_QWORD *)(a1 + 40) = v10;
  if (!v10)
  {
    v16 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v18 = 136446210;
    v19 = "ioloop_add_wake_event";
    v17 = "%{public}s: dispatch_source_create failed in ioloop_add_wake_event().";
    goto LABEL_17;
  }
  dispatch_source_set_event_handler_f(v10, (dispatch_function_t)wakeup_event);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 40), (void *)a1);
  if (!v5)
  {
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v18 = 136446466;
      v19 = "ioloop_add_wake_event";
      v20 = 1024;
      v21 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_add_wake_event: milliseconds = %d", (uint8_t *)&v18, 0x12u);
    }
    v5 = 10;
  }
  v12 = *(NSObject **)(a1 + 40);
  v13 = 1000000 * v5;
  v14 = dispatch_time(0, v13);
  dispatch_source_set_timer(v12, v14, v13, 0x989680uLL);
  dispatch_resume(*(dispatch_object_t *)(a1 + 40));
  return 1;
}

uint64_t ioloop_cancel_wake_event(uint64_t result)
{
  uint64_t v1;
  NSObject *v2;
  uint64_t (*v3)(void);

  if (result)
  {
    v1 = result;
    v2 = *(NSObject **)(result + 40);
    if (v2)
    {
      dispatch_source_cancel(v2);
      dispatch_release(*(dispatch_object_t *)(v1 + 40));
      *(_QWORD *)(v1 + 40) = 0;
    }
    result = *(_QWORD *)(v1 + 16);
    if (result)
    {
      v3 = *(uint64_t (**)(void))(v1 + 32);
      *(_QWORD *)(v1 + 16) = 0;
      *(_QWORD *)(v1 + 32) = 0;
      if (v3)
        return v3();
    }
  }
  return result;
}

uint64_t wakeup_event(uint64_t a1)
{
  uint64_t v2;
  uint64_t result;
  BOOL v4;
  uint64_t (*v5)(uint64_t);

  v2 = *(_QWORD *)(a1 + 16);
  v5 = *(uint64_t (**)(uint64_t))(a1 + 32);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  ioloop_cancel_wake_event(a1);
  result = (*(uint64_t (**)(uint64_t))(a1 + 24))(v2);
  if (v2)
    v4 = v5 == 0;
  else
    v4 = 1;
  if (!v4)
    return v5(v2);
  return result;
}

void ioloop()
{
  dispatch_main();
}

void ioloop_comm_retain_(uint64_t a1, char *a2, int a3)
{
  NSObject *v6;
  int v7;
  int v8;
  int v9;
  NSObject *v10;
  char *v11;
  int v12;
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  int v24;

  if (a1)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)buf = 136447490;
      v14 = "ioloop_comm_retain_";
      v15 = 1024;
      v16 = v7;
      v17 = 2048;
      v18 = a1;
      v19 = 2080;
      v20 = "comm";
      v21 = 2080;
      v22 = strrchr(a2, 47) + 1;
      v23 = 1024;
      v24 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v8 = *(_DWORD *)(a1 + 32);
    if (v8)
    {
      v9 = v8 + 1;
      *(_DWORD *)(a1 + 32) = v9;
      if (v9 >= 10001)
      {
        v12 = v9;
        v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v11 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          v14 = "ioloop_comm_retain_";
          v15 = 1024;
          v16 = v12;
          v17 = 2048;
          v18 = a1;
          v19 = 2080;
          v20 = "comm";
          v21 = 2080;
          v22 = v11 + 1;
          v23 = 1024;
          v24 = a3;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++comm_created;
      *(_DWORD *)(a1 + 32) = 1;
    }
  }
}

void ioloop_comm_release_(uint64_t a1, char *a2, int a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  if (!a1)
    return;
  v6 = *(_DWORD *)(a1 + 32);
  if (!v6)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "ioloop_comm_release_";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "comm";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "ioloop_comm_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "comm";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "ioloop_comm_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "comm";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v6 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v6 - 1;
  if (v6 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      v11 = 136447234;
      v12 = "ioloop_comm_release_";
      v13 = 2048;
      *(_QWORD *)v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "comm";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++comm_finalized;
    comm_finalize(a1);
  }
}

void comm_finalize(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  void *v4;
  NSObject *v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD *v11;
  int v12;
  NSObject *v13;
  void *v14;
  int *v15;
  void (*v16)(_QWORD);
  uint64_t v17;
  const char *v18;
  NSObject *v19;
  int v20;
  const char *v21;
  __int16 v22;
  _BYTE v23[34];
  __int16 v24;
  int v25;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v20 = 136446210;
    v21 = "comm_finalize";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%{public}s: comm_finalize", (uint8_t *)&v20, 0xCu);
  }
  if (*(_QWORD *)a1)
  {
    nw_release(*(void **)a1);
    ++nw_connection_finalized;
    *(_QWORD *)a1 = 0;
  }
  v3 = *(void **)(a1 + 8);
  if (v3)
  {
    nw_release(v3);
    ++nw_listener_finalized;
    *(_QWORD *)(a1 + 8) = 0;
  }
  v4 = *(void **)(a1 + 16);
  if (v4)
  {
    nw_release(v4);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v5 = *(NSObject **)(a1 + 48);
  if (v5)
  {
    dispatch_release(v5);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v6 = *(_QWORD *)(a1 + 24);
  if (v6)
  {
    v7 = *(_DWORD *)(v6 + 32);
    if (!v7)
    {
      v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_51;
      v20 = 136447490;
      v21 = "comm_finalize";
      v22 = 1024;
      *(_DWORD *)v23 = 0;
      *(_WORD *)&v23[4] = 2048;
      *(_QWORD *)&v23[6] = v6;
      *(_WORD *)&v23[14] = 2080;
      *(_QWORD *)&v23[16] = "comm->listener_state";
      *(_WORD *)&v23[24] = 2080;
      *(_QWORD *)&v23[26] = "macos-ioloop.c";
      v24 = 1024;
      v25 = 275;
      v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_46;
    }
    v8 = global_os_log;
    if (v7 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_51;
      v20 = 136447490;
      v21 = "comm_finalize";
      v22 = 1024;
      *(_DWORD *)v23 = v7;
      *(_WORD *)&v23[4] = 2048;
      *(_QWORD *)&v23[6] = v6;
      *(_WORD *)&v23[14] = 2080;
      *(_QWORD *)&v23[16] = "comm->listener_state";
      *(_WORD *)&v23[24] = 2080;
      *(_QWORD *)&v23[26] = "macos-ioloop.c";
      v24 = 1024;
      v25 = 275;
      v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_49:
      v19 = v8;
      goto LABEL_50;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v20 = 136447490;
      v21 = "comm_finalize";
      v22 = 1024;
      *(_DWORD *)v23 = v7;
      *(_WORD *)&v23[4] = 2048;
      *(_QWORD *)&v23[6] = v6;
      *(_WORD *)&v23[14] = 2080;
      *(_QWORD *)&v23[16] = "comm->listener_state";
      *(_WORD *)&v23[24] = 2080;
      *(_QWORD *)&v23[26] = "macos-ioloop.c";
      v24 = 1024;
      v25 = 275;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
      v6 = *(_QWORD *)(a1 + 24);
      v7 = *(_DWORD *)(v6 + 32);
    }
    *(_DWORD *)(v6 + 32) = v7 - 1;
    if (v7 == 1)
    {
      v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v20 = 136447234;
        v21 = "comm_finalize";
        v22 = 2048;
        *(_QWORD *)v23 = v6;
        *(_WORD *)&v23[8] = 2080;
        *(_QWORD *)&v23[10] = "comm->listener_state";
        *(_WORD *)&v23[18] = 2080;
        *(_QWORD *)&v23[20] = "macos-ioloop.c";
        *(_WORD *)&v23[28] = 1024;
        *(_DWORD *)&v23[30] = 275;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
        v6 = *(_QWORD *)(a1 + 24);
      }
      ++listener_finalized;
      listener_finalize((_QWORD *)v6);
    }
    *(_QWORD *)(a1 + 24) = 0;
  }
  if (*(int *)(a1 + 32) > 0)
    return;
  v10 = *(_QWORD *)(a1 + 40);
  if (v10)
  {
    ioloop_cancel_wake_event(v10);
    v11 = *(_QWORD **)(a1 + 40);
    if (v11)
    {
      v12 = *(_DWORD *)v11;
      if (*(_DWORD *)v11)
      {
        v8 = global_os_log;
        if (v12 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v20 = 136447490;
            v21 = "comm_finalize";
            v22 = 1024;
            *(_DWORD *)v23 = v12;
            *(_WORD *)&v23[4] = 2048;
            *(_QWORD *)&v23[6] = v11;
            *(_WORD *)&v23[14] = 2080;
            *(_QWORD *)&v23[16] = "comm->idle_timer";
            *(_WORD *)&v23[24] = 2080;
            *(_QWORD *)&v23[26] = "macos-ioloop.c";
            v24 = 1024;
            v25 = 296;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
            v11 = *(_QWORD **)(a1 + 40);
            v12 = *(_DWORD *)v11;
          }
          *(_DWORD *)v11 = v12 - 1;
          if (v12 == 1)
          {
            v13 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v20 = 136447234;
              v21 = "comm_finalize";
              v22 = 2048;
              *(_QWORD *)v23 = v11;
              *(_WORD *)&v23[8] = 2080;
              *(_QWORD *)&v23[10] = "comm->idle_timer";
              *(_WORD *)&v23[18] = 2080;
              *(_QWORD *)&v23[20] = "macos-ioloop.c";
              *(_WORD *)&v23[28] = 1024;
              *(_DWORD *)&v23[30] = 296;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
              v11 = *(_QWORD **)(a1 + 40);
            }
            ++wakeup_finalized;
            wakeup_finalize(v11);
          }
          goto LABEL_32;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_51:
          abort();
        v20 = 136447490;
        v21 = "comm_finalize";
        v22 = 1024;
        *(_DWORD *)v23 = v12;
        *(_WORD *)&v23[4] = 2048;
        *(_QWORD *)&v23[6] = v11;
        *(_WORD *)&v23[14] = 2080;
        *(_QWORD *)&v23[16] = "comm->idle_timer";
        *(_WORD *)&v23[24] = 2080;
        *(_QWORD *)&v23[26] = "macos-ioloop.c";
        v24 = 1024;
        v25 = 296;
        v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_49;
      }
      v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_51;
      v20 = 136447490;
      v21 = "comm_finalize";
      v22 = 1024;
      *(_DWORD *)v23 = 0;
      *(_WORD *)&v23[4] = 2048;
      *(_QWORD *)&v23[6] = v11;
      *(_WORD *)&v23[14] = 2080;
      *(_QWORD *)&v23[16] = "comm->idle_timer";
      *(_WORD *)&v23[24] = 2080;
      *(_QWORD *)&v23[26] = "macos-ioloop.c";
      v24 = 1024;
      v25 = 296;
      v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_46:
      v19 = v17;
LABEL_50:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v20, 0x36u);
      goto LABEL_51;
    }
  }
LABEL_32:
  v14 = *(void **)(a1 + 192);
  if (v14)
    free(v14);
  v15 = *(int **)(a1 + 408);
  if (v15)
    ifpermit_list_release_(v15, 303);
  v16 = *(void (**)(_QWORD))(a1 + 240);
  if (v16)
    v16(*(_QWORD *)(a1 + 200));
  free((void *)a1);
}

void listener_finalize(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  int *v6;
  void (*v7)(_QWORD);

  v2 = (void *)a1[1];
  if (v2)
  {
    nw_release(v2);
    ++nw_listener_finalized;
    a1[1] = 0;
  }
  v3 = (void *)a1[24];
  if (v3)
    free(v3);
  v4 = (void *)a1[2];
  if (v4)
    nw_release(v4);
  v5 = (void *)a1[21];
  if (v5)
    free(v5);
  v6 = (int *)a1[51];
  if (v6)
    ifpermit_list_release_(v6, 1100);
  v7 = (void (*)(_QWORD))a1[30];
  if (v7)
    v7(a1[25]);
  free(a1);
}

uint64_t ioloop_comm_cancel(uint64_t a1)
{
  NSObject *v2;
  NSObject *v3;
  uint64_t result;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  NSObject *v9;
  int v10;
  _QWORD block[5];
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  _BYTE v15[24];
  __int16 v16;
  char *v17;
  __int16 v18;
  int v19;

  v2 = *(NSObject **)a1;
  if (*(_QWORD *)a1)
  {
    v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      v13 = "ioloop_comm_cancel";
      v14 = 2048;
      *(_QWORD *)v15 = a1;
      *(_WORD *)&v15[8] = 2048;
      *(_QWORD *)&v15[10] = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: %p %p", buf, 0x20u);
      v2 = *(NSObject **)a1;
    }
    connection_cancel_(a1, v2, 331);
  }
  if ((*(_WORD *)(a1 + 416) & 0x20) == 0 && !*(_QWORD *)a1 && *(_DWORD *)(a1 + 148) != -1)
  {
    ioloop_close(a1 + 56);
    if (*(_QWORD *)(a1 + 248))
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_DWORD *)(a1 + 32);
        *(_DWORD *)buf = 136447490;
        v13 = "ioloop_comm_cancel";
        v14 = 1024;
        *(_DWORD *)v15 = v6;
        *(_WORD *)&v15[4] = 2048;
        *(_QWORD *)&v15[6] = a1;
        *(_WORD *)&v15[14] = 2080;
        *(_QWORD *)&v15[16] = "connection";
        v16 = 2080;
        v17 = "macos-ioloop.c";
        v18 = 1024;
        v19 = 343;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      v7 = *(_DWORD *)(a1 + 32);
      if (v7)
      {
        v8 = v7 + 1;
        *(_DWORD *)(a1 + 32) = v8;
        if (v8 >= 10001)
        {
          v10 = v8;
          v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v13 = "ioloop_comm_cancel";
            v14 = 1024;
            *(_DWORD *)v15 = v10;
            *(_WORD *)&v15[4] = 2048;
            *(_QWORD *)&v15[6] = a1;
            *(_WORD *)&v15[14] = 2080;
            *(_QWORD *)&v15[16] = "connection";
            v16 = 2080;
            v17 = "macos-ioloop.c";
            v18 = 1024;
            v19 = 343;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++listener_created;
        *(_DWORD *)(a1 + 32) = 1;
      }
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = __ioloop_comm_cancel_block_invoke;
      block[3] = &__block_descriptor_tmp_1086;
      block[4] = a1;
      dispatch_async((dispatch_queue_t)ioloop_main_queue, block);
    }
  }
  result = *(_QWORD *)(a1 + 40);
  if (result)
    return ioloop_cancel_wake_event(result);
  return result;
}

void connection_cancel_(uint64_t a1, NSObject *a2, int a3)
{
  NSObject *v6;
  _BOOL4 v7;
  const char *v8;
  __int16 v9;
  int v10;
  const char *v11;
  __int16 v12;
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  int v19;

  v6 = global_os_log;
  v7 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v7)
    {
      v8 = " (already canceled)";
      v9 = *(_WORD *)(a1 + 416);
      v11 = "connection_cancel_";
      v10 = 136447234;
      v12 = 2048;
      if ((v9 & 0x400) == 0)
        v8 = (const char *)&unk_10007C3B5;
      v13 = (const char *)a2;
      v14 = 2082;
      v15 = v8;
      v16 = 2082;
      v17 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c";
      v18 = 1024;
      v19 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %p: %{public}s %{public}s:%d", (uint8_t *)&v10, 0x30u);
    }
    if ((*(_WORD *)(a1 + 416) & 0x400) == 0)
    {
      nw_connection_cancel(a2);
      *(_WORD *)(a1 + 416) |= 0x400u;
    }
  }
  else if (v7)
  {
    v10 = 136446722;
    v11 = "connection_cancel_";
    v12 = 2082;
    v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c";
    v14 = 1024;
    LODWORD(v15) = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: null connection at %{public}s:%d", (uint8_t *)&v10, 0x1Cu);
  }
}

void ioloop_close(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint64_t v17;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_DWORD *)(a1 + 92);
    v4 = *(_QWORD *)(a1 + 72);
    v5 = *(_QWORD *)(a1 + 80);
    v8 = 136447234;
    v9 = "ioloop_close";
    v10 = 2048;
    v11 = a1;
    v12 = 1024;
    v13 = v3;
    v14 = 2048;
    v15 = v4;
    v16 = 2048;
    v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: io %p fd %d, read source %p, write_source %p", (uint8_t *)&v8, 0x30u);
  }
  v6 = *(NSObject **)(a1 + 72);
  if (v6)
    dispatch_source_cancel(v6);
  v7 = *(NSObject **)(a1 + 80);
  if (v7)
    dispatch_source_cancel(v7);
}

void __ioloop_comm_cancel_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(_QWORD, _QWORD);
  int v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void (**)(_QWORD, _QWORD))(v2 + 248);
  if (v3)
  {
    v3(*(_QWORD *)(a1 + 32), *(_QWORD *)(v2 + 200));
    v2 = *(_QWORD *)(a1 + 32);
    if (!v2)
      return;
  }
  v4 = *(_DWORD *)(v2 + 32);
  if (!v4)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_17;
    v10 = 136447490;
    v11 = "ioloop_comm_cancel_block_invoke";
    v12 = 1024;
    *(_DWORD *)v13 = 0;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = 348;
    v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    v9 = v7;
    goto LABEL_16;
  }
  v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_17;
    v10 = 136447490;
    v11 = "ioloop_comm_cancel_block_invoke";
    v12 = 1024;
    *(_DWORD *)v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = 348;
    v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    v9 = v5;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, v8, (uint8_t *)&v10, 0x36u);
LABEL_17:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136447490;
    v11 = "ioloop_comm_cancel_block_invoke";
    v12 = 1024;
    *(_DWORD *)v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = 348;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
    v2 = *(_QWORD *)(a1 + 32);
    v4 = *(_DWORD *)(v2 + 32);
  }
  *(_DWORD *)(v2 + 32) = v4 - 1;
  if (v4 == 1)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136447234;
      v11 = "ioloop_comm_cancel_block_invoke";
      v12 = 2048;
      *(_QWORD *)v13 = v2;
      *(_WORD *)&v13[8] = 2080;
      *(_QWORD *)&v13[10] = "connection";
      *(_WORD *)&v13[18] = 2080;
      *(_QWORD *)&v13[20] = "macos-ioloop.c";
      *(_WORD *)&v13[28] = 1024;
      *(_DWORD *)&v13[30] = 348;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
      v2 = *(_QWORD *)(a1 + 32);
    }
    ++listener_finalized;
    listener_finalize((_QWORD *)v2);
  }
}

void ioloop_message_retain_(int *a1, char *a2, int a3)
{
  NSObject *v6;
  int v7;
  int v8;
  NSObject *v9;
  char *v10;
  int v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  int *v17;
  __int16 v18;
  const char *v19;
  __int16 v20;
  char *v21;
  __int16 v22;
  int v23;

  if (a1)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *a1;
      *(_DWORD *)buf = 136447490;
      v13 = "ioloop_message_retain_";
      v14 = 1024;
      v15 = v7;
      v16 = 2048;
      v17 = a1;
      v18 = 2080;
      v19 = "message";
      v20 = 2080;
      v21 = strrchr(a2, 47) + 1;
      v22 = 1024;
      v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      v8 = *a1 + 1;
      *a1 = v8;
      if (v8 >= 10001)
      {
        v11 = v8;
        v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v10 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          v13 = "ioloop_message_retain_";
          v14 = 1024;
          v15 = v11;
          v16 = 2048;
          v17 = a1;
          v18 = 2080;
          v19 = "message";
          v20 = 2080;
          v21 = v10 + 1;
          v22 = 1024;
          v23 = a3;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++message_created;
      *a1 = 1;
    }
  }
}

void ioloop_message_release_(int *a1, char *a2, int a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  v6 = *a1;
  if (!*a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_15;
    v11 = 136447490;
    v12 = "ioloop_message_release_";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "message";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_14;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_15;
    v11 = 136447490;
    v12 = "ioloop_message_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "message";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_15:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "ioloop_message_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "message";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      v11 = 136447234;
      v12 = "ioloop_message_release_";
      v13 = 2048;
      *(_QWORD *)v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "message";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++message_finalized;
    free(a1);
  }
}

uint64_t ioloop_send_message(uint64_t a1, uint64_t a2, iovec *a3)
{
  uint64_t v5;
  int v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  dispatch_data_t concat;
  NSObject *v13;
  const char *v14;
  __int16 v15;
  _BOOL8 v16;
  NSObject *v17;
  const char *v18;
  __int128 *v19;
  size_t iov_len;
  int v21;
  uint64_t v22;
  _BOOL4 v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  const char *v27;
  unsigned int v29;
  const char *v30;
  ssize_t v31;
  NSObject *v32;
  int *v33;
  char *v34;
  NSObject *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  msghdr v44;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  _BYTE v52[14];
  __int16 v53;
  _BYTE v54[10];
  uint64_t v55;
  __int16 v56;
  _BYTE v57[6];
  _BYTE v58[10];
  uint64_t v59;
  __int16 v60;
  int v61;
  __int16 v62;
  uint64_t *v63;
  __int16 v64;
  unsigned int v65;
  __int16 v66;
  int v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  uint64_t v71;
  __int16 v72;
  int v73;
  __int16 v74;
  uint64_t *v75;
  __int16 v76;
  uint64_t v77;
  __int16 v78;
  int v79;
  __int16 v80;
  char *v81;
  __int16 v82;
  uint64_t v83;
  __int16 v84;
  int v85;
  __int16 v86;
  uint64_t *v87;
  __int16 v88;
  unsigned int v89;
  uint64_t buffer;
  int v91;
  __int128 v92;
  int v93;

  v5 = *(_QWORD *)a1;
  if ((*(_WORD *)(a1 + 416) & 0x20) != 0)
  {
    if (!v5)
    {
      v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)buf = 136446210;
      v46 = "ioloop_send_message_inner";
      v18 = "%{public}s: no connection";
      goto LABEL_38;
    }
  }
  else if (!v5)
  {
    if (*(_DWORD *)(a1 + 148) != -1)
    {
      v6 = *(_DWORD *)(a2 + 60);
      *(_QWORD *)&v44.msg_namelen = 0;
      *(&v44.msg_iovlen + 1) = 0;
      v44.msg_iov = a3;
      v44.msg_iovlen = 1;
      v44.msg_name = (void *)(a2 + 4);
      v44.msg_control = &buffer;
      *(_QWORD *)&v44.msg_controllen = 0;
      v7 = *(unsigned __int8 *)(a2 + 33);
      if (v7 == 30)
      {
        v44.msg_namelen = 28;
        v44.msg_controllen = 32;
        buffer = 0x2900000020;
        v91 = 46;
        v93 = v6;
        v92 = *(_OWORD *)(a2 + 40);
      }
      else
      {
        if (v7 != 2)
        {
          v35 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v46 = "ioloop_udp_send_message";
            v47 = 1024;
            LODWORD(v48) = v7;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%{public}s: unknown family %d", buf, 0x12u);
          }
          abort();
        }
        v44.msg_namelen = 16;
        v44.msg_controllen = 24;
        buffer = 24;
        v91 = 26;
        LODWORD(v92) = v6;
        DWORD1(v92) = *(_DWORD *)(a2 + 36);
        DWORD2(v92) = DWORD1(v92);
      }
      v19 = (__int128 *)(a2 + 32);
      iov_len = a3->iov_len;
      v40 = 0;
      v41 = 0;
      v43 = 0;
      v42 = 0;
      v36 = 0;
      v37 = 0;
      v39 = 0;
      v38 = 0;
      ioloop_normalize_address((uint64_t)&v40, (__int128 *)(a2 + 4));
      ioloop_normalize_address((uint64_t)&v36, v19);
      v21 = BYTE1(v40);
      v22 = global_os_log;
      v23 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      if (v21 == 2)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136448771;
          v46 = "ioloop_udp_send_message";
          v47 = 2048;
          v48 = iov_len;
          v49 = 2160;
          v50 = 1752392040;
          v51 = 1041;
          *(_DWORD *)v52 = 4;
          *(_WORD *)&v52[4] = 2097;
          *(_QWORD *)&v52[6] = (char *)&v36 + 4;
          v53 = 1024;
          *(_DWORD *)v54 = v6;
          *(_WORD *)&v54[4] = 1024;
          *(_DWORD *)&v54[6] = bswap32(WORD1(v36)) >> 16;
          strcpy((char *)&v55, "p\bhash");
          HIBYTE(v55) = 0;
          v56 = 0;
          *(_WORD *)v57 = 1041;
          *(_DWORD *)&v57[2] = 4;
          *(_WORD *)v58 = 2097;
          *(_QWORD *)&v58[2] = (char *)&v40 + 4;
          LOWORD(v59) = 1024;
          *(_DWORD *)((char *)&v59 + 2) = bswap32(WORD1(v40)) >> 16;
          v24 = "%{public}s: sending %zd byte UDP response from %{private, mask.hash, network:in_addr}.4P port %d index %"
                "d to %{private, mask.hash, network:in_addr}.4P#%d";
          v25 = v22;
          v26 = 92;
LABEL_55:
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
        }
      }
      else if (v23)
      {
        if ((v37 & 0xFE) == 0xFC)
        {
          v27 = "ULA: ";
        }
        else if (v37 == 254 && (BYTE1(v37) & 0xC0) == 0x80)
        {
          v27 = "LUA: ";
        }
        else if ((v37 & 0xE0) == 0x20)
        {
          v27 = "GUA: ";
        }
        else
        {
          v27 = (const char *)&unk_10007C3B5;
        }
        v29 = bswap32(WORD1(v36)) >> 16;
        if ((v41 & 0xFE) == 0xFC)
        {
          v30 = "ULA: ";
        }
        else if (v41 == 254 && (BYTE1(v41) & 0xC0) == 0x80)
        {
          v30 = "LUA: ";
        }
        else
        {
          v30 = (const char *)&unk_10007C3B5;
          if ((v41 & 0xE0) == 0x20)
            v30 = "GUA: ";
        }
        *(_DWORD *)buf = 136452355;
        v46 = "ioloop_udp_send_message";
        v47 = 2048;
        v48 = iov_len;
        v49 = 2082;
        v50 = (uint64_t)v27;
        v51 = 2160;
        *(_QWORD *)v52 = 1752392040;
        *(_WORD *)&v52[8] = 1041;
        *(_DWORD *)&v52[10] = 6;
        v53 = 2097;
        *(_QWORD *)v54 = &v37;
        *(_WORD *)&v54[8] = 2160;
        v55 = 1752392040;
        v56 = 1042;
        *(_DWORD *)v57 = 2;
        *(_WORD *)&v57[4] = 2098;
        *(_QWORD *)v58 = (char *)&v37 + 6;
        *(_WORD *)&v58[8] = 2160;
        v59 = 1752392040;
        v60 = 1041;
        v61 = 8;
        v62 = 2097;
        v63 = &v38;
        v64 = 1024;
        v65 = v29;
        v66 = 1024;
        v67 = v6;
        v68 = 2082;
        v69 = v30;
        v70 = 2160;
        v71 = 1752392040;
        v72 = 1041;
        v73 = 6;
        v74 = 2097;
        v75 = &v41;
        v76 = 2160;
        v77 = 1752392040;
        v78 = 1042;
        v79 = 2;
        v80 = 2098;
        v81 = (char *)&v41 + 6;
        v82 = 2160;
        v83 = 1752392040;
        v84 = 1041;
        v85 = 8;
        v86 = 2097;
        v87 = &v42;
        v88 = 1024;
        v89 = bswap32(WORD1(v40)) >> 16;
        v24 = "%{public}s: sending %zd byte UDP response from {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%"
              "{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} port %d index"
              " %d to {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment"
              "}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d";
        v25 = v22;
        v26 = 216;
        goto LABEL_55;
      }
      v31 = sendmsg(*(_DWORD *)(a1 + 148), &v44, 0);
      v16 = v31 >= 0;
      if (v31 < 0)
      {
        v32 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v33 = __error();
          v34 = strerror(*v33);
          *(_DWORD *)buf = 136446466;
          v46 = "ioloop_udp_send_message";
          v47 = 2080;
          v48 = (uint64_t)v34;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%{public}s: %s", buf, 0x16u);
        }
      }
      return v16;
    }
    return 0;
  }
  v8 = dispatch_data_create(a3->iov_base, a3->iov_len, (dispatch_queue_t)ioloop_main_queue, 0);
  if (!v8)
  {
    v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    v46 = "ioloop_send_message_inner";
    v18 = "%{public}s: ioloop_send_message: no memory.";
LABEL_38:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
    return 0;
  }
  v9 = v8;
  LOWORD(buffer) = a3->iov_len;
  if (!(_WORD)buffer)
  {
    dispatch_release(v8);
    v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    v46 = "ioloop_send_message_inner";
    v18 = "%{public}s: zero length";
    goto LABEL_38;
  }
  if ((*(_WORD *)(a1 + 416) & 0x20) == 0)
    goto LABEL_13;
  LOWORD(buffer) = bswap32((unsigned __int16)buffer) >> 16;
  v10 = dispatch_data_create(&buffer, 2uLL, (dispatch_queue_t)ioloop_main_queue, 0);
  if (!v10)
  {
    dispatch_release(v9);
    v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    v46 = "ioloop_send_message_inner";
    v18 = "%{public}s: no memory for new_data";
    goto LABEL_38;
  }
  v11 = v10;
  concat = dispatch_data_create_concat(v10, v9);
  dispatch_release(v9);
  dispatch_release(v11);
  v9 = concat;
  if (!concat)
  {
    v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    v46 = "ioloop_send_message_inner";
    v18 = "%{public}s: no memory for combined";
    goto LABEL_38;
  }
LABEL_13:
  if (*(_QWORD *)(a1 + 48))
  {
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v14 = *(const char **)(a1 + 192);
      if (!v14)
        v14 = "<null>";
      *(_DWORD *)buf = 136446723;
      v46 = "ioloop_send_message_inner";
      v47 = 2160;
      v48 = 1752392040;
      v49 = 2081;
      v50 = (uint64_t)v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: Dropping pending write on %{private, mask.hash}s", buf, 0x20u);
    }
  }
  *(_QWORD *)(a1 + 48) = v9;
  v15 = *(_WORD *)(a1 + 416);
  *(_WORD *)(a1 + 416) = v15 & 0xFFF7;
  if ((v15 & 4) != 0)
    connection_write_now(a1);
  return 1;
}

void connection_write_now(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  NSObject *v8;
  const nw_content_context_t *v9;
  NSObject *v10;
  int v11;
  _QWORD completion[5];
  uint8_t buf[4];
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  const char *v20;
  __int16 v21;
  char *v22;
  __int16 v23;
  int v24;

  ++*(_DWORD *)(a1 + 36);
  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)buf = 136447490;
    v14 = "connection_write_now";
    v15 = 1024;
    v16 = v3;
    v17 = 2048;
    v18 = a1;
    v19 = 2080;
    v20 = "connection";
    v21 = 2080;
    v22 = "macos-ioloop.c";
    v23 = 1024;
    v24 = 560;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    v5 = v4 + 1;
    *(_DWORD *)(a1 + 32) = v5;
    if (v5 >= 10001)
    {
      v11 = v5;
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v14 = "connection_write_now";
        v15 = 1024;
        v16 = v11;
        v17 = 2048;
        v18 = a1;
        v19 = 2080;
        v20 = "connection";
        v21 = 2080;
        v22 = "macos-ioloop.c";
        v23 = 1024;
        v24 = 560;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      abort();
    }
  }
  else
  {
    ++comm_created;
    *(_DWORD *)(a1 + 32) = 1;
  }
  v7 = *(NSObject **)a1;
  v8 = *(NSObject **)(a1 + 48);
  if ((*(_WORD *)(a1 + 416) & 8) != 0)
    v9 = &_nw_content_context_final_send;
  else
    v9 = &_nw_content_context_default_message;
  v10 = *v9;
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000;
  completion[2] = __connection_write_now_block_invoke;
  completion[3] = &__block_descriptor_tmp_45;
  completion[4] = a1;
  nw_connection_send(v7, v8, v10, 1, completion);
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
}

void __connection_write_now_block_invoke(uint64_t a1, NSObject *a2)
{
  NSObject *v4;
  int error_code;
  uint64_t v6;
  int v7;
  BOOL v8;
  int v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  int v17;
  const char *v18;
  __int16 v19;
  _BYTE v20[34];
  __int16 v21;
  int v22;

  if (a2)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      error_code = nw_error_get_error_code(a2);
      v17 = 136446466;
      v18 = "connection_write_now_block_invoke";
      v19 = 2082;
      *(_QWORD *)v20 = strerror(error_code);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_send_message: write failed: %{public}s", (uint8_t *)&v17, 0x16u);
    }
    connection_cancel_(*(_QWORD *)(a1 + 32), **(NSObject ***)(a1 + 32), 569);
  }
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(_DWORD *)(v6 + 36);
  v8 = __OFSUB__(v7, 1);
  v9 = v7 - 1;
  if (v9 < 0 != v8)
  {
    v10 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v17 = 136446210;
      v18 = "connection_write_now_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_send_message: write callback reached with no writes marked pending.", (uint8_t *)&v17, 0xCu);
      v6 = *(_QWORD *)(a1 + 32);
      if (!v6)
        return;
    }
  }
  else
  {
    *(_DWORD *)(v6 + 36) = v9;
  }
  v11 = *(_DWORD *)(v6 + 32);
  if (!v11)
  {
    v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_23;
    v17 = 136447490;
    v18 = "connection_write_now_block_invoke";
    v19 = 1024;
    *(_DWORD *)v20 = 0;
    *(_WORD *)&v20[4] = 2048;
    *(_QWORD *)&v20[6] = v6;
    *(_WORD *)&v20[14] = 2080;
    *(_QWORD *)&v20[16] = "connection";
    *(_WORD *)&v20[24] = 2080;
    *(_QWORD *)&v20[26] = "macos-ioloop.c";
    v21 = 1024;
    v22 = 576;
    v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    v16 = v14;
    goto LABEL_22;
  }
  v12 = global_os_log;
  if (v11 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_23;
    v17 = 136447490;
    v18 = "connection_write_now_block_invoke";
    v19 = 1024;
    *(_DWORD *)v20 = v11;
    *(_WORD *)&v20[4] = 2048;
    *(_QWORD *)&v20[6] = v6;
    *(_WORD *)&v20[14] = 2080;
    *(_QWORD *)&v20[16] = "connection";
    *(_WORD *)&v20[24] = 2080;
    *(_QWORD *)&v20[26] = "macos-ioloop.c";
    v21 = 1024;
    v22 = 576;
    v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    v16 = v12;
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, (uint8_t *)&v17, 0x36u);
LABEL_23:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v17 = 136447490;
    v18 = "connection_write_now_block_invoke";
    v19 = 1024;
    *(_DWORD *)v20 = v11;
    *(_WORD *)&v20[4] = 2048;
    *(_QWORD *)&v20[6] = v6;
    *(_WORD *)&v20[14] = 2080;
    *(_QWORD *)&v20[16] = "connection";
    *(_WORD *)&v20[24] = 2080;
    *(_QWORD *)&v20[26] = "macos-ioloop.c";
    v21 = 1024;
    v22 = 576;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
    v6 = *(_QWORD *)(a1 + 32);
    v11 = *(_DWORD *)(v6 + 32);
  }
  *(_DWORD *)(v6 + 32) = v11 - 1;
  if (v11 == 1)
  {
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v17 = 136447234;
      v18 = "connection_write_now_block_invoke";
      v19 = 2048;
      *(_QWORD *)v20 = v6;
      *(_WORD *)&v20[8] = 2080;
      *(_QWORD *)&v20[10] = "connection";
      *(_WORD *)&v20[18] = 2080;
      *(_QWORD *)&v20[20] = "macos-ioloop.c";
      *(_WORD *)&v20[28] = 1024;
      *(_DWORD *)&v20[30] = 576;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v17, 0x30u);
      v6 = *(_QWORD *)(a1 + 32);
    }
    ++comm_finalized;
    comm_finalize(v6);
  }
}

void ioloop_listener_permitted_interface_list_set(uint64_t a1, int *a2)
{
  int *v4;

  v4 = *(int **)(a1 + 408);
  if (v4)
    ifpermit_list_release_(v4, 977);
  *(_QWORD *)(a1 + 408) = a2;
  ifpermit_list_retain_(a2, 980);
}

void __ioloop_listener_cancel_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(_QWORD, _QWORD);
  int v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = *(_QWORD *)(a1 + 32);
  v3 = *(void (**)(_QWORD, _QWORD))(v2 + 248);
  if (v3)
  {
    v3(*(_QWORD *)(a1 + 32), *(_QWORD *)(v2 + 200));
    v2 = *(_QWORD *)(a1 + 32);
    if (!v2)
      return;
  }
  v4 = *(_DWORD *)(v2 + 32);
  if (!v4)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_17;
    v10 = 136447490;
    v11 = "ioloop_listener_cancel_block_invoke";
    v12 = 1024;
    *(_DWORD *)v13 = 0;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = 1156;
    v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    v9 = v7;
    goto LABEL_16;
  }
  v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_17;
    v10 = 136447490;
    v11 = "ioloop_listener_cancel_block_invoke";
    v12 = 1024;
    *(_DWORD *)v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = 1156;
    v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    v9 = v5;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, v8, (uint8_t *)&v10, 0x36u);
LABEL_17:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = 136447490;
    v11 = "ioloop_listener_cancel_block_invoke";
    v12 = 1024;
    *(_DWORD *)v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(_QWORD *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(_QWORD *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(_QWORD *)&v13[26] = "macos-ioloop.c";
    v14 = 1024;
    v15 = 1156;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
    v2 = *(_QWORD *)(a1 + 32);
    v4 = *(_DWORD *)(v2 + 32);
  }
  *(_DWORD *)(v2 + 32) = v4 - 1;
  if (v4 == 1)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v10 = 136447234;
      v11 = "ioloop_listener_cancel_block_invoke";
      v12 = 2048;
      *(_QWORD *)v13 = v2;
      *(_WORD *)&v13[8] = 2080;
      *(_QWORD *)&v13[10] = "connection";
      *(_WORD *)&v13[18] = 2080;
      *(_QWORD *)&v13[20] = "macos-ioloop.c";
      *(_WORD *)&v13[28] = 1024;
      *(_DWORD *)&v13[30] = 1156;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
      v2 = *(_QWORD *)(a1 + 32);
    }
    ++listener_finalized;
    listener_finalize((_QWORD *)v2);
  }
}

_DWORD *ioloop_listener_create(int a1, int a2, int a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, uint64_t a11)
{
  int v17;
  unsigned int v18;
  _DWORD *v19;
  _DWORD *v20;
  NSObject *v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  NSObject *v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  uint64_t v32;
  char *v33;
  __int16 v34;
  void *v35;
  const void *v36;
  int v37;
  NSObject *v38;
  NSObject *v39;
  unsigned __int8 v40;
  unsigned __int8 v41;
  _BYTE *v42;
  int v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  int v47;
  int v48;
  NSObject *v49;
  char *v50;
  const char *v51;
  int v52;
  int v53;
  uint64_t v54;
  int *v55;
  char *v56;
  const char *v57;
  uint64_t v58;
  int v59;
  const char *v60;
  uint64_t v61;
  NSObject *v62;
  int *v63;
  char *v64;
  size_t v65;
  int *v66;
  char *v67;
  nw_endpoint_t host;
  _QWORD *v69;
  NSObject *secure_tcp;
  NSObject *v71;
  NSObject *v72;
  NSObject *v73;
  NSObject *v74;
  int v75;
  int v76;
  int v77;
  NSObject *v78;
  int v79;
  NSObject *v80;
  int v81;
  int *v82;
  char *v83;
  NSObject *v84;
  int v85;
  int v86;
  NSObject *v87;
  _BOOL4 v88;
  int v89;
  const char *v90;
  int *v91;
  NSObject *v92;
  size_t v93;
  int v94;
  int *v95;
  char *v96;
  int v97;
  const char *v98;
  socklen_t v99;
  NSObject *v100;
  int v101;
  int v102;
  int v103;
  NSObject *v104;
  int v105;
  int v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  int *v110;
  char *v111;
  unsigned int v112;
  unsigned int v113;
  NSObject *v114;
  uint64_t v115;
  _BOOL4 v116;
  int *v117;
  char *v118;
  NSObject *v119;
  uint32_t v120;
  const char *v121;
  int *v122;
  char *v123;
  int v124;
  const char *v125;
  NSObject *v126;
  int v127;
  int *v128;
  char *v129;
  int v130;
  int *v132;
  char *v133;
  unsigned int v136;
  _QWORD v137[5];
  _QWORD handler[5];
  _QWORD configure_tls[5];
  int v140;
  size_t cnt;
  int *fds;
  socklen_t v143;
  sockaddr v144;
  uint64_t v145;
  int v146;
  int v147;
  int v148;
  char hostname[8];
  uint64_t v150;
  void (*v151)(uint64_t);
  void *v152;
  _DWORD *v153;
  char __str[10];
  uint8_t buf[4];
  const char *v156;
  __int16 v157;
  _BYTE v158[44];
  __int16 v159;
  int v160;
  __int16 v161;
  char *v162;
  __int16 v163;
  uint64_t v164;
  __int16 v165;
  int v166;
  __int16 v167;
  _DWORD *v168;
  __int16 v169;
  unsigned int v170;
  __int16 v171;
  char *v172;

  if (a4)
  {
    v17 = *(unsigned __int8 *)(a4 + 1);
    v18 = bswap32(*(unsigned __int16 *)(a4 + 2)) >> 16;
  }
  else
  {
    v17 = 0;
    v18 = 0;
  }
  if (!a6)
  {
    v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return 0;
    *(_DWORD *)buf = 136446210;
    v156 = "ioloop_listener_create";
    v29 = "%{public}s: ioloop_setup: no datagram callback provided.";
    v30 = v28;
    v31 = 12;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
    return 0;
  }
  snprintf(__str, 0xAuLL, "%d", v18);
  v19 = malloc_type_calloc(1uLL, 0x1A8uLL, 0x10B00402743B0D3uLL);
  if (!v19)
  {
    if (a4)
    {
      if (v17 == 30)
      {
        v58 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          return 0;
        v59 = *(unsigned __int8 *)(a4 + 8);
        if ((v59 & 0xFE) == 0xFC)
        {
          v60 = "ULA: ";
        }
        else if (v59 == 254 && (*(_BYTE *)(a4 + 9) & 0xC0) == 0x80)
        {
          v60 = "LUA: ";
        }
        else if ((v59 & 0xE0) == 0x20)
        {
          v60 = "GUA: ";
        }
        else
        {
          v60 = (const char *)&unk_10007C3B5;
        }
        *(_DWORD *)buf = 136449027;
        v156 = "ioloop_listener_create";
        v157 = 2082;
        *(_QWORD *)v158 = v60;
        *(_WORD *)&v158[8] = 2160;
        *(_QWORD *)&v158[10] = 1752392040;
        *(_WORD *)&v158[18] = 1041;
        *(_DWORD *)&v158[20] = 6;
        *(_WORD *)&v158[24] = 2097;
        *(_QWORD *)&v158[26] = a4 + 8;
        *(_WORD *)&v158[34] = 2160;
        *(_QWORD *)&v158[36] = 1752392040;
        v159 = 1042;
        v160 = 2;
        v161 = 2098;
        v162 = (char *)(a4 + 14);
        v163 = 2160;
        v164 = 1752392040;
        v165 = 1041;
        v166 = 8;
        v167 = 2097;
        v168 = (_DWORD *)(a4 + 16);
        v169 = 1024;
        v170 = v18;
        v29 = "%{public}s: No memory for listener on {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, "
              "mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d";
        v30 = v58;
        v31 = 106;
      }
      else if (v17 == 2)
      {
        v32 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          return 0;
        *(_DWORD *)buf = 136447235;
        v156 = "ioloop_listener_create";
        v157 = 2160;
        *(_QWORD *)v158 = 1752392040;
        *(_WORD *)&v158[8] = 1041;
        *(_DWORD *)&v158[10] = 4;
        *(_WORD *)&v158[14] = 2097;
        *(_QWORD *)&v158[16] = a4 + 4;
        *(_WORD *)&v158[24] = 1024;
        *(_DWORD *)&v158[26] = v18;
        v29 = "%{public}s: No memory for listener on %{private, mask.hash, network:in_addr}.4P#%d";
        v30 = v32;
        v31 = 44;
      }
      else
      {
        v61 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          return 0;
        *(_DWORD *)buf = 136446722;
        v156 = "ioloop_listener_create";
        v157 = 1024;
        *(_DWORD *)v158 = v17;
        *(_WORD *)&v158[4] = 1024;
        *(_DWORD *)&v158[6] = v18;
        v29 = "%{public}s: No memory for listener on <family address other than AF_INET or AF_INET6: %d>#%d";
        v30 = v61;
        v31 = 24;
      }
    }
    else
    {
      v44 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        return 0;
      *(_DWORD *)buf = 136446466;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = v18;
      v29 = "%{public}s: No memory for listener on <NULL>#%d";
      v30 = v44;
      v31 = 18;
    }
    goto LABEL_14;
  }
  v20 = v19;
  v136 = v18;
  v19[45] = ++cur_connection_serial;
  v21 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v22 = v20[8];
    *(_DWORD *)buf = 136447490;
    v156 = "ioloop_listener_create";
    v157 = 1024;
    *(_DWORD *)v158 = v22;
    *(_WORD *)&v158[4] = 2048;
    *(_QWORD *)&v158[6] = v20;
    *(_WORD *)&v158[14] = 2080;
    *(_QWORD *)&v158[16] = "listener";
    *(_WORD *)&v158[24] = 2080;
    *(_QWORD *)&v158[26] = "macos-ioloop.c";
    *(_WORD *)&v158[34] = 1024;
    *(_DWORD *)&v158[36] = 1583;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v23 = v20[8];
  if (v23)
  {
    v24 = v23 + 1;
    v20[8] = v23 + 1;
    v25 = v136;
    if (v23 + 1 >= 10001)
    {
      v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_271;
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = v24;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1583;
      v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
  }
  else
  {
    ++listener_created;
    v24 = 1;
    v20[8] = 1;
    v25 = v136;
  }
  v33 = strdup(a5);
  *((_QWORD *)v20 + 24) = v33;
  if (!v33)
  {
    v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v156 = "ioloop_listener_create";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%{public}s: no memory for listener name.", buf, 0xCu);
      v24 = v20[8];
    }
    if (!v24)
    {
      v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_271;
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = 0;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1587;
      v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    v26 = global_os_log;
    if (v24 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_271;
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = v24;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1587;
      v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = v24;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1587;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v24 = v20[8];
    }
    v20[8] = v24 - 1;
    if (v24 != 1)
      return 0;
    v39 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_230;
    *(_DWORD *)buf = 136447234;
    v156 = "ioloop_listener_create";
    v157 = 2048;
    *(_QWORD *)v158 = v20;
    *(_WORD *)&v158[8] = 2080;
    *(_QWORD *)&v158[10] = "listener";
    *(_WORD *)&v158[18] = 2080;
    *(_QWORD *)&v158[20] = "macos-ioloop.c";
    *(_WORD *)&v158[28] = 1024;
    *(_DWORD *)&v158[30] = 1587;
    goto LABEL_229;
  }
  *((_QWORD *)v20 + 32) = a8;
  *((_QWORD *)v20 + 25) = a11;
  if (a1)
    v34 = 288;
  else
    v34 = 256;
  *((_WORD *)v20 + 208) = v34 | v20[104] & 0xFEDF;
  if ((a1 & 1) == 0)
  {
    if (!a3)
      a5 = 0;
    v148 = a10;
    if (!a4 || (v40 = *(_BYTE *)(a4 + 1), (v41 = v40) == 0))
    {
      v40 = 0;
      v41 = 30;
    }
    v147 = 1;
    *(_QWORD *)&v144.sa_len = 0;
    *(_QWORD *)&v144.sa_data[6] = 0;
    v146 = 0;
    v145 = 0;
    v143 = 0;
    v42 = v20 + 72;
    v43 = v41;
    *((_BYTE *)v20 + 289) = v41;
    if (v41 == 2)
    {
      *v42 = 16;
    }
    else
    {
      *v42 = 28;
      if (v41 == 30)
      {
        v45 = 1;
        goto LABEL_52;
      }
    }
    v45 = 0;
LABEL_52:
    v46 = __rev16(v25);
    *((_WORD *)v20 + 145) = v46;
    v20[37] = -1;
    if (!a5)
    {
LABEL_58:
      v52 = socket(v43, 2, 17);
      v20[37] = v52;
      if (v52 < 0)
      {
        v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v63 = __error();
          v64 = strerror(*v63);
          *(_DWORD *)buf = 136446466;
          v156 = "ioloop_udp_listener_setup";
          v157 = 2080;
          *(_QWORD *)v158 = v64;
          v57 = "%{public}s: Can't get socket: %s";
          goto LABEL_220;
        }
LABEL_222:
        close(v20[37]);
        v20[37] = -1;
        v130 = v20[8];
        if (!v130)
        {
          v26 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_271;
          *(_DWORD *)buf = 136447490;
          v156 = "ioloop_udp_listener_setup";
          v157 = 1024;
          *(_DWORD *)v158 = 0;
          *(_WORD *)&v158[4] = 2048;
          *(_QWORD *)&v158[6] = v20;
          *(_WORD *)&v158[14] = 2080;
          *(_QWORD *)&v158[16] = "listener";
          *(_WORD *)&v158[24] = 2080;
          *(_QWORD *)&v158[26] = "macos-ioloop.c";
          *(_WORD *)&v158[34] = 1024;
          *(_DWORD *)&v158[36] = 1448;
          v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_270;
        }
        v26 = global_os_log;
        if (v130 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_271;
          *(_DWORD *)buf = 136447490;
          v156 = "ioloop_udp_listener_setup";
          v157 = 1024;
          *(_DWORD *)v158 = v130;
          *(_WORD *)&v158[4] = 2048;
          *(_QWORD *)&v158[6] = v20;
          *(_WORD *)&v158[14] = 2080;
          *(_QWORD *)&v158[16] = "listener";
          *(_WORD *)&v158[24] = 2080;
          *(_QWORD *)&v158[26] = "macos-ioloop.c";
          *(_WORD *)&v158[34] = 1024;
          *(_DWORD *)&v158[36] = 1448;
          v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_270;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v156 = "ioloop_udp_listener_setup";
          v157 = 1024;
          *(_DWORD *)v158 = v130;
          *(_WORD *)&v158[4] = 2048;
          *(_QWORD *)&v158[6] = v20;
          *(_WORD *)&v158[14] = 2080;
          *(_QWORD *)&v158[16] = "listener";
          *(_WORD *)&v158[24] = 2080;
          *(_QWORD *)&v158[26] = "macos-ioloop.c";
          *(_WORD *)&v158[34] = 1024;
          *(_DWORD *)&v158[36] = 1448;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v130 = v20[8];
        }
        v20[8] = v130 - 1;
        if (v130 != 1)
          return 0;
        v39 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_230;
        *(_DWORD *)buf = 136447234;
        v156 = "ioloop_udp_listener_setup";
        v157 = 2048;
        *(_QWORD *)v158 = v20;
        *(_WORD *)&v158[8] = 2080;
        *(_QWORD *)&v158[10] = "listener";
        *(_WORD *)&v158[18] = 2080;
        *(_QWORD *)&v158[20] = "macos-ioloop.c";
        *(_WORD *)&v158[28] = 1024;
        *(_DWORD *)&v158[30] = 1448;
        goto LABEL_229;
      }
      if (setsockopt(v52, 0xFFFF, 4, &v147, 4u) < 0)
      {
        v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v66 = __error();
          v67 = strerror(*v66);
          *(_DWORD *)buf = 136446466;
          v156 = "ioloop_udp_listener_setup";
          v157 = 2080;
          *(_QWORD *)v158 = v67;
          v57 = "%{public}s: SO_REUSEADDR failed: %s";
          goto LABEL_220;
        }
        goto LABEL_222;
      }
      if (setsockopt(v20[37], 0xFFFF, 512, &v147, 4u) < 0)
      {
        v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v82 = __error();
          v83 = strerror(*v82);
          *(_DWORD *)buf = 136446466;
          v156 = "ioloop_udp_listener_setup";
          v157 = 2080;
          *(_QWORD *)v158 = v83;
          v57 = "%{public}s: SO_REUSEPORT failed: %s";
          goto LABEL_220;
        }
        goto LABEL_222;
      }
      v140 = 160;
      v53 = v20[37];
      if (v45)
      {
        if (setsockopt(v53, 41, 36, &v140, 4u) < 0)
        {
          v54 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            v55 = __error();
            v56 = strerror(*v55);
            *(_DWORD *)buf = 136446466;
            v156 = "ioloop_udp_listener_setup";
            v157 = 2080;
            *(_QWORD *)v158 = v56;
            v57 = "%{public}s: IPV6_TCLASS failed: %s";
LABEL_220:
            v119 = v54;
            v120 = 22;
            goto LABEL_221;
          }
          goto LABEL_222;
        }
      }
      else if (setsockopt(v53, 0, 3, &v140, 4u) < 0)
      {
        v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v95 = __error();
          v96 = strerror(*v95);
          *(_DWORD *)buf = 136446466;
          v156 = "ioloop_udp_listener_setup";
          v157 = 2080;
          *(_QWORD *)v158 = v96;
          v57 = "%{public}s: IP_TOS failed: %s";
          goto LABEL_220;
        }
        goto LABEL_222;
      }
      if (v40 == 30)
      {
        v86 = setsockopt(v20[37], 41, 27, &v147, 4u);
        v87 = global_os_log;
        v88 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if (v86 < 0)
        {
          if (v88)
          {
            v97 = *((unsigned __int8 *)v20 + 296);
            if ((v97 & 0xFE) == 0xFC)
            {
              v98 = "ULA: ";
            }
            else if (v97 == 254 && (*((_BYTE *)v20 + 297) & 0xC0) == 0x80)
            {
              v98 = "LUA: ";
            }
            else if ((v97 & 0xE0) == 0x20)
            {
              v98 = "GUA: ";
            }
            else
            {
              v98 = (const char *)&unk_10007C3B5;
            }
            *(_DWORD *)buf = 136448771;
            v156 = "ioloop_udp_listener_setup";
            v157 = 2082;
            *(_QWORD *)v158 = v98;
            *(_WORD *)&v158[8] = 2160;
            *(_QWORD *)&v158[10] = 1752392040;
            *(_WORD *)&v158[18] = 1041;
            *(_DWORD *)&v158[20] = 6;
            *(_WORD *)&v158[24] = 2097;
            *(_QWORD *)&v158[26] = v20 + 74;
            *(_WORD *)&v158[34] = 2160;
            *(_QWORD *)&v158[36] = 1752392040;
            v159 = 1042;
            v160 = 2;
            v161 = 2098;
            v162 = (char *)v20 + 302;
            v163 = 2160;
            v164 = 1752392040;
            v165 = 1041;
            v166 = 8;
            v167 = 2097;
            v168 = v20 + 76;
            v57 = "%{public}s: Unable to set IPv6-only flag on UDP socket for {%{public}s%{private, mask.hash, srp:in6_ad"
                  "dr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
            v119 = v87;
            v120 = 100;
            goto LABEL_221;
          }
          goto LABEL_222;
        }
        v25 = v136;
        if (v88)
        {
          v89 = *((unsigned __int8 *)v20 + 296);
          if ((v89 & 0xFE) == 0xFC)
          {
            v90 = "ULA: ";
          }
          else if (v89 == 254 && (*((_BYTE *)v20 + 297) & 0xC0) == 0x80)
          {
            v90 = "LUA: ";
          }
          else if ((v89 & 0xE0) == 0x20)
          {
            v90 = "GUA: ";
          }
          else
          {
            v90 = (const char *)&unk_10007C3B5;
          }
          *(_DWORD *)buf = 136448771;
          v156 = "ioloop_udp_listener_setup";
          v157 = 2082;
          *(_QWORD *)v158 = v90;
          *(_WORD *)&v158[8] = 2160;
          *(_QWORD *)&v158[10] = 1752392040;
          *(_WORD *)&v158[18] = 1041;
          *(_DWORD *)&v158[20] = 6;
          *(_WORD *)&v158[24] = 2097;
          *(_QWORD *)&v158[26] = v20 + 74;
          *(_WORD *)&v158[34] = 2160;
          *(_QWORD *)&v158[36] = 1752392040;
          v159 = 1042;
          v160 = 2;
          v161 = 2098;
          v162 = (char *)v20 + 302;
          v163 = 2160;
          v164 = 1752392040;
          v165 = 1041;
          v166 = 8;
          v167 = 2097;
          v168 = v20 + 76;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "%{public}s: Successfully set IPv6-only flag on UDP socket for {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x64u);
        }
      }
      v99 = *((unsigned __int8 *)v20 + 288);
      v143 = v99;
      if (bind(v20[37], (const sockaddr *)v20 + 18, v99) < 0)
      {
        v115 = global_os_log;
        v116 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if (v40 != 2)
        {
          if (v116)
          {
            v124 = *((unsigned __int8 *)v20 + 296);
            if ((v124 & 0xFE) == 0xFC)
            {
              v125 = "ULA: ";
            }
            else if (v124 == 254 && (*((_BYTE *)v20 + 297) & 0xC0) == 0x80)
            {
              v125 = "LUA: ";
            }
            else if ((v124 & 0xE0) == 0x20)
            {
              v125 = "GUA: ";
            }
            else
            {
              v125 = (const char *)&unk_10007C3B5;
            }
            v132 = __error();
            v133 = strerror(*v132);
            *(_DWORD *)buf = 136449283;
            v156 = "ioloop_udp_listener_setup";
            v157 = 2082;
            *(_QWORD *)v158 = v125;
            *(_WORD *)&v158[8] = 2160;
            *(_QWORD *)&v158[10] = 1752392040;
            *(_WORD *)&v158[18] = 1041;
            *(_DWORD *)&v158[20] = 6;
            *(_WORD *)&v158[24] = 2097;
            *(_QWORD *)&v158[26] = v20 + 74;
            *(_WORD *)&v158[34] = 2160;
            *(_QWORD *)&v158[36] = 1752392040;
            v159 = 1042;
            v160 = 2;
            v161 = 2098;
            v162 = (char *)v20 + 302;
            v163 = 2160;
            v164 = 1752392040;
            v165 = 1041;
            v166 = 8;
            v167 = 2097;
            v168 = v20 + 76;
            v169 = 1024;
            v170 = v46;
            v171 = 2080;
            v172 = v133;
            v57 = "%{public}s: Can't bind to {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.has"
                  "h, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d: %s";
            v119 = v115;
            v120 = 116;
            goto LABEL_221;
          }
          goto LABEL_222;
        }
        if (!v116)
          goto LABEL_222;
        v117 = __error();
        v118 = strerror(*v117);
        *(_DWORD *)buf = 136447491;
        v156 = "ioloop_udp_listener_setup";
        v157 = 2160;
        *(_QWORD *)v158 = 1752392040;
        *(_WORD *)&v158[8] = 1041;
        *(_DWORD *)&v158[10] = 4;
        *(_WORD *)&v158[14] = 2097;
        *(_QWORD *)&v158[16] = v20 + 73;
        *(_WORD *)&v158[24] = 1024;
        *(_DWORD *)&v158[26] = v46;
        *(_WORD *)&v158[30] = 2080;
        *(_QWORD *)&v158[32] = v118;
        v57 = "%{public}s: Can't bind to %{private, mask.hash, network:in_addr}.4P#%d: %s";
        v119 = v115;
        v120 = 54;
        goto LABEL_221;
      }
      v94 = v20[37];
LABEL_170:
      if (fcntl(v94, 4, 4) < 0)
      {
        v108 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_222;
        v109 = *((_QWORD *)v20 + 24);
        v110 = __error();
        v111 = strerror(*v110);
        *(_DWORD *)buf = 136446722;
        v156 = "ioloop_udp_listener_setup";
        v157 = 2080;
        *(_QWORD *)v158 = v109;
        *(_WORD *)&v158[8] = 2080;
        *(_QWORD *)&v158[10] = v111;
        v57 = "%{public}s: %s: Can't set O_NONBLOCK: %s";
      }
      else
      {
        if (a5 || !v25)
        {
          v143 = 28;
          if (getsockname(v20[37], &v144, &v143) < 0)
          {
            v54 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              v128 = __error();
              v129 = strerror(*v128);
              *(_DWORD *)buf = 136446466;
              v156 = "ioloop_udp_listener_setup";
              v157 = 2080;
              *(_QWORD *)v158 = v129;
              v57 = "%{public}s: getsockname: %s";
              goto LABEL_220;
            }
            goto LABEL_222;
          }
          v112 = bswap32(*(unsigned __int16 *)v144.sa_data);
          v113 = HIWORD(v112);
          *((_WORD *)v20 + 80) = HIWORD(v112);
          if (a5)
          {
            if (v113 != v136)
            {
              v114 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446722;
                v156 = "ioloop_udp_listener_setup";
                v157 = 1024;
                *(_DWORD *)v158 = v136;
                *(_WORD *)&v158[4] = 1024;
                *(_DWORD *)&v158[6] = v113;
                _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "%{public}s: launchd port mismatch: %u %u", buf, 0x18u);
              }
            }
          }
        }
        else
        {
          *((_WORD *)v20 + 80) = v25;
        }
        v100 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v101 = *((unsigned __int16 *)v20 + 80);
          *(_DWORD *)buf = 136446466;
          v156 = "ioloop_udp_listener_setup";
          v157 = 1024;
          *(_DWORD *)v158 = v101;
          _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "%{public}s: port is %d", buf, 0x12u);
        }
        if (v148)
        {
          setsockopt(v20[37], 0, 25, &v148, 4u);
          setsockopt(v20[37], 41, 125, &v148, 4u);
        }
        if (v40 == 2)
          v102 = 0;
        else
          v102 = 41;
        if (v40 == 2)
          v103 = 26;
        else
          v103 = 61;
        if ((setsockopt(v20[37], v102, v103, &v147, 4u) & 0x80000000) == 0)
        {
          ioloop_add_reader(v20 + 14);
          v104 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v105 = v20[8];
            *(_DWORD *)buf = 136447490;
            v156 = "ioloop_udp_listener_setup";
            v157 = 1024;
            *(_DWORD *)v158 = v105;
            *(_WORD *)&v158[4] = 2048;
            *(_QWORD *)&v158[6] = v20;
            *(_WORD *)&v158[14] = 2080;
            *(_QWORD *)&v158[16] = "listener";
            *(_WORD *)&v158[24] = 2080;
            *(_QWORD *)&v158[26] = "macos-ioloop.c";
            *(_WORD *)&v158[34] = 1024;
            *(_DWORD *)&v158[36] = 1487;
            _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          v106 = v20[8];
          if (v106)
          {
            v107 = v106 + 1;
            v20[8] = v106 + 1;
            if (v106 + 1 >= 10001)
            {
              v26 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_271;
              *(_DWORD *)buf = 136447490;
              v156 = "ioloop_udp_listener_setup";
              v157 = 1024;
              *(_DWORD *)v158 = v107;
              *(_WORD *)&v158[4] = 2048;
              *(_QWORD *)&v158[6] = v20;
              *(_WORD *)&v158[14] = 2080;
              *(_QWORD *)&v158[16] = "listener";
              *(_WORD *)&v158[24] = 2080;
              *(_QWORD *)&v158[26] = "macos-ioloop.c";
              *(_WORD *)&v158[34] = 1024;
              *(_DWORD *)&v158[36] = 1487;
              v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_270;
            }
          }
          else
          {
            ++listener_created;
            v107 = 1;
            v20[8] = 1;
          }
          *((_BYTE *)v20 + 144) = 1;
          *((_QWORD *)v20 + 13) = ioloop_listener_context_release;
          *((_QWORD *)v20 + 14) = v20;
          if (*((_QWORD *)v20 + 32))
          {
            v126 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              v156 = "ioloop_udp_listener_setup";
              v157 = 1024;
              *(_DWORD *)v158 = v107;
              *(_WORD *)&v158[4] = 2048;
              *(_QWORD *)&v158[6] = v20;
              *(_WORD *)&v158[14] = 2080;
              *(_QWORD *)&v158[16] = "listener";
              *(_WORD *)&v158[24] = 2080;
              *(_QWORD *)&v158[26] = "macos-ioloop.c";
              *(_WORD *)&v158[34] = 1024;
              *(_DWORD *)&v158[36] = 1494;
              _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              v107 = v20[8];
            }
            if (v107)
            {
              v127 = v107 + 1;
              v20[8] = v127;
              if (v127 >= 10001)
              {
                v26 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  goto LABEL_271;
                *(_DWORD *)buf = 136447490;
                v156 = "ioloop_udp_listener_setup";
                v157 = 1024;
                *(_DWORD *)v158 = v127;
                *(_WORD *)&v158[4] = 2048;
                *(_QWORD *)&v158[6] = v20;
                *(_WORD *)&v158[14] = 2080;
                *(_QWORD *)&v158[16] = "listener";
                *(_WORD *)&v158[24] = 2080;
                *(_QWORD *)&v158[26] = "macos-ioloop.c";
                *(_WORD *)&v158[34] = 1024;
                *(_DWORD *)&v158[36] = 1494;
                v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_270;
              }
            }
            else
            {
              ++listener_created;
              v20[8] = 1;
            }
            *(_QWORD *)hostname = _NSConcreteStackBlock;
            v150 = 0x40000000;
            v151 = __ioloop_udp_listener_setup_block_invoke;
            v152 = &__block_descriptor_tmp_48;
            v153 = v20;
            dispatch_async((dispatch_queue_t)ioloop_main_queue, hostname);
          }
          *((_QWORD *)v20 + 26) = a6;
          *((_QWORD *)v20 + 30) = 0;
          *((_QWORD *)v20 + 31) = a7;
          *((_QWORD *)v20 + 28) = 0;
          return v20;
        }
        v108 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_222;
        if (v40 == 2)
          v121 = "IP_PKTINFO";
        else
          v121 = "IPV6_RECVPKTINFO";
        v122 = __error();
        v123 = strerror(*v122);
        *(_DWORD *)buf = 136446722;
        v156 = "ioloop_udp_listener_setup";
        v157 = 2080;
        *(_QWORD *)v158 = v121;
        *(_WORD *)&v158[8] = 2080;
        *(_QWORD *)&v158[10] = v123;
        v57 = "%{public}s: Can't set %s: %s.";
      }
      v119 = v108;
      v120 = 32;
LABEL_221:
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, v57, buf, v120);
      goto LABEL_222;
    }
    cnt = 0;
    fds = 0;
    v47 = launch_activate_socket(a5, &fds, &cnt);
    if (v47)
    {
      v48 = v47;
      v49 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
LABEL_57:
        v20[37] = -1;
        v25 = v136;
        goto LABEL_58;
      }
      v50 = strerror(v48);
      *(_DWORD *)buf = 136446722;
      v156 = "ioloop_udp_listener_setup";
      v157 = 2082;
      *(_QWORD *)v158 = a5;
      *(_WORD *)&v158[8] = 2082;
      *(_QWORD *)&v158[10] = v50;
      v51 = "%{public}s: launchd_activate_socket failed for %{public}s: %{public}s";
LABEL_56:
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, v51, buf, 0x20u);
      goto LABEL_57;
    }
    v65 = cnt;
    if (cnt == 1)
    {
      v91 = fds;
      v20[37] = *fds;
    }
    else
    {
      if (!cnt)
      {
        v49 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_57;
        *(_DWORD *)buf = 136446722;
        v156 = "ioloop_udp_listener_setup";
        v157 = 2082;
        *(_QWORD *)v158 = a5;
        *(_WORD *)&v158[8] = 2048;
        *(_QWORD *)&v158[10] = 0;
        v51 = "%{public}s: too few sockets returned from launchd_active_socket for %{public}s : %zd";
        goto LABEL_56;
      }
      v92 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)
        || (*(_DWORD *)buf = 136446722,
            v156 = "ioloop_udp_listener_setup",
            v157 = 2082,
            *(_QWORD *)v158 = a5,
            *(_WORD *)&v158[8] = 2048,
            *(_QWORD *)&v158[10] = v65,
            _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_FAULT, "%{public}s: too many sockets returned from launchd_active_socket for %{public}s : %zd", buf, 0x20u), cnt))
      {
        v93 = 0;
        do
          close(fds[v93++]);
        while (v93 < cnt);
      }
      v91 = fds;
      v25 = v136;
    }
    free(v91);
    v94 = v20[37];
    if (v94 != -1)
      goto LABEL_170;
    goto LABEL_58;
  }
  *((_QWORD *)v20 + 26) = a6;
  *((_QWORD *)v20 + 30) = 0;
  *((_QWORD *)v20 + 31) = a7;
  *((_QWORD *)v20 + 28) = 0;
  if (v25)
  {
    *((_WORD *)v20 + 80) = v25;
    if (a4 && v17)
    {
      v35 = &dnssd_client_states;
      if (v17 == 2)
      {
        v36 = (const void *)(a4 + 4);
        v37 = 2;
      }
      else
      {
        v36 = (const void *)(a4 + 8);
        v37 = v17;
      }
      inet_ntop(v37, v36, hostname, 0x2Eu);
    }
    else
    {
      v35 = &dnssd_client_states;
      if (v17 == 2)
        strcpy(hostname, "0.0.0.0");
      else
        strcpy(hostname, "::");
    }
    host = nw_endpoint_create_host(hostname, __str);
    if (!host)
    {
      v80 = *((_QWORD *)v35 + 306);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v156 = "ioloop_listener_create";
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%{public}s: No memory for listener endpoint.", buf, 0xCu);
      }
      v81 = v20[8];
      if (!v81)
      {
        v26 = *((_QWORD *)v35 + 306);
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
          goto LABEL_271;
        *(_DWORD *)buf = 136447490;
        v156 = "ioloop_listener_create";
        v157 = 1024;
        *(_DWORD *)v158 = 0;
        *(_WORD *)&v158[4] = 2048;
        *(_QWORD *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(_QWORD *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(_QWORD *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1639;
        v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_270;
      }
      v26 = *((_QWORD *)v35 + 306);
      if (v81 >= 10001)
      {
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
          goto LABEL_271;
        *(_DWORD *)buf = 136447490;
        v156 = "ioloop_listener_create";
        v157 = 1024;
        *(_DWORD *)v158 = v81;
        *(_WORD *)&v158[4] = 2048;
        *(_QWORD *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(_QWORD *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(_QWORD *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1639;
        v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_270;
      }
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v156 = "ioloop_listener_create";
        v157 = 1024;
        *(_DWORD *)v158 = v81;
        *(_WORD *)&v158[4] = 2048;
        *(_QWORD *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(_QWORD *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(_QWORD *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1639;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v81 = v20[8];
      }
      v20[8] = v81 - 1;
      if (v81 != 1)
        return 0;
      v39 = *((_QWORD *)v35 + 306);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        goto LABEL_230;
      *(_DWORD *)buf = 136447234;
      v156 = "ioloop_listener_create";
      v157 = 2048;
      *(_QWORD *)v158 = v20;
      *(_WORD *)&v158[8] = 2080;
      *(_QWORD *)&v158[10] = "listener";
      *(_WORD *)&v158[18] = 2080;
      *(_QWORD *)&v158[20] = "macos-ioloop.c";
      *(_WORD *)&v158[28] = 1024;
      *(_DWORD *)&v158[30] = 1639;
      goto LABEL_229;
    }
    v62 = host;
  }
  else
  {
    v62 = 0;
    *((_BYTE *)v20 + 184) = 1;
    v35 = &dnssd_client_states;
  }
  v69 = _nw_parameters_configure_protocol_disable;
  if (a9 && a2)
  {
    configure_tls[0] = _NSConcreteStackBlock;
    configure_tls[1] = 0x40000000;
    configure_tls[2] = __ioloop_listener_create_block_invoke;
    configure_tls[3] = &__block_descriptor_tmp_17_1190;
    configure_tls[4] = a9;
    v69 = configure_tls;
  }
  secure_tcp = nw_parameters_create_secure_tcp(v69, _nw_parameters_configure_protocol_default_configuration);
  *((_QWORD *)v20 + 2) = secure_tcp;
  if (!secure_tcp)
  {
    v78 = *((_QWORD *)v35 + 306);
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v156 = "ioloop_listener_create";
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%{public}s: No memory for listener parameters.", buf, 0xCu);
    }
    nw_release(v62);
    v79 = v20[8];
    if (!v79)
    {
      v26 = *((_QWORD *)v35 + 306);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        goto LABEL_271;
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = 0;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1668;
      v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    v26 = *((_QWORD *)v35 + 306);
    if (v79 >= 10001)
    {
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        goto LABEL_271;
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = v79;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1668;
      v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = v79;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1668;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v79 = v20[8];
    }
    v20[8] = v79 - 1;
    if (v79 != 1)
      return 0;
    v39 = *((_QWORD *)v35 + 306);
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      goto LABEL_230;
    *(_DWORD *)buf = 136447234;
    v156 = "ioloop_listener_create";
    v157 = 2048;
    *(_QWORD *)v158 = v20;
    *(_WORD *)&v158[8] = 2080;
    *(_QWORD *)&v158[10] = "listener";
    *(_WORD *)&v158[18] = 2080;
    *(_QWORD *)&v158[20] = "macos-ioloop.c";
    *(_WORD *)&v158[28] = 1024;
    *(_DWORD *)&v158[30] = 1668;
    goto LABEL_229;
  }
  if (v62)
  {
    nw_parameters_set_local_endpoint(secure_tcp, v62);
    nw_release(v62);
    secure_tcp = *((_QWORD *)v20 + 2);
  }
  nw_parameters_set_reuse_local_address(secure_tcp, 1);
  nw_parameters_prohibit_interface_type(*((nw_parameters_t *)v20 + 2), nw_interface_type_cellular);
  *((_QWORD *)v20 + 1) = 0;
  if (!a5
    || !a3
    || (v71 = nw_listener_create_with_launchd_key(*((_QWORD *)v20 + 2), a5),
        (*((_QWORD *)v20 + 1) = v71) == 0)
    && ((v72 = *((_QWORD *)v35 + 306), !os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
     || (*(_DWORD *)buf = 136446210,
         v156 = "ioloop_listener_create",
         _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "%{public}s: launchd listener create failed, trying to create it without relying on launchd.", buf, 0xCu), (v71 = *((_QWORD *)v20 + 1)) == 0)))
  {
    v71 = nw_listener_create(*((nw_parameters_t *)v20 + 2));
    *((_QWORD *)v20 + 1) = v71;
    if (!v71)
    {
      v84 = *((_QWORD *)v35 + 306);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v156 = "ioloop_listener_create";
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "%{public}s: no memory for nw_listener object", buf, 0xCu);
      }
      v85 = v20[8];
      if (!v85)
      {
        v26 = *((_QWORD *)v35 + 306);
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
          goto LABEL_271;
        *(_DWORD *)buf = 136447490;
        v156 = "ioloop_listener_create";
        v157 = 1024;
        *(_DWORD *)v158 = 0;
        *(_WORD *)&v158[4] = 2048;
        *(_QWORD *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(_QWORD *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(_QWORD *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1702;
        v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_270;
      }
      v26 = *((_QWORD *)v35 + 306);
      if (v85 >= 10001)
      {
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
          goto LABEL_271;
        *(_DWORD *)buf = 136447490;
        v156 = "ioloop_listener_create";
        v157 = 1024;
        *(_DWORD *)v158 = v85;
        *(_WORD *)&v158[4] = 2048;
        *(_QWORD *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(_QWORD *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(_QWORD *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1702;
        v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_270:
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v27, buf, 0x36u);
LABEL_271:
        abort();
      }
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v156 = "ioloop_listener_create";
        v157 = 1024;
        *(_DWORD *)v158 = v85;
        *(_WORD *)&v158[4] = 2048;
        *(_QWORD *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(_QWORD *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(_QWORD *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1702;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v85 = v20[8];
      }
      v20[8] = v85 - 1;
      if (v85 != 1)
        return 0;
      v39 = *((_QWORD *)v35 + 306);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        goto LABEL_230;
      *(_DWORD *)buf = 136447234;
      v156 = "ioloop_listener_create";
      v157 = 2048;
      *(_QWORD *)v158 = v20;
      *(_WORD *)&v158[8] = 2080;
      *(_QWORD *)&v158[10] = "listener";
      *(_WORD *)&v158[18] = 2080;
      *(_QWORD *)&v158[20] = "macos-ioloop.c";
      *(_WORD *)&v158[28] = 1024;
      *(_DWORD *)&v158[30] = 1702;
LABEL_229:
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
LABEL_230:
      ++listener_finalized;
      listener_finalize(v20);
      return 0;
    }
  }
  ++nw_listener_created;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = __ioloop_listener_create_block_invoke_18;
  handler[3] = &__block_descriptor_tmp_20;
  handler[4] = v20;
  nw_listener_set_new_connection_handler(v71, handler);
  v73 = *((_QWORD *)v20 + 1);
  v137[0] = _NSConcreteStackBlock;
  v137[1] = 0x40000000;
  v137[2] = __ioloop_listener_create_block_invoke_2;
  v137[3] = &__block_descriptor_tmp_22;
  v137[4] = v20;
  nw_listener_set_state_changed_handler(v73, v137);
  v74 = *((_QWORD *)v35 + 306);
  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
  {
    v75 = v20[8];
    *(_DWORD *)buf = 136447490;
    v156 = "ioloop_listener_create";
    v157 = 1024;
    *(_DWORD *)v158 = v75;
    *(_WORD *)&v158[4] = 2048;
    *(_QWORD *)&v158[6] = v20;
    *(_WORD *)&v158[14] = 2080;
    *(_QWORD *)&v158[16] = "listener";
    *(_WORD *)&v158[24] = 2080;
    *(_QWORD *)&v158[26] = "macos-ioloop.c";
    *(_WORD *)&v158[34] = 1024;
    *(_DWORD *)&v158[36] = 1714;
    _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v76 = v20[8];
  if (v76)
  {
    v77 = v76 + 1;
    v20[8] = v76 + 1;
    if (v76 + 1 >= 10001)
    {
      v26 = *((_QWORD *)v35 + 306);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        goto LABEL_271;
      *(_DWORD *)buf = 136447490;
      v156 = "ioloop_listener_create";
      v157 = 1024;
      *(_DWORD *)v158 = v77;
      *(_WORD *)&v158[4] = 2048;
      *(_QWORD *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(_QWORD *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(_QWORD *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1714;
      v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
  }
  else
  {
    ++listener_created;
    v20[8] = 1;
  }
  nw_listener_set_queue(*((nw_listener_t *)v20 + 1), (dispatch_queue_t)ioloop_main_queue);
  nw_listener_start(*((nw_listener_t *)v20 + 1));
  return v20;
}

void ioloop_add_reader(int *a1)
{
  NSObject *v2;
  NSObject *v3;
  int v4;
  int v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  const char *v9;
  char *v10;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  uint32_t v14;
  uint64_t v15;
  int v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  _BYTE v20[14];
  __int16 v21;
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  int v26;

  *((_QWORD *)a1 + 2) = ioloop_udp_read_callback;
  v2 = *((_QWORD *)a1 + 9);
  if (v2
    || (v2 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a1[23], 0, (dispatch_queue_t)ioloop_main_queue), (*((_QWORD *)a1 + 9) = v2) != 0))
  {
    dispatch_source_set_event_handler_f(v2, (dispatch_function_t)ioloop_read_event);
    dispatch_source_set_cancel_handler_f(*((dispatch_source_t *)a1 + 9), (dispatch_function_t)ioloop_read_source_cancel_callback);
    dispatch_set_finalizer_f(*((dispatch_object_t *)a1 + 9), (dispatch_function_t)ioloop_read_source_finalize);
    dispatch_set_context(*((dispatch_object_t *)a1 + 9), a1);
    v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *a1;
      *(_DWORD *)buf = 136447490;
      v18 = "ioloop_add_reader";
      v19 = 1024;
      *(_DWORD *)v20 = v4;
      *(_WORD *)&v20[4] = 2048;
      *(_QWORD *)&v20[6] = a1;
      v21 = 2080;
      v22 = "io";
      v23 = 2080;
      v24 = "macos-ioloop.c";
      v25 = 1024;
      v26 = 2370;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      v5 = *a1 + 1;
      *a1 = v5;
      if (v5 >= 10001)
      {
        v16 = v5;
        v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v18 = "ioloop_add_reader";
          v19 = 1024;
          *(_DWORD *)v20 = v16;
          *(_WORD *)&v20[4] = 2048;
          *(_QWORD *)&v20[6] = a1;
          v21 = 2080;
          v22 = "io";
          v23 = 2080;
          v24 = "macos-ioloop.c";
          v25 = 1024;
          v26 = 2370;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++file_descriptor_created;
      *a1 = 1;
    }
    dispatch_resume(*((dispatch_object_t *)a1 + 9));
    v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v8 = a1[23];
      v9 = (const char *)*((_QWORD *)a1 + 9);
      v10 = (char *)*((_QWORD *)a1 + 10);
      *(_DWORD *)buf = 136447234;
      v18 = "ioloop_add_reader";
      v19 = 2048;
      *(_QWORD *)v20 = a1;
      *(_WORD *)&v20[8] = 1024;
      *(_DWORD *)&v20[10] = v8;
      v21 = 2048;
      v22 = v9;
      v23 = 2048;
      v24 = v10;
      v11 = "%{public}s: io %p fd %d, read source %p, write_source %p";
      v12 = v7;
      v13 = OS_LOG_TYPE_DEFAULT;
      v14 = 48;
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v12, v13, v11, buf, v14);
    }
  }
  else
  {
    v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v18 = "ioloop_add_reader";
      v11 = "%{public}s: dispatch_source_create: unable to create read dispatch source.";
      v12 = v15;
      v13 = OS_LOG_TYPE_ERROR;
      v14 = 12;
      goto LABEL_13;
    }
  }
}

void ioloop_listener_context_release(uint64_t a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *(_DWORD *)(a1 + 32);
  if (!v2)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "ioloop_listener_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "listener";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "macos-ioloop.c";
    v10 = 1024;
    v11 = 1124;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "ioloop_listener_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "listener";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "macos-ioloop.c";
    v10 = 1024;
    v11 = 1124;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "ioloop_listener_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "listener";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "macos-ioloop.c";
    v10 = 1024;
    v11 = 1124;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "ioloop_listener_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "listener";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "macos-ioloop.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 1124;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++listener_finalized;
    listener_finalize((_QWORD *)a1);
  }
}

void __ioloop_udp_listener_setup_block_invoke(uint64_t a1)
{
  uint64_t v2;
  void (*v3)(_QWORD, _QWORD);
  NSObject *v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  v2 = *(_QWORD *)(a1 + 32);
  if ((*(_WORD *)(v2 + 416) & 0x400) != 0)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136446210;
      v13 = "ioloop_udp_listener_setup_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ready but canceled", (uint8_t *)&v12, 0xCu);
    }
  }
  else
  {
    v3 = *(void (**)(_QWORD, _QWORD))(v2 + 256);
    if (v3)
      v3(*(_QWORD *)(v2 + 200), *(unsigned __int16 *)(v2 + 160));
  }
  v5 = *(_QWORD *)(a1 + 32);
  if (v5)
  {
    v6 = *(_DWORD *)(v5 + 32);
    if (v6)
    {
      v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136447490;
          v13 = "ioloop_udp_listener_setup_block_invoke";
          v14 = 1024;
          *(_DWORD *)v15 = v6;
          *(_WORD *)&v15[4] = 2048;
          *(_QWORD *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(_QWORD *)&v15[16] = "listener";
          *(_WORD *)&v15[24] = 2080;
          *(_QWORD *)&v15[26] = "macos-ioloop.c";
          v16 = 1024;
          v17 = 1505;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
          v5 = *(_QWORD *)(a1 + 32);
          v6 = *(_DWORD *)(v5 + 32);
        }
        *(_DWORD *)(v5 + 32) = v6 - 1;
        if (v6 == 1)
        {
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v12 = 136447234;
            v13 = "ioloop_udp_listener_setup_block_invoke";
            v14 = 2048;
            *(_QWORD *)v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(_QWORD *)&v15[10] = "listener";
            *(_WORD *)&v15[18] = 2080;
            *(_QWORD *)&v15[20] = "macos-ioloop.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 1505;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
            v5 = *(_QWORD *)(a1 + 32);
          }
          ++listener_finalized;
          listener_finalize((_QWORD *)v5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_21:
        abort();
      v12 = 136447490;
      v13 = "ioloop_udp_listener_setup_block_invoke";
      v14 = 1024;
      *(_DWORD *)v15 = v6;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "listener";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "macos-ioloop.c";
      v16 = 1024;
      v17 = 1505;
      v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v11 = v7;
    }
    else
    {
      v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_21;
      v12 = 136447490;
      v13 = "ioloop_udp_listener_setup_block_invoke";
      v14 = 1024;
      *(_DWORD *)v15 = 0;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "listener";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "macos-ioloop.c";
      v16 = 1024;
      v17 = 1505;
      v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v11 = v9;
    }
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v12, 0x36u);
    goto LABEL_21;
  }
}

uint64_t __ioloop_listener_create_block_invoke(uint64_t a1, uint64_t a2)
{
  _QWORD v3[2];

  v3[0] = a2;
  v3[1] = ioloop_main_queue;
  return (*(uint64_t (**)(_QWORD *))(a1 + 32))(v3);
}

void __ioloop_listener_create_block_invoke_18(uint64_t a1, nw_connection_t connection)
{
  uint64_t v3;
  _DWORD *v4;
  _DWORD *v5;
  int *v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  uint8_t v17[4];
  const char *v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  _BYTE buf[40];
  char *v24;
  __int16 v25;
  int v26;

  v3 = *(_QWORD *)(a1 + 32);
  nw_connection_set_queue(connection, (dispatch_queue_t)ioloop_main_queue);
  nw_connection_start(connection);
  v4 = malloc_type_calloc(1uLL, 0x1A8uLL, 0x10B00402743B0D3uLL);
  if (v4)
  {
    v5 = v4;
    v4[45] = ++cur_connection_serial;
    *(_QWORD *)v4 = connection;
    nw_retain(connection);
    ++nw_connection_created;
    *((_QWORD *)v5 + 24) = strdup(*(const char **)(v3 + 192));
    *((_QWORD *)v5 + 26) = *(_QWORD *)(v3 + 208);
    *((_WORD *)v5 + 208) = *(_WORD *)(v3 + 416) & 0x20 | v5[104] & 0xFFDF | 2;
    *((_QWORD *)v5 + 25) = *(_QWORD *)(v3 + 200);
    *((_QWORD *)v5 + 28) = *(_QWORD *)(v3 + 224);
    v6 = *(int **)(v3 + 408);
    *((_QWORD *)v5 + 51) = v6;
    ifpermit_list_retain_(v6, 1066);
    v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v8 = v5[8];
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_listener_connection_callback";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v5;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      v24 = "macos-ioloop.c";
      v25 = 1024;
      v26 = 1068;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v9 = v5[8];
    if (v9)
    {
      v10 = v9 + 1;
      v5[8] = v10;
      if (v10 >= 10001)
      {
        v16 = v10;
        v11 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "ioloop_listener_connection_callback";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v16;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v5;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "connection";
          *(_WORD *)&buf[38] = 2080;
          v24 = "macos-ioloop.c";
          v25 = 1024;
          v26 = 1068;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++comm_created;
      v5[8] = 1;
    }
    v13 = *(NSObject **)v5;
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = __ioloop_listener_connection_callback_block_invoke;
    *(_QWORD *)&buf[24] = &__block_descriptor_tmp_49;
    *(_QWORD *)&buf[32] = v5;
    nw_connection_set_state_changed_handler(v13, buf);
    v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *((_QWORD *)v5 + 24);
      *(_DWORD *)v17 = 136446723;
      v18 = "ioloop_listener_connection_callback";
      v19 = 2160;
      v20 = 1752392040;
      v21 = 2081;
      v22 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: started %{private, mask.hash}s", v17, 0x20u);
    }
  }
  else
  {
    v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "ioloop_listener_connection_callback";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: Unable to receive connection: no memory.", buf, 0xCu);
    }
    nw_connection_cancel(connection);
  }
}

void __ioloop_listener_create_block_invoke_2(uint64_t a1, int a2, NSObject *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint32_t v11;
  uint64_t v12;
  NSObject *v13;
  _BOOL4 v14;
  NSObject *v15;
  uint64_t v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  NSObject *v22;
  void (*v23)(_QWORD, _QWORD);
  NSObject *v24;
  void (*v25)(uint64_t, _QWORD);
  int v26;
  NSObject *v27;
  NSObject *v28;
  const char *v29;
  int v30;
  const char *v31;
  __int16 v32;
  uint8_t *v33;
  uint8_t buf[4];
  const char *v35;
  __int16 v36;
  _BYTE v37[34];
  __int16 v38;
  int v39;

  v5 = *(_QWORD *)(a1 + 32);
  if (!*(_QWORD *)(v5 + 8))
  {
    v6 = global_os_log;
    if (a2 == 4)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_8;
      v7 = *(_QWORD *)(v5 + 192);
      *(_DWORD *)buf = 136446723;
      v35 = "ioloop_listener_state_changed_handler";
      v36 = 2160;
      *(_QWORD *)v37 = 1752392040;
      *(_WORD *)&v37[8] = 2081;
      *(_QWORD *)&v37[10] = v7;
      v8 = "%{public}s: nw_listener gets released before the final nw_listener_state_cancelled event - name: %{private, mask.hash}s";
      v9 = v6;
      v10 = OS_LOG_TYPE_DEFAULT;
      v11 = 32;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_8;
      v12 = *(_QWORD *)(v5 + 192);
      *(_DWORD *)buf = 136446979;
      v35 = "ioloop_listener_state_changed_handler";
      v36 = 2160;
      *(_QWORD *)v37 = 1752392040;
      *(_WORD *)&v37[8] = 2081;
      *(_QWORD *)&v37[10] = v12;
      *(_WORD *)&v37[18] = 1024;
      *(_DWORD *)&v37[20] = a2;
      v8 = "%{public}s: nw_listener gets released before the listener is canceled - name: %{private, mask.hash}s, state: %d";
      v9 = v6;
      v10 = OS_LOG_TYPE_ERROR;
      v11 = 38;
    }
    _os_log_impl((void *)&_mh_execute_header, v9, v10, v8, buf, v11);
  }
LABEL_8:
  v13 = global_os_log;
  v14 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  v15 = *(NSObject **)(v5 + 8);
  if (v14)
  {
    v16 = *(_QWORD *)(v5 + 192);
    *(_DWORD *)buf = 136447234;
    v35 = "ioloop_listener_state_changed_handler";
    v36 = 2048;
    *(_QWORD *)v37 = v5;
    *(_WORD *)&v37[8] = 2048;
    *(_QWORD *)&v37[10] = v15;
    *(_WORD *)&v37[18] = 2082;
    *(_QWORD *)&v37[20] = v16;
    *(_WORD *)&v37[28] = 1024;
    *(_DWORD *)&v37[30] = a2;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: %p %p %{public}s %d", buf, 0x30u);
    v15 = *(NSObject **)(v5 + 8);
  }
  if (a2 == 4 || v15)
  {
    if (a3)
    {
      connection_error_to_string(a3, (char *)buf);
      v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v30 = 136446466;
        v31 = "ioloop_listener_state_changed_handler";
        v32 = 2082;
        v33 = buf;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: state changed: %{public}s", (uint8_t *)&v30, 0x16u);
      }
      v18 = *(NSObject **)(v5 + 8);
      if (v18)
LABEL_16:
        nw_listener_cancel(v18);
      return;
    }
    switch(a2)
    {
      case 1:
        v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 136446210;
        v35 = "ioloop_listener_state_changed_handler";
        v20 = "%{public}s: waiting";
        goto LABEL_26;
      case 2:
        v22 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "ioloop_listener_state_changed_handler";
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ready", buf, 0xCu);
        }
        v23 = *(void (**)(_QWORD, _QWORD))(v5 + 256);
        if (v23)
          v23(*(_QWORD *)(v5 + 200), *(unsigned __int16 *)(v5 + 160));
        return;
      case 3:
        v21 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "ioloop_listener_state_changed_handler";
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: failed", buf, 0xCu);
          v15 = *(NSObject **)(v5 + 8);
        }
        v18 = v15;
        goto LABEL_16;
      case 4:
        v24 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v35 = "ioloop_listener_state_changed_handler";
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: cancelled", buf, 0xCu);
          v15 = *(NSObject **)(v5 + 8);
        }
        nw_release(v15);
        ++nw_listener_finalized;
        *(_QWORD *)(v5 + 8) = 0;
        v25 = *(void (**)(uint64_t, _QWORD))(v5 + 248);
        if (v25)
          v25(v5, *(_QWORD *)(v5 + 200));
        v26 = *(_DWORD *)(v5 + 32);
        if (v26)
        {
          v27 = global_os_log;
          if (v26 < 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              v35 = "ioloop_listener_state_changed_handler";
              v36 = 1024;
              *(_DWORD *)v37 = v26;
              *(_WORD *)&v37[4] = 2048;
              *(_QWORD *)&v37[6] = v5;
              *(_WORD *)&v37[14] = 2080;
              *(_QWORD *)&v37[16] = "listener";
              *(_WORD *)&v37[24] = 2080;
              *(_QWORD *)&v37[26] = "macos-ioloop.c";
              v38 = 1024;
              v39 = 1305;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              v26 = *(_DWORD *)(v5 + 32);
            }
            *(_DWORD *)(v5 + 32) = v26 - 1;
            if (v26 == 1)
            {
              v28 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                v35 = "ioloop_listener_state_changed_handler";
                v36 = 2048;
                *(_QWORD *)v37 = v5;
                *(_WORD *)&v37[8] = 2080;
                *(_QWORD *)&v37[10] = "listener";
                *(_WORD *)&v37[18] = 2080;
                *(_QWORD *)&v37[20] = "macos-ioloop.c";
                *(_WORD *)&v37[28] = 1024;
                *(_DWORD *)&v37[30] = 1305;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              }
              ++listener_finalized;
              listener_finalize((_QWORD *)v5);
            }
            return;
          }
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_48:
            abort();
          *(_DWORD *)buf = 136447490;
          v35 = "ioloop_listener_state_changed_handler";
          v36 = 1024;
          *(_DWORD *)v37 = v26;
          *(_WORD *)&v37[4] = 2048;
          *(_QWORD *)&v37[6] = v5;
          *(_WORD *)&v37[14] = 2080;
          *(_QWORD *)&v37[16] = "listener";
          *(_WORD *)&v37[24] = 2080;
          *(_QWORD *)&v37[26] = "macos-ioloop.c";
          v38 = 1024;
          v39 = 1305;
          v29 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        }
        else
        {
          v27 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_48;
          *(_DWORD *)buf = 136447490;
          v35 = "ioloop_listener_state_changed_handler";
          v36 = 1024;
          *(_DWORD *)v37 = 0;
          *(_WORD *)&v37[4] = 2048;
          *(_QWORD *)&v37[6] = v5;
          *(_WORD *)&v37[14] = 2080;
          *(_QWORD *)&v37[16] = "listener";
          *(_WORD *)&v37[24] = 2080;
          *(_QWORD *)&v37[26] = "macos-ioloop.c";
          v38 = 1024;
          v39 = 1305;
          v29 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        }
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, v29, buf, 0x36u);
        goto LABEL_48;
      default:
        v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          return;
        *(_DWORD *)buf = 136446210;
        v35 = "ioloop_listener_state_changed_handler";
        v20 = "%{public}s: something else";
LABEL_26:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v20, buf, 0xCu);
        return;
    }
  }
}

void connection_error_to_string(NSObject *a1, char *a2)
{
  __CFError *v3;
  __CFError *v4;
  const __CFString *v5;
  const __CFString *v6;

  *a2 = 0;
  if (!a1)
    goto LABEL_7;
  v3 = nw_error_copy_cf_error(a1);
  if (v3)
  {
    v4 = v3;
    v5 = CFErrorCopyDescription(v3);
    if (v5)
    {
      v6 = v5;
      CFStringGetCString(v5, a2, 512, 0x8000100u);
      CFRelease(v6);
    }
    CFRelease(v4);
  }
  if (!*a2)
LABEL_7:
    strcpy(a2, "<NULL>");
}

void __ioloop_listener_connection_callback_block_invoke(uint64_t a1, int a2, NSObject *a3)
{
  ioloop_connection_state_changed(*(_QWORD **)(a1 + 32), a2, a3);
}

void ioloop_connection_state_changed(_QWORD *a1, int a2, NSObject *a3)
{
  uint64_t v6;
  void *v7;
  NSObject *v8;
  uint32_t index;
  unint64_t v10;
  _BOOL4 v11;
  NSObject *v12;
  const char *v13;
  const char *v14;
  nw_connection_t v15;
  NSObject *v16;
  const char *v17;
  nw_connection_t v18;
  void (*v19)(_QWORD *, _QWORD, _QWORD);
  int v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  const char *v24;
  nw_connection_t v25;
  NSObject *v26;
  const char *v27;
  unint64_t v28;
  char *v29;
  const char *name;
  NSObject *v31;
  const char *v32;
  NSObject *v33;
  NSObject *v34;
  nw_endpoint_type_t type;
  char *v36;
  char *v37;
  char *v38;
  char **v39;
  void *v40;
  const char *v41;
  int v42;
  uint64_t v43;
  _BOOL4 v44;
  int v45;
  const char *v46;
  nw_endpoint_type_t v47;
  char *v48;
  NSObject *v49;
  uint64_t v50;
  const char *v51;
  NSObject *v52;
  os_log_type_t v53;
  uint32_t v54;
  uint64_t v55;
  NSObject *v56;
  uint64_t v57;
  void *v58;
  char *v59;
  int v60;
  uint64_t v61;
  _BOOL4 v62;
  int v63;
  const char *v64;
  uint64_t v65;
  const char *v66;
  NSObject *v67;
  os_log_type_t v68;
  uint32_t v69;
  void (*v70)(_QWORD *, _QWORD);
  NSObject *v71;
  const char *v72;
  nw_connection_t v73;
  void (*v74)(_QWORD *, _QWORD);
  const char *v75;
  char v76[512];
  uint8_t buf[4];
  const char *v78;
  __int16 v79;
  _BYTE v80[60];
  __int16 v81;
  uint64_t v82;
  __int16 v83;
  int v84;
  __int16 v85;
  _QWORD *v86;

  connection_error_to_string(a3, v76);
  switch(a2)
  {
    case 3:
      if ((a1[52] & 2) == 0)
      {
LABEL_112:
        v71 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v72 = (const char *)a1[24];
          v73 = (nw_connection_t)*a1;
          if (!v72)
            v72 = "<no name>";
          *(_DWORD *)buf = 136447491;
          v78 = "ioloop_connection_state_changed";
          v79 = 2160;
          *(_QWORD *)v80 = 1752392040;
          *(_WORD *)&v80[8] = 2081;
          *(_QWORD *)&v80[10] = v72;
          *(_WORD *)&v80[18] = 2048;
          *(_QWORD *)&v80[20] = a1;
          *(_WORD *)&v80[28] = 2048;
          *(_QWORD *)&v80[30] = v73;
          *(_WORD *)&v80[38] = 2082;
          *(_QWORD *)&v80[40] = v76;
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p %p) state is ready; error = %{public}s",
            buf,
            0x3Eu);
        }
        if ((a1[52] & 0x20) != 0)
          ioloop_tcp_input_start((uint64_t)a1);
        else
          ioloop_udp_input_start((uint64_t)a1);
        *((_WORD *)a1 + 208) |= 4u;
        if (a1[6])
          connection_write_now((uint64_t)a1);
        v74 = (void (*)(_QWORD *, _QWORD))a1[28];
        if (v74)
          v74(a1, a1[25]);
        return;
      }
      if (!a1[51])
      {
LABEL_52:
        v33 = nw_connection_copy_endpoint((nw_connection_t)*a1);
        v34 = v33;
        if (!v33)
          goto LABEL_83;
        type = nw_endpoint_get_type(v33);
        if (type != nw_endpoint_type_address)
        {
          v47 = type;
          v48 = (char *)a1[24];
          if (!v48)
          {
            v48 = nw_connection_copy_description((nw_connection_t)*a1);
            a1[24] = v48;
          }
          v49 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446979;
            v78 = "ioloop_connection_set_name_from_endpoint";
            v79 = 2160;
            *(_QWORD *)v80 = 1752392040;
            *(_WORD *)&v80[8] = 2081;
            *(_QWORD *)&v80[10] = v48;
            *(_WORD *)&v80[18] = 1024;
            *(_DWORD *)&v80[20] = v47;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%{public}s: incoming connection %{private, mask.hash}s is of unexpected type %d", buf, 0x26u);
          }
          goto LABEL_82;
        }
        v36 = nw_endpoint_copy_port_string(v34);
        v37 = nw_endpoint_copy_address_string(v34);
        v38 = v37;
        if (v36 && v37)
        {
          v39 = (char **)(a1 + 24);
          v40 = (void *)a1[24];
          v41 = "bogus";
          if (v40)
            v41 = (const char *)a1[24];
          *v39 = 0;
          asprintf(v39, "%s connection from %s/%s", v41, v38, v36);
          if (v40)
            free(v40);
          getipaddr((char *)a1 + 288, v38);
          v42 = *((unsigned __int8 *)a1 + 289);
          v43 = global_os_log;
          v44 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (v42 == 30)
          {
            if (v44)
            {
              v45 = *((unsigned __int8 *)a1 + 296);
              if ((v45 & 0xFE) == 0xFC)
              {
                v46 = "ULA: ";
              }
              else if (v45 == 254 && (*((_BYTE *)a1 + 297) & 0xC0) == 0x80)
              {
                v46 = "LUA: ";
              }
              else if ((v45 & 0xE0) == 0x20)
              {
                v46 = "GUA: ";
              }
              else
              {
                v46 = (const char *)&unk_10007C3B5;
              }
              *(_DWORD *)buf = 136448771;
              v78 = "ioloop_connection_set_name_from_endpoint";
              v79 = 2082;
              *(_QWORD *)v80 = v46;
              *(_WORD *)&v80[8] = 2160;
              *(_QWORD *)&v80[10] = 1752392040;
              *(_WORD *)&v80[18] = 1041;
              *(_DWORD *)&v80[20] = 6;
              *(_WORD *)&v80[24] = 2097;
              *(_QWORD *)&v80[26] = a1 + 37;
              *(_WORD *)&v80[34] = 2160;
              *(_QWORD *)&v80[36] = 1752392040;
              *(_WORD *)&v80[44] = 1042;
              *(_DWORD *)&v80[46] = 2;
              *(_WORD *)&v80[50] = 2098;
              *(_QWORD *)&v80[52] = (char *)a1 + 302;
              v81 = 2160;
              v82 = 1752392040;
              v83 = 1041;
              v84 = 8;
              v85 = 2097;
              v86 = a1 + 38;
              v51 = "%{public}s: parsed connection remote IPv6 address is: {%{public}s%{private, mask.hash, srp:in6_addr_"
                    "segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
              v52 = v43;
              v53 = OS_LOG_TYPE_DEFAULT;
              v54 = 100;
              goto LABEL_80;
            }
LABEL_81:
            free(v36);
            free(v38);
LABEL_82:
            nw_release(v34);
LABEL_83:
            v55 = a1[24];
            v56 = global_os_log;
            if (v55)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446723;
                v78 = "ioloop_listener_connection_ready";
                v79 = 2160;
                *(_QWORD *)v80 = 1752392040;
                *(_WORD *)&v80[8] = 2081;
                *(_QWORD *)&v80[10] = v55;
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: Received connection from %{private, mask.hash}s", buf, 0x20u);
              }
            }
            else
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446210;
                v78 = "ioloop_listener_connection_ready";
                _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%{public}s: Unable to get description of new connection.", buf, 0xCu);
              }
              a1[24] = strdup("unidentified");
            }
            v57 = nw_connection_copy_connected_local_endpoint(*a1);
            if (!v57)
              goto LABEL_110;
            v58 = (void *)v57;
            if (nw_endpoint_get_type(v34) != nw_endpoint_type_address)
            {
LABEL_109:
              nw_release(v58);
LABEL_110:
              v70 = (void (*)(_QWORD *, _QWORD))a1[28];
              if (v70)
                v70(a1, a1[25]);
              goto LABEL_112;
            }
            v59 = nw_endpoint_copy_address_string(v34);
            if (v59)
            {
              getipaddr((char *)a1 + 344, v59);
              v60 = *((unsigned __int8 *)a1 + 345);
              v61 = global_os_log;
              v62 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
              if (v60 == 30)
              {
                if (v62)
                {
                  v63 = *((unsigned __int8 *)a1 + 352);
                  if ((v63 & 0xFE) == 0xFC)
                  {
                    v64 = "ULA: ";
                  }
                  else if (v63 == 254 && (*((_BYTE *)a1 + 353) & 0xC0) == 0x80)
                  {
                    v64 = "LUA: ";
                  }
                  else if ((v63 & 0xE0) == 0x20)
                  {
                    v64 = "GUA: ";
                  }
                  else
                  {
                    v64 = (const char *)&unk_10007C3B5;
                  }
                  *(_DWORD *)buf = 136448771;
                  v78 = "ioloop_connection_get_address_from_endpoint";
                  v79 = 2082;
                  *(_QWORD *)v80 = v64;
                  *(_WORD *)&v80[8] = 2160;
                  *(_QWORD *)&v80[10] = 1752392040;
                  *(_WORD *)&v80[18] = 1041;
                  *(_DWORD *)&v80[20] = 6;
                  *(_WORD *)&v80[24] = 2097;
                  *(_QWORD *)&v80[26] = a1 + 44;
                  *(_WORD *)&v80[34] = 2160;
                  *(_QWORD *)&v80[36] = 1752392040;
                  *(_WORD *)&v80[44] = 1042;
                  *(_DWORD *)&v80[46] = 2;
                  *(_WORD *)&v80[50] = 2098;
                  *(_QWORD *)&v80[52] = (char *)a1 + 358;
                  v81 = 2160;
                  v82 = 1752392040;
                  v83 = 1041;
                  v84 = 8;
                  v85 = 2097;
                  v86 = a1 + 45;
                  v66 = "%{public}s: parsed connection local IPv6 address is: {%{public}s%{private, mask.hash, srp:in6_ad"
                        "dr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
                  v67 = v61;
                  v68 = OS_LOG_TYPE_DEFAULT;
                  v69 = 100;
                  goto LABEL_107;
                }
LABEL_108:
                free(v59);
                goto LABEL_109;
              }
              if (!v62)
                goto LABEL_108;
              *(_DWORD *)buf = 136446979;
              v78 = "ioloop_connection_get_address_from_endpoint";
              v79 = 2160;
              *(_QWORD *)v80 = 1752392040;
              *(_WORD *)&v80[8] = 1041;
              *(_DWORD *)&v80[10] = 4;
              *(_WORD *)&v80[14] = 2097;
              *(_QWORD *)&v80[16] = (char *)a1 + 348;
              v66 = "%{public}s: parsed connection local IPv4 address is: %{private, mask.hash, network:in_addr}.4P";
              v67 = v61;
              v68 = OS_LOG_TYPE_DEFAULT;
              v69 = 38;
            }
            else
            {
              v65 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                goto LABEL_108;
              *(_DWORD *)buf = 136446210;
              v78 = "ioloop_connection_get_address_from_endpoint";
              v66 = "%{public}s: unable to get description of new connection.";
              v67 = v65;
              v68 = OS_LOG_TYPE_ERROR;
              v69 = 12;
            }
LABEL_107:
            _os_log_impl((void *)&_mh_execute_header, v67, v68, v66, buf, v69);
            goto LABEL_108;
          }
          if (!v44)
            goto LABEL_81;
          *(_DWORD *)buf = 136446979;
          v78 = "ioloop_connection_set_name_from_endpoint";
          v79 = 2160;
          *(_QWORD *)v80 = 1752392040;
          *(_WORD *)&v80[8] = 1041;
          *(_DWORD *)&v80[10] = 4;
          *(_WORD *)&v80[14] = 2097;
          *(_QWORD *)&v80[16] = (char *)a1 + 292;
          v51 = "%{public}s: parsed connection remote IPv4 address is: %{private, mask.hash, network:in_addr}.4P";
          v52 = v43;
          v53 = OS_LOG_TYPE_DEFAULT;
          v54 = 38;
        }
        else
        {
          v50 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_81;
          *(_DWORD *)buf = 136446210;
          v78 = "ioloop_connection_set_name_from_endpoint";
          v51 = "%{public}s: Unable to get description of new connection.";
          v52 = v50;
          v53 = OS_LOG_TYPE_ERROR;
          v54 = 12;
        }
LABEL_80:
        _os_log_impl((void *)&_mh_execute_header, v52, v53, v51, buf, v54);
        goto LABEL_81;
      }
      v6 = nw_connection_copy_connected_path(*a1);
      if (v6)
      {
        v7 = (void *)v6;
        v8 = nw_path_copy_interface();
        nw_release(v7);
        if (v8)
        {
          index = nw_interface_get_index(v8);
          v10 = a1[51];
          if (v10 >= 2)
          {
            v28 = v10 + 8;
            while (1)
            {
              v28 = *(_QWORD *)v28;
              v11 = v28 != 0;
              if (!v28)
                break;
              if (*(_DWORD *)(v28 + 16) == index)
              {
                v11 = 1;
                break;
              }
            }
          }
          else
          {
            v11 = 0;
          }
          v29 = nw_connection_copy_description((nw_connection_t)*a1);
          name = nw_interface_get_name(v8);
          v31 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v78 = "ioloop_listener_connection_ready";
            v79 = 2160;
            v32 = "not ";
            *(_QWORD *)v80 = 1752392040;
            *(_WORD *)&v80[8] = 2081;
            *(_DWORD *)buf = 136447235;
            if (v11)
              v32 = (const char *)&unk_10007C3B5;
            *(_QWORD *)&v80[10] = v29;
            *(_WORD *)&v80[18] = 2082;
            *(_QWORD *)&v80[20] = name;
            *(_WORD *)&v80[28] = 2082;
            *(_QWORD *)&v80[30] = v32;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%{public}s: incoming connection from %{private, mask.hash}s is on %{public}s, which is %{public}spermitted.", buf, 0x34u);
          }
          free(v29);
          nw_release(v8);
          if (v11)
            goto LABEL_52;
LABEL_64:
          ioloop_comm_cancel((uint64_t)a1);
          return;
        }
        v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_64;
        *(_DWORD *)buf = 136446210;
        v78 = "ioloop_listener_connection_ready";
        v27 = "%{public}s: unable to get interface from local endpoint to check for excluded interface types.";
      }
      else
      {
        v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_64;
        *(_DWORD *)buf = 136446210;
        v78 = "ioloop_listener_connection_ready";
        v27 = "%{public}s: unable to get local endpoint to check for excluded interface types.";
      }
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, v27, buf, 0xCu);
      goto LABEL_64;
    case 1:
      goto LABEL_11;
    case 5:
      v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v17 = (const char *)a1[24];
        v18 = (nw_connection_t)*a1;
        if (!v17)
          v17 = "<no name>";
        *(_DWORD *)buf = 136447491;
        v78 = "ioloop_connection_state_changed";
        v79 = 2160;
        *(_QWORD *)v80 = 1752392040;
        *(_WORD *)&v80[8] = 2081;
        *(_QWORD *)&v80[10] = v17;
        *(_WORD *)&v80[18] = 2048;
        *(_QWORD *)&v80[20] = a1;
        *(_WORD *)&v80[28] = 2048;
        *(_QWORD *)&v80[30] = v18;
        *(_WORD *)&v80[38] = 2082;
        *(_QWORD *)&v80[40] = v76;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p %p) state is canceled; error = %{public}s",
          buf,
          0x3Eu);
      }
      v19 = (void (*)(_QWORD *, _QWORD, _QWORD))a1[29];
      if (v19)
        v19(a1, a1[25], 0);
      v20 = *((_DWORD *)a1 + 8);
      if (v20)
      {
        v21 = global_os_log;
        if (v20 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            v78 = "ioloop_connection_state_changed";
            v79 = 1024;
            *(_DWORD *)v80 = v20;
            *(_WORD *)&v80[4] = 2048;
            *(_QWORD *)&v80[6] = a1;
            *(_WORD *)&v80[14] = 2080;
            *(_QWORD *)&v80[16] = "connection";
            *(_WORD *)&v80[24] = 2080;
            *(_QWORD *)&v80[26] = "macos-ioloop.c";
            *(_WORD *)&v80[34] = 1024;
            *(_DWORD *)&v80[36] = 868;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v20 = *((_DWORD *)a1 + 8);
          }
          *((_DWORD *)a1 + 8) = v20 - 1;
          if (v20 == 1)
          {
            v22 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              v78 = "ioloop_connection_state_changed";
              v79 = 2048;
              *(_QWORD *)v80 = a1;
              *(_WORD *)&v80[8] = 2080;
              *(_QWORD *)&v80[10] = "connection";
              *(_WORD *)&v80[18] = 2080;
              *(_QWORD *)&v80[20] = "macos-ioloop.c";
              *(_WORD *)&v80[28] = 1024;
              *(_DWORD *)&v80[30] = 868;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            }
            ++comm_finalized;
            comm_finalize((uint64_t)a1);
          }
          return;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_129:
          abort();
        *(_DWORD *)buf = 136447490;
        v78 = "ioloop_connection_state_changed";
        v79 = 1024;
        *(_DWORD *)v80 = v20;
        *(_WORD *)&v80[4] = 2048;
        *(_QWORD *)&v80[6] = a1;
        *(_WORD *)&v80[14] = 2080;
        *(_QWORD *)&v80[16] = "connection";
        *(_WORD *)&v80[24] = 2080;
        *(_QWORD *)&v80[26] = "macos-ioloop.c";
        *(_WORD *)&v80[34] = 1024;
        *(_DWORD *)&v80[36] = 868;
        v75 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        v21 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_129;
        *(_DWORD *)buf = 136447490;
        v78 = "ioloop_connection_state_changed";
        v79 = 1024;
        *(_DWORD *)v80 = 0;
        *(_WORD *)&v80[4] = 2048;
        *(_QWORD *)&v80[6] = a1;
        *(_WORD *)&v80[14] = 2080;
        *(_QWORD *)&v80[16] = "connection";
        *(_WORD *)&v80[24] = 2080;
        *(_QWORD *)&v80[26] = "macos-ioloop.c";
        *(_WORD *)&v80[34] = 1024;
        *(_DWORD *)&v80[36] = 868;
        v75 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v75, buf, 0x36u);
      goto LABEL_129;
    case 4:
LABEL_11:
      v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v13 = (const char *)a1[24];
        v78 = "ioloop_connection_state_changed";
        v79 = 2160;
        if (!v13)
          v13 = "<no name>";
        *(_QWORD *)v80 = 1752392040;
        v14 = "waiting";
        v15 = (nw_connection_t)*a1;
        *(_DWORD *)buf = 136447747;
        *(_WORD *)&v80[8] = 2081;
        if (a2 == 4)
          v14 = "failed";
        *(_QWORD *)&v80[10] = v13;
        *(_WORD *)&v80[18] = 2048;
        *(_QWORD *)&v80[20] = a1;
        *(_WORD *)&v80[28] = 2048;
        *(_QWORD *)&v80[30] = v15;
        *(_WORD *)&v80[38] = 2082;
        *(_QWORD *)&v80[40] = v14;
        *(_WORD *)&v80[48] = 2082;
        *(_QWORD *)&v80[50] = v76;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p %p) state is %{public}s; error = %{public}s",
          buf,
          0x48u);
      }
      connection_cancel_((uint64_t)a1, *a1, 860);
      return;
  }
  if (a3)
    connection_cancel_((uint64_t)a1, *a1, 872);
  v23 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v24 = (const char *)a1[24];
    v25 = (nw_connection_t)*a1;
    if (!v24)
      v24 = "<no name>";
    *(_DWORD *)buf = 136447747;
    v78 = "ioloop_connection_state_changed";
    v79 = 2160;
    *(_QWORD *)v80 = 1752392040;
    *(_WORD *)&v80[8] = 2081;
    *(_QWORD *)&v80[10] = v24;
    *(_WORD *)&v80[18] = 2048;
    *(_QWORD *)&v80[20] = a1;
    *(_WORD *)&v80[28] = 2048;
    *(_QWORD *)&v80[30] = v25;
    *(_WORD *)&v80[38] = 1024;
    *(_DWORD *)&v80[40] = a2;
    *(_WORD *)&v80[44] = 2082;
    *(_QWORD *)&v80[46] = v76;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p %p) state is %d; error = %{public}s",
      buf,
      0x44u);
  }
}

void ioloop_tcp_input_start(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  _QWORD completion[5];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  int v21;

  if (*(_QWORD *)a1)
  {
    v2 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)buf = 136447490;
      v11 = "ioloop_tcp_input_start";
      v12 = 1024;
      v13 = v3;
      v14 = 2048;
      v15 = a1;
      v16 = 2080;
      v17 = "connection";
      v18 = 2080;
      v19 = "macos-ioloop.c";
      v20 = 1024;
      v21 = 798;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v4 = *(_DWORD *)(a1 + 32);
    if (v4)
    {
      v5 = v4 + 1;
      *(_DWORD *)(a1 + 32) = v5;
      if (v5 >= 10001)
      {
        v8 = v5;
        v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v11 = "ioloop_tcp_input_start";
          v12 = 1024;
          v13 = v8;
          v14 = 2048;
          v15 = a1;
          v16 = 2080;
          v17 = "connection";
          v18 = 2080;
          v19 = "macos-ioloop.c";
          v20 = 1024;
          v21 = 798;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++comm_created;
      *(_DWORD *)(a1 + 32) = 1;
    }
    v7 = *(NSObject **)a1;
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 0x40000000;
    completion[2] = __ioloop_tcp_input_start_block_invoke;
    completion[3] = &__block_descriptor_tmp_59;
    completion[4] = a1;
    nw_connection_receive(v7, 2u, 2u, completion);
  }
}

void ioloop_udp_input_start(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  int v8;
  _QWORD completion[5];
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  int v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  const char *v17;
  __int16 v18;
  char *v19;
  __int16 v20;
  int v21;

  if (a1)
  {
    v2 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v3 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)buf = 136447490;
      v11 = "ioloop_udp_input_start";
      v12 = 1024;
      v13 = v3;
      v14 = 2048;
      v15 = a1;
      v16 = 2080;
      v17 = "connection";
      v18 = 2080;
      v19 = "macos-ioloop.c";
      v20 = 1024;
      v21 = 812;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v4 = *(_DWORD *)(a1 + 32);
    if (v4)
    {
      v5 = v4 + 1;
      *(_DWORD *)(a1 + 32) = v5;
      if (v5 >= 10001)
      {
        v8 = v5;
        v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v11 = "ioloop_udp_input_start";
          v12 = 1024;
          v13 = v8;
          v14 = 2048;
          v15 = a1;
          v16 = 2080;
          v17 = "connection";
          v18 = 2080;
          v19 = "macos-ioloop.c";
          v20 = 1024;
          v21 = 812;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++comm_created;
      *(_DWORD *)(a1 + 32) = 1;
    }
  }
  v7 = *(NSObject **)a1;
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000;
  completion[2] = __ioloop_udp_input_start_block_invoke;
  completion[3] = &__block_descriptor_tmp_65;
  completion[4] = a1;
  nw_connection_receive_message(v7, completion);
}

void __ioloop_udp_input_start_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3, int a4, NSObject *a5)
{
  uint64_t v8;
  size_t size;
  uint64_t v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  int v17;
  const char *v18;
  __int16 v19;
  _BYTE v20[34];
  __int16 v21;
  int v22;

  if ((ioloop_connection_input_badness_check(*(_QWORD *)(a1 + 32), (uint64_t)a2, a4, a5) & 1) == 0)
  {
    v8 = *(_QWORD *)(a1 + 32);
    size = dispatch_data_get_size(a2);
    if (datagram_read(v8, size, a2, a5))
      ioloop_udp_input_start(*(_QWORD *)(a1 + 32));
  }
  v10 = *(_QWORD *)(a1 + 32);
  if (v10)
  {
    v11 = *(_DWORD *)(v10 + 32);
    if (v11)
    {
      v12 = global_os_log;
      if (v11 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v17 = 136447490;
          v18 = "ioloop_udp_input_start_block_invoke";
          v19 = 1024;
          *(_DWORD *)v20 = v11;
          *(_WORD *)&v20[4] = 2048;
          *(_QWORD *)&v20[6] = v10;
          *(_WORD *)&v20[14] = 2080;
          *(_QWORD *)&v20[16] = "connection";
          *(_WORD *)&v20[24] = 2080;
          *(_QWORD *)&v20[26] = "macos-ioloop.c";
          v21 = 1024;
          v22 = 821;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
          v10 = *(_QWORD *)(a1 + 32);
          v11 = *(_DWORD *)(v10 + 32);
        }
        *(_DWORD *)(v10 + 32) = v11 - 1;
        if (v11 == 1)
        {
          v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v17 = 136447234;
            v18 = "ioloop_udp_input_start_block_invoke";
            v19 = 2048;
            *(_QWORD *)v20 = v10;
            *(_WORD *)&v20[8] = 2080;
            *(_QWORD *)&v20[10] = "connection";
            *(_WORD *)&v20[18] = 2080;
            *(_QWORD *)&v20[20] = "macos-ioloop.c";
            *(_WORD *)&v20[28] = 1024;
            *(_DWORD *)&v20[30] = 821;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v17, 0x30u);
            v10 = *(_QWORD *)(a1 + 32);
          }
          ++comm_finalized;
          comm_finalize(v10);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_19:
        abort();
      v17 = 136447490;
      v18 = "ioloop_udp_input_start_block_invoke";
      v19 = 1024;
      *(_DWORD *)v20 = v11;
      *(_WORD *)&v20[4] = 2048;
      *(_QWORD *)&v20[6] = v10;
      *(_WORD *)&v20[14] = 2080;
      *(_QWORD *)&v20[16] = "connection";
      *(_WORD *)&v20[24] = 2080;
      *(_QWORD *)&v20[26] = "macos-ioloop.c";
      v21 = 1024;
      v22 = 821;
      v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v16 = v12;
    }
    else
    {
      v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_19;
      v17 = 136447490;
      v18 = "ioloop_udp_input_start_block_invoke";
      v19 = 1024;
      *(_DWORD *)v20 = 0;
      *(_WORD *)&v20[4] = 2048;
      *(_QWORD *)&v20[6] = v10;
      *(_WORD *)&v20[14] = 2080;
      *(_QWORD *)&v20[16] = "connection";
      *(_WORD *)&v20[24] = 2080;
      *(_QWORD *)&v20[26] = "macos-ioloop.c";
      v21 = 1024;
      v22 = 821;
      v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v16 = v14;
    }
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, (uint8_t *)&v17, 0x36u);
    goto LABEL_19;
  }
}

uint64_t ioloop_connection_input_badness_check(uint64_t a1, uint64_t a2, int a3, NSObject *a4)
{
  NSObject *v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  int v9;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  uint64_t v15;
  __int16 v16;
  uint8_t *v17;
  uint8_t buf[4];
  const char *v19;

  if (a4)
  {
    connection_error_to_string(a4, (char *)buf);
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136446722;
      v13 = "ioloop_connection_input_badness_check";
      v14 = 2048;
      v15 = a1;
      v16 = 2082;
      v17 = buf;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %p: %{public}s", (uint8_t *)&v12, 0x20u);
    }
  }
  else
  {
    if ((*(_WORD *)(a1 + 416) & 0x20) != 0 && a3)
    {
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "ioloop_connection_input_badness_check";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: remote end closed connection.", buf, 0xCu);
      }
      v7 = *(NSObject **)a1;
      v8 = a1;
      v9 = 779;
    }
    else
    {
      if (a2)
        return 0;
      v11 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v19 = "ioloop_connection_input_badness_check";
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: remote end closed connection.", buf, 0xCu);
      }
      v7 = *(NSObject **)a1;
      v8 = a1;
      v9 = 785;
    }
    connection_cancel_(v8, v7, v9);
  }
  return 1;
}

BOOL datagram_read(uint64_t a1, unint64_t a2, NSObject *a3, NSObject *a4)
{
  uint64_t v6;
  int error_code;
  const char *v8;
  NSObject *v9;
  uint64_t v11;
  uint32_t v12;
  int v13;
  _OWORD *v16;
  _OWORD *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD applier[6];
  unsigned __int8 v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;

  v22 = 1;
  if (a4)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      error_code = nw_error_get_error_code(a4);
      *(_DWORD *)buf = 136446466;
      v24 = "datagram_read";
      v25 = 2082;
      v26 = strerror(error_code);
      v8 = "%{public}s: %{public}s";
      v9 = v6;
LABEL_7:
      v12 = 22;
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v8, buf, v12);
      goto LABEL_9;
    }
    goto LABEL_9;
  }
  if (a2 >= 0x10000)
  {
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v24 = "datagram_read";
      v25 = 2048;
      v26 = (char *)a2;
      v8 = "%{public}s: oversized datagram length %zd";
      v9 = v11;
      goto LABEL_7;
    }
LABEL_9:
    v22 = 0;
LABEL_10:
    if (*(_QWORD *)a1)
    {
      connection_cancel_(a1, *(NSObject **)a1, 664);
      v13 = v22;
    }
    else
    {
      v13 = 0;
    }
    return v13 != 0;
  }
  v16 = ioloop_message_create_(a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c", 601);
  if (!v16)
  {
    v20 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_9;
    *(_DWORD *)buf = 136446210;
    v24 = "datagram_read";
    v8 = "%{public}s: unable to allocate message.";
    v9 = v20;
    v12 = 12;
    goto LABEL_8;
  }
  v17 = v16;
  *((_WORD *)v16 + 32) = a2;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = __datagram_read_block_invoke;
  applier[3] = &__block_descriptor_tmp_64;
  applier[4] = v16;
  applier[5] = &v22;
  dispatch_data_apply(a3, applier);
  if (v22)
  {
    v18 = *(_OWORD *)(a1 + 344);
    *(_OWORD *)((char *)v17 + 44) = *(_OWORD *)(a1 + 356);
    v17[2] = v18;
    v19 = *(_QWORD *)(a1 + 24);
    if (!v19)
      v19 = a1;
    (*(void (**)(uint64_t, _OWORD *, _QWORD))(v19 + 208))(a1, v17, *(_QWORD *)(v19 + 200));
  }
  ioloop_message_release_((int *)v17, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c", 661);
  v13 = v22;
  if (!v22)
    goto LABEL_10;
  return v13 != 0;
}

BOOL __datagram_read_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  uint64_t v7;
  size_t v8;
  size_t v9;
  NSObject *v11;
  int v13;
  const char *v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  size_t v18;
  __int16 v19;
  int v20;

  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(unsigned __int16 *)(v7 + 64);
  v9 = __n + a3;
  if (__n + a3 > v8)
  {
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v13 = 136446978;
      v14 = "datagram_read_block_invoke";
      v15 = 2048;
      v16 = a3;
      v17 = 2048;
      v18 = __n;
      v19 = 1024;
      v20 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: data region %zd:%zd is out of range for message length %d", (uint8_t *)&v13, 0x26u);
    }
    **(_BYTE **)(a1 + 40) = 0;
  }
  else
  {
    memcpy((void *)(v7 + a3 + 88), __src, __n);
  }
  return v9 <= v8;
}

void __ioloop_tcp_input_start_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3, int a4, NSObject *a5)
{
  uint64_t v8;
  NSObject *v9;
  unsigned int v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  const char *v16;
  NSObject *v17;
  NSObject *v18;
  uint64_t v19;
  int v20;
  NSObject *v21;
  NSObject *v22;
  NSObject *v23;
  unsigned __int16 *v24;
  size_t size_ptr;
  _BYTE buf[48];
  __int16 v27;
  int v28;

  if ((ioloop_connection_input_badness_check(*(_QWORD *)(a1 + 32), (uint64_t)a2, a4, a5) & 1) == 0)
  {
    v8 = *(_QWORD *)(a1 + 32);
    if ((check_fail(v8, 2, a2, (uint64_t)a5, (uint64_t)"tcp_read_length") & 1) == 0)
    {
      v24 = 0;
      size_ptr = 0;
      v9 = dispatch_data_create_map(a2, (const void **)&v24, &size_ptr);
      if (v9)
      {
        dispatch_release(v9);
        v10 = *v24;
        if (v8)
        {
          v11 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v12 = *(_DWORD *)(v8 + 32);
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "tcp_read_length";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v12;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v8;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "connection";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "macos-ioloop.c";
            v27 = 1024;
            v28 = 750;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          v13 = *(_DWORD *)(v8 + 32);
          if (v13)
          {
            v14 = v13 + 1;
            *(_DWORD *)(v8 + 32) = v13 + 1;
            if (v13 + 1 >= 10001)
            {
              v15 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_32;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "tcp_read_length";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v14;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v8;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "connection";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "macos-ioloop.c";
              v27 = 1024;
              v28 = 750;
              v16 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_28:
              v23 = v15;
              goto LABEL_31;
            }
          }
          else
          {
            ++comm_created;
            *(_DWORD *)(v8 + 32) = 1;
          }
        }
        v18 = *(NSObject **)v8;
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __tcp_read_length_block_invoke;
        *(_QWORD *)&buf[24] = &__block_descriptor_tmp_61;
        *(_QWORD *)&buf[32] = v8;
        *(_DWORD *)&buf[40] = __rev16(v10);
        nw_connection_receive(v18, *(uint32_t *)&buf[40], *(uint32_t *)&buf[40], buf);
      }
      else
      {
        v17 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "tcp_read_length";
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%{public}s: tcp_read_length: map create failed", buf, 0xCu);
        }
        connection_cancel_(v8, *(NSObject **)v8, 745);
      }
    }
  }
  v19 = *(_QWORD *)(a1 + 32);
  if (v19)
  {
    v20 = *(_DWORD *)(v19 + 32);
    if (!v20)
    {
      v15 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_32;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_tcp_input_start_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v27 = 1024;
      v28 = 805;
      v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_28;
    }
    v21 = global_os_log;
    if (v20 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_32;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_tcp_input_start_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v20;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v27 = 1024;
      v28 = 805;
      v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v23 = v21;
LABEL_31:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, v16, buf, 0x36u);
LABEL_32:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "ioloop_tcp_input_start_block_invoke";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v20;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "macos-ioloop.c";
      v27 = 1024;
      v28 = 805;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v19 = *(_QWORD *)(a1 + 32);
      v20 = *(_DWORD *)(v19 + 32);
    }
    *(_DWORD *)(v19 + 32) = v20 - 1;
    if (v20 == 1)
    {
      v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "ioloop_tcp_input_start_block_invoke";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = "connection";
        *(_WORD *)&buf[32] = 2080;
        *(_QWORD *)&buf[34] = "macos-ioloop.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 805;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v19 = *(_QWORD *)(a1 + 32);
      }
      ++comm_finalized;
      comm_finalize(v19);
    }
  }
}

uint64_t check_fail(uint64_t a1, uint64_t a2, NSObject *a3, uint64_t a4, uint64_t a5)
{
  NSObject *v10;
  uint64_t v11;
  size_t size;
  uint64_t v14;
  size_t v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  uint64_t v19;
  size_t v20;
  size_t v21;
  int v22;
  const char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  size_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  size_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;

  v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *(_QWORD *)(a1 + 192);
    if (a3)
      size = dispatch_data_get_size(a3);
    else
      size = -1;
    v22 = 136448003;
    v23 = "check_fail";
    v24 = 2160;
    v25 = 1752392040;
    v26 = 2081;
    v27 = v11;
    v28 = 2048;
    v29 = a2;
    v30 = 2048;
    v31 = (uint64_t)a3;
    v32 = 2048;
    v33 = size;
    v34 = 2048;
    v35 = a4;
    v36 = 2080;
    v37 = a5;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s: length %zd, content %p, content_length %ld, error %p, source %s", (uint8_t *)&v22, 0x52u);
  }
  if (a4)
    goto LABEL_7;
  if (*(_QWORD *)a1)
  {
    if (a3)
    {
      if (dispatch_data_get_size(a3) == a2)
        return 0;
      v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_7;
      v20 = dispatch_data_get_size(a3);
      v21 = *(_QWORD *)(a1 + 192);
      v22 = 136447491;
      v23 = "check_fail";
      v24 = 2082;
      v25 = a5;
      v26 = 2048;
      v27 = a2;
      v28 = 2048;
      v29 = v20;
      v30 = 2160;
      v31 = 1752392040;
      v32 = 2081;
      v33 = v21;
      v16 = "%{public}s: short content returned in %{public}s: %zd != %zd: connection must have dropped unexpectedly for "
            "%{private, mask.hash}s";
      v17 = v19;
      v18 = 62;
    }
    else
    {
      v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_7;
      v15 = *(_QWORD *)(a1 + 192);
      v22 = 136446979;
      v23 = "check_fail";
      v24 = 2082;
      v25 = a5;
      v26 = 2160;
      v27 = 1752392040;
      v28 = 2081;
      v29 = v15;
      v16 = "%{public}s: no content returned in %{public}s: connection must have dropped unexpectedly for %{private, mask.hash}s";
      v17 = v14;
      v18 = 42;
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&v22, v18);
LABEL_7:
    if (*(_QWORD *)a1)
      connection_cancel_(a1, *(NSObject **)a1, 712);
  }
  return 1;
}

void __tcp_read_length_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, NSObject *a5)
{
  NSObject *v6;
  uint64_t v7;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  NSObject *v14;
  uint64_t v15;
  const char *v16;
  NSObject *v17;
  int v18;
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint8_t *v23;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  _BYTE v27[34];
  __int16 v28;
  int v29;

  if (a5)
  {
    connection_error_to_string(a5, (char *)buf);
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(a1 + 32);
      v18 = 136446722;
      v19 = "tcp_read_length_block_invoke";
      v20 = 2048;
      v21 = v7;
      v22 = 2082;
      v23 = buf;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %p: %{public}s", (uint8_t *)&v18, 0x20u);
    }
  }
  else
  {
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(unsigned int *)(a1 + 40);
    if ((check_fail(v9, v10, a2, 0, (uint64_t)"tcp_read") & 1) == 0 && datagram_read(v9, v10, a2, 0))
      ioloop_tcp_input_start(v9);
  }
  v11 = *(_QWORD *)(a1 + 32);
  if (v11)
  {
    v12 = *(_DWORD *)(v11 + 32);
    if (v12)
    {
      v13 = global_os_log;
      if (v12 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v25 = "tcp_read_length_block_invoke";
          v26 = 1024;
          *(_DWORD *)v27 = v12;
          *(_WORD *)&v27[4] = 2048;
          *(_QWORD *)&v27[6] = v11;
          *(_WORD *)&v27[14] = 2080;
          *(_QWORD *)&v27[16] = "connection";
          *(_WORD *)&v27[24] = 2080;
          *(_QWORD *)&v27[26] = "macos-ioloop.c";
          v28 = 1024;
          v29 = 762;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v11 = *(_QWORD *)(a1 + 32);
          v12 = *(_DWORD *)(v11 + 32);
        }
        *(_DWORD *)(v11 + 32) = v12 - 1;
        if (v12 == 1)
        {
          v14 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v25 = "tcp_read_length_block_invoke";
            v26 = 2048;
            *(_QWORD *)v27 = v11;
            *(_WORD *)&v27[8] = 2080;
            *(_QWORD *)&v27[10] = "connection";
            *(_WORD *)&v27[18] = 2080;
            *(_QWORD *)&v27[20] = "macos-ioloop.c";
            *(_WORD *)&v27[28] = 1024;
            *(_DWORD *)&v27[30] = 762;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            v11 = *(_QWORD *)(a1 + 32);
          }
          ++comm_finalized;
          comm_finalize(v11);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_22:
        abort();
      *(_DWORD *)buf = 136447490;
      v25 = "tcp_read_length_block_invoke";
      v26 = 1024;
      *(_DWORD *)v27 = v12;
      *(_WORD *)&v27[4] = 2048;
      *(_QWORD *)&v27[6] = v11;
      *(_WORD *)&v27[14] = 2080;
      *(_QWORD *)&v27[16] = "connection";
      *(_WORD *)&v27[24] = 2080;
      *(_QWORD *)&v27[26] = "macos-ioloop.c";
      v28 = 1024;
      v29 = 762;
      v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v17 = v13;
    }
    else
    {
      v15 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_22;
      *(_DWORD *)buf = 136447490;
      v25 = "tcp_read_length_block_invoke";
      v26 = 1024;
      *(_DWORD *)v27 = 0;
      *(_WORD *)&v27[4] = 2048;
      *(_QWORD *)&v27[6] = v11;
      *(_WORD *)&v27[14] = 2080;
      *(_QWORD *)&v27[16] = "connection";
      *(_WORD *)&v27[24] = 2080;
      *(_QWORD *)&v27[26] = "macos-ioloop.c";
      v28 = 1024;
      v29 = 762;
      v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v17 = v15;
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v16, buf, 0x36u);
    goto LABEL_22;
  }
}

uint64_t ioloop_read_event(uint64_t result)
{
  uint64_t (*v1)(uint64_t, _QWORD);

  v1 = *(uint64_t (**)(uint64_t, _QWORD))(result + 16);
  if (v1)
    return v1(result, *(_QWORD *)(result + 56));
  return result;
}

void ioloop_read_source_cancel_callback(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  NSObject *v8;
  int v9;
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_DWORD *)(a1 + 92);
    v4 = *(_QWORD *)(a1 + 72);
    v5 = *(_QWORD *)(a1 + 80);
    v9 = 136447234;
    v10 = "ioloop_read_source_cancel_callback";
    v11 = 2048;
    v12 = a1;
    v13 = 1024;
    v14 = v3;
    v15 = 2048;
    v16 = v4;
    v17 = 2048;
    v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: io %p fd %d, read source %p, write_source %p", (uint8_t *)&v9, 0x30u);
  }
  v6 = *(NSObject **)(a1 + 72);
  if (v6)
  {
    dispatch_release(v6);
    *(_QWORD *)(a1 + 72) = 0;
    v7 = *(_DWORD *)(a1 + 92);
    if (v7 == -1)
    {
      v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v9 = 136446210;
        v10 = "ioloop_read_source_cancel_callback";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: io->fd has been set to -1 too early", (uint8_t *)&v9, 0xCu);
      }
    }
    else
    {
      close(v7);
      *(_DWORD *)(a1 + 92) = -1;
    }
  }
}

void ioloop_read_source_finalize(_DWORD *a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  void (*v6)(_QWORD);
  int v7;
  NSObject *v8;
  NSObject *v9;
  int v10;
  void (*v11)(_QWORD);
  const char *v12;
  int v13;
  const char *v14;
  __int16 v15;
  _BYTE v16[34];
  __int16 v17;
  int v18;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = a1[23];
    v4 = *((_QWORD *)a1 + 9);
    v5 = *((_QWORD *)a1 + 10);
    v13 = 136447234;
    v14 = "ioloop_read_source_finalize";
    v15 = 2048;
    *(_QWORD *)v16 = a1;
    *(_WORD *)&v16[8] = 1024;
    *(_DWORD *)&v16[10] = v3;
    *(_WORD *)&v16[14] = 2048;
    *(_QWORD *)&v16[16] = v4;
    *(_WORD *)&v16[24] = 2048;
    *(_QWORD *)&v16[26] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: io %p fd %d, read source %p, write_source %p", (uint8_t *)&v13, 0x30u);
  }
  if (*((_BYTE *)a1 + 88))
  {
    v6 = (void (*)(_QWORD))*((_QWORD *)a1 + 6);
    if (v6)
      v6(*((_QWORD *)a1 + 7));
    ++file_descriptor_finalized;
    return;
  }
  v7 = *a1;
  if (!*a1)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_25;
    v13 = 136447490;
    v14 = "ioloop_read_source_finalize";
    v15 = 1024;
    *(_DWORD *)v16 = 0;
    *(_WORD *)&v16[4] = 2048;
    *(_QWORD *)&v16[6] = a1;
    *(_WORD *)&v16[14] = 2080;
    *(_QWORD *)&v16[16] = "io";
    *(_WORD *)&v16[24] = 2080;
    *(_QWORD *)&v16[26] = "macos-ioloop.c";
    v17 = 1024;
    v18 = 2311;
    v12 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_24;
  }
  v8 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_25;
    v13 = 136447490;
    v14 = "ioloop_read_source_finalize";
    v15 = 1024;
    *(_DWORD *)v16 = v7;
    *(_WORD *)&v16[4] = 2048;
    *(_QWORD *)&v16[6] = a1;
    *(_WORD *)&v16[14] = 2080;
    *(_QWORD *)&v16[16] = "io";
    *(_WORD *)&v16[24] = 2080;
    *(_QWORD *)&v16[26] = "macos-ioloop.c";
    v17 = 1024;
    v18 = 2311;
    v12 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_24:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v13, 0x36u);
LABEL_25:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v13 = 136447490;
    v14 = "ioloop_read_source_finalize";
    v15 = 1024;
    *(_DWORD *)v16 = v7;
    *(_WORD *)&v16[4] = 2048;
    *(_QWORD *)&v16[6] = a1;
    *(_WORD *)&v16[14] = 2080;
    *(_QWORD *)&v16[16] = "io";
    *(_WORD *)&v16[24] = 2080;
    *(_QWORD *)&v16[26] = "macos-ioloop.c";
    v17 = 1024;
    v18 = 2311;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v13, 0x36u);
    v7 = *a1;
  }
  *a1 = v7 - 1;
  if (v7 == 1)
  {
    v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v13 = 136447234;
      v14 = "ioloop_read_source_finalize";
      v15 = 2048;
      *(_QWORD *)v16 = a1;
      *(_WORD *)&v16[8] = 2080;
      *(_QWORD *)&v16[10] = "io";
      *(_WORD *)&v16[18] = 2080;
      *(_QWORD *)&v16[20] = "macos-ioloop.c";
      *(_WORD *)&v16[28] = 1024;
      *(_DWORD *)&v16[30] = 2311;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v13, 0x30u);
      v10 = *a1;
      ++file_descriptor_finalized;
      if (v10)
        return;
    }
    else
    {
      ++file_descriptor_finalized;
    }
    v11 = (void (*)(_QWORD))*((_QWORD *)a1 + 4);
    if (v11)
      v11(*((_QWORD *)a1 + 7));
    free(a1);
  }
}

void __ioloop_connection_create_block_invoke_26(uint64_t a1, int a2, NSObject *a3)
{
  ioloop_connection_state_changed(*(_QWORD **)(a1 + 32), a2, a3);
}

void ioloop_dnssd_txn_cancel(uint64_t a1)
{
  _DNSServiceRef_t *v2;
  NSObject *v3;
  _BOOL4 v4;
  int v5;
  const char *v6;
  __int16 v7;
  uint64_t v8;
  __int16 v9;
  _DNSServiceRef_t *v10;

  v2 = *(_DNSServiceRef_t **)(a1 + 8);
  v3 = global_os_log;
  v4 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      v5 = 136446722;
      v6 = "ioloop_dnssd_txn_cancel";
      v7 = 2048;
      v8 = a1;
      v9 = 2048;
      v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: txn %p serviceref %p", (uint8_t *)&v5, 0x20u);
      v2 = *(_DNSServiceRef_t **)(a1 + 8);
    }
    DNSServiceRefDeallocate(v2);
    *(_QWORD *)(a1 + 8) = 0;
  }
  else if (v4)
  {
    v5 = 136446210;
    v6 = "ioloop_dnssd_txn_cancel";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: dead transaction.", (uint8_t *)&v5, 0xCu);
  }
}

void ioloop_dnssd_txn_release_(int *a1, char *a2, int a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  void (*v10)(_QWORD);
  const char *v11;
  int v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  if (!a1)
    return;
  v6 = *a1;
  if (!*a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_20;
    v12 = 136447490;
    v13 = "ioloop_dnssd_txn_release_";
    v14 = 1024;
    *(_DWORD *)v15 = 0;
    *(_WORD *)&v15[4] = 2048;
    *(_QWORD *)&v15[6] = a1;
    *(_WORD *)&v15[14] = 2080;
    *(_QWORD *)&v15[16] = "dnssd_txn";
    *(_WORD *)&v15[24] = 2080;
    *(_QWORD *)&v15[26] = strrchr(a2, 47) + 1;
    v16 = 1024;
    v17 = a3;
    v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_19;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_20;
    v12 = 136447490;
    v13 = "ioloop_dnssd_txn_release_";
    v14 = 1024;
    *(_DWORD *)v15 = v6;
    *(_WORD *)&v15[4] = 2048;
    *(_QWORD *)&v15[6] = a1;
    *(_WORD *)&v15[14] = 2080;
    *(_QWORD *)&v15[16] = "dnssd_txn";
    *(_WORD *)&v15[24] = 2080;
    *(_QWORD *)&v15[26] = strrchr(a2, 47) + 1;
    v16 = 1024;
    v17 = a3;
    v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
LABEL_20:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 136447490;
    v13 = "ioloop_dnssd_txn_release_";
    v14 = 1024;
    *(_DWORD *)v15 = v6;
    *(_WORD *)&v15[4] = 2048;
    *(_QWORD *)&v15[6] = a1;
    *(_WORD *)&v15[14] = 2080;
    *(_QWORD *)&v15[16] = "dnssd_txn";
    *(_WORD *)&v15[24] = 2080;
    *(_QWORD *)&v15[26] = strrchr(a2, 47) + 1;
    v16 = 1024;
    v17 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
    v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      v12 = 136447234;
      v13 = "ioloop_dnssd_txn_release_";
      v14 = 2048;
      *(_QWORD *)v15 = a1;
      *(_WORD *)&v15[8] = 2080;
      *(_QWORD *)&v15[10] = "dnssd_txn";
      *(_WORD *)&v15[18] = 2080;
      *(_QWORD *)&v15[20] = v9 + 1;
      *(_WORD *)&v15[28] = 1024;
      *(_DWORD *)&v15[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
    }
    ++dnssd_txn_finalized;
    if (*((_QWORD *)a1 + 1))
      ioloop_dnssd_txn_cancel((uint64_t)a1);
    v10 = (void (*)(_QWORD))*((_QWORD *)a1 + 4);
    if (v10)
      v10(*((_QWORD *)a1 + 2));
    free(a1);
  }
}

_QWORD *ioloop_dnssd_txn_add_subordinate_(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  _QWORD *v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  NSObject *v15;
  char *v16;
  NSObject *v17;
  int v19;
  const char *v20;
  __int16 v21;
  _BYTE v22[24];
  __int16 v23;
  char *v24;
  __int16 v25;
  int v26;

  v10 = malloc_type_calloc(1uLL, 0x30uLL, 0x10A004060EFF21DuLL);
  if (v10)
  {
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_DWORD *)v10;
      v19 = 136447490;
      v20 = "ioloop_dnssd_txn_add_subordinate_";
      v21 = 1024;
      *(_DWORD *)v22 = v12;
      *(_WORD *)&v22[4] = 2048;
      *(_QWORD *)&v22[6] = v10;
      *(_WORD *)&v22[14] = 2080;
      *(_QWORD *)&v22[16] = "txn";
      v23 = 2080;
      v24 = strrchr(a4, 47) + 1;
      v25 = 1024;
      v26 = a5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
    }
    v13 = *(_DWORD *)v10;
    if (*(_DWORD *)v10)
    {
      v14 = v13 + 1;
      *(_DWORD *)v10 = v13 + 1;
      if (v13 + 1 >= 10001)
      {
        v15 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v16 = strrchr(a4, 47);
          v19 = 136447490;
          v20 = "ioloop_dnssd_txn_add_subordinate_";
          v21 = 1024;
          *(_DWORD *)v22 = v14;
          *(_WORD *)&v22[4] = 2048;
          *(_QWORD *)&v22[6] = v10;
          *(_WORD *)&v22[14] = 2080;
          *(_QWORD *)&v22[16] = "txn";
          v23 = 2080;
          v24 = v16 + 1;
          v25 = 1024;
          v26 = a5;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++dnssd_txn_created;
      *(_DWORD *)v10 = 1;
    }
    v10[1] = a1;
    v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v19 = 136446722;
      v20 = "ioloop_dnssd_txn_add_subordinate_";
      v21 = 2048;
      *(_QWORD *)v22 = v10;
      *(_WORD *)&v22[8] = 2048;
      *(_QWORD *)&v22[10] = a1;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: txn %p serviceref %p", (uint8_t *)&v19, 0x20u);
    }
    v10[2] = a2;
    v10[4] = a3;
  }
  return v10;
}

_QWORD *ioloop_dnssd_txn_add_(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  _QWORD *v6;
  int v7;
  uint64_t v9;
  NSObject *v10;
  NSObject *v11;
  _QWORD v12[4];
  int v13;
  _QWORD handler[5];

  v6 = ioloop_dnssd_txn_add_subordinate_(a1, a2, a3, a4, a5);
  if (v6)
  {
    if (a1)
    {
      v7 = *(_DWORD *)(a1 + 16);
      if (v7 < 0 || (*(_DWORD *)(a1 + 20) ^ v7) != 0x12345678)
      {
        syslog(4, "dnssd_clientstub DNSServiceRefSockFD called with invalid DNSServiceRef %p %08X %08X");
      }
      else if (*(_QWORD *)(a1 + 8))
      {
        syslog(4, "dnssd_clientstub DNSServiceRefSockFD undefined for kDNSServiceFlagsShareConnection subordinate DNSServiceRef %p");
      }
      else
      {
        v9 = ioloop_main_queue;
        if (ioloop_main_queue)
        {
          if (*(_QWORD *)(a1 + 96))
          {
            syslog(4, "dnssd_clientstub DNSServiceSetDispatchQueue dispatch queue set already");
          }
          else if (*(_QWORD *)(a1 + 88))
          {
            syslog(4, "dnssd_clientstub DNSServiceSetDispatchQueue dispatch source set already");
          }
          else
          {
            v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(unsigned int *)(a1 + 16), 0, (dispatch_queue_t)ioloop_main_queue);
            *(_QWORD *)(a1 + 88) = v10;
            if (v10)
            {
              *(_QWORD *)(a1 + 96) = v9;
              handler[0] = _NSConcreteStackBlock;
              handler[1] = 0x40000000;
              handler[2] = __DNSServiceSetDispatchQueue_block_invoke;
              handler[3] = &__block_descriptor_tmp;
              handler[4] = a1;
              dispatch_source_set_event_handler(v10, handler);
              v11 = *(NSObject **)(a1 + 88);
              v12[0] = _NSConcreteStackBlock;
              v12[1] = 0x40000000;
              v12[2] = __DNSServiceSetDispatchQueue_block_invoke_2;
              v12[3] = &__block_descriptor_tmp_36;
              v13 = v7;
              dispatch_source_set_cancel_handler(v11, v12);
              dispatch_resume(*(dispatch_object_t *)(a1 + 88));
            }
            else
            {
              syslog(4, "dnssd_clientstub DNSServiceSetDispatchQueue dispatch_source_create failed");
            }
          }
        }
        else
        {
          syslog(4, "dnssd_clientstub: DNSServiceSetDispatchQueue dispatch queue NULL");
        }
      }
    }
    else
    {
      syslog(4, "dnssd_clientstub DNSServiceRefSockFD called with NULL DNSServiceRef");
    }
  }
  return v6;
}

_xpc_connection_s *ioloop_create_xpc_service(uint64_t a1)
{
  xpc_connection_t mach_service;
  _xpc_connection_s *v3;
  NSObject *v4;
  _QWORD handler[7];
  uint8_t buf[4];
  const char *v8;
  __int16 v9;
  const char *v10;
  __int16 v11;
  _xpc_connection_s *v12;

  mach_service = xpc_connection_create_mach_service("com.apple.srp-mdns-proxy.proxy", (dispatch_queue_t)ioloop_main_queue, 1uLL);
  v3 = mach_service;
  if (mach_service && xpc_get_type(mach_service) == (xpc_type_t)&_xpc_type_connection)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = __ioloop_create_xpc_service_block_invoke;
    handler[3] = &__block_descriptor_tmp_36_1317;
    handler[4] = "com.apple.srp-mdns-proxy.proxy";
    handler[5] = adv_xpc_message;
    handler[6] = a1;
    xpc_connection_set_event_handler(v3, handler);
    xpc_connection_resume(v3);
  }
  else
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      v8 = "ioloop_create_xpc_service";
      v9 = 2082;
      v10 = "com.apple.srp-mdns-proxy.proxy";
      v11 = 2048;
      v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_create_xpc_service: %{public}s: unable to create listener %p", buf, 0x20u);
    }
    if (v3)
    {
      xpc_release(v3);
      return 0;
    }
  }
  return v3;
}

void __ioloop_create_xpc_service_block_invoke(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type;
  NSObject *v5;
  const char *v6;
  NSObject *v7;
  os_log_type_t v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  pid_t pid;
  uid_t euid;
  void *v16;
  void *v17;
  uint64_t v18;
  NSObject *v19;
  BOOL value;
  NSObject *v21;
  int8x16_t v22;
  _BYTE buf[24];
  __int128 v24;
  int8x16_t v25;

  type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_connection)
  {
    v5 = global_os_log;
    if (type != (xpc_type_t)&_xpc_type_error)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "ioloop_create_xpc_service_block_invoke";
      v6 = "%{public}s: Unknown EventMsg type";
      v7 = v5;
      v8 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_20;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "ioloop_create_xpc_service_block_invoke";
      *(_WORD *)&buf[12] = 2082;
      *(_QWORD *)&buf[14] = xpc_dictionary_get_string(object, _xpc_error_key_description);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_create_xpc_service: XPCError: %{public}s", buf, 0x16u);
    }
    (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 40))(0, 0, *(_QWORD *)(a1 + 48));
    return;
  }
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "ioloop_create_xpc_service_block_invoke";
    *(_WORD *)&buf[12] = 2082;
    *(_QWORD *)&buf[14] = v10;
    *(_WORD *)&buf[22] = 2048;
    *(_QWORD *)&v24 = object;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: New %{public}s Client %p", buf, 0x20u);
  }
  if (!object)
  {
    v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "ioloop_xpc_accept";
    v6 = "%{public}s: ioloop_xpc_accept: listener has been canceled.";
LABEL_19:
    v7 = v18;
    v8 = OS_LOG_TYPE_ERROR;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v7, v8, v6, buf, 0xCu);
    return;
  }
  v11 = *(_QWORD *)(a1 + 32);
  v22 = *(int8x16_t *)(a1 + 40);
  v12 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v12)
  {
    v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "ioloop_xpc_accept";
    v6 = "%{public}s: ioloop_xpc_accept: no memory for xpc connection state.";
    goto LABEL_19;
  }
  v13 = v12;
  pid = xpc_connection_get_pid((xpc_connection_t)object);
  euid = xpc_connection_get_euid((xpc_connection_t)object);
  v16 = (void *)xpc_connection_copy_entitlement_value(object, v11);
  if (v16)
  {
    v17 = v16;
    if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_BOOL)
    {
      value = xpc_BOOL_get_value(v17);
      xpc_release(v17);
      if (value)
      {
        *v13 = object;
        xpc_retain(object);
        v13[1] = v22.i64[0];
        xpc_connection_set_target_queue((xpc_connection_t)object, (dispatch_queue_t)ioloop_main_queue);
        *(_QWORD *)buf = _NSConcreteStackBlock;
        *(_QWORD *)&buf[8] = 0x40000000;
        *(_QWORD *)&buf[16] = __ioloop_xpc_accept_block_invoke;
        *(_QWORD *)&v24 = &__block_descriptor_tmp_66;
        *((_QWORD *)&v24 + 1) = v13;
        v25 = vextq_s8(v22, v22, 8uLL);
        xpc_connection_set_event_handler((xpc_connection_t)object, buf);
        xpc_connection_resume((xpc_connection_t)object);
        return;
      }
    }
    else
    {
      xpc_release(v17);
    }
  }
  else
  {
    v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "ioloop_xpc_client_is_entitled";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_xpc_client_is_entitled: Client Entitlement is NULL", buf, 0xCu);
    }
  }
  v21 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "ioloop_xpc_client_is_entitled";
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_xpc_client_is_entitled: Client is missing Entitlement!", buf, 0xCu);
    v21 = global_os_log;
  }
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "ioloop_xpc_accept";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = euid;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = pid;
    LOWORD(v24) = 2082;
    *(_QWORD *)((char *)&v24 + 2) = v11;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_xpc_accept: connection from uid %d pid %d is missing entitlement %{public}s.", buf, 0x22u);
  }
  xpc_connection_cancel((xpc_connection_t)object);
  free(v13);
}

void __ioloop_xpc_accept_block_invoke(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type;
  NSObject *v5;
  _QWORD *v6;
  NSObject *v7;
  xpc_object_t *v8;
  void (*v9)(_QWORD, _QWORD, _QWORD);
  _QWORD *v10;
  uint64_t (*v11)(_QWORD, xpc_object_t, _QWORD);
  char v12;
  NSObject *v13;
  _BOOL4 v14;
  int v15;
  const char *v16;

  type = xpc_get_type(object);
  if (object == &_xpc_error_connection_invalid)
  {
    v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v15 = 136446210;
      v16 = "ioloop_xpc_accept_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: connection has been finalized.", (uint8_t *)&v15, 0xCu);
    }
    v8 = *(xpc_object_t **)(a1 + 32);
    v9 = (void (*)(_QWORD, _QWORD, _QWORD))v8[1];
    if (v9)
    {
      v9(*v8, 0, *(_QWORD *)(a1 + 40));
      v8 = *(xpc_object_t **)(a1 + 32);
    }
    if (*v8)
    {
      xpc_release(*v8);
      **(_QWORD **)(a1 + 32) = 0;
      v8 = *(xpc_object_t **)(a1 + 32);
    }
    free(v8);
  }
  else
  {
    if (type != (xpc_type_t)&_xpc_type_dictionary)
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v15 = 136446210;
        v16 = "ioloop_xpc_accept_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: client went away.", (uint8_t *)&v15, 0xCu);
      }
      xpc_connection_cancel(**(xpc_connection_t **)(a1 + 32));
      v6 = *(_QWORD **)(a1 + 32);
      if (!v6[1])
        goto LABEL_22;
      (*(void (**)(_QWORD, _QWORD, _QWORD))(a1 + 48))(*v6, 0, *(_QWORD *)(a1 + 40));
LABEL_21:
      v6 = *(_QWORD **)(a1 + 32);
LABEL_22:
      v6[1] = 0;
      return;
    }
    v10 = *(_QWORD **)(a1 + 32);
    v11 = (uint64_t (*)(_QWORD, xpc_object_t, _QWORD))v10[1];
    if (!v11)
      return;
    v12 = v11(*v10, object, *(_QWORD *)(a1 + 40));
    v13 = global_os_log;
    v14 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if ((v12 & 1) == 0)
    {
      if (v14)
      {
        v15 = 136446210;
        v16 = "ioloop_xpc_accept_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: callback indicated done.", (uint8_t *)&v15, 0xCu);
      }
      xpc_connection_cancel(**(xpc_connection_t **)(a1 + 32));
      goto LABEL_21;
    }
    if (v14)
    {
      v15 = 136446210;
      v16 = "ioloop_xpc_accept_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: continuing.", (uint8_t *)&v15, 0xCu);
    }
  }
}

uint64_t __ioloop_run_async_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

void service_tracker_finalize(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = a1[6];
  if (v2)
  {
    do
    {
      v3 = *(_QWORD *)(v2 + 8);
      thread_service_release_((int *)v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 83);
      v2 = v3;
    }
    while (v3);
  }
  free(a1);
}

void service_tracker_start(_QWORD *a1)
{
  uint64_t v2;
  _QWORD *v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  NSObject *v9;
  xpc_object_t v10;
  int v11;
  NSObject *v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  _BYTE v25[34];
  __int16 v26;
  int v27;

  v3 = a1 + 4;
  v2 = a1[4];
  if (v2)
  {
    cti_events_discontinue(v2);
    *v3 = 0;
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v5 = a1[1];
      *(_DWORD *)buf = 136446466;
      v23 = "service_tracker_start";
      v24 = 2048;
      *(_QWORD *)v25 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] restarting", buf, 0x16u);
    }
    v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 == 1)
    {
      v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "service_tracker_start";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: service tracker reference count should not be 1 here!", buf, 0xCu);
      }
    }
    else
    {
      if (!v6)
      {
        v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_34;
        *(_DWORD *)buf = 136447490;
        v23 = "service_tracker_start";
        v24 = 1024;
        *(_DWORD *)v25 = 0;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = a1;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "tracker";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "service-tracker.c";
        v26 = 1024;
        v27 = 382;
        v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_30:
        v21 = v19;
LABEL_33:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v20, buf, 0x36u);
        goto LABEL_34;
      }
      v7 = global_os_log;
      if (v6 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_34;
        *(_DWORD *)buf = 136447490;
        v23 = "service_tracker_start";
        v24 = 1024;
        *(_DWORD *)v25 = v6;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = a1;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "tracker";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "service-tracker.c";
        v26 = 1024;
        v27 = 382;
        v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v21 = v7;
        goto LABEL_33;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v23 = "service_tracker_start";
        v24 = 1024;
        *(_DWORD *)v25 = v6;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = a1;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "tracker";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "service-tracker.c";
        v26 = 1024;
        v27 = 382;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v6 = *(_DWORD *)a1;
      }
      *(_DWORD *)a1 = v6 - 1;
      if (v6 == 1)
      {
        v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v23 = "service_tracker_start";
          v24 = 2048;
          *(_QWORD *)v25 = a1;
          *(_WORD *)&v25[8] = 2080;
          *(_QWORD *)&v25[10] = "tracker";
          *(_WORD *)&v25[18] = 2080;
          *(_QWORD *)&v25[20] = "service-tracker.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 382;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++service_tracker_finalized;
        service_tracker_finalize(a1);
      }
    }
  }
  v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v10, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v10, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v10, "method", "PropGet");
  xpc_dictionary_set_string(v10, "property_name", "Thread:Services");
  v11 = setup_for_command(v3, (uint64_t)"get_service_list", "Thread:Services", 0, v10, (uint64_t)a1, (uint64_t)service_tracker_callback, (uint64_t)cti_internal_service_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 388);
  xpc_release(v10);
  v12 = global_os_log;
  v13 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (v13)
    {
      v15 = a1[1];
      *(_DWORD *)buf = 136446466;
      v23 = "service_tracker_start";
      v24 = 2048;
      *(_QWORD *)v25 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] service list get started", buf, 0x16u);
      v12 = global_os_log;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      v16 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      v23 = "service_tracker_start";
      v24 = 1024;
      *(_DWORD *)v25 = v16;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = a1;
      *(_WORD *)&v25[14] = 2080;
      *(_QWORD *)&v25[16] = "tracker";
      *(_WORD *)&v25[24] = 2080;
      *(_QWORD *)&v25[26] = "service-tracker.c";
      v26 = 1024;
      v27 = 394;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v17 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      ++service_tracker_created;
      *(_DWORD *)a1 = 1;
      return;
    }
    v18 = v17 + 1;
    *(_DWORD *)a1 = v17 + 1;
    if (v17 + 1 < 10001)
      return;
    v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_34:
      abort();
    *(_DWORD *)buf = 136447490;
    v23 = "service_tracker_start";
    v24 = 1024;
    *(_DWORD *)v25 = v18;
    *(_WORD *)&v25[4] = 2048;
    *(_QWORD *)&v25[6] = a1;
    *(_WORD *)&v25[14] = 2080;
    *(_QWORD *)&v25[16] = "tracker";
    *(_WORD *)&v25[24] = 2080;
    *(_QWORD *)&v25[26] = "service-tracker.c";
    v26 = 1024;
    v27 = 394;
    v20 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
    goto LABEL_30;
  }
  if (v13)
  {
    v14 = a1[1];
    *(_DWORD *)buf = 136446722;
    v23 = "service_tracker_start";
    v24 = 2048;
    *(_QWORD *)v25 = v14;
    *(_WORD *)&v25[8] = 1024;
    *(_DWORD *)&v25[10] = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] service list get failed: %d", buf, 0x1Cu);
  }
}

void service_tracker_callback(uint64_t a1, unint64_t *a2, int a3)
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t *v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  NSObject *v21;
  uint64_t v22;
  int v23;
  NSObject *v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  unint64_t i;
  uint64_t *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  int v35;
  int v36;
  uint64_t v37;
  int v38;
  int v39;
  int v41;
  _DWORD *v42;
  int v43;
  NSObject *v44;
  uint64_t v45;
  uint64_t j;
  uint64_t k;
  uint64_t **m;
  uint64_t v49;
  const char *v50;
  char __str[48];
  __int16 v52;
  int v53;
  char v54[20];

  *(_BYTE *)(a1 + 58) = 0;
  if (a3 == -65569 || a3 == -65563)
  {
    v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v22 = *(_QWORD *)(a1 + 8);
      *(_DWORD *)__str = 136446466;
      *(_QWORD *)&__str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 2048;
      *(_QWORD *)&__str[14] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] disconnected", (uint8_t *)__str, 0x16u);
    }
    cti_events_discontinue(*(_QWORD *)(a1 + 32));
    *(_QWORD *)(a1 + 32) = 0;
    v23 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v24 = global_os_log;
      if (v23 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__str = 136447490;
          *(_QWORD *)&__str[4] = "service_tracker_callback";
          *(_WORD *)&__str[12] = 1024;
          *(_DWORD *)&__str[14] = v23;
          *(_WORD *)&__str[18] = 2048;
          *(_QWORD *)&__str[20] = a1;
          *(_WORD *)&__str[28] = 2080;
          *(_QWORD *)&__str[30] = "tracker";
          *(_WORD *)&__str[38] = 2080;
          *(_QWORD *)&__str[40] = "service-tracker.c";
          v52 = 1024;
          v53 = 148;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)__str, 0x36u);
          v23 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v23 - 1;
        if (v23 == 1)
        {
          v25 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__str = 136447234;
            *(_QWORD *)&__str[4] = "service_tracker_callback";
            *(_WORD *)&__str[12] = 2048;
            *(_QWORD *)&__str[14] = a1;
            *(_WORD *)&__str[22] = 2080;
            *(_QWORD *)&__str[24] = "tracker";
            *(_WORD *)&__str[32] = 2080;
            *(_QWORD *)&__str[34] = "service-tracker.c";
            *(_WORD *)&__str[42] = 1024;
            *(_DWORD *)&__str[44] = 148;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)__str, 0x30u);
          }
          ++service_tracker_finalized;
          service_tracker_finalize((_QWORD *)a1);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_140:
        abort();
      *(_DWORD *)__str = 136447490;
      *(_QWORD *)&__str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = v23;
      *(_WORD *)&__str[18] = 2048;
      *(_QWORD *)&__str[20] = a1;
      *(_WORD *)&__str[28] = 2080;
      *(_QWORD *)&__str[30] = "tracker";
      *(_WORD *)&__str[38] = 2080;
      *(_QWORD *)&__str[40] = "service-tracker.c";
      v52 = 1024;
      v53 = 148;
      v50 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v24 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_140;
      *(_DWORD *)__str = 136447490;
      *(_QWORD *)&__str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 0;
      *(_WORD *)&__str[18] = 2048;
      *(_QWORD *)&__str[20] = a1;
      *(_WORD *)&__str[28] = 2080;
      *(_QWORD *)&__str[30] = "tracker";
      *(_WORD *)&__str[38] = 2080;
      *(_QWORD *)&__str[40] = "service-tracker.c";
      v52 = 1024;
      v53 = 148;
      v50 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, v50, (uint8_t *)__str, 0x36u);
    goto LABEL_140;
  }
  if (a3)
  {
    v26 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v27 = *(_QWORD *)(a1 + 8);
      *(_DWORD *)__str = 136446722;
      *(_QWORD *)&__str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 2048;
      *(_QWORD *)&__str[14] = v27;
      *(_WORD *)&__str[22] = 1024;
      *(_DWORD *)&__str[24] = a3;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] %d", (uint8_t *)__str, 0x1Cu);
    }
  }
  else
  {
    v6 = (uint64_t *)(a1 + 48);
    v7 = *(_QWORD *)(a1 + 48);
    v8 = (uint64_t *)(a1 + 48);
    if (v7)
    {
      v8 = (uint64_t *)(a1 + 48);
      do
      {
        v9 = *(_DWORD *)(v7 + 20);
        switch(v9)
        {
          case 1:
            v10 = *a2;
            if (!*a2)
              goto LABEL_45;
            v11 = 0;
            while (1)
            {
              v16 = *(_QWORD *)(a2[2] + 8 * v11);
              if (*(_QWORD *)v16 == 44970
                && *(_WORD *)(v16 + 8) == 157
                && *(_WORD *)(v16 + 10) == 1
                && *(_QWORD *)(v16 + 40) == 9)
              {
                v17 = *(_QWORD *)(v16 + 24);
                if (*(_DWORD *)(v7 + 64) == *(_DWORD *)v17)
                {
                  v18 = *(_DWORD *)(v17 + 4);
                  v19 = *(unsigned __int8 *)(v17 + 8);
                  if (*(_DWORD *)(v7 + 68) == v18 && *(unsigned __int8 *)(v7 + 72) == v19)
                    break;
                }
              }
              if (v10 == ++v11)
                goto LABEL_45;
            }
            break;
          case 2:
            v10 = *a2;
            if (!*a2)
              goto LABEL_45;
            v11 = 0;
            while (1)
            {
              v13 = *(_QWORD *)(a2[2] + 8 * v11);
              if (*(_QWORD *)v13 == 44970
                && *(_WORD *)(v13 + 8) == 93
                && *(_WORD *)(v13 + 10) == 1
                && *(_QWORD *)(v13 + 40) == 18)
              {
                v14 = *(_QWORD *)(v13 + 24);
                v15 = *(_QWORD *)(v7 + 64) == *(_QWORD *)v14 && *(_QWORD *)(v7 + 72) == *(_QWORD *)(v14 + 8);
                if (v15 && *(unsigned __int16 *)(v7 + 80) == *(unsigned __int16 *)(v14 + 16))
                  break;
              }
              if (v10 == ++v11)
                goto LABEL_45;
            }
            break;
          case 3:
            v10 = *a2;
            if (!*a2)
              goto LABEL_45;
            v11 = 0;
            while (1)
            {
              v12 = *(_QWORD *)(a2[2] + 8 * v11);
              if (*(_QWORD *)v12 == 44970
                && *(_WORD *)(v12 + 8) == 92
                && *(_WORD *)(v12 + 10) == 1
                && *(_QWORD *)(v12 + 32) == 2
                && *(unsigned __int16 *)(v7 + 16) == *(unsigned __int16 *)(v12 + 12)
                && *(unsigned __int8 *)(v7 + 80) == *(unsigned __int8 *)(*(_QWORD *)(v12 + 16) + 1))
              {
                break;
              }
              if (v10 == ++v11)
                goto LABEL_45;
            }
            break;
          default:
            goto LABEL_45;
        }
        if (v11 != v10)
        {
          *(_BYTE *)(v7 + 29) = *(_BYTE *)(v7 + 24);
          *(_WORD *)(v7 + 30) = *(_WORD *)(v7 + 25);
          v8 = (uint64_t *)(v7 + 8);
          *(_DWORD *)(v7 + 24) = 0;
          goto LABEL_46;
        }
LABEL_45:
        snprintf(__str, 0x14uLL, "[ST%lld]", *(_QWORD *)(a1 + 8));
        thread_service_note((uint64_t)__str, v7, (uint64_t)"went away");
        *v8 = *(_QWORD *)(v7 + 8);
        thread_service_release_((int *)v7, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 218);
LABEL_46:
        v7 = *v8;
      }
      while (*v8);
    }
    if (*a2)
    {
      for (i = 0; i < *a2; ++i)
      {
        v29 = *(uint64_t **)(a2[2] + 8 * i);
        v30 = *v6;
        v31 = *v29;
        while (v30)
        {
          if (v31 == 44970)
          {
            v32 = *((unsigned __int16 *)v29 + 4);
            if (v32 == 92)
            {
              if (*((_WORD *)v29 + 5) == 1
                && v29[4] == 2
                && *(_DWORD *)(v30 + 20) == 3
                && *(unsigned __int16 *)(v30 + 16) == *((unsigned __int16 *)v29 + 6))
              {
                v36 = *(unsigned __int8 *)(v29[2] + 1);
                v35 = *(unsigned __int8 *)(v30 + 80);
LABEL_93:
                if (v35 == v36)
                  goto LABEL_110;
              }
            }
            else if (v32 == 157)
            {
              if (*((_WORD *)v29 + 5) == 1 && v29[5] == 9 && *(_DWORD *)(v30 + 20) == 1)
              {
                v37 = v29[3];
                if (*(_DWORD *)(v30 + 64) == *(_DWORD *)v37)
                {
                  v38 = *(_DWORD *)(v37 + 4);
                  v39 = *(unsigned __int8 *)(v37 + 8);
                  if (*(_DWORD *)(v30 + 68) == v38 && *(unsigned __int8 *)(v30 + 72) == v39)
                    goto LABEL_110;
                }
              }
            }
            else if (v32 == 93 && *((_WORD *)v29 + 5) == 1 && v29[5] == 18 && *(_DWORD *)(v30 + 20) == 2)
            {
              v33 = v29[3];
              if (*(_QWORD *)(v30 + 64) == *(_QWORD *)v33 && *(_QWORD *)(v30 + 72) == *(_QWORD *)(v33 + 8))
              {
                v35 = *(unsigned __int16 *)(v30 + 80);
                v36 = *(unsigned __int16 *)(v33 + 16);
                goto LABEL_93;
              }
            }
          }
          v30 = *(_QWORD *)(v30 + 8);
        }
        if (v31 == 44970)
        {
          v41 = *((unsigned __int16 *)v29 + 4);
          if (v41 == 92)
          {
            if (*((_WORD *)v29 + 5) != 1 || v29[4] != 2)
              continue;
            v42 = thread_service_anycast_create_(*((_WORD *)v29 + 6), *(_BYTE *)(v29[2] + 1), *((_BYTE *)v29 + 14), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 269);
          }
          else if (v41 == 157)
          {
            if (*((_WORD *)v29 + 5) != 1 || v29[5] != 9)
              continue;
            v42 = thread_service_pref_id_create_(*((_WORD *)v29 + 6), (_DWORD *)v29[3], (int *)(v29[3] + 4), *((_BYTE *)v29 + 14), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 277);
          }
          else
          {
            if (v41 != 93 || *((_WORD *)v29 + 5) != 1 || v29[5] != 18)
              continue;
            v42 = thread_service_unicast_create_(*((_WORD *)v29 + 6), (_OWORD *)v29[3], (_WORD *)(v29[3] + 16), *((_BYTE *)v29 + 14), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 261);
          }
          v30 = (uint64_t)v42;
          if (!v42)
          {
            v44 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              v45 = *(_QWORD *)(a1 + 8);
              *(_DWORD *)__str = 136446466;
              *(_QWORD *)&__str[4] = "service_tracker_callback";
              *(_WORD *)&__str[12] = 2048;
              *(_QWORD *)&__str[14] = v45;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory for service.", (uint8_t *)__str, 0x16u);
            }
            continue;
          }
          snprintf(__str, 0x14uLL, "[ST%lld]", *(_QWORD *)(a1 + 8));
          thread_service_note((uint64_t)__str, v30, (uint64_t)"showed up");
          *v8 = v30;
          v8 = (uint64_t *)(v30 + 8);
LABEL_110:
          v43 = *((_DWORD *)v29 + 13);
          if ((v43 & 2) == 0)
          {
            *(_BYTE *)(v30 + 24) = 1;
            *(_BYTE *)(a1 + 58) = 1;
            if ((v43 & 1) == 0)
              continue;
LABEL_114:
            *(_BYTE *)(v30 + 26) = 1;
            continue;
          }
          *(_BYTE *)(v30 + 25) = 1;
          if ((v43 & 1) != 0)
            goto LABEL_114;
        }
      }
    }
    memset(__str, 0, sizeof(__str));
    for (j = *v6; j; j = *(_QWORD *)(j + 8))
    {
      if (*(_DWORD *)(j + 20) == 2)
      {
        *(_BYTE *)(j + 82) = 0;
        for (k = *v6; k; k = *(_QWORD *)(k + 8))
        {
          if (*(_DWORD *)(k + 20) == 3 && *(unsigned __int16 *)(k + 16) == *(unsigned __int16 *)(j + 16))
            *(_BYTE *)(j + 82) = 1;
        }
      }
      memset(__str, 0, 24);
      *(_QWORD *)&__str[24] = __str;
      *(_OWORD *)&__str[32] = 0x14uLL;
      service_tracker_flags_accumulate((size_t)__str, *(unsigned __int8 *)(j + 30), *(unsigned __int8 *)(j + 25), "ncp");
      service_tracker_flags_accumulate((size_t)__str, *(unsigned __int8 *)(j + 31), *(unsigned __int8 *)(j + 25), "stable");
      service_tracker_flags_accumulate((size_t)__str, *(unsigned __int8 *)(j + 29), *(unsigned __int8 *)(j + 24), "user");
      if (__str[40])
      {
        snprintf(v54, 0x14uLL, "[ST%lld]", *(_QWORD *)(a1 + 8));
        thread_service_note((uint64_t)v54, j, (uint64_t)__str);
      }
    }
    for (m = *(uint64_t ***)(a1 + 40); m; m = (uint64_t **)*m)
      ((void (*)(uint64_t *))m[2])(m[3]);
    if (!*(_BYTE *)(a1 + 58))
    {
      v49 = *(_QWORD *)(a1 + 24);
      if (v49)
      {
        if (*(_BYTE *)(v49 + 284))
        {
          *(_BYTE *)(v49 + 284) = 0;
          adv_ctl_thread_shutdown_continue(v49);
        }
      }
    }
  }
}

size_t service_tracker_flags_accumulate(size_t result, int a2, int a3, const char *a4)
{
  size_t v4;
  char *v5;
  const char *v6;
  const char *v7;
  size_t v8;

  if (a2 != a3)
  {
    v4 = result;
    v5 = *(char **)(result + 24);
    v6 = " ";
    if (v5 == (char *)v4)
      v6 = (const char *)&unk_10007C3B5;
    v7 = "-";
    if (a3)
      v7 = "+";
    snprintf(v5, *(_QWORD *)(v4 + 32), "%s%s%s", v6, v7, a4);
    result = strlen(*(const char **)(v4 + 24));
    v8 = *(_QWORD *)(v4 + 32) - result;
    *(_QWORD *)(v4 + 24) += result;
    *(_QWORD *)(v4 + 32) = v8;
    *(_BYTE *)(v4 + 40) = 1;
  }
  return result;
}

BOOL service_tracker_callback_add(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _BOOL8 result;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  os_log_type_t v15;
  uint32_t v16;
  _QWORD *v17;
  _QWORD *v18;
  NSObject *v19;
  int v20;
  int v21;
  int v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  const char *v27;
  __int16 v28;
  _BYTE v29[24];
  __int16 v30;
  char *v31;
  __int16 v32;
  int v33;

  v8 = a1 + 10;
  while (1)
  {
    v9 = (_QWORD *)*v8;
    if (!*v8)
      break;
    v8 = (_QWORD *)*v8;
    if (v9[3] == a4)
    {
      v10 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT);
      if (!result)
        return result;
      v12 = *((_QWORD *)a1 + 1);
      v26 = 136446722;
      v27 = "service_tracker_callback_add";
      v28 = 2048;
      *(_QWORD *)v29 = v12;
      *(_WORD *)&v29[8] = 2048;
      *(_QWORD *)&v29[10] = a4;
      v13 = "%{public}s: [ST%lld] duplicate context %p";
      v14 = v10;
      v15 = OS_LOG_TYPE_FAULT;
      v16 = 32;
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v14, v15, v13, (uint8_t *)&v26, v16);
      return 0;
    }
  }
  v17 = malloc_type_calloc(1uLL, 0x20uLL, 0xA00403705585FuLL);
  if (!v17)
  {
    v24 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v25 = *((_QWORD *)a1 + 1);
    v26 = 136446466;
    v27 = "service_tracker_callback_add";
    v28 = 2048;
    *(_QWORD *)v29 = v25;
    v13 = "%{public}s: [ST%lld] no memory";
    v14 = v24;
    v15 = OS_LOG_TYPE_ERROR;
    v16 = 22;
    goto LABEL_18;
  }
  v18 = v17;
  v17[1] = a3;
  v17[2] = a2;
  v17[3] = a4;
  if (a1 && !*((_QWORD *)a1 + 5))
  {
    v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *a1;
      v26 = 136447490;
      v27 = "service_tracker_callback_add";
      v28 = 1024;
      *(_DWORD *)v29 = v20;
      *(_WORD *)&v29[4] = 2048;
      *(_QWORD *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(_QWORD *)&v29[16] = "tracker";
      v30 = 2080;
      v31 = "service-tracker.c";
      v32 = 1024;
      v33 = 423;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
    }
    v21 = *a1;
    if (*a1)
    {
      v22 = v21 + 1;
      *a1 = v21 + 1;
      if (v21 + 1 >= 10001)
      {
        v23 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v26 = 136447490;
          v27 = "service_tracker_callback_add";
          v28 = 1024;
          *(_DWORD *)v29 = v22;
          *(_WORD *)&v29[4] = 2048;
          *(_QWORD *)&v29[6] = a1;
          *(_WORD *)&v29[14] = 2080;
          *(_QWORD *)&v29[16] = "tracker";
          v30 = 2080;
          v31 = "service-tracker.c";
          v32 = 1024;
          v33 = 423;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++service_tracker_created;
      *a1 = 1;
    }
  }
  *v8 = v18;
  return 1;
}

void service_tracker_stop(_QWORD *a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  const char *v6;
  int v7;
  const char *v8;
  __int16 v9;
  _BYTE v10[34];
  __int16 v11;
  int v12;

  if (!a1)
    return;
  v2 = a1[4];
  if (!v2)
    return;
  cti_events_discontinue(v2);
  a1[4] = 0;
  v3 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_17;
    v7 = 136447490;
    v8 = "service_tracker_stop";
    v9 = 1024;
    *(_DWORD *)v10 = 0;
    *(_WORD *)&v10[4] = 2048;
    *(_QWORD *)&v10[6] = a1;
    *(_WORD *)&v10[14] = 2080;
    *(_QWORD *)&v10[16] = "tracker";
    *(_WORD *)&v10[24] = 2080;
    *(_QWORD *)&v10[26] = "service-tracker.c";
    v11 = 1024;
    v12 = 453;
    v6 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_16;
  }
  v4 = global_os_log;
  if (v3 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_17;
    v7 = 136447490;
    v8 = "service_tracker_stop";
    v9 = 1024;
    *(_DWORD *)v10 = v3;
    *(_WORD *)&v10[4] = 2048;
    *(_QWORD *)&v10[6] = a1;
    *(_WORD *)&v10[14] = 2080;
    *(_QWORD *)&v10[16] = "tracker";
    *(_WORD *)&v10[24] = 2080;
    *(_QWORD *)&v10[26] = "service-tracker.c";
    v11 = 1024;
    v12 = 453;
    v6 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, v6, (uint8_t *)&v7, 0x36u);
LABEL_17:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 136447490;
    v8 = "service_tracker_stop";
    v9 = 1024;
    *(_DWORD *)v10 = v3;
    *(_WORD *)&v10[4] = 2048;
    *(_QWORD *)&v10[6] = a1;
    *(_WORD *)&v10[14] = 2080;
    *(_QWORD *)&v10[16] = "tracker";
    *(_WORD *)&v10[24] = 2080;
    *(_QWORD *)&v10[26] = "service-tracker.c";
    v11 = 1024;
    v12 = 453;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v7, 0x36u);
    v3 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v3 - 1;
  if (v3 == 1)
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = 136447234;
      v8 = "service_tracker_stop";
      v9 = 2048;
      *(_QWORD *)v10 = a1;
      *(_WORD *)&v10[8] = 2080;
      *(_QWORD *)&v10[10] = "tracker";
      *(_WORD *)&v10[18] = 2080;
      *(_QWORD *)&v10[20] = "service-tracker.c";
      *(_WORD *)&v10[28] = 1024;
      *(_DWORD *)&v10[30] = 453;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v7, 0x30u);
    }
    ++service_tracker_finalized;
    service_tracker_finalize(a1);
  }
}

void service_tracker_callback_cancel(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  void (*v4)(_QWORD);

  if (a1)
  {
    v2 = (_QWORD *)(a1 + 40);
    while (1)
    {
      v3 = v2;
      v2 = (_QWORD *)*v2;
      if (!v2)
        break;
      if (v2[3] == a2)
      {
        *v3 = *v2;
        v4 = (void (*)(_QWORD))v2[1];
        if (v4)
          v4(v2[3]);
        free(v2);
        return;
      }
    }
  }
}

void service_tracker_cancel_probes(uint64_t a1)
{
  uint64_t i;
  _QWORD *v2;
  void (*v3)(_QWORD);
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  for (i = *(_QWORD *)(a1 + 48); i; i = *(_QWORD *)(i + 8))
  {
    v2 = *(_QWORD **)(i + 56);
    if (v2)
    {
      v2[3] = 0;
      *(_QWORD *)(i + 56) = 0;
      v3 = (void (*)(_QWORD))v2[6];
      if (v3)
        v3(v2[4]);
      v2[4] = 0;
      thread_service_release_((int *)i, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 107);
      v4 = v2[2];
      if (v4)
        ioloop_cancel_wake_event(v4);
      v5 = v2[1];
      if (v5)
      {
        ioloop_comm_cancel(v5);
        ioloop_comm_release_(v2[1], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 114);
        v2[1] = 0;
      }
      v6 = *(_DWORD *)v2;
      if (!*(_DWORD *)v2)
      {
        v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v13 = "probe_srp_service_probe_cancel";
          v14 = 1024;
          *(_DWORD *)v15 = 0;
          *(_WORD *)&v15[4] = 2048;
          *(_QWORD *)&v15[6] = v2;
          *(_WORD *)&v15[14] = 2080;
          *(_QWORD *)&v15[16] = "probe_state";
          *(_WORD *)&v15[24] = 2080;
          *(_QWORD *)&v15[26] = "probe-srp.c";
          v16 = 1024;
          v17 = 117;
          v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          v11 = v9;
          goto LABEL_23;
        }
LABEL_24:
        abort();
      }
      v7 = global_os_log;
      if (v6 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v13 = "probe_srp_service_probe_cancel";
          v14 = 1024;
          *(_DWORD *)v15 = v6;
          *(_WORD *)&v15[4] = 2048;
          *(_QWORD *)&v15[6] = v2;
          *(_WORD *)&v15[14] = 2080;
          *(_QWORD *)&v15[16] = "probe_state";
          *(_WORD *)&v15[24] = 2080;
          *(_QWORD *)&v15[26] = "probe-srp.c";
          v16 = 1024;
          v17 = 117;
          v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v11 = v7;
LABEL_23:
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
        }
        goto LABEL_24;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v13 = "probe_srp_service_probe_cancel";
        v14 = 1024;
        *(_DWORD *)v15 = v6;
        *(_WORD *)&v15[4] = 2048;
        *(_QWORD *)&v15[6] = v2;
        *(_WORD *)&v15[14] = 2080;
        *(_QWORD *)&v15[16] = "probe_state";
        *(_WORD *)&v15[24] = 2080;
        *(_QWORD *)&v15[26] = "probe-srp.c";
        v16 = 1024;
        v17 = 117;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v6 = *(_DWORD *)v2;
      }
      *(_DWORD *)v2 = v6 - 1;
      if (v6 == 1)
      {
        v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v13 = "probe_srp_service_probe_cancel";
          v14 = 2048;
          *(_QWORD *)v15 = v2;
          *(_WORD *)&v15[8] = 2080;
          *(_QWORD *)&v15[10] = "probe_state";
          *(_WORD *)&v15[18] = 2080;
          *(_QWORD *)&v15[20] = "probe-srp.c";
          *(_WORD *)&v15[28] = 1024;
          *(_DWORD *)&v15[30] = 117;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++probe_state_finalized;
        probe_state_finalize(v2);
      }
    }
  }
}

uint64_t dso_state_cancel(uint64_t result)
{
  uint64_t *v1;
  uint64_t *v2;
  uint64_t *v3;
  BOOL v4;
  uint64_t (*v5)(uint64_t, _QWORD, uint64_t);

  v1 = (uint64_t *)result;
  v2 = &dso_connections;
  do
  {
    v3 = v2;
    v2 = (uint64_t *)*v2;
    if (v2)
      v4 = v2 == (uint64_t *)result;
    else
      v4 = 1;
  }
  while (!v4);
  if (v2)
  {
    v5 = *(uint64_t (**)(uint64_t, _QWORD, uint64_t))(result + 16);
    if (!v5 || (result = v5(1, *(_QWORD *)(result + 8), result), (_DWORD)result))
    {
      *v3 = *v1;
      *v1 = dso_connections_needing_cleanup;
      dso_connections_needing_cleanup = (uint64_t)v1;
    }
  }
  return result;
}

uint64_t **dso_find_activity(uint64_t a1, char *__s1, uint64_t *a3)
{
  NSObject *v4;
  int v5;
  uint64_t **v6;
  const char *v9;
  NSObject *v10;
  int v11;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  uint64_t *v24;

  if (!((unint64_t)__s1 | (unint64_t)a3))
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      v5 = *(_DWORD *)(a1 + 48);
      v13 = 136446722;
      v14 = "dso_find_activity";
      v15 = 1024;
      v16 = v5;
      v17 = 2082;
      v18 = (uint64_t)"push subscription";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] Cannot search for activity with name and context both equal to NULL - activity_type: %{public}s.", (uint8_t *)&v13, 0x1Cu);
    }
    return 0;
  }
  v6 = *(uint64_t ***)(a1 + 80);
  if (!v6)
    return v6;
  while (1)
  {
    if (v6[2] != (uint64_t *)"push subscription")
      goto LABEL_7;
    if (__s1)
      break;
    if (v6[3] == a3)
      return v6;
LABEL_7:
    v6 = (uint64_t **)*v6;
    if (!v6)
      return v6;
  }
  v9 = (const char *)v6[4];
  if (!v9 || strcmp(__s1, v9))
    goto LABEL_7;
  if (a3)
  {
    if (v6[3] != a3)
    {
      v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v11 = *(_DWORD *)(a1 + 48);
        v13 = 136447491;
        v14 = "dso_find_activity";
        v15 = 1024;
        v16 = v11;
        v17 = 2160;
        v18 = 1752392040;
        v19 = 2081;
        v20 = __s1;
        v21 = 2082;
        v22 = "push subscription";
        v23 = 2048;
        v24 = a3;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] The activity specified by the name does not have the expected context - name: %{private, mask.hash}s, activity_type: %{public}s, context: %p.", (uint8_t *)&v13, 0x3Au);
      }
    }
  }
  return v6;
}

void dso_drop_activity(uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(_QWORD *);
  int v17;
  const char *v18;
  __int16 v19;
  int v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;

  v4 = (_QWORD *)(a1 + 80);
  while (1)
  {
    v5 = v4;
    v4 = (_QWORD *)*v4;
    if (!v4)
      break;
    if (v4 == a2)
    {
      *v5 = *a2;
      goto LABEL_7;
    }
  }
  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    v7 = *(_DWORD *)(a1 + 48);
    v9 = a2[3];
    v8 = a2[4];
    v10 = a2[2];
    v17 = 136447491;
    v18 = "dso_drop_activity";
    v19 = 1024;
    v20 = v7;
    v21 = 2160;
    v22 = 1752392040;
    v23 = 2081;
    v24 = v8;
    v25 = 2082;
    v26 = v10;
    v27 = 2048;
    v28 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] Trying to remove an activity that is not in the list - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&v17, 0x3Au);
  }
LABEL_7:
  v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v12 = *(_DWORD *)(a1 + 48);
    v14 = a2[3];
    v13 = a2[4];
    v15 = a2[2];
    v17 = 136447491;
    v18 = "dso_drop_activity";
    v19 = 1024;
    v20 = v12;
    v21 = 2160;
    v22 = 1752392040;
    v23 = 2081;
    v24 = v13;
    v25 = 2082;
    v26 = v15;
    v27 = 2048;
    v28 = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] Removing a DSO activity - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&v17, 0x3Au);
  }
  v16 = (void (*)(_QWORD *))a2[1];
  if (v16)
    v16(a2);
  free(a2);
}

uint64_t dso_retry_delay(uint64_t result, _WORD *a2)
{
  uint64_t (*v2)(_QWORD, unsigned int *, uint64_t, uint64_t);
  uint64_t v3;
  int v4;
  NSObject *v6;
  uint64_t v7;
  unsigned int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;

  v2 = *(uint64_t (**)(_QWORD, unsigned int *, uint64_t, uint64_t))(result + 24);
  if (v2)
  {
    v3 = result;
    v4 = *(unsigned __int16 *)(result + 90);
    if (v4 == 4)
    {
      v8 = bswap32(**(_DWORD **)(result + 96));
      return v2(*(_QWORD *)(result + 8), &v8, result, 12);
    }
    else
    {
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_QWORD *)(v3 + 152);
        v8 = 136446722;
        v9 = "dso_retry_delay";
        v10 = 1024;
        v11 = v4;
        v12 = 2080;
        v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: Invalid DSO Retry Delay length %d from %s", (uint8_t *)&v8, 0x1Cu);
      }
      return dso_simple_response(*(_QWORD *)(v3 + 32), 0, a2, 1);
    }
  }
  return result;
}

void dso_keepalive(uint64_t a1, _WORD *a2, int a3)
{
  int v5;
  int v6;
  BOOL v7;
  unsigned int v8;
  unsigned int v9;
  NSObject *v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  _WORD *v16;
  int v17;
  NSObject *v18;
  void (*v20)(_QWORD, unsigned int *, uint64_t, uint64_t);
  void (*v21)(_QWORD, unsigned int *, uint64_t, uint64_t);
  unsigned int v22;
  unsigned int v23;
  int v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  int v28;
  __int16 v29;
  _QWORD v30[2];

  v24 = 0x10000;
  v5 = *(unsigned __int16 *)(a1 + 90);
  if (v5 != 8)
  {
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v14 = *(_QWORD *)(a1 + 152);
      *(_DWORD *)buf = 136446722;
      v26 = "dso_keepalive";
      v27 = 1024;
      v28 = v5;
      v29 = 2080;
      v30[0] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: Invalid DSO Keepalive length %d from %s", buf, 0x1Cu);
    }
    if (!*(_BYTE *)(a1 + 52))
      return;
LABEL_19:
    v15 = *(_QWORD *)(a1 + 32);
    v16 = a2;
    v17 = 1;
LABEL_20:
    dso_simple_response(v15, 0, v16, v17);
    return;
  }
  v6 = *(unsigned __int8 *)(a1 + 52);
  if (*(_BYTE *)(a1 + 52))
    v7 = a3 == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v18 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v26 = "dso_keepalive";
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: Dropping Keepalive Response received by DSO server", buf, 0xCu);
    }
    return;
  }
  v8 = bswap32(**(_DWORD **)(a1 + 96));
  v9 = bswap32(*(_DWORD *)(*(_QWORD *)(a1 + 96) + 4));
  v22 = v8;
  v23 = v9;
  LOWORD(v24) = *a2;
  if (v8 > 0x38000000 || v9 >= 0x38000001)
  {
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v12 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)buf = 136446978;
      v26 = "dso_keepalive";
      v27 = 1024;
      v28 = v12;
      v29 = 1024;
      LODWORD(v30[0]) = v8;
      WORD2(v30[0]) = 1024;
      *(_DWORD *)((char *)v30 + 6) = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] inactivity_timeoutl[%u] keepalive_interva[%u] is unreasonably large.", buf, 0x1Eu);
      v6 = *(unsigned __int8 *)(a1 + 52);
    }
    if (!v6)
      return;
    goto LABEL_19;
  }
  if (v6)
  {
    v20 = *(void (**)(_QWORD, unsigned int *, uint64_t, uint64_t))(a1 + 24);
    if (!v20)
      goto LABEL_31;
    if (*(_DWORD *)(a1 + 60) < v9)
      v23 = *(_DWORD *)(a1 + 60);
    if (*(_DWORD *)(a1 + 64) < v8)
      v22 = *(_DWORD *)(a1 + 64);
    v20(*(_QWORD *)(a1 + 8), &v22, a1, 11);
    if (BYTE2(v24))
    {
LABEL_31:
      v15 = *(_QWORD *)(a1 + 32);
      v16 = a2;
      v17 = 0;
      goto LABEL_20;
    }
  }
  else
  {
    if (*(_DWORD *)(a1 + 60) > v9)
      *(_DWORD *)(a1 + 60) = v9;
    if (*(_DWORD *)(a1 + 64) > v8)
      *(_DWORD *)(a1 + 64) = v8;
    v21 = *(void (**)(_QWORD, unsigned int *, uint64_t, uint64_t))(a1 + 24);
    if (v21)
      v21(*(_QWORD *)(a1 + 8), &v22, a1, 11);
  }
}

void dso_session_established(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  int v5;
  const char *v6;
  __int16 v7;
  int v8;
  __int16 v9;
  uint64_t v10;
  __int16 v11;
  uint64_t v12;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_DWORD *)(a1 + 48);
    v4 = *(_QWORD *)(a1 + 152);
    v5 = 136446978;
    v6 = "dso_session_established";
    v7 = 1024;
    v8 = v3;
    v9 = 2048;
    v10 = a1;
    v11 = 2080;
    v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] DSO session established - dso: %p, remote name: %s.", (uint8_t *)&v5, 0x26u);
  }
  *(_BYTE *)(a1 + 53) = 1;
}

void dns_concatenate_name_to_wire_(uint64_t a1, uint64_t **a2, char *a3, char *a4, int a5)
{
  char *v8;
  uint64_t **v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  unint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v20;
  _BYTE *v21;
  unsigned __int8 *v22;
  unsigned __int8 *v23;
  uint64_t v25;
  unsigned __int8 *v26;
  unsigned __int8 *v27;
  uint64_t v28;
  unsigned __int8 *v29;
  unsigned __int8 *v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned __int8 *v36;
  char v37;
  _BYTE *v38;
  _BYTE *v39;
  _OWORD *v40;
  unint64_t v41;
  _BYTE *v42;
  __int128 v43;
  __int128 v44;
  _OWORD v45[88];
  _BYTE v46[6];

  memset(v45, 0, 512);
  BYTE12(v45[0]) = 0;
  if (*(_DWORD *)(a1 + 48) <= 1u)
  {
    v8 = (char *)((unint64_t)v45 | 0xC);
    v43 = 0uLL;
    v44 = 0uLL;
    v41 = (unint64_t)v45 | 0xC;
    v42 = v46;
    v40 = v45;
    if (a3)
    {
      dns_name_to_wire_(0, (uint64_t *)&v40, a3, 127);
    }
    else
    {
      v9 = a2;
      if (a2)
      {
        v10 = 0;
        v11 = 1398;
        v12 = (char *)((unint64_t)v45 | 0xC);
        while (1)
        {
          v13 = *((unsigned __int8 *)v9 + 8);
          if (v11 <= v13)
            break;
          *v12 = v13;
          v14 = v12 + 1;
          memcpy(v14, (char *)v9 + 9, *((unsigned __int8 *)v9 + 8));
          v15 = *((unsigned __int8 *)v9 + 8);
          v12 = &v14[v15];
          v11 += ~v15;
          v16 = v10 + v15;
          v10 = v16 + 1;
          v9 = (uint64_t **)*v9;
          if (!v9)
          {
            if (v16 != -1)
            {
              v41 = (unint64_t)&v8[v10];
              goto LABEL_11;
            }
            break;
          }
        }
        DWORD2(v44) = 1;
      }
    }
LABEL_11:
    if (a4)
      dns_full_name_to_wire_(0, (uint64_t)&v40, a4, 148);
    if (DWORD2(v44) >= 2)
    {
      *(_DWORD *)(a1 + 48) = DWORD2(v44);
      *(_DWORD *)(a1 + 40) = a5;
    }
    v17 = *(_QWORD *)(a1 + 8);
    if (v17)
    {
      v18 = *(_QWORD *)(a1 + 16);
      v19 = BYTE12(v45[0]);
      if (BYTE12(v45[0]))
      {
        v20 = *(_QWORD *)a1;
        v21 = *(_BYTE **)(a1 + 8);
        while (v19 <= 0x3F && &v8[v19 + 1] < (char *)&v45[16] + 12)
        {
          if (v20 && v19)
          {
            v22 = (unsigned __int8 *)(v17 - v19);
LABEL_23:
            while ((unint64_t)(v22 - 1) >= v20)
            {
              v23 = v22--;
              if (*(v23 - 1) == v19 && *v23 == v8[1] && (unint64_t)&v22[v19] < v17)
              {
                LODWORD(v25) = v19;
                v26 = v22;
                v27 = (unsigned __int8 *)v8;
LABEL_30:
                v28 = v25 + 1;
                v29 = v26;
                v30 = v27;
                v31 = v28;
                while (1)
                {
                  v33 = *v29++;
                  v32 = v33;
                  v34 = *v30++;
                  if (v32 != v34)
                    break;
                  if (!--v31)
                  {
                    v26 += v28;
                    v27 += v28;
                    v25 = *v27;
                    v35 = *v26;
                    if (*v27)
                    {
                      if (v35 < 0x40
                        || v35 >= 0xC0
                        && (unint64_t)(v26 + 1) < v17
                        && (v36 = (unsigned __int8 *)(v20 + ((unint64_t)(v35 & 0x3F) << 8) + v26[1]), v26 >= v36)
                        && (v26 = v36, *v36 <= 0x3Fu))
                      {
                        if ((unint64_t)&v26[v25] < v17)
                          goto LABEL_30;
                      }
                      goto LABEL_23;
                    }
                    if (*v26)
                      goto LABEL_23;
                    v39 = v21 + 2;
                    if ((unint64_t)(v21 + 2) <= v18)
                    {
                      *v21 = ((unsigned __int16)((_WORD)v22 - v20) >> 8) | 0xC0;
                      v21[1] = (_BYTE)v22 - v20;
                      v38 = v21 + 2;
                      if (v39)
                        goto LABEL_50;
                    }
                    goto LABEL_51;
                  }
                }
              }
            }
          }
          if ((unint64_t)&v21[v19 + 1] >= v18)
            break;
          *v21++ = v19;
          ++v8;
          do
          {
            v37 = *v8++;
            *v21++ = v37;
            --v19;
          }
          while (v19);
          v19 = *v8;
          if (!*v8)
            goto LABEL_49;
        }
      }
      else
      {
        v21 = *(_BYTE **)(a1 + 8);
        if (v17 < v18)
        {
LABEL_49:
          *v21 = 0;
          v38 = v21 + 1;
          if (v38)
          {
LABEL_50:
            if ((unint64_t)v38 <= *(_QWORD *)(a1 + 16))
            {
              *(_QWORD *)(a1 + 8) = v38;
              return;
            }
          }
        }
      }
    }
LABEL_51:
    *(_DWORD *)(a1 + 48) = 111;
    *(_DWORD *)(a1 + 40) = a5;
  }
}

uint64_t dns_name_print_to_limit(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  int v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;

  v4 = 0;
  if (a1 != a2 && a1)
  {
    v4 = 0;
    do
    {
      if (v4)
      {
        if (v4 + 2 >= a4)
          break;
        *(_BYTE *)(a3 + v4++) = 46;
      }
      LOBYTE(v5) = *((_BYTE *)a1 + 8);
      if ((_BYTE)v5)
      {
        v6 = 0;
        do
        {
          v7 = *((char *)a1 + v6 + 9);
          if ((*((_BYTE *)a1 + v6 + 9) & 0x80) == 0
            && (v7 == 32 || (_DefaultRuneLocale.__runetype[v7] & 0x40000) != 0))
          {
            if (v4 + 2 >= a4)
              break;
            v10 = 1;
            v9 = v4;
          }
          else
          {
            if (v4 + 5 >= a4)
              break;
            v8 = (_BYTE *)(a3 + v4);
            *v8 = 92;
            v8[1] = (v7 / 0x64u) | 0x30;
            v9 = v4 + 3;
            v8[2] = (v7 / 0xAu - 10 * ((unsigned __int16)(26 * (v7 / 0xAu)) >> 8)) | 0x30;
            LOBYTE(v7) = (v7 % 0xAu) | 0x30;
            v10 = 4;
          }
          v4 += v10;
          *(_BYTE *)(a3 + v9) = v7;
          ++v6;
          v5 = *((unsigned __int8 *)a1 + 8);
        }
        while (v6 < v5);
      }
      else
      {
        v6 = 0;
      }
      if (v6 != v5)
        break;
      a1 = (uint64_t *)*a1;
    }
    while (a1 != a2 && a1 != 0);
  }
  *(_BYTE *)(a3 + v4) = 0;
  return a3;
}

uint64_t dns_labels_equal(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6;
  unsigned int v7;
  __darwin_ct_rune_t v8;
  int v9;
  __darwin_ct_rune_t v10;

  v6 = 0;
  v7 = 1;
  while (1)
  {
    v8 = *(unsigned __int8 *)(a1 + v6);
    v9 = *(char *)(a2 + v6);
    if (*(char *)(a1 + v6) < 0 || v9 < 0)
      break;
    v10 = __tolower(v8);
    if (v10 != __tolower(*(char *)(a2 + v6)))
      return 0;
LABEL_7:
    v6 = v7++;
    if (v6 >= a3)
      return 1;
  }
  if (v8 == v9)
    goto LABEL_7;
  return 0;
}

uint64_t dns_names_equal(uint64_t *a1, uint64_t **a2)
{
  unint64_t v4;
  uint64_t result;

  while (1)
  {
    v4 = *((unsigned __int8 *)a1 + 8);
    if ((_DWORD)v4 != *((unsigned __int8 *)a2 + 8))
      return 0;
    if (*((_BYTE *)a1 + 8))
    {
      result = dns_labels_equal((uint64_t)a1 + 9, (uint64_t)a2 + 9, v4);
      if (!(_DWORD)result)
        return result;
    }
    a1 = (uint64_t *)*a1;
    a2 = (uint64_t **)*a2;
    if (!a1)
      break;
    if (!a2)
      return 0;
  }
  return !a2;
}

BOOL dns_names_equal_text(uint64_t *a1, char *__s)
{
  char *v4;
  int v5;
  char *v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  __darwin_ct_rune_t v12;

  while (1)
  {
    v4 = strchr(__s, 46);
    if (!v4)
      v4 = &__s[strlen(__s)];
    if (__s >= v4)
    {
      v5 = 0;
    }
    else
    {
      v5 = 0;
      v6 = __s;
      do
      {
        if (*v6 == 92)
        {
          if (v6 + 4 > v4)
            return 0;
          v6 += 3;
        }
        ++v5;
        ++v6;
      }
      while (v6 < v4);
    }
    if (v5 != *((unsigned __int8 *)a1 + 8))
      return 0;
    if (*((_BYTE *)a1 + 8) && __s < v4)
    {
      v7 = (unsigned __int8 *)a1 + 9;
      while (1)
      {
        v8 = *__s;
        if (v8 != 92)
          break;
        v9 = __s[3];
        __s += 3;
        v10 = 100 * *(__s - 2) + 10 * *(__s - 1) + v9;
        if (v10 > 5583)
          return 0;
        v11 = (char)*v7;
        if (v11 < 0)
        {
          v8 = v10 - 5328;
LABEL_22:
          if (v8 != v11)
            return 0;
          goto LABEL_23;
        }
        v12 = __tolower(92);
        if (v12 != __tolower((char)*v7))
          return 0;
LABEL_23:
        ++__s;
        ++v7;
        if (__s >= v4)
          goto LABEL_24;
      }
      v11 = *v7;
      goto LABEL_22;
    }
LABEL_24:
    a1 = (uint64_t *)*a1;
    if (!a1)
      return !*v4;
    if (*v4 != 46)
      return 0;
    __s = v4 + 1;
  }
}

_QWORD *dns_pres_name_parse(char *a1)
{
  char *v1;
  char *v2;
  void **v3;
  uint64_t v4;
  int v5;
  int v6;
  _BYTE *v7;
  uint64_t v8;
  void **v9;
  void **v10;
  BOOL v11;
  _QWORD *result;
  _QWORD *v13;
  void *v14;
  _BYTE __src[63];

  v1 = a1;
  v14 = 0;
  v2 = strchr(a1, 46);
  v3 = &v14;
  while (1)
  {
    if (!v2)
      v2 = &v1[strlen(v1)];
    if (v2 == v1)
    {
      v8 = 0;
      goto LABEL_16;
    }
    if (v1 < v2)
      break;
    v7 = __src;
LABEL_15:
    v8 = v7 - __src;
LABEL_16:
    v9 = (void **)malloc_type_calloc(1uLL, v8 + 10, 0x95FA72F8uLL);
    if (!v9)
      goto LABEL_29;
    v10 = v9;
    *v3 = v9;
    *((_BYTE *)v9 + 8) = v8;
    if ((_BYTE)v8)
      memcpy((char *)v9 + 9, __src, v8);
    *((_BYTE *)v10 + v8 + 9) = 0;
    if (v8)
      v11 = *v2 == 46;
    else
      v11 = 0;
    if (v11)
      v1 = v2 + 1;
    else
      v1 = v2;
    if (*v1)
    {
      v2 = strchr(v1, 46);
      v3 = v10;
    }
    else
    {
      v3 = v10;
      v2 = v1;
      if (!v8)
        return v14;
    }
  }
  v4 = 0;
  while (1)
  {
    v5 = *v1;
    if (v5 == 92)
    {
      v6 = v1[3];
      v1 += 3;
      v5 = 100 * *(v1 - 2) + 10 * *(v1 - 1) + v6;
      if (v5 > 5583)
        break;
      LOBYTE(v5) = v5 + 48;
    }
    __src[v4] = v5;
    if (v4 == 62)
      break;
    ++v1;
    ++v4;
    if (v1 >= v2)
    {
      v7 = &__src[v4];
      goto LABEL_15;
    }
  }
LABEL_29:
  result = v14;
  if (v14)
  {
    do
    {
      v13 = (_QWORD *)*result;
      free(result);
      result = v13;
    }
    while (v13);
  }
  return result;
}

uint64_t *dns_name_subdomain_of(uint64_t *a1, uint64_t **a2)
{
  uint64_t *v2;
  int v3;
  uint64_t **v4;
  BOOL v5;
  int v6;
  uint64_t *v7;
  int v8;
  BOOL v9;

  v2 = a1;
  v3 = 0;
  if (a2)
  {
    v4 = a2;
    do
    {
      ++v3;
      v4 = (uint64_t **)*v4;
    }
    while (v4);
  }
  v5 = a1 == 0;
  v6 = 0;
  if (a1)
  {
    v7 = a1;
    do
    {
      ++v6;
      v7 = (uint64_t *)*v7;
    }
    while (v7);
  }
  if (v6 < v3)
    return 0;
  if (a1 && v6 != v3)
  {
    v8 = v3 - v6 + 1;
    do
    {
      v2 = (uint64_t *)*v2;
      v5 = v2 == 0;
      if (v2)
        v9 = v8 == 0;
      else
        v9 = 1;
      ++v8;
    }
    while (!v9);
  }
  if (v5 || (dns_names_equal(v2, a2) & 1) == 0)
    return 0;
  return v2;
}

BOOL dns_keys_rdata_equal(uint64_t a1, uint64_t a2)
{
  size_t v2;
  _BOOL8 result;

  result = 0;
  if (*(_WORD *)(a1 + 8) == 25
    && *(_WORD *)(a2 + 8) == 25
    && *(unsigned __int16 *)(a1 + 16) == *(unsigned __int16 *)(a2 + 16)
    && *(unsigned __int8 *)(a1 + 18) == *(unsigned __int8 *)(a2 + 18)
    && *(unsigned __int8 *)(a1 + 19) == *(unsigned __int8 *)(a2 + 19))
  {
    v2 = *(unsigned int *)(a1 + 20);
    if ((_DWORD)v2 == *(_DWORD *)(a2 + 20) && !memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2))
      return 1;
  }
  return result;
}

unint64_t dns_txt_data_print(unint64_t __str, unsigned int a2, uint64_t a3)
{
  unint64_t v3;
  _WORD *v6;
  int v7;
  int v8;
  size_t v9;
  const char *v10;
  int v11;
  int v12;
  unint64_t v14;
  unint64_t v15;
  int v16;

  v3 = __str + 1398;
  *(_BYTE *)__str = 0;
  if (__str + 1398 >= __str && a2 != 0)
  {
    v6 = (_WORD *)__str;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = (const char *)&unk_10007C3B5;
    do
    {
      v11 = *(unsigned __int8 *)(a3 + (unsigned __int16)v8);
      v12 = v8 + v11 + 1;
      if (a2 < (unsigned __int16)(v8 + v11 + 1))
        break;
      if ((unsigned __int16)(v8 + v11 + 1) < (unsigned __int16)v8 || (unint64_t)&v6[v9] + 1 >= v3)
        break;
      if (*(_BYTE *)(a3 + (unsigned __int16)v8))
      {
        if (v9 * 2)
        {
          __str = (unint64_t)memcpy(v6, v10, v9 * 2);
          LOBYTE(v6[v9]) = 0;
          v6 = (_WORD *)((char *)v6 + v9 * 2);
        }
        v14 = (v7 + 1);
        v15 = (v14 + v11);
        do
        {
          v16 = *(char *)(a3 + v14);
          if ((v16 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[*(unsigned __int8 *)(a3 + v14)] & 0x40000) != 0)
          {
            if ((unint64_t)v6 + 1 < v3)
            {
              *v6 = v16;
              v6 = (_WORD *)((char *)v6 + 1);
            }
          }
          else if ((unint64_t)v6 + 5 < v3)
          {
            __str = snprintf((char *)v6, 5uLL, "%o", *(unsigned __int8 *)(a3 + v14));
            v6 = (_WORD *)((char *)v6 + (int)__str);
          }
          ++v14;
        }
        while (v14 < v15);
        v10 = ", ";
        v9 = 1;
      }
      if ((unint64_t)v6 >= v3)
        break;
      v7 = (unsigned __int16)v12;
      v8 = v12;
    }
    while (a2 > (unsigned __int16)v12);
  }
  return __str;
}

const char *dns_qclass_to_string(int a1)
{
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;

  if (a1 <= 3)
  {
    if (a1 == 1)
      return "in";
    if (a1 == 3)
      return "chaos";
  }
  else
  {
    switch(a1)
    {
      case 4:
        return "hesiod";
      case 254:
        return "none";
      case 255:
        return "any";
    }
  }
  v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    v4 = 136446466;
    v5 = "dns_qclass_to_string";
    v6 = 1024;
    v7 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "%{public}s: Invalid qclass - qclass: %u", (uint8_t *)&v4, 0x12u);
  }
  return "<INVALID dns_qclass>";
}

const char *dns_rrtype_to_string(int a1)
{
  const char *result;
  NSObject *v3;
  int v4;
  const char *v5;
  __int16 v6;
  int v7;

  if (a1 > 248)
  {
    switch(a1)
    {
      case 249:
        result = "tkey";
        break;
      case 250:
        result = "tsig";
        break;
      case 251:
        result = "ixfr";
        break;
      case 252:
        result = "axfr";
        break;
      case 253:
        result = "mailb";
        break;
      case 254:
        result = "maila";
        break;
      case 255:
        result = "any";
        break;
      case 256:
        result = "uri";
        break;
      case 257:
        result = "caa";
        break;
      case 258:
        result = "avc";
        break;
      case 259:
        result = "doa";
        break;
      case 260:
        result = "amtrelay";
        break;
      default:
        if (a1 == 0x8000)
        {
          result = "ta";
        }
        else if (a1 == 32769)
        {
          result = "dlv";
        }
        else
        {
LABEL_94:
          v3 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            v4 = 136446466;
            v5 = "dns_rrtype_to_string";
            v6 = 1024;
            v7 = a1;
            _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "%{public}s: Invalid dns_rrtype - rrtype: %u", (uint8_t *)&v4, 0x12u);
          }
          result = "<INVALID dns_rrtype>";
        }
        break;
    }
  }
  else
  {
    result = "a";
    switch(a1)
    {
      case 1:
        return result;
      case 2:
        result = "ns";
        break;
      case 3:
        result = "md";
        break;
      case 4:
        result = "mf";
        break;
      case 5:
        result = "cname";
        break;
      case 6:
        result = "soa";
        break;
      case 7:
        result = "mb";
        break;
      case 8:
        result = "mg";
        break;
      case 9:
        result = "mr";
        break;
      case 10:
        result = "null";
        break;
      case 11:
        result = "wks";
        break;
      case 12:
        result = "ptr";
        break;
      case 13:
        result = "hinfo";
        break;
      case 14:
        result = "minfo";
        break;
      case 15:
        result = "mx";
        break;
      case 16:
        result = "txt";
        break;
      case 17:
        result = "rp";
        break;
      case 18:
        result = "afsdb";
        break;
      case 19:
        result = "x25";
        break;
      case 20:
        result = "isdn";
        break;
      case 21:
        result = "rt";
        break;
      case 22:
        result = "nsap";
        break;
      case 23:
        result = "nsap_ptr";
        break;
      case 24:
        result = "sig";
        break;
      case 25:
        result = "key";
        break;
      case 26:
        result = "px";
        break;
      case 27:
        result = "gpos";
        break;
      case 28:
        result = "aaaa";
        break;
      case 29:
        result = "loc";
        break;
      case 30:
        result = "nxt";
        break;
      case 31:
        result = "eid";
        break;
      case 32:
        result = "nimloc";
        break;
      case 33:
        result = "srv";
        break;
      case 34:
        result = "atma";
        break;
      case 35:
        result = "naptr";
        break;
      case 36:
        result = "kx";
        break;
      case 37:
        result = "cert";
        break;
      case 38:
        result = "a6";
        break;
      case 39:
        result = "dname";
        break;
      case 40:
        result = "sink";
        break;
      case 41:
        result = "opt";
        break;
      case 42:
        result = "apl";
        break;
      case 43:
        result = "ds";
        break;
      case 44:
        result = "sshfp";
        break;
      case 45:
        result = "ipseckey";
        break;
      case 46:
        result = "rrsig";
        break;
      case 47:
        result = "nsec";
        break;
      case 48:
        result = "dnskey";
        break;
      case 49:
        result = "dhcid";
        break;
      case 50:
        result = "nsec3";
        break;
      case 51:
        result = "nsec3param";
        break;
      case 52:
        result = "tlsa";
        break;
      case 53:
        result = "smimea";
        break;
      case 55:
        result = "hip";
        break;
      case 56:
        result = "ninfo";
        break;
      case 57:
        result = "rkey";
        break;
      case 58:
        result = "talink";
        break;
      case 59:
        result = "cds";
        break;
      case 60:
        result = "cdnskey";
        break;
      case 61:
        result = "openpgpkey";
        break;
      case 62:
        result = "csync";
        break;
      case 63:
        result = "zonemd";
        break;
      case 64:
        result = "svcb";
        break;
      case 65:
        result = "https";
        break;
      case 99:
        result = "spf";
        break;
      case 100:
        result = "uinfo";
        break;
      case 101:
        result = "uid";
        break;
      case 102:
        result = "gid";
        break;
      case 103:
        result = "unspec";
        break;
      case 104:
        result = "nid";
        break;
      case 105:
        result = "l32";
        break;
      case 106:
        result = "l64";
        break;
      case 107:
        result = "lp";
        break;
      case 108:
        result = "eui48";
        break;
      case 109:
        result = "eui64";
        break;
      default:
        goto LABEL_94;
    }
  }
  return result;
}

void dp_start_dropping()
{
  int *v0;
  NSObject *v1;
  int v2;
  const char *v3;

  v0 = (int *)connection_dropper;
  if (connection_dropper
    || (v0 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 650), (connection_dropper = (uint64_t)v0) != 0))
  {
    ioloop_add_wake_event((uint64_t)v0, 0, (uint64_t)dp_drop_connections, 0, 0x15F90u);
  }
  else
  {
    v1 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v2 = 136446210;
      v3 = "dp_start_dropping";
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "%{public}s: can't create connection dropper.", (uint8_t *)&v2, 0xCu);
    }
  }
}

uint64_t dp_drop_connections()
{
  uint64_t i;
  uint64_t v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint8_t buf[4];
  const char *v7;
  __int16 v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;

  for (i = dso_connections; i; i = *(_QWORD *)i)
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, int))(i + 24) == dns_push_callback)
    {
      v1 = *(_QWORD *)(i + 8);
      v2 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v3 = *(_QWORD *)(i + 152);
        *(_DWORD *)buf = 136446723;
        v7 = "dp_drop_connections";
        v8 = 2160;
        v9 = 1752392040;
        v10 = 2081;
        v11 = v3;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: dropping connection for %{private, mask.hash}s.", buf, 0x20u);
      }
      v4 = *(_QWORD *)(v1 + 8);
      if (v4)
        ioloop_comm_cancel(v4);
    }
  }
  return dp_start_dropping();
}

void dns_push_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  int v7;
  int v8;
  NSObject *v10;
  int v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  NSObject *v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;
  const char *v28;
  int v29;
  uint64_t v30;
  uint8_t *v31;
  NSObject *v32;
  int v33;
  uint64_t v34;
  NSObject *v35;
  int v36;
  int v37;
  uint64_t v38;
  os_log_type_t v39;
  uint32_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  __int16 v47;
  char v48;
  uint64_t v49;
  _BOOL4 v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  int v57;
  NSObject *v58;
  int v59;
  int v60;
  _WORD *v61;
  const char *v62;
  NSObject *v63;
  int v64;
  int v65;
  NSObject *v66;
  int v67;
  int v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  uint16_t v72;
  __int16 v73;
  size_t v74;
  const void *v75;
  uint64_t v76;
  int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  uint64_t v83;
  const char *v84;
  uint8_t *v85;
  NSObject *v86;
  uint32_t v87;
  _QWORD *v88;
  _QWORD *v89;
  int v90;
  uint64_t v91;
  int v92;
  int v93;
  int v94;
  uint64_t v95;
  NSObject *v96;
  unsigned int v97;
  uint16_t v98;
  _BYTE v99[18];
  __int16 v100;
  int v101;
  __int16 v102;
  int v103;
  __int16 v104;
  _BYTE *v105;
  uint16_t rrtype[32];
  _BYTE buf[12];
  __int16 v108;
  _BYTE v109[32];
  __int16 v110;
  unsigned int v111;
  _BYTE v112[4];

  switch(a4)
  {
    case 0:
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v7 = *(_DWORD *)(a3 + 48);
      else
        v7 = 0;
      v26 = (*(unsigned __int16 *)(a2 + 90) >> 3) & 0xF;
      v27 = *(_QWORD *)(a3 + 152);
      *(_DWORD *)buf = 136447235;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v7;
      *(_WORD *)&v109[4] = 1024;
      *(_DWORD *)&v109[6] = v26;
      *(_WORD *)&v109[10] = 2160;
      *(_QWORD *)&v109[12] = 1752392040;
      *(_WORD *)&v109[20] = 2081;
      *(_QWORD *)&v109[22] = v27;
      v28 = "%{public}s: [DSO%d] DNS Message (opcode=%d) received from %{private, mask.hash}s";
      goto LABEL_45;
    case 1:
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v8 = *(_DWORD *)(a3 + 48);
      else
        v8 = 0;
      v29 = (*(unsigned __int16 *)(a2 + 90) >> 3) & 0xF;
      v30 = *(_QWORD *)(a3 + 152);
      *(_DWORD *)buf = 136447235;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v8;
      *(_WORD *)&v109[4] = 1024;
      *(_DWORD *)&v109[6] = v29;
      *(_WORD *)&v109[10] = 2160;
      *(_QWORD *)&v109[12] = 1752392040;
      *(_WORD *)&v109[20] = 2081;
      *(_QWORD *)&v109[22] = v30;
      v28 = "%{public}s: [DSO%d] DNS Response (opcode=%d) received from %{private, mask.hash}s";
LABEL_45:
      v31 = buf;
      v32 = v6;
      goto LABEL_58;
    case 2:
      v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v11 = *(_DWORD *)(a3 + 48);
        else
          v11 = 0;
        v33 = *(unsigned __int16 *)(a3 + 88);
        v34 = *(_QWORD *)(a3 + 152);
        *(_DWORD *)buf = 136447235;
        *(_QWORD *)&buf[4] = "dns_push_callback";
        v108 = 1024;
        *(_DWORD *)v109 = v11;
        *(_WORD *)&v109[4] = 1024;
        *(_DWORD *)&v109[6] = v33;
        *(_WORD *)&v109[10] = 2160;
        *(_QWORD *)&v109[12] = 1752392040;
        *(_WORD *)&v109[20] = 2081;
        *(_QWORD *)&v109[22] = v34;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d] DSO Message (Primary TLV=%d) received from %{private, mask.hash}s", buf, 0x2Cu);
      }
      if (*(_DWORD *)(a1 + 40) || *(__int16 *)(a3 + 88) == -1780)
        goto LABEL_96;
      if (num_push_sessions != 15)
      {
        v57 = ++num_push_sessions;
        v58 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v59 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "dso_limit";
          v108 = 1024;
          *(_DWORD *)v109 = v59;
          *(_WORD *)&v109[4] = 1024;
          *(_DWORD *)&v109[6] = v57;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d] new DNS Push connection, count is now %d", buf, 0x18u);
        }
        *(_DWORD *)(a1 + 40) = 1;
LABEL_96:
        v60 = *(unsigned __int16 *)(a3 + 88);
        switch(*(_WORD *)(a3 + 88))
        {
          case '@':
            v61 = (_WORD *)(a2 + 88);
            v62 = "DNS Push Subscribe";
            goto LABEL_105;
          case 'A':
            v66 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v67 = *(_DWORD *)(a3 + 48);
              v68 = *(_DWORD *)(a1 + 4);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "dso_message";
              v108 = 1024;
              *(_DWORD *)v109 = v67;
              *(_WORD *)&v109[4] = 1024;
              *(_DWORD *)&v109[6] = v68;
              *(_WORD *)&v109[10] = 1024;
              *(_DWORD *)&v109[12] = 65;
              _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] bogus push update message %d", buf, 0x1Eu);
            }
            dso_state_cancel(a3);
            return;
          case 'B':
            v61 = (_WORD *)(a2 + 88);
            v62 = "DNS Push Unsubscribe";
LABEL_105:
            dns_push_subscription_change((uint64_t)v62, a1, v61, a3);
            return;
          case 'C':
            v69 = *(_QWORD *)(a1 + 8);
            v98 = 0;
            memset(rrtype, 0, sizeof(rrtype));
            v97 = *(_DWORD *)(a3 + 96) - (a2 + 100);
            v70 = v97 + *(unsigned __int16 *)(a3 + 90);
            v71 = *(_QWORD *)(v69 + 200);
            if (dns_rr_parse_((uint64_t)rrtype, a2 + 100, v70, &v97, 0)
              && dns_u16_parse(a2 + 100, v70, &v97, &v98))
            {
              v72 = v98;
              v73 = v97;
              if (v97 + v98 == v70)
              {
                if (dp_served(*(uint64_t **)rrtype, (uint64_t)buf))
                {
                  v74 = strlen(buf);
                  if (v74 - 249 <= 0xFFFFFFFFFFFFFEFELL)
                  {
                    dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 1);
                    v76 = global_os_log;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                      goto LABEL_123;
                    v77 = *(_DWORD *)(a3 + 48);
                    v78 = *(_DWORD *)(v69 + 180);
                    if (v71)
                      v79 = *(_DWORD *)(v71 + 4);
                    else
                      v79 = 0;
                    *(_DWORD *)v99 = 136447234;
                    *(_QWORD *)&v99[4] = "dns_push_reconfirm";
                    *(_WORD *)&v99[12] = 1024;
                    *(_DWORD *)&v99[14] = v77;
                    v100 = 1024;
                    v101 = v78;
                    v102 = 1024;
                    v103 = v79;
                    v104 = 2080;
                    v105 = buf;
                    v84 = "%{public}s: [DSO%d][C%d][TRK%d] name is too long for .local suffix: %s";
                    v85 = v99;
LABEL_121:
                    v86 = v76;
                    v87 = 40;
LABEL_122:
                    _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, v84, v85, v87);
                    goto LABEL_123;
                  }
                  *(_QWORD *)&buf[v74] = 0x2E6C61636F6C2ELL;
                }
                else
                {
                  dns_name_print_to_limit(*(uint64_t **)rrtype, 0, (uint64_t)&buf[8], 0xF8uLL);
                }
                DNSServiceReconfirmRecord(0, (uint32_t)buf, (const char *)rrtype[4], rrtype[5], v72, a2 + v73 + 100, v75);
                dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 0);
              }
              else
              {
                v90 = v97 + v98;
                dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 1);
                v91 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  v92 = *(_DWORD *)(a3 + 48);
                  v93 = *(_DWORD *)(v69 + 180);
                  if (v71)
                    v94 = *(_DWORD *)(v71 + 4);
                  else
                    v94 = 0;
                  v95 = *(_QWORD *)(a3 + 152);
                  *(_DWORD *)buf = 136447746;
                  *(_QWORD *)&buf[4] = "dns_push_reconfirm";
                  v108 = 1024;
                  *(_DWORD *)v109 = v92;
                  *(_WORD *)&v109[4] = 1024;
                  *(_DWORD *)&v109[6] = v93;
                  *(_WORD *)&v109[10] = 1024;
                  *(_DWORD *)&v109[12] = v94;
                  *(_WORD *)&v109[16] = 2080;
                  *(_QWORD *)&v109[18] = v95;
                  *(_WORD *)&v109[26] = 1024;
                  *(_DWORD *)&v109[28] = v90;
                  v110 = 1024;
                  v111 = v70;
                  v84 = "%{public}s: [DSO%d][C%d][TRK%d] RRdata parse from %s failed: length mismatch (%d != %d)";
                  v85 = buf;
                  v86 = v91;
                  v87 = 52;
                  goto LABEL_122;
                }
              }
LABEL_123:
              dns_rrdata_free((uint64_t)rrtype);
              v88 = *(_QWORD **)rrtype;
              do
              {
                if (!v88)
                  break;
                v89 = (_QWORD *)*v88;
                free(v88);
                v88 = v89;
              }
              while (v89);
              return;
            }
            dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 1);
            v76 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_123;
            v80 = *(_DWORD *)(a3 + 48);
            v81 = *(_DWORD *)(v69 + 180);
            if (v71)
              v82 = *(_DWORD *)(v71 + 4);
            else
              v82 = 0;
            v83 = *(_QWORD *)(a3 + 152);
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "dns_push_reconfirm";
            v108 = 1024;
            *(_DWORD *)v109 = v80;
            *(_WORD *)&v109[4] = 1024;
            *(_DWORD *)&v109[6] = v81;
            *(_WORD *)&v109[10] = 1024;
            *(_DWORD *)&v109[12] = v82;
            *(_WORD *)&v109[16] = 2080;
            *(_QWORD *)&v109[18] = v83;
            v84 = "%{public}s: [DSO%d][C%d][TRK%d] RR parse from %s failed";
            v85 = buf;
            goto LABEL_121;
          default:
            v63 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v64 = *(_DWORD *)(a3 + 48);
              v65 = *(_DWORD *)(a1 + 4);
              *(_DWORD *)buf = 136446978;
              *(_QWORD *)&buf[4] = "dso_message";
              v108 = 1024;
              *(_DWORD *)v109 = v64;
              *(_WORD *)&v109[4] = 1024;
              *(_DWORD *)&v109[6] = v65;
              *(_WORD *)&v109[10] = 1024;
              *(_DWORD *)&v109[12] = v60;
              _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] unexpected primary TLV %d", buf, 0x1Eu);
            }
            dso_simple_response(*(_QWORD *)(a1 + 8), 0, (_WORD *)(a2 + 88), 11);
            return;
        }
      }
      v35 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v36 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "dso_limit";
        v108 = 1024;
        *(_DWORD *)v109 = v36;
        *(_WORD *)&v109[4] = 1024;
        *(_DWORD *)&v109[6] = 15;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d] no more DNS Push connections allowed--sending retry-delay: %d", buf, 0x18u);
      }
      dso_retry_delay_response(*(_QWORD *)(a1 + 8), a2, *(_WORD *)(a2 + 88), *(unsigned __int16 *)(a2 + 90));
      ++num_push_sessions_dropped_for_load;
      dp_tracker_idle_after(a1, 5, 0);
      return;
    case 3:
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v13 = *(_DWORD *)(a3 + 48);
      else
        v13 = 0;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v13;
      v28 = "%{public}s: [DSO%d] Finalize";
      goto LABEL_87;
    case 4:
      v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v15 = *(_DWORD *)(a3 + 48);
      else
        v15 = 0;
      v37 = *(unsigned __int16 *)(a3 + 88);
      v38 = *(_QWORD *)(a3 + 152);
      *(_DWORD *)buf = 136447235;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v15;
      *(_WORD *)&v109[4] = 1024;
      *(_DWORD *)&v109[6] = v37;
      *(_WORD *)&v109[10] = 2160;
      *(_QWORD *)&v109[12] = 1752392040;
      *(_WORD *)&v109[20] = 2081;
      *(_QWORD *)&v109[22] = v38;
      v28 = "%{public}s: [DSO%d] DSO Response (Primary TLV=%d) received from %{private, mask.hash}s";
      v31 = buf;
      v32 = v14;
LABEL_58:
      v39 = OS_LOG_TYPE_DEFAULT;
      v40 = 44;
      goto LABEL_88;
    case 5:
      v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v17 = *(_DWORD *)(a3 + 48);
      else
        v17 = 0;
      v41 = *(_QWORD *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v17;
      *(_WORD *)&v109[4] = 2160;
      *(_QWORD *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(_QWORD *)&v109[16] = v41;
      v28 = "%{public}s: [DSO%d] Connected to %{private, mask.hash}s";
      goto LABEL_67;
    case 6:
      v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v18 = *(_DWORD *)(a3 + 48);
      else
        v18 = 0;
      v42 = *(_QWORD *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v18;
      *(_WORD *)&v109[4] = 2160;
      *(_QWORD *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(_QWORD *)&v109[16] = v42;
      v28 = "%{public}s: [DSO%d] Connection to %{private, mask.hash}s failed";
      goto LABEL_67;
    case 7:
      v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v19 = *(_DWORD *)(a3 + 48);
      else
        v19 = 0;
      v43 = *(_QWORD *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v19;
      *(_WORD *)&v109[4] = 2160;
      *(_QWORD *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(_QWORD *)&v109[16] = v43;
      v28 = "%{public}s: [DSO%d] Connection to %{private, mask.hash}s disconnected";
      goto LABEL_67;
    case 8:
      v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v20 = *(_DWORD *)(a3 + 48);
      else
        v20 = 0;
      v44 = *(_QWORD *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v20;
      *(_WORD *)&v109[4] = 2160;
      *(_QWORD *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(_QWORD *)&v109[16] = v44;
      v28 = "%{public}s: [DSO%d] Connection to %{private, mask.hash}s should reconnect (not for a server)";
LABEL_67:
      v31 = buf;
      v32 = v16;
      v39 = OS_LOG_TYPE_DEFAULT;
      v40 = 38;
      goto LABEL_88;
    case 9:
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v21 = *(_DWORD *)(a3 + 48);
      else
        v21 = 0;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v21;
      v28 = "%{public}s: [DSO%d] Inactivity timer went off, closing connection.";
      goto LABEL_87;
    case 10:
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v22 = *(_DWORD *)(a3 + 48);
      else
        v22 = 0;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v22;
      v28 = "%{public}s: [DSO%d] should send a keepalive now.";
      goto LABEL_87;
    case 11:
      *(_BYTE *)(a2 + 10) = 0;
      v23 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        if (a3)
          v24 = *(_DWORD *)(a3 + 48);
        else
          v24 = 0;
        v45 = *(_QWORD *)(*(_QWORD *)(a3 + 32) + 192);
        v46 = *(unsigned __int16 *)(a2 + 8);
        *(_DWORD *)buf = 136447235;
        *(_QWORD *)&buf[4] = "dns_push_callback";
        v108 = 1024;
        *(_DWORD *)v109 = v24;
        *(_WORD *)&v109[4] = 2160;
        *(_QWORD *)&v109[6] = 1752392040;
        *(_WORD *)&v109[14] = 2081;
        *(_QWORD *)&v109[16] = v45;
        *(_WORD *)&v109[24] = 1024;
        *(_DWORD *)&v109[26] = v46;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d] %{private, mask.hash}s: keepalive received, xid %04x.", buf, 0x2Cu);
      }
      if (!*(_BYTE *)(a3 + 52))
        return;
      if (!*(_QWORD *)(a3 + 32))
      {
        v53 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          return;
        v54 = *(_QWORD *)(a3 + 152);
        *(_DWORD *)buf = 136446723;
        *(_QWORD *)&buf[4] = "dp_keepalive_response_send";
        v108 = 2160;
        *(_QWORD *)v109 = 1752392040;
        *(_WORD *)&v109[8] = 2081;
        *(_QWORD *)&v109[10] = v54;
        v28 = "%{public}s: dso state %{private, mask.hash}s has no transport";
        v31 = buf;
        v32 = v53;
        v39 = OS_LOG_TYPE_ERROR;
        v40 = 32;
        goto LABEL_88;
      }
      v47 = *(_WORD *)(a2 + 8);
      *(_QWORD *)buf = 11534336;
      *(_DWORD *)&buf[8] = 0;
      if (!*(_BYTE *)(a3 + 53))
      {
        v96 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)rrtype = 136446210;
          *(_QWORD *)&rrtype[2] = "dso_make_message";
          _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_make_message: FATAL: server attempting to make a DSO message with no session!", (uint8_t *)rrtype, 0xCu);
        }
        __assert_rtn("dso_make_message", "dso.c", 640, "0");
      }
      *(_WORD *)buf = v47;
      v108 = 256;
      if (&v109[6] >= v112)
      {
        v55 = 3771;
      }
      else
      {
        *(_DWORD *)&v109[2] = bswap32(*(_DWORD *)a2);
        if (&v109[10] < v112)
        {
          *(_DWORD *)&v109[6] = bswap32(*(_DWORD *)(a2 + 4));
          v109[0] = (unsigned __int16)(&v109[10] - v109 - 2) >> 8;
          v109[1] = &v109[10] - v109 - 2;
          *(_QWORD *)v99 = buf;
          *(_QWORD *)&v99[8] = &v109[10] - buf;
          v48 = ioloop_send_message(*(_QWORD *)(a3 + 32), 0, (iovec *)v99);
          v49 = global_os_log;
          v50 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if ((v48 & 1) != 0)
          {
            if (!v50)
              return;
            v51 = *(unsigned __int16 *)(a2 + 8);
            v52 = *(_QWORD *)(*(_QWORD *)(a3 + 32) + 192);
            *(_DWORD *)rrtype = 136447747;
            *(_QWORD *)&rrtype[2] = "dp_keepalive_response_send";
            rrtype[6] = 2048;
            *(_QWORD *)&rrtype[7] = *(_QWORD *)&v99[8];
            rrtype[11] = 1024;
            *(_DWORD *)&rrtype[12] = buf[0];
            rrtype[14] = 1024;
            *(_DWORD *)&rrtype[15] = buf[1];
            rrtype[17] = 1024;
            *(_DWORD *)&rrtype[18] = v51;
            rrtype[20] = 2160;
            *(_QWORD *)&rrtype[21] = 1752392040;
            rrtype[25] = 2081;
            *(_QWORD *)&rrtype[26] = v52;
            v28 = "%{public}s: sent %zd byte response Keepalive, xid %02x%02x (was %04x), to %{private, mask.hash}s";
            v31 = (uint8_t *)rrtype;
            v32 = v49;
            v39 = OS_LOG_TYPE_DEFAULT;
            v40 = 60;
          }
          else
          {
            if (!v50)
              return;
            *(_DWORD *)rrtype = 136446210;
            *(_QWORD *)&rrtype[2] = "dp_keepalive_response_send";
            v28 = "%{public}s: send failed";
            v31 = (uint8_t *)rrtype;
            v32 = v49;
            v39 = OS_LOG_TYPE_DEFAULT;
            v40 = 12;
          }
LABEL_88:
          _os_log_impl((void *)&_mh_execute_header, v32, v39, v28, v31, v40);
          return;
        }
        v55 = 3772;
      }
      v56 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        return;
      *(_DWORD *)rrtype = 136446722;
      *(_QWORD *)&rrtype[2] = "dp_keepalive_response_send";
      rrtype[6] = 2082;
      *(_QWORD *)&rrtype[7] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c";
      rrtype[11] = 1024;
      *(_DWORD *)&rrtype[12] = v55;
      v28 = "%{public}s: ran out of message space at %{public}s, :%d";
      v31 = (uint8_t *)rrtype;
      v32 = v56;
      v39 = OS_LOG_TYPE_ERROR;
      v40 = 28;
      goto LABEL_88;
    case 12:
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      if (a3)
        v25 = *(_DWORD *)(a3 + 48);
      else
        v25 = 0;
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "dns_push_callback";
      v108 = 1024;
      *(_DWORD *)v109 = v25;
      v28 = "%{public}s: [DSO%d] keepalive received.";
LABEL_87:
      v31 = buf;
      v32 = v12;
      v39 = OS_LOG_TYPE_DEFAULT;
      v40 = 18;
      goto LABEL_88;
    default:
      return;
  }
}

void dp_tracker_idle_after(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v6;
  int *v7;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  int v13;
  int v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  int v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  const char *v22;
  __int16 v23;
  char *v24;
  __int16 v25;
  int v26;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    if ((*(_WORD *)(v3 + 416) & 0x100) == 0
      && !*(_QWORD *)(a1 + 24)
      && (!a3 || (v6 = *(_QWORD *)(a1 + 16)) == 0 || v6 == a3 && !*(_QWORD *)(a3 + 16)))
    {
      v7 = *(int **)(a1 + 32);
      if (v7
        || (v7 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 879), (*(_QWORD *)(a1 + 32) = v7) != 0))
      {
        ioloop_add_wake_event((uint64_t)v7, a1, (uint64_t)dp_tracker_idle, (uint64_t)dp_tracker_context_release, 1000 * a2);
        v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(_DWORD *)a1;
          *(_DWORD *)buf = 136447490;
          v16 = "dp_tracker_idle_after";
          v17 = 1024;
          v18 = v9;
          v19 = 2048;
          v20 = a1;
          v21 = 2080;
          v22 = "tracker";
          v23 = 2080;
          v24 = "dnssd-proxy.c";
          v25 = 1024;
          v26 = 885;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        if (*(_DWORD *)a1)
        {
          v10 = *(_DWORD *)a1 + 1;
          *(_DWORD *)a1 = v10;
          if (v10 >= 10001)
          {
            v14 = v10;
            v11 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v16 = "dp_tracker_idle_after";
              v17 = 1024;
              v18 = v14;
              v19 = 2048;
              v20 = a1;
              v21 = 2080;
              v22 = "tracker";
              v23 = 2080;
              v24 = "dnssd-proxy.c";
              v25 = 1024;
              v26 = 885;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            }
            abort();
          }
        }
        else
        {
          ++dp_tracker_created;
          *(_DWORD *)a1 = 1;
        }
      }
      else
      {
        v12 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v13 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)buf = 136446466;
          v16 = "dp_tracker_idle_after";
          v17 = 1024;
          v18 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d] no memory for idle timeout", buf, 0x12u);
        }
      }
    }
  }
}

_QWORD *dns_push_subscription_change(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  int v11;
  uint64_t **activity;
  int v13;
  NSObject *v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  const char *v21;
  NSObject *v22;
  uint64_t v23;
  uint32_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  _QWORD *result;
  _QWORD *v29;
  NSObject *v30;
  int v31;
  int v32;
  uint64_t **v33;
  uint64_t v34;
  uint64_t v35;
  char *v36;
  int v37;
  int v38;
  NSObject *v39;
  int v40;
  int v41;
  uint64_t v42;
  _WORD *v43;
  int v44;
  int *v45;
  uint64_t v46;
  size_t v47;
  NSObject *v48;
  int v49;
  _QWORD *v50;
  _QWORD *v51;
  size_t v52;
  char *v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  int v57;
  int v58;
  int v59;
  NSObject *v60;
  const char *v61;
  NSObject *v62;
  int v63;
  int v64;
  int v65;
  NSObject *v66;
  uint64_t v67;
  NSObject *v68;
  int v69;
  int v70;
  int v71;
  unsigned __int16 v72;
  void *v73[2];
  __int128 v74;
  __int128 v75;
  __int128 v76;
  int v77;
  char __str[5];
  char v79;
  int v80;
  char v81[256];
  int v82;
  const char *v83;
  __int16 v84;
  int v85;
  __int16 v86;
  int v87;
  __int16 v88;
  _BYTE v89[24];
  __int16 v90;
  int v91;
  __int16 v92;
  int v93;
  int buf;
  const char *v95;
  __int16 v96;
  _BYTE v97[50];
  __int16 v98;
  int v99;

  v8 = (uint64_t)(a3 + 6);
  v77 = *(_DWORD *)(a4 + 96) - ((_DWORD)a3 + 12);
  v9 = v77 + *(unsigned __int16 *)(a4 + 90);
  v72 = bswap32((unsigned __int16)*a3) >> 16;
  *(_OWORD *)v73 = 0u;
  v74 = 0u;
  v75 = 0u;
  v76 = 0u;
  if (*(_WORD *)(a4 + 88) == 64)
  {
    if ((dns_rr_parse_((uint64_t)v73, v8, v9, (unsigned int *)&v77, 0) & 1) == 0)
    {
      dso_simple_response(*(_QWORD *)(a2 + 8), 0, a3, 1);
      v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_25;
      v18 = *(_DWORD *)(a4 + 48);
      v19 = *(_DWORD *)(a2 + 4);
      v20 = *(_QWORD *)(a4 + 152);
      buf = 136447234;
      v95 = "dns_push_subscription_change";
      v96 = 1024;
      *(_DWORD *)v97 = v18;
      *(_WORD *)&v97[4] = 1024;
      *(_DWORD *)&v97[6] = v19;
      *(_WORD *)&v97[10] = 2080;
      *(_QWORD *)&v97[12] = v20;
      *(_WORD *)&v97[20] = 2080;
      *(_QWORD *)&v97[22] = a1;
      v21 = "%{public}s: [DSO%d][TRK%d] RR parse for %s from %s failed";
      v22 = v17;
LABEL_23:
      v24 = 44;
      goto LABEL_24;
    }
    dns_name_print_to_limit((uint64_t *)v73[0], 0, (uint64_t)v81, 0x100uLL);
  }
  else
  {
    if (!dns_u16_parse(v8, v9, (unsigned int *)&v77, &v72))
    {
      v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_25;
      buf = 136446210;
      v95 = "dns_push_subscription_change";
      v21 = "%{public}s: unable to get subscribe xid from primary";
      v22 = v23;
      v24 = 12;
      goto LABEL_24;
    }
    strcpy(v81, "none");
  }
  v10 = v77;
  if (v77 != (_DWORD)v9)
  {
    if (*(_WORD *)(a4 + 88) == 64)
      dso_simple_response(*(_QWORD *)(a2 + 8), 0, a3, 1);
    v25 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_25;
    v26 = *(_QWORD *)(a4 + 152);
    if (*(_WORD *)(a4 + 88) == 64)
      v27 = "subscribe";
    else
      v27 = "unsubscribe";
    buf = 136447234;
    v95 = "dns_push_subscription_change";
    v96 = 2082;
    *(_QWORD *)v97 = v27;
    *(_WORD *)&v97[8] = 2080;
    *(_QWORD *)&v97[10] = v26;
    *(_WORD *)&v97[18] = 1024;
    *(_DWORD *)&v97[20] = v10;
    *(_WORD *)&v97[24] = 1024;
    *(_DWORD *)&v97[26] = v9;
    v21 = "%{public}s: DNS push %{public}s parse from %s failed: length mismatch (%d != %d)";
    v22 = v25;
    goto LABEL_23;
  }
  v11 = v72;
  snprintf(__str, 5uLL, "%04x", v72);
  activity = dso_find_activity(a4, __str, 0);
  v13 = *(unsigned __int16 *)(a4 + 88);
  if (!activity)
  {
    v30 = global_os_log;
    if (v13 == 64)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v31 = *(_DWORD *)(a4 + 48);
        if (a2)
          v32 = *(_DWORD *)(a2 + 4);
        else
          v32 = 0;
        buf = 136448003;
        v95 = "dns_push_subscription_change";
        v96 = 1024;
        *(_DWORD *)v97 = v31;
        *(_WORD *)&v97[4] = 1024;
        *(_DWORD *)&v97[6] = v32;
        *(_WORD *)&v97[10] = 2082;
        *(_QWORD *)&v97[12] = a1;
        *(_WORD *)&v97[20] = 2160;
        *(_QWORD *)&v97[22] = 1752392040;
        *(_WORD *)&v97[30] = 2081;
        *(_QWORD *)&v97[32] = v81;
        *(_WORD *)&v97[40] = 2082;
        *(_QWORD *)&v97[42] = __str;
        v98 = 1024;
        v99 = LOWORD(v73[1]);
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) type %d.", (uint8_t *)&buf, 0x46u);
      }
      v80 = 0;
      v45 = dp_query_create((int *)a2, (uint64_t)v73, 0, a4, &v80);
      if (!v45)
      {
        v42 = *(_QWORD *)(a2 + 8);
        v44 = v80;
        v43 = a3;
LABEL_45:
        dso_simple_response(v42, 0, v43, v44);
        goto LABEL_25;
      }
      v46 = (uint64_t)v45;
      v47 = strlen(__str);
      if (dso_find_activity(a4, __str, (uint64_t *)v46))
      {
        v48 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          v49 = *(_DWORD *)(a4 + 48);
          buf = 136447491;
          v95 = "dso_add_activity";
          v96 = 1024;
          *(_DWORD *)v97 = v49;
          *(_WORD *)&v97[4] = 2160;
          *(_QWORD *)&v97[6] = 1752392040;
          *(_WORD *)&v97[14] = 2081;
          *(_QWORD *)&v97[16] = __str;
          *(_WORD *)&v97[24] = 2082;
          *(_QWORD *)&v97[26] = "push subscription";
          *(_WORD *)&v97[34] = 2048;
          *(_QWORD *)&v97[36] = v46;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] Trying to add a duplicate activity - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&buf, 0x3Au);
        }
        v50 = 0;
      }
      else
      {
        if ((_DWORD)v47 == -41 || (v51 = malloc_type_calloc(1uLL, (v47 + 41), 0xF1748037uLL)) == 0)
          __break(1u);
        v50 = v51;
        v52 = v47 + 1;
        if (v47 == -1)
        {
          v53 = 0;
        }
        else
        {
          v53 = (char *)(v51 + 5);
          memcpy(v51 + 5, __str, v52);
        }
        v50[3] = v46;
        v50[4] = v53;
        v50[1] = dns_push_cancel;
        v50[2] = "push subscription";
        v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v55 = *(_DWORD *)(a4 + 48);
          buf = 136447491;
          v95 = "dso_add_activity";
          v96 = 1024;
          *(_DWORD *)v97 = v55;
          *(_WORD *)&v97[4] = 2160;
          *(_QWORD *)&v97[6] = 1752392040;
          *(_WORD *)&v97[14] = 2081;
          *(_QWORD *)&v97[16] = v53;
          *(_WORD *)&v97[24] = 2082;
          *(_QWORD *)&v97[26] = "push subscription";
          *(_WORD *)&v97[34] = 2048;
          *(_QWORD *)&v97[36] = v46;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] Adding a DSO activity - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&buf, 0x3Au);
        }
        *v50 = *(_QWORD *)(a4 + 80);
        *(_QWORD *)(a4 + 80) = v50;
      }
      v56 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v57 = *(_DWORD *)v46;
        buf = 136447490;
        v95 = "dns_push_subscribe";
        v96 = 1024;
        *(_DWORD *)v97 = v57;
        *(_WORD *)&v97[4] = 2048;
        *(_QWORD *)&v97[6] = v46;
        *(_WORD *)&v97[14] = 2080;
        *(_QWORD *)&v97[16] = "query";
        *(_WORD *)&v97[24] = 2080;
        *(_QWORD *)&v97[26] = "dnssd-proxy.c";
        *(_WORD *)&v97[34] = 1024;
        *(_DWORD *)&v97[36] = 3490;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&buf, 0x36u);
      }
      v58 = *(_DWORD *)v46;
      if (*(_DWORD *)v46)
      {
        v59 = v58 + 1;
        *(_DWORD *)v46 = v58 + 1;
        if (v58 + 1 >= 10001)
        {
          v60 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_98;
          buf = 136447490;
          v95 = "dns_push_subscribe";
          v96 = 1024;
          *(_DWORD *)v97 = v59;
          *(_WORD *)&v97[4] = 2048;
          *(_QWORD *)&v97[6] = v46;
          *(_WORD *)&v97[14] = 2080;
          *(_QWORD *)&v97[16] = "query";
          *(_WORD *)&v97[24] = 2080;
          *(_QWORD *)&v97[26] = "dnssd-proxy.c";
          *(_WORD *)&v97[34] = 1024;
          *(_DWORD *)&v97[36] = 3490;
          v61 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_97;
        }
      }
      else
      {
        ++dnssd_query_created;
        *(_DWORD *)v46 = 1;
      }
      *(_QWORD *)(v46 + 80) = v50;
      v79 = 0;
      if ((dp_query_start(v46, &v80, &v79) & 1) != 0)
      {
        dns_name_print_to_limit((uint64_t *)v73[0], 0, (uint64_t)&buf, 0x100uLL);
        dso_simple_response(*(_QWORD *)(a2 + 8), 0, a3, 0);
        if (v79)
        {
          v62 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v63 = *(_DWORD *)(a4 + 48);
            v64 = *(_DWORD *)(v46 + 4);
            v82 = 136447747;
            v83 = "dns_push_subscribe";
            v84 = 1024;
            v85 = v63;
            v86 = 1024;
            v87 = v64;
            v88 = 2160;
            *(_QWORD *)v89 = 1752392040;
            *(_WORD *)&v89[8] = 2081;
            *(_QWORD *)&v89[10] = &buf;
            *(_WORD *)&v89[18] = 1024;
            *(_DWORD *)&v89[20] = LOWORD(v73[1]);
            v90 = 1024;
            v91 = WORD1(v73[1]);
            _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][Q%d] hardwired response for %{private, mask.hash}s %d %d", (uint8_t *)&v82, 0x38u);
          }
          dp_push_response(v46, (uint64_t **)v73);
        }
        else
        {
          v67 = *(_QWORD *)(v46 + 192);
          if (v67)
          {
            v68 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v69 = *(_DWORD *)(a4 + 48);
              v70 = *(_DWORD *)(v46 + 4);
              v71 = *(_DWORD *)(v67 + 64);
              v82 = 136448003;
              v83 = "dns_push_subscribe";
              v84 = 1024;
              v85 = v69;
              v86 = 1024;
              v87 = v70;
              v88 = 1024;
              *(_DWORD *)v89 = v71;
              *(_WORD *)&v89[4] = 2160;
              *(_QWORD *)&v89[6] = 1752392040;
              *(_WORD *)&v89[14] = 2081;
              *(_QWORD *)&v89[16] = &buf;
              v90 = 1024;
              v91 = LOWORD(v73[1]);
              v92 = 1024;
              v93 = WORD1(v73[1]);
              _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][Q%d][QU%d] replying from cache for %{private, mask.hash}s %d %d", (uint8_t *)&v82, 0x3Eu);
              v67 = *(_QWORD *)(v46 + 192);
            }
            dp_query_reply_from_cache(v67, v46, 0);
          }
        }
      }
      else
      {
        dso_simple_response(*(_QWORD *)(a2 + 8), 0, a3, v80);
        dp_question_cache_remove_queries(*(_QWORD *)(v46 + 192));
        dnssd_query_cancel(v46);
      }
      v65 = *(_DWORD *)v46;
      if (*(_DWORD *)v46)
      {
        v60 = global_os_log;
        if (v65 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            buf = 136447490;
            v95 = "dns_push_subscribe";
            v96 = 1024;
            *(_DWORD *)v97 = v65;
            *(_WORD *)&v97[4] = 2048;
            *(_QWORD *)&v97[6] = v46;
            *(_WORD *)&v97[14] = 2080;
            *(_QWORD *)&v97[16] = "query";
            *(_WORD *)&v97[24] = 2080;
            *(_QWORD *)&v97[26] = "dnssd-proxy.c";
            *(_WORD *)&v97[34] = 1024;
            *(_DWORD *)&v97[36] = 3522;
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&buf, 0x36u);
            v65 = *(_DWORD *)v46;
          }
          *(_DWORD *)v46 = v65 - 1;
          if (v65 == 1)
          {
            v66 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              buf = 136447234;
              v95 = "dns_push_subscribe";
              v96 = 2048;
              *(_QWORD *)v97 = v46;
              *(_WORD *)&v97[8] = 2080;
              *(_QWORD *)&v97[10] = "query";
              *(_WORD *)&v97[18] = 2080;
              *(_QWORD *)&v97[20] = "dnssd-proxy.c";
              *(_WORD *)&v97[28] = 1024;
              *(_DWORD *)&v97[30] = 3522;
              _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&buf, 0x30u);
            }
            ++dnssd_query_finalized;
            dnssd_query_finalize((_QWORD *)v46);
          }
          goto LABEL_25;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_98:
          abort();
        buf = 136447490;
        v95 = "dns_push_subscribe";
        v96 = 1024;
        *(_DWORD *)v97 = v65;
        *(_WORD *)&v97[4] = 2048;
        *(_QWORD *)&v97[6] = v46;
        *(_WORD *)&v97[14] = 2080;
        *(_QWORD *)&v97[16] = "query";
        *(_WORD *)&v97[24] = 2080;
        *(_QWORD *)&v97[26] = "dnssd-proxy.c";
        *(_WORD *)&v97[34] = 1024;
        *(_DWORD *)&v97[36] = 3522;
        v61 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        v60 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_98;
        buf = 136447490;
        v95 = "dns_push_subscribe";
        v96 = 1024;
        *(_DWORD *)v97 = 0;
        *(_WORD *)&v97[4] = 2048;
        *(_QWORD *)&v97[6] = v46;
        *(_WORD *)&v97[14] = 2080;
        *(_QWORD *)&v97[16] = "query";
        *(_WORD *)&v97[24] = 2080;
        *(_QWORD *)&v97[26] = "dnssd-proxy.c";
        *(_WORD *)&v97[34] = 1024;
        *(_DWORD *)&v97[36] = 3522;
        v61 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
LABEL_97:
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_FAULT, v61, (uint8_t *)&buf, 0x36u);
      goto LABEL_98;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_25;
    v37 = *(_DWORD *)(a4 + 48);
    if (a2)
      v38 = *(_DWORD *)(a2 + 4);
    else
      v38 = 0;
    buf = 136447747;
    v95 = "dns_push_subscription_change";
    v96 = 1024;
    *(_DWORD *)v97 = v37;
    *(_WORD *)&v97[4] = 1024;
    *(_DWORD *)&v97[6] = v38;
    *(_WORD *)&v97[10] = 2082;
    *(_QWORD *)&v97[12] = a1;
    *(_WORD *)&v97[20] = 2160;
    *(_QWORD *)&v97[22] = 1752392040;
    *(_WORD *)&v97[30] = 2081;
    *(_QWORD *)&v97[32] = v81;
    *(_WORD *)&v97[40] = 2082;
    *(_QWORD *)&v97[42] = __str;
    v21 = "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) when no subscription exists.";
    v22 = v30;
    v24 = 64;
LABEL_24:
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, v21, (uint8_t *)&buf, v24);
    goto LABEL_25;
  }
  if (v13 == 64)
  {
    v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v15 = *(_DWORD *)(a4 + 48);
      if (a2)
        v16 = *(_DWORD *)(a2 + 4);
      else
        v16 = 0;
      buf = 136448003;
      v95 = "dns_push_subscription_change";
      v96 = 1024;
      *(_DWORD *)v97 = v15;
      *(_WORD *)&v97[4] = 1024;
      *(_DWORD *)&v97[6] = v16;
      *(_WORD *)&v97[10] = 2082;
      *(_QWORD *)&v97[12] = a1;
      *(_WORD *)&v97[20] = 2160;
      *(_QWORD *)&v97[22] = 1752392040;
      *(_WORD *)&v97[30] = 2081;
      *(_QWORD *)&v97[32] = v81;
      *(_WORD *)&v97[40] = 2082;
      *(_QWORD *)&v97[42] = __str;
      v98 = 1024;
      v99 = v11;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) xid %d when subscription already exists.", (uint8_t *)&buf, 0x46u);
    }
    v42 = *(_QWORD *)(a2 + 8);
    v43 = a3;
    v44 = 5;
    goto LABEL_45;
  }
  v33 = activity;
  v34 = (uint64_t)activity[3];
  v35 = *(_QWORD *)(v34 + 192);
  if (v35)
    v36 = *(char **)(v35 + 32);
  else
    v36 = v81;
  v39 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v40 = *(_DWORD *)(a4 + 48);
    if (a2)
      v41 = *(_DWORD *)(a2 + 4);
    else
      v41 = 0;
    buf = 136448003;
    v95 = "dns_push_subscription_change";
    v96 = 1024;
    *(_DWORD *)v97 = v40;
    *(_WORD *)&v97[4] = 1024;
    *(_DWORD *)&v97[6] = v41;
    *(_WORD *)&v97[10] = 2082;
    *(_QWORD *)&v97[12] = a1;
    *(_WORD *)&v97[20] = 2160;
    *(_QWORD *)&v97[22] = 1752392040;
    *(_WORD *)&v97[30] = 2081;
    *(_QWORD *)&v97[32] = v36;
    *(_WORD *)&v97[40] = 2082;
    *(_QWORD *)&v97[42] = __str;
    v98 = 1024;
    v99 = LOWORD(v73[1]);
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) type %d.", (uint8_t *)&buf, 0x46u);
    v34 = (uint64_t)v33[3];
  }
  dnssd_query_cancel(v34);
LABEL_25:
  dns_rrdata_free((uint64_t)v73);
  result = v73[0];
  do
  {
    if (!result)
      break;
    v29 = (_QWORD *)*result;
    free(result);
    result = v29;
  }
  while (v29);
  return result;
}

uint64_t *dp_served(uint64_t *a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t *v5;

  v4 = &served_domains;
  while (1)
  {
    v4 = (uint64_t *)*v4;
    if (!v4)
      break;
    v5 = dns_name_subdomain_of(a1, (uint64_t **)v4[3]);
    if (v5)
    {
      dns_name_print_to_limit(a1, v5, a2, 0x100uLL);
      return v4;
    }
  }
  return v4;
}

int *dp_query_create(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t *v10;
  int *v11;
  int *v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  NSObject *v17;
  const char *v18;
  uint8_t *v19;
  NSObject *v20;
  int v21;
  uint64_t v22;
  int v23;
  const char *v24;
  int v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  uint64_t v30;
  int v31;
  const char *v32;
  int v33;
  int v34;
  _DWORD *v35;
  NSObject *v36;
  int v37;
  int v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t *v44;
  uint64_t v45;
  int v46;
  void *v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  _DWORD *v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  int v58;
  NSObject *v59;
  int v60;
  int v61;
  int v62;
  int **v63;
  int **v64;
  int *v65;
  NSObject *v66;
  int *v67;
  int v68;
  int v69;
  int v70;
  NSObject *v71;
  int v72;
  const char *v73;
  uint64_t v74;
  int v75;
  int v76;
  NSObject *v78;
  NSObject *v79;
  int v80;
  NSObject *v81;
  NSObject *v82;
  int v83;
  NSObject *v84;
  NSObject *v85;
  int v86;
  NSObject *v87;
  unsigned int v88;
  _BYTE v89[256];
  _BYTE __tp[48];
  __int16 v91;
  int v92;
  uint8_t buf[4];
  const char *v94;
  __int16 v95;
  _BYTE v96[36];
  _BYTE v97[6];
  __int16 v98;
  uint64_t v99;
  __int16 v100;
  _BYTE *v101;
  __int16 v102;
  uint64_t v103;
  __int16 v104;
  uint64_t v105;
  __int16 v106;
  uint64_t v107;
  __int16 v108;
  _BYTE *v109;

  v10 = dp_served(*(uint64_t **)a2, (uint64_t)v89);
  if (a3)
    v88 = bswap32(*(unsigned __int16 *)(a3 + 88)) >> 16;
  else
    v88 = 0;
  v11 = (int *)malloc_type_calloc(1uLL, 0xD0uLL, 0x1030040B73B653FuLL);
  if (!v11)
  {
    *a5 = 2;
    v78 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446723;
      v94 = "dp_query_create";
      v95 = 2160;
      *(_QWORD *)v96 = 1752392040;
      *(_WORD *)&v96[8] = 2081;
      *(_QWORD *)&v96[10] = v89;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%{public}s: Unable to allocate memory for query on %{private, mask.hash}s", buf, 0x20u);
    }
    return 0;
  }
  v12 = v11;
  v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *v12;
    *(_DWORD *)buf = 136447490;
    v94 = "dp_query_create";
    v95 = 1024;
    *(_DWORD *)v96 = v14;
    *(_WORD *)&v96[4] = 2048;
    *(_QWORD *)&v96[6] = v12;
    *(_WORD *)&v96[14] = 2080;
    *(_QWORD *)&v96[16] = "query";
    *(_WORD *)&v96[24] = 2080;
    *(_QWORD *)&v96[26] = "dnssd-proxy.c";
    *(_WORD *)&v96[34] = 1024;
    *(_DWORD *)v97 = 3328;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v15 = *v12;
  if (*v12)
  {
    v16 = v15 + 1;
    *v12 = v15 + 1;
    if (v15 + 1 >= 10001)
    {
      v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_112;
      *(_DWORD *)buf = 136447490;
      v94 = "dp_query_create";
      v95 = 1024;
      *(_DWORD *)v96 = v16;
      *(_WORD *)&v96[4] = 2048;
      *(_QWORD *)&v96[6] = v12;
      *(_WORD *)&v96[14] = 2080;
      *(_QWORD *)&v96[16] = "query";
      *(_WORD *)&v96[24] = 2080;
      *(_QWORD *)&v96[26] = "dnssd-proxy.c";
      *(_WORD *)&v96[34] = 1024;
      *(_DWORD *)v97 = 3328;
      v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_11;
    }
  }
  else
  {
    ++dnssd_query_created;
    *v12 = 1;
  }
  v21 = cur_query_serial + 1;
  cur_query_serial = v21;
  v12[1] = v21;
  if (v10)
  {
    v22 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_23;
    v23 = *(unsigned __int16 *)(a2 + 8);
    v24 = "push";
    v25 = *(unsigned __int16 *)(a2 + 10);
    v26 = v10[1];
    if (!a4)
      v24 = " dns";
    *(_DWORD *)buf = 136449283;
    v94 = "dp_query_create";
    v95 = 1024;
    *(_DWORD *)v96 = v21;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v88;
    *(_WORD *)&v96[10] = 2048;
    *(_QWORD *)&v96[12] = a3;
    *(_WORD *)&v96[20] = 2082;
    *(_QWORD *)&v96[22] = v24;
    *(_WORD *)&v96[30] = 1024;
    *(_DWORD *)&v96[32] = v23;
    *(_WORD *)v97 = 1024;
    *(_DWORD *)&v97[2] = v25;
    v98 = 2160;
    v99 = 1752392040;
    v100 = 2081;
    v101 = v89;
    v102 = 2160;
    v103 = 1752392040;
    v104 = 2081;
    v105 = v26;
    v106 = 2160;
    v107 = 1752392040;
    v108 = 2081;
    v109 = v89;
    v27 = "%{public}s: [Q%d][QID%x] msg %p %{public}s question: type %d class %d %{private, mask.hash}s.%{private, mask.h"
          "ash}s -> %{private, mask.hash}s.local.";
    v28 = v22;
    v29 = 116;
  }
  else
  {
    dns_name_print_to_limit(*(uint64_t **)a2, 0, (uint64_t)v89, 0x100uLL);
    v30 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_23;
    v31 = v12[1];
    v32 = "push";
    v33 = *(unsigned __int16 *)(a2 + 8);
    v34 = *(unsigned __int16 *)(a2 + 10);
    if (!a4)
      v32 = " dns";
    *(_DWORD *)buf = 136448259;
    v94 = "dp_query_create";
    v95 = 1024;
    *(_DWORD *)v96 = v31;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v88;
    *(_WORD *)&v96[10] = 2048;
    *(_QWORD *)&v96[12] = a3;
    *(_WORD *)&v96[20] = 2082;
    *(_QWORD *)&v96[22] = v32;
    *(_WORD *)&v96[30] = 1024;
    *(_DWORD *)&v96[32] = v33;
    *(_WORD *)v97 = 1024;
    *(_DWORD *)&v97[2] = v34;
    v98 = 2160;
    v99 = 1752392040;
    v100 = 2081;
    v101 = v89;
    v27 = "%{public}s: [Q%d][QID%x] msg %p %{public}s question: type %d class %d %{private, mask.hash}s";
    v28 = v30;
    v29 = 76;
  }
  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
LABEL_23:
  v35 = malloc_type_malloc(0x582uLL, 0x10000408470CEFFuLL);
  *((_QWORD *)v12 + 20) = v35;
  if (!v35)
  {
    *a5 = 2;
    v79 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v80 = v12[1];
      *(_DWORD *)buf = 136446979;
      v94 = "dp_query_create";
      v95 = 1024;
      *(_DWORD *)v96 = v80;
      *(_WORD *)&v96[4] = 2160;
      *(_QWORD *)&v96[6] = 1752392040;
      *(_WORD *)&v96[14] = 2081;
      *(_QWORD *)&v96[16] = v89;
      _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] Unable to allocate memory for query response on %{private, mask.hash}s", buf, 0x26u);
      if (!*a5)
        return v12;
    }
    goto LABEL_96;
  }
  *((_QWORD *)v12 + 22) = 1398;
  v35[2] = 0;
  *(_QWORD *)v35 = 0;
  *((_QWORD *)v12 + 1) = a1;
  if (a1)
  {
    v36 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v37 = *a1;
      *(_DWORD *)buf = 136447490;
      v94 = "dp_query_create";
      v95 = 1024;
      *(_DWORD *)v96 = v37;
      *(_WORD *)&v96[4] = 2048;
      *(_QWORD *)&v96[6] = a1;
      *(_WORD *)&v96[14] = 2080;
      *(_QWORD *)&v96[16] = "query->tracker";
      *(_WORD *)&v96[24] = 2080;
      *(_QWORD *)&v96[26] = "dnssd-proxy.c";
      *(_WORD *)&v96[34] = 1024;
      *(_DWORD *)v97 = 3356;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      a1 = (int *)*((_QWORD *)v12 + 1);
    }
    v38 = *a1;
    if (*a1)
    {
      v39 = v38 + 1;
      *a1 = v38 + 1;
      if (v38 + 1 >= 10001)
      {
        v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_112;
        *(_DWORD *)buf = 136447490;
        v94 = "dp_query_create";
        v95 = 1024;
        *(_DWORD *)v96 = v39;
        *(_WORD *)&v96[4] = 2048;
        *(_QWORD *)&v96[6] = a1;
        *(_WORD *)&v96[14] = 2080;
        *(_QWORD *)&v96[16] = "query->tracker";
        *(_WORD *)&v96[24] = 2080;
        *(_QWORD *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)v97 = 3356;
        v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        v19 = buf;
        goto LABEL_110;
      }
    }
    else
    {
      ++dp_tracker_created;
      *a1 = 1;
    }
  }
  *((_QWORD *)v12 + 9) = a4;
  if (a3)
  {
    *((_QWORD *)v12 + 8) = a3;
    ioloop_message_retain_((int *)a3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 3364);
  }
  v41 = *((_QWORD *)v12 + 20);
  v42 = v41 + 12 + *((_QWORD *)v12 + 22);
  *((_QWORD *)v12 + 12) = v41;
  *((_QWORD *)v12 + 13) = v41 + 12;
  *((_QWORD *)v12 + 19) = 0;
  *((_QWORD *)v12 + 15) = 0;
  *((_QWORD *)v12 + 16) = 0;
  *((_QWORD *)v12 + 14) = v42;
  v43 = dp_served(*(uint64_t **)a2, (uint64_t)buf);
  if (v43)
  {
    v44 = v43 + 6;
  }
  else
  {
    dns_name_print_to_limit(*(uint64_t **)a2, 0, (uint64_t)buf, 0x100uLL);
    v44 = &questions_without_domain;
  }
  v45 = *v44;
  if (!*v44)
  {
LABEL_43:
    v47 = malloc_type_calloc(1uLL, 0x50uLL, 0x1030040F8A6FD2BuLL);
    if (v47)
    {
      v48 = (uint64_t)v47;
      v49 = strdup((const char *)buf);
      *(_QWORD *)(v48 + 32) = v49;
      if (v49)
      {
        *(_DWORD *)(v48 + 72) = *(_DWORD *)(a2 + 8);
        *(_QWORD *)__tp = 0;
        *(_QWORD *)&__tp[8] = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
        v50 = *(_QWORD *)&__tp[8] / 1000 + 1000000 * *(_QWORD *)__tp;
        *(_QWORD *)(v48 + 40) = 0;
        *(_QWORD *)(v48 + 48) = v50;
        *(_QWORD *)(v48 + 8) = v43;
        *(_QWORD *)(v48 + 16) = 0;
        *(_BYTE *)(v48 + 76) = 0;
        *(_DWORD *)(v48 + 64) = ++cur_question_serial;
        if (v43)
        {
          v51 = (_DWORD *)v43[5];
          if (v51)
          {
            LODWORD(v51) = *v51;
            v52 = 1024;
LABEL_50:
            *(_DWORD *)(v48 + 68) = (_DWORD)v51;
            *(_DWORD *)(v48 + 56) = v52;
            *(_QWORD *)v48 = *v44;
            *v44 = v48;
            v53 = global_os_log;
            v54 = v48;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v55 = *(_DWORD *)(v48 + 60);
              *(_DWORD *)__tp = 136447490;
              *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
              *(_WORD *)&__tp[12] = 1024;
              *(_DWORD *)&__tp[14] = v55;
              *(_WORD *)&__tp[18] = 2048;
              *(_QWORD *)&__tp[20] = v48;
              *(_WORD *)&__tp[28] = 2080;
              *(_QWORD *)&__tp[30] = "*questions";
              *(_WORD *)&__tp[38] = 2080;
              *(_QWORD *)&__tp[40] = "dnssd-proxy.c";
              v91 = 1024;
              v92 = 3166;
              _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", __tp, 0x36u);
              v54 = *v44;
            }
            v56 = *(_DWORD *)(v54 + 60);
            if (v56)
            {
              v57 = v56 + 1;
              *(_DWORD *)(v54 + 60) = v56 + 1;
              if (v56 + 1 >= 10001)
              {
                v40 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  goto LABEL_112;
                *(_DWORD *)__tp = 136447490;
                *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
                *(_WORD *)&__tp[12] = 1024;
                *(_DWORD *)&__tp[14] = v57;
                *(_WORD *)&__tp[18] = 2048;
                *(_QWORD *)&__tp[20] = v54;
                *(_WORD *)&__tp[28] = 2080;
                *(_QWORD *)&__tp[30] = "*questions";
                *(_WORD *)&__tp[38] = 2080;
                *(_QWORD *)&__tp[40] = "dnssd-proxy.c";
                v91 = 1024;
                v92 = 3166;
                v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_109;
              }
              v58 = 0;
            }
            else
            {
              v58 = 0;
              ++question_created;
              *(_DWORD *)(v54 + 60) = 1;
            }
            v44 = (uint64_t *)v48;
            goto LABEL_57;
          }
        }
        else
        {
          LODWORD(v51) = 0;
        }
        v52 = 4096;
        goto LABEL_50;
      }
      v82 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__tp = 136446723;
        *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
        *(_WORD *)&__tp[12] = 2160;
        *(_QWORD *)&__tp[14] = 1752392040;
        *(_WORD *)&__tp[22] = 2081;
        *(_QWORD *)&__tp[24] = buf;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate memory for question name on %{private, mask.hash}s", __tp, 0x20u);
      }
      v83 = *(_DWORD *)(v48 + 60);
      if (!v83)
      {
        v40 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__tp = 136447490;
          *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
          *(_WORD *)&__tp[12] = 1024;
          *(_DWORD *)&__tp[14] = 0;
          *(_WORD *)&__tp[18] = 2048;
          *(_QWORD *)&__tp[20] = v48;
          *(_WORD *)&__tp[28] = 2080;
          *(_QWORD *)&__tp[30] = "new_question";
          *(_WORD *)&__tp[38] = 2080;
          *(_QWORD *)&__tp[40] = "dnssd-proxy.c";
          v91 = 1024;
          v92 = 3175;
          v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_109:
          v19 = __tp;
LABEL_110:
          v20 = v40;
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      v84 = global_os_log;
      if (v83 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__tp = 136447490;
          *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
          *(_WORD *)&__tp[12] = 1024;
          *(_DWORD *)&__tp[14] = v83;
          *(_WORD *)&__tp[18] = 2048;
          *(_QWORD *)&__tp[20] = v48;
          *(_WORD *)&__tp[28] = 2080;
          *(_QWORD *)&__tp[30] = "new_question";
          *(_WORD *)&__tp[38] = 2080;
          *(_QWORD *)&__tp[40] = "dnssd-proxy.c";
          v91 = 1024;
          v92 = 3175;
          v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v19 = __tp;
          v20 = v84;
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__tp = 136447490;
        *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
        *(_WORD *)&__tp[12] = 1024;
        *(_DWORD *)&__tp[14] = v83;
        *(_WORD *)&__tp[18] = 2048;
        *(_QWORD *)&__tp[20] = v48;
        *(_WORD *)&__tp[28] = 2080;
        *(_QWORD *)&__tp[30] = "new_question";
        *(_WORD *)&__tp[38] = 2080;
        *(_QWORD *)&__tp[40] = "dnssd-proxy.c";
        v91 = 1024;
        v92 = 3175;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", __tp, 0x36u);
        v83 = *(_DWORD *)(v48 + 60);
      }
      *(_DWORD *)(v48 + 60) = v83 - 1;
      if (v83 == 1)
      {
        v85 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__tp = 136447234;
          *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
          *(_WORD *)&__tp[12] = 2048;
          *(_QWORD *)&__tp[14] = v48;
          *(_WORD *)&__tp[22] = 2080;
          *(_QWORD *)&__tp[24] = "new_question";
          *(_WORD *)&__tp[32] = 2080;
          *(_QWORD *)&__tp[34] = "dnssd-proxy.c";
          *(_WORD *)&__tp[42] = 1024;
          *(_DWORD *)&__tp[44] = 3175;
          _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", __tp, 0x30u);
        }
        ++question_finalized;
        question_finalize(v48);
      }
    }
    else
    {
      v81 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__tp = 136446723;
        *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
        *(_WORD *)&__tp[12] = 2160;
        *(_QWORD *)&__tp[14] = 1752392040;
        *(_WORD *)&__tp[22] = 2081;
        *(_QWORD *)&__tp[24] = buf;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%{public}s: Unable to allocate memory for question entry on %{private, mask.hash}s", __tp, 0x20u);
      }
    }
    *((_QWORD *)v12 + 24) = 0;
    *a5 = 2;
LABEL_96:
    v86 = *v12;
    if (*v12)
    {
      v17 = global_os_log;
      if (v86 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v94 = "dp_query_create";
          v95 = 1024;
          *(_DWORD *)v96 = v86;
          *(_WORD *)&v96[4] = 2048;
          *(_QWORD *)&v96[6] = v12;
          *(_WORD *)&v96[14] = 2080;
          *(_QWORD *)&v96[16] = "query";
          *(_WORD *)&v96[24] = 2080;
          *(_QWORD *)&v96[26] = "dnssd-proxy.c";
          *(_WORD *)&v96[34] = 1024;
          *(_DWORD *)v97 = 3389;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v86 = *v12;
        }
        *v12 = v86 - 1;
        if (v86 == 1)
        {
          v87 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v94 = "dp_query_create";
            v95 = 2048;
            *(_QWORD *)v96 = v12;
            *(_WORD *)&v96[8] = 2080;
            *(_QWORD *)&v96[10] = "query";
            *(_WORD *)&v96[18] = 2080;
            *(_QWORD *)&v96[20] = "dnssd-proxy.c";
            *(_WORD *)&v96[28] = 1024;
            *(_DWORD *)&v96[30] = 3389;
            _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++dnssd_query_finalized;
          dnssd_query_finalize(v12);
        }
        return 0;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v94 = "dp_query_create";
        v95 = 1024;
        *(_DWORD *)v96 = v86;
        *(_WORD *)&v96[4] = 2048;
        *(_QWORD *)&v96[6] = v12;
        *(_WORD *)&v96[14] = 2080;
        *(_QWORD *)&v96[16] = "query";
        *(_WORD *)&v96[24] = 2080;
        *(_QWORD *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)v97 = 3389;
        v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_11;
      }
    }
    else
    {
      v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v94 = "dp_query_create";
        v95 = 1024;
        *(_DWORD *)v96 = 0;
        *(_WORD *)&v96[4] = 2048;
        *(_QWORD *)&v96[6] = v12;
        *(_WORD *)&v96[14] = 2080;
        *(_QWORD *)&v96[16] = "query";
        *(_WORD *)&v96[24] = 2080;
        *(_QWORD *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)v97 = 3389;
        v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_11:
        v19 = buf;
        v20 = v17;
LABEL_111:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, v18, v19, 0x36u);
      }
    }
LABEL_112:
    abort();
  }
  v46 = *(unsigned __int16 *)(a2 + 8);
  while (1)
  {
    v44 = (uint64_t *)v45;
    if (v46 == *(unsigned __int16 *)(v45 + 72)
      && *(unsigned __int16 *)(a2 + 10) == *(unsigned __int16 *)(v45 + 74)
      && !strcmp((const char *)buf, *(const char **)(v45 + 32)))
    {
      break;
    }
    v45 = *v44;
    if (!*v44)
      goto LABEL_43;
  }
  v58 = 1;
LABEL_57:
  v59 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v60 = *((_DWORD *)v44 + 15);
    *(_DWORD *)__tp = 136447490;
    *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
    *(_WORD *)&__tp[12] = 1024;
    *(_DWORD *)&__tp[14] = v60;
    *(_WORD *)&__tp[18] = 2048;
    *(_QWORD *)&__tp[20] = v44;
    *(_WORD *)&__tp[28] = 2080;
    *(_QWORD *)&__tp[30] = "ret";
    *(_WORD *)&__tp[38] = 2080;
    *(_QWORD *)&__tp[40] = "dnssd-proxy.c";
    v91 = 1024;
    v92 = 3178;
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", __tp, 0x36u);
  }
  v61 = *((_DWORD *)v44 + 15);
  if (v61)
  {
    v62 = v61 + 1;
    *((_DWORD *)v44 + 15) = v61 + 1;
    if (v61 + 1 >= 10001)
    {
      v40 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_112;
      *(_DWORD *)__tp = 136447490;
      *(_QWORD *)&__tp[4] = "dp_query_question_cache_copy";
      *(_WORD *)&__tp[12] = 1024;
      *(_DWORD *)&__tp[14] = v62;
      *(_WORD *)&__tp[18] = 2048;
      *(_QWORD *)&__tp[20] = v44;
      *(_WORD *)&__tp[28] = 2080;
      *(_QWORD *)&__tp[30] = "ret";
      *(_WORD *)&__tp[38] = 2080;
      *(_QWORD *)&__tp[40] = "dnssd-proxy.c";
      v91 = 1024;
      v92 = 3178;
      v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_109;
    }
  }
  else
  {
    ++question_created;
    *((_DWORD *)v44 + 15) = 1;
  }
  *((_QWORD *)v12 + 24) = v44;
  v63 = (int **)(v44 + 2);
  do
  {
    v64 = v63;
    v65 = *v63;
    v63 = (int **)(*v63 + 46);
  }
  while (v65);
  *v64 = v12;
  v66 = global_os_log;
  v67 = v12;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v68 = *v12;
    *(_DWORD *)buf = 136447490;
    v94 = "dp_query_create";
    v95 = 1024;
    *(_DWORD *)v96 = v68;
    *(_WORD *)&v96[4] = 2048;
    *(_QWORD *)&v96[6] = v12;
    *(_WORD *)&v96[14] = 2080;
    *(_QWORD *)&v96[16] = "*qr";
    *(_WORD *)&v96[24] = 2080;
    *(_QWORD *)&v96[26] = "dnssd-proxy.c";
    *(_WORD *)&v96[34] = 1024;
    *(_DWORD *)v97 = 3381;
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v67 = *v64;
  }
  v69 = *v67;
  if (!*v67)
  {
    ++dnssd_query_created;
    v69 = *v67;
  }
  v70 = v69 + 1;
  *v67 = v69 + 1;
  v71 = global_os_log;
  if (v69 + 1 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_112;
    *(_DWORD *)buf = 136447490;
    v94 = "dp_query_create";
    v95 = 1024;
    *(_DWORD *)v96 = v70;
    *(_WORD *)&v96[4] = 2048;
    *(_QWORD *)&v96[6] = v67;
    *(_WORD *)&v96[14] = 2080;
    *(_QWORD *)&v96[16] = "*qr";
    *(_WORD *)&v96[24] = 2080;
    *(_QWORD *)&v96[26] = "dnssd-proxy.c";
    *(_WORD *)&v96[34] = 1024;
    *(_DWORD *)v97 = 3381;
    v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
    v19 = buf;
    v20 = v71;
    goto LABEL_111;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v72 = v12[1];
    v73 = "new";
    v74 = *((_QWORD *)v12 + 8);
    v75 = *(unsigned __int16 *)(a2 + 8);
    if (v58)
      v73 = " existing";
    v76 = *(unsigned __int16 *)(a2 + 10);
    *(_DWORD *)buf = 136448259;
    v94 = "dp_query_create";
    v95 = 1024;
    *(_DWORD *)v96 = v72;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v88;
    *(_WORD *)&v96[10] = 2048;
    *(_QWORD *)&v96[12] = v74;
    *(_WORD *)&v96[20] = 2082;
    *(_QWORD *)&v96[22] = v73;
    *(_WORD *)&v96[30] = 1024;
    *(_DWORD *)&v96[32] = v75;
    *(_WORD *)v97 = 1024;
    *(_DWORD *)&v97[2] = v76;
    v98 = 2160;
    v99 = 1752392040;
    v100 = 2081;
    v101 = v89;
    _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QID%x] msg %p %{public}s cache entry for question: type %d class %d %{private, mask.hash}s", buf, 0x4Cu);
  }
  *a5 = 0;
  ++dp_num_outstanding_queries;
  return v12;
}

void dns_push_cancel(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  v2 = *(_QWORD *)(a1 + 24);
  v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (v2)
      v4 = *(_DWORD *)(v2 + 4);
    else
      v4 = 0;
    v5 = *(_QWORD *)(v2 + 192);
    if (v5)
      LODWORD(v5) = *(_DWORD *)(v5 + 64);
    v6 = *(_QWORD *)(a1 + 32);
    v11 = 136446978;
    v12 = "dns_push_cancel";
    v13 = 1024;
    *(_DWORD *)v14 = v4;
    *(_WORD *)&v14[4] = 1024;
    *(_DWORD *)&v14[6] = v5;
    *(_WORD *)&v14[10] = 2082;
    *(_QWORD *)&v14[12] = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{public}s", (uint8_t *)&v11, 0x22u);
  }
  if (*(_QWORD *)(v2 + 80))
  {
    *(_QWORD *)(v2 + 80) = 0;
    *(_BYTE *)(v2 + 200) = 1;
    dp_question_cache_remove_queries(*(_QWORD *)(v2 + 192));
    dnssd_query_cancel(v2);
  }
  v7 = *(_DWORD *)v2;
  if (!*(_DWORD *)v2)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_24;
    v11 = 136447490;
    v12 = "dns_push_cancel";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = v2;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "query";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = "dnssd-proxy.c";
    v15 = 1024;
    v16 = 1080;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_23;
  }
  v8 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_24;
    v11 = 136447490;
    v12 = "dns_push_cancel";
    v13 = 1024;
    *(_DWORD *)v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = v2;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "query";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = "dnssd-proxy.c";
    v15 = 1024;
    v16 = 1080;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_24:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "dns_push_cancel";
    v13 = 1024;
    *(_DWORD *)v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = v2;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "query";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = "dnssd-proxy.c";
    v15 = 1024;
    v16 = 1080;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v7 = *(_DWORD *)v2;
  }
  *(_DWORD *)v2 = v7 - 1;
  if (v7 == 1)
  {
    v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v11 = 136447234;
      v12 = "dns_push_cancel";
      v13 = 2048;
      *(_QWORD *)v14 = v2;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "query";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = "dnssd-proxy.c";
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = 1080;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize((_QWORD *)v2);
  }
}

uint64_t dp_query_start(uint64_t a1, _DWORD *a2, _BYTE *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  uint8_t *v9;
  uint64_t **v10;
  const char *v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  BOOL v15;
  int v16;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int32x4_t *v21;
  uint64_t v22;
  uint8_t *v23;
  unsigned int v24;
  size_t v25;
  uint64_t v27;
  uint64_t v28;
  BOOL v29;
  BOOL v30;
  const char *v31;
  NSObject *v32;
  int v33;
  int started;
  NSObject *v35;
  BOOL v36;
  NSObject *v37;
  int *v38;
  NSObject *v39;
  int v40;
  int v41;
  int v42;
  NSObject *v43;
  uint64_t v44;
  int v45;
  int v46;
  uint64_t v48;
  NSObject *v49;
  const char *v50;
  NSObject *v51;
  int v52;
  _WORD *v53;
  __int128 v54;
  uint8_t buf[4];
  const char *v56;
  __int16 v57;
  _BYTE v58[34];
  __int16 v59;
  __int128 *v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  int v64;
  __int16 v65;
  char *v66;
  __int16 v67;
  uint64_t v68;
  __int16 v69;
  int v70;
  __int16 v71;
  char *v72;
  __int16 v73;
  const char *v74;

  v5 = *(_QWORD *)(a1 + 192);
  v6 = *(_QWORD *)(v5 + 8);
  if (!v6)
    goto LABEL_51;
  v8 = *(_QWORD *)(v5 + 8);
  v9 = *(uint8_t **)(v5 + 32);
  if (!strcasecmp((const char *)v9, &uuid_name))
  {
    v16 = *(unsigned __int16 *)(v5 + 72);
    if (v16 == 28 || v16 == 1)
    {
      v18 = *(_QWORD *)(a1 + 64);
      if (v18)
        v19 = v18 + 32;
      else
        v19 = *(_QWORD *)(*(_QWORD *)(a1 + 72) + 32) + 344;
      v20 = *(unsigned __int8 *)(v19 + 1);
      if (v16 == 1)
      {
        if (v20 == 30)
        {
          if (*(_QWORD *)(v19 + 8) | *(unsigned int *)(v19 + 16) ^ 0xFFFF0000)
            goto LABEL_49;
          dp_query_add_data_to_response(a1, v9, 1u, 1, 4uLL, (int32x4_t *)(v19 + 20), 3600, 1, 1, (_WORD *)(*(_QWORD *)(a1 + 160) + 6));
          goto LABEL_102;
        }
        if (v20 != 2)
          goto LABEL_49;
        v21 = (int32x4_t *)(v19 + 4);
        v53 = (_WORD *)(*(_QWORD *)(a1 + 160) + 6);
        v22 = a1;
        v23 = v9;
        v24 = 1;
        v25 = 4;
      }
      else
      {
        if (v16 != 28 || v20 != 30)
          goto LABEL_49;
        v28 = *(_QWORD *)(v19 + 8);
        v27 = v19 + 8;
        if (!(v28 | *(unsigned int *)(v27 + 8) ^ 0xFFFF0000))
          goto LABEL_49;
        v54 = *(_OWORD *)v27;
        v29 = DWORD2(v54) == -16777216 && *(_DWORD *)((char *)&v54 + 11) == -67043585;
        if (v29 || (DWORD2(v54) == -16777216 ? (v30 = WORD6(v54) == 254) : (v30 = 0), v30))
        {
          v48 = *(_QWORD *)(srp_servers + 48);
          if (!v48 || !*(_BYTE *)(v48 + 258))
          {
LABEL_102:
            *a2 = 0;
            v44 = 1;
            *a3 = 1;
            v51 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v52 = *(_DWORD *)(a1 + 4);
              *(_DWORD *)buf = 136446466;
              v56 = "dp_query_start";
              v57 = 1024;
              *(_DWORD *)v58 = v52;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] hardwired response", buf, 0x12u);
            }
            return v44;
          }
          v54 = *(_OWORD *)(v48 + 176);
          v31 = "thread device ML-EID";
        }
        else
        {
          v31 = "local host IPv6 address";
        }
        v49 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          if ((v54 & 0xFE) == 0xFC)
          {
            v50 = "ULA: ";
          }
          else if (v54 == 254 && (BYTE1(v54) & 0xC0) == 0x80)
          {
            v50 = "LUA: ";
          }
          else if ((v54 & 0xE0) == 0x20)
          {
            v50 = "GUA: ";
          }
          else
          {
            v50 = (const char *)&unk_10007C3B5;
          }
          *(_DWORD *)buf = 136449283;
          v56 = "dnssd_hardwired_response";
          v57 = 2082;
          *(_QWORD *)v58 = v9;
          *(_WORD *)&v58[8] = 2082;
          *(_QWORD *)&v58[10] = v50;
          *(_WORD *)&v58[18] = 2160;
          *(_QWORD *)&v58[20] = 1752392040;
          *(_WORD *)&v58[28] = 1041;
          *(_DWORD *)&v58[30] = 6;
          v59 = 2097;
          v60 = &v54;
          v61 = 2160;
          v62 = 1752392040;
          v63 = 1042;
          v64 = 2;
          v65 = 2098;
          v66 = (char *)&v54 + 6;
          v67 = 2160;
          v68 = 1752392040;
          v69 = 1041;
          v70 = 8;
          v71 = 2097;
          v72 = (char *)&v54 + 8;
          v73 = 2082;
          v74 = v31;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s IN AAAA {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} %{public}s", buf, 0x78u);
          v9 = *(uint8_t **)(v5 + 32);
          v24 = *(unsigned __int16 *)(v5 + 72);
        }
        else
        {
          v24 = 28;
        }
        v53 = (_WORD *)(*(_QWORD *)(a1 + 160) + 6);
        v21 = (int32x4_t *)&v54;
        v22 = a1;
        v23 = v9;
        v25 = 16;
      }
      dp_query_add_data_to_response(v22, v23, v24, 1, v25, v21, 300, 1, 1, v53);
      goto LABEL_102;
    }
  }
  v10 = *(uint64_t ***)(v6 + 32);
  if (!v10)
    goto LABEL_49;
  v11 = 0;
  do
  {
    v12 = *(_QWORD *)(a1 + 192);
    v13 = *(unsigned __int16 *)(v12 + 72);
    v14 = *((unsigned __int16 *)v10 + 4);
    v15 = v13 == 255 || v13 == v14;
    if (v15 && *(_WORD *)(v12 + 74) == 1 && !strcasecmp((const char *)v10[2], *(const char **)(v12 + 32)))
    {
      if (*(_QWORD *)(a1 + 72))
      {
        dp_query_add_data_to_response(a1, (uint8_t *)v10[3], v14, 1, *((unsigned __int16 *)v10 + 20), (int32x4_t *)v10[4], 3600, 1, 0, 0);
      }
      else
      {
        v11 = "hardwired";
        if ((*(_BYTE *)(a1 + 144) & 1) != 0)
          goto LABEL_17;
        dp_query_add_data_to_response(a1, (uint8_t *)v10[3], v14, 1, *((unsigned __int16 *)v10 + 20), (int32x4_t *)v10[4], 3600, 1, 0, (_WORD *)(*(_QWORD *)(a1 + 160) + 6));
      }
      v11 = "hardwired";
    }
LABEL_17:
    v10 = (uint64_t **)*v10;
  }
  while (v10);
  if (v11)
    goto LABEL_102;
  v8 = *(_QWORD *)(v5 + 8);
  if (!v8)
    goto LABEL_51;
LABEL_49:
  if (*(_QWORD *)(v8 + 40) && !**(_BYTE **)(v5 + 32))
  {
    v44 = 1;
    if (!*(_QWORD *)(a1 + 72))
      *a3 = 1;
  }
  else
  {
LABEL_51:
    if (*(_QWORD *)(v5 + 24))
    {
      if (*(_QWORD *)(v5 + 40) || *(_BYTE *)(v5 + 76))
      {
        v32 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v33 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)buf = 136446466;
          v56 = "dp_query_start";
          v57 = 1024;
          *(_DWORD *)v58 = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] answering immediately from cache", buf, 0x12u);
        }
        *a2 = 0;
        return 1;
      }
LABEL_61:
      if (v6)
        v36 = *(_QWORD *)(a1 + 72) == 0;
      else
        v36 = 0;
      if (v36)
      {
        v38 = *(int **)(a1 + 24);
        if (v38
          || (v38 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 3304), (*(_QWORD *)(a1 + 24) = v38) != 0))
        {
          ioloop_add_wake_event((uint64_t)v38, a1, (uint64_t)dp_query_wakeup, (uint64_t)dp_query_context_release, 0x320u);
          v39 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v40 = *(_DWORD *)a1;
            *(_DWORD *)buf = 136447490;
            v56 = "dp_query_start";
            v57 = 1024;
            *(_DWORD *)v58 = v40;
            *(_WORD *)&v58[4] = 2048;
            *(_QWORD *)&v58[6] = a1;
            *(_WORD *)&v58[14] = 2080;
            *(_QWORD *)&v58[16] = "query";
            *(_WORD *)&v58[24] = 2080;
            *(_QWORD *)&v58[26] = "dnssd-proxy.c";
            v59 = 1024;
            LODWORD(v60) = 3311;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          v41 = *(_DWORD *)a1;
          if (*(_DWORD *)a1)
          {
            v42 = v41 + 1;
            *(_DWORD *)a1 = v41 + 1;
            v37 = global_os_log;
            if (v41 + 1 >= 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136447490;
                v56 = "dp_query_start";
                v57 = 1024;
                *(_DWORD *)v58 = v42;
                *(_WORD *)&v58[4] = 2048;
                *(_QWORD *)&v58[6] = a1;
                *(_WORD *)&v58[14] = 2080;
                *(_QWORD *)&v58[16] = "query";
                *(_WORD *)&v58[24] = 2080;
                *(_QWORD *)&v58[26] = "dnssd-proxy.c";
                v59 = 1024;
                LODWORD(v60) = 3311;
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              }
              abort();
            }
          }
          else
          {
            ++dnssd_query_created;
            *(_DWORD *)a1 = 1;
            v37 = global_os_log;
          }
          goto LABEL_80;
        }
        v44 = 0;
        *a2 = 2;
      }
      else
      {
        v37 = global_os_log;
LABEL_80:
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          v46 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)buf = 136446466;
          v56 = "dp_query_start";
          v57 = 1024;
          *(_DWORD *)v58 = v46;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] waiting for wakeup or response", buf, 0x12u);
        }
        return 1;
      }
    }
    else
    {
      started = dp_start_question(v5);
      if (!started)
        goto LABEL_61;
      if (started == -65553)
      {
        *a2 = 2;
        v35 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          v56 = "dp_query_start";
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: question was refused", buf, 0xCu);
        }
        goto LABEL_61;
      }
      *a2 = 2;
      v43 = global_os_log;
      v44 = 0;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v45 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)buf = 136446466;
        v56 = "dp_query_start";
        v57 = 1024;
        *(_DWORD *)v58 = v45;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] couldn't start question", buf, 0x12u);
        return 0;
      }
    }
  }
  return v44;
}

void dp_question_cache_remove_queries(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  int v5;
  NSObject *v6;
  const char *v7;
  uint64_t *v8;
  uint64_t v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  NSObject *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t *v21;
  uint64_t *v22;
  int v23;
  uint64_t v24;
  NSObject *v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  _BYTE v29[34];
  __int16 v30;
  int v31;

  if (!a1)
    return;
  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)buf = 136447490;
    v27 = "dp_question_cache_remove_queries";
    v28 = 1024;
    *(_DWORD *)v29 = v3;
    *(_WORD *)&v29[4] = 2048;
    *(_QWORD *)&v29[6] = a1;
    *(_WORD *)&v29[14] = 2080;
    *(_QWORD *)&v29[16] = "question";
    *(_WORD *)&v29[24] = 2080;
    *(_QWORD *)&v29[26] = "dnssd-proxy.c";
    v30 = 1024;
    v31 = 809;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v4 = *(_DWORD *)(a1 + 60);
  if (v4)
  {
    v5 = v4 + 1;
    *(_DWORD *)(a1 + 60) = v4 + 1;
    if (v4 + 1 >= 10001)
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_60;
      *(_DWORD *)buf = 136447490;
      v27 = "dp_question_cache_remove_queries";
      v28 = 1024;
      *(_DWORD *)v29 = v5;
      *(_WORD *)&v29[4] = 2048;
      *(_QWORD *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(_QWORD *)&v29[16] = "question";
      *(_WORD *)&v29[24] = 2080;
      *(_QWORD *)&v29[26] = "dnssd-proxy.c";
      v30 = 1024;
      v31 = 809;
      v7 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_69;
    }
  }
  else
  {
    ++question_created;
    *(_DWORD *)(a1 + 60) = 1;
  }
  v8 = (uint64_t *)(a1 + 16);
  v9 = *(_QWORD *)(a1 + 16);
  if (!v9)
    goto LABEL_22;
  do
  {
    if (*(_BYTE *)(v9 + 200))
    {
      *v8 = *(_QWORD *)(v9 + 184);
      v10 = *(_DWORD *)v9;
      if (!*(_DWORD *)v9)
      {
        v24 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_60;
        *(_DWORD *)buf = 136447490;
        v27 = "dp_question_cache_remove_queries";
        v28 = 1024;
        *(_DWORD *)v29 = 0;
        *(_WORD *)&v29[4] = 2048;
        *(_QWORD *)&v29[6] = v9;
        *(_WORD *)&v29[14] = 2080;
        *(_QWORD *)&v29[16] = "cquery";
        *(_WORD *)&v29[24] = 2080;
        *(_QWORD *)&v29[26] = "dnssd-proxy.c";
        v30 = 1024;
        v31 = 815;
        v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        v25 = v24;
        goto LABEL_59;
      }
      v11 = global_os_log;
      if (v10 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_60;
        *(_DWORD *)buf = 136447490;
        v27 = "dp_question_cache_remove_queries";
        v28 = 1024;
        *(_DWORD *)v29 = v10;
        *(_WORD *)&v29[4] = 2048;
        *(_QWORD *)&v29[6] = v9;
        *(_WORD *)&v29[14] = 2080;
        *(_QWORD *)&v29[16] = "cquery";
        *(_WORD *)&v29[24] = 2080;
        *(_QWORD *)&v29[26] = "dnssd-proxy.c";
        v30 = 1024;
        v31 = 815;
        v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v25 = v11;
        goto LABEL_59;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v27 = "dp_question_cache_remove_queries";
        v28 = 1024;
        *(_DWORD *)v29 = v10;
        *(_WORD *)&v29[4] = 2048;
        *(_QWORD *)&v29[6] = v9;
        *(_WORD *)&v29[14] = 2080;
        *(_QWORD *)&v29[16] = "cquery";
        *(_WORD *)&v29[24] = 2080;
        *(_QWORD *)&v29[26] = "dnssd-proxy.c";
        v30 = 1024;
        v31 = 815;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v10 = *(_DWORD *)v9;
      }
      *(_DWORD *)v9 = v10 - 1;
      if (v10 == 1)
      {
        v12 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v27 = "dp_question_cache_remove_queries";
          v28 = 2048;
          *(_QWORD *)v29 = v9;
          *(_WORD *)&v29[8] = 2080;
          *(_QWORD *)&v29[10] = "cquery";
          *(_WORD *)&v29[18] = 2080;
          *(_QWORD *)&v29[20] = "dnssd-proxy.c";
          *(_WORD *)&v29[28] = 1024;
          *(_DWORD *)&v29[30] = 815;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++dnssd_query_finalized;
        dnssd_query_finalize((_QWORD *)v9);
      }
    }
    else
    {
      v8 = (uint64_t *)(v9 + 184);
    }
    v9 = *v8;
  }
  while (*v8);
  if (*(_QWORD *)(a1 + 16))
    goto LABEL_22;
  v15 = *(_QWORD *)(a1 + 24);
  if (v15)
  {
    v16 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(_DWORD *)(a1 + 64);
      v18 = *(_QWORD *)(v15 + 8);
      *(_DWORD *)buf = 136446978;
      v27 = "dp_question_cancel";
      v28 = 1024;
      *(_DWORD *)v29 = v17;
      *(_WORD *)&v29[4] = 2048;
      *(_QWORD *)&v29[6] = v15;
      *(_WORD *)&v29[14] = 2048;
      *(_QWORD *)&v29[16] = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] question->txn = %p sdref=%p", buf, 0x26u);
      v15 = *(_QWORD *)(a1 + 24);
    }
    ioloop_dnssd_txn_cancel(v15);
    ioloop_dnssd_txn_release_(*(int **)(a1 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 730);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v19 = *(_QWORD *)(a1 + 8);
  v20 = (uint64_t *)(v19 + 48);
  if (!v19)
    v20 = &questions_without_domain;
  while (1)
  {
    v21 = v20;
    v20 = (uint64_t *)*v20;
    if (!v20)
      break;
    if (v20 == (uint64_t *)a1)
    {
      *v21 = *(_QWORD *)a1;
      v19 = *(_QWORD *)(a1 + 8);
      break;
    }
  }
  if (v19 && !*(_QWORD *)(v19 + 48))
  {
    v22 = &served_domains;
    while (1)
    {
      v22 = (uint64_t *)*v22;
      if (!v22)
        break;
      if (v22 == (uint64_t *)v19)
        goto LABEL_47;
    }
    served_domain_free(v19);
  }
LABEL_47:
  v23 = *(_DWORD *)(a1 + 60);
  if (!v23)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      v27 = "dp_question_cancel";
      v28 = 1024;
      *(_DWORD *)v29 = 0;
      *(_WORD *)&v29[4] = 2048;
      *(_QWORD *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(_QWORD *)&v29[16] = "question";
      *(_WORD *)&v29[24] = 2080;
      *(_QWORD *)&v29[26] = "dnssd-proxy.c";
      v30 = 1024;
      v31 = 763;
      v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_69;
    }
    goto LABEL_60;
  }
  v6 = global_os_log;
  if (v23 >= 10001)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      v27 = "dp_question_cancel";
      v28 = 1024;
      *(_DWORD *)v29 = v23;
      *(_WORD *)&v29[4] = 2048;
      *(_QWORD *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(_QWORD *)&v29[16] = "question";
      *(_WORD *)&v29[24] = 2080;
      *(_QWORD *)&v29[26] = "dnssd-proxy.c";
      v30 = 1024;
      v31 = 763;
      v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_69;
    }
    goto LABEL_60;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v27 = "dp_question_cancel";
    v28 = 1024;
    *(_DWORD *)v29 = v23;
    *(_WORD *)&v29[4] = 2048;
    *(_QWORD *)&v29[6] = a1;
    *(_WORD *)&v29[14] = 2080;
    *(_QWORD *)&v29[16] = "question";
    *(_WORD *)&v29[24] = 2080;
    *(_QWORD *)&v29[26] = "dnssd-proxy.c";
    v30 = 1024;
    v31 = 763;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v23 = *(_DWORD *)(a1 + 60);
    v6 = global_os_log;
  }
  v13 = v23 - 1;
  *(_DWORD *)(a1 + 60) = v13;
  if (!v13)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v27 = "dp_question_cancel";
      v28 = 2048;
      *(_QWORD *)v29 = a1;
      *(_WORD *)&v29[8] = 2080;
      *(_QWORD *)&v29[10] = "question";
      *(_WORD *)&v29[18] = 2080;
      *(_QWORD *)&v29[20] = "dnssd-proxy.c";
      *(_WORD *)&v29[28] = 1024;
      *(_DWORD *)&v29[30] = 763;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++question_finalized;
    question_finalize(a1);
LABEL_22:
    v13 = *(_DWORD *)(a1 + 60);
    v6 = global_os_log;
    if (!v13)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v27 = "dp_question_cache_remove_queries";
        v28 = 1024;
        *(_DWORD *)v29 = 0;
        *(_WORD *)&v29[4] = 2048;
        *(_QWORD *)&v29[6] = a1;
        *(_WORD *)&v29[14] = 2080;
        *(_QWORD *)&v29[16] = "question";
        *(_WORD *)&v29[24] = 2080;
        *(_QWORD *)&v29[26] = "dnssd-proxy.c";
        v30 = 1024;
        v31 = 824;
        v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_69;
      }
LABEL_60:
      abort();
    }
  }
  if (v13 >= 10001)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      v27 = "dp_question_cache_remove_queries";
      v28 = 1024;
      *(_DWORD *)v29 = v13;
      *(_WORD *)&v29[4] = 2048;
      *(_QWORD *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(_QWORD *)&v29[16] = "question";
      *(_WORD *)&v29[24] = 2080;
      *(_QWORD *)&v29[26] = "dnssd-proxy.c";
      v30 = 1024;
      v31 = 824;
      v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_69:
      v25 = v6;
LABEL_59:
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, v7, buf, 0x36u);
      goto LABEL_60;
    }
    goto LABEL_60;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v27 = "dp_question_cache_remove_queries";
    v28 = 1024;
    *(_DWORD *)v29 = v13;
    *(_WORD *)&v29[4] = 2048;
    *(_QWORD *)&v29[6] = a1;
    *(_WORD *)&v29[14] = 2080;
    *(_QWORD *)&v29[16] = "question";
    *(_WORD *)&v29[24] = 2080;
    *(_QWORD *)&v29[26] = "dnssd-proxy.c";
    v30 = 1024;
    v31 = 824;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v13 = *(_DWORD *)(a1 + 60);
  }
  *(_DWORD *)(a1 + 60) = v13 - 1;
  if (v13 == 1)
  {
    v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v27 = "dp_question_cache_remove_queries";
      v28 = 2048;
      *(_QWORD *)v29 = a1;
      *(_WORD *)&v29[8] = 2080;
      *(_QWORD *)&v29[10] = "question";
      *(_WORD *)&v29[18] = 2080;
      *(_QWORD *)&v29[20] = "dnssd-proxy.c";
      *(_WORD *)&v29[28] = 1024;
      *(_DWORD *)&v29[30] = 824;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++question_finalized;
    question_finalize(a1);
  }
}

void dnssd_query_cancel(uint64_t a1)
{
  NSObject *v2;
  int v3;
  uint64_t v4;
  const char *v5;
  int v6;
  const char *v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  NSObject *v14;
  const char *v15;
  _QWORD *v16;
  NSObject *v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  NSObject *v25;
  NSObject *v26;
  _QWORD *v27;
  _QWORD *v28;
  char v29;
  uint64_t v30;
  _QWORD *v31;
  int v32;
  NSObject *v33;
  NSObject *v34;
  int v35;
  NSObject *v36;
  uint64_t v37;
  int v38;
  NSObject *v39;
  int v40;
  NSObject *v41;
  NSObject *v42;
  uint8_t buf[4];
  const char *v44;
  __int16 v45;
  _BYTE v46[40];
  __int16 v47;
  const char *v48;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a1)
      v3 = *(_DWORD *)(a1 + 4);
    else
      v3 = 0;
    v4 = *(_QWORD *)(a1 + 192);
    v5 = (const char *)&unk_10007C3B5;
    if (v4)
    {
      v6 = *(_DWORD *)(v4 + 64);
      v7 = *(const char **)(v4 + 32);
      v8 = *(_QWORD *)(v4 + 8);
      if (v8)
      {
        if (*(_QWORD *)(v8 + 40))
          v9 = ".local.";
        else
          v9 = *(const char **)(v8 + 16);
      }
      else
      {
        v9 = (const char *)&unk_10007C3B5;
      }
    }
    else
    {
      v6 = 0;
      v7 = "<null>";
      v9 = (const char *)&unk_10007C3B5;
    }
    if (*(_BYTE *)(a1 + 201))
      v5 = " canceled";
    *(_DWORD *)buf = 136447747;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v3;
    *(_WORD *)&v46[4] = 1024;
    *(_DWORD *)&v46[6] = v6;
    *(_WORD *)&v46[10] = 2160;
    *(_QWORD *)&v46[12] = 1752392040;
    *(_WORD *)&v46[20] = 2081;
    *(_QWORD *)&v46[22] = v7;
    *(_WORD *)&v46[30] = 2082;
    *(_QWORD *)&v46[32] = v9;
    v47 = 2082;
    v48 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{private, mask.hash}s%{public}s%{public}s", buf, 0x40u);
  }
  if (*(_BYTE *)(a1 + 201))
    return;
  v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = *(_DWORD *)a1;
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v11;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 918;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v12 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    v13 = v12 + 1;
    *(_DWORD *)a1 = v12 + 1;
    if (v12 + 1 >= 10001)
    {
      v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_118;
      *(_DWORD *)buf = 136447490;
      v44 = "dnssd_query_cancel";
      v45 = 1024;
      *(_DWORD *)v46 = v13;
      *(_WORD *)&v46[4] = 2048;
      *(_QWORD *)&v46[6] = a1;
      *(_WORD *)&v46[14] = 2080;
      *(_QWORD *)&v46[16] = "query";
      *(_WORD *)&v46[24] = 2080;
      *(_QWORD *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&v46[34] = 1024;
      *(_DWORD *)&v46[36] = 918;
      v15 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_97:
      v42 = v14;
      goto LABEL_117;
    }
  }
  else
  {
    ++dnssd_query_created;
    *(_DWORD *)a1 = 1;
  }
  *(_BYTE *)(a1 + 201) = 1;
  v16 = *(_QWORD **)(a1 + 8);
  if (!v16)
  {
    v22 = *(_QWORD **)(a1 + 24);
    if (v22)
    {
      ioloop_wakeup_release_(v22, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 995);
      *(_QWORD *)(a1 + 24) = 0;
    }
    goto LABEL_84;
  }
  v17 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v18 = *(_DWORD *)v16;
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v18;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 924;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v19 = *(_DWORD *)v16;
  if (*(_DWORD *)v16)
  {
    v20 = v19 + 1;
    *(_DWORD *)v16 = v19 + 1;
    if (v19 + 1 >= 10001)
    {
      v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v44 = "dnssd_query_cancel";
        v45 = 1024;
        *(_DWORD *)v46 = v20;
        *(_WORD *)&v46[4] = 2048;
        *(_QWORD *)&v46[6] = v16;
        *(_WORD *)&v46[14] = 2080;
        *(_QWORD *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(_QWORD *)&v46[26] = "dnssd-proxy.c";
        *(_WORD *)&v46[34] = 1024;
        *(_DWORD *)&v46[36] = 924;
        v15 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_113;
      }
      goto LABEL_118;
    }
  }
  else
  {
    ++dp_tracker_created;
    v20 = 1;
    *(_DWORD *)v16 = 1;
  }
  v23 = *(_QWORD *)(a1 + 72);
  if (v23)
  {
    v24 = *(_QWORD **)(a1 + 80);
    if (v24)
    {
      dso_drop_activity(v23, v24);
      *(_QWORD *)(a1 + 80) = 0;
      v20 = *(_DWORD *)v16;
    }
    *(_QWORD *)(a1 + 8) = 0;
    if (!v20)
    {
      v21 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_118;
      *(_DWORD *)buf = 136447490;
      v44 = "dnssd_query_cancel";
      v45 = 1024;
      *(_DWORD *)v46 = 0;
      *(_WORD *)&v46[4] = 2048;
      *(_QWORD *)&v46[6] = v16;
      *(_WORD *)&v46[14] = 2080;
      *(_QWORD *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(_QWORD *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&v46[34] = 1024;
      *(_DWORD *)&v46[36] = 974;
      v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_113;
    }
    v25 = global_os_log;
    if (v20 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_118;
      *(_DWORD *)buf = 136447490;
      v44 = "dnssd_query_cancel";
      v45 = 1024;
      *(_DWORD *)v46 = v20;
      *(_WORD *)&v46[4] = 2048;
      *(_QWORD *)&v46[6] = v16;
      *(_WORD *)&v46[14] = 2080;
      *(_QWORD *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(_QWORD *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&v46[34] = 1024;
      *(_DWORD *)&v46[36] = 974;
      v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_116;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v44 = "dnssd_query_cancel";
      v45 = 1024;
      *(_DWORD *)v46 = v20;
      *(_WORD *)&v46[4] = 2048;
      *(_QWORD *)&v46[6] = v16;
      *(_WORD *)&v46[14] = 2080;
      *(_QWORD *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(_QWORD *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&v46[34] = 1024;
      *(_DWORD *)&v46[36] = 974;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v20 = *(_DWORD *)v16;
    }
    *(_DWORD *)v16 = v20 - 1;
    if (v20 == 1)
    {
      v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v44 = "dnssd_query_cancel";
        v45 = 2048;
        *(_QWORD *)v46 = v16;
        *(_WORD *)&v46[8] = 2080;
        *(_QWORD *)&v46[10] = "tracker";
        *(_WORD *)&v46[18] = 2080;
        *(_QWORD *)&v46[20] = "dnssd-proxy.c";
        *(_WORD *)&v46[28] = 1024;
        *(_DWORD *)&v46[30] = 974;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++dp_tracker_finalized;
      dp_tracker_finalize(v16);
    }
  }
  else
  {
    v27 = v16 + 2;
    v28 = (_QWORD *)v16[2];
    if (v28)
    {
      v29 = 0;
      v30 = v16[2];
      do
      {
        if (*(_QWORD *)(a1 + 64) == *(_QWORD *)(v30 + 64))
          v29 |= *(_BYTE *)(a1 + 200) == 0;
        v30 = *(_QWORD *)(v30 + 16);
      }
      while (v30);
      if ((v29 & 1) == 0)
      {
        do
        {
          if (*(_QWORD *)(a1 + 64) == v28[8])
          {
            *v27 = v28[2];
            v31 = (_QWORD *)v28[3];
            if (v31)
            {
              ioloop_wakeup_release_(v31, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 949);
              v28[3] = 0;
            }
            v32 = *(_DWORD *)v16;
            if (!*(_DWORD *)v16)
            {
              v21 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136447490;
                v44 = "dnssd_query_cancel";
                v45 = 1024;
                *(_DWORD *)v46 = 0;
                *(_WORD *)&v46[4] = 2048;
                *(_QWORD *)&v46[6] = v16;
                *(_WORD *)&v46[14] = 2080;
                *(_QWORD *)&v46[16] = "tracker";
                *(_WORD *)&v46[24] = 2080;
                *(_QWORD *)&v46[26] = "dnssd-proxy.c";
                *(_WORD *)&v46[34] = 1024;
                *(_DWORD *)&v46[36] = 954;
                v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                goto LABEL_113;
              }
LABEL_118:
              abort();
            }
            v33 = global_os_log;
            if (v32 >= 10001)
            {
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_118;
              *(_DWORD *)buf = 136447490;
              v44 = "dnssd_query_cancel";
              v45 = 1024;
              *(_DWORD *)v46 = v32;
              *(_WORD *)&v46[4] = 2048;
              *(_QWORD *)&v46[6] = v16;
              *(_WORD *)&v46[14] = 2080;
              *(_QWORD *)&v46[16] = "tracker";
              *(_WORD *)&v46[24] = 2080;
              *(_QWORD *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&v46[34] = 1024;
              *(_DWORD *)&v46[36] = 954;
              v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_106;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              v44 = "dnssd_query_cancel";
              v45 = 1024;
              *(_DWORD *)v46 = v32;
              *(_WORD *)&v46[4] = 2048;
              *(_QWORD *)&v46[6] = v16;
              *(_WORD *)&v46[14] = 2080;
              *(_QWORD *)&v46[16] = "tracker";
              *(_WORD *)&v46[24] = 2080;
              *(_QWORD *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&v46[34] = 1024;
              *(_DWORD *)&v46[36] = 954;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              v32 = *(_DWORD *)v16;
            }
            *(_DWORD *)v16 = v32 - 1;
            if (v32 == 1)
            {
              v34 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                v44 = "dnssd_query_cancel";
                v45 = 2048;
                *(_QWORD *)v46 = v16;
                *(_WORD *)&v46[8] = 2080;
                *(_QWORD *)&v46[10] = "tracker";
                *(_WORD *)&v46[18] = 2080;
                *(_QWORD *)&v46[20] = "dnssd-proxy.c";
                *(_WORD *)&v46[28] = 1024;
                *(_DWORD *)&v46[30] = 954;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              }
              ++dp_tracker_finalized;
              dp_tracker_finalize(v16);
            }
            v28[1] = 0;
            v35 = *(_DWORD *)v28;
            if (!*(_DWORD *)v28)
            {
              v21 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_118;
              *(_DWORD *)buf = 136447490;
              v44 = "dnssd_query_cancel";
              v45 = 1024;
              *(_DWORD *)v46 = 0;
              *(_WORD *)&v46[4] = 2048;
              *(_QWORD *)&v46[6] = v28;
              *(_WORD *)&v46[14] = 2080;
              *(_QWORD *)&v46[16] = "list_query";
              *(_WORD *)&v46[24] = 2080;
              *(_QWORD *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&v46[34] = 1024;
              *(_DWORD *)&v46[36] = 958;
              v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_113;
            }
            v33 = global_os_log;
            if (v35 >= 10001)
            {
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_118;
              *(_DWORD *)buf = 136447490;
              v44 = "dnssd_query_cancel";
              v45 = 1024;
              *(_DWORD *)v46 = v35;
              *(_WORD *)&v46[4] = 2048;
              *(_QWORD *)&v46[6] = v28;
              *(_WORD *)&v46[14] = 2080;
              *(_QWORD *)&v46[16] = "list_query";
              *(_WORD *)&v46[24] = 2080;
              *(_QWORD *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&v46[34] = 1024;
              *(_DWORD *)&v46[36] = 958;
              v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_106:
              v42 = v33;
LABEL_117:
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_FAULT, v15, buf, 0x36u);
              goto LABEL_118;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              v44 = "dnssd_query_cancel";
              v45 = 1024;
              *(_DWORD *)v46 = v35;
              *(_WORD *)&v46[4] = 2048;
              *(_QWORD *)&v46[6] = v28;
              *(_WORD *)&v46[14] = 2080;
              *(_QWORD *)&v46[16] = "list_query";
              *(_WORD *)&v46[24] = 2080;
              *(_QWORD *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&v46[34] = 1024;
              *(_DWORD *)&v46[36] = 958;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              v35 = *(_DWORD *)v28;
            }
            *(_DWORD *)v28 = v35 - 1;
            if (v35 == 1)
            {
              v36 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                v44 = "dnssd_query_cancel";
                v45 = 2048;
                *(_QWORD *)v46 = v28;
                *(_WORD *)&v46[8] = 2080;
                *(_QWORD *)&v46[10] = "list_query";
                *(_WORD *)&v46[18] = 2080;
                *(_QWORD *)&v46[20] = "dnssd-proxy.c";
                *(_WORD *)&v46[28] = 1024;
                *(_DWORD *)&v46[30] = 958;
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              }
              ++dnssd_query_finalized;
              dnssd_query_finalize(v28);
            }
          }
          else
          {
            v27 = v28 + 2;
          }
          v28 = (_QWORD *)*v27;
        }
        while (*v27);
      }
    }
  }
  v37 = v16[1];
  if (v37 && !v16[2])
  {
    if ((*(_WORD *)(v37 + 416) & 0x20) != 0)
    {
      dp_tracker_idle_after((uint64_t)v16, 15, a1);
    }
    else
    {
      ioloop_comm_release_(v37, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 985);
      v16[1] = 0;
    }
  }
  v38 = *(_DWORD *)v16;
  if (!*(_DWORD *)v16)
  {
    v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_118;
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 992;
    v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_113:
    v42 = v21;
    goto LABEL_117;
  }
  v25 = global_os_log;
  if (v38 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_118;
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v38;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 992;
    v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_116:
    v42 = v25;
    goto LABEL_117;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v38;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 992;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v38 = *(_DWORD *)v16;
  }
  *(_DWORD *)v16 = v38 - 1;
  if (v38 == 1)
  {
    v39 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v44 = "dnssd_query_cancel";
      v45 = 2048;
      *(_QWORD *)v46 = v16;
      *(_WORD *)&v46[8] = 2080;
      *(_QWORD *)&v46[10] = "tracker";
      *(_WORD *)&v46[18] = 2080;
      *(_QWORD *)&v46[20] = "dnssd-proxy.c";
      *(_WORD *)&v46[28] = 1024;
      *(_DWORD *)&v46[30] = 992;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++dp_tracker_finalized;
    dp_tracker_finalize(v16);
  }
LABEL_84:
  *(_BYTE *)(a1 + 200) = 1;
  v40 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_118;
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 1000;
    v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_97;
  }
  v14 = global_os_log;
  if (v40 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_118;
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v40;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 1000;
    v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_97;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v44 = "dnssd_query_cancel";
    v45 = 1024;
    *(_DWORD *)v46 = v40;
    *(_WORD *)&v46[4] = 2048;
    *(_QWORD *)&v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(_QWORD *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(_QWORD *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&v46[34] = 1024;
    *(_DWORD *)&v46[36] = 1000;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v40 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v40 - 1;
  if (v40 == 1)
  {
    v41 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v44 = "dnssd_query_cancel";
      v45 = 2048;
      *(_QWORD *)v46 = a1;
      *(_WORD *)&v46[8] = 2080;
      *(_QWORD *)&v46[10] = "query";
      *(_WORD *)&v46[18] = 2080;
      *(_QWORD *)&v46[20] = "dnssd-proxy.c";
      *(_WORD *)&v46[28] = 1024;
      *(_DWORD *)&v46[30] = 1000;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize((_QWORD *)a1);
  }
}

void dp_push_response(uint64_t a1, uint64_t **a2)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  _BYTE *v6;
  uint64_t v7;
  size_t v8;
  NSObject *v9;
  _BOOL4 v10;
  _BYTE *v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  uint64_t v19;
  int v20;
  int v21;
  _BYTE *v22;
  uint64_t v23;
  uint64_t v24;
  iovec v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  const char *v35;
  __int16 v36;
  size_t v37;
  _BYTE v38[1010];

  v3 = *(_QWORD *)(a1 + 192);
  if (v3)
  {
    v4 = *(const char **)(v3 + 32);
  }
  else if (a2)
  {
    v4 = v38;
    dns_name_print_to_limit(*a2, 0, (uint64_t)v38, 0x3F2uLL);
  }
  else
  {
    v4 = "<null question name>";
  }
  v5 = *(_QWORD *)(a1 + 8);
  if (!v5)
  {
    v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v15 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)buf = 136446466;
    v27 = "dp_push_response";
    v28 = 1024;
    v29 = v15;
    v16 = "%{public}s: [Q%d] query->tracker NULL for query!";
    v17 = v14;
    v18 = 18;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
    return;
  }
  if (!*(_QWORD *)(v5 + 8))
  {
    v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v20 = *(_DWORD *)(a1 + 4);
    v21 = *(_DWORD *)(v5 + 4);
    *(_DWORD *)buf = 136446722;
    v27 = "dp_push_response";
    v28 = 1024;
    v29 = v20;
    v30 = 1024;
    v31 = v21;
    v16 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    v17 = v19;
    v18 = 24;
    goto LABEL_16;
  }
  v6 = *(_BYTE **)(a1 + 152);
  if (v6)
  {
    v7 = *(_QWORD *)(a1 + 104);
    v8 = v7 - *(_QWORD *)(a1 + 160);
    v25.iov_base = *(void **)(a1 + 160);
    v25.iov_len = v8;
    v9 = global_os_log;
    v10 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    v11 = v6;
    if (v10)
    {
      v12 = *(_DWORD *)(a1 + 4);
      if (v3)
        v13 = *(_DWORD *)(v3 + 64);
      else
        v13 = 0;
      *(_DWORD *)buf = 136447491;
      v27 = "dp_push_response";
      v28 = 1024;
      v29 = v12;
      v30 = 1024;
      v31 = v13;
      v32 = 2160;
      v33 = 1752392040;
      v34 = 2081;
      v35 = v4;
      v36 = 2048;
      v37 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{private, mask.hash}s (len %zd)", buf, 0x36u);
      v11 = *(_BYTE **)(a1 + 152);
    }
    *(_QWORD *)(a1 + 104) = v11;
    if (*(_DWORD *)(a1 + 144) <= 1u)
    {
      if ((unint64_t)(v11 + 2) >= *(_QWORD *)(a1 + 112))
      {
        *(_DWORD *)(a1 + 144) = 111;
        *(_DWORD *)(a1 + 136) = 2669;
      }
      else
      {
        *(_QWORD *)(a1 + 104) = v11 + 1;
        *v11 = (unsigned __int16)(v7 - (_WORD)v6 - 2) >> 8;
        v22 = *(_BYTE **)(a1 + 104);
        *(_QWORD *)(a1 + 104) = v22 + 1;
        *v22 = v7 - (_BYTE)v6 - 2;
      }
    }
    ioloop_send_message(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8), *(_QWORD *)(a1 + 64), &v25);
    v23 = *(_QWORD *)(a1 + 160);
    v24 = v23 + 12 + *(_QWORD *)(a1 + 176);
    *(_QWORD *)(a1 + 96) = v23;
    *(_QWORD *)(a1 + 104) = v23 + 12;
    *(_QWORD *)(a1 + 152) = 0;
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 112) = v24;
  }
}

void dp_query_reply_from_cache(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t *v6;
  NSObject *v7;
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  char v13;
  uint64_t *v14;
  char v15;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  _BYTE buf[18];
  __int16 v23;
  int v24;
  __int16 v25;
  int v26;
  __int16 v27;
  int v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;

  if (*(_QWORD *)(a2 + 72)
    || !*(_BYTE *)(a1 + 76)
    && (*(_QWORD *)(a1 + 40)
     || (*(_QWORD *)buf = 0,
         *(_QWORD *)&buf[8] = 0,
         clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf),
         *(_QWORD *)&buf[8] / 1000 + 1000000 * *(_QWORD *)buf - *(_QWORD *)(a1 + 48) < 800001)))
  {
    v6 = *(uint64_t **)(a1 + 40);
    if (!v6)
      return;
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_5;
    v8 = *(_DWORD *)(a2 + 4);
    v9 = *(_DWORD *)(a1 + 64);
    v10 = *(unsigned __int16 *)(a1 + 72);
    v11 = *(unsigned __int16 *)(a1 + 74);
    v12 = *(_QWORD *)(a1 + 32);
    *(_DWORD *)buf = 136447747;
    *(_QWORD *)&buf[4] = "dp_query_reply_from_cache";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    v23 = 1024;
    v24 = v9;
    v25 = 1024;
    v26 = v10;
    v27 = 1024;
    v28 = v11;
    v29 = 2160;
    v30 = 1752392040;
    v31 = 2081;
    v32 = v12;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] reply from cache for question - type %d class %d %{private, mask.hash}s", buf, 0x38u);
    v6 = *(uint64_t **)(a1 + 40);
    if (v6)
    {
LABEL_5:
      if (a3)
        v13 = 0;
      else
        v13 = 2;
      do
      {
        v14 = (uint64_t *)*v6;
        v15 = v13 | (*v6 != 0);
        if (*(_QWORD *)(a2 + 72))
        {
          dns_push_query_answer_process(v15, 0, (uint8_t *)v6[1], *((unsigned __int16 *)v6 + 16), *((unsigned __int16 *)v6 + 17), *((unsigned __int16 *)v6 + 18), (int32x4_t *)v6[2], *((_DWORD *)v6 + 7), a2, 1);
        }
        else if ((a3 & 1) == 0)
        {
          dns_query_answer_process(v15, 0, (uint8_t *)v6[1], *((unsigned __int16 *)v6 + 16), *((unsigned __int16 *)v6 + 17), *((unsigned __int16 *)v6 + 18), (int32x4_t *)v6[2], *((_DWORD *)v6 + 7), a2, 1);
        }
        v6 = v14;
      }
      while (v14);
    }
  }
  else
  {
    v16 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v17 = *(_DWORD *)(a2 + 4);
      v18 = *(_DWORD *)(a1 + 64);
      v19 = *(unsigned __int16 *)(a1 + 72);
      v20 = *(unsigned __int16 *)(a1 + 74);
      v21 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)buf = 136447747;
      *(_QWORD *)&buf[4] = "dp_query_reply_from_cache";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v17;
      v23 = 1024;
      v24 = v18;
      v25 = 1024;
      v26 = v19;
      v27 = 1024;
      v28 = v20;
      v29 = 2160;
      v30 = 1752392040;
      v31 = 2081;
      v32 = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] no data for question - type %d class %d %{private, mask.hash}s", buf, 0x38u);
    }
    dns_query_answer_process(0, -65554, *(uint8_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 72), *(unsigned __int16 *)(a1 + 74), 0, 0, 0, a2, 1);
  }
  dp_question_cache_remove_queries(a1);
}

void dnssd_query_finalize(_QWORD *a1)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  int *v6;
  _QWORD *v7;
  void *v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  NSObject *v15;
  int v16;
  const char *v17;
  __int16 v18;
  _BYTE v19[34];
  __int16 v20;
  int v21;

  v2 = (_QWORD *)a1[1];
  if (v2)
  {
    v3 = *(_DWORD *)v2;
    if (!*(_DWORD *)v2)
    {
      v13 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_40;
      v16 = 136447490;
      v17 = "dnssd_query_finalize";
      v18 = 1024;
      *(_DWORD *)v19 = 0;
      *(_WORD *)&v19[4] = 2048;
      *(_QWORD *)&v19[6] = v2;
      *(_WORD *)&v19[14] = 2080;
      *(_QWORD *)&v19[16] = "query->tracker";
      *(_WORD *)&v19[24] = 2080;
      *(_QWORD *)&v19[26] = "dnssd-proxy.c";
      v20 = 1024;
      v21 = 772;
      v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_35;
    }
    v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_40;
      v16 = 136447490;
      v17 = "dnssd_query_finalize";
      v18 = 1024;
      *(_DWORD *)v19 = v3;
      *(_WORD *)&v19[4] = 2048;
      *(_QWORD *)&v19[6] = v2;
      *(_WORD *)&v19[14] = 2080;
      *(_QWORD *)&v19[16] = "query->tracker";
      *(_WORD *)&v19[24] = 2080;
      *(_QWORD *)&v19[26] = "dnssd-proxy.c";
      v20 = 1024;
      v21 = 772;
      v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_38:
      v15 = v4;
      goto LABEL_39;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v16 = 136447490;
      v17 = "dnssd_query_finalize";
      v18 = 1024;
      *(_DWORD *)v19 = v3;
      *(_WORD *)&v19[4] = 2048;
      *(_QWORD *)&v19[6] = v2;
      *(_WORD *)&v19[14] = 2080;
      *(_QWORD *)&v19[16] = "query->tracker";
      *(_WORD *)&v19[24] = 2080;
      *(_QWORD *)&v19[26] = "dnssd-proxy.c";
      v20 = 1024;
      v21 = 772;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v16, 0x36u);
      v2 = (_QWORD *)a1[1];
      v3 = *(_DWORD *)v2;
    }
    *(_DWORD *)v2 = v3 - 1;
    if (v3 == 1)
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v16 = 136447234;
        v17 = "dnssd_query_finalize";
        v18 = 2048;
        *(_QWORD *)v19 = v2;
        *(_WORD *)&v19[8] = 2080;
        *(_QWORD *)&v19[10] = "query->tracker";
        *(_WORD *)&v19[18] = 2080;
        *(_QWORD *)&v19[20] = "dnssd-proxy.c";
        *(_WORD *)&v19[28] = 1024;
        *(_DWORD *)&v19[30] = 772;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v16, 0x30u);
        v2 = (_QWORD *)a1[1];
      }
      ++dp_tracker_finalized;
      dp_tracker_finalize(v2);
    }
    a1[1] = 0;
  }
  v6 = (int *)a1[8];
  if (v6)
  {
    ioloop_message_release_(v6, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 776);
    a1[8] = 0;
  }
  v7 = (_QWORD *)a1[3];
  if (v7)
  {
    ioloop_wakeup_release_(v7, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 780);
    a1[3] = 0;
  }
  v8 = (void *)a1[20];
  if (v8)
  {
    free(v8);
    a1[20] = 0;
  }
  v9 = (_QWORD *)a1[21];
  if (v9)
  {
    dns_message_free(v9);
    a1[21] = 0;
  }
  v10 = a1[24];
  if (v10)
  {
    v11 = *(_DWORD *)(v10 + 60);
    if (v11)
    {
      v4 = global_os_log;
      if (v11 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v16 = 136447490;
          v17 = "dnssd_query_finalize";
          v18 = 1024;
          *(_DWORD *)v19 = v11;
          *(_WORD *)&v19[4] = 2048;
          *(_QWORD *)&v19[6] = v10;
          *(_WORD *)&v19[14] = 2080;
          *(_QWORD *)&v19[16] = "query->question";
          *(_WORD *)&v19[24] = 2080;
          *(_QWORD *)&v19[26] = "dnssd-proxy.c";
          v20 = 1024;
          v21 = 792;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v16, 0x36u);
          v10 = a1[24];
          v11 = *(_DWORD *)(v10 + 60);
        }
        *(_DWORD *)(v10 + 60) = v11 - 1;
        if (v11 == 1)
        {
          v12 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v16 = 136447234;
            v17 = "dnssd_query_finalize";
            v18 = 2048;
            *(_QWORD *)v19 = v10;
            *(_WORD *)&v19[8] = 2080;
            *(_QWORD *)&v19[10] = "query->question";
            *(_WORD *)&v19[18] = 2080;
            *(_QWORD *)&v19[20] = "dnssd-proxy.c";
            *(_WORD *)&v19[28] = 1024;
            *(_DWORD *)&v19[30] = 792;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v16, 0x30u);
            v10 = a1[24];
          }
          ++question_finalized;
          question_finalize(v10);
        }
        goto LABEL_28;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_40:
        abort();
      v16 = 136447490;
      v17 = "dnssd_query_finalize";
      v18 = 1024;
      *(_DWORD *)v19 = v11;
      *(_WORD *)&v19[4] = 2048;
      *(_QWORD *)&v19[6] = v10;
      *(_WORD *)&v19[14] = 2080;
      *(_QWORD *)&v19[16] = "query->question";
      *(_WORD *)&v19[24] = 2080;
      *(_QWORD *)&v19[26] = "dnssd-proxy.c";
      v20 = 1024;
      v21 = 792;
      v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    v13 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_40;
    v16 = 136447490;
    v17 = "dnssd_query_finalize";
    v18 = 1024;
    *(_DWORD *)v19 = 0;
    *(_WORD *)&v19[4] = 2048;
    *(_QWORD *)&v19[6] = v10;
    *(_WORD *)&v19[14] = 2080;
    *(_QWORD *)&v19[16] = "query->question";
    *(_WORD *)&v19[24] = 2080;
    *(_QWORD *)&v19[26] = "dnssd-proxy.c";
    v20 = 1024;
    v21 = 792;
    v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_35:
    v15 = v13;
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, v14, (uint8_t *)&v16, 0x36u);
    goto LABEL_40;
  }
LABEL_28:
  free(a1);
  --dp_num_outstanding_queries;
}

void dp_tracker_finalize(_QWORD *a1)
{
  _QWORD *v2;
  uint64_t v3;

  v2 = (_QWORD *)a1[4];
  if (v2)
    ioloop_wakeup_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 680);
  v3 = a1[1];
  if (v3)
    ioloop_comm_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 685);
  free(a1);
}

void question_finalize(uint64_t a1)
{
  NSObject *v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  const char *v8;
  __int16 v9;
  int v10;
  __int16 v11;
  int v12;
  __int16 v13;
  int v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a1)
      v3 = *(_DWORD *)(a1 + 64);
    else
      v3 = 0;
    v4 = *(unsigned __int16 *)(a1 + 72);
    v5 = *(unsigned __int16 *)(a1 + 74);
    v6 = *(_QWORD *)(a1 + 32);
    v7 = 136447491;
    v8 = "question_finalize";
    v9 = 1024;
    v10 = v3;
    v11 = 1024;
    v12 = v4;
    v13 = 1024;
    v14 = v5;
    v15 = 2160;
    v16 = 1752392040;
    v17 = 2081;
    v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] type %d class %d %{private, mask.hash}s", (uint8_t *)&v7, 0x32u);
  }
  dp_question_answers_free(a1);
  free(*(void **)(a1 + 32));
  free((void *)a1);
}

void dp_question_answers_free(uint64_t a1)
{
  void **v2;
  void **v3;

  v2 = *(void ***)(a1 + 40);
  if (v2)
  {
    do
    {
      v3 = (void **)*v2;
      free(v2[1]);
      free(v2);
      v2 = v3;
    }
    while (v3);
  }
  *(_QWORD *)(a1 + 40) = 0;
}

void dns_query_answer_process(char a1, int a2, uint8_t *a3, unsigned int a4, int a5, size_t a6, int32x4_t *a7, unsigned int a8, uint64_t a9, char a10)
{
  uint64_t v15;
  NSObject *v16;
  int v17;
  int v18;
  const char *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  const char *v25;
  NSObject *v26;
  os_log_type_t v27;
  uint32_t v28;
  uint64_t v29;
  int v30;
  int v31;
  const char *v32;
  uint64_t v33;
  int v34;
  int v35;
  uint64_t v36;
  uint8_t buf[4];
  const char *v41;
  __int16 v42;
  int v43;
  __int16 v44;
  int v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  uint8_t *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  const char *v53;
  __int16 v54;
  int v55;
  __int16 v56;
  int v57;
  __int16 v58;
  int v59;
  __int16 v60;
  uint64_t v61;

  v15 = *(_QWORD *)(a9 + 192);
  v16 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v17 = *(_DWORD *)(a9 + 4);
    v36 = v15;
    if (v15)
      v18 = *(_DWORD *)(v15 + 64);
    else
      v18 = 0;
    if ((a1 & 1) != 0)
      v19 = " m ";
    else
      v19 = " ";
    *(_DWORD *)buf = 136448771;
    v41 = "dns_query_answer_process";
    v42 = 1024;
    v43 = v17;
    v44 = 1024;
    v45 = v18;
    v46 = 2160;
    v47 = 1752392040;
    v48 = 2081;
    v49 = a3;
    v50 = 2082;
    v51 = v19;
    v52 = 2082;
    v53 = dns_rrtype_to_string(a4);
    v54 = 1024;
    v55 = a5;
    v56 = 1024;
    v57 = a6;
    v58 = 1024;
    v59 = a2;
    v60 = 2048;
    v61 = a9;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{private, mask.hash}s%{public}s%{public}s %d %x %d %p", buf, 0x5Cu);
    v15 = v36;
  }
  v20 = *(_QWORD *)(a9 + 8);
  if (!v20)
  {
    v23 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v24 = *(_DWORD *)(a9 + 4);
    *(_DWORD *)buf = 136446466;
    v41 = "dns_query_answer_process";
    v42 = 1024;
    v43 = v24;
    v25 = "%{public}s: [Q%d] query->tracker NULL for query!";
    v26 = v23;
    v27 = OS_LOG_TYPE_ERROR;
    v28 = 18;
    goto LABEL_26;
  }
  if (!*(_QWORD *)(v20 + 8))
  {
    v29 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v30 = *(_DWORD *)(a9 + 4);
    v31 = *(_DWORD *)(v20 + 4);
    *(_DWORD *)buf = 136446722;
    v41 = "dns_query_answer_process";
    v42 = 1024;
    v43 = v30;
    v44 = 1024;
    v45 = v31;
    v25 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    v26 = v29;
    v27 = OS_LOG_TYPE_ERROR;
    goto LABEL_25;
  }
  if (a2 == -65554)
  {
    v32 = "no such record";
LABEL_37:
    dp_query_send_dns_response(a9, (uint64_t)v32);
    return;
  }
  if (a2)
  {
    *(_WORD *)(*(_QWORD *)(a9 + 160) + 2) = *(_WORD *)(*(_QWORD *)(a9 + 160) + 2) & 0xF0FF | 0x200;
    v32 = "unhandled error";
    goto LABEL_37;
  }
  if (a10)
  {
    if (a8 >= 0x12C)
      v21 = 300;
    else
      v21 = a8;
    while (1)
    {
      v22 = *(_QWORD *)(a9 + 104);
      dp_query_add_data_to_response(a9, a3, a4, a5, a6, a7, v21, 0, 0, (_WORD *)(*(_QWORD *)(a9 + 160) + 6));
      if ((*(_BYTE *)(a9 + 144) & 1) == 0)
        break;
      *(_QWORD *)(a9 + 104) = v22;
      if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a9 + 8) + 8) + 416) & 0x20) == 0)
        break;
      if (!embiggen(a9))
      {
        *(_WORD *)(*(_QWORD *)(a9 + 160) + 2) = *(_WORD *)(*(_QWORD *)(a9 + 160) + 2) & 0xF0FF | 0x200;
        v32 = "failed embiggen";
        goto LABEL_37;
      }
      *(_DWORD *)(a9 + 144) = 0;
    }
  }
  if ((a1 & 1) != 0 && (*(_BYTE *)(a9 + 144) & 1) == 0)
    return;
  if (a4 != 5 || *(_WORD *)(v15 + 72) == 5)
  {
    v32 = "normal success";
    goto LABEL_37;
  }
  v33 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v34 = *(_DWORD *)(a9 + 4);
    v35 = *(_DWORD *)(v15 + 64);
    *(_DWORD *)buf = 136446722;
    v41 = "dns_query_answer_process";
    v42 = 1024;
    v43 = v34;
    v44 = 1024;
    v45 = v35;
    v25 = "%{public}s: [Q%d][QU%d] not responding yet because CNAME.";
    v26 = v33;
    v27 = OS_LOG_TYPE_DEFAULT;
LABEL_25:
    v28 = 24;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v26, v27, v25, buf, v28);
  }
}

void dns_push_query_answer_process(char a1, int a2, uint8_t *a3, unsigned int a4, int a5, size_t a6, int32x4_t *a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  NSObject *v11;
  int v19;
  int32x4_t *v20;
  int v21;
  NSObject *v22;
  _BOOL4 v23;
  int32x4_t *v24;
  int v25;
  int v26;
  const char *v27;
  const char *v28;
  int v29;
  const char *v30;
  const char *v31;
  uint64_t v32;
  int v33;
  const char *v34;
  NSObject *v35;
  uint32_t v36;
  int v37;
  int v38;
  NSObject *v39;
  int v40;
  int v41;
  int32x4_t *v42;
  uint64_t v43;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  int v48;
  __int16 v49;
  uint64_t v50;
  __int16 v51;
  uint8_t *v52;
  __int16 v53;
  _BYTE v54[10];
  const char *v55;
  _BYTE v56[6];
  uint64_t v57;

  v10 = *(_QWORD *)(a9 + 8);
  if (!v10)
  {
    v32 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v33 = *(_DWORD *)(a9 + 4);
    *(_DWORD *)buf = 136446466;
    v46 = "dns_push_query_answer_process";
    v47 = 1024;
    v48 = v33;
    v34 = "%{public}s: [Q%d] query->tracker NULL for query!";
    v35 = v32;
    v36 = 18;
LABEL_25:
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
    return;
  }
  v11 = global_os_log;
  if (!*(_QWORD *)(v10 + 8))
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v37 = *(_DWORD *)(a9 + 4);
    v38 = *(_DWORD *)(v10 + 4);
    *(_DWORD *)buf = 136446722;
    v46 = "dns_push_query_answer_process";
    v47 = 1024;
    v48 = v37;
    v49 = 1024;
    LODWORD(v50) = v38;
    v34 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    v35 = v11;
    v36 = 24;
    goto LABEL_25;
  }
  v43 = *(_QWORD *)(a9 + 104);
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v19 = *(_DWORD *)(a9 + 4);
    *(_DWORD *)buf = 136448259;
    v46 = "dns_push_query_answer_process";
    v47 = 1024;
    v48 = v19;
    v49 = 2160;
    v50 = 1752392040;
    v51 = 2081;
    v52 = a3;
    v53 = 1024;
    *(_DWORD *)v54 = a4;
    *(_WORD *)&v54[4] = 1024;
    *(_DWORD *)&v54[6] = a5;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = a6;
    HIWORD(v55) = 1024;
    *(_DWORD *)v56 = a2;
    *(_WORD *)&v56[4] = 2048;
    v57 = a9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] PUSH %{private, mask.hash}s %d %d %x %d %p", buf, 0x48u);
  }
  if (a2 != -65554)
  {
    if (a2)
    {
      v39 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v40 = *(_DWORD *)(a9 + 4);
        *(_DWORD *)buf = 136446722;
        v46 = "dns_push_query_answer_process";
        v47 = 1024;
        v48 = v40;
        v49 = 1024;
        LODWORD(v50) = a2;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] unexpected error code %d", buf, 0x18u);
      }
      dnssd_query_cancel(a9);
    }
    else
    {
      if (a10)
      {
        v20 = a7;
        if (!(_DWORD)a6)
          v20 = 0;
        v42 = v20;
        if ((_DWORD)a6)
          v21 = -1;
        else
          v21 = -2;
        v41 = a8;
        while (1)
        {
          v22 = global_os_log;
          v23 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if ((a1 & 2) != 0)
          {
            v24 = a7;
            v25 = a8;
            if (v23)
            {
              v29 = *(_DWORD *)(a9 + 4);
              v30 = dns_rrtype_to_string(a4);
              v31 = dns_qclass_to_string(a5);
              *(_DWORD *)buf = 136448003;
              v46 = "dns_push_query_answer_process";
              v47 = 1024;
              v48 = v29;
              a8 = v41;
              v49 = 2160;
              v50 = 1752392040;
              v51 = 2081;
              v52 = a3;
              v53 = 2082;
              *(_QWORD *)v54 = v30;
              *(_WORD *)&v54[8] = 2082;
              v55 = v31;
              *(_WORD *)v56 = 1024;
              *(_DWORD *)&v56[2] = a6;
              LOWORD(v57) = 1024;
              *(_DWORD *)((char *)&v57 + 2) = v41;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] DNS Push adding record - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u, ttl: %u.", buf, 0x46u);
              v24 = a7;
              v25 = v41;
            }
          }
          else
          {
            v24 = v42;
            v25 = v21;
            if (v23)
            {
              v26 = *(_DWORD *)(a9 + 4);
              v27 = dns_rrtype_to_string(a4);
              v28 = dns_qclass_to_string(a5);
              *(_DWORD *)buf = 136448003;
              v46 = "dns_push_query_answer_process";
              v47 = 1024;
              v48 = v26;
              a8 = v41;
              v49 = 2160;
              v50 = 1752392040;
              v51 = 2081;
              v52 = a3;
              v53 = 2082;
              *(_QWORD *)v54 = v27;
              *(_WORD *)&v54[8] = 2082;
              v55 = v28;
              *(_WORD *)v56 = 1024;
              *(_DWORD *)&v56[2] = a6;
              LOWORD(v57) = 1024;
              *(_DWORD *)((char *)&v57 + 2) = v21;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] DNS Push removing record - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u, ttl: 0x%X.", buf, 0x46u);
              v24 = v42;
              v25 = v21;
            }
          }
          dp_query_add_data_to_response(a9, a3, a4, a5, a6, v24, v25, 0, 0, 0);
          if ((*(_BYTE *)(a9 + 144) & 1) == 0)
            break;
          *(_QWORD *)(a9 + 104) = v43;
          *(_DWORD *)(a9 + 144) = 0;
          dp_push_response(a9, 0);
          dns_push_start(a9);
        }
      }
      if ((a1 & 1) == 0)
        dp_push_response(a9, 0);
    }
  }
}

void dp_query_add_data_to_response(uint64_t a1, uint8_t *a2, unsigned int a3, int a4, size_t a5, int32x4_t *a6, int a7, char a8, char a9, _WORD *a10)
{
  uint64_t v14;
  size_t v16;
  void *v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  int v24;
  const char *v25;
  const char *v26;
  uint64_t v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  uint64_t v32;
  int v33;
  int v34;
  const char *v35;
  NSObject *v36;
  uint32_t v37;
  int v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  int v43;
  int v44;
  uint64_t v45;
  size_t v46;
  char v47;
  const char *v48;
  const char *v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  _BYTE *v53;
  _BYTE *v54;
  BOOL v55;
  const char *v56;
  _BYTE *v57;
  _BYTE *v58;
  BOOL v59;
  const char *v60;
  uint64_t *v61;
  char v62;
  uint64_t v63;
  int v64;
  int v65;
  const char *v66;
  BOOL v67;
  BOOL v68;
  BOOL v69;
  const char *v70;
  uint64_t v71;
  unsigned int v72;
  uint64_t v73;
  NSObject *v74;
  int v75;
  int v76;
  unsigned int v77;
  _BYTE *v78;
  _BYTE *v79;
  BOOL v80;
  unsigned int v81;
  const char *v82;
  uint64_t v83;
  void *v84;
  BOOL v85;
  BOOL v86;
  const char *v87;
  int v88;
  int v89;
  BOOL v90;
  const char *v91;
  _QWORD *v92;
  _QWORD *v93;
  _QWORD *v94;
  uint64_t v95;
  _BYTE *v96;
  _BYTE *v97;
  _QWORD *v98;
  _BYTE *v99;
  BOOL v100;
  NSObject *v101;
  int v102;
  int v103;
  uint64_t v104;
  BOOL v105;
  NSObject *v106;
  int v107;
  int v108;
  uint64_t v109;
  unsigned int v110;
  _BYTE *v111;
  uint64_t v112;
  int v113;
  NSObject *v114;
  int v115;
  int v116;
  const char *v117;
  unsigned int v118;
  const char *v119;
  const char *v120;
  uint64_t v121;
  _BYTE *v122;
  int v123;
  int v124;
  NSObject *v125;
  int v126;
  int v127;
  void *v128;
  int v129;
  const char *v130;
  BOOL v131;
  BOOL v132;
  BOOL v133;
  BOOL v134;
  BOOL v135;
  char v136;
  int v137;
  _BYTE *v138;
  BOOL v139;
  _BYTE *v140;
  char v141;
  int v142;
  _BYTE *v143;
  BOOL v144;
  _BYTE *v145;
  char v146;
  int v147;
  _BYTE *v148;
  int v149;
  uint64_t v151;
  unsigned int v154;
  __int128 v155;
  __int128 v156;
  __int128 v157;
  __int128 v158;
  uint8_t v159[4];
  const char *v160;
  __int16 v161;
  int v162;
  __int16 v163;
  int v164;
  __int16 v165;
  uint64_t v166;
  __int16 v167;
  uint8_t *v168;
  __int16 v169;
  uint64_t v170;
  __int16 v171;
  uint8_t *v172;
  __int16 v173;
  uint64_t v174;
  __int16 v175;
  uint64_t v176;
  uint8_t v177[256];
  uint8_t buf[4];
  const char *v179;
  __int16 v180;
  _BYTE v181[10];
  _BYTE v182[10];
  __int16 v183;
  uint8_t *v184;
  __int16 v185;
  _BYTE v186[24];
  __int16 v187;
  uint64_t v188;
  __int16 v189;
  uint64_t v190;
  __int16 v191;
  int v192;
  __int16 v193;
  __int8 *v194;
  __int16 v195;
  uint64_t v196;
  __int16 v197;
  int v198;
  __int16 v199;
  uint64_t *v200;

  v14 = *(_QWORD *)(a1 + 192);
  if (!*(_QWORD *)(v14 + 8))
    a8 = 1;
  if (!(_DWORD)a5)
  {
    v32 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return;
    v33 = *(_DWORD *)(a1 + 4);
    v34 = *(_DWORD *)(v14 + 64);
    *(_DWORD *)buf = 136447747;
    v179 = "dp_query_add_data_to_response";
    v180 = 1024;
    *(_DWORD *)v181 = v33;
    *(_WORD *)&v181[4] = 1024;
    *(_DWORD *)&v181[6] = v34;
    strcpy(v182, "p\bhash");
    v182[7] = 0;
    *(_WORD *)&v182[8] = 0;
    v183 = 2081;
    v184 = a2;
    v185 = 2082;
    *(_QWORD *)v186 = dns_rrtype_to_string(a3);
    *(_WORD *)&v186[8] = 1024;
    *(_DWORD *)&v186[10] = a4;
    v35 = "%{public}s: [Q%d][QU%d] eliding zero-length response for %{private, mask.hash}s %{public}s %d";
    v36 = v32;
    v37 = 60;
LABEL_21:
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v35, buf, v37);
    return;
  }
  v16 = a5;
  v151 = *(_QWORD *)(a1 + 104);
  if ((a9 & 1) != 0)
    goto LABEL_6;
  if (a3 == 1 && (_DWORD)a5 == 4)
  {
    v38 = a6->u8[0];
    if (v38 == 169)
    {
      if (a6->u8[1] == 254)
      {
        v39 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          return;
        v88 = *(_DWORD *)(a1 + 4);
        v89 = *(_DWORD *)(v14 + 64);
        *(_DWORD *)buf = 136448003;
        v179 = "dp_query_add_data_to_response";
        v180 = 1024;
        *(_DWORD *)v181 = v88;
        *(_WORD *)&v181[4] = 1024;
        *(_DWORD *)&v181[6] = v89;
        strcpy(v182, "p\bhash");
        v182[7] = 0;
        *(_WORD *)&v182[8] = 0;
        v183 = 2081;
        v184 = a2;
        v185 = 2160;
        *(_QWORD *)v186 = 1752392040;
        *(_WORD *)&v186[8] = 1041;
        *(_DWORD *)&v186[10] = 4;
        *(_WORD *)&v186[14] = 2097;
        *(_QWORD *)&v186[16] = a6;
        v35 = "%{public}s: [Q%d][QU%d] eliding link-local response for %{private, mask.hash}s: %{private, mask.hash, network:in_addr}.4P";
        goto LABEL_118;
      }
    }
    else if (v38 == 127)
    {
      v39 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v40 = *(_DWORD *)(a1 + 4);
      v41 = *(_DWORD *)(v14 + 64);
      *(_DWORD *)buf = 136448003;
      v179 = "dp_query_add_data_to_response";
      v180 = 1024;
      *(_DWORD *)v181 = v40;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v41;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      v183 = 2081;
      v184 = a2;
      v185 = 2160;
      *(_QWORD *)v186 = 1752392040;
      *(_WORD *)&v186[8] = 1041;
      *(_DWORD *)&v186[10] = 4;
      *(_WORD *)&v186[14] = 2097;
      *(_QWORD *)&v186[16] = a6;
      v35 = "%{public}s: [Q%d][QU%d] eliding localhost response for %{private, mask.hash}s: %{private, mask.hash, network:in_addr}.4P";
LABEL_118:
      v36 = v39;
      v37 = 70;
      goto LABEL_21;
    }
  }
  else if (a3 == 28 && (_DWORD)a5 == 16)
  {
    v61 = &a6->i64[1];
    if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*a6, (int32x4_t)xmmword_10007C750)))) & 1) != 0)
    {
      v62 = (char)*a6;
      if ((*(_OWORD *)a6 & 0xC0FF) != 0x80FE)
        goto LABEL_6;
      v63 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v64 = *(_DWORD *)(a1 + 4);
      v65 = *(_DWORD *)(v14 + 64);
      v66 = "LUA: ";
      *(_DWORD *)buf = 136449795;
      v179 = "dp_query_add_data_to_response";
      if ((v62 & 0xFE) == 0xFC)
        v66 = "ULA: ";
      v180 = 1024;
      *(_DWORD *)v181 = v64;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v65;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      v183 = 2081;
      v184 = a2;
      v185 = 2082;
      *(_QWORD *)v186 = v66;
      *(_WORD *)&v186[8] = 2160;
      *(_QWORD *)&v186[10] = 1752392040;
      *(_WORD *)&v186[18] = 1041;
      *(_DWORD *)&v186[20] = 6;
      v187 = 2097;
      v188 = (uint64_t)a6;
      v189 = 2160;
      v190 = 1752392040;
      v191 = 1042;
      v192 = 2;
      v193 = 2098;
      v194 = &a6->i8[6];
      v195 = 2160;
      v196 = 1752392040;
      v197 = 1041;
      v198 = 8;
      v199 = 2097;
      v200 = v61;
      v35 = "%{public}s: [Q%d][QU%d] eliding link-local response for %{private, mask.hash}s: {%{public}s%{private, mask.h"
            "ash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
    }
    else
    {
      v63 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      v123 = *(_DWORD *)(a1 + 4);
      v124 = *(_DWORD *)(v14 + 64);
      *(_DWORD *)buf = 136449795;
      v179 = "dp_query_add_data_to_response";
      v180 = 1024;
      *(_DWORD *)v181 = v123;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v124;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      v183 = 2081;
      v184 = a2;
      v185 = 2082;
      *(_QWORD *)v186 = &unk_10007C3B5;
      *(_WORD *)&v186[8] = 2160;
      *(_QWORD *)&v186[10] = 1752392040;
      *(_WORD *)&v186[18] = 1041;
      *(_DWORD *)&v186[20] = 6;
      v187 = 2097;
      v188 = (uint64_t)a6;
      v189 = 2160;
      v190 = 1752392040;
      v191 = 1042;
      v192 = 2;
      v193 = 2098;
      v194 = &a6->i8[6];
      v195 = 2160;
      v196 = 1752392040;
      v197 = 1041;
      v198 = 8;
      v199 = 2097;
      v200 = v61;
      v35 = "%{public}s: [Q%d][QU%d] eliding localhost response for %{private, mask.hash}s: {%{public}s%{private, mask.ha"
            "sh, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
    }
    v36 = v63;
    v37 = 132;
    goto LABEL_21;
  }
LABEL_6:
  v18 = &dnssd_client_states;
  v19 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446722;
    v179 = "dp_query_add_data_to_response";
    v180 = 2082;
    *(_QWORD *)v181 = dns_rrtype_to_string(a3);
    *(_WORD *)&v181[8] = 1024;
    *(_DWORD *)v182 = v16;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: survived for rrtype %{public}s rdlen %d", buf, 0x1Cu);
  }
  v20 = a1 + 96;
  if (*(_QWORD *)(a1 + 72))
    dns_push_start(a1);
  v21 = *(_QWORD *)(v14 + 8);
  if (v21)
  {
    dns_concatenate_name_to_wire_(a1 + 96, 0, *(char **)(v14 + 32), *(char **)(v21 + 8), 1225);
    if (*(_DWORD *)(a1 + 144) >= 2u)
      v22 = "concatenate_name_to_wire";
    else
      v22 = 0;
    v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v24 = *(_DWORD *)(a1 + 4);
      v149 = *(_DWORD *)(v14 + 64);
      if (*(_QWORD *)(a1 + 72))
        v25 = "PUSH";
      else
        v25 = "DNS ";
      v26 = dns_rrtype_to_string(a3);
      v27 = *(_QWORD *)(v14 + 32);
      v28 = *(_QWORD *)(*(_QWORD *)(v14 + 8) + 8);
      *(_DWORD *)buf = 136448515;
      v179 = "dp_query_add_data_to_response";
      v180 = 1024;
      *(_DWORD *)v181 = v24;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v149;
      v18 = &dnssd_client_states;
      *(_WORD *)v182 = 2082;
      *(_QWORD *)&v182[2] = v25;
      v20 = a1 + 96;
      v16 = v16;
      v183 = 2082;
      v184 = (uint8_t *)v26;
      v185 = 1024;
      *(_DWORD *)v186 = a4;
      *(_WORD *)&v186[4] = 2160;
      *(_QWORD *)&v186[6] = 1752392040;
      *(_WORD *)&v186[14] = 2081;
      *(_QWORD *)&v186[16] = v27;
      v187 = 2160;
      v188 = 1752392040;
      v189 = 2081;
      v190 = v28;
      v29 = "%{public}s: [Q%d][QU%d] %{public}s answer:  type %{public}s class %02d %{private, mask.hash}s.%{private, mask.hash}s";
      v30 = v23;
      v31 = 90;
LABEL_36:
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
    }
  }
  else
  {
    dns_concatenate_name_to_wire_(a1 + 96, 0, 0, *(char **)(v14 + 32), 1229);
    if (*(_DWORD *)(a1 + 144) >= 2u)
      v22 = "compress_name_to_wire";
    else
      v22 = 0;
    v42 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v43 = *(_DWORD *)(a1 + 4);
      v44 = *(_DWORD *)(v14 + 64);
      v45 = v14;
      v46 = v16;
      v47 = a8;
      if (*(_QWORD *)(a1 + 72))
        v48 = "push";
      else
        v48 = " dns";
      v49 = dns_rrtype_to_string(a3);
      v50 = *(_QWORD *)(v45 + 32);
      *(_DWORD *)buf = 136448003;
      v179 = "dp_query_add_data_to_response";
      v180 = 1024;
      *(_DWORD *)v181 = v43;
      v20 = a1 + 96;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v44;
      *(_WORD *)v182 = 2082;
      *(_QWORD *)&v182[2] = v48;
      a8 = v47;
      v16 = v46;
      v14 = v45;
      v18 = &dnssd_client_states;
      v183 = 2082;
      v184 = (uint8_t *)v49;
      v185 = 1024;
      *(_DWORD *)v186 = a4;
      *(_WORD *)&v186[4] = 2160;
      *(_QWORD *)&v186[6] = 1752392040;
      *(_WORD *)&v186[14] = 2081;
      *(_QWORD *)&v186[16] = v50;
      v29 = "%{public}s: [Q%d][QU%d] %{public}s answer:  type %{public}s class %02d %{private, mask.hash}s (p)";
      v30 = v42;
      v31 = 70;
      goto LABEL_36;
    }
  }
  v51 = *(_DWORD *)(a1 + 144);
  v52 = a3;
  if (v51 > 1)
    goto LABEL_63;
  v53 = *(_BYTE **)(a1 + 104);
  if ((unint64_t)(v53 + 2) >= *(_QWORD *)(a1 + 112))
  {
    v51 = 111;
    *(_DWORD *)(a1 + 144) = 111;
    *(_DWORD *)(a1 + 136) = 1233;
LABEL_63:
    if (v22)
      v67 = 0;
    else
      v67 = v51 > 1;
    v56 = "rrtype";
    if (!v67)
      v56 = v22;
    goto LABEL_68;
  }
  *(_QWORD *)(a1 + 104) = v53 + 1;
  *v53 = BYTE1(a3);
  v54 = *(_BYTE **)(a1 + 104);
  *(_QWORD *)(a1 + 104) = v54 + 1;
  *v54 = a3;
  v51 = *(_DWORD *)(a1 + 144);
  if (v22)
    v55 = 0;
  else
    v55 = v51 > 1;
  v56 = "rrtype";
  if (!v55)
    v56 = v22;
  if (v51 > 1)
  {
LABEL_68:
    if (v56)
      v68 = 0;
    else
      v68 = v51 > 1;
    if (v68)
      v60 = "rrclass";
    else
      v60 = v56;
    goto LABEL_74;
  }
  v57 = *(_BYTE **)(a1 + 104);
  if ((unint64_t)(v57 + 2) >= *(_QWORD *)(a1 + 112))
  {
    v51 = 111;
    *(_DWORD *)(a1 + 144) = 111;
    *(_DWORD *)(a1 + 136) = 1234;
    if (v56)
      v60 = v56;
    else
      v60 = "rrclass";
  }
  else
  {
    *(_QWORD *)(a1 + 104) = v57 + 1;
    *v57 = BYTE1(a4);
    v58 = *(_BYTE **)(a1 + 104);
    *(_QWORD *)(a1 + 104) = v58 + 1;
    *v58 = a4;
    v51 = *(_DWORD *)(a1 + 144);
    if (v56)
      v59 = 0;
    else
      v59 = v51 > 1;
    if (v59)
      v60 = "rrclass";
    else
      v60 = v56;
    if (v51 <= 1)
    {
      dns_u32_to_wire_(v20, a7, 1235);
      v51 = *(_DWORD *)(a1 + 144);
    }
  }
LABEL_74:
  if (v60)
    v69 = 0;
  else
    v69 = v51 > 1;
  v157 = 0u;
  v158 = 0u;
  if (v69)
    v70 = "ttl";
  else
    v70 = v60;
  v155 = 0uLL;
  v156 = 0uLL;
  v154 = 0;
  WORD4(v155) = a3;
  WORD5(v155) = a4;
  if (!dns_rdata_parse_data_((uint64_t)&v155, (uint64_t)a6, &v154, v16, v16, 0))
  {
    v74 = *((_QWORD *)v18 + 306);
    if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
    {
      v75 = *(_DWORD *)(a1 + 4);
      v76 = *(_DWORD *)(v14 + 64);
      *(_DWORD *)buf = 136446722;
      v179 = "dp_query_add_data_to_response";
      v180 = 1024;
      *(_DWORD *)v181 = v75;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v76;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d] rdata from mDNSResponder didn't parse!!", buf, 0x18u);
    }
LABEL_89:
    v77 = *(_DWORD *)(a1 + 144);
    if (v77 <= 1)
    {
      v78 = *(_BYTE **)(a1 + 104);
      if ((unint64_t)(v78 + 2) < *(_QWORD *)(a1 + 112))
      {
        *(_QWORD *)(a1 + 104) = v78 + 1;
        *v78 = BYTE1(v16);
        v79 = *(_BYTE **)(a1 + 104);
        *(_QWORD *)(a1 + 104) = v79 + 1;
        *v79 = v16;
        v77 = *(_DWORD *)(a1 + 144);
        if (v70)
          v80 = 0;
        else
          v80 = v77 > 1;
        v81 = v16;
        if (v80)
          v82 = "rdlen";
        else
          v82 = v70;
        if (v77 <= 1)
        {
          v83 = v81;
          v84 = *(void **)(a1 + 104);
          if ((unint64_t)v84 + v81 <= *(_QWORD *)(a1 + 112))
          {
            memcpy(v84, a6, v81);
            *(_QWORD *)(a1 + 104) += v83;
            v77 = *(_DWORD *)(a1 + 144);
          }
          else
          {
            v77 = 111;
            *(_DWORD *)(a1 + 144) = 111;
            *(_DWORD *)(a1 + 136) = 1295;
          }
        }
LABEL_107:
        if (v82)
          v86 = 0;
        else
          v86 = v77 > 1;
        if (v86)
          v87 = "rdata";
        else
          v87 = v82;
        if ((v77 & 1) != 0)
          goto LABEL_174;
        goto LABEL_169;
      }
      v77 = 111;
      *(_DWORD *)(a1 + 144) = 111;
      *(_DWORD *)(a1 + 136) = 1294;
    }
    if (v70)
      v85 = 0;
    else
      v85 = v77 > 1;
    if (v85)
      v82 = "rdlen";
    else
      v82 = v70;
    goto LABEL_107;
  }
  if (a3 > 0x27)
  {
LABEL_192:
    v125 = *((_QWORD *)v18 + 306);
    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
    {
      v126 = *(_DWORD *)(a1 + 4);
      v127 = v52;
      v128 = v18;
      v129 = *(_DWORD *)(v14 + 64);
      v130 = dns_rrtype_to_string(v127);
      *(_DWORD *)buf = 136446978;
      v179 = "dp_query_add_data_to_response";
      v180 = 1024;
      *(_DWORD *)v181 = v126;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v129;
      v18 = v128;
      *(_WORD *)v182 = 2082;
      *(_QWORD *)&v182[2] = v130;
      _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] record type %{public}s not translated", buf, 0x22u);
    }
    dns_rrdata_free((uint64_t)&v155);
    goto LABEL_89;
  }
  if (((1 << a3) & 0x80008013BCLL) == 0)
  {
    if (a3 == 33)
    {
      v71 = v156;
      v117 = "rdlength begin";
      v118 = *(_DWORD *)(a1 + 144);
      v119 = "answer.data.srv.priority";
      v120 = "answer.data.srv.weight";
      if (v118 <= 1)
      {
        v121 = *(_QWORD *)(a1 + 104);
        v122 = (_BYTE *)(v121 + 2);
        if ((unint64_t)(v121 + 2) >= *(_QWORD *)(a1 + 112))
        {
          v118 = 111;
        }
        else
        {
          if (!*(_QWORD *)(a1 + 120))
          {
            *(_QWORD *)(a1 + 120) = v121;
            *(_QWORD *)(a1 + 104) = v122;
            if (v70)
              v135 = 0;
            else
              v135 = v118 > 1;
            if (!v135)
              v117 = v70;
            if ((unint64_t)(v121 + 4) < *(_QWORD *)(a1 + 112))
            {
              v136 = BYTE8(v156);
              v137 = HIBYTE(WORD4(v156));
              *(_QWORD *)(a1 + 104) = v122 + 1;
              *v122 = v137;
              v138 = *(_BYTE **)(a1 + 104);
              *(_QWORD *)(a1 + 104) = v138 + 1;
              *v138 = v136;
              v118 = *(_DWORD *)(a1 + 144);
              if (v117)
                v139 = 0;
              else
                v139 = v118 > 1;
              if (!v139)
                v119 = v117;
              if (v118 <= 1)
              {
                v140 = *(_BYTE **)(a1 + 104);
                if ((unint64_t)(v140 + 2) < *(_QWORD *)(a1 + 112))
                {
                  v141 = BYTE10(v156);
                  v142 = HIBYTE(WORD5(v156));
                  *(_QWORD *)(a1 + 104) = v140 + 1;
                  *v140 = v142;
                  v143 = *(_BYTE **)(a1 + 104);
                  *(_QWORD *)(a1 + 104) = v143 + 1;
                  *v143 = v141;
                  v118 = *(_DWORD *)(a1 + 144);
                  if (v119)
                    v144 = 0;
                  else
                    v144 = v118 > 1;
                  if (!v144)
                    v120 = v119;
                  if (v118 <= 1)
                  {
                    v145 = *(_BYTE **)(a1 + 104);
                    if ((unint64_t)(v145 + 2) >= *(_QWORD *)(a1 + 112))
                    {
                      v118 = 111;
                      *(_DWORD *)(a1 + 144) = 111;
                      *(_DWORD *)(a1 + 136) = 1264;
                    }
                    else
                    {
                      v146 = BYTE12(v156);
                      v147 = HIBYTE(WORD6(v156));
                      *(_QWORD *)(a1 + 104) = v145 + 1;
                      *v145 = v147;
                      v148 = *(_BYTE **)(a1 + 104);
                      *(_QWORD *)(a1 + 104) = v148 + 1;
                      *v148 = v146;
                      v118 = *(_DWORD *)(a1 + 144);
                    }
                  }
                  goto LABEL_214;
                }
                v118 = 111;
                *(_DWORD *)(a1 + 144) = 111;
                *(_DWORD *)(a1 + 136) = 1263;
              }
LABEL_209:
              if (v119)
                v133 = 0;
              else
                v133 = v118 > 1;
              if (!v133)
                v120 = v119;
LABEL_214:
              if (v120)
                v134 = 0;
              else
                v134 = v118 > 1;
              if (v134)
                v91 = "answer.data.srv.port";
              else
                v91 = v120;
              goto LABEL_127;
            }
            v118 = 111;
            *(_DWORD *)(a1 + 144) = 111;
            *(_DWORD *)(a1 + 136) = 1262;
LABEL_204:
            if (v117)
              v132 = 0;
            else
              v132 = v118 > 1;
            if (!v132)
              v119 = v117;
            goto LABEL_209;
          }
          v118 |= 0x2Cu;
        }
        *(_DWORD *)(a1 + 144) = v118;
        *(_DWORD *)(a1 + 136) = 1261;
      }
      if (v70)
        v131 = 0;
      else
        v131 = v118 > 1;
      if (!v131)
        v117 = v70;
      goto LABEL_204;
    }
    goto LABEL_192;
  }
  v71 = v156;
  v72 = *(_DWORD *)(a1 + 144);
  if (v72 <= 1)
  {
    v73 = *(_QWORD *)(a1 + 104);
    if ((unint64_t)(v73 + 2) >= *(_QWORD *)(a1 + 112))
    {
      v72 = 111;
    }
    else
    {
      if (!*(_QWORD *)(a1 + 120))
      {
        *(_QWORD *)(a1 + 120) = v73;
        *(_QWORD *)(a1 + 104) = v73 + 2;
        goto LABEL_121;
      }
      v72 |= 0x2Cu;
    }
    *(_DWORD *)(a1 + 144) = v72;
    *(_DWORD *)(a1 + 136) = 1257;
  }
LABEL_121:
  if (v70)
    v90 = 0;
  else
    v90 = v72 > 1;
  if (v90)
    v91 = "rdlength begin";
  else
    v91 = v70;
LABEL_127:
  dns_name_print_to_limit((uint64_t *)v71, 0, (uint64_t)v177, 0x100uLL);
  if ((a8 & 1) != 0)
    goto LABEL_152;
  v92 = 0;
  v93 = (_QWORD *)v71;
  do
  {
    v94 = v92;
    v92 = v93;
    v93 = (_QWORD *)*v93;
  }
  while (v93);
  if (v94 && *((_BYTE *)v94 + 8) == 5 && dns_labels_equal((uint64_t)v94 + 9, (uint64_t)"local", 5uLL))
  {
    v95 = v20;
    if (v71 && *(_BYTE *)(v71 + 8))
    {
      v96 = 0;
      v97 = (_BYTE *)v71;
      while (1)
      {
        v98 = v96;
        v96 = v97;
        v97 = *(_BYTE **)v97;
        if (!v97)
          break;
        if (!v97[8])
        {
          if (v98 && v96[8] == 5 && dns_labels_equal((uint64_t)(v96 + 9), (uint64_t)"local", 5uLL))
          {
            do
            {
              v99 = *(_BYTE **)v96;
              free(v96);
              v96 = v99;
            }
            while (v99);
            *v98 = 0;
          }
          break;
        }
      }
    }
    dns_name_print_to_limit((uint64_t *)v71, 0, (uint64_t)buf, 0x100uLL);
    dns_concatenate_name_to_wire_(v95, (uint64_t **)v71, 0, *(char **)(*(_QWORD *)(v14 + 8) + 8), 1280);
    if (v91)
      v100 = 0;
    else
      v100 = *(_DWORD *)(a1 + 144) > 1u;
    if (v100)
      v87 = "concatenate_name_to_wire 2";
    else
      v87 = v91;
    v101 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v102 = *(_DWORD *)(a1 + 4);
      v103 = *(_DWORD *)(v14 + 64);
      v104 = *(_QWORD *)(*(_QWORD *)(v14 + 8) + 8);
      *(_DWORD *)v159 = 136448259;
      v160 = "dp_query_add_data_to_response";
      v161 = 1024;
      v162 = v102;
      v163 = 1024;
      v164 = v103;
      v165 = 2160;
      v166 = 1752392040;
      v167 = 2081;
      v168 = v177;
      v169 = 2160;
      v170 = 1752392040;
      v171 = 2081;
      v172 = buf;
      v173 = 2160;
      v174 = 1752392040;
      v175 = 2081;
      v176 = v104;
      _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] translating %{private, mask.hash}s to %{private, mask.hash}s . %{private, mask.hash}s", v159, 0x54u);
    }
    v18 = &dnssd_client_states;
  }
  else
  {
LABEL_152:
    dns_concatenate_name_to_wire_(v20, (uint64_t **)v71, 0, 0, 1285);
    if (v91)
      v105 = 0;
    else
      v105 = *(_DWORD *)(a1 + 144) > 1u;
    if (v105)
      v87 = "concatenate_name_to_wire 2";
    else
      v87 = v91;
    v106 = *((_QWORD *)v18 + 306);
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
    {
      v107 = *(_DWORD *)(a1 + 4);
      if (v14)
        v108 = *(_DWORD *)(v14 + 64);
      else
        v108 = 0;
      *(_DWORD *)buf = 136447235;
      v179 = "dp_query_add_data_to_response";
      v180 = 1024;
      *(_DWORD *)v181 = v107;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v108;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      v183 = 2081;
      v184 = v177;
      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] compressing %{private, mask.hash}s", buf, 0x2Cu);
    }
  }
  do
  {
    if (!v71)
      break;
    v109 = *(_QWORD *)v71;
    free((void *)v71);
    v71 = v109;
  }
  while (v109);
  v110 = *(_DWORD *)(a1 + 144);
  if (v110 > 1)
  {
LABEL_168:
    if ((v110 & 1) != 0)
      goto LABEL_174;
    goto LABEL_169;
  }
  v111 = *(_BYTE **)(a1 + 120);
  if (v111)
  {
    v112 = *(_QWORD *)(a1 + 104) - (_QWORD)v111 - 2;
    *v111 = BYTE1(v112);
    *(_BYTE *)(*(_QWORD *)(a1 + 120) + 1) = v112;
    *(_QWORD *)(a1 + 120) = 0;
    v110 = *(_DWORD *)(a1 + 144);
    goto LABEL_168;
  }
  v113 = v110 | 0x2C;
  *(_DWORD *)(a1 + 144) = v113;
  *(_DWORD *)(a1 + 136) = 1290;
  if ((v113 & 1) != 0)
    goto LABEL_174;
LABEL_169:
  if (!v87)
  {
    if (a10)
    {
      if (!*(_QWORD *)(a1 + 72))
        *a10 = bswap32((bswap32((unsigned __int16)*a10) >> 16) + 1) >> 16;
    }
    return;
  }
LABEL_174:
  v114 = *((_QWORD *)v18 + 306);
  if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
  {
    v115 = *(_DWORD *)(a1 + 4);
    if (v14)
      v116 = *(_DWORD *)(v14 + 64);
    else
      v116 = 0;
    *(_DWORD *)v159 = 136446978;
    v160 = "dp_query_add_data_to_response";
    v161 = 1024;
    v162 = v115;
    v163 = 1024;
    v164 = v116;
    v165 = 2082;
    v166 = (uint64_t)v87;
    _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d] RR ADD FAIL: %{public}s", v159, 0x22u);
  }
  *(_QWORD *)(a1 + 104) = v151;
}

void dns_push_start(uint64_t a1)
{
  uint64_t v2;
  _BYTE *v3;
  _BYTE *v4;
  uint64_t v5;
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  NSObject *v11;
  int v12;
  int v13;
  const char *v14;
  __int16 v15;
  int v16;
  __int16 v17;
  const char *v18;

  if (!*(_QWORD *)(a1 + 152))
  {
    v2 = *(_QWORD *)(a1 + 160);
    *(_DWORD *)(v2 + 8) = 0;
    *(_QWORD *)v2 = 0;
    *(_WORD *)(*(_QWORD *)(a1 + 160) + 2) = *(_WORD *)(*(_QWORD *)(a1 + 160) + 2) & 0xF007 | 0x30;
    if (*(_DWORD *)(a1 + 144) <= 1u)
    {
      v3 = *(_BYTE **)(a1 + 104);
      if ((unint64_t)(v3 + 2) >= *(_QWORD *)(a1 + 112))
      {
        *(_DWORD *)(a1 + 144) = 111;
        *(_DWORD *)(a1 + 136) = 2632;
      }
      else
      {
        *(_QWORD *)(a1 + 104) = v3 + 1;
        *v3 = 0;
        v4 = *(_BYTE **)(a1 + 104);
        *(_QWORD *)(a1 + 104) = v4 + 1;
        *v4 = 65;
      }
    }
    v5 = *(_QWORD *)(a1 + 104);
    if ((unint64_t)(v5 + 2) <= *(_QWORD *)(a1 + 112))
    {
      v10 = *(_DWORD *)(a1 + 144);
      *(_QWORD *)(a1 + 152) = v5;
      *(_QWORD *)(a1 + 104) = v5 + 2;
      if (v10 >= 2)
      {
        v11 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v12 = *(_DWORD *)(a1 + 4);
          v13 = 136446722;
          v14 = "dns_push_start";
          v15 = 1024;
          v16 = v12;
          v17 = 2080;
          v18 = "kDSOType_DNSPushUpdate";
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] couldn't start update: %s", (uint8_t *)&v13, 0x1Cu);
        }
      }
    }
    else
    {
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v7 = *(_DWORD *)(a1 + 4);
        v13 = 136446466;
        v14 = "dns_push_start";
        v15 = 1024;
        v16 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] No room for dso length in DNS Push notification message.", (uint8_t *)&v13, 0x12u);
      }
      v8 = *(_QWORD *)(a1 + 160);
      v9 = v8 + 12 + *(_QWORD *)(a1 + 176);
      *(_QWORD *)(a1 + 96) = v8;
      *(_QWORD *)(a1 + 104) = v8 + 12;
      *(_QWORD *)(a1 + 152) = 0;
      *(_QWORD *)(a1 + 120) = 0;
      *(_QWORD *)(a1 + 128) = 0;
      *(_QWORD *)(a1 + 112) = v9;
    }
  }
}

BOOL embiggen(uint64_t a1)
{
  char *v2;
  char *v3;
  uint64_t v4;
  void *v5;
  char *v6;

  v2 = (char *)malloc_type_malloc(*(_QWORD *)(a1 + 176) + 1410, 0xFBB9856EuLL);
  v3 = v2;
  if (v2)
  {
    memcpy(v2, *(const void **)(a1 + 160), *(_QWORD *)(a1 + 176) + 12);
    v4 = *(_QWORD *)(a1 + 176) + 1398;
    *(_QWORD *)(a1 + 176) = v4;
    v5 = *(void **)(a1 + 160);
    v6 = &v3[*(_QWORD *)(a1 + 104) - (_QWORD)v5];
    *(_QWORD *)(a1 + 120) = 0;
    *(_QWORD *)(a1 + 128) = 0;
    *(_QWORD *)(a1 + 104) = v6;
    *(_QWORD *)(a1 + 112) = &v3[v4 + 12];
    *(_QWORD *)(a1 + 96) = v3;
    free(v5);
    *(_QWORD *)(a1 + 160) = v3;
  }
  return v3 != 0;
}

void dp_query_send_dns_response(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  int v10;
  unsigned int v11;
  uint64_t v12;
  int v13;
  BOOL v14;
  const char *v15;
  uint64_t v16;
  int v17;
  const char *v18;
  NSObject *v19;
  uint32_t v20;
  uint64_t v21;
  int v22;
  int v23;
  int v24;
  __int16 v25;
  uint64_t v26;
  unsigned int v27;
  BOOL v28;
  const char *v29;
  _BYTE *v30;
  _BYTE *v31;
  BOOL v32;
  _BYTE *v33;
  _BYTE *v34;
  BOOL v35;
  const char *v36;
  BOOL v37;
  uint64_t v38;
  BOOL v39;
  BOOL v40;
  BOOL v41;
  const char *v42;
  BOOL v43;
  int v44;
  const char *v45;
  BOOL v46;
  BOOL v47;
  BOOL v48;
  BOOL v49;
  unsigned int v50;
  BOOL v51;
  BOOL v52;
  BOOL v53;
  BOOL v54;
  BOOL v55;
  _BYTE *v56;
  uint64_t v57;
  BOOL v58;
  BOOL v59;
  BOOL v60;
  int v61;
  __int16 v62;
  NSObject *v63;
  int v64;
  int v65;
  unsigned int v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  __int16 v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  const char *v75;
  const char *v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _DWORD *v84;
  int v85;
  _QWORD *v86;
  int32x4_t *v87;
  const void **v88;
  const void **v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unsigned __int32 v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t ***v98;
  uint64_t **v99;
  int v100;
  BOOL v101;
  unsigned int v102;
  size_t v103;
  uint64_t *v104;
  uint64_t **v105;
  char *v107;
  __int128 v108;
  __int128 v109;
  __int128 v110;
  char *v111;
  NSObject *v112;
  void *v113;
  const void *v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t *v120;
  unsigned int *v121;
  uint64_t v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unsigned int v130;
  _BYTE *v131;
  __int16 v132;
  _BYTE *v133;
  _BYTE *v134;
  __int16 v135;
  _BYTE *v136;
  uint64_t v137;
  uint64_t **v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  NSObject *v142;
  const char *v143;
  uint64_t v144;
  _DWORD *v145;
  int v146;
  size_t v147;
  void *v148;
  uint64_t v149;
  _OWORD *v150;
  uint64_t v151;
  _BYTE *v152;
  __int16 v153;
  _BYTE *v154;
  _BYTE *v155;
  __int16 v156;
  _BYTE *v157;
  _BYTE *v158;
  __int16 v159;
  _BYTE *v160;
  uint64_t v161;
  const void *v162;
  int v163;
  unsigned int v164;
  _BYTE *v165;
  uint64_t v166;
  NSObject *v167;
  uint64_t v168;
  _BOOL4 v169;
  int v170;
  uint64_t v171;
  _BOOL4 v172;
  _WORD *v173;
  const char *v174;
  NSObject *v175;
  _BOOL4 v176;
  const char *v177;
  unsigned int v178;
  __int16 v179;
  unsigned int v180;
  _BYTE *v181;
  const char *v182;
  BOOL v183;
  _BYTE *v184;
  _BYTE *v185;
  BOOL v186;
  _BYTE *v187;
  _BYTE *v188;
  BOOL v189;
  _BYTE *v190;
  BOOL v191;
  _BYTE *v192;
  BOOL v193;
  _BYTE *v194;
  _BYTE *v195;
  BOOL v196;
  _BYTE *v197;
  _BYTE *v198;
  BOOL v199;
  BOOL v200;
  BOOL v201;
  BOOL v202;
  BOOL v203;
  BOOL v204;
  BOOL v205;
  uint64_t v206;
  const char *v207;
  uint64_t v208;
  NSObject *v209;
  int v210;
  int v211;
  unsigned int v212;
  uint64_t v213;
  size_t v214;
  NSObject *v215;
  int v216;
  int v217;
  _BOOL4 v218;
  NSObject *v219;
  const char *v220;
  _BOOL4 v221;
  __int16 v222;
  const char *v223;
  uint64_t v224;
  int v225;
  uint64_t v226;
  const void **v227;
  int32x4_t *v228;
  const void **v229;
  int32x4_t *v230;
  const void **v231;
  int32x4_t *v232;
  const void **v233;
  int32x4_t *v234;
  uint64_t v235;
  uint64_t v236;
  const char *v237;
  uint64_t v239;
  int32x4_t *v240;
  uint64_t *v241;
  unsigned int *v242;
  const void **v243;
  uint64_t *v244;
  _QWORD *v245;
  unsigned int *v246;
  char *v247;
  uint64_t *v248;
  uint64_t v249;
  unsigned int *v250;
  char *v251;
  uint64_t *v252;
  uint64_t ***v253;
  unsigned int *v254;
  uint64_t v255;
  _QWORD *v256;
  unsigned __int32 v257;
  char v258;
  iovec v259;
  uint8_t buf[4];
  const char *v261;
  __int16 v262;
  _BYTE v263[10];
  __int128 v264;
  __int16 v265;
  uint64_t v266;
  __int16 v267;
  uint64_t v268;
  __int16 v269;
  int v270;
  __int16 v271;
  uint64_t v272;

  v2 = a1;
  v259.iov_base = 0;
  v259.iov_len = 0;
  v3 = *(_QWORD *)(a1 + 104);
  v4 = *(_DWORD *)(a1 + 144);
  v5 = *(unsigned __int16 *)(*(_QWORD *)(a1 + 160) + 2);
  v6 = *(_QWORD *)(a1 + 192);
  *(_BYTE *)(a1 + 200) = 1;
  v7 = *(_QWORD *)(a1 + 8);
  if (!v7)
  {
    v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v17 = *(_DWORD *)(v2 + 4);
    *(_DWORD *)buf = 136446466;
    v261 = "dp_query_send_dns_response";
    v262 = 1024;
    *(_DWORD *)v263 = v17;
    v18 = "%{public}s: [Q%d] query->tracker NULL for query!";
    v19 = v16;
    v20 = 18;
    goto LABEL_14;
  }
  if (!*(_QWORD *)(v7 + 8))
  {
    v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v22 = *(_DWORD *)(v2 + 4);
    v23 = *(_DWORD *)(v7 + 4);
    *(_DWORD *)buf = 136446722;
    v261 = "dp_query_send_dns_response";
    v262 = 1024;
    *(_DWORD *)v263 = v22;
    *(_WORD *)&v263[4] = 1024;
    *(_DWORD *)&v263[6] = v23;
    v18 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    v19 = v21;
    v20 = 24;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v18, buf, v20);
    return;
  }
  v9 = a1 + 96;
  v10 = (v4 & 1) << 9;
  v11 = bswap32(v5) >> 16;
  v12 = *(_QWORD *)(v6 + 8);
  if (v12)
  {
    v13 = v4 & 1;
    v14 = *(_QWORD *)(v12 + 40) && v13 == 0;
    if (v14 && (*(_WORD *)(v6 + 72) != 6 || **(_BYTE **)(v6 + 32)))
    {
      v15 = 0;
      v26 = a1 + 32;
      while (1)
      {
        dns_pointer_to_wire_(v9, v26, 2412);
        v27 = *(_DWORD *)(v2 + 144);
        if (v15)
          v28 = 0;
        else
          v28 = v27 > 1;
        v29 = "&query->enclosing_domain_pointer 1";
        if (!v28)
          v29 = v15;
        if (v27 >= 2)
        {
          if (!v29)
            v29 = "dns_rrtype_soa";
LABEL_51:
          if (v29)
            v39 = 0;
          else
            v39 = v27 > 1;
          if (v39)
            v36 = "dns_qclass_in";
          else
            v36 = v29;
LABEL_57:
          if (v36)
            v40 = 0;
          else
            v40 = v27 > 1;
          v29 = "ttl";
          if (!v40)
            v29 = v36;
          goto LABEL_66;
        }
        v30 = *(_BYTE **)(v2 + 104);
        if ((unint64_t)(v30 + 2) >= *(_QWORD *)(v2 + 112))
          break;
        *(_QWORD *)(v2 + 104) = v30 + 1;
        *v30 = 0;
        v31 = *(_BYTE **)(v2 + 104);
        *(_QWORD *)(v2 + 104) = v31 + 1;
        *v31 = 6;
        v27 = *(_DWORD *)(v2 + 144);
        if (v29)
          v32 = 0;
        else
          v32 = v27 > 1;
        if (v32)
          v29 = "dns_rrtype_soa";
        if (v27 > 1)
          goto LABEL_51;
        v33 = *(_BYTE **)(v2 + 104);
        if ((unint64_t)(v33 + 2) >= *(_QWORD *)(v2 + 112))
        {
          v27 = 111;
          *(_DWORD *)(v2 + 144) = 111;
          *(_DWORD *)(v2 + 136) = 2416;
          v41 = v29 == 0;
          v42 = "dns_qclass_in";
LABEL_64:
          if (v41)
            v29 = v42;
          goto LABEL_66;
        }
        *(_QWORD *)(v2 + 104) = v33 + 1;
        *v33 = 0;
        v34 = *(_BYTE **)(v2 + 104);
        *(_QWORD *)(v2 + 104) = v34 + 1;
        *v34 = 1;
        v27 = *(_DWORD *)(v2 + 144);
        if (v29)
          v35 = 0;
        else
          v35 = v27 > 1;
        if (v35)
          v36 = "dns_qclass_in";
        else
          v36 = v29;
        if (v27 >= 2)
          goto LABEL_57;
        dns_u32_to_wire_(v9, 3600, 2417);
        v27 = *(_DWORD *)(v2 + 144);
        if (v36)
          v37 = 0;
        else
          v37 = v27 > 1;
        v29 = "ttl";
        if (!v37)
          v29 = v36;
        if (v27 <= 1)
        {
          v38 = *(_QWORD *)(v2 + 104);
          if ((unint64_t)(v38 + 2) >= *(_QWORD *)(v2 + 112))
          {
            v27 = 111;
            goto LABEL_153;
          }
          if (*(_QWORD *)(v2 + 120))
          {
            v27 |= 0x2Cu;
LABEL_153:
            *(_DWORD *)(v2 + 144) = v27;
            *(_DWORD *)(v2 + 136) = 2418;
            goto LABEL_66;
          }
          *(_QWORD *)(v2 + 120) = v38;
          *(_QWORD *)(v2 + 104) = v38 + 2;
        }
LABEL_66:
        if (v29)
          v43 = 0;
        else
          v43 = v27 > 1;
        if (v43)
          v15 = "rdlength_begin ";
        else
          v15 = v29;
        if (uuid_name)
        {
          dns_name_to_wire_(0, (uint64_t *)v9, &uuid_name, 2425);
          v44 = 2427;
          v45 = "uuid_name";
        }
        else
        {
          dns_name_to_wire_(0, (uint64_t *)v9, "ns", 2429);
          v44 = 2431;
          v45 = "\"ns\"";
        }
        if (v15)
          v46 = 0;
        else
          v46 = *(_DWORD *)(a1 + 144) > 1u;
        if (v46)
          v15 = v45;
        dns_pointer_to_wire_(v9, v26, v44);
        if (v15)
          v47 = 0;
        else
          v47 = *(_DWORD *)(a1 + 144) > 1u;
        if (v47)
          v15 = "&query->enclosing_domain_pointer 2";
        dns_name_to_wire_(0, (uint64_t *)v9, "postmaster", 2434);
        if (v15)
          v48 = 0;
        else
          v48 = *(_DWORD *)(a1 + 144) > 1u;
        if (v48)
          v15 = "\"postmaster\"";
        dns_pointer_to_wire_(v9, v26, 2436);
        if (v15)
          v49 = 0;
        else
          v49 = *(_DWORD *)(a1 + 144) > 1u;
        if (v49)
          v15 = "&query->enclosing_domain_pointer 3";
        dns_u32_to_wire_(v9, 0, 2437);
        v50 = *(_DWORD *)(a1 + 144);
        if (v15)
          v51 = 0;
        else
          v51 = v50 > 1;
        if (v51)
          v15 = "serial";
        if (v50 >= 2)
        {
          if (!v15)
            v15 = "refresh";
LABEL_130:
          if (v15)
            v58 = 0;
          else
            v58 = v50 > 1;
          if (v58)
            v15 = "retry";
LABEL_135:
          if (v15)
            v59 = 0;
          else
            v59 = v50 > 1;
          if (v59)
            v15 = "expire";
LABEL_140:
          if (v15)
            v60 = 0;
          else
            v60 = v50 > 1;
          if (v60)
            v15 = "minimum";
LABEL_145:
          if ((v50 & 1) == 0)
            goto LABEL_155;
          goto LABEL_146;
        }
        dns_u32_to_wire_(v9, 7200, 2438);
        v50 = *(_DWORD *)(a1 + 144);
        if (v15)
          v52 = 0;
        else
          v52 = v50 > 1;
        if (v52)
          v15 = "refresh";
        if (v50 >= 2)
          goto LABEL_130;
        dns_u32_to_wire_(v9, 3600, 2439);
        v50 = *(_DWORD *)(a1 + 144);
        if (v15)
          v53 = 0;
        else
          v53 = v50 > 1;
        if (v53)
          v15 = "retry";
        if (v50 >= 2)
          goto LABEL_135;
        dns_u32_to_wire_(v9, 86400, 2440);
        v50 = *(_DWORD *)(a1 + 144);
        if (v15)
          v54 = 0;
        else
          v54 = v50 > 1;
        if (v54)
          v15 = "expire";
        if (v50 >= 2)
          goto LABEL_140;
        dns_u32_to_wire_(v9, 120, 2441);
        v50 = *(_DWORD *)(a1 + 144);
        if (v15)
          v55 = 0;
        else
          v55 = v50 > 1;
        if (v55)
          v15 = "minimum";
        if (v50 > 1)
          goto LABEL_145;
        v56 = *(_BYTE **)(a1 + 120);
        if (v56)
        {
          v57 = *(_QWORD *)(a1 + 104) - (_QWORD)v56 - 2;
          *v56 = BYTE1(v57);
          *(_BYTE *)(*(_QWORD *)(a1 + 120) + 1) = v57;
          *(_QWORD *)(a1 + 120) = 0;
          if ((*(_DWORD *)(a1 + 144) & 1) == 0)
            goto LABEL_155;
        }
        else
        {
          v61 = v50 | 0x2C;
          *(_DWORD *)(a1 + 144) = v61;
          *(_DWORD *)(a1 + 136) = 2442;
          if ((v61 & 1) == 0)
          {
LABEL_155:
            v2 = a1;
            *(_WORD *)(*(_QWORD *)(a1 + 160) + 8) = 256;
            goto LABEL_157;
          }
        }
LABEL_146:
        v2 = a1;
        *(_QWORD *)(a1 + 104) = v3;
        if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) + 416) & 0x20) == 0)
        {
          v10 = 512;
LABEL_157:
          v237 = v15;
          v24 = v10;
          LOWORD(v10) = v11 & 0xFB7F;
          v25 = 1024;
          v225 = v24;
          goto LABEL_158;
        }
        if (!embiggen(a1))
          goto LABEL_157;
        *(_DWORD *)(a1 + 144) = 0;
      }
      v27 = 111;
      *(_DWORD *)(v2 + 144) = 111;
      *(_DWORD *)(v2 + 136) = 2414;
      v41 = v29 == 0;
      v42 = "dns_rrtype_soa";
      goto LABEL_64;
    }
  }
  if (*(_WORD *)(v6 + 72) == 6)
  {
    v15 = 0;
    goto LABEL_157;
  }
  v237 = 0;
  LOWORD(v24) = v11 & 0xFB7F;
  v25 = 128;
  v225 = v10;
LABEL_158:
  v62 = v24 | v25;
  v63 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v64 = *(_DWORD *)(v2 + 4);
    if (v6)
      v65 = *(_DWORD *)(v6 + 64);
    else
      v65 = 0;
    v66 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v2 + 64) + 88));
    v67 = *(_QWORD *)(v2 + 104);
    v68 = *(_QWORD *)(v2 + 96) + 12;
    v69 = *(_BYTE *)(*(_QWORD *)(v2 + 160) + 3) & 0xF;
    *(_DWORD *)buf = 136448258;
    v261 = "dp_query_send_dns_response";
    v262 = 1024;
    *(_DWORD *)v263 = v64;
    *(_WORD *)&v263[4] = 1024;
    *(_DWORD *)&v263[6] = v65;
    LOWORD(v264) = 1024;
    *(_DWORD *)((char *)&v264 + 2) = HIWORD(v66);
    WORD3(v264) = 2048;
    *((_QWORD *)&v264 + 1) = v67;
    v265 = 2048;
    v266 = v68;
    v267 = 2048;
    v268 = v67 - v68;
    v269 = 1024;
    v270 = v69;
    v271 = 2082;
    v272 = a2;
    _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d][QID %x] ->p %p ->lim %p len %zd rcode %d %{public}s", buf, 0x4Cu);
  }
  v70 = (v5 >> 8) & 0xF;
  v71 = v10 | v62;
  if (*(_DWORD *)(v2 + 144) > 1u || v70)
  {
    v173 = *(_WORD **)(v2 + 160);
    v79 = v2;
    v74 = &dnssd_client_states;
    v75 = v237;
LABEL_337:
    v173[1] = bswap32(v71 & 0x7ECF | 0xFFFF8000) >> 16;
    if (v70)
    {
      v179 = __rev16(v71 & 0x7EC0 | 0x8000 | v70);
      goto LABEL_459;
    }
    goto LABEL_340;
  }
  v72 = *(_QWORD *)(v2 + 8);
  v73 = *(_QWORD *)(v2 + 192);
  v74 = &dnssd_client_states;
  v75 = v237;
  if (v73)
  {
    v76 = *(const char **)(v73 + 32);
    if (v72)
      goto LABEL_167;
LABEL_332:
    v174 = v76;
    *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) = *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) & 0xF0FF | 0x200;
    v175 = global_os_log;
    v176 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    v79 = v2;
    if (!v176)
      goto LABEL_335;
    *(_DWORD *)buf = 136446723;
    v261 = "dp_dns_queries_finished";
    v262 = 2160;
    *(_QWORD *)v263 = 1752392040;
    *(_WORD *)&v263[8] = 2081;
    *(_QWORD *)&v264 = v174;
    v177 = "%{public}s: NULL tracker on %{private, mask.hash}s";
    goto LABEL_470;
  }
  v76 = "(null)";
  if (!v72)
    goto LABEL_332;
LABEL_167:
  v226 = *(_QWORD *)(v2 + 8);
  v77 = *(_QWORD *)(v72 + 16);
  if (!v77)
  {
    v220 = v76;
    *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) = *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) & 0xF0FF | 0x200;
    v175 = global_os_log;
    v221 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    v79 = v2;
    if (!v221)
      goto LABEL_335;
    *(_DWORD *)buf = 136446723;
    v261 = "dp_dns_queries_finished";
    v262 = 2160;
    *(_QWORD *)v263 = 1752392040;
    *(_WORD *)&v263[8] = 2081;
    *(_QWORD *)&v264 = v220;
    v177 = "%{public}s: NULL tracker->dns_queries on %{private, mask.hash}s";
LABEL_470:
    _os_log_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_ERROR, v177, buf, 0x20u);
    goto LABEL_474;
  }
  v78 = *(_DWORD *)(v2 + 88);
  v79 = v2;
  if (v78 == 1)
    goto LABEL_335;
  v223 = v76;
  v80 = 0;
  v81 = *(_QWORD *)(v72 + 16);
  do
  {
    if (!*(_QWORD *)(v81 + 160))
    {
      v219 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v261 = "dp_dns_queries_finished";
        _os_log_impl((void *)&_mh_execute_header, v219, OS_LOG_TYPE_ERROR, "%{public}s: null response on match query", buf, 0xCu);
      }
LABEL_473:
      *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) = *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) & 0xF0FF | 0x200;
LABEL_474:
      v79 = v2;
      goto LABEL_335;
    }
    if (*(_QWORD *)(v81 + 64) == *(_QWORD *)(v2 + 64))
    {
      if (!*(_BYTE *)(v81 + 200))
        return;
      ++v80;
    }
    v81 = *(_QWORD *)(v81 + 16);
  }
  while (v81);
  if (v80 != v78)
    return;
  v79 = 0;
  v235 = 0;
  v236 = 0;
  v82 = 0;
  do
  {
    if (*(_QWORD *)(v77 + 64) == *(_QWORD *)(v2 + 64))
    {
      v83 = v79;
      if ((dns_wire_parse_((uint64_t *)(v77 + 168), *(unsigned __int16 **)(v77 + 160), *(_DWORD *)(v77 + 104) - *(_QWORD *)(v77 + 160)) & 1) == 0)goto LABEL_473;
      v84 = *(_DWORD **)(v77 + 168);
      if (v83)
      {
        v79 = v83;
      }
      else
      {
        v82 = *(_QWORD *)(v77 + 168);
        v79 = v77;
      }
      LODWORD(v235) = v84[1] + v235;
      HIDWORD(v235) += v84[2];
      LODWORD(v236) = v84[3] + v236;
      HIDWORD(v236) += v84[4];
    }
    v77 = *(_QWORD *)(v77 + 16);
  }
  while (v77);
  v222 = v71;
  v224 = v6;
  v85 = 0;
  v232 = (int32x4_t *)(v82 + 16);
  v233 = (const void **)(v82 + 48);
  v230 = (int32x4_t *)(v82 + 12);
  v231 = (const void **)(v82 + 40);
  v228 = (int32x4_t *)(v82 + 8);
  v229 = (const void **)(v82 + 32);
  v227 = (const void **)(v82 + 24);
  v234 = (int32x4_t *)(v82 + 4);
  while (2)
  {
    v86 = *(_QWORD **)(v226 + 16);
    if (v86)
    {
      v87 = 0;
      v255 = 0;
      v257 = 0;
      v88 = 0;
      v89 = 0;
      v239 = v79;
      do
      {
        if (*(_QWORD *)(v2 + 64) != v86[8])
          break;
        switch(v85)
        {
          case 0:
            v90 = v86[21];
            v88 = (const void **)(v90 + 24);
            v255 = *(unsigned int *)(v90 + 4);
            v89 = v227;
            v257 = v235;
            v87 = v234;
            break;
          case 1:
            v91 = v86[21];
            v88 = (const void **)(v91 + 32);
            v255 = *(unsigned int *)(v91 + 8);
            v89 = v229;
            v257 = HIDWORD(v235);
            v87 = v228;
            break;
          case 2:
            v92 = v86[21];
            v88 = (const void **)(v92 + 40);
            v255 = *(unsigned int *)(v92 + 12);
            v89 = v231;
            v257 = v236;
            v87 = v230;
            break;
          case 3:
            v93 = v86[21];
            v88 = (const void **)(v93 + 48);
            v255 = *(unsigned int *)(v93 + 16);
            v89 = v233;
            v257 = HIDWORD(v236);
            v87 = v232;
            break;
          default:
            break;
        }
        if (v89 == v88)
        {
          v113 = malloc_type_calloc(v257, 0x40uLL, 0x1032040A90C5805uLL);
          if (!v113)
          {
            *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) = *(_WORD *)(*(_QWORD *)(v2 + 160) + 2) & 0xF0FF | 0x200;
            v74 = &dnssd_client_states;
            v175 = global_os_log;
            v218 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
            v79 = v2;
            v75 = v237;
            v71 = v222;
            if (!v218)
              goto LABEL_335;
            *(_DWORD *)buf = 136446723;
            v261 = "dp_dns_queries_finished";
            v262 = 2160;
            *(_QWORD *)v263 = 1752392040;
            *(_WORD *)&v263[8] = 2081;
            *(_QWORD *)&v264 = v223;
            v177 = "%{public}s: Unable to allocate memory for query response section on %{private, mask.hash}s";
            goto LABEL_470;
          }
          v114 = v113;
          memcpy(v113, *v89, v255 << 6);
          bzero((void *)*v89, v255 << 6);
          free((void *)*v89);
          *v89 = v114;
        }
        else
        {
          v245 = v86;
          v240 = v87;
          v94 = v87->i32[0];
          v243 = v88;
          if (v255)
          {
            v95 = 0;
            v251 = (char *)*v88;
            v247 = (char *)*v89;
            v249 = (uint64_t)*v89 + 16;
            while (!v94)
            {
LABEL_232:
              if (v94 >= v257)
              {
                v112 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446978;
                  v261 = "dp_move_rrs";
                  v262 = 1024;
                  *(_DWORD *)v263 = v94;
                  *(_WORD *)&v263[4] = 1024;
                  *(_DWORD *)&v263[6] = v257;
                  LOWORD(v264) = 1024;
                  *(_DWORD *)((char *)&v264 + 2) = v95;
                  _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_ERROR, "%{public}s: first_count %d unexpectedly equal to count %d with i = %d", buf, 0x1Eu);
                }
              }
              else
              {
                v107 = &v251[64 * v95];
                v108 = *(_OWORD *)v107;
                v109 = *((_OWORD *)v107 + 1);
                v110 = *((_OWORD *)v107 + 3);
                v111 = &v247[64 * (unint64_t)v94];
                *((_OWORD *)v111 + 2) = *((_OWORD *)v107 + 2);
                *((_OWORD *)v111 + 3) = v110;
                *(_OWORD *)v111 = v108;
                *((_OWORD *)v111 + 1) = v109;
                ++v94;
                *((_WORD *)v107 + 4) = 0;
              }
LABEL_236:
              if (++v95 == v255)
                goto LABEL_237;
            }
            v96 = (uint64_t)&v251[64 * v95];
            v97 = v94;
            v98 = (uint64_t ***)(v96 + 16);
            v253 = (uint64_t ***)(v96 + 24);
            v99 = (uint64_t **)v249;
            while (2)
            {
              if (*((unsigned __int16 *)v99 - 4) == *(unsigned __int16 *)(v96 + 8)
                && *((unsigned __int16 *)v99 - 3) == *(unsigned __int16 *)(v96 + 10))
              {
                v100 = dns_names_equal(*(v99 - 2), *(uint64_t ***)v96);
                if (v100)
                  v101 = v85 == 0;
                else
                  v101 = 1;
                if (v101)
                {
LABEL_215:
                  if ((v100 & 1) != 0)
                    goto LABEL_236;
                  goto LABEL_216;
                }
                v102 = *((unsigned __int16 *)v99 - 4);
                if (v102 > 0xF)
                {
                  switch(*((_WORD *)v99 - 4))
                  {
                    case 0x18:
                      goto LABEL_216;
                    case 0x19:
                      LOBYTE(v100) = dns_keys_rdata_equal((uint64_t)(v99 - 2), v96);
                      goto LABEL_215;
                    case 0x1A:
                    case 0x1B:
                    case 0x1D:
                    case 0x1E:
                    case 0x1F:
                    case 0x20:
                      goto LABEL_218;
                    case 0x1C:
                      if (*v99 != (uint64_t *)*v98 || v99[1] != *(uint64_t **)(v96 + 24))
                        goto LABEL_216;
                      goto LABEL_236;
                    case 0x21:
                      if (*((unsigned __int16 *)v99 + 4) != *(unsigned __int16 *)v253
                        || *((unsigned __int16 *)v99 + 5) != *(unsigned __int16 *)(v96 + 26)
                        || *((unsigned __int16 *)v99 + 6) != *(unsigned __int16 *)(v96 + 28))
                      {
                        goto LABEL_216;
                      }
                      goto LABEL_214;
                    default:
                      if (v102 != 16)
                        goto LABEL_218;
                      v103 = *(unsigned __int8 *)v99;
                      if ((_DWORD)v103 != *(unsigned __int8 *)v98)
                        goto LABEL_216;
                      v104 = v99[1];
                      v105 = *v253;
                      break;
                  }
                  goto LABEL_220;
                }
                switch(*((_WORD *)v99 - 4))
                {
                  case 0:
                    goto LABEL_236;
                  case 1:
                    if (*(_DWORD *)v99 != *(_DWORD *)v98)
                      break;
                    goto LABEL_236;
                  case 2:
                  case 5:
                    goto LABEL_214;
                  case 3:
                  case 4:
                    goto LABEL_218;
                  default:
                    if (v102 == 12)
                    {
LABEL_214:
                      LOBYTE(v100) = dns_names_equal(*v99, *v98);
                      goto LABEL_215;
                    }
LABEL_218:
                    v103 = *((unsigned __int16 *)v99 + 4);
                    if ((_DWORD)v103 == *(unsigned __int16 *)v253)
                    {
                      v104 = *v99;
                      v105 = *v98;
LABEL_220:
                      if (!memcmp(v104, v105, v103))
                        goto LABEL_236;
                    }
                    break;
                }
              }
LABEL_216:
              v99 += 8;
              if (!--v97)
                goto LABEL_232;
              continue;
            }
          }
LABEL_237:
          v87 = v240;
          v240->i32[0] = v94;
          v2 = a1;
          v88 = v243;
          v86 = v245;
        }
        v86 = (_QWORD *)v86[2];
        v79 = v239;
      }
      while (v86);
    }
    if (++v85 != 4)
      continue;
    break;
  }
  v115 = v79 + 96;
  v256 = (_QWORD *)(v79 + 120);
  while (2)
  {
    v116 = 0;
    v117 = *(_QWORD *)(v79 + 160);
    v118 = *(_QWORD *)(v79 + 168);
    v119 = v117 + 12 + *(_QWORD *)(v79 + 176);
    *(_QWORD *)(v79 + 104) = v117 + 12;
    *(_QWORD *)(v79 + 112) = v119;
    *(_QWORD *)(v79 + 96) = v117;
    *(_QWORD *)(v79 + 152) = 0;
    v248 = (uint64_t *)(v118 + 48);
    v250 = (unsigned int *)(v118 + 16);
    v244 = (uint64_t *)(v118 + 40);
    v246 = (unsigned int *)(v118 + 12);
    v242 = (unsigned int *)(v118 + 8);
    *v256 = 0;
    v256[1] = 0;
    v241 = (uint64_t *)(v118 + 32);
    v254 = (unsigned int *)(v118 + 4);
    v252 = (uint64_t *)(v118 + 24);
    v258 = 1;
    while (2)
    {
      v120 = v252;
      v121 = v254;
      switch(v116)
      {
        case 0:
          goto LABEL_248;
        case 1:
          v120 = v241;
          v121 = v242;
          goto LABEL_248;
        case 2:
          v120 = v244;
          v121 = v246;
          goto LABEL_248;
        case 3:
          v120 = v248;
          v121 = v250;
LABEL_248:
          v122 = *v121;
          if ((int)v122 < 1)
            goto LABEL_325;
          v123 = 0;
          v124 = 0;
          v125 = *v120;
          v126 = v122 << 6;
          break;
        default:
          goto LABEL_325;
      }
      while (2)
      {
        if ((*(_BYTE *)(v79 + 144) & 1) != 0)
        {
LABEL_319:
          v167 = global_os_log;
          v168 = v79;
          v169 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
          v79 = v168;
          if (v169)
          {
            v170 = *(unsigned __int16 *)(v125 + v124 + 8);
            *(_DWORD *)buf = 136446978;
            v261 = "dns_message_rrs_to_wire";
            v262 = 1024;
            *(_DWORD *)v263 = v116;
            *(_WORD *)&v263[4] = 1024;
            *(_DWORD *)&v263[6] = v123;
            LOWORD(v264) = 1024;
            *(_DWORD *)((char *)&v264 + 2) = v170;
            _os_log_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_ERROR, "%{public}s: no space in message for rr %d/%d %d", buf, 0x1Eu);
            v79 = v168;
          }
        }
        else
        {
          v127 = *(_QWORD *)(v79 + 104);
          v128 = v125 + v124;
          v129 = v79;
          dns_concatenate_name_to_wire_(v115, *(uint64_t ***)(v125 + v124), 0, 0, 648);
          v79 = v129;
          v130 = *(_DWORD *)(v129 + 144);
          if (v130 > 1)
            goto LABEL_257;
          v131 = *(_BYTE **)(v129 + 104);
          if ((unint64_t)(v131 + 2) < *(_QWORD *)(v129 + 112))
          {
            v132 = *(_WORD *)(v128 + 8);
            *(_QWORD *)(v129 + 104) = v131 + 1;
            *v131 = HIBYTE(v132);
            v133 = *(_BYTE **)(v129 + 104);
            *(_QWORD *)(v129 + 104) = v133 + 1;
            *v133 = v132;
            v130 = *(_DWORD *)(v129 + 144);
            if (v130 > 1)
              goto LABEL_257;
            v134 = *(_BYTE **)(v129 + 104);
            if ((unint64_t)(v134 + 2) < *(_QWORD *)(v129 + 112))
            {
              v135 = *(_WORD *)(v125 + v124 + 10);
              *(_QWORD *)(v129 + 104) = v134 + 1;
              *v134 = HIBYTE(v135);
              v136 = *(_BYTE **)(v129 + 104);
              *(_QWORD *)(v129 + 104) = v136 + 1;
              *v136 = v135;
              v130 = *(_DWORD *)(v129 + 144);
              goto LABEL_257;
            }
            v130 = 111;
            *(_DWORD *)(v129 + 144) = 111;
            *(_DWORD *)(v129 + 136) = 650;
            if ((v258 & 1) != 0)
            {
LABEL_318:
              *(_QWORD *)(v79 + 104) = v127;
              goto LABEL_319;
            }
            goto LABEL_269;
          }
          v130 = 111;
          *(_DWORD *)(v129 + 144) = 111;
          *(_DWORD *)(v129 + 136) = 649;
LABEL_257:
          if ((v258 & 1) != 0)
          {
            if (v130)
              goto LABEL_318;
          }
          else
          {
            if (v130 > 1)
              goto LABEL_269;
            dns_u32_to_wire_(v115, *(_DWORD *)(v125 + v124 + 12), 654);
            v79 = v129;
            v130 = *(_DWORD *)(v129 + 144);
            if (v130 > 1)
              goto LABEL_269;
            v137 = *(_QWORD *)(v129 + 104);
            if ((unint64_t)(v137 + 2) >= *(_QWORD *)(v129 + 112))
            {
              v130 = 111;
            }
            else
            {
              if (!*v256)
              {
                *(_QWORD *)(v129 + 120) = v137;
                *(_QWORD *)(v129 + 104) = v137 + 2;
                goto LABEL_269;
              }
              v130 |= 0x2Cu;
            }
            *(_DWORD *)(v129 + 144) = v130;
            *(_DWORD *)(v129 + 136) = 655;
LABEL_269:
            switch(*(_WORD *)(v128 + 8))
            {
              case 0:
                v144 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446210;
                  v261 = "dns_rr_to_wire";
                  v142 = v144;
                  v143 = "%{public}s: invalid rr!";
LABEL_288:
                  _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_ERROR, v143, buf, 0xCu);
                  v130 = *(_DWORD *)(v129 + 144);
                }
LABEL_289:
                v79 = v129;
                *(_DWORD *)(v129 + 144) = v130 & 1 | 0x2C;
                goto LABEL_318;
              case 1:
                if (v130 > 1)
                  goto LABEL_312;
                v145 = *(_DWORD **)(v79 + 104);
                if ((unint64_t)(v145 + 1) > *(_QWORD *)(v79 + 112))
                {
                  *(_DWORD *)(v79 + 144) = 111;
                  v146 = 693;
                  goto LABEL_317;
                }
                *v145 = *(_DWORD *)(v125 + v124 + 16);
                v161 = *(_QWORD *)(v79 + 104) + 4;
LABEL_306:
                *(_QWORD *)(v79 + 104) = v161;
                goto LABEL_312;
              case 2:
              case 5:
              case 0xC:
                v138 = *(uint64_t ***)(v125 + v124 + 16);
                v139 = v115;
                v140 = 682;
                goto LABEL_310;
              case 3:
              case 4:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xD:
              case 0xE:
              case 0xF:
LABEL_283:
                if (v130 > 1)
                  goto LABEL_312;
                v147 = *(unsigned __int16 *)(v125 + v124 + 24);
                v148 = *(void **)(v79 + 104);
                if ((unint64_t)v148 + v147 > *(_QWORD *)(v79 + 112))
                {
                  *(_DWORD *)(v79 + 144) = 111;
                  v146 = 665;
                  goto LABEL_317;
                }
                v162 = *(const void **)(v125 + v124 + 16);
                goto LABEL_304;
              case 6:
                dns_concatenate_name_to_wire_(v115, *(uint64_t ***)(v125 + v124 + 16), 0, 0, 669);
                dns_concatenate_name_to_wire_(v115, *(uint64_t ***)(v125 + v124 + 24), 0, 0, 670);
                dns_u32_to_wire_(v115, *(_DWORD *)(v125 + v124 + 32), 671);
                dns_u32_to_wire_(v115, *(_DWORD *)(v125 + v124 + 36), 672);
                dns_u32_to_wire_(v115, *(_DWORD *)(v125 + v124 + 40), 673);
                dns_u32_to_wire_(v115, *(_DWORD *)(v125 + v124 + 44), 674);
                dns_u32_to_wire_(v115, *(_DWORD *)(v125 + v124 + 48), 675);
                goto LABEL_311;
              case 0x10:
                if (v130 > 1)
                  goto LABEL_312;
                v147 = *(unsigned __int8 *)(v125 + v124 + 16);
                v148 = *(void **)(v79 + 104);
                if ((unint64_t)v148 + v147 > *(_QWORD *)(v79 + 112))
                {
                  *(_DWORD *)(v79 + 144) = 111;
                  v146 = 712;
LABEL_317:
                  *(_DWORD *)(v79 + 136) = v146;
                  goto LABEL_318;
                }
                v162 = *(const void **)(v125 + v124 + 24);
LABEL_304:
                memcpy(v148, v162, v147);
                v79 = v129;
                *(_QWORD *)(v129 + 104) += v147;
LABEL_312:
                v164 = *(_DWORD *)(v79 + 144);
                if (v164 > 1)
                  goto LABEL_318;
                v165 = (_BYTE *)*v256;
                if (!*v256)
                {
                  *(_DWORD *)(v79 + 144) = v164 | 0x2C;
                  v146 = 715;
                  goto LABEL_317;
                }
                v166 = *(_QWORD *)(v79 + 104) - (_QWORD)v165 - 2;
                *v165 = BYTE1(v166);
                *(_BYTE *)(*(_QWORD *)(v79 + 120) + 1) = v166;
                *(_QWORD *)(v79 + 120) = 0;
                if (*(_DWORD *)(v79 + 144))
                  goto LABEL_318;
                break;
              default:
                switch(*(_WORD *)(v128 + 8))
                {
                  case 0x18:
                    v141 = global_os_log;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                      goto LABEL_289;
                    *(_DWORD *)buf = 136446210;
                    v261 = "dns_rr_to_wire";
                    v142 = v141;
                    v143 = "%{public}s: signature not valid here!";
                    goto LABEL_288;
                  case 0x19:
                    v149 = global_os_log;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                      goto LABEL_289;
                    *(_DWORD *)buf = 136446210;
                    v261 = "dns_rr_to_wire";
                    v142 = v149;
                    v143 = "%{public}s: key not valid here!";
                    goto LABEL_288;
                  case 0x1C:
                    if (v130 > 1)
                      goto LABEL_312;
                    v150 = *(_OWORD **)(v79 + 104);
                    if ((unint64_t)(v150 + 1) > *(_QWORD *)(v79 + 112))
                    {
                      *(_DWORD *)(v79 + 144) = 111;
                      v146 = 697;
                      goto LABEL_317;
                    }
                    *v150 = *(_OWORD *)(v125 + v124 + 16);
                    v161 = *(_QWORD *)(v79 + 104) + 16;
                    goto LABEL_306;
                  case 0x21:
                    v151 = v125 + v124;
                    if (v130 > 1)
                      goto LABEL_309;
                    v152 = *(_BYTE **)(v79 + 104);
                    if ((unint64_t)(v152 + 2) >= *(_QWORD *)(v79 + 112))
                    {
                      *(_DWORD *)(v79 + 144) = 111;
                      v163 = 686;
                    }
                    else
                    {
                      v153 = *(_WORD *)(v151 + 24);
                      *(_QWORD *)(v79 + 104) = v152 + 1;
                      *v152 = HIBYTE(v153);
                      v154 = *(_BYTE **)(v79 + 104);
                      *(_QWORD *)(v79 + 104) = v154 + 1;
                      *v154 = v153;
                      if (*(_DWORD *)(v79 + 144) > 1u)
                        goto LABEL_309;
                      v155 = *(_BYTE **)(v79 + 104);
                      if ((unint64_t)(v155 + 2) >= *(_QWORD *)(v79 + 112))
                      {
                        *(_DWORD *)(v79 + 144) = 111;
                        v163 = 687;
                      }
                      else
                      {
                        v156 = *(_WORD *)(v125 + v124 + 26);
                        *(_QWORD *)(v79 + 104) = v155 + 1;
                        *v155 = HIBYTE(v156);
                        v157 = *(_BYTE **)(v79 + 104);
                        *(_QWORD *)(v79 + 104) = v157 + 1;
                        *v157 = v156;
                        if (*(_DWORD *)(v79 + 144) > 1u)
                          goto LABEL_309;
                        v158 = *(_BYTE **)(v79 + 104);
                        if ((unint64_t)(v158 + 2) < *(_QWORD *)(v79 + 112))
                        {
                          v159 = *(_WORD *)(v125 + v124 + 28);
                          *(_QWORD *)(v79 + 104) = v158 + 1;
                          *v158 = HIBYTE(v159);
                          v160 = *(_BYTE **)(v79 + 104);
                          *(_QWORD *)(v79 + 104) = v160 + 1;
                          *v160 = v159;
                          goto LABEL_309;
                        }
                        *(_DWORD *)(v79 + 144) = 111;
                        v163 = 688;
                      }
                    }
                    *(_DWORD *)(v79 + 136) = v163;
LABEL_309:
                    v138 = *(uint64_t ***)(v151 + 16);
                    v139 = v115;
                    v140 = 689;
                    break;
                  default:
                    goto LABEL_283;
                }
LABEL_310:
                dns_concatenate_name_to_wire_(v139, v138, 0, 0, v140);
LABEL_311:
                v79 = v129;
                goto LABEL_312;
            }
          }
        }
        v124 += 64;
        ++v123;
        if (v126 != v124)
          continue;
        break;
      }
LABEL_325:
      v258 = 0;
      if (++v116 != 4)
        continue;
      break;
    }
    if ((*(_BYTE *)(v79 + 144) & 1) != 0 && (*(_WORD *)(*(_QWORD *)(*(_QWORD *)(v79 + 8) + 8) + 416) & 0x20) != 0)
    {
      v171 = v79;
      v172 = embiggen(v79);
      v79 = v171;
      if (v172)
      {
        *(_DWORD *)(v171 + 144) = 0;
        continue;
      }
    }
    break;
  }
  *(int8x8_t *)(*(_QWORD *)(v79 + 160) + 4) = vrev16_s8((int8x8_t)vmovn_s32(*v234));
  v75 = v237;
  v2 = a1;
  v6 = v224;
  v74 = &dnssd_client_states;
  v71 = v222;
LABEL_335:
  v173 = *(_WORD **)(v79 + 160);
  v178 = (unsigned __int16)v173[1];
  v9 = v79 + 96;
  v3 = *(_QWORD *)(v79 + 104);
  if ((v178 & 0xF00) != 0)
  {
    v70 = (v178 >> 8) & 0xF;
    goto LABEL_337;
  }
  v173[1] = __rev16(v71 & 0x7ECF | 0x8000);
LABEL_340:
  if (!*(_BYTE *)(v79 + 92))
    goto LABEL_448;
  while (2)
  {
    v180 = *(_DWORD *)(v9 + 48);
    if (v180 > 1)
      goto LABEL_387;
    v181 = *(_BYTE **)(v9 + 8);
    if ((unint64_t)(v181 + 1) >= *(_QWORD *)(v9 + 16))
    {
      v180 = 111;
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2556;
LABEL_387:
      v182 = v237;
      if (v237)
        v199 = 0;
      else
        v199 = v180 > 1;
      if (v199)
        v182 = "Root label";
      goto LABEL_392;
    }
    *(_QWORD *)(v9 + 8) = v181 + 1;
    *v181 = 0;
    v180 = *(_DWORD *)(v9 + 48);
    v182 = v237;
    if (v237)
      v183 = 0;
    else
      v183 = v180 > 1;
    if (v183)
      v182 = "Root label";
    if (v180 > 1)
    {
LABEL_392:
      if (v182)
        v200 = 0;
      else
        v200 = v180 > 1;
      if (v200)
        v182 = "dns_rrtype_opt";
LABEL_397:
      if (v182)
        v201 = 0;
      else
        v201 = v180 > 1;
      if (v201)
        v182 = "UDP Payload size";
LABEL_402:
      if (v182)
        v202 = 0;
      else
        v202 = v180 > 1;
      if (v202)
        v182 = "extended-rcode";
LABEL_407:
      if (v182)
        v203 = 0;
      else
        v203 = v180 > 1;
      if (v203)
        v182 = "EDNS version 0";
LABEL_412:
      if (v182)
        v204 = 0;
      else
        v204 = v180 > 1;
      if (v204)
        v182 = "No extended flags";
      break;
    }
    v184 = *(_BYTE **)(v9 + 8);
    if ((unint64_t)(v184 + 2) >= *(_QWORD *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2557;
      if (!v182)
        v182 = "dns_rrtype_opt";
      goto LABEL_440;
    }
    *(_QWORD *)(v9 + 8) = v184 + 1;
    *v184 = 0;
    v185 = *(_BYTE **)(v9 + 8);
    *(_QWORD *)(v9 + 8) = v185 + 1;
    *v185 = 41;
    v180 = *(_DWORD *)(v9 + 48);
    if (v182)
      v186 = 0;
    else
      v186 = v180 > 1;
    if (v186)
      v182 = "dns_rrtype_opt";
    if (v180 > 1)
      goto LABEL_397;
    v187 = *(_BYTE **)(v9 + 8);
    if ((unint64_t)(v187 + 2) >= *(_QWORD *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2558;
      if (!v182)
        v182 = "UDP Payload size";
      goto LABEL_440;
    }
    *(_QWORD *)(v9 + 8) = v187 + 1;
    *v187 = 16;
    v188 = *(_BYTE **)(v9 + 8);
    *(_QWORD *)(v9 + 8) = v188 + 1;
    *v188 = 0;
    v180 = *(_DWORD *)(v9 + 48);
    if (v182)
      v189 = 0;
    else
      v189 = v180 > 1;
    if (v189)
      v182 = "UDP Payload size";
    if (v180 > 1)
      goto LABEL_402;
    v190 = *(_BYTE **)(v9 + 8);
    if ((unint64_t)(v190 + 1) >= *(_QWORD *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2559;
      if (!v182)
        v182 = "extended-rcode";
      goto LABEL_440;
    }
    *(_QWORD *)(v9 + 8) = v190 + 1;
    *v190 = 0;
    v180 = *(_DWORD *)(v9 + 48);
    if (v182)
      v191 = 0;
    else
      v191 = v180 > 1;
    if (v191)
      v182 = "extended-rcode";
    if (v180 > 1)
      goto LABEL_407;
    v192 = *(_BYTE **)(v9 + 8);
    if ((unint64_t)(v192 + 1) >= *(_QWORD *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2560;
      if (!v182)
        v182 = "EDNS version 0";
      goto LABEL_440;
    }
    *(_QWORD *)(v9 + 8) = v192 + 1;
    *v192 = 0;
    v180 = *(_DWORD *)(v9 + 48);
    if (v182)
      v193 = 0;
    else
      v193 = v180 > 1;
    if (v193)
      v182 = "EDNS version 0";
    if (v180 > 1)
      goto LABEL_412;
    v194 = *(_BYTE **)(v9 + 8);
    if ((unint64_t)(v194 + 2) >= *(_QWORD *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2561;
      if (!v182)
        v182 = "No extended flags";
      goto LABEL_440;
    }
    *(_QWORD *)(v9 + 8) = v194 + 1;
    *v194 = 0;
    v195 = *(_BYTE **)(v9 + 8);
    *(_QWORD *)(v9 + 8) = v195 + 1;
    *v195 = 0;
    v180 = *(_DWORD *)(v9 + 48);
    if (v182)
      v196 = 0;
    else
      v196 = v180 > 1;
    if (v196)
      v182 = "No extended flags";
    if (v180 <= 1)
    {
      v197 = *(_BYTE **)(v9 + 8);
      if ((unint64_t)(v197 + 2) < *(_QWORD *)(v9 + 16))
      {
        *(_QWORD *)(v9 + 8) = v197 + 1;
        *v197 = 0;
        v198 = *(_BYTE **)(v9 + 8);
        *(_QWORD *)(v9 + 8) = v198 + 1;
        *v198 = 0;
        v180 = *(_DWORD *)(v9 + 48);
        break;
      }
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2562;
LABEL_440:
      if (v182)
        v207 = v182;
      else
        v207 = "No payload";
      v237 = v207;
LABEL_423:
      *(_QWORD *)(v79 + 104) = v3;
      if ((*(_WORD *)(*(_QWORD *)(*(_QWORD *)(v79 + 8) + 8) + 416) & 0x20) == 0)
        goto LABEL_447;
      v206 = v79;
      if (!embiggen(v79))
      {
        v75 = v237;
        v2 = a1;
        v74 = &dnssd_client_states;
        v79 = v206;
        goto LABEL_448;
      }
      *(_DWORD *)(v206 + 144) = 0;
      v79 = v206;
      continue;
    }
    break;
  }
  if (v182)
    v205 = 0;
  else
    v205 = v180 > 1;
  if (v205)
    v182 = "No payload";
  v237 = v182;
  if ((v180 & 1) != 0)
    goto LABEL_423;
  *(_WORD *)(*(_QWORD *)(v79 + 160) + 10) = 256;
LABEL_447:
  v75 = v237;
  v2 = a1;
  v74 = &dnssd_client_states;
LABEL_448:
  if (*(_DWORD *)(v9 + 48) < 2u)
  {
    v173 = *(_WORD **)(v79 + 160);
    v179 = v173[1] & 0xF0FF;
    goto LABEL_459;
  }
  v208 = v79;
  v209 = *((_QWORD *)v74 + 306);
  if (os_log_type_enabled(v209, OS_LOG_TYPE_ERROR))
  {
    if (v2)
    {
      v210 = *(_DWORD *)(v2 + 4);
      if (v6)
        goto LABEL_453;
LABEL_455:
      v211 = 0;
    }
    else
    {
      v210 = 0;
      if (!v6)
        goto LABEL_455;
LABEL_453:
      v211 = *(_DWORD *)(v6 + 64);
    }
    v212 = bswap32(*(unsigned __int16 *)(*(_QWORD *)(v208 + 64) + 88));
    *(_DWORD *)buf = 136447234;
    v261 = "dp_query_send_dns_response";
    v262 = 1024;
    *(_DWORD *)v263 = v210;
    *(_WORD *)&v263[4] = 1024;
    *(_DWORD *)&v263[6] = v211;
    LOWORD(v264) = 1024;
    *(_DWORD *)((char *)&v264 + 2) = HIWORD(v212);
    WORD3(v264) = 2080;
    *((_QWORD *)&v264 + 1) = v75;
    _os_log_impl((void *)&_mh_execute_header, v209, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d][QID%x] failed on %s", buf, 0x28u);
  }
  v79 = v208;
  v173 = *(_WORD **)(v208 + 160);
  v179 = v173[1] & 0xF0FF;
  if (v225 != 512)
    v179 |= 0x200u;
LABEL_459:
  v173[1] = v179;
  v213 = v79;
  v214 = *(_QWORD *)(v79 + 104) - (_QWORD)v173;
  v259.iov_base = v173;
  v259.iov_len = v214;
  v215 = *((_QWORD *)v74 + 306);
  if (os_log_type_enabled(v215, OS_LOG_TYPE_DEFAULT))
  {
    if (v2)
    {
      v216 = *(_DWORD *)(v2 + 4);
      if (v6)
        goto LABEL_462;
LABEL_464:
      v217 = 0;
    }
    else
    {
      v216 = 0;
      if (!v6)
        goto LABEL_464;
LABEL_462:
      v217 = *(_DWORD *)(v6 + 64);
    }
    *(_DWORD *)buf = 136446978;
    v261 = "dp_query_send_dns_response";
    v262 = 1024;
    *(_DWORD *)v263 = v216;
    *(_WORD *)&v263[4] = 1024;
    *(_DWORD *)&v263[6] = v217;
    LOWORD(v264) = 2048;
    *(_QWORD *)((char *)&v264 + 2) = v214;
    _os_log_impl((void *)&_mh_execute_header, v215, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] (len %zd)", buf, 0x22u);
  }
  ioloop_send_message(*(_QWORD *)(*(_QWORD *)(v213 + 8) + 8), *(_QWORD *)(v213 + 64), &v259);
  dnssd_query_cancel(v213);
}

void served_domain_free(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  int v11;
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v3 = *(_QWORD *)(a1 + 8);
    v11 = 136446723;
    v12 = "served_domain_free";
    v13 = 2160;
    v14 = 1752392040;
    v15 = 2081;
    v16 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: served domain removed - domain name: %{private, mask.hash}s", (uint8_t *)&v11, 0x20u);
  }
  v4 = *(_QWORD *)(a1 + 40);
  if (v4)
  {
    v5 = *(_QWORD **)(v4 + 16);
    if (v5)
    {
      do
      {
        v6 = (_QWORD *)*v5;
        free(v5);
        v5 = v6;
      }
      while (v6);
      v4 = *(_QWORD *)(a1 + 40);
    }
    if (*(_QWORD *)(v4 + 8))
    {
      free(*(void **)(v4 + 8));
      v4 = *(_QWORD *)(a1 + 40);
    }
    free((void *)v4);
  }
  v7 = *(_QWORD **)(a1 + 32);
  if (v7)
  {
    do
    {
      v8 = (_QWORD *)*v7;
      free(v7);
      v7 = v8;
    }
    while (v8);
  }
  v9 = *(_QWORD **)(a1 + 24);
  if (v9)
  {
    do
    {
      v10 = (_QWORD *)*v9;
      free(v9);
      v9 = v10;
    }
    while (v10);
  }
  free(*(void **)(a1 + 16));
  free((void *)a1);
}

void dns_question_callback(int a1, char a2, int a3, int a4, uint8_t *__s2, unsigned int a6, int a7, size_t __n, int32x4_t *a9, int a10, uint64_t a11)
{
  uint64_t v17;
  char v18;
  NSObject *v19;
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  int *v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  const char *v31;
  NSObject *v32;
  const char *v33;
  const char *v34;
  const char *v35;
  _QWORD *v37;
  NSObject *v38;
  const char *v39;
  const char *v40;
  const char *v41;
  _QWORD *v42;
  _QWORD *v43;
  char *v44;
  uint64_t *v45;
  NSObject *v46;
  int v47;
  const char *v48;
  const char *v49;
  const char *v50;
  uint64_t v51;
  int v52;
  NSObject *v53;
  int v54;
  const char *v55;
  const char *v56;
  const char *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  NSObject *v61;
  int v62;
  const char *v63;
  NSObject *v64;
  size_t __na;
  NSObject *__nb;
  uint8_t buf[4];
  const char *v68;
  __int16 v69;
  int v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  uint8_t *v74;
  __int16 v75;
  const char *v76;
  __int16 v77;
  const char *v78;
  __int16 v79;
  int v80;
  __int16 v81;
  size_t v82;

  v17 = a11;
  v18 = 1;
  if (a4 <= -65555)
  {
    if (a4 == -65569 || a4 == -65563)
    {
      ioloop_dnssd_txn_cancel(*(_QWORD *)(a11 + 24));
      ioloop_dnssd_txn_release_(*(int **)(a11 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 3048);
      *(_QWORD *)(a11 + 24) = 0;
      v19 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v68 = "dp_handle_server_disconnect";
        v69 = 1024;
        v70 = a4;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: status %d", buf, 0x12u);
      }
      v20 = (_QWORD *)questions_without_domain;
      if (questions_without_domain)
      {
        while ((dp_void_question((uint64_t)v20) & 1) == 0)
        {
          v20 = (_QWORD *)*v20;
          if (!v20)
            goto LABEL_9;
        }
      }
      else
      {
LABEL_9:
        v21 = (_QWORD *)served_domains;
        if (served_domains)
        {
          while (1)
          {
            v22 = (_QWORD *)v21[6];
            if (v22)
              break;
LABEL_13:
            v21 = (_QWORD *)*v21;
            if (!v21)
              goto LABEL_14;
          }
          while ((dp_void_question((uint64_t)v22) & 1) == 0)
          {
            v22 = (_QWORD *)*v22;
            if (!v22)
              goto LABEL_13;
          }
        }
      }
LABEL_14:
      v23 = (int *)discovery_restart_wakeup;
      if (discovery_restart_wakeup
        || (v23 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 617), (discovery_restart_wakeup = (uint64_t)v23) != 0))
      {
        ioloop_add_wake_event((uint64_t)v23, 0, (uint64_t)dp_restart_all_questions, 0, 0x3E8u);
      }
      return;
    }
LABEL_75:
    v58 = v17;
    v59 = *(_QWORD *)(v17 + 16);
    if (v59)
    {
      do
      {
        v60 = *(_QWORD *)(v59 + 184);
        if (*(_QWORD *)(v59 + 72))
          dns_push_query_answer_process(a2, a4, __s2, a6, a7, __n, a9, a10, v59, v18);
        else
          dns_query_answer_process(a2, a4, __s2, a6, a7, __n, a9, a10, v59, v18);
        v59 = v60;
      }
      while (v60);
    }
    dp_question_cache_remove_queries(v58);
    return;
  }
  if (a4 == -65554)
  {
    v32 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      if (a11)
        LODWORD(v17) = *(_DWORD *)(a11 + 64);
      v33 = dns_rrtype_to_string(a6);
      v34 = dns_qclass_to_string(a7);
      *(_DWORD *)buf = 136448003;
      v35 = " more coming";
      v68 = "dns_question_callback";
      v70 = v17;
      v71 = 2160;
      v69 = 1024;
      if ((a2 & 1) == 0)
        v35 = " done";
      v72 = 1752392040;
      v73 = 2081;
      v74 = __s2;
      v75 = 2082;
      v76 = v33;
      v77 = 2082;
      v78 = v34;
      v79 = 1024;
      v80 = __n;
      v81 = 2082;
      v82 = (size_t)v35;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] no data - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      v17 = a11;
    }
    v18 = 1;
LABEL_74:
    *(_BYTE *)(v17 + 76) = 1;
    goto LABEL_75;
  }
  if (a4)
    goto LABEL_75;
  v24 = (uint64_t *)(a11 + 40);
  if ((a2 & 2) == 0)
  {
    v25 = *v24;
    if (*v24)
    {
      v26 = 0;
      v27 = " more coming";
      if ((a2 & 1) == 0)
        v27 = " done";
      __na = (size_t)v27;
      do
      {
        while (1)
        {
          v28 = v25;
          if (!answer_match(v25, __n, (char *)__s2, a6, a7, a9))
            break;
          v29 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v64 = v29;
            v30 = *(_DWORD *)(a11 + 64);
            v63 = dns_rrtype_to_string(a6);
            v31 = dns_qclass_to_string(a7);
            *(_DWORD *)buf = 136448003;
            v68 = "dns_question_callback";
            v69 = 1024;
            v70 = v30;
            v71 = 2160;
            v72 = 1752392040;
            v73 = 2081;
            v74 = __s2;
            v75 = 2082;
            v76 = v63;
            v77 = 2082;
            v78 = v31;
            v79 = 1024;
            v80 = __n;
            v81 = 2082;
            v82 = __na;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] remove answer from cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
          }
          *v24 = *(_QWORD *)v28;
          free(*(void **)(v28 + 8));
          free((void *)v28);
          if ((_DWORD)__n)
          {
            v28 = (uint64_t)v24;
            goto LABEL_70;
          }
          v25 = *v24;
          v26 = 1;
          if (!*v24)
            goto LABEL_73;
        }
        v25 = *(_QWORD *)v28;
        v24 = (uint64_t *)v28;
      }
      while (*(_QWORD *)v28);
      if ((v26 & 1) == 0)
        goto LABEL_60;
    }
    else
    {
      v28 = a11 + 40;
LABEL_60:
      v51 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        __nb = v51;
        if (a11)
          v52 = *(_DWORD *)(a11 + 64);
        else
          v52 = 0;
        v55 = dns_rrtype_to_string(a6);
        v56 = dns_qclass_to_string(a7);
        *(_DWORD *)buf = 136448003;
        v57 = " more coming";
        v68 = "dns_question_callback";
        v70 = v52;
        v71 = 2160;
        v69 = 1024;
        if ((a2 & 1) == 0)
          v57 = " done";
        v72 = 1752392040;
        v73 = 2081;
        v74 = __s2;
        v75 = 2082;
        v76 = v55;
        v77 = 2082;
        v78 = v56;
        v79 = 1024;
        v80 = __n;
        v81 = 2082;
        v82 = (size_t)v57;
        _os_log_impl((void *)&_mh_execute_header, __nb, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] remove not found in cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      }
LABEL_70:
      if (*(_QWORD *)v28)
      {
        v18 = 1;
LABEL_72:
        v17 = a11;
        goto LABEL_75;
      }
    }
LABEL_73:
    v18 = 1;
    v17 = a11;
    goto LABEL_74;
  }
  v37 = (_QWORD *)(a11 + 40);
  while (1)
  {
    v37 = (_QWORD *)*v37;
    if (!v37)
      break;
    if (answer_match((uint64_t)v37, __n, (char *)__s2, a6, a7, a9))
    {
      v38 = global_os_log;
      v18 = 0;
      v17 = a11;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_75;
      if (a11)
        LODWORD(v17) = *(_DWORD *)(a11 + 64);
      v39 = dns_rrtype_to_string(a6);
      v40 = dns_qclass_to_string(a7);
      *(_DWORD *)buf = 136448003;
      v41 = " more coming";
      v68 = "dns_question_callback";
      v70 = v17;
      v71 = 2160;
      v69 = 1024;
      if ((a2 & 1) == 0)
        v41 = " done";
      v72 = 1752392040;
      v73 = 2081;
      v74 = __s2;
      v75 = 2082;
      v76 = v39;
      v77 = 2082;
      v78 = v40;
      v79 = 1024;
      v80 = __n;
      v81 = 2082;
      v82 = (size_t)v41;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] duplicate answer in cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      v18 = 0;
      goto LABEL_72;
    }
  }
  v42 = malloc_type_calloc(1uLL, __n + 40, 0x6EC9939CuLL);
  if (v42)
  {
    v43 = v42;
    v44 = strdup((const char *)__s2);
    v43[1] = v44;
    if (v44)
    {
      *((_DWORD *)v43 + 6) = a3;
      *((_DWORD *)v43 + 7) = a10;
      *((_WORD *)v43 + 16) = a6;
      *((_WORD *)v43 + 17) = a7;
      *((_WORD *)v43 + 18) = __n;
      v43[2] = v43 + 5;
      memcpy(v43 + 5, a9, __n);
      *v43 = 0;
      do
      {
        v45 = v24;
        v24 = (uint64_t *)*v24;
      }
      while (v24);
      *v45 = (uint64_t)v43;
      v17 = a11;
      *(_BYTE *)(a11 + 76) = 0;
      v46 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v47 = *(_DWORD *)(a11 + 64);
        v48 = dns_rrtype_to_string(a6);
        v49 = dns_qclass_to_string(a7);
        *(_DWORD *)buf = 136448003;
        v50 = " more coming";
        v68 = "dns_question_callback";
        v70 = v47;
        v17 = a11;
        v71 = 2160;
        v69 = 1024;
        if ((a2 & 1) == 0)
          v50 = " done";
        v72 = 1752392040;
        v73 = 2081;
        v74 = __s2;
        v75 = 2082;
        v76 = v48;
        v77 = 2082;
        v78 = v49;
        v79 = 1024;
        v80 = __n;
        v81 = 2082;
        v82 = (size_t)v50;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] add answer to cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      }
      v18 = 1;
      goto LABEL_75;
    }
    v61 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v62 = a11;
      if (a11)
        v62 = *(_DWORD *)(a11 + 64);
      *(_DWORD *)buf = 136446979;
      v68 = "dns_question_callback";
      v69 = 1024;
      v70 = v62;
      v71 = 2160;
      v72 = 1752392040;
      v73 = 2081;
      v74 = __s2;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%{public}s: [QU%d] strdup failed to copy the answer name: %{private, mask.hash}s", buf, 0x26u);
    }
    free(v43);
  }
  else
  {
    v53 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      if (a11)
        v54 = *(_DWORD *)(a11 + 64);
      else
        v54 = 0;
      *(_DWORD *)buf = 136447747;
      v68 = "dns_question_callback";
      v69 = 1024;
      v70 = v54;
      v71 = 2160;
      v72 = 1752392040;
      v73 = 2081;
      v74 = __s2;
      v75 = 2082;
      v76 = dns_rrtype_to_string(a6);
      v77 = 2082;
      v78 = dns_qclass_to_string(a7);
      v79 = 1024;
      v80 = __n;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "%{public}s: [QU%d] unable to allocate memory for answer - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.", buf, 0x40u);
    }
  }
}

uint64_t dp_start_question(uint64_t a1)
{
  _QWORD *v2;
  char *v3;
  size_t v4;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  const char *v9;
  NSObject *v10;
  uint32_t v11;
  const char *v12;
  size_t v13;
  signed int v14;
  NSObject *v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;
  BOOL v20;
  int v21;
  BOOL v22;
  int should_save_stacktrace;
  uint64_t v24;
  int v25;
  const char *v26;
  size_t v27;
  int8x16_t *v28;
  _BYTE *v29;
  size_t v30;
  _BYTE *v31;
  _BYTE *v32;
  uint64_t v33;
  BOOL v34;
  DNSServiceRef v35;
  void *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  int v40;
  _DNSServiceRef_t *v41;
  NSObject *v43;
  _BOOL4 v44;
  DNSServiceRef v45;
  int v46;
  uint64_t v47;
  NSObject *v48;
  int v49;
  int v50;
  int v51;
  NSObject *v52;
  int v53;
  size_t v54;
  DNSServiceRef sdRef;
  size_t v56;
  _BYTE buf[12];
  __int16 v58;
  int v59;
  __int16 v60;
  uint64_t v61;
  __int16 v62;
  DNSServiceRef v63;
  __int16 v64;
  char *v65;
  __int16 v66;
  int v67;
  _BYTE v68[256];

  sdRef = 0;
  v2 = *(_QWORD **)(a1 + 8);
  v3 = *(char **)(a1 + 32);
  if (v2)
  {
    v4 = strlen(*(const char **)(a1 + 32));
    v5 = v4;
    if (v2[5])
    {
      if (v4 - 249 <= 0xFFFFFFFFFFFFFEFELL)
      {
        v6 = 4294901756;
        v7 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v8 = *(_DWORD *)(a1 + 64);
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "dp_start_question";
          v58 = 1024;
          v59 = v8;
          v60 = 2080;
          v61 = (uint64_t)v68;
          v9 = "%{public}s: [QU%d] question name %s is too long for .local.";
          v10 = v7;
          v11 = 28;
LABEL_59:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
          return v6;
        }
        return v6;
      }
      __memcpy_chk(v68, v3, v4, 256);
      *(_QWORD *)&v68[v5] = 0x2E6C61636F6C2ELL;
    }
    else
    {
      v12 = (const char *)v2[2];
      v13 = strlen(v12) + 1;
      if (v13 + v5 >= 0x101)
      {
        v6 = 4294901756;
        v39 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v40 = *(_DWORD *)(a1 + 64);
          v41 = (_DNSServiceRef_t *)v2[1];
          *(_DWORD *)buf = 136446978;
          *(_QWORD *)&buf[4] = "dp_start_question";
          v58 = 1024;
          v59 = v40;
          v60 = 2080;
          v61 = (uint64_t)v68;
          v62 = 2080;
          v63 = v41;
          v9 = "%{public}s: [QU%d] question name %s is too long for %s.";
          v10 = v39;
          v11 = 38;
          goto LABEL_59;
        }
        return v6;
      }
      __memcpy_chk(v68, v3, v5, 256);
      memcpy(&v68[v5], v12, v13);
    }
    v3 = v68;
  }
  v14 = *(_DWORD *)(a1 + 68);
  if (v14 == -5)
  {
    v14 = dp_start_question_en0_ifindex;
    if (!dp_start_question_en0_ifindex)
    {
      v14 = if_nametoindex("en0");
      dp_start_question_en0_ifindex = v14;
      if (!v14)
      {
        v15 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          return 4294901743;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "dp_start_question";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s: getting en0 ifindex failed!", buf, 0xCu);
        v14 = dp_start_question_en0_ifindex;
      }
    }
    if (v14 >= 1)
      goto LABEL_16;
    return 4294901743;
  }
LABEL_16:
  v16 = *(_DWORD *)(a1 + 56);
  v17 = *(unsigned __int16 *)(a1 + 72);
  v18 = *(unsigned __int16 *)(a1 + 74);
  if (!&_ne_tracker_check_is_hostname_blocked
    || (v17 != 1 ? (v19 = v17 == 28) : (v19 = 1),
        !v19 ? (v20 = v17 == 255) : (v20 = 1),
        !v20 ? (v21 = 0) : (v21 = 1),
        v18 == 1 ? (v22 = v21 == 0) : (v22 = 1),
        v22))
  {
    should_save_stacktrace = 0;
  }
  else
  {
    v38 = ne_tracker_check_is_hostname_blocked(v3, 0);
    if (v38 == 1)
    {
      v6 = 4294901726;
      goto LABEL_33;
    }
    should_save_stacktrace = ne_tracker_should_save_stacktrace();
  }
  v6 = ConnectToServer((uint64_t *)&sdRef, v16, 8, (uint64_t)handle_query_response, (uint64_t)dns_question_callback, a1);
  if ((_DWORD)v6)
    goto LABEL_33;
  if (v3)
    v26 = v3;
  else
    v26 = (const char *)&unk_10007C721;
  v27 = strlen(v26);
  v56 = v27 + 13;
  os_unfair_lock_lock(&g_defaults_lock);
  os_unfair_lock_unlock(&g_defaults_lock);
  if (should_save_stacktrace)
    v56 = v27 + 18;
  *(_QWORD *)buf = 0;
  v28 = (int8x16_t *)create_hdr(8, &v56, buf, *((_QWORD *)sdRef + 1) != 0, (uint64_t)sdRef);
  v29 = *(_BYTE **)buf;
  v54 = v56;
  **(_BYTE **)buf = HIBYTE(v16);
  v29[1] = BYTE2(v16);
  v29[2] = BYTE1(v16);
  v29[3] = v16;
  v29[4] = HIBYTE(v14);
  v29[5] = BYTE2(v14);
  v29[6] = BYTE1(v14);
  v29[7] = v14;
  v30 = strlen(v26) + 1;
  memcpy(v29 + 8, v26, v30);
  v31 = &v29[v30 + 8];
  *v31 = BYTE1(v17);
  v31[1] = v17;
  v31[2] = BYTE1(v18);
  v32 = v31 + 4;
  v31[3] = v18;
  *(_QWORD *)buf = v31 + 4;
  if (should_save_stacktrace)
  {
    if (v31 != (_BYTE *)-4 && &v29[v54] >= v32 && (unint64_t)(&v29[v54] - v32) >= 5)
    {
      *((_DWORD *)v31 + 1) = 16779264;
      v31[8] = 1;
      v32 = v31 + 9;
    }
    *(_QWORD *)buf = v32;
    v28->i32[2] |= 2u;
  }
  v33 = deliver_request(v28, (uint64_t)sdRef);
  v6 = v33;
  if ((_DWORD)v33)
    v34 = 1;
  else
    v34 = &_ne_tracker_check_is_hostname_blocked == 0;
  if (!v34 && ((should_save_stacktrace ^ 1) & 1) == 0)
  {
    v35 = sdRef;
    v36 = (void *)*((_QWORD *)sdRef + 15);
    if (v36)
    {
      free(v36);
      v35 = sdRef;
      *((_QWORD *)sdRef + 15) = 0;
    }
    v37 = ne_tracker_copy_current_stacktrace((char *)v35 + 128);
    *((_QWORD *)sdRef + 15) = v37;
LABEL_67:
    v43 = global_os_log;
    v44 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    v45 = sdRef;
    if (v44)
    {
      v46 = *(_DWORD *)(a1 + 64);
      v47 = *(_QWORD *)(a1 + 24);
      *(_DWORD *)buf = 136446978;
      *(_QWORD *)&buf[4] = "dp_start_question";
      v58 = 1024;
      v59 = v46;
      v60 = 2048;
      v61 = v47;
      v62 = 2048;
      v63 = sdRef;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] txn %p new sdref %p", buf, 0x26u);
      v45 = sdRef;
    }
    *(_QWORD *)(a1 + 24) = ioloop_dnssd_txn_add_((uint64_t)v45, a1, (uint64_t)dp_question_context_release, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 515);
    v48 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v49 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "dp_start_question";
      v58 = 1024;
      v59 = v49;
      v60 = 2048;
      v61 = a1;
      v62 = 2080;
      v63 = (DNSServiceRef)"question";
      v64 = 2080;
      v65 = "dnssd-proxy.c";
      v66 = 1024;
      v67 = 517;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v50 = *(_DWORD *)(a1 + 60);
    if (v50)
    {
      v51 = v50 + 1;
      *(_DWORD *)(a1 + 60) = v50 + 1;
      v52 = global_os_log;
      if (v50 + 1 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "dp_start_question";
          v58 = 1024;
          v59 = v51;
          v60 = 2048;
          v61 = a1;
          v62 = 2080;
          v63 = (DNSServiceRef)"question";
          v64 = 2080;
          v65 = "dnssd-proxy.c";
          v66 = 1024;
          v67 = 517;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++question_created;
      *(_DWORD *)(a1 + 60) = 1;
      v52 = global_os_log;
    }
    v6 = 0;
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      v53 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)buf = 136447235;
      *(_QWORD *)&buf[4] = "dp_start_question";
      v58 = 1024;
      v59 = v53;
      v60 = 2160;
      v61 = 1752392040;
      v62 = 2081;
      v63 = (DNSServiceRef)v3;
      v64 = 1024;
      LODWORD(v65) = 0;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] DNSServiceQueryRecord started for '%{private, mask.hash}s': %d", buf, 0x2Cu);
      return 0;
    }
    return v6;
  }
  if (!(_DWORD)v33)
    goto LABEL_67;
  if ((_DWORD)v33 == -65555)
  {
    if (_should_return_noauth_error_s_once != -1)
      dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
    if (!_should_return_noauth_error_s_should)
      goto LABEL_67;
  }
  DNSServiceRefDeallocate(sdRef);
  sdRef = 0;
LABEL_33:
  v24 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v25 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "dp_start_question";
    v58 = 1024;
    v59 = v25;
    v60 = 2080;
    v61 = (uint64_t)v3;
    v62 = 1024;
    LODWORD(v63) = v6;
    v9 = "%{public}s: [QU%d] DNSServiceQueryRecord failed for '%s': %d";
    v10 = v24;
    v11 = 34;
    goto LABEL_59;
  }
  return v6;
}

void dp_query_wakeup(uint64_t a1)
{
  uint64_t v2;
  const char *v3;
  size_t v4;
  NSObject *v5;
  int v6;
  int v7;
  uint64_t v8;
  size_t v9;
  NSObject *v10;
  int v11;
  int v12;
  NSObject *v13;
  int v14;
  int v15;
  int v16;
  NSObject *v17;
  const char *v18;
  int v19;
  NSObject *v20;
  int v21;
  const char *v22;
  __int16 v23;
  _BYTE v24[34];
  __int16 v25;
  int v26;
  uint8_t buf[4];
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  int v32;
  __int16 v33;
  uint64_t v34;
  __int16 v35;
  const char *v36;

  v2 = *(_QWORD *)(a1 + 192);
  v3 = *(const char **)(v2 + 32);
  v4 = strlen(v3);
  if (*(_QWORD *)(v2 + 40))
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      v6 = *(_DWORD *)(a1 + 4);
      v7 = *(_DWORD *)(v2 + 64);
      *(_DWORD *)buf = 136447235;
      v28 = "dp_query_wakeup";
      v29 = 1024;
      v30 = v6;
      v31 = 1024;
      v32 = v7;
      v33 = 2160;
      v34 = 1752392040;
      v35 = 2081;
      v36 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "%{public}s: [Q%d][QU%d] answers present, but dp_query_wakeup reached for name %{private, mask.hash}s", buf, 0x2Cu);
    }
  }
  else
  {
    *(_BYTE *)(v2 + 76) = 1;
  }
  v8 = *(_QWORD *)(v2 + 8);
  if (v8)
  {
    if (*(_QWORD *)(v8 + 40))
      v9 = 8;
    else
      v9 = strlen(*(const char **)(v8 + 16)) + 1;
  }
  else
  {
    v9 = 0;
  }
  if (v9 + v4 >= 0x101)
  {
    v10 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v11 = *(_DWORD *)(a1 + 4);
      v12 = *(_DWORD *)(v2 + 64);
      *(_DWORD *)buf = 136446722;
      v28 = "dp_query_wakeup";
      v29 = 1024;
      v30 = v11;
      v31 = 1024;
      v32 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d] no space to construct name.", buf, 0x18u);
    }
    dnssd_query_cancel(a1);
    return;
  }
  __memcpy_chk(buf, *(_QWORD *)(v2 + 32), v4 + 1, 256);
  if (v8)
    *(_QWORD *)&buf[v4] = 0x2E6C61636F6C2ELL;
  v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(_DWORD *)a1;
    v21 = 136447490;
    v22 = "dp_query_wakeup";
    v23 = 1024;
    *(_DWORD *)v24 = v14;
    *(_WORD *)&v24[4] = 2048;
    *(_QWORD *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(_QWORD *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(_QWORD *)&v24[26] = "dnssd-proxy.c";
    v25 = 1024;
    v26 = 3100;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
  }
  v15 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    v16 = v15 + 1;
    *(_DWORD *)a1 = v15 + 1;
    if (v15 + 1 >= 10001)
    {
      v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_37;
      v21 = 136447490;
      v22 = "dp_query_wakeup";
      v23 = 1024;
      *(_DWORD *)v24 = v16;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "query";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "dnssd-proxy.c";
      v25 = 1024;
      v26 = 3100;
      v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_36;
    }
  }
  else
  {
    ++dnssd_query_created;
    *(_DWORD *)a1 = 1;
  }
  dp_query_send_dns_response(a1, (uint64_t)"query wakeup");
  dp_question_cache_remove_queries(v2);
  v19 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_37;
    v21 = 136447490;
    v22 = "dp_query_wakeup";
    v23 = 1024;
    *(_DWORD *)v24 = 0;
    *(_WORD *)&v24[4] = 2048;
    *(_QWORD *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(_QWORD *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(_QWORD *)&v24[26] = "dnssd-proxy.c";
    v25 = 1024;
    v26 = 3103;
    v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_36;
  }
  v17 = global_os_log;
  if (v19 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_37;
    v21 = 136447490;
    v22 = "dp_query_wakeup";
    v23 = 1024;
    *(_DWORD *)v24 = v19;
    *(_WORD *)&v24[4] = 2048;
    *(_QWORD *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(_QWORD *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(_QWORD *)&v24[26] = "dnssd-proxy.c";
    v25 = 1024;
    v26 = 3103;
    v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_36:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v21, 0x36u);
LABEL_37:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v21 = 136447490;
    v22 = "dp_query_wakeup";
    v23 = 1024;
    *(_DWORD *)v24 = v19;
    *(_WORD *)&v24[4] = 2048;
    *(_QWORD *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(_QWORD *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(_QWORD *)&v24[26] = "dnssd-proxy.c";
    v25 = 1024;
    v26 = 3103;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
    v19 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v19 - 1;
  if (v19 == 1)
  {
    v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 136447234;
      v22 = "dp_query_wakeup";
      v23 = 2048;
      *(_QWORD *)v24 = a1;
      *(_WORD *)&v24[8] = 2080;
      *(_QWORD *)&v24[10] = "query";
      *(_WORD *)&v24[18] = 2080;
      *(_QWORD *)&v24[20] = "dnssd-proxy.c";
      *(_WORD *)&v24[28] = 1024;
      *(_DWORD *)&v24[30] = 3103;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize((_QWORD *)a1);
  }
}

void dp_query_context_release(_QWORD *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dp_query_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "query";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 3243;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dp_query_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "query";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 3243;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "dp_query_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "query";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 3243;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "dp_query_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "query";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "dnssd-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 3243;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize(a1);
  }
}

void dp_question_context_release(uint64_t a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *(_DWORD *)(a1 + 60);
  if (!v2)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dp_question_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "question";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 423;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dp_question_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "question";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 423;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "dp_question_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "question";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 423;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *(_DWORD *)(a1 + 60);
  }
  *(_DWORD *)(a1 + 60) = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "dp_question_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "question";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "dnssd-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 423;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++question_finalized;
    question_finalize(a1);
  }
}

uint64_t dp_void_question(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
  {
    v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_DWORD *)(a1 + 64);
      v8 = 136446722;
      v9 = "dp_void_question";
      v10 = 1024;
      v11 = v4;
      v12 = 2048;
      v13 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] question->txn = %p", (uint8_t *)&v8, 0x1Cu);
      v2 = *(_QWORD *)(a1 + 24);
    }
    ioloop_dnssd_txn_cancel(v2);
    ioloop_dnssd_txn_release_(*(int **)(a1 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 585);
    *(_QWORD *)(a1 + 24) = 0;
  }
  if (*(_QWORD *)(a1 + 40))
  {
    v5 = *(_QWORD *)(a1 + 16);
    if (v5)
    {
      do
      {
        v6 = *(_QWORD *)(v5 + 184);
        if (*(_QWORD *)(v5 + 72))
          dp_query_reply_from_cache(a1, v5, 1);
        v5 = v6;
      }
      while (v6);
    }
    dp_question_answers_free(a1);
  }
  return 0;
}

uint64_t dp_restart_all_questions()
{
  _QWORD *v0;
  uint64_t result;
  _QWORD *v2;
  _QWORD *i;

  v0 = (_QWORD *)questions_without_domain;
  if (questions_without_domain)
  {
    do
    {
      if (!v0[3])
        result = dp_start_question(v0);
      v0 = (_QWORD *)*v0;
    }
    while (v0);
  }
  v2 = (_QWORD *)served_domains;
  if (served_domains)
  {
    do
    {
      for (i = (_QWORD *)v2[6]; i; i = (_QWORD *)*i)
      {
        if (!i[3])
          result = dp_start_question(i);
      }
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  return result;
}

BOOL answer_match(uint64_t a1, size_t __n, char *__s2, int a4, int a5, void *a6)
{
  return (a5 == 255 || *(unsigned __int16 *)(a1 + 34) == a5)
      && (a4 == 255 || *(unsigned __int16 *)(a1 + 32) == a4)
      && (!(_DWORD)__n
       || *(unsigned __int16 *)(a1 + 36) == (_DWORD)__n && !memcmp(*(const void **)(a1 + 16), a6, __n))
      && strcmp(*(const char **)(a1 + 8), __s2) == 0;
}

void dp_tracker_idle(uint64_t a1)
{
  uint64_t v1;
  NSObject *v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  uint64_t v19;

  v1 = *(_QWORD *)(a1 + 8);
  if (v1)
  {
    v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v4 = *(_DWORD *)(a1 + 4);
      v5 = *(_QWORD *)(a1 + 24);
      if (v5)
        LODWORD(v5) = *(_DWORD *)(v5 + 48);
      v6 = *(_DWORD *)(v1 + 180);
      v7 = *(_QWORD *)(v1 + 192);
      v8 = 136447491;
      v9 = "dp_tracker_idle";
      v10 = 1024;
      v11 = v4;
      v12 = 1024;
      v13 = v5;
      v14 = 1024;
      v15 = v6;
      v16 = 2160;
      v17 = 1752392040;
      v18 = 2081;
      v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][DSO%d][C%d] tracker for connection %{private, mask.hash}s has gone idle.", (uint8_t *)&v8, 0x32u);
    }
    *(_QWORD *)(a1 + 8) = 0;
    if ((*(_WORD *)(v1 + 416) & 0x100) == 0)
      ioloop_comm_cancel(v1);
    ioloop_comm_release_(v1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 866);
  }
}

void dp_tracker_context_release(_QWORD *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dp_tracker_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "tracker";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 831;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "dp_tracker_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "tracker";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 831;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "dp_tracker_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "tracker";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "dnssd-proxy.c";
    v10 = 1024;
    v11 = 831;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "dp_tracker_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "tracker";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "dnssd-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 831;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++dp_tracker_finalized;
    dp_tracker_finalize(a1);
  }
}

void dns_proxy_input_for_server(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  int v6;
  BOOL v7;
  const void *v8;
  char *v9;
  uint64_t v10;
  NSObject **v11;
  NSObject *v12;
  int v13;
  int v14;
  unsigned int v15;
  int v16;
  NSObject *v17;
  _BOOL4 v18;
  int v19;
  int v20;
  NSObject *v21;
  const char *v22;
  _QWORD *v23;
  __int16 v24;
  void (*v25)(void);
  NSObject *v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  _WORD *v31;
  int v32;
  NSObject *v33;
  int v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  _WORD *v39;
  int v40;
  NSObject *v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  unsigned int v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  char *v52;
  unsigned int v53;
  unsigned int v54;
  const char *v55;
  uint8_t *v56;
  uint8_t v57;
  uint8_t v58;
  uint8_t *v59;
  BOOL v60;
  uint8_t *v61;
  uint8_t v62;
  uint8_t v63;
  uint8_t *v64;
  BOOL v65;
  BOOL v66;
  const char *v67;
  uint64_t *v68;
  int *v69;
  int *v70;
  NSObject *v71;
  int v72;
  int v73;
  int v74;
  NSObject *v75;
  uint64_t v76;
  int v77;
  NSObject *v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  NSObject **v83;
  NSObject *v84;
  NSObject *v85;
  NSObject **v86;
  uint64_t v87;
  NSObject **v88;
  NSObject *v89;
  _BOOL4 v90;
  int v91;
  int v92;
  int v93;
  int v94;
  int v95;
  NSObject *v96;
  NSObject *v97;
  _QWORD *v98;
  _QWORD *v99;
  NSObject *v100;
  int v101;
  uint64_t v102;
  int v103;
  NSObject *v104;
  const char *v105;
  size_t v106;
  size_t v107;
  NSObject *v108;
  int v109;
  int v110;
  uint64_t v111;
  uint64_t v112;
  NSObject *v113;
  int v114;
  int v115;
  NSObject *v116;
  int v117;
  unsigned int v118;
  NSObject *v119;
  int v120;
  unsigned int v121;
  NSObject *v122;
  int v123;
  unsigned int v124;
  const char *v125;
  NSObject *v126;
  os_log_type_t v127;
  uint32_t v128;
  NSObject *v129;
  int v130;
  int v131;
  unsigned int v132;
  int v133;
  NSObject *v134;
  NSObject *v135;
  _QWORD *v136;
  _QWORD *v137;
  int *v138;
  _QWORD *v139;
  int *v140;
  NSObject *v141;
  int v142;
  int v143;
  int v144;
  int v145;
  NSObject *v146;
  _DWORD *v147;
  uint64_t v148;
  char *v149;
  int v150;
  NSObject *v151;
  uint64_t v152;
  uint64_t v153;
  unint64_t v154;
  int v155;
  uint64_t v156;
  const char *v157;
  NSObject *v158;
  uint32_t v159;
  uint64_t v160;
  _BYTE *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  const char *v166;
  const char *v167;
  const char *v168;
  unsigned int v169;
  uint64_t v170;
  uint64_t v171;
  _DWORD *v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  char v178;
  unsigned int v179;
  unint64_t v180;
  unsigned int v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  unsigned int v185;
  uint64_t v186;
  uint64_t v187;
  void *v188;
  void *v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  int v195;
  _DWORD *v197;
  NSObject *v199;
  const char *v200;
  uint64_t v201;
  void (*v202)(_QWORD, uint64_t *, uint64_t, uint64_t);
  int v203;
  uint64_t *v204;
  uint64_t v205;
  uint64_t v206;
  NSObject *v207;
  NSObject *v208;
  NSObject *v210;
  unsigned int v211;
  void *v212;
  unsigned int v213;
  int **v214;
  uint64_t v215;
  NSObject *log;
  unsigned __int16 *v217;
  unsigned int v218;
  char v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  char __str[46];
  uint8_t buf[32];
  _OWORD v225[2];
  uint8_t v226[4];
  const char *v227;
  __int16 v228;
  _BYTE v229[34];
  __int16 v230;
  int v231;

  if ((*(_WORD *)(a1 + 416) & 0x20) != 0)
  {
    v9 = *(char **)(a1 + 192);
  }
  else
  {
    v6 = *(unsigned __int8 *)(a2 + 5);
    v7 = v6 == 30 || v6 == 2;
    if (v7)
    {
      if (v6 == 2)
        v8 = (const void *)(a2 + 8);
      else
        v8 = (const void *)(a2 + 12);
      v9 = __str;
      inet_ntop(v6, v8, __str, 0x2Eu);
    }
    else
    {
      v9 = __str;
      snprintf(__str, 0x2EuLL, "Address type %d", *(unsigned __int8 *)(a2 + 5));
    }
  }
  v10 = *(_QWORD *)(a1 + 200);
  v11 = (NSObject **)&dnssd_client_states;
  v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v13 = *(_DWORD *)(a1 + 180);
    if (v10)
      v14 = *(_DWORD *)(v10 + 4);
    else
      v14 = 0;
    v15 = bswap32(*(unsigned __int16 *)(a2 + 88));
    v16 = *(unsigned __int16 *)(a2 + 64);
    *(_DWORD *)buf = 136447747;
    *(_QWORD *)&buf[4] = "dns_proxy_input_for_server";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v13;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v14;
    *(_WORD *)&buf[24] = 1024;
    *(_DWORD *)&buf[26] = HIWORD(v15);
    *(_WORD *)&buf[30] = 2160;
    *(_QWORD *)&v225[0] = 1752392040;
    WORD4(v225[0]) = 2081;
    *(_QWORD *)((char *)v225 + 10) = v9;
    WORD1(v225[1]) = 1024;
    DWORD1(v225[1]) = v16;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: [C%d][TRK%d][QID %x] Received a new DNS message - src: %{private, mask.hash}s, message length: %u bytes.", buf, 0x38u);
  }
  memset(v225, 0, sizeof(v225));
  memset(buf, 0, sizeof(buf));
  v218 = 0;
  if (!a3)
  {
    v23 = malloc_type_calloc(1uLL, 0x30uLL, 0x102004009C3B402uLL);
    if (!v23)
    {
      v100 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v101 = *(_DWORD *)(a1 + 180);
        v102 = *(_QWORD *)(a1 + 192);
        *(_DWORD *)v226 = 136446979;
        v227 = "dnssd_proxy_dns_evaluate";
        v228 = 1024;
        *(_DWORD *)v229 = v101;
        *(_WORD *)&v229[4] = 2160;
        *(_QWORD *)&v229[6] = 1752392040;
        *(_WORD *)&v229[14] = 2081;
        *(_QWORD *)&v229[16] = v102;
        _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "%{public}s: [C%d] %{private, mask.hash}s: no memory for a connection tracker object!", v226, 0x26u);
      }
      a3 = 0;
      goto LABEL_135;
    }
    a3 = v23;
    v23[1] = a1;
    *((_DWORD *)v23 + 1) = ++cur_tracker_serial;
    ioloop_comm_retain_(a1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 4004);
    v24 = *(_WORD *)(a1 + 416);
    if ((v24 & 0x20) != 0)
    {
      if (*(_QWORD *)(a1 + 200))
      {
        v25 = *(void (**)(void))(a1 + 240);
        if (v25)
          v25();
      }
      *(_QWORD *)(a1 + 240) = dp_tracker_context_release;
      *(_QWORD *)(a1 + 200) = a3;
      v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v27 = *(_DWORD *)a3;
        *(_DWORD *)v226 = 136447490;
        v227 = "dnssd_proxy_dns_evaluate";
        v228 = 1024;
        *(_DWORD *)v229 = v27;
        *(_WORD *)&v229[4] = 2048;
        *(_QWORD *)&v229[6] = a3;
        *(_WORD *)&v229[14] = 2080;
        *(_QWORD *)&v229[16] = "tracker";
        *(_WORD *)&v229[24] = 2080;
        *(_QWORD *)&v229[26] = "dnssd-proxy.c";
        v230 = 1024;
        v231 = 4007;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
      }
      v28 = *(_DWORD *)a3;
      if (*(_DWORD *)a3)
      {
        v29 = v28 + 1;
        *(_DWORD *)a3 = v28 + 1;
        if (v28 + 1 > 10000)
        {
          v21 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_333;
          *(_DWORD *)v226 = 136447490;
          v227 = "dnssd_proxy_dns_evaluate";
          v228 = 1024;
          *(_DWORD *)v229 = v29;
          *(_WORD *)&v229[4] = 2048;
          *(_QWORD *)&v229[6] = a3;
          *(_WORD *)&v229[14] = 2080;
          *(_QWORD *)&v229[16] = "tracker";
          *(_WORD *)&v229[24] = 2080;
          *(_QWORD *)&v229[26] = "dnssd-proxy.c";
          v230 = 1024;
          v231 = 4007;
          v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_318;
        }
      }
      else
      {
        ++dp_tracker_created;
        *(_DWORD *)a3 = 1;
      }
      v24 = *(_WORD *)(a1 + 416);
    }
    if ((v24 & 0x100) == 0)
      *(_QWORD *)(a1 + 232) = dp_tracker_disconnected;
  }
  v17 = global_os_log;
  v18 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  v19 = *(_DWORD *)a3;
  if (v18)
  {
    *(_DWORD *)v226 = 136447490;
    v227 = "dnssd_proxy_dns_evaluate";
    v228 = 1024;
    *(_DWORD *)v229 = v19;
    *(_WORD *)&v229[4] = 2048;
    *(_QWORD *)&v229[6] = a3;
    *(_WORD *)&v229[14] = 2080;
    *(_QWORD *)&v229[16] = "tracker";
    *(_WORD *)&v229[24] = 2080;
    *(_QWORD *)&v229[26] = "dnssd-proxy.c";
    v230 = 1024;
    v231 = 4013;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
    v19 = *(_DWORD *)a3;
  }
  if (v19)
  {
    v20 = v19 + 1;
    *(_DWORD *)a3 = v19 + 1;
    if (v19 + 1 >= 10001)
    {
      v21 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_333;
      *(_DWORD *)v226 = 136447490;
      v227 = "dnssd_proxy_dns_evaluate";
      v228 = 1024;
      *(_DWORD *)v229 = v20;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = a3;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "tracker";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 4013;
      v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_318:
      v207 = v21;
      goto LABEL_332;
    }
  }
  else
  {
    ++dp_tracker_created;
    *(_DWORD *)a3 = 1;
  }
  v30 = *(unsigned __int16 *)(a2 + 90);
  if ((v30 & 0x80) != 0)
  {
    v41 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v42 = *((_DWORD *)a3 + 1);
      v43 = *(_DWORD *)(a1 + 180);
      v44 = *(_QWORD *)(a1 + 192);
      *(_DWORD *)v226 = 136447235;
      v227 = "dnssd_proxy_dns_evaluate";
      v228 = 1024;
      *(_DWORD *)v229 = v42;
      *(_WORD *)&v229[4] = 1024;
      *(_DWORD *)&v229[6] = v43;
      *(_WORD *)&v229[10] = 2160;
      *(_QWORD *)&v229[12] = 1752392040;
      *(_WORD *)&v229[20] = 2081;
      *(_QWORD *)&v229[22] = v44;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: dropping unexpected response", v226, 0x2Cu);
    }
    goto LABEL_135;
  }
  v31 = (_WORD *)(a2 + 88);
  v32 = (v30 >> 3) & 0xF;
  v217 = (unsigned __int16 *)(a2 + 88);
  if (v32)
  {
    if (v32 != 6)
    {
      dso_simple_response(a1, a2, (_WORD *)(a2 + 88), 4);
      goto LABEL_139;
    }
    if ((*(_WORD *)(a1 + 416) & 0x20) == 0)
    {
      v33 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v34 = *((_DWORD *)a3 + 1);
        v35 = *(_DWORD *)(a1 + 180);
        v36 = *(_QWORD *)(a1 + 192);
        *(_DWORD *)v226 = 136447235;
        v227 = "dnssd_proxy_dns_evaluate";
        v228 = 1024;
        *(_DWORD *)v229 = v34;
        *(_WORD *)&v229[4] = 1024;
        *(_DWORD *)&v229[6] = v35;
        *(_WORD *)&v229[10] = 2160;
        *(_QWORD *)&v229[12] = 1752392040;
        *(_WORD *)&v229[20] = 2081;
        *(_QWORD *)&v229[22] = v36;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: DSO message received on non-tcp socket.", v226, 0x2Cu);
      }
      v37 = a1;
      v38 = a2;
      v39 = (_WORD *)(a2 + 88);
      v40 = 4;
LABEL_43:
      dso_simple_response(v37, v38, v39, v40);
LABEL_135:
      if ((*(_WORD *)(a1 + 416) & 0x20) == 0)
        goto LABEL_136;
      ioloop_comm_cancel(a3[1]);
      goto LABEL_139;
    }
    if (!a3[3])
    {
      v105 = *(const char **)(a1 + 192);
      v106 = strlen(v105);
      v107 = v106;
      if ((v106 + 209) >> 32)
      {
        v108 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)v226 = 136446978;
          v227 = "dso_state_create";
          v228 = 2048;
          *(_QWORD *)v229 = 168;
          *(_WORD *)&v229[8] = 2048;
          *(_QWORD *)&v229[10] = 40;
          *(_WORD *)&v229[18] = 2048;
          *(_QWORD *)&v229[20] = v107 + 1;
          _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_FAULT, "%{public}s: Fatal: sizeof (*dso)[%zd], outsize[%zd], namespace[%zd]", v226, 0x2Au);
          v108 = global_os_log;
        }
        v11 = (NSObject **)&dnssd_client_states;
        a3[3] = 0;
        if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
        {
          v109 = *((_DWORD *)a3 + 1);
          v110 = *(_DWORD *)(a1 + 180);
          v111 = *(_QWORD *)(a1 + 192);
          *(_DWORD *)v226 = 136447235;
          v227 = "dnssd_proxy_dns_evaluate";
          v228 = 1024;
          *(_DWORD *)v229 = v109;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v110;
          *(_WORD *)&v229[10] = 2160;
          *(_QWORD *)&v229[12] = 1752392040;
          *(_WORD *)&v229[20] = 2081;
          *(_QWORD *)&v229[22] = v111;
          _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: Unable to create a dso context.", v226, 0x2Cu);
        }
        v37 = a1;
        v38 = a2;
        v39 = (_WORD *)(a2 + 88);
        v40 = 2;
        goto LABEL_43;
      }
      if (v106 == -209 || (v147 = malloc_type_calloc(1uLL, v106 + 209, 0xF1748037uLL)) == 0)
LABEL_313:
        __break(1u);
      v148 = (uint64_t)v147;
      v147[43] = 2;
      v149 = (char *)(v147 + 52);
      *((_QWORD *)v147 + 19) = v147 + 52;
      *((_QWORD *)v147 + 20) = v147 + 42;
      memcpy(v147 + 52, v105, v107);
      v149[v107] = 0;
      *(_QWORD *)(v148 + 16) = dp_tracker_dso_state_change;
      *(_QWORD *)(v148 + 24) = dns_push_callback;
      *(_QWORD *)(v148 + 32) = a1;
      *(_BYTE *)(v148 + 52) = 1;
      v150 = dso_state_create_dso_state_serial++;
      *(_DWORD *)(v148 + 48) = v150;
      *(_QWORD *)(v148 + 104) = v148 + 120;
      *(_DWORD *)(v148 + 116) = 2;
      *(_QWORD *)(v148 + 60) = 64424513040000;
      *(_QWORD *)v148 = dso_connections;
      *(_QWORD *)(v148 + 8) = a3;
      dso_connections = v148;
      v11 = (NSObject **)&dnssd_client_states;
      v151 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v226 = 136447234;
        v227 = "dso_state_create";
        v228 = 1024;
        *(_DWORD *)v229 = v150;
        *(_WORD *)&v229[4] = 2048;
        *(_QWORD *)&v229[6] = v148;
        *(_WORD *)&v229[14] = 2080;
        *(_QWORD *)&v229[16] = v105;
        *(_WORD *)&v229[24] = 2048;
        *(_QWORD *)&v229[26] = a3;
        _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] New dso_state_t created - dso: %p, remote name: %s, context: %p", v226, 0x30u);
      }
      a3[3] = v148;
      *(_QWORD *)(a1 + 272) = v148;
    }
    v152 = a3[4];
    if (v152)
      ioloop_cancel_wake_event(v152);
    v153 = *(_QWORD *)(a1 + 272);
    v154 = *(unsigned __int16 *)(a2 + 64);
    v155 = *(char *)(a2 + 90);
    v220 = 0;
    v221 = 0;
    v222 = 0;
    if (v154 <= 0xB)
    {
      v156 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v226 = 136446466;
        v227 = "dso_message_received";
        v228 = 2048;
        *(_QWORD *)v229 = v154;
        v157 = "%{public}s: dso_message_received: response too short: %ld bytes";
LABEL_216:
        v158 = v156;
        v159 = 22;
        goto LABEL_280;
      }
      goto LABEL_281;
    }
    if (v155 < 0)
    {
      v169 = *v217;
      if (!*v217)
      {
        v156 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v171 = *(_QWORD *)(v153 + 152);
          *(_DWORD *)v226 = 136446466;
          v227 = "dso_message_received";
          v228 = 2080;
          *(_QWORD *)v229 = v171;
          v157 = "%{public}s: dso_message_received: response with id==0 received from %s";
          goto LABEL_216;
        }
LABEL_281:
        dso_state_cancel(v153);
        goto LABEL_139;
      }
      if (v154 <= 0xF && (_DWORD)v154 != 12)
      {
        v162 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v170 = *(_QWORD *)(v153 + 152);
          *(_DWORD *)v226 = 136446722;
          v227 = "dso_message_received";
          v228 = 2048;
          *(_QWORD *)v229 = v154;
          *(_WORD *)&v229[8] = 2080;
          *(_QWORD *)&v229[10] = v170;
          v157 = "%{public}s: dso_message_received: response with bogus length==%ld received from %s";
          goto LABEL_240;
        }
        goto LABEL_281;
      }
      v172 = *(_DWORD **)(v153 + 160);
      v173 = v172[1];
      if ((int)v173 < 1)
      {
LABEL_247:
        v176 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v177 = *(_QWORD *)(v153 + 152);
          *(_DWORD *)v226 = 136447234;
          v227 = "dso_message_received";
          v228 = 2080;
          *(_QWORD *)v229 = v177;
          *(_WORD *)&v229[8] = 2048;
          *(_QWORD *)&v229[10] = v154;
          *(_WORD *)&v229[18] = 1024;
          *(_DWORD *)&v229[20] = v169;
          *(_WORD *)&v229[24] = 1024;
          *(_DWORD *)&v229[26] = v169 >> 8;
          v157 = "%{public}s: dso_message_received: fatal: %s sent %ld byte message, QR=1, xid=%02x%02x";
          v158 = v176;
          v159 = 44;
          goto LABEL_280;
        }
        goto LABEL_281;
      }
      v174 = 0;
      v175 = 2;
      while (LOWORD(v172[v175]) != v169)
      {
        ++v174;
        v175 += 4;
        if (v173 == v174)
          goto LABEL_247;
      }
      v194 = *(_QWORD *)&v172[4 * v174 + 4];
      v195 = *(_BYTE *)(a2 + 91) & 0xF;
      LOWORD(v222) = *(_BYTE *)(a2 + 91) & 0xF;
      v220 = v194;
      v221 = a2;
      if (!*(_BYTE *)(v153 + 52) && !*(_BYTE *)(v153 + 53) && v195 == 0)
      {
        dso_session_established(v153);
        v172 = *(_DWORD **)(v153 + 160);
      }
      v197 = &v172[4 * v174];
      *((_WORD *)v197 + 4) = 0;
      *((_QWORD *)v197 + 2) = 0;
      if (--*v172 < 0)
      {
        v210 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v226 = 136446210;
          v227 = "dso_message_received";
          _os_log_impl((void *)&_mh_execute_header, v210, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_message_receive: programming error: outstanding_query_count went negative.", v226, 0xCu);
        }
        __assert_rtn("dso_message_received", "dso.c", 827, "0");
      }
      if ((_DWORD)v154 == 12)
      {
        *(_DWORD *)(v153 + 88) = 0;
        *(_DWORD *)(v153 + 112) = 0;
      }
    }
    v160 = 0;
    v161 = (_BYTE *)(a2 + 93);
    do
    {
      if (*(v161 - 1) || *v161)
      {
        v164 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_281;
        v165 = *(_QWORD *)(v153 + 152);
        v166 = "ANCOUNT";
        v167 = "ARCOUNT";
        if ((_DWORD)v160 == 2)
          v167 = "NSCOUNT";
        *(_DWORD *)v226 = 136446978;
        v227 = "dso_message_received";
        if ((_DWORD)v160 != 1)
          v166 = v167;
        v228 = 2080;
        *(_QWORD *)v229 = v165;
        *(_WORD *)&v229[8] = 2048;
        *(_QWORD *)&v229[10] = v154;
        if ((_DWORD)v160)
          v168 = v166;
        else
          v168 = "QDCOUNT";
        *(_WORD *)&v229[18] = 2080;
        *(_QWORD *)&v229[20] = v168;
        v157 = "%{public}s: dso_message_received: fatal: %s sent %ld byte DSO message, %s is nonzero";
        v158 = v164;
        v159 = 42;
        goto LABEL_280;
      }
      ++v160;
      v161 += 2;
    }
    while (v160 != 4);
    if (v154 <= 0xF && (_DWORD)v154 != 12)
    {
      v162 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_281;
      v163 = *(_QWORD *)(v153 + 152);
      *(_DWORD *)v226 = 136446722;
      v227 = "dso_message_received";
      v228 = 2080;
      *(_QWORD *)v229 = v163;
      *(_WORD *)&v229[8] = 2048;
      *(_QWORD *)&v229[10] = v154;
      v157 = "%{public}s: dso_message_received: fatal: %s sent short (%ld byte) DSO message";
LABEL_240:
      v158 = v162;
      v159 = 32;
LABEL_280:
      _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, v157, v226, v159);
      goto LABEL_281;
    }
    if (!*(_BYTE *)(v153 + 53))
    {
      if (!*(_BYTE *)(v153 + 52) || v155 < 0)
      {
        if (v155 < 0 != (*(_BYTE *)(v153 + 52) != 0))
          goto LABEL_250;
      }
      else
      {
        dso_session_established(v153);
        if (*(_BYTE *)(v153 + 53) || v155 < 0 != (*(_BYTE *)(v153 + 52) != 0))
          goto LABEL_250;
      }
      v199 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v200 = "request";
        v227 = "dso_message_received";
        v201 = *(_QWORD *)(v153 + 152);
        *(_DWORD *)v226 = 136446722;
        if (v155 < 0)
          v200 = "response";
        v228 = 2080;
        *(_QWORD *)v229 = v200;
        *(_WORD *)&v229[8] = 2080;
        *(_QWORD *)&v229[10] = v201;
        _os_log_impl((void *)&_mh_execute_header, v199, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_message_received: received a %s with no established session from %s", v226, 0x20u);
      }
      dso_state_cancel(v153);
    }
LABEL_250:
    v211 = v155;
    v212 = (void *)(v153 + 120);
    v178 = 1;
    v215 = v153;
    while (1)
    {
      if (v154 >= 0xD)
      {
        v179 = 0;
        v180 = 12;
        while (1)
        {
          v181 = __rev16(*(unsigned __int16 *)((char *)v217 + v180));
          v182 = __rev16(*(unsigned __int16 *)((char *)v217 + v180 + 2));
          if (v180 + v182 > v154)
            break;
          if ((v178 & 1) != 0)
          {
            ++v179;
          }
          else if (v180 == 12)
          {
            *(_WORD *)(v153 + 88) = v181;
            *(_WORD *)(v153 + 90) = v182;
            *(_QWORD *)(v153 + 96) = a2 + 104;
            *(_DWORD *)(v153 + 112) = 0;
          }
          else
          {
            v183 = v153;
            v184 = *(unsigned int *)(v153 + 112);
            v185 = *(_DWORD *)(v153 + 116);
            if (v184 >= v185)
            {
              log = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                v187 = *(_QWORD *)(v215 + 152);
                *(_DWORD *)v226 = 136447234;
                v227 = "dso_message_received";
                v228 = 2080;
                *(_QWORD *)v229 = v187;
                *(_WORD *)&v229[8] = 1024;
                *(_DWORD *)&v229[10] = v181;
                *(_WORD *)&v229[14] = 2048;
                *(_QWORD *)&v229[16] = v182;
                *(_WORD *)&v229[24] = 1024;
                *(_DWORD *)&v229[26] = v185;
                v153 = v215;
                _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_message_received: %s: ignoring additional TLV (%d %ld) in excess of %d", v226, 0x2Cu);
              }
              else
              {
                v153 = v215;
              }
            }
            else
            {
              v186 = *(_QWORD *)(v183 + 104) + 16 * v184;
              *(_WORD *)v186 = v181;
              *(_WORD *)(v186 + 2) = v182;
              *(_QWORD *)(v186 + 8) = (char *)v217 + v180 + 4;
              *(_DWORD *)(v183 + 112) = v184 + 1;
              v153 = v183;
            }
          }
          v180 += v182 + 4;
          if (v180 >= v154)
            goto LABEL_266;
        }
        v11 = (NSObject **)&dnssd_client_states;
        v192 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v193 = *(_QWORD *)(v153 + 152);
          *(_DWORD *)v226 = 136447234;
          v227 = "dso_message_received";
          v228 = 2080;
          *(_QWORD *)v229 = v193;
          *(_WORD *)&v229[8] = 1024;
          *(_DWORD *)&v229[10] = v181;
          *(_WORD *)&v229[14] = 2048;
          *(_QWORD *)&v229[16] = v182;
          *(_WORD *)&v229[24] = 2048;
          *(_QWORD *)&v229[26] = v154;
          v157 = "%{public}s: dso_message_received: fatal: %s: TLV (%d %ld) extends past end (%ld)";
          v158 = v192;
          v159 = 48;
          goto LABEL_280;
        }
        goto LABEL_281;
      }
      v179 = 0;
LABEL_266:
      if ((v178 & 1) == 0)
        break;
      v178 = 0;
      if (v179 > *(_DWORD *)(v153 + 116))
      {
        v188 = *(void **)(v153 + 104);
        if (v188 != v212 && v188 != 0)
        {
          free(v188);
          *(_QWORD *)(v153 + 104) = 0;
        }
        v190 = malloc_type_calloc(v179, 0x10uLL, 0xF1748037uLL);
        if (!v190)
          goto LABEL_313;
        v178 = 0;
        *(_QWORD *)(v153 + 104) = v190;
        *(_DWORD *)(v153 + 116) = v179;
      }
    }
    v202 = *(void (**)(_QWORD, uint64_t *, uint64_t, uint64_t))(v153 + 24);
    v11 = (NSObject **)&dnssd_client_states;
    if (!v202)
      goto LABEL_139;
    if ((_DWORD)v154 != 12)
    {
      v203 = *(unsigned __int16 *)(v153 + 88);
      if (v203 == 2)
      {
        dso_retry_delay(v153, v217);
        goto LABEL_139;
      }
      if (v203 == 1)
      {
        dso_keepalive(v153, v217, (v211 >> 7) & 1);
        goto LABEL_139;
      }
    }
    if ((v211 & 0x80000000) != 0)
    {
      v204 = &v220;
      v205 = v153;
      v206 = 4;
    }
    else
    {
      v204 = (uint64_t *)a2;
      v205 = v153;
      v206 = 2;
    }
    v202(*(_QWORD *)(v153 + 8), v204, v205, v206);
    goto LABEL_139;
  }
  if (!*(_WORD *)(a2 + 92))
  {
LABEL_155:
    v112 = a3[4];
    if (v112)
      ioloop_cancel_wake_event(v112);
    goto LABEL_139;
  }
  v45 = 0;
  v46 = __rev16(*(unsigned __int16 *)(a2 + 92));
  v214 = (int **)(a3 + 2);
  v213 = v46;
  while (1)
  {
    memset(v225, 0, sizeof(v225));
    memset(buf, 0, sizeof(buf));
    if ((dns_rr_parse_((uint64_t)buf, a2 + 100, *(unsigned __int16 *)(a2 + 64) - 12, &v218, 0) & 1) == 0)
    {
      v113 = v11[306];
      if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
      {
        v114 = *((_DWORD *)a3 + 1);
        if (a1)
          v115 = *(_DWORD *)(a1 + 180);
        else
          v115 = 0;
        v191 = *(_QWORD *)(a1 + 192);
        *(_DWORD *)v226 = 136447235;
        v227 = "dnssd_proxy_dns_evaluate";
        v228 = 1024;
        *(_DWORD *)v229 = v114;
        *(_WORD *)&v229[4] = 1024;
        *(_DWORD *)&v229[6] = v115;
        *(_WORD *)&v229[10] = 2160;
        *(_QWORD *)&v229[12] = 1752392040;
        *(_WORD *)&v229[20] = 2081;
        *(_QWORD *)&v229[22] = v191;
        _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: rr parse failed.", v226, 0x2Cu);
      }
      v37 = a1;
      v38 = a2;
      v39 = v31;
      v40 = 1;
      goto LABEL_43;
    }
    if (dp_num_outstanding_queries >= 256)
      break;
    LODWORD(v220) = 0;
    v47 = dp_query_create((int *)a3, (uint64_t)buf, a2, 0, &v220);
    if (!v47)
    {
      v119 = v11[306];
      if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
      {
        v120 = *((_DWORD *)a3 + 1);
        v121 = bswap32((unsigned __int16)*v31);
        *(_DWORD *)v226 = 136446722;
        v227 = "dp_dns_query";
        v228 = 1024;
        *(_DWORD *)v229 = v120;
        *(_WORD *)&v229[4] = 1024;
        *(_DWORD *)&v229[6] = HIWORD(v121);
        _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][QID %x] query create failed", v226, 0x18u);
      }
      dso_simple_response(a3[1], a2, v31, v220);
      goto LABEL_182;
    }
    v48 = (uint64_t)v47;
    v47[22] = v46;
    v49 = *((_QWORD *)v47 + 20);
    *(_WORD *)(v49 + 2) &= 0xF0FFu;
    *(_WORD *)(v49 + 4) = 256;
    v50 = *((_QWORD *)v47 + 24);
    v51 = (uint64_t *)(v47 + 24);
    v52 = *(char **)(v50 + 32);
    if (*(_QWORD *)(v50 + 8))
    {
      dns_name_to_wire_(0, v51, v52, 3898);
      v53 = *(_DWORD *)(v48 + 144);
      dns_full_name_to_wire_((_OWORD *)(v48 + 32), (uint64_t)v51, *(char **)(*(_QWORD *)(*(_QWORD *)(v48 + 192) + 8) + 8), 3901);
      v54 = *(_DWORD *)(v48 + 144);
      v55 = "enclosing_domain";
      if (v54 <= 1)
        v55 = 0;
      if (v53 >= 2)
        v55 = "name";
    }
    else
    {
      dns_full_name_to_wire_(0, (uint64_t)v51, v52, 3903);
      v54 = *(_DWORD *)(v48 + 144);
      v55 = "full name";
      if (v54 < 2)
        v55 = 0;
    }
    if (v54 <= 1)
    {
      v56 = *(uint8_t **)(v48 + 104);
      if ((unint64_t)(v56 + 2) < *(_QWORD *)(v48 + 112))
      {
        v57 = buf[8];
        v58 = buf[9];
        *(_QWORD *)(v48 + 104) = v56 + 1;
        *v56 = v58;
        v59 = *(uint8_t **)(v48 + 104);
        *(_QWORD *)(v48 + 104) = v59 + 1;
        *v59 = v57;
        v54 = *(_DWORD *)(v48 + 144);
        if (v55)
          v60 = 0;
        else
          v60 = v54 > 1;
        if (v60)
          v55 = "TYPE";
        if (v54 <= 1)
        {
          v61 = *(uint8_t **)(v48 + 104);
          if ((unint64_t)(v61 + 2) >= *(_QWORD *)(v48 + 112))
          {
            v54 = 111;
            *(_DWORD *)(v48 + 144) = 111;
            *(_DWORD *)(v48 + 136) = 3906;
          }
          else
          {
            v62 = buf[10];
            v63 = buf[11];
            *(_QWORD *)(v48 + 104) = v61 + 1;
            *v61 = v63;
            v64 = *(uint8_t **)(v48 + 104);
            *(_QWORD *)(v48 + 104) = v64 + 1;
            *v64 = v62;
            v54 = *(_DWORD *)(v48 + 144);
          }
        }
        goto LABEL_75;
      }
      v54 = 111;
      *(_DWORD *)(v48 + 144) = 111;
      *(_DWORD *)(v48 + 136) = 3905;
    }
    if (v55)
      v65 = 0;
    else
      v65 = v54 > 1;
    if (v65)
      v55 = "TYPE";
LABEL_75:
    if (v55)
      v66 = 0;
    else
      v66 = v54 > 1;
    if (v66)
      v67 = "CLASS";
    else
      v67 = v55;
    if (v67)
    {
      v122 = v11[306];
      if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
      {
        v123 = *((_DWORD *)a3 + 1);
        v124 = bswap32((unsigned __int16)*v31);
        *(_DWORD *)v226 = 136446978;
        v227 = "dp_dns_query";
        v228 = 1024;
        *(_DWORD *)v229 = v123;
        *(_WORD *)&v229[4] = 1024;
        *(_DWORD *)&v229[6] = HIWORD(v124);
        *(_WORD *)&v229[10] = 2082;
        *(_QWORD *)&v229[12] = v67;
        v125 = "%{public}s: [TRK%d][QID %x] failure encoding question: %{public}s";
        v126 = v122;
        v127 = OS_LOG_TYPE_ERROR;
        v128 = 34;
        goto LABEL_173;
      }
LABEL_174:
      dso_simple_response(a3[1], a2, v31, v220);
      *(_BYTE *)(v48 + 200) = 1;
      dp_question_cache_remove_queries(*(_QWORD *)(v48 + 192));
      dnssd_query_cancel(v48);
      v133 = *(_DWORD *)v48;
      if (*(_DWORD *)v48)
      {
        v134 = v11[306];
        if (v133 < 10001)
        {
          if (os_log_type_enabled(v134, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v226 = 136447490;
            v227 = "dp_dns_query";
            v228 = 1024;
            *(_DWORD *)v229 = v133;
            *(_WORD *)&v229[4] = 2048;
            *(_QWORD *)&v229[6] = v48;
            *(_WORD *)&v229[14] = 2080;
            *(_QWORD *)&v229[16] = "query";
            *(_WORD *)&v229[24] = 2080;
            *(_QWORD *)&v229[26] = "dnssd-proxy.c";
            v230 = 1024;
            v231 = 3948;
            _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
            v133 = *(_DWORD *)v48;
          }
          *(_DWORD *)v48 = v133 - 1;
          if (v133 == 1)
          {
            v135 = v11[306];
            if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v226 = 136447234;
              v227 = "dp_dns_query";
              v228 = 2048;
              *(_QWORD *)v229 = v48;
              *(_WORD *)&v229[8] = 2080;
              *(_QWORD *)&v229[10] = "query";
              *(_WORD *)&v229[18] = 2080;
              *(_QWORD *)&v229[20] = "dnssd-proxy.c";
              *(_WORD *)&v229[28] = 1024;
              *(_DWORD *)&v229[30] = 3948;
              _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
            }
            ++dnssd_query_finalized;
            dnssd_query_finalize((_QWORD *)v48);
          }
          goto LABEL_182;
        }
        if (!os_log_type_enabled(v134, OS_LOG_TYPE_FAULT))
          goto LABEL_333;
        *(_DWORD *)v226 = 136447490;
        v227 = "dp_dns_query";
        v228 = 1024;
        *(_DWORD *)v229 = v133;
        *(_WORD *)&v229[4] = 2048;
        *(_QWORD *)&v229[6] = v48;
        *(_WORD *)&v229[14] = 2080;
        *(_QWORD *)&v229[16] = "query";
        *(_WORD *)&v229[24] = 2080;
        *(_QWORD *)&v229[26] = "dnssd-proxy.c";
        v230 = 1024;
        v231 = 3948;
        v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v207 = v134;
LABEL_332:
        _os_log_impl((void *)&_mh_execute_header, v207, OS_LOG_TYPE_FAULT, v22, v226, 0x36u);
        goto LABEL_333;
      }
      v208 = v11[306];
      if (!os_log_type_enabled(v208, OS_LOG_TYPE_FAULT))
        goto LABEL_333;
      *(_DWORD *)v226 = 136447490;
      v227 = "dp_dns_query";
      v228 = 1024;
      *(_DWORD *)v229 = 0;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = v48;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "query";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 3948;
      v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_331:
      v207 = v208;
      goto LABEL_332;
    }
    **(_WORD **)(v48 + 96) = *v31;
    *(_BYTE *)(v48 + 92) = 1;
    v68 = a3 + 2;
    v69 = *v214;
    if (!*v214)
      goto LABEL_86;
    do
    {
      if (v69 == (int *)v48)
      {
        v75 = v11[306];
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        {
          v76 = *(_QWORD *)(v48 + 8);
          if (v76)
            LODWORD(v76) = *(_DWORD *)(v76 + 4);
          v77 = *(_DWORD *)(v48 + 4);
          *(_DWORD *)v226 = 136446722;
          v227 = "dp_query_track";
          v228 = 1024;
          *(_DWORD *)v229 = v77;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v76;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][TRK%d] query is already being tracked.", v226, 0x18u);
        }
        goto LABEL_96;
      }
      v70 = v69;
      v69 = (int *)*((_QWORD *)v69 + 2);
    }
    while (v69);
    v68 = (uint64_t *)(v70 + 4);
LABEL_86:
    *v68 = v48;
    v71 = v11[306];
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
    {
      v72 = *(_DWORD *)v48;
      *(_DWORD *)v226 = 136447490;
      v227 = "dp_query_track";
      v228 = 1024;
      *(_DWORD *)v229 = v72;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = v48;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "query";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 1016;
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
    }
    v73 = *(_DWORD *)v48;
    if (*(_DWORD *)v48)
    {
      v74 = v73 + 1;
      *(_DWORD *)v48 = v73 + 1;
      if (v73 + 1 >= 10001)
      {
        v208 = v11[306];
        if (os_log_type_enabled(v208, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)v226 = 136447490;
          v227 = "dp_query_track";
          v228 = 1024;
          *(_DWORD *)v229 = v74;
          *(_WORD *)&v229[4] = 2048;
          *(_QWORD *)&v229[6] = v48;
          *(_WORD *)&v229[14] = 2080;
          *(_QWORD *)&v229[16] = "query";
          *(_WORD *)&v229[24] = 2080;
          *(_QWORD *)&v229[26] = "dnssd-proxy.c";
          v230 = 1024;
          v231 = 1016;
          v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_331;
        }
LABEL_333:
        abort();
      }
    }
    else
    {
      ++dnssd_query_created;
      *(_DWORD *)v48 = 1;
    }
LABEL_96:
    v219 = 0;
    if (!dp_query_start(v48, &v220, &v219))
    {
      v129 = v11[306];
      if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
      {
        v130 = *(_DWORD *)(v48 + 4);
        v131 = *((_DWORD *)a3 + 1);
        v132 = bswap32((unsigned __int16)*v31);
        *(_DWORD *)v226 = 136446978;
        v227 = "dp_dns_query";
        v228 = 1024;
        *(_DWORD *)v229 = v130;
        *(_WORD *)&v229[4] = 1024;
        *(_DWORD *)&v229[6] = v131;
        *(_WORD *)&v229[10] = 1024;
        *(_DWORD *)&v229[12] = HIWORD(v132);
        v125 = "%{public}s: [Q%d][TRK%d][QID %x] query start failed";
        v126 = v129;
        v127 = OS_LOG_TYPE_DEFAULT;
        v128 = 30;
LABEL_173:
        _os_log_impl((void *)&_mh_execute_header, v126, v127, v125, v226, v128);
      }
      goto LABEL_174;
    }
    if (v219)
    {
      v78 = v11[306];
      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
      {
        v79 = *(_DWORD *)(v48 + 4);
        v80 = *((_DWORD *)a3 + 1);
        *(_DWORD *)v226 = 136446722;
        v227 = "dp_dns_query";
        v228 = 1024;
        *(_DWORD *)v229 = v79;
        *(_WORD *)&v229[4] = 1024;
        *(_DWORD *)&v229[6] = v80;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][TRK%d] hardwired reply", v226, 0x18u);
      }
      dp_query_send_dns_response(v48, (uint64_t)"hardwired");
      dp_question_cache_remove_queries(*(_QWORD *)(v48 + 192));
      v81 = *(_QWORD *)(v48 + 192);
      if (v81)
      {
        v82 = *(_DWORD *)(v81 + 60);
        if (!v82)
        {
          v208 = v11[306];
          if (!os_log_type_enabled(v208, OS_LOG_TYPE_FAULT))
            goto LABEL_333;
          *(_DWORD *)v226 = 136447490;
          v227 = "dp_dns_query";
          v228 = 1024;
          *(_DWORD *)v229 = 0;
          *(_WORD *)&v229[4] = 2048;
          *(_QWORD *)&v229[6] = v81;
          *(_WORD *)&v229[14] = 2080;
          *(_QWORD *)&v229[16] = "query->question";
          *(_WORD *)&v229[24] = 2080;
          *(_QWORD *)&v229[26] = "dnssd-proxy.c";
          v230 = 1024;
          v231 = 3932;
          v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_331;
        }
        v83 = v11;
        v84 = v11[306];
        if (v82 >= 10001)
        {
          if (!os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
            goto LABEL_333;
          *(_DWORD *)v226 = 136447490;
          v227 = "dp_dns_query";
          v228 = 1024;
          *(_DWORD *)v229 = v82;
          *(_WORD *)&v229[4] = 2048;
          *(_QWORD *)&v229[6] = v81;
          *(_WORD *)&v229[14] = 2080;
          *(_QWORD *)&v229[16] = "query->question";
          *(_WORD *)&v229[24] = 2080;
          *(_QWORD *)&v229[26] = "dnssd-proxy.c";
          v230 = 1024;
          v231 = 3932;
          v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v207 = v84;
          goto LABEL_332;
        }
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v226 = 136447490;
          v227 = "dp_dns_query";
          v228 = 1024;
          *(_DWORD *)v229 = v82;
          *(_WORD *)&v229[4] = 2048;
          *(_QWORD *)&v229[6] = v81;
          *(_WORD *)&v229[14] = 2080;
          *(_QWORD *)&v229[16] = "query->question";
          *(_WORD *)&v229[24] = 2080;
          *(_QWORD *)&v229[26] = "dnssd-proxy.c";
          v230 = 1024;
          v231 = 3932;
          _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
          v81 = *(_QWORD *)(v48 + 192);
          v82 = *(_DWORD *)(v81 + 60);
        }
        v11 = v83;
        *(_DWORD *)(v81 + 60) = v82 - 1;
        if (v82 == 1)
        {
          v85 = v83[306];
          if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v226 = 136447234;
            v227 = "dp_dns_query";
            v228 = 2048;
            *(_QWORD *)v229 = v81;
            *(_WORD *)&v229[8] = 2080;
            *(_QWORD *)&v229[10] = "query->question";
            *(_WORD *)&v229[18] = 2080;
            *(_QWORD *)&v229[20] = "dnssd-proxy.c";
            *(_WORD *)&v229[28] = 1024;
            *(_DWORD *)&v229[30] = 3932;
            _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
            v81 = *(_QWORD *)(v48 + 192);
          }
          ++question_finalized;
          question_finalize(v81);
          v11 = v83;
        }
      }
      *(_QWORD *)(v48 + 192) = 0;
    }
    else
    {
      v86 = v11;
      v87 = *(_QWORD *)(v48 + 192);
      v88 = v86;
      v89 = v86[306];
      v90 = os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT);
      if (v87)
      {
        if (v90)
        {
          v91 = *(_DWORD *)(v48 + 4);
          v92 = *((_DWORD *)a3 + 1);
          *(_DWORD *)v226 = 136446722;
          v227 = "dp_dns_query";
          v228 = 1024;
          *(_DWORD *)v229 = v91;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v92;
          _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][TRK%d] replying from cache", v226, 0x18u);
          v87 = *(_QWORD *)(v48 + 192);
        }
        dp_query_reply_from_cache(v87, v48, 0);
        dp_question_cache_remove_queries(*(_QWORD *)(v48 + 192));
        v11 = v88;
      }
      else
      {
        v11 = v88;
        if (v90)
        {
          v93 = *(_DWORD *)(v48 + 4);
          v94 = *((_DWORD *)a3 + 1);
          *(_DWORD *)v226 = 136446722;
          v227 = "dp_dns_query";
          v228 = 1024;
          *(_DWORD *)v229 = v93;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v94;
          _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][TRK%d] not replying from cache", v226, 0x18u);
        }
      }
    }
    v95 = *(_DWORD *)v48;
    if (!*(_DWORD *)v48)
    {
      v208 = v11[306];
      if (os_log_type_enabled(v208, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v226 = 136447490;
        v227 = "dp_dns_query";
        v228 = 1024;
        *(_DWORD *)v229 = 0;
        *(_WORD *)&v229[4] = 2048;
        *(_QWORD *)&v229[6] = v48;
        *(_WORD *)&v229[14] = 2080;
        *(_QWORD *)&v229[16] = "query";
        *(_WORD *)&v229[24] = 2080;
        *(_QWORD *)&v229[26] = "dnssd-proxy.c";
        v230 = 1024;
        v231 = 3952;
        v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_331;
      }
      goto LABEL_333;
    }
    v96 = v11[306];
    if (v95 >= 10001)
    {
      if (!os_log_type_enabled(v96, OS_LOG_TYPE_FAULT))
        goto LABEL_333;
      *(_DWORD *)v226 = 136447490;
      v227 = "dp_dns_query";
      v228 = 1024;
      *(_DWORD *)v229 = v95;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = v48;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "query";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 3952;
      v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v207 = v96;
      goto LABEL_332;
    }
    v31 = (_WORD *)(a2 + 88);
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v226 = 136447490;
      v227 = "dp_dns_query";
      v228 = 1024;
      *(_DWORD *)v229 = v95;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = v48;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "query";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 3952;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
      v95 = *(_DWORD *)v48;
    }
    v7 = v95 == 1;
    *(_DWORD *)v48 = v95 - 1;
    v46 = v213;
    if (v7)
    {
      v97 = v11[306];
      if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v226 = 136447234;
        v227 = "dp_dns_query";
        v228 = 2048;
        *(_QWORD *)v229 = v48;
        *(_WORD *)&v229[8] = 2080;
        *(_QWORD *)&v229[10] = "query";
        *(_WORD *)&v229[18] = 2080;
        *(_QWORD *)&v229[20] = "dnssd-proxy.c";
        *(_WORD *)&v229[28] = 1024;
        *(_DWORD *)&v229[30] = 3952;
        _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
      }
      ++dnssd_query_finalized;
      dnssd_query_finalize((_QWORD *)v48);
    }
    dns_rrdata_free((uint64_t)buf);
    v98 = *(_QWORD **)buf;
    do
    {
      if (!v98)
        break;
      v99 = (_QWORD *)*v98;
      free(v98);
      v98 = v99;
    }
    while (v99);
    if (++v45 == v213)
      goto LABEL_155;
  }
  ++num_queries_dropped_for_load;
  dso_simple_response(a3[1], a2, v31, 2);
  v116 = v11[306];
  if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
  {
    v117 = *((_DWORD *)a3 + 1);
    v118 = bswap32((unsigned __int16)*v31);
    *(_DWORD *)v226 = 136446722;
    v227 = "dp_dns_query";
    v228 = 1024;
    *(_DWORD *)v229 = v117;
    *(_WORD *)&v229[4] = 1024;
    *(_DWORD *)&v229[6] = HIWORD(v118);
    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][QID %x] dropping query because there are too many", v226, 0x18u);
  }
LABEL_182:
  dns_rrdata_free((uint64_t)buf);
  v136 = *(_QWORD **)buf;
  do
  {
    if (!v136)
      break;
    v137 = (_QWORD *)*v136;
    free(v136);
    v136 = v137;
  }
  while (v137);
  v138 = *v214;
  if (!*v214)
    goto LABEL_139;
  v139 = 0;
  do
  {
    while (1)
    {
      v140 = v138;
      v138 = (int *)*((_QWORD *)v138 + 2);
      if (*((_QWORD *)v140 + 8) == a2)
      {
        *((_BYTE *)v140 + 200) = 1;
        dp_question_cache_remove_queries(*((_QWORD *)v140 + 24));
        if (!v139)
          break;
      }
      if (!v138)
        goto LABEL_197;
    }
    v141 = v11[306];
    if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
    {
      v142 = *v140;
      *(_DWORD *)v226 = 136447490;
      v227 = "dnssd_proxy_dns_evaluate";
      v228 = 1024;
      *(_DWORD *)v229 = v142;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = v140;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "match";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 4094;
      _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
    }
    v143 = *v140;
    if (!*v140)
    {
      ++dnssd_query_created;
      v143 = *v140;
    }
    v144 = v143 + 1;
    *v140 = v143 + 1;
    if (v143 + 1 >= 10001)
    {
      v208 = v11[306];
      if (!os_log_type_enabled(v208, OS_LOG_TYPE_FAULT))
        goto LABEL_333;
      *(_DWORD *)v226 = 136447490;
      v227 = "dnssd_proxy_dns_evaluate";
      v228 = 1024;
      *(_DWORD *)v229 = v144;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = v140;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "match";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 4094;
      v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_331;
    }
    v139 = v140;
  }
  while (v138);
LABEL_197:
  if (!v139)
    goto LABEL_136;
  dnssd_query_cancel((uint64_t)v139);
  v145 = *(_DWORD *)v139;
  if (!*(_DWORD *)v139)
  {
    v208 = v11[306];
    if (!os_log_type_enabled(v208, OS_LOG_TYPE_FAULT))
      goto LABEL_333;
    *(_DWORD *)v226 = 136447490;
    v227 = "dnssd_proxy_dns_evaluate";
    v228 = 1024;
    *(_DWORD *)v229 = 0;
    *(_WORD *)&v229[4] = 2048;
    *(_QWORD *)&v229[6] = v139;
    *(_WORD *)&v229[14] = 2080;
    *(_QWORD *)&v229[16] = "match";
    *(_WORD *)&v229[24] = 2080;
    *(_QWORD *)&v229[26] = "dnssd-proxy.c";
    v230 = 1024;
    v231 = 4100;
    v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_331;
  }
  v21 = v11[306];
  if (v145 >= 10001)
  {
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      goto LABEL_333;
    *(_DWORD *)v226 = 136447490;
    v227 = "dnssd_proxy_dns_evaluate";
    v228 = 1024;
    *(_DWORD *)v229 = v145;
    *(_WORD *)&v229[4] = 2048;
    *(_QWORD *)&v229[6] = v139;
    *(_WORD *)&v229[14] = 2080;
    *(_QWORD *)&v229[16] = "match";
    *(_WORD *)&v229[24] = 2080;
    *(_QWORD *)&v229[26] = "dnssd-proxy.c";
    v230 = 1024;
    v231 = 4100;
    v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_318;
  }
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v226 = 136447490;
    v227 = "dnssd_proxy_dns_evaluate";
    v228 = 1024;
    *(_DWORD *)v229 = v145;
    *(_WORD *)&v229[4] = 2048;
    *(_QWORD *)&v229[6] = v139;
    *(_WORD *)&v229[14] = 2080;
    *(_QWORD *)&v229[16] = "match";
    *(_WORD *)&v229[24] = 2080;
    *(_QWORD *)&v229[26] = "dnssd-proxy.c";
    v230 = 1024;
    v231 = 4100;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
    v145 = *(_DWORD *)v139;
  }
  *(_DWORD *)v139 = v145 - 1;
  if (v145 == 1)
  {
    v146 = v11[306];
    if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v226 = 136447234;
      v227 = "dnssd_proxy_dns_evaluate";
      v228 = 2048;
      *(_QWORD *)v229 = v139;
      *(_WORD *)&v229[8] = 2080;
      *(_QWORD *)&v229[10] = "match";
      *(_WORD *)&v229[18] = 2080;
      *(_QWORD *)&v229[20] = "dnssd-proxy.c";
      *(_WORD *)&v229[28] = 1024;
      *(_DWORD *)&v229[30] = 4100;
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize(v139);
  }
LABEL_136:
  if (a3)
  {
LABEL_139:
    v103 = *(_DWORD *)a3;
    if (*(_DWORD *)a3)
    {
      v21 = v11[306];
      if (v103 < 10001)
      {
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v226 = 136447490;
          v227 = "dnssd_proxy_dns_evaluate";
          v228 = 1024;
          *(_DWORD *)v229 = v103;
          *(_WORD *)&v229[4] = 2048;
          *(_QWORD *)&v229[6] = a3;
          *(_WORD *)&v229[14] = 2080;
          *(_QWORD *)&v229[16] = "tracker";
          *(_WORD *)&v229[24] = 2080;
          *(_QWORD *)&v229[26] = "dnssd-proxy.c";
          v230 = 1024;
          v231 = 4121;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
          v103 = *(_DWORD *)a3;
        }
        *(_DWORD *)a3 = v103 - 1;
        if (v103 == 1)
        {
          v104 = v11[306];
          if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v226 = 136447234;
            v227 = "dnssd_proxy_dns_evaluate";
            v228 = 2048;
            *(_QWORD *)v229 = a3;
            *(_WORD *)&v229[8] = 2080;
            *(_QWORD *)&v229[10] = "tracker";
            *(_WORD *)&v229[18] = 2080;
            *(_QWORD *)&v229[20] = "dnssd-proxy.c";
            *(_WORD *)&v229[28] = 1024;
            *(_DWORD *)&v229[30] = 4121;
            _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
          }
          ++dp_tracker_finalized;
          dp_tracker_finalize(a3);
        }
        return;
      }
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
        goto LABEL_333;
      *(_DWORD *)v226 = 136447490;
      v227 = "dnssd_proxy_dns_evaluate";
      v228 = 1024;
      *(_DWORD *)v229 = v103;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = a3;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "tracker";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 4121;
      v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v21 = v11[306];
      if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
        goto LABEL_333;
      *(_DWORD *)v226 = 136447490;
      v227 = "dnssd_proxy_dns_evaluate";
      v228 = 1024;
      *(_DWORD *)v229 = 0;
      *(_WORD *)&v229[4] = 2048;
      *(_QWORD *)&v229[6] = a3;
      *(_WORD *)&v229[14] = 2080;
      *(_QWORD *)&v229[16] = "tracker";
      *(_WORD *)&v229[24] = 2080;
      *(_QWORD *)&v229[26] = "dnssd-proxy.c";
      v230 = 1024;
      v231 = 4121;
      v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    goto LABEL_318;
  }
}

void dp_tracker_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  _QWORD *v5;
  NSObject *v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  BOOL v12;
  NSObject *v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  NSObject *v19;
  _QWORD *v20;
  NSObject *v21;
  uint64_t v22;
  const char *v23;
  NSObject *v24;
  uint8_t buf[4];
  const char *v26;
  __int16 v27;
  _BYTE v28[34];
  __int16 v29;
  int v30;

  v3 = *(_QWORD *)(a2 + 8);
  v5 = *(_QWORD **)(a2 + 16);
  v4 = (uint64_t *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = 0;
  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_QWORD *)(a2 + 24);
    if (v7)
      LODWORD(v7) = *(_DWORD *)(v7 + 48);
    v8 = *(_DWORD *)(a2 + 4);
    if (v3)
      v9 = *(_DWORD *)(v3 + 180);
    else
      v9 = 0;
    *(_DWORD *)buf = 136447234;
    v26 = "dp_tracker_disconnected";
    v27 = 1024;
    *(_DWORD *)v28 = v8;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = v7;
    *(_WORD *)&v28[10] = 1024;
    *(_DWORD *)&v28[12] = v9;
    *(_WORD *)&v28[16] = 2048;
    *(_QWORD *)&v28[18] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][DSO%d][C%d] queries %p", buf, 0x28u);
  }
  v10 = *(_QWORD *)(a2 + 24);
  if (v10)
  {
    v11 = *(_QWORD **)(v10 + 80);
    do
    {
      if (!v11)
        break;
      dso_drop_activity(v10, v11);
      v10 = *(_QWORD *)(a2 + 24);
      v12 = *(_QWORD *)(v10 + 80) == (_QWORD)v11;
      v11 = *(_QWORD **)(v10 + 80);
    }
    while (!v12);
    dso_state_cancel(v10);
    if (*(_DWORD *)(a2 + 40) == 1)
    {
      v13 = global_os_log;
      v14 = --num_push_sessions;
      if (num_push_sessions < 0)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446210;
          v26 = "dp_tracker_went_away";
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "%{public}s: DNS Push connection count went negative", buf, 0xCu);
        }
        num_push_sessions = 0;
      }
      else if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v15 = *(_QWORD *)(a2 + 24);
        if (v15)
          LODWORD(v15) = *(_DWORD *)(v15 + 48);
        v16 = *(_DWORD *)(a2 + 4);
        v17 = *v4;
        if (*v4)
          LODWORD(v17) = *(_DWORD *)(v17 + 180);
        *(_DWORD *)buf = 136447234;
        v26 = "dp_tracker_went_away";
        v27 = 1024;
        *(_DWORD *)v28 = v16;
        *(_WORD *)&v28[4] = 1024;
        *(_DWORD *)&v28[6] = v15;
        *(_WORD *)&v28[10] = 1024;
        *(_DWORD *)&v28[12] = v17;
        *(_WORD *)&v28[16] = 1024;
        *(_DWORD *)&v28[18] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][DSO%d][C%d] dso connection count dropped: %d", buf, 0x24u);
      }
    }
    *(_DWORD *)(a2 + 40) = 0;
    *(_QWORD *)(a2 + 24) = 0;
  }
  if (v3)
  {
    ioloop_comm_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 1050);
    *v4 = 0;
  }
  if (v5)
  {
    while (1)
    {
      v18 = *(_DWORD *)v5;
      if (!*(_DWORD *)v5)
        break;
      v19 = global_os_log;
      if (v18 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v26 = "dp_tracker_disconnected";
          v27 = 1024;
          *(_DWORD *)v28 = v18;
          *(_WORD *)&v28[4] = 2048;
          *(_QWORD *)&v28[6] = v5;
          *(_WORD *)&v28[14] = 2080;
          *(_QWORD *)&v28[16] = "query";
          *(_WORD *)&v28[24] = 2080;
          *(_QWORD *)&v28[26] = "dnssd-proxy.c";
          v29 = 1024;
          v30 = 1060;
          v23 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v24 = v19;
LABEL_42:
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, v23, buf, 0x36u);
        }
        goto LABEL_43;
      }
      v20 = (_QWORD *)v5[2];
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v26 = "dp_tracker_disconnected";
        v27 = 1024;
        *(_DWORD *)v28 = v18;
        *(_WORD *)&v28[4] = 2048;
        *(_QWORD *)&v28[6] = v5;
        *(_WORD *)&v28[14] = 2080;
        *(_QWORD *)&v28[16] = "query";
        *(_WORD *)&v28[24] = 2080;
        *(_QWORD *)&v28[26] = "dnssd-proxy.c";
        v29 = 1024;
        v30 = 1060;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v18 = *(_DWORD *)v5;
      }
      *(_DWORD *)v5 = v18 - 1;
      if (v18 == 1)
      {
        v21 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v26 = "dp_tracker_disconnected";
          v27 = 2048;
          *(_QWORD *)v28 = v5;
          *(_WORD *)&v28[8] = 2080;
          *(_QWORD *)&v28[10] = "query";
          *(_WORD *)&v28[18] = 2080;
          *(_QWORD *)&v28[20] = "dnssd-proxy.c";
          *(_WORD *)&v28[28] = 1024;
          *(_DWORD *)&v28[30] = 1060;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++dnssd_query_finalized;
        dnssd_query_finalize(v5);
      }
      v5 = v20;
      if (!v20)
        return;
    }
    v22 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      v26 = "dp_tracker_disconnected";
      v27 = 1024;
      *(_DWORD *)v28 = 0;
      *(_WORD *)&v28[4] = 2048;
      *(_QWORD *)&v28[6] = v5;
      *(_WORD *)&v28[14] = 2080;
      *(_QWORD *)&v28[16] = "query";
      *(_WORD *)&v28[24] = 2080;
      *(_QWORD *)&v28[26] = "dnssd-proxy.c";
      v29 = 1024;
      v30 = 1060;
      v23 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v24 = v22;
      goto LABEL_42;
    }
LABEL_43:
    abort();
  }
}

BOOL dp_tracker_dso_state_change(int a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v6;
  _QWORD *i;
  int v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v12;
  const char *v13;
  NSObject *v14;
  _BYTE buf[48];
  __int16 v16;
  int v17;

  if (a1 == 1)
  {
    if (a2[3])
    {
      a2[3] = 0;
      v6 = a2[1];
      if (v6)
      {
        *(_QWORD *)(v6 + 272) = 0;
        ioloop_comm_cancel(v6);
      }
      for (i = (_QWORD *)a2[2]; i; i = (_QWORD *)i[2])
      {
        if (i[9] == a3)
          i[9] = 0;
        if (i[10])
        {
          i[10] = 0;
          v8 = *(_DWORD *)i;
          if (!*(_DWORD *)i)
          {
            v12 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "dp_tracker_dso_state_change";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 0;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = i;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "query";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "dnssd-proxy.c";
              v16 = 1024;
              v17 = 3980;
              v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              v14 = v12;
              goto LABEL_24;
            }
LABEL_25:
            abort();
          }
          v9 = global_os_log;
          if (v8 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "dp_tracker_dso_state_change";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v8;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = i;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "query";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "dnssd-proxy.c";
              v16 = 1024;
              v17 = 3980;
              v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              v14 = v9;
LABEL_24:
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, v13, buf, 0x36u);
            }
            goto LABEL_25;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "dp_tracker_dso_state_change";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v8;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = i;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "query";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "dnssd-proxy.c";
            v16 = 1024;
            v17 = 3980;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v8 = *(_DWORD *)i;
          }
          *(_DWORD *)i = v8 - 1;
          if (v8 == 1)
          {
            v10 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "dp_tracker_dso_state_change";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = i;
              *(_WORD *)&buf[22] = 2080;
              *(_QWORD *)&buf[24] = "query";
              *(_WORD *)&buf[32] = 2080;
              *(_QWORD *)&buf[34] = "dnssd-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 3980;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            }
            ++dnssd_query_finalized;
            dnssd_query_finalize(i);
          }
        }
      }
    }
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = __ioloop_run_async_block_invoke;
    *(_QWORD *)&buf[24] = &__block_descriptor_tmp_39;
    *(_QWORD *)&buf[32] = dp_tracker_dso_cleanup;
    *(_QWORD *)&buf[40] = 0;
    dispatch_async((dispatch_queue_t)ioloop_main_queue, buf);
  }
  return a1 == 1;
}

void dp_tracker_dso_cleanup()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *v2;
  void (*v3)(_QWORD *);
  _QWORD *v4;
  void (*v5)(void);
  NSObject *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  _QWORD *v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;

  v0 = (_QWORD *)dso_connections_needing_cleanup;
  if (dso_connections_needing_cleanup)
  {
    do
    {
      v1 = v0;
      v0 = (_QWORD *)*v0;
      v2 = (_QWORD *)v1[10];
      if (v2)
      {
        do
        {
          v4 = (_QWORD *)*v2;
          v3 = (void (*)(_QWORD *))v2[1];
          if (v3)
            v3(v2);
          free(v2);
          v2 = v4;
        }
        while (v4);
      }
      if (v1[4])
      {
        v5 = (void (*)(void))v1[5];
        if (v5)
        {
          v5();
          v1[4] = 0;
        }
      }
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *((_DWORD *)v1 + 12);
        v8 = v1[19];
        v9 = v1[1];
        *(_DWORD *)buf = 136447234;
        v12 = "dso_cleanup";
        v13 = 1024;
        v14 = v7;
        v15 = 2048;
        v16 = v1;
        v17 = 2080;
        v18 = v8;
        v19 = 2048;
        v20 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] dso_state_t finalizing - dso: %p, remote name: %s, dso->context: %p", buf, 0x30u);
      }
      v10 = (_QWORD *)v1[13];
      if (v10 != v1 + 15 && v10)
        free(v10);
      free(v1);
    }
    while (v0);
  }
  dso_connections_needing_cleanup = 0;
}

_QWORD *add_new_served_domain_with_interface(char *__s2)
{
  int v2;
  int v3;
  _BOOL4 v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  int v8;
  const char *v9;
  int v10;
  const char *v11;
  int v12;
  _QWORD *v13;
  NSObject *v14;
  _QWORD *v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  uint32_t v19;
  _QWORD *v20;
  void *v21;
  NSObject *v23;
  NSObject *v24;
  int v25;
  const char *v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;

  v2 = strcmp("local only pseudo interface", __s2);
  if (v2 && !strcmp("all locally-discoverable services pseudo interface", __s2))
  {
    v4 = 0;
    v3 = 1;
  }
  else
  {
    v3 = 0;
    v4 = strcmp("infrastructure interface", __s2) == 0;
  }
  v5 = malloc_type_calloc(1uLL, 0x18uLL, 0x10300403255E7C6uLL);
  if (!v5)
  {
    v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v25 = 136446979;
      v26 = "add_new_served_domain_with_interface";
      v27 = 2160;
      v28 = 1752392040;
      v29 = 2081;
      v30 = (uint64_t)__s2;
      v31 = 2048;
      v32 = 24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%{public}s: calloc failed - name: %{private, mask.hash}s, allocate size: %lu", (uint8_t *)&v25, 0x2Au);
    }
    return 0;
  }
  v6 = v5;
  v7 = strdup(__s2);
  *((_QWORD *)v6 + 1) = v7;
  if (!v7)
  {
    v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    v25 = 136446723;
    v26 = "add_new_served_domain_with_interface";
    v27 = 2160;
    v28 = 1752392040;
    v29 = 2081;
    v30 = (uint64_t)__s2;
    v17 = "%{public}s: strdup failed to copy interface name - interface name: %{private, mask.hash}s";
LABEL_27:
    v18 = v16;
    v19 = 32;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v25, v19);
    goto LABEL_29;
  }
  if (v2)
    v8 = v3;
  else
    v8 = 1;
  if (((v8 | v4) & 1) == 0)
  {
    *(_DWORD *)v6 = if_nametoindex(__s2);
    v6[4] = 0;
    v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
LABEL_29:
      v20 = (_QWORD *)*((_QWORD *)v6 + 2);
      if (v20)
      {
        if (*v20)
        {
          v24 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            v25 = 136446210;
            v26 = "add_new_served_domain_with_interface";
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%{public}s: multiple addresses added for this new interface", (uint8_t *)&v25, 0xCu);
            v20 = (_QWORD *)*((_QWORD *)v6 + 2);
          }
        }
        free(v20);
      }
      v21 = (void *)*((_QWORD *)v6 + 1);
      if (v21)
        free(v21);
      free(v6);
      return 0;
    }
    v25 = 136446723;
    v26 = "add_new_served_domain_with_interface";
    v27 = 2160;
    v28 = 1752392040;
    v29 = 2081;
    v30 = (uint64_t)__s2;
    v17 = "%{public}s: unexpected served domain %{private, mask.hash}s";
    goto LABEL_27;
  }
  v9 = "local.";
  if (v3)
    v9 = "default.service.arpa.";
  if (v2)
    v10 = 0;
  else
    v10 = -1;
  if (v2)
    v11 = v9;
  else
    v11 = "openthread.thread.home.arpa.";
  if (v8)
    v12 = v10;
  else
    v12 = -5;
  *(_DWORD *)v6 = v12;
  v6[4] = 0;
  v13 = new_served_domain((uint64_t)v6, v11);
  v14 = global_os_log;
  if (!v13)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_29;
    v25 = 136446979;
    v26 = "add_new_served_domain_with_interface";
    v27 = 2082;
    v28 = (uint64_t)__s2;
    v29 = 2160;
    v30 = 1752392040;
    v31 = 2081;
    v32 = (uint64_t)v11;
    v17 = "%{public}s: new_served_domain failed - interface name: %{public}s, served domain: %{private, mask.hash}s";
    v18 = v14;
    v19 = 42;
    goto LABEL_28;
  }
  v15 = v13;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v25 = 136446722;
    v26 = "add_new_served_domain_with_interface";
    v27 = 2082;
    v28 = (uint64_t)v11;
    v29 = 2082;
    v30 = (uint64_t)__s2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: new served domain added with interface - served domain: %{public}s, interface name: %{public}s", (uint8_t *)&v25, 0x20u);
  }
  return v15;
}

BOOL dnssd_hardwired_setup_for_served_domain(uint64_t a1)
{
  unint64_t v2;
  int v3;
  _DWORD *v4;
  _DWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  _BOOL8 result;
  NSObject *v11;
  uint64_t v12;
  const char *v13;
  uint8_t *v14;
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  _OWORD v22[88];
  _BYTE v23[6];
  _OWORD v24[88];

  memset(v22, 0, 512);
  if (*(_QWORD *)(a1 + 40))
  {
    memset(v24, 0, 512);
    dnssd_hardwired_add(a1, "_dns-llq._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-llq-tls._tcp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-update._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-update-tls._tcp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-query-tls._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "lb._dns-sd._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0xCu);
    dnssd_hardwired_add(a1, "b._dns-sd._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0xCu);
    dnssd_hardwired_add(a1, "db._dns-sd._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0xCu);
    memset((char *)&v24[1] + 8, 0, 32);
    v2 = (unint64_t)v22 | 0xC;
    *(_QWORD *)&v24[0] = v22;
    *((_QWORD *)&v24[0] + 1) = (unint64_t)v22 | 0xC;
    *(_QWORD *)&v24[1] = v23;
    if (uuid_name)
    {
      dns_name_to_wire_(0, (uint64_t *)v24, &uuid_name, 2110);
      v3 = 2111;
    }
    else
    {
      dns_name_to_wire_(0, (uint64_t *)v24, "ns", 2113);
      v3 = 2114;
    }
    dns_full_name_to_wire_(0, (uint64_t)v24, *(char **)(a1 + 8), v3);
    dnssd_hardwired_add(a1, (char *)&unk_10007C3B5, *(const char **)(a1 + 8), *((_QWORD *)&v24[0] + 1) - v2, (const void *)((unint64_t)v22 | 0xC), 2u);
    dns_name_to_wire_(0, (uint64_t *)v24, "postmaster", 2119);
    dns_full_name_to_wire_(0, (uint64_t)v24, *(char **)(a1 + 8), 2120);
    if (LODWORD(v24[3]) <= 1)
    {
      v4 = (_DWORD *)*((_QWORD *)&v24[0] + 1);
      if ((unint64_t)(*((_QWORD *)&v24[0] + 1) + 4) >= *(_QWORD *)&v24[1])
        goto LABEL_16;
      *((_QWORD *)&v24[0] + 1) += 4;
      *v4 = 0;
      if (LODWORD(v24[3]) > 1)
        goto LABEL_17;
      v5 = (_DWORD *)*((_QWORD *)&v24[0] + 1);
      if ((unint64_t)(*((_QWORD *)&v24[0] + 1) + 4) >= *(_QWORD *)&v24[1])
        goto LABEL_16;
      *((_QWORD *)&v24[0] + 1) += 4;
      *v5 = 538705920;
      if (LODWORD(v24[3]) > 1)
        goto LABEL_17;
      v6 = (_DWORD *)*((_QWORD *)&v24[0] + 1);
      if ((unint64_t)(*((_QWORD *)&v24[0] + 1) + 4) >= *(_QWORD *)&v24[1])
      {
LABEL_16:
        LODWORD(v24[3]) = 111;
      }
      else
      {
        *((_QWORD *)&v24[0] + 1) += 4;
        *v6 = 269352960;
        if (LODWORD(v24[3]) <= 1)
        {
          v7 = (_DWORD *)*((_QWORD *)&v24[0] + 1);
          if ((unint64_t)(*((_QWORD *)&v24[0] + 1) + 4) < *(_QWORD *)&v24[1])
          {
            *((_QWORD *)&v24[0] + 1) += 4;
            *v7 = -2142174976;
            if (LODWORD(v24[3]) <= 1)
            {
              v8 = (_DWORD *)*((_QWORD *)&v24[0] + 1);
              if ((unint64_t)(*((_QWORD *)&v24[0] + 1) + 4) < *(_QWORD *)&v24[1])
              {
                *((_QWORD *)&v24[0] + 1) += 4;
                *v8 = 2013265920;
              }
            }
          }
        }
      }
    }
LABEL_17:
    dnssd_hardwired_add(a1, (char *)&unk_10007C3B5, *(const char **)(a1 + 8), *((_QWORD *)&v24[0] + 1) - v2, (const void *)((unint64_t)v22 | 0xC), 6u);
    v9 = *(_QWORD *)(a1 + 40);
    if (v9 && *(_BYTE *)(v9 + 4) || dnssd_hardwired_setup_dns_push_for_domain(a1))
      return 1;
    v11 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      v12 = *(_QWORD *)(a1 + 8);
      v16 = 136446723;
      v17 = "dnssd_hardwired_setup_for_served_domain";
      v18 = 2160;
      v19 = 1752392040;
      v20 = 2081;
      v21 = v12;
      v13 = "%{public}s: failed to setup DNS push service for hardwired response - domain: %{private, mask.hash}s";
      v14 = (uint8_t *)&v16;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v13, v14, 0x20u);
      return 0;
    }
    return result;
  }
  v11 = global_os_log;
  result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (result)
  {
    v15 = *(_QWORD *)(a1 + 8);
    LODWORD(v24[0]) = 136446723;
    *(_QWORD *)((char *)v24 + 4) = "dnssd_hardwired_setup_for_served_domain";
    WORD6(v24[0]) = 2160;
    *(_QWORD *)((char *)v24 + 14) = 1752392040;
    WORD3(v24[1]) = 2081;
    *((_QWORD *)&v24[1] + 1) = v15;
    v13 = "%{public}s: only domain with usable interface can setup hardwired response - domain name: %{private, mask.hash}s";
    v14 = (uint8_t *)v24;
    goto LABEL_24;
  }
  return result;
}

void dnssd_hardwired_add(uint64_t a1, char *__s, const char *a3, size_t a4, const void *a5, unsigned int a6)
{
  size_t v11;
  size_t v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  char *v16;
  const char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  const char *v21;
  const char *v22;
  size_t v23;
  NSObject *v24;
  os_log_type_t v25;
  uint32_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  _QWORD *v31;
  const char *v32;
  NSObject *v33;
  uint64_t v34;
  int v35;
  NSObject *v36;
  uint64_t v37;
  int v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  unsigned int v42;
  int v43;
  uint8_t buf[4];
  const char *v46;
  __int16 v47;
  uint64_t v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  uint64_t v52;
  __int16 v53;
  uint64_t v54;
  __int16 v55;
  unsigned int v56;
  __int16 v57;
  int v58;

  v11 = strlen(__s);
  v12 = strlen(a3);
  v13 = a4 + v12 + 2 * v11;
  v14 = malloc_type_calloc(1uLL, v13 + 54, 0xDE7D6ED7uLL);
  if (!v14)
  {
    v20 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446722;
    v46 = "dnssd_hardwired_add";
    v47 = 2080;
    v48 = (uint64_t)__s;
    v49 = 2080;
    v50 = a3;
    v21 = "%{public}s: no memory for %s %s";
LABEL_10:
    v24 = v20;
    v25 = OS_LOG_TYPE_ERROR;
    v26 = 32;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v24, v25, v21, buf, v26);
    return;
  }
  v15 = v14;
  v16 = (char *)v14 + v13 + 49;
  *(_DWORD *)(v16 + 1) = 1684234849;
  v17 = v16 + 1;
  v18 = (char *)(v14 + 6);
  v14[4] = v14 + 6;
  *((_WORD *)v14 + 20) = a4;
  memcpy(v14 + 6, a5, a4);
  v15[2] = &v18[a4];
  memcpy(&v18[a4], __s, v11);
  *(_BYTE *)(v15[2] + v11) = 0;
  v19 = (char *)(v15[2] + v11 + 1);
  v15[3] = v19;
  if (v11)
  {
    snprintf(v19, v11 + v12 + 1, "%s%s", __s, a3);
  }
  else
  {
    memcpy(v19, a3, v12);
    *(_BYTE *)(v15[3] + v12) = 0;
  }
  v22 = (const char *)v15[3];
  v23 = (size_t)&v22[strlen(v22) + 1];
  if ((const char *)v23 != v17)
  {
    v20 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446722;
    v46 = "dnssd_hardwired_add";
    v47 = 2048;
    v48 = v23;
    v49 = 2048;
    v50 = v17;
    v21 = "%{public}s: %p != %p";
    goto LABEL_10;
  }
  if (*(_DWORD *)v17 == 1684234849)
  {
    *((_WORD *)v15 + 4) = a6;
    *v15 = 0;
    v30 = *(_QWORD *)(a1 + 32);
    v29 = (_QWORD *)(a1 + 32);
    v28 = v30;
    if (v30)
    {
      while (1)
      {
        v31 = (_QWORD *)v28;
        if (*(unsigned __int16 *)(v28 + 8) == a6)
        {
          v32 = *(const char **)(v28 + 24);
          if (!strcasecmp(v32, v22))
            break;
        }
        v28 = *v31;
        v29 = v31;
        if (!*v31)
          goto LABEL_30;
      }
      if (a6 <= 0x1C && ((1 << a6) & 0x10001006) != 0)
      {
        v33 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v34 = v31[2];
          v35 = *((unsigned __int16 *)v31 + 20);
          *(_DWORD *)buf = 136447747;
          v46 = "dnssd_hardwired_add";
          v47 = 2160;
          v48 = 1752392040;
          v49 = 2081;
          v50 = v32;
          v51 = 2160;
          v52 = 1752392040;
          v53 = 2081;
          v54 = v34;
          v55 = 1024;
          v56 = a6;
          v57 = 1024;
          v58 = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: inserting before %{private, mask.hash}s name %{private, mask.hash}s type %d rdlen %d", buf, 0x40u);
        }
        *v15 = v31;
      }
      else
      {
        v36 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v37 = v31[2];
          v38 = *((unsigned __int16 *)v31 + 20);
          *(_DWORD *)buf = 136447747;
          v46 = "dnssd_hardwired_add";
          v47 = 2160;
          v48 = 1752392040;
          v49 = 2081;
          v50 = v32;
          v51 = 2160;
          v52 = 1752392040;
          v53 = 2081;
          v54 = v37;
          v55 = 1024;
          v56 = a6;
          v57 = 1024;
          v58 = v38;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: superseding %{private, mask.hash}s name %{private, mask.hash}s type %d rdlen %d", buf, 0x40u);
        }
        *v15 = *v31;
        free(v31);
      }
    }
    v31 = v29;
LABEL_30:
    *v31 = v15;
    v39 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v41 = v15[2];
      v40 = (const char *)v15[3];
      v42 = *((unsigned __int16 *)v15 + 4);
      v43 = *((unsigned __int16 *)v15 + 20);
      *(_DWORD *)buf = 136447747;
      v46 = "dnssd_hardwired_add";
      v47 = 2160;
      v48 = 1752392040;
      v49 = 2081;
      v50 = v40;
      v51 = 2160;
      v52 = 1752392040;
      v53 = 2081;
      v54 = v41;
      v55 = 1024;
      v56 = v42;
      v57 = 1024;
      v58 = v43;
      v21 = "%{public}s: fullname %{private, mask.hash}s name %{private, mask.hash}s type %d rdlen %d";
      v24 = v39;
      v25 = OS_LOG_TYPE_DEFAULT;
      v26 = 64;
      goto LABEL_11;
    }
  }
  else
  {
    v27 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v46 = "dnssd_hardwired_add";
      v21 = "%{public}s: ran off the end.";
      v24 = v27;
      v25 = OS_LOG_TYPE_ERROR;
      v26 = 12;
      goto LABEL_11;
    }
  }
}

BOOL dnssd_hardwired_setup_dns_push_for_domain(uint64_t a1)
{
  uint64_t v2;
  int v3;
  _BOOL8 result;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  uint64_t v10;
  __int128 *v11;
  char *v12;
  _BYTE *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _OWORD v17[87];
  _BYTE v18[14];
  uint8_t buf[4];
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;

  v2 = *(_QWORD *)(a1 + 40);
  if (!v2 || *(_BYTE *)(v2 + 4))
  {
    v5 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    v6 = *(_QWORD *)(a1 + 8);
    *(_DWORD *)buf = 136446723;
    v20 = "dnssd_hardwired_setup_dns_push_for_domain";
    v21 = 2160;
    v22 = 1752392040;
    v23 = 2081;
    v24 = v6;
    v7 = "%{public}s: the associated interface does not enable DNS push - domain: %{private, mask.hash}s";
    v8 = v5;
    v9 = 32;
    goto LABEL_16;
  }
  if (!my_name)
  {
    v10 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446210;
    v20 = "dnssd_hardwired_setup_dns_push_for_domain";
    v7 = "%{public}s: my_name is not set";
    v8 = v10;
    v9 = 12;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v7, buf, v9);
    return 0;
  }
  memset(v17, 0, 496);
  v15 = 0u;
  v16 = 0u;
  v14 = 0u;
  v12 = (char *)v17;
  v13 = v18;
  BYTE12(v16) = 0;
  HIWORD(v16) = 0;
  v11 = &v16;
  if ((char *)v17 + 2 >= v18)
  {
    DWORD2(v15) = 111;
    LODWORD(v15) = 2164;
  }
  else
  {
    LOWORD(v17[0]) = 21763;
    v12 = (char *)v17 + 2;
  }
  if (uuid_name)
  {
    dns_name_to_wire_(0, (uint64_t *)&v11, &uuid_name, 2177);
    v3 = 2178;
  }
  else
  {
    dns_name_to_wire_(0, (uint64_t *)&v11, "ns", 2181);
    v3 = 2182;
  }
  dns_full_name_to_wire_(0, (uint64_t)&v11, *(char **)(a1 + 8), v3);
  dnssd_hardwired_add(a1, "_dns-push-tls._tcp", *(const char **)(a1 + 16), (size_t)&v12[-((unint64_t)&v16 | 0xC)], (const void *)((unint64_t)&v16 | 0xC), 0x21u);
  return 1;
}

_QWORD *new_served_domain(uint64_t a1, const char *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  size_t v6;
  _BYTE *v7;
  void *v8;
  _QWORD *v9;
  NSObject *v10;
  uint64_t v11;
  NSObject *v12;
  uint64_t v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  _BOOL4 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  int v23;
  const char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;

  v4 = malloc_type_calloc(1uLL, 0x38uLL, 0x3004060E82668uLL);
  if (!v4)
  {
    v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v23 = 136446466;
      v24 = "new_served_domain";
      v25 = 2080;
      v26 = (uint64_t)a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: Unable to allocate served domain %s", (uint8_t *)&v23, 0x16u);
    }
    return 0;
  }
  v5 = v4;
  v6 = strlen(a2);
  v7 = malloc_type_malloc(v6 + 2, 0xA189CA15uLL);
  v5[2] = v7;
  if (!v7)
  {
    v13 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    v23 = 136446466;
    v24 = "new_served_domain";
    v25 = 2080;
    v26 = (uint64_t)a2;
    v14 = "%{public}s: Unable to allocate served domain name %s";
    v15 = v13;
    goto LABEL_10;
  }
  *v7 = 46;
  v8 = (void *)(v5[2] + 1);
  v5[1] = v8;
  memcpy(v8, a2, v6 + 1);
  v9 = dns_pres_name_parse((char *)v5[1]);
  v5[3] = v9;
  v5[5] = a1;
  if (!v9)
  {
    v17 = global_os_log;
    v18 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (a1)
    {
      if (v18)
      {
        v19 = *(_QWORD *)(a1 + 8);
        v20 = v5[1];
        v23 = 136446722;
        v24 = "new_served_domain";
        v25 = 2080;
        v26 = v19;
        v27 = 2080;
        v28 = v20;
        v14 = "%{public}s: invalid domain name for interface %s: %s";
        v15 = v17;
        v16 = 32;
        goto LABEL_14;
      }
LABEL_15:
      free(v5);
      return 0;
    }
    if (!v18)
      goto LABEL_15;
    v22 = v5[1];
    v23 = 136446466;
    v24 = "new_served_domain";
    v25 = 2080;
    v26 = v22;
    v14 = "%{public}s: invalid domain name: %s";
    v15 = v17;
LABEL_10:
    v16 = 22;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v23, v16);
    goto LABEL_15;
  }
  *v5 = served_domains;
  served_domains = (uint64_t)v5;
  v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = v5[1];
    v23 = 136446723;
    v24 = "new_served_domain";
    v25 = 2160;
    v26 = 1752392040;
    v27 = 2081;
    v28 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: new served domain created - domain name: %{private, mask.hash}s", (uint8_t *)&v23, 0x20u);
  }
  return v5;
}

BOOL init_dnssd_proxy(uint64_t a1)
{
  char *v2;
  SCDynamicStoreRef v3;
  const __SCDynamicStore *v4;
  __CFString *HostNames;
  const __CFArray *v6;
  const __CFArray *v7;
  int v8;
  NSObject *v9;
  CFStringRef v10;
  unint64_t v11;
  char *v12;
  int v13;
  uint64_t v14;
  int *v15;
  NSObject *v16;
  char *v17;
  _QWORD *v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  _BOOL8 result;
  NSObject *v27;
  NSObject *v28;
  const char *v29;
  const __SCDynamicStore *v30;
  const char *v31;
  NSObject *v32;
  uint64_t v33;
  const char *v34;
  NSObject *v35;
  uint32_t v36;
  NSObject *v37;
  uint64_t v38;
  void *values;
  _BYTE buf[12];
  __int16 v41;
  char *v42;

  v2 = *(char **)(a1 + 112);
  if (v2)
  {
LABEL_4:
    dnssd_proxy_tls_port = 1;
    values = 0;
    v3 = SCDynamicStoreCreate(kCFAllocatorDefault, CFSTR("dnssd-proxy:watch for name change events"), (SCDynamicStoreCallBack)monitor_name_changes_callback, (SCDynamicStoreContext *)(v2 + 56));
    if (!v3)
    {
      v27 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "monitor_name_changes";
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%{public}s: failed to create SCDynamicStoreRef", buf, 0xCu);
      }
      goto LABEL_49;
    }
    v4 = v3;
    HostNames = (__CFString *)SCDynamicStoreKeyCreateHostNames(kCFAllocatorDefault);
    sc_dynamic_store_key_host_name = (uint64_t)HostNames;
    if (HostNames)
    {
      values = HostNames;
      v6 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      if (v6)
      {
        v7 = v6;
        if (SCDynamicStoreSetNotificationKeys(v4, v6, 0))
        {
          v8 = SCDynamicStoreSetDispatchQueue(v4, (dispatch_queue_t)&_dispatch_main_q);
          v9 = global_os_log;
          if (v8)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "monitor_name_changes";
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: Start to monitor local host name changes", buf, 0xCu);
            }
            CFRelease(v7);
            v10 = SCDynamicStoreCopyLocalHostName(0);
            if (update_my_name(v10))
            {
              if (v10)
                CFRelease(v10);
              *(_QWORD *)buf = 0;
              arc4random_buf(buf, 8uLL);
              v11 = *(_QWORD *)buf;
              uuid_name = 117;
              v12 = &byte_1000904D9;
              if (*(_QWORD *)buf)
              {
                v12 = &byte_1000904D9;
                do
                {
                  *v12++ = initialize_uuid_name_letters[v11 % 0x24];
                  if (v11 < 0x24)
                    break;
                  v11 /= 0x24uLL;
                }
                while (v12 < (char *)&unk_1000905D7);
              }
              *v12 = 0;
              if (srp_tls_init())
              {
                v13 = dnssd_proxy_num_listeners++;
                tls_listener_index = v13;
                dnssd_tls_listener_listen(0, 1);
                dnssd_hardwired_push_setup();
                if (dnssd_proxy_num_listeners >= 1)
                {
                  v14 = 0;
                  do
                  {
                    v15 = *(int **)(srp_servers + 72);
                    if (v15)
                      ioloop_listener_permitted_interface_list_set(dnssd_proxy_listeners[v14], v15);
                    v16 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      v17 = *(char **)(dnssd_proxy_listeners[v14] + 192);
                      *(_DWORD *)buf = 136446466;
                      *(_QWORD *)&buf[4] = "start_dnssd_proxy_listener";
                      v41 = 2082;
                      v42 = v17;
                      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: listener started - name: %{public}s", buf, 0x16u);
                    }
                    ++v14;
                  }
                  while (v14 < dnssd_proxy_num_listeners);
                }
                v18 = new_served_domain(0, my_name);
                if (v18)
                {
                  v19 = (uint64_t)v18;
                  v20 = add_new_served_domain_with_interface("local only pseudo interface");
                  if (!v20)
                  {
LABEL_73:
                    if (!*(_QWORD *)(v19 + 48))
                      served_domain_free(v19);
                    return 0;
                  }
                  v21 = (uint64_t)v20;
                  if (dnssd_hardwired_setup_for_served_domain((uint64_t)v20))
                  {
                    v22 = add_new_served_domain_with_interface("all locally-discoverable services pseudo interface");
                    v23 = (uint64_t)v22;
                    if (v22 && dnssd_hardwired_setup_for_served_domain((uint64_t)v22))
                    {
                      v24 = add_new_served_domain_with_interface("infrastructure interface");
                      v25 = (uint64_t)v24;
                      if (v24 && dnssd_hardwired_setup_for_served_domain((uint64_t)v24))
                        return 1;
                      goto LABEL_65;
                    }
                  }
                  else
                  {
                    v23 = 0;
                  }
                  v25 = 0;
LABEL_65:
                  if (!*(_QWORD *)(v21 + 48))
                    served_domain_free(v21);
                  if (v23 && !*(_QWORD *)(v23 + 48))
                    served_domain_free(v23);
                  if (v25 && !*(_QWORD *)(v25 + 48))
                    served_domain_free(v25);
                  goto LABEL_73;
                }
                v38 = global_os_log;
                result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
                if (!result)
                  return result;
                *(_DWORD *)buf = 136446466;
                *(_QWORD *)&buf[4] = "served_domain_init";
                v41 = 2082;
                v42 = my_name;
                v34 = "%{public}s: failed to create new served domain - domain name: %{public}s";
                v35 = v38;
                v36 = 22;
LABEL_54:
                _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
                return 0;
              }
              v33 = global_os_log;
              result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
              if (!result)
                return result;
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "init_dnssd_proxy";
              v34 = "%{public}s: srp_tls_init failed.";
LABEL_53:
              v35 = v33;
              v36 = 12;
              goto LABEL_54;
            }
            v37 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "initialize_my_name_and_monitoring";
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%{public}s: failed to update myname", buf, 0xCu);
            }
            if (v10)
              CFRelease(v10);
LABEL_51:
            v33 = global_os_log;
            result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
            if (!result)
              return result;
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "init_dnssd_proxy";
            v34 = "%{public}s: initialize_my_name_and_monitoring failed";
            goto LABEL_53;
          }
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_47;
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "monitor_name_changes";
          v31 = "%{public}s: SCDynamicStoreSetDispatchQueue failed";
        }
        else
        {
          v9 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
LABEL_47:
            CFRelease(v4);
            v30 = v7;
            goto LABEL_48;
          }
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "monitor_name_changes";
          v31 = "%{public}s: SCDynamicStoreSetNotificationKeys failed";
        }
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v31, buf, 0xCu);
        goto LABEL_47;
      }
      v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "monitor_name_changes";
        v29 = "%{public}s: failed to create CFArrayRef for monitored keys";
        goto LABEL_40;
      }
    }
    else
    {
      v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "monitor_name_changes";
        v29 = "%{public}s: failed to create SCDynamicStoreKey for host name";
LABEL_40:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
      }
    }
    v30 = v4;
LABEL_48:
    CFRelease(v30);
LABEL_49:
    v32 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "initialize_my_name_and_monitoring";
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%{public}s: failed to monitor name changes", buf, 0xCu);
    }
    goto LABEL_51;
  }
  v2 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040ED03978EuLL);
  if (v2)
  {
    *(_QWORD *)(a1 + 112) = v2;
    *((_QWORD *)v2 + 6) = a1;
    *((_QWORD *)v2 + 8) = v2;
    goto LABEL_4;
  }
  v33 = global_os_log;
  result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "init_dnssd_proxy";
    v34 = "%{public}s: no memory for advertisements";
    goto LABEL_53;
  }
  return result;
}

void monitor_name_changes_callback(const __SCDynamicStore *a1, CFArrayRef theArray, _QWORD *a3)
{
  const __CFString *v6;
  const __CFString *v7;
  BOOL updated;
  NSObject *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  uint8_t *v16;
  _DWORD *v17;
  _DWORD *v18;
  _DWORD *v19;
  _DWORD *v20;
  int v21;
  int v22;
  NSObject *v23;
  const char *v24;
  uint8_t *v25;
  NSObject *v26;
  os_log_type_t v27;
  uint32_t v28;
  NSObject *v29;
  _QWORD *v30;
  const __CFString *v31;
  uint8_t *v32;
  uint8_t *v33;
  uint8_t *v34;
  __int128 v35;
  __int128 v36;
  uint8_t v37[4];
  const char *v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  uint64_t *v42;
  uint8_t buf[16];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  _BYTE v75[6];
  CFRange v76;

  v76.length = CFArrayGetCount(theArray);
  v76.location = 0;
  if (CFArrayContainsValue(theArray, v76, (const void *)sc_dynamic_store_key_host_name))
  {
    v6 = SCDynamicStoreCopyLocalHostName(a1);
    if (v6)
    {
      v7 = v6;
      updated = update_my_name(v6);
      v9 = global_os_log;
      if (updated)
      {
        v30 = a3;
        v31 = v7;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "dnssd_hardwired_clear";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: Clearing all hardwired response", buf, 0xCu);
        }
        v10 = (_QWORD *)served_domains;
        if (served_domains)
        {
          do
          {
            v11 = (_QWORD *)v10[4];
            if (v11)
            {
              v10[4] = 0;
              do
              {
                v12 = (_QWORD *)*v11;
                free(v11);
                v11 = v12;
              }
              while (v12);
            }
            v10 = (_QWORD *)*v10;
          }
          while (v10);
          v13 = served_domains;
          if (served_domains)
          {
            v73 = 0u;
            v74 = 0u;
            v71 = 0u;
            v72 = 0u;
            v69 = 0u;
            v70 = 0u;
            v67 = 0u;
            v68 = 0u;
            v65 = 0u;
            v66 = 0u;
            v63 = 0u;
            v64 = 0u;
            v61 = 0u;
            v62 = 0u;
            v59 = 0u;
            v60 = 0u;
            v57 = 0u;
            v58 = 0u;
            v55 = 0u;
            v56 = 0u;
            v14 = (unint64_t)buf | 0xC;
            v53 = 0u;
            v54 = 0u;
            v51 = 0u;
            v52 = 0u;
            v49 = 0u;
            v50 = 0u;
            v47 = 0u;
            v48 = 0u;
            v46 = 0u;
            v44 = 0u;
            v45 = 0u;
            *(_OWORD *)buf = 0u;
            while (!*(_QWORD *)(v13 + 40))
            {
LABEL_31:
              v13 = *(_QWORD *)v13;
              if (!v13)
                goto LABEL_32;
            }
            dnssd_hardwired_add(v13, "_dns-llq._udp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-llq-tls._tcp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-update._udp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-update-tls._tcp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-push-tls._tcp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            v35 = 0u;
            v36 = 0u;
            v32 = buf;
            v33 = (uint8_t *)((unint64_t)buf | 0xC);
            v34 = v75;
            if (uuid_name)
            {
              dns_name_to_wire_(0, (uint64_t *)&v32, &uuid_name, 1874);
              v15 = 1875;
            }
            else
            {
              dns_name_to_wire_(0, (uint64_t *)&v32, "ns", 1877);
              v15 = 1878;
            }
            dns_full_name_to_wire_(0, (uint64_t)&v32, *(char **)(v13 + 8), v15);
            dnssd_hardwired_add(v13, (char *)&unk_10007C3B5, *(const char **)(v13 + 8), (size_t)&v33[-v14], (const void *)((unint64_t)buf | 0xC), 2u);
            dns_name_to_wire_(0, (uint64_t *)&v32, "postmaster", 1883);
            dns_full_name_to_wire_(0, (uint64_t)&v32, *(char **)(v13 + 8), 1884);
            if (DWORD2(v36) <= 1)
            {
              v16 = v33;
              v17 = v33 + 4;
              if (v33 + 4 >= v34)
              {
                DWORD2(v36) = 111;
                v21 = 1885;
              }
              else
              {
                v33 += 4;
                *(_DWORD *)v16 = 0;
                v18 = v17 + 1;
                if (v17 + 1 >= (_DWORD *)v34)
                {
                  DWORD2(v36) = 111;
                  v21 = 1886;
                }
                else
                {
                  v33 = (uint8_t *)(v17 + 1);
                  *v17 = 538705920;
                  v19 = v17 + 2;
                  if (v18 + 1 >= (_DWORD *)v34)
                  {
                    DWORD2(v36) = 111;
                    v21 = 1887;
                  }
                  else
                  {
                    v33 = (uint8_t *)(v18 + 1);
                    *v18 = 269352960;
                    v20 = v18 + 2;
                    if (v19 + 1 >= (_DWORD *)v34)
                    {
                      DWORD2(v36) = 111;
                      v21 = 1888;
                    }
                    else
                    {
                      v33 = (uint8_t *)(v19 + 1);
                      *v19 = -2142174976;
                      if (v19 + 2 < (_DWORD *)v34)
                      {
                        v33 = (uint8_t *)(v19 + 2);
                        *v20 = 2013265920;
                        goto LABEL_30;
                      }
                      DWORD2(v36) = 111;
                      v21 = 1889;
                    }
                  }
                }
              }
              LODWORD(v36) = v21;
            }
LABEL_30:
            dnssd_hardwired_add(v13, (char *)&unk_10007C3B5, *(const char **)(v13 + 8), (size_t)&v33[-v14], (const void *)((unint64_t)buf | 0xC), 6u);
            goto LABEL_31;
          }
        }
LABEL_32:
        dnssd_hardwired_push_setup();
        v7 = v31;
        if (!v30[1])
          goto LABEL_39;
        bzero(buf, 0x582uLL);
        v35 = 0u;
        v36 = 0u;
        v33 = &buf[12];
        v34 = v75;
        v32 = buf;
        dns_full_name_to_wire_(0, (uint64_t)&v32, (char *)local_host_name_dot_local, 5345);
        v22 = DNSServiceUpdateRecordInternal(v30[2], v30[3], (unsigned __int16)((_WORD)v33 - (unsigned __int16)&buf[12]), &buf[12], 0);
        v23 = global_os_log;
        if (v22)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v37 = 136446723;
            v38 = "monitor_name_changes_callback";
            v39 = 2160;
            v40 = 1752392040;
            v41 = 2081;
            v42 = local_host_name_dot_local;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%{public}s: DNSServiceUpdateRecord failed to update NS record to new name - name: %{private, mask.hash}s", v37, 0x20u);
            v23 = global_os_log;
          }
        }
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          goto LABEL_39;
        *(_DWORD *)v37 = 136446723;
        v38 = "monitor_name_changes_callback";
        v39 = 2160;
        v40 = 1752392040;
        v41 = 2081;
        v42 = local_host_name_dot_local;
        v24 = "%{public}s: Updating record - new NS record rdata: %{private, mask.hash}s";
        v25 = v37;
        v26 = v23;
        v27 = OS_LOG_TYPE_DEFAULT;
        v28 = 32;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_39;
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "monitor_name_changes_callback";
        v24 = "%{public}s: failed to update my name";
        v25 = buf;
        v26 = v9;
        v27 = OS_LOG_TYPE_ERROR;
        v28 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v26, v27, v24, v25, v28);
LABEL_39:
      CFRelease(v7);
      return;
    }
    v29 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "monitor_name_changes_callback";
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%{public}s: failed to get updated local host name", buf, 0xCu);
    }
  }
}

BOOL update_my_name(const __CFString *a1)
{
  size_t v2;
  size_t v3;
  size_t v4;
  uint64_t *v5;
  __darwin_ct_rune_t v6;
  __darwin_ct_rune_t v7;
  __uint32_t v8;
  uint64_t v10;
  _BOOL8 result;
  const char *v12;
  NSObject *v13;
  uint32_t v14;
  NSObject *v15;
  uint64_t v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  size_t v20;
  __int16 v21;
  uint64_t CStringPtr;
  __int16 v23;
  uint64_t *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t *v28;

  if (!a1)
  {
    strcpy((char *)local_host_name, "localhost.");
    strcpy((char *)local_host_name_dot_local, "localhost.");
    strcpy((char *)&my_name_buf, "localhost.");
    goto LABEL_20;
  }
  if (!CFStringGetCString(a1, (char *)local_host_name, 256, 0x8000100u))
  {
    v10 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446723;
    v18 = "update_my_name";
    v19 = 2160;
    v20 = 1752392040;
    v21 = 2081;
    CStringPtr = (uint64_t)CFStringGetCStringPtr(a1, 0x8000100u);
    v12 = "%{public}s: CFStringGetCString failed - local host name: %{private, mask.hash}s";
    goto LABEL_17;
  }
  v2 = strlen((const char *)local_host_name);
  v3 = v2;
  if (!v2)
  {
LABEL_14:
    __memcpy_chk(&my_name_buf, local_host_name, v3, 256);
    strcpy((char *)&my_name_buf + v3, ".home.arpa.");
    if (snprintf((char *)local_host_name_dot_local, 0x100uLL, "%s.local.", (const char *)local_host_name) >= 0x101)
    {
      v10 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      *(_DWORD *)buf = 136446722;
      v18 = "update_my_name";
      v19 = 2048;
      v20 = strlen((const char *)local_host_name) + 8;
      v21 = 2048;
      CStringPtr = 256;
      v12 = "%{public}s: snprintf failed - name length: %lu, max: %lu";
LABEL_17:
      v13 = v10;
      v14 = 32;
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
      return 0;
    }
LABEL_20:
    my_name = (char *)&my_name_buf;
    v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447491;
      v18 = "update_my_name";
      v19 = 2082;
      v20 = (size_t)"updated";
      v21 = 2160;
      CStringPtr = 1752392040;
      v23 = 2081;
      v24 = &my_name_buf;
      v25 = 2160;
      v26 = 1752392040;
      v27 = 2081;
      v28 = local_host_name_dot_local;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s my_name: %{private, mask.hash}s, local host name: %{private, mask.hash}s", buf, 0x3Eu);
    }
    return 1;
  }
  v4 = v2;
  v5 = local_host_name;
  do
  {
    v7 = *(char *)v5;
    v5 = (uint64_t *)((char *)v5 + 1);
    v6 = v7;
    if (v7 < 0)
      v8 = __maskrune(v6, 0x500uLL);
    else
      v8 = _DefaultRuneLocale.__runetype[v6] & 0x500;
    if (v6 != 45 && v8 == 0)
    {
      v16 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
      if (!result)
        return result;
      *(_DWORD *)buf = 136446466;
      v18 = "update_my_name";
      v19 = 2082;
      v20 = (size_t)local_host_name;
      v12 = "%{public}s: invalid DNS name - name: %{public}s";
      goto LABEL_26;
    }
    --v4;
  }
  while (v4);
  if (v3 - 245 > 0xFFFFFFFFFFFFFEFELL)
    goto LABEL_14;
  v16 = global_os_log;
  result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136446466;
    v18 = "update_my_name";
    v19 = 2082;
    v20 = (size_t)local_host_name;
    v12 = "%{public}s: generated name too long: %{public}s.home.arpa.";
LABEL_26:
    v13 = v16;
    v14 = 22;
    goto LABEL_18;
  }
  return result;
}

void dnssd_tls_listener_listen(uint64_t a1, int a2)
{
  NSObject *v4;
  unsigned int v5;
  _DWORD *v6;
  int *v7;
  uint64_t v8;
  double v9;
  double Current;
  double v11;
  unsigned int v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  NSObject *v16;
  os_log_type_t v17;
  uint32_t v18;
  uint64_t v19;
  NSObject *v20;
  _QWORD v21[3];
  int v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  double v26;
  __int16 v27;
  double v28;
  __int16 v29;
  double v30;

  v4 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    v24 = "dnssd_tls_listener_listen";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: starting DoT listener", buf, 0xCu);
  }
  v21[1] = 0;
  v22 = 0;
  v21[2] = 0;
  v21[0] = 28;
  if (dnssd_proxy_tls_port)
    v5 = 853;
  else
    v5 = 0;
  WORD1(v21[0]) = __rev16(v5);
  v6 = ioloop_listener_create(1, 1, a2, (uint64_t)v21, "DNS over TLS", (uint64_t)dns_proxy_input, (uint64_t)dnssd_tls_listener_restart, (uint64_t)dnssd_tls_listener_ready, (uint64_t)srp_tls_configure, 0, a1);
  dnssd_proxy_listeners[tls_listener_index] = v6;
  if (!v6)
  {
    v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    v24 = "dnssd_tls_listener_listen";
    v14 = "%{public}s: DNS Push listener: fail.";
    v16 = v15;
    v17 = OS_LOG_TYPE_ERROR;
LABEL_18:
    v18 = 12;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v16, v17, v14, buf, v18);
    return;
  }
  v7 = *(int **)(srp_servers + 72);
  if (v7)
    ioloop_listener_permitted_interface_list_set((uint64_t)v6, v7);
  dnssd_tls_key_change_notification_send();
  v8 = dnssd_proxy_listeners[tls_listener_index];
  if (!tls_listener_wakeup)
  {
    tls_listener_wakeup = (uint64_t)ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/tls-macos.c", 389);
    if (!tls_listener_wakeup)
    {
      v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        return;
      *(_DWORD *)buf = 136446210;
      v24 = "schedule_tls_certificate_rotation";
      v14 = "%{public}s: Unable to allocate wakeup in order to set up TLS certificate rotation timer.";
      v16 = v19;
      v17 = OS_LOG_TYPE_FAULT;
      goto LABEL_18;
    }
  }
  v9 = *(double *)&g_tls_identity_creation_time;
  if (*(double *)&g_tls_identity_creation_time <= 0.0)
  {
LABEL_23:
    v12 = 0;
    goto LABEL_24;
  }
  Current = CFAbsoluteTimeGetCurrent();
  v11 = v9 + 1209600.0 - Current;
  if (v11 <= 0.0)
  {
    v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446978;
      v24 = "srp_tls_get_next_rotation_time";
      v25 = 2048;
      v26 = v9;
      v27 = 2048;
      v28 = Current;
      v29 = 2048;
      v30 = v9 + 1209600.0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "%{public}s: The TLS certificate rotation date is in the past - creation date: %lf, now: %lf, rotate date: %lf.", buf, 0x2Au);
    }
    goto LABEL_23;
  }
  v12 = v11;
  if (v11 >= 0x20C49C)
  {
    v13 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      return;
    *(_DWORD *)buf = 136446466;
    v24 = "schedule_tls_certificate_rotation";
    v25 = 1024;
    LODWORD(v26) = v12;
    v14 = "%{public}s: Remaining time too long, unable to set the timer - remaining time: %u.";
    goto LABEL_27;
  }
LABEL_24:
  if (!ioloop_add_wake_event(tls_listener_wakeup, v8, (uint64_t)tls_certificate_rotate, 0, 1000 * v12))
  {
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446466;
      v24 = "schedule_tls_certificate_rotation";
      v25 = 1024;
      LODWORD(v26) = v12;
      v14 = "%{public}s: Failed to schedule the wake event for the next TLS certificate rotation - remaining_time_to_rotate: %d.";
LABEL_27:
      v16 = v13;
      v17 = OS_LOG_TYPE_FAULT;
      v18 = 18;
      goto LABEL_28;
    }
  }
}

BOOL dnssd_hardwired_push_setup()
{
  _QWORD *v0;
  uint64_t v1;
  _BOOL8 result;

  v0 = (_QWORD *)served_domains;
  if (served_domains)
  {
    do
    {
      v1 = v0[5];
      if (v1)
      {
        if (!*(_BYTE *)(v1 + 4))
          result = dnssd_hardwired_setup_dns_push_for_domain((uint64_t)v0);
      }
      v0 = (_QWORD *)*v0;
    }
    while (v0);
  }
  return result;
}

void dnssd_tls_listener_restart(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  __int16 v6;
  NSObject *v7;
  NSObject *v8;
  int *v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  os_log_type_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  NSObject *v17;
  int v18;
  const char *v19;
  __int16 v20;
  _BYTE v21[34];
  __int16 v22;
  int v23;

  v2 = dnssd_proxy_listeners[tls_listener_index];
  v3 = *(_DWORD *)(v2 + 32);
  if (!v3)
  {
    v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_28;
    v18 = 136447490;
    v19 = "ioloop_listener_release_";
    v20 = 1024;
    *(_DWORD *)v21 = 0;
    *(_WORD *)&v21[4] = 2048;
    *(_QWORD *)&v21[6] = v2;
    *(_WORD *)&v21[14] = 2080;
    *(_QWORD *)&v21[16] = "listener";
    *(_WORD *)&v21[24] = 2080;
    *(_QWORD *)&v21[26] = "dnssd-proxy.c";
    v22 = 1024;
    v23 = 4703;
    v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    v17 = v15;
    goto LABEL_27;
  }
  v4 = global_os_log;
  if (v3 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_28;
    v18 = 136447490;
    v19 = "ioloop_listener_release_";
    v20 = 1024;
    *(_DWORD *)v21 = v3;
    *(_WORD *)&v21[4] = 2048;
    *(_QWORD *)&v21[6] = v2;
    *(_WORD *)&v21[14] = 2080;
    *(_QWORD *)&v21[16] = "listener";
    *(_WORD *)&v21[24] = 2080;
    *(_QWORD *)&v21[26] = "dnssd-proxy.c";
    v22 = 1024;
    v23 = 4703;
    v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    v17 = v4;
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v16, (uint8_t *)&v18, 0x36u);
LABEL_28:
    abort();
  }
  v6 = *(_WORD *)(v2 + 416);
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v18 = 136447490;
    v19 = "ioloop_listener_release_";
    v20 = 1024;
    *(_DWORD *)v21 = v3;
    *(_WORD *)&v21[4] = 2048;
    *(_QWORD *)&v21[6] = v2;
    *(_WORD *)&v21[14] = 2080;
    *(_QWORD *)&v21[16] = "listener";
    *(_WORD *)&v21[24] = 2080;
    *(_QWORD *)&v21[26] = "dnssd-proxy.c";
    v22 = 1024;
    v23 = 4703;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
    v3 = *(_DWORD *)(v2 + 32);
  }
  *(_DWORD *)(v2 + 32) = v3 - 1;
  if (v3 == 1)
  {
    v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136447234;
      v19 = "ioloop_listener_release_";
      v20 = 2048;
      *(_QWORD *)v21 = v2;
      *(_WORD *)&v21[8] = 2080;
      *(_QWORD *)&v21[10] = "listener";
      *(_WORD *)&v21[18] = 2080;
      *(_QWORD *)&v21[20] = "dnssd-proxy.c";
      *(_WORD *)&v21[28] = 1024;
      *(_DWORD *)&v21[30] = 4703;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
    }
    ++listener_finalized;
    listener_finalize((_QWORD *)v2);
  }
  dnssd_proxy_listeners[tls_listener_index] = 0;
  if ((v6 & 0x10) != 0)
  {
    if (srp_tls_init())
    {
      dnssd_tls_key_change_notification_send();
      dnssd_tls_listener_listen(0, 0);
      return;
    }
    v10 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      v18 = 136446210;
      v19 = "dnssd_tls_listener_restart";
      v11 = "%{public}s: srp_tls_init failed.";
      v12 = v10;
      v13 = OS_LOG_TYPE_FAULT;
LABEL_21:
      _os_log_impl((void *)&_mh_execute_header, v12, v13, v11, (uint8_t *)&v18, 0xCu);
    }
  }
  else
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136446210;
      v19 = "dnssd_tls_listener_restart";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: Creation of TLS listener failed; reattempting in 10s.",
        (uint8_t *)&v18,
        0xCu);
    }
    v9 = (int *)tls_listener_wakeup;
    if (tls_listener_wakeup
      || (v9 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 4720), (tls_listener_wakeup = (uint64_t)v9) != 0))
    {
      ioloop_add_wake_event((uint64_t)v9, a2, (uint64_t)dnssd_tls_listener_relisten, 0, 0x2710u);
      return;
    }
    v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v18 = 136446210;
      v19 = "dnssd_tls_listener_restart";
      v11 = "%{public}s: Unable to allocate wakeup in order to re-attempt TLS listener creation.";
      v12 = v14;
      v13 = OS_LOG_TYPE_ERROR;
      goto LABEL_21;
    }
  }
}

void dnssd_tls_key_change_notification_send()
{
  uint32_t v0;
  uint32_t v1;
  NSObject *v2;
  uint32_t v3;
  uint32_t v4;
  NSObject *v5;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  uint32_t v11;

  if (dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token != -1)
  {
LABEL_2:
    v0 = notify_post("com.apple.srp-mdns-proxy.tls-key-update");
    if (v0)
    {
      v1 = v0;
      v2 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v6 = 136446722;
        v7 = "dnssd_tls_key_change_notification_send";
        v8 = 2080;
        v9 = "com.apple.srp-mdns-proxy.tls-key-update";
        v10 = 1024;
        v11 = v1;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%{public}s: notify_post(%s) %u", (uint8_t *)&v6, 0x1Cu);
      }
      notify_cancel(dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token);
      dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token = -1;
    }
    return;
  }
  v3 = notify_register_check("com.apple.srp-mdns-proxy.tls-key-update", &dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token);
  if (!v3)
  {
    if (dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token == -1)
      return;
    goto LABEL_2;
  }
  v4 = v3;
  dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token = -1;
  v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v6 = 136446722;
    v7 = "dnssd_tls_key_change_notification_send";
    v8 = 2080;
    v9 = "com.apple.srp-mdns-proxy.tls-key-update";
    v10 = 1024;
    v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: notify_register_check(%s) failed with %u", (uint8_t *)&v6, 0x1Cu);
  }
}

uint64_t dnssd_tls_listener_relisten(uint64_t a1)
{
  return dnssd_tls_listener_listen(a1, 0);
}

void thread_tracker_callback(uint64_t a1, int a2, int a3)
{
  NSObject *v5;
  void (*v6)(void);
  int v8;
  NSObject *v9;
  char *v10;
  int v11;
  uint64_t **i;
  NSObject *v13;
  int v14;
  NSObject *v15;
  NSObject *v16;
  const char *v17;
  _BYTE v18[48];
  __int16 v19;
  int v20;

  if (a3 == -65569)
    goto LABEL_4;
  if (a3)
  {
    if (a3 != -65563)
    {
      v13 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v18 = 136446466;
        *(_QWORD *)&v18[4] = "thread_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = a3;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: unexpected error %d", v18, 0x12u);
      }
LABEL_20:
      cti_events_discontinue(*(_QWORD *)(a1 + 40));
      *(_QWORD *)(a1 + 40) = 0;
      v14 = *(_DWORD *)a1;
      if (*(_DWORD *)a1)
      {
        v15 = global_os_log;
        if (v14 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v18 = 136447490;
            *(_QWORD *)&v18[4] = "thread_tracker_callback";
            *(_WORD *)&v18[12] = 1024;
            *(_DWORD *)&v18[14] = v14;
            *(_WORD *)&v18[18] = 2048;
            *(_QWORD *)&v18[20] = a1;
            *(_WORD *)&v18[28] = 2080;
            *(_QWORD *)&v18[30] = "tracker";
            *(_WORD *)&v18[38] = 2080;
            *(_QWORD *)&v18[40] = "thread-tracker.c";
            v19 = 1024;
            v20 = 123;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
            v14 = *(_DWORD *)a1;
          }
          *(_DWORD *)a1 = v14 - 1;
          if (v14 == 1)
          {
            v16 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v18 = 136447234;
              *(_QWORD *)&v18[4] = "thread_tracker_callback";
              *(_WORD *)&v18[12] = 2048;
              *(_QWORD *)&v18[14] = a1;
              *(_WORD *)&v18[22] = 2080;
              *(_QWORD *)&v18[24] = "tracker";
              *(_WORD *)&v18[32] = 2080;
              *(_QWORD *)&v18[34] = "thread-tracker.c";
              *(_WORD *)&v18[42] = 1024;
              *(_DWORD *)&v18[44] = 123;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v18, 0x30u);
            }
            ++thread_tracker_finalized;
            free((void *)a1);
          }
          return;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_34:
          abort();
        *(_DWORD *)v18 = 136447490;
        *(_QWORD *)&v18[4] = "thread_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = v14;
        *(_WORD *)&v18[18] = 2048;
        *(_QWORD *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(_QWORD *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(_QWORD *)&v18[40] = "thread-tracker.c";
        v19 = 1024;
        v20 = 123;
        v17 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        v15 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_34;
        *(_DWORD *)v18 = 136447490;
        *(_QWORD *)&v18[4] = "thread_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = 0;
        *(_WORD *)&v18[18] = 2048;
        *(_QWORD *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(_QWORD *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(_QWORD *)&v18[40] = "thread-tracker.c";
        v19 = 1024;
        v20 = 123;
        v17 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, v17, v18, 0x36u);
      goto LABEL_34;
    }
LABEL_4:
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v18 = 136446210;
      *(_QWORD *)&v18[4] = "thread_tracker_callback";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: disconnected", v18, 0xCu);
    }
    if (*(_QWORD *)(a1 + 24))
    {
      v6 = *(void (**)(void))(a1 + 16);
      if (v6)
        v6();
    }
    goto LABEL_20;
  }
  *(_QWORD *)v18 = 0;
  *(_QWORD *)&v18[8] = 0;
  gettimeofday((timeval *)v18, 0);
  *(_QWORD *)(a1 + 56) = 1000 * *(_QWORD *)v18 + *(_DWORD *)&v18[8] / 1000;
  if ((a2 - 1) >= 0xC)
    v8 = 0;
  else
    v8 = a2;
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = (&off_10008D288)[v8];
    *(_DWORD *)v18 = 136446722;
    *(_QWORD *)&v18[4] = "thread_tracker_callback";
    *(_WORD *)&v18[12] = 2082;
    *(_QWORD *)&v18[14] = v10;
    *(_WORD *)&v18[22] = 1024;
    *(_DWORD *)&v18[24] = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: state is: %{public}s (%d)\n ", v18, 0x1Cu);
  }
  v11 = *(_DWORD *)(a1 + 64);
  if (v11 != v8)
  {
    *(_BYTE *)(a1 + 73) = *(_BYTE *)(a1 + 72);
    *(_DWORD *)(a1 + 64) = v8;
    *(_DWORD *)(a1 + 68) = v11;
    *(_BYTE *)(a1 + 72) = (a2 & 0xFFFFFFFC) == 8;
    for (i = *(uint64_t ***)(a1 + 48); i; i = (uint64_t **)*i)
      ((void (*)(uint64_t *))i[2])(i[3]);
  }
}

void thread_tracker_callback_cancel(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD *v3;
  void (*v4)(_QWORD);

  if (a1)
  {
    v2 = (_QWORD *)(a1 + 48);
    while (1)
    {
      v3 = v2;
      v2 = (_QWORD *)*v2;
      if (!v2)
        break;
      if (v2[3] == a2)
      {
        *v3 = *v2;
        v4 = (void (*)(_QWORD))v2[1];
        if (v4)
          v4(v2[3]);
        free(v2);
        return;
      }
    }
  }
}

void srp_mdns_shared_record_remove(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  int v5;
  int v6;
  int v7;
  NSObject *v8;
  const char *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  _QWORD *v16;
  _QWORD *v17;
  BOOL v18;
  int8x16_t *v19;
  int v20;
  int v21;
  void *v22;
  int v23;
  NSObject *v24;
  uint64_t v25;
  const char *v26;
  NSObject *v27;
  os_log_type_t v28;
  uint32_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  NSObject *v34;
  _DWORD *v35;
  _BYTE buf[12];
  __int16 v37;
  _BYTE v38[34];
  __int16 v39;
  int v40;

  if (a2)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_DWORD *)a2;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
      v37 = 1024;
      *(_DWORD *)v38 = v5;
      *(_WORD *)&v38[4] = 2048;
      *(_QWORD *)&v38[6] = a2;
      *(_WORD *)&v38[14] = 2080;
      *(_QWORD *)&v38[16] = "record";
      *(_WORD *)&v38[24] = 2080;
      *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
      v39 = 1024;
      v40 = 136;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v6 = *(_DWORD *)a2;
    if (*(_DWORD *)a2)
    {
      v7 = v6 + 1;
      *(_DWORD *)a2 = v6 + 1;
      if (v6 + 1 >= 10001)
      {
        v8 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_68;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
        v37 = 1024;
        *(_DWORD *)v38 = v7;
        *(_WORD *)&v38[4] = 2048;
        *(_QWORD *)&v38[6] = a2;
        *(_WORD *)&v38[14] = 2080;
        *(_QWORD *)&v38[16] = "record";
        *(_WORD *)&v38[24] = 2080;
        *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
        v39 = 1024;
        v40 = 136;
        v9 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_67;
      }
    }
    else
    {
      ++adv_record_created;
      *(_DWORD *)a2 = 1;
    }
  }
  v10 = *(_DWORD **)(a2 + 8);
  if (v10)
  {
    v11 = *(_QWORD *)(a2 + 24);
    if (v11)
    {
      v12 = *(_QWORD *)(a1 + 16);
      v13 = global_os_log;
      if (v11 == v12)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
          v37 = 2048;
          *(_QWORD *)v38 = v10;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: removing rref %p", buf, 0x16u);
          v12 = *(_QWORD *)(a1 + 16);
          v10 = *(_DWORD **)(a2 + 8);
        }
        v14 = *(_QWORD *)(v12 + 8);
        v35 = 0;
        if (v14)
        {
          if (v10)
          {
            if (*(_DWORD *)(v14 + 36))
            {
              v15 = *(_DWORD *)(v14 + 16);
              if (v15 < 0 || (*(_DWORD *)(v14 + 20) ^ v15) != 0x12345678)
              {
                v21 = -65541;
                syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with invalid DNSServiceRef %p %08X %08X");
              }
              else
              {
                v16 = (_QWORD *)(v14 + 80);
                do
                {
                  v17 = v16;
                  v16 = (_QWORD *)*v16;
                  if (v16)
                    v18 = v16 == (_QWORD *)v10;
                  else
                    v18 = 1;
                }
                while (!v18);
                if (v16)
                {
                  *(_QWORD *)buf = 4;
                  v19 = (int8x16_t *)create_hdr(3, (size_t *)buf, &v35, 1, v14);
                  if (!*(_QWORD *)(v14 + 8))
                    v19[1].i64[0] = 0;
                  v19[1].i32[2] = v10[8];
                  *v35 = 0;
                  v20 = deliver_request(v19, v14);
                  if (!v20 || (v21 = v20, v20 == -65541))
                  {
                    *v17 = *(_QWORD *)v10;
                    ++rref_finalized;
                    v22 = (void *)*((_QWORD *)v10 + 7);
                    if (v22)
                      free(v22);
                    free(v10);
                    v23 = *(_DWORD *)a2;
                    if (*(_DWORD *)a2)
                    {
                      v8 = global_os_log;
                      if (v23 < 10001)
                      {
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 136447490;
                          *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
                          v37 = 1024;
                          *(_DWORD *)v38 = v23;
                          *(_WORD *)&v38[4] = 2048;
                          *(_QWORD *)&v38[6] = a2;
                          *(_WORD *)&v38[14] = 2080;
                          *(_QWORD *)&v38[16] = "record";
                          *(_WORD *)&v38[24] = 2080;
                          *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
                          v39 = 1024;
                          v40 = 145;
                          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                          v23 = *(_DWORD *)a2;
                        }
                        *(_DWORD *)a2 = v23 - 1;
                        if (v23 == 1)
                        {
                          v24 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136447234;
                            *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
                            v37 = 2048;
                            *(_QWORD *)v38 = a2;
                            *(_WORD *)&v38[8] = 2080;
                            *(_QWORD *)&v38[10] = "record";
                            *(_WORD *)&v38[18] = 2080;
                            *(_QWORD *)&v38[20] = "srp-mdns-proxy.c";
                            *(_WORD *)&v38[28] = 1024;
                            *(_DWORD *)&v38[30] = 145;
                            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                          }
                          ++adv_record_finalized;
                          adv_record_finalize(a2);
                        }
                        goto LABEL_53;
                      }
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 136447490;
                        *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
                        v37 = 1024;
                        *(_DWORD *)v38 = v23;
                        *(_WORD *)&v38[4] = 2048;
                        *(_QWORD *)&v38[6] = a2;
                        *(_WORD *)&v38[14] = 2080;
                        *(_QWORD *)&v38[16] = "record";
                        *(_WORD *)&v38[24] = 2080;
                        *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
                        v39 = 1024;
                        v40 = 145;
                        v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                        goto LABEL_67;
                      }
                    }
                    else
                    {
                      v8 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 136447490;
                        *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
                        v37 = 1024;
                        *(_DWORD *)v38 = 0;
                        *(_WORD *)&v38[4] = 2048;
                        *(_QWORD *)&v38[6] = a2;
                        *(_WORD *)&v38[14] = 2080;
                        *(_QWORD *)&v38[16] = "record";
                        *(_WORD *)&v38[24] = 2080;
                        *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
                        v39 = 1024;
                        v40 = 145;
                        v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_67:
                        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v9, buf, 0x36u);
                      }
                    }
LABEL_68:
                    abort();
                  }
                }
                else
                {
                  v21 = -65541;
                  syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with invalid DNSRecordRef %p %08X %08X");
                }
              }
            }
            else
            {
              v21 = -65541;
              syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with bad DNSServiceRef");
            }
            goto LABEL_50;
          }
          syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with NULL DNSRecordRef");
        }
        else
        {
          syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with NULL DNSServiceRef");
        }
        v21 = -65540;
LABEL_50:
        if (*(_BYTE *)(a2 + 52))
          goto LABEL_53;
        v30 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_53;
        v31 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
        v32 = *(_QWORD *)(a2 + 8);
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
        v37 = 2048;
        *(_QWORD *)v38 = v31;
        *(_WORD *)&v38[8] = 2048;
        *(_QWORD *)&v38[10] = a2;
        *(_WORD *)&v38[18] = 2048;
        *(_QWORD *)&v38[20] = v32;
        *(_WORD *)&v38[28] = 1024;
        *(_DWORD *)&v38[30] = v21;
        v26 = "%{public}s: DNSServiceRemoveRecord(%p, %p, %p, 0) returned %d";
        v27 = v30;
        v28 = OS_LOG_TYPE_FAULT;
        v29 = 48;
        goto LABEL_43;
      }
    }
    else
    {
      v13 = global_os_log;
    }
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
LABEL_53:
      *(_QWORD *)(a2 + 8) = 0;
      goto LABEL_54;
    }
    v25 = *(_QWORD *)(a1 + 16);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
    v37 = 2048;
    *(_QWORD *)v38 = v10;
    *(_WORD *)&v38[8] = 2048;
    *(_QWORD *)&v38[10] = v11;
    *(_WORD *)&v38[18] = 2048;
    *(_QWORD *)&v38[20] = v25;
    v26 = "%{public}s: didn't remove stale rref %p because %lx != %p";
    v27 = v13;
    v28 = OS_LOG_TYPE_DEFAULT;
    v29 = 42;
LABEL_43:
    _os_log_impl((void *)&_mh_execute_header, v27, v28, v26, buf, v29);
    goto LABEL_53;
  }
LABEL_54:
  *(_QWORD *)(a2 + 24) = 0;
  v33 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_68;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
    v37 = 1024;
    *(_DWORD *)v38 = 0;
    *(_WORD *)&v38[4] = 2048;
    *(_QWORD *)&v38[6] = a2;
    *(_WORD *)&v38[14] = 2080;
    *(_QWORD *)&v38[16] = "record";
    *(_WORD *)&v38[24] = 2080;
    *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
    v39 = 1024;
    v40 = 161;
    v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_67;
  }
  v8 = global_os_log;
  if (v33 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_68;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
    v37 = 1024;
    *(_DWORD *)v38 = v33;
    *(_WORD *)&v38[4] = 2048;
    *(_QWORD *)&v38[6] = a2;
    *(_WORD *)&v38[14] = 2080;
    *(_QWORD *)&v38[16] = "record";
    *(_WORD *)&v38[24] = 2080;
    *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
    v39 = 1024;
    v40 = 161;
    v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_67;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
    v37 = 1024;
    *(_DWORD *)v38 = v33;
    *(_WORD *)&v38[4] = 2048;
    *(_QWORD *)&v38[6] = a2;
    *(_WORD *)&v38[14] = 2080;
    *(_QWORD *)&v38[16] = "record";
    *(_WORD *)&v38[24] = 2080;
    *(_QWORD *)&v38[26] = "srp-mdns-proxy.c";
    v39 = 1024;
    v40 = 161;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v33 = *(_DWORD *)a2;
  }
  *(_DWORD *)a2 = v33 - 1;
  if (v33 == 1)
  {
    v34 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "srp_mdns_shared_record_remove";
      v37 = 2048;
      *(_QWORD *)v38 = a2;
      *(_WORD *)&v38[8] = 2080;
      *(_QWORD *)&v38[10] = "record";
      *(_WORD *)&v38[18] = 2080;
      *(_QWORD *)&v38[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v38[28] = 1024;
      *(_DWORD *)&v38[30] = 161;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_record_finalized;
    adv_record_finalize(a2);
  }
}

void adv_record_finalize(uint64_t a1)
{
  int *v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  int *v6;
  int v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  int v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  v2 = *(int **)(a1 + 32);
  if (v2)
  {
    v3 = *v2;
    if (!*v2)
    {
      v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_31;
      v12 = 136447490;
      v13 = "adv_record_finalize";
      v14 = 1024;
      *(_DWORD *)v15 = 0;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v2;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "record->update";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
      v16 = 1024;
      v17 = 171;
      v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_26:
      v11 = v9;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v12, 0x36u);
LABEL_31:
      abort();
    }
    v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_31;
      v12 = 136447490;
      v13 = "adv_record_finalize";
      v14 = 1024;
      *(_DWORD *)v15 = v3;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v2;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "record->update";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
      v16 = 1024;
      v17 = 171;
      v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_29:
      v11 = v4;
      goto LABEL_30;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136447490;
      v13 = "adv_record_finalize";
      v14 = 1024;
      *(_DWORD *)v15 = v3;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v2;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "record->update";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
      v16 = 1024;
      v17 = 171;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
      v2 = *(int **)(a1 + 32);
      v3 = *v2;
    }
    *v2 = v3 - 1;
    if (v3 == 1)
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v12 = 136447234;
        v13 = "adv_record_finalize";
        v14 = 2048;
        *(_QWORD *)v15 = v2;
        *(_WORD *)&v15[8] = 2080;
        *(_QWORD *)&v15[10] = "record->update";
        *(_WORD *)&v15[18] = 2080;
        *(_QWORD *)&v15[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v15[28] = 1024;
        *(_DWORD *)&v15[30] = 171;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
        v2 = *(int **)(a1 + 32);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v2);
    }
  }
  v6 = *(int **)(a1 + 16);
  if (!v6)
    goto LABEL_19;
  v7 = *v6;
  if (!*v6)
  {
    v9 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_31;
    v12 = 136447490;
    v13 = "adv_record_finalize";
    v14 = 1024;
    *(_DWORD *)v15 = 0;
    *(_WORD *)&v15[4] = 2048;
    *(_QWORD *)&v15[6] = v6;
    *(_WORD *)&v15[14] = 2080;
    *(_QWORD *)&v15[16] = "record->host";
    *(_WORD *)&v15[24] = 2080;
    *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
    v16 = 1024;
    v17 = 174;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_26;
  }
  v4 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_31;
    v12 = 136447490;
    v13 = "adv_record_finalize";
    v14 = 1024;
    *(_DWORD *)v15 = v7;
    *(_WORD *)&v15[4] = 2048;
    *(_QWORD *)&v15[6] = v6;
    *(_WORD *)&v15[14] = 2080;
    *(_QWORD *)&v15[16] = "record->host";
    *(_WORD *)&v15[24] = 2080;
    *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
    v16 = 1024;
    v17 = 174;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_29;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v12 = 136447490;
    v13 = "adv_record_finalize";
    v14 = 1024;
    *(_DWORD *)v15 = v7;
    *(_WORD *)&v15[4] = 2048;
    *(_QWORD *)&v15[6] = v6;
    *(_WORD *)&v15[14] = 2080;
    *(_QWORD *)&v15[16] = "record->host";
    *(_WORD *)&v15[24] = 2080;
    *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
    v16 = 1024;
    v17 = 174;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
    v6 = *(int **)(a1 + 16);
    v7 = *v6;
  }
  *v6 = v7 - 1;
  if (v7 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136447234;
      v13 = "adv_record_finalize";
      v14 = 2048;
      *(_QWORD *)v15 = v6;
      *(_WORD *)&v15[8] = 2080;
      *(_QWORD *)&v15[10] = "record->host";
      *(_WORD *)&v15[18] = 2080;
      *(_QWORD *)&v15[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v15[28] = 1024;
      *(_DWORD *)&v15[30] = 174;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
      v6 = *(int **)(a1 + 16);
    }
    ++adv_host_finalized;
    adv_host_finalize((uint64_t)v6);
  }
LABEL_19:
  free(*(void **)(a1 + 40));
  free((void *)a1);
}

void adv_update_finalize(uint64_t a1)
{
  int *v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  _QWORD *v6;
  uint64_t v7;
  int *v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  int *v12;
  int v13;
  NSObject *v14;
  int *v15;
  int v16;
  NSObject *v17;
  uint64_t v18;
  const char *v19;
  NSObject *v20;
  int v21;
  const char *v22;
  __int16 v23;
  _BYTE v24[34];
  __int16 v25;
  int v26;

  v2 = *(int **)(a1 + 8);
  if (v2)
  {
    v3 = *v2;
    if (!*v2)
    {
      v18 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_61;
      v21 = 136447490;
      v22 = "adv_update_finalize";
      v23 = 1024;
      *(_DWORD *)v24 = 0;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = v2;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "update->host";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
      v25 = 1024;
      v26 = 916;
      v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_56:
      v20 = v18;
LABEL_60:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, v19, (uint8_t *)&v21, 0x36u);
LABEL_61:
      abort();
    }
    v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_61;
      v21 = 136447490;
      v22 = "adv_update_finalize";
      v23 = 1024;
      *(_DWORD *)v24 = v3;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = v2;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "update->host";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
      v25 = 1024;
      v26 = 916;
      v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_59:
      v20 = v4;
      goto LABEL_60;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 136447490;
      v22 = "adv_update_finalize";
      v23 = 1024;
      *(_DWORD *)v24 = v3;
      *(_WORD *)&v24[4] = 2048;
      *(_QWORD *)&v24[6] = v2;
      *(_WORD *)&v24[14] = 2080;
      *(_QWORD *)&v24[16] = "update->host";
      *(_WORD *)&v24[24] = 2080;
      *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
      v25 = 1024;
      v26 = 916;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
      v2 = *(int **)(a1 + 8);
      v3 = *v2;
    }
    *v2 = v3 - 1;
    if (v3 == 1)
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136447234;
        v22 = "adv_update_finalize";
        v23 = 2048;
        *(_QWORD *)v24 = v2;
        *(_WORD *)&v24[8] = 2080;
        *(_QWORD *)&v24[10] = "update->host";
        *(_WORD *)&v24[18] = 2080;
        *(_QWORD *)&v24[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v24[28] = 1024;
        *(_DWORD *)&v24[30] = 916;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
        v2 = *(int **)(a1 + 8);
      }
      ++adv_host_finalized;
      adv_host_finalize((uint64_t)v2);
    }
  }
  v6 = *(_QWORD **)(a1 + 16);
  if (v6)
  {
    srp_parse_client_updates_free_(v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 920);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v7 = *(_QWORD *)(a1 + 32);
  if (v7)
  {
    adv_record_vec_remove_update(v7, (int *)a1);
    v8 = *(int **)(a1 + 32);
    if (v8)
    {
      v9 = *v8;
      if (!*v8)
      {
        v18 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_61;
        v21 = 136447490;
        v22 = "adv_update_finalize";
        v23 = 1024;
        *(_DWORD *)v24 = 0;
        *(_WORD *)&v24[4] = 2048;
        *(_QWORD *)&v24[6] = v8;
        *(_WORD *)&v24[14] = 2080;
        *(_QWORD *)&v24[16] = "update->remove_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
        v25 = 1024;
        v26 = 926;
        v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_56;
      }
      v4 = global_os_log;
      if (v9 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_61;
        v21 = 136447490;
        v22 = "adv_update_finalize";
        v23 = 1024;
        *(_DWORD *)v24 = v9;
        *(_WORD *)&v24[4] = 2048;
        *(_QWORD *)&v24[6] = v8;
        *(_WORD *)&v24[14] = 2080;
        *(_QWORD *)&v24[16] = "update->remove_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
        v25 = 1024;
        v26 = 926;
        v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_59;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136447490;
        v22 = "adv_update_finalize";
        v23 = 1024;
        *(_DWORD *)v24 = v9;
        *(_WORD *)&v24[4] = 2048;
        *(_QWORD *)&v24[6] = v8;
        *(_WORD *)&v24[14] = 2080;
        *(_QWORD *)&v24[16] = "update->remove_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
        v25 = 1024;
        v26 = 926;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
        v8 = *(int **)(a1 + 32);
        v9 = *v8;
      }
      *v8 = v9 - 1;
      if (v9 == 1)
      {
        v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v21 = 136447234;
          v22 = "adv_update_finalize";
          v23 = 2048;
          *(_QWORD *)v24 = v8;
          *(_WORD *)&v24[8] = 2080;
          *(_QWORD *)&v24[10] = "update->remove_addresses";
          *(_WORD *)&v24[18] = 2080;
          *(_QWORD *)&v24[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v24[28] = 1024;
          *(_DWORD *)&v24[30] = 926;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
          v8 = *(int **)(a1 + 32);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v8);
      }
    }
  }
  v11 = *(_QWORD *)(a1 + 40);
  if (v11)
  {
    adv_record_vec_remove_update(v11, (int *)a1);
    v12 = *(int **)(a1 + 40);
    if (v12)
    {
      v13 = *v12;
      if (!*v12)
      {
        v18 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_61;
        v21 = 136447490;
        v22 = "adv_update_finalize";
        v23 = 1024;
        *(_DWORD *)v24 = 0;
        *(_WORD *)&v24[4] = 2048;
        *(_QWORD *)&v24[6] = v12;
        *(_WORD *)&v24[14] = 2080;
        *(_QWORD *)&v24[16] = "update->add_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
        v25 = 1024;
        v26 = 931;
        v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_56;
      }
      v4 = global_os_log;
      if (v13 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_61;
        v21 = 136447490;
        v22 = "adv_update_finalize";
        v23 = 1024;
        *(_DWORD *)v24 = v13;
        *(_WORD *)&v24[4] = 2048;
        *(_QWORD *)&v24[6] = v12;
        *(_WORD *)&v24[14] = 2080;
        *(_QWORD *)&v24[16] = "update->add_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
        v25 = 1024;
        v26 = 931;
        v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_59;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v21 = 136447490;
        v22 = "adv_update_finalize";
        v23 = 1024;
        *(_DWORD *)v24 = v13;
        *(_WORD *)&v24[4] = 2048;
        *(_QWORD *)&v24[6] = v12;
        *(_WORD *)&v24[14] = 2080;
        *(_QWORD *)&v24[16] = "update->add_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
        v25 = 1024;
        v26 = 931;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
        v12 = *(int **)(a1 + 40);
        v13 = *v12;
      }
      *v12 = v13 - 1;
      if (v13 == 1)
      {
        v14 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v21 = 136447234;
          v22 = "adv_update_finalize";
          v23 = 2048;
          *(_QWORD *)v24 = v12;
          *(_WORD *)&v24[8] = 2080;
          *(_QWORD *)&v24[10] = "update->add_addresses";
          *(_WORD *)&v24[18] = 2080;
          *(_QWORD *)&v24[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v24[28] = 1024;
          *(_DWORD *)&v24[30] = 931;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
          v12 = *(int **)(a1 + 40);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v12);
      }
    }
  }
  adv_update_free_instance_vectors(a1);
  v15 = *(int **)(a1 + 48);
  if (!v15)
    goto LABEL_41;
  v16 = *v15;
  if (!*v15)
  {
    v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_61;
    v21 = 136447490;
    v22 = "adv_update_finalize";
    v23 = 1024;
    *(_DWORD *)v24 = 0;
    *(_WORD *)&v24[4] = 2048;
    *(_QWORD *)&v24[6] = v15;
    *(_WORD *)&v24[14] = 2080;
    *(_QWORD *)&v24[16] = "update->key";
    *(_WORD *)&v24[24] = 2080;
    *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
    v25 = 1024;
    v26 = 936;
    v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_56;
  }
  v4 = global_os_log;
  if (v16 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_61;
    v21 = 136447490;
    v22 = "adv_update_finalize";
    v23 = 1024;
    *(_DWORD *)v24 = v16;
    *(_WORD *)&v24[4] = 2048;
    *(_QWORD *)&v24[6] = v15;
    *(_WORD *)&v24[14] = 2080;
    *(_QWORD *)&v24[16] = "update->key";
    *(_WORD *)&v24[24] = 2080;
    *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
    v25 = 1024;
    v26 = 936;
    v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_59;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v21 = 136447490;
    v22 = "adv_update_finalize";
    v23 = 1024;
    *(_DWORD *)v24 = v16;
    *(_WORD *)&v24[4] = 2048;
    *(_QWORD *)&v24[6] = v15;
    *(_WORD *)&v24[14] = 2080;
    *(_QWORD *)&v24[16] = "update->key";
    *(_WORD *)&v24[24] = 2080;
    *(_QWORD *)&v24[26] = "srp-mdns-proxy.c";
    v25 = 1024;
    v26 = 936;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
    v15 = *(int **)(a1 + 48);
    v16 = *v15;
  }
  *v15 = v16 - 1;
  if (v16 == 1)
  {
    v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v21 = 136447234;
      v22 = "adv_update_finalize";
      v23 = 2048;
      *(_QWORD *)v24 = v15;
      *(_WORD *)&v24[8] = 2080;
      *(_QWORD *)&v24[10] = "update->key";
      *(_WORD *)&v24[18] = 2080;
      *(_QWORD *)&v24[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v24[28] = 1024;
      *(_DWORD *)&v24[30] = 936;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
      v15 = *(int **)(a1 + 48);
    }
    ++adv_record_finalized;
    adv_record_finalize(v15);
  }
LABEL_41:
  free((void *)a1);
}

void adv_host_finalize(uint64_t a1)
{
  int *v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  void *v6;
  int *v7;
  int v8;
  NSObject *v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  const char *v15;
  int v16;
  void *v17;
  void *v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  int v22;
  const char *v23;
  __int16 v24;
  _BYTE v25[34];
  __int16 v26;
  int v27;

  host_invalidate(a1);
  v2 = *(int **)(a1 + 96);
  if (v2)
  {
    v3 = *v2;
    if (!*v2)
    {
      v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_53;
      v22 = 136447490;
      v23 = "adv_host_finalize";
      v24 = 1024;
      *(_DWORD *)v25 = 0;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = v2;
      *(_WORD *)&v25[14] = 2080;
      *(_QWORD *)&v25[16] = "host->addresses";
      *(_WORD *)&v25[24] = 2080;
      *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
      v26 = 1024;
      v27 = 1124;
      v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_48;
    }
    v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_53;
      v22 = 136447490;
      v23 = "adv_host_finalize";
      v24 = 1024;
      *(_DWORD *)v25 = v3;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = v2;
      *(_WORD *)&v25[14] = 2080;
      *(_QWORD *)&v25[16] = "host->addresses";
      *(_WORD *)&v25[24] = 2080;
      *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
      v26 = 1024;
      v27 = 1124;
      v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_51:
      v21 = v4;
      goto LABEL_52;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v22 = 136447490;
      v23 = "adv_host_finalize";
      v24 = 1024;
      *(_DWORD *)v25 = v3;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = v2;
      *(_WORD *)&v25[14] = 2080;
      *(_QWORD *)&v25[16] = "host->addresses";
      *(_WORD *)&v25[24] = 2080;
      *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
      v26 = 1024;
      v27 = 1124;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
      v2 = *(int **)(a1 + 96);
      v3 = *v2;
    }
    *v2 = v3 - 1;
    if (v3 == 1)
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v22 = 136447234;
        v23 = "adv_host_finalize";
        v24 = 2048;
        *(_QWORD *)v25 = v2;
        *(_WORD *)&v25[8] = 2080;
        *(_QWORD *)&v25[10] = "host->addresses";
        *(_WORD *)&v25[18] = 2080;
        *(_QWORD *)&v25[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v25[28] = 1024;
        *(_DWORD *)&v25[30] = 1124;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
        v2 = *(int **)(a1 + 96);
      }
      ++adv_record_vec_finalized;
      adv_record_vec_finalize((uint64_t)v2);
    }
    *(_QWORD *)(a1 + 96) = 0;
  }
  v6 = *(void **)(a1 + 240);
  if (v6)
  {
    free(v6);
    *(_QWORD *)(a1 + 240) = 0;
  }
  v7 = *(int **)(a1 + 104);
  if (v7)
  {
    v8 = *v7;
    if (*v7)
    {
      v4 = global_os_log;
      if (v8 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v22 = 136447490;
          v23 = "adv_host_finalize";
          v24 = 1024;
          *(_DWORD *)v25 = v8;
          *(_WORD *)&v25[4] = 2048;
          *(_QWORD *)&v25[6] = v7;
          *(_WORD *)&v25[14] = 2080;
          *(_QWORD *)&v25[16] = "host->key_record";
          *(_WORD *)&v25[24] = 2080;
          *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
          v26 = 1024;
          v27 = 1133;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
          v7 = *(int **)(a1 + 104);
          v8 = *v7;
        }
        *v7 = v8 - 1;
        if (v8 == 1)
        {
          v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v22 = 136447234;
            v23 = "adv_host_finalize";
            v24 = 2048;
            *(_QWORD *)v25 = v7;
            *(_WORD *)&v25[8] = 2080;
            *(_QWORD *)&v25[10] = "host->key_record";
            *(_WORD *)&v25[18] = 2080;
            *(_QWORD *)&v25[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v25[28] = 1024;
            *(_DWORD *)&v25[30] = 1133;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
            v7 = *(int **)(a1 + 104);
          }
          ++adv_record_finalized;
          adv_record_finalize(v7);
        }
        *(_QWORD *)(a1 + 104) = 0;
        goto LABEL_23;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_53:
        abort();
      v22 = 136447490;
      v23 = "adv_host_finalize";
      v24 = 1024;
      *(_DWORD *)v25 = v8;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = v7;
      *(_WORD *)&v25[14] = 2080;
      *(_QWORD *)&v25[16] = "host->key_record";
      *(_WORD *)&v25[24] = 2080;
      *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
      v26 = 1024;
      v27 = 1133;
      v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_51;
    }
    v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_53;
    v22 = 136447490;
    v23 = "adv_host_finalize";
    v24 = 1024;
    *(_DWORD *)v25 = 0;
    *(_WORD *)&v25[4] = 2048;
    *(_QWORD *)&v25[6] = v7;
    *(_WORD *)&v25[14] = 2080;
    *(_QWORD *)&v25[16] = "host->key_record";
    *(_WORD *)&v25[24] = 2080;
    *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
    v26 = 1024;
    v27 = 1133;
    v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_48:
    v21 = v19;
LABEL_52:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v20, (uint8_t *)&v22, 0x36u);
    goto LABEL_53;
  }
LABEL_23:
  v10 = *(int **)(a1 + 72);
  if (v10)
  {
    ioloop_message_release_(v10, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1138);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v11 = *(_QWORD *)(a1 + 32);
  if (v11)
  {
    ioloop_cancel_wake_event(v11);
    ioloop_wakeup_release_(*(_QWORD **)(a1 + 32), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1145);
    *(_QWORD *)(a1 + 32) = 0;
  }
  v12 = *(_QWORD *)(a1 + 24);
  if (v12)
  {
    ioloop_cancel_wake_event(v12);
    ioloop_wakeup_release_(*(_QWORD **)(a1 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1151);
    *(_QWORD *)(a1 + 24) = 0;
  }
  v13 = *(_QWORD *)(a1 + 16);
  if (v13)
  {
    ioloop_cancel_wake_event(v13);
    ioloop_wakeup_release_(*(_QWORD **)(a1 + 16), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1157);
    *(_QWORD *)(a1 + 16) = 0;
  }
  v14 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v15 = *(const char **)(a1 + 56);
    if (!v15)
      v15 = "<null>";
    v16 = *(_DWORD *)(a1 + 184);
    v22 = 136446979;
    v23 = "adv_host_finalize";
    v24 = 2160;
    *(_QWORD *)v25 = 1752392040;
    *(_WORD *)&v25[8] = 2081;
    *(_QWORD *)&v25[10] = v15;
    *(_WORD *)&v25[18] = 1024;
    *(_DWORD *)&v25[20] = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: removed %{private, mask.hash}s, key_id %x", (uint8_t *)&v22, 0x26u);
  }
  v18 = *(void **)(a1 + 56);
  v17 = *(void **)(a1 + 64);
  if (v17 == v18)
  {
    v17 = 0;
    *(_QWORD *)(a1 + 64) = 0;
  }
  if (v18)
  {
    free(v18);
    v17 = *(void **)(a1 + 64);
  }
  if (v17)
    free(v17);
  free((void *)a1);
}

void host_invalidate(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  uint64_t v14;
  int *v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  int *v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  int *v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  uint8_t buf[4];
  const char *v30;
  __int16 v31;
  _BYTE v32[34];
  __int16 v33;
  int v34;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2)
    ioloop_cancel_wake_event(v2);
  v3 = *(_QWORD *)(a1 + 16);
  if (v3)
    ioloop_cancel_wake_event(v3);
  v4 = *(_QWORD *)(a1 + 96);
  if (v4)
  {
    if (*(int *)(v4 + 4) >= 1)
    {
      for (i = 0; i < *(int *)(v4 + 4); ++i)
      {
        v6 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * i);
        if (v6)
        {
          v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v8 = *(_QWORD *)(a1 + 64);
            *(_DWORD *)buf = 136446723;
            v30 = "host_addr_free";
            v31 = 2160;
            *(_QWORD *)v32 = 1752392040;
            *(_WORD *)&v32[8] = 2081;
            *(_QWORD *)&v32[10] = v8;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: Removing AAAA record for %{private, mask.hash}s", buf, 0x20u);
            v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 8 * i);
          }
          srp_mdns_shared_record_remove(*(_QWORD *)(a1 + 8), v6);
          v9 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8);
          v10 = *(int **)(v9 + 8 * i);
          if (v10)
          {
            v11 = *v10;
            if (!*v10)
            {
              v26 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_75;
              *(_DWORD *)buf = 136447490;
              v30 = "host_addr_free";
              v31 = 1024;
              *(_DWORD *)v32 = 0;
              *(_WORD *)&v32[4] = 2048;
              *(_QWORD *)&v32[6] = v10;
              *(_WORD *)&v32[14] = 2080;
              *(_QWORD *)&v32[16] = "host->addresses->vec[i]";
              *(_WORD *)&v32[24] = 2080;
              *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
              v33 = 1024;
              v34 = 1072;
              v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_58;
            }
            v12 = global_os_log;
            if (v11 >= 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136447490;
                v30 = "host_addr_free";
                v31 = 1024;
                *(_DWORD *)v32 = v11;
                *(_WORD *)&v32[4] = 2048;
                *(_QWORD *)&v32[6] = v10;
                *(_WORD *)&v32[14] = 2080;
                *(_QWORD *)&v32[16] = "host->addresses->vec[i]";
                *(_WORD *)&v32[24] = 2080;
                *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
                v33 = 1024;
                v34 = 1072;
                v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                v28 = v12;
                goto LABEL_74;
              }
              goto LABEL_75;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              v30 = "host_addr_free";
              v31 = 1024;
              *(_DWORD *)v32 = v11;
              *(_WORD *)&v32[4] = 2048;
              *(_QWORD *)&v32[6] = v10;
              *(_WORD *)&v32[14] = 2080;
              *(_QWORD *)&v32[16] = "host->addresses->vec[i]";
              *(_WORD *)&v32[24] = 2080;
              *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
              v33 = 1024;
              v34 = 1072;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              v9 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8);
              v10 = *(int **)(v9 + 8 * i);
              v11 = *v10;
            }
            *v10 = v11 - 1;
            if (v11 == 1)
            {
              v13 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                v30 = "host_addr_free";
                v31 = 2048;
                *(_QWORD *)v32 = v10;
                *(_WORD *)&v32[8] = 2080;
                *(_QWORD *)&v32[10] = "host->addresses->vec[i]";
                *(_WORD *)&v32[18] = 2080;
                *(_QWORD *)&v32[20] = "srp-mdns-proxy.c";
                *(_WORD *)&v32[28] = 1024;
                *(_DWORD *)&v32[30] = 1072;
                _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                v10 = *(int **)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 8 * i);
              }
              ++adv_record_finalized;
              adv_record_finalize(v10);
              v9 = *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8);
            }
          }
          *(_QWORD *)(v9 + 8 * i) = 0;
          v4 = *(_QWORD *)(a1 + 96);
        }
      }
    }
    *(_DWORD *)(v4 + 4) = 0;
  }
  v14 = *(_QWORD *)(a1 + 112);
  if (v14)
  {
    adv_instances_cancel(v14);
    v15 = *(int **)(a1 + 112);
    if (v15)
    {
      v16 = *v15;
      if (!*v15)
      {
        v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_75;
        *(_DWORD *)buf = 136447490;
        v30 = "host_invalidate";
        v31 = 1024;
        *(_DWORD *)v32 = 0;
        *(_WORD *)&v32[4] = 2048;
        *(_QWORD *)&v32[6] = v15;
        *(_WORD *)&v32[14] = 2080;
        *(_QWORD *)&v32[16] = "host->instances";
        *(_WORD *)&v32[24] = 2080;
        *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
        v33 = 1024;
        v34 = 1098;
        v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_58;
      }
      v17 = global_os_log;
      if (v16 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_75;
        *(_DWORD *)buf = 136447490;
        v30 = "host_invalidate";
        v31 = 1024;
        *(_DWORD *)v32 = v16;
        *(_WORD *)&v32[4] = 2048;
        *(_QWORD *)&v32[6] = v15;
        *(_WORD *)&v32[14] = 2080;
        *(_QWORD *)&v32[16] = "host->instances";
        *(_WORD *)&v32[24] = 2080;
        *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
        v33 = 1024;
        v34 = 1098;
        v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_73;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v30 = "host_invalidate";
        v31 = 1024;
        *(_DWORD *)v32 = v16;
        *(_WORD *)&v32[4] = 2048;
        *(_QWORD *)&v32[6] = v15;
        *(_WORD *)&v32[14] = 2080;
        *(_QWORD *)&v32[16] = "host->instances";
        *(_WORD *)&v32[24] = 2080;
        *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
        v33 = 1024;
        v34 = 1098;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v15 = *(int **)(a1 + 112);
        v16 = *v15;
      }
      *v15 = v16 - 1;
      if (v16 == 1)
      {
        v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v30 = "host_invalidate";
          v31 = 2048;
          *(_QWORD *)v32 = v15;
          *(_WORD *)&v32[8] = 2080;
          *(_QWORD *)&v32[10] = "host->instances";
          *(_WORD *)&v32[18] = 2080;
          *(_QWORD *)&v32[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v32[28] = 1024;
          *(_DWORD *)&v32[30] = 1098;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v15 = *(int **)(a1 + 112);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v15);
      }
    }
    *(_QWORD *)(a1 + 112) = 0;
  }
  v19 = *(int **)(a1 + 48);
  if (v19)
  {
    v20 = *v19;
    if (!*v19)
    {
      v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_75;
      *(_DWORD *)buf = 136447490;
      v30 = "host_invalidate";
      v31 = 1024;
      *(_DWORD *)v32 = 0;
      *(_WORD *)&v32[4] = 2048;
      *(_QWORD *)&v32[6] = v19;
      *(_WORD *)&v32[14] = 2080;
      *(_QWORD *)&v32[16] = "host->update";
      *(_WORD *)&v32[24] = 2080;
      *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
      v33 = 1024;
      v34 = 1103;
      v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_58;
    }
    v17 = global_os_log;
    if (v20 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_75;
      *(_DWORD *)buf = 136447490;
      v30 = "host_invalidate";
      v31 = 1024;
      *(_DWORD *)v32 = v20;
      *(_WORD *)&v32[4] = 2048;
      *(_QWORD *)&v32[6] = v19;
      *(_WORD *)&v32[14] = 2080;
      *(_QWORD *)&v32[16] = "host->update";
      *(_WORD *)&v32[24] = 2080;
      *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
      v33 = 1024;
      v34 = 1103;
      v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_73;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v30 = "host_invalidate";
      v31 = 1024;
      *(_DWORD *)v32 = v20;
      *(_WORD *)&v32[4] = 2048;
      *(_QWORD *)&v32[6] = v19;
      *(_WORD *)&v32[14] = 2080;
      *(_QWORD *)&v32[16] = "host->update";
      *(_WORD *)&v32[24] = 2080;
      *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
      v33 = 1024;
      v34 = 1103;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v19 = *(int **)(a1 + 48);
      v20 = *v19;
    }
    *v19 = v20 - 1;
    if (v20 == 1)
    {
      v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v30 = "host_invalidate";
        v31 = 2048;
        *(_QWORD *)v32 = v19;
        *(_WORD *)&v32[8] = 2080;
        *(_QWORD *)&v32[10] = "host->update";
        *(_WORD *)&v32[18] = 2080;
        *(_QWORD *)&v32[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v32[28] = 1024;
        *(_DWORD *)&v32[30] = 1103;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v19 = *(int **)(a1 + 48);
      }
      ++adv_update_finalized;
      adv_update_finalize(v19);
    }
    *(_QWORD *)(a1 + 48) = 0;
  }
  v22 = *(_QWORD *)(a1 + 104);
  if (v22)
  {
    srp_mdns_shared_record_remove(*(_QWORD *)(a1 + 8), v22);
    v23 = *(int **)(a1 + 104);
    if (!v23)
    {
LABEL_54:
      *(_QWORD *)(a1 + 104) = 0;
      goto LABEL_55;
    }
    v24 = *v23;
    if (*v23)
    {
      v17 = global_os_log;
      if (v24 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v30 = "host_invalidate";
          v31 = 1024;
          *(_DWORD *)v32 = v24;
          *(_WORD *)&v32[4] = 2048;
          *(_QWORD *)&v32[6] = v23;
          *(_WORD *)&v32[14] = 2080;
          *(_QWORD *)&v32[16] = "host->key_record";
          *(_WORD *)&v32[24] = 2080;
          *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
          v33 = 1024;
          v34 = 1108;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v23 = *(int **)(a1 + 104);
          v24 = *v23;
        }
        *v23 = v24 - 1;
        if (v24 == 1)
        {
          v25 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v30 = "host_invalidate";
            v31 = 2048;
            *(_QWORD *)v32 = v23;
            *(_WORD *)&v32[8] = 2080;
            *(_QWORD *)&v32[10] = "host->key_record";
            *(_WORD *)&v32[18] = 2080;
            *(_QWORD *)&v32[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v32[28] = 1024;
            *(_DWORD *)&v32[30] = 1108;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            v23 = *(int **)(a1 + 104);
          }
          ++adv_record_finalized;
          adv_record_finalize(v23);
        }
        goto LABEL_54;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_75;
      *(_DWORD *)buf = 136447490;
      v30 = "host_invalidate";
      v31 = 1024;
      *(_DWORD *)v32 = v24;
      *(_WORD *)&v32[4] = 2048;
      *(_QWORD *)&v32[6] = v23;
      *(_WORD *)&v32[14] = 2080;
      *(_QWORD *)&v32[16] = "host->key_record";
      *(_WORD *)&v32[24] = 2080;
      *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
      v33 = 1024;
      v34 = 1108;
      v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_73:
      v28 = v17;
LABEL_74:
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v27, buf, 0x36u);
LABEL_75:
      abort();
    }
    v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_75;
    *(_DWORD *)buf = 136447490;
    v30 = "host_invalidate";
    v31 = 1024;
    *(_DWORD *)v32 = 0;
    *(_WORD *)&v32[4] = 2048;
    *(_QWORD *)&v32[6] = v23;
    *(_WORD *)&v32[14] = 2080;
    *(_QWORD *)&v32[16] = "host->key_record";
    *(_WORD *)&v32[24] = 2080;
    *(_QWORD *)&v32[26] = "srp-mdns-proxy.c";
    v33 = 1024;
    v34 = 1108;
    v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_58:
    v28 = v26;
    goto LABEL_74;
  }
LABEL_55:
  *(_QWORD *)(a1 + 48) = 0;
  *(_BYTE *)(a1 + 264) = 1;
}

void adv_record_vec_finalize(uint64_t a1)
{
  int v2;
  uint64_t i;
  uint64_t v4;
  int *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD *)(a1 + 8);
      v5 = *(int **)(v4 + 8 * i);
      if (v5)
      {
        v6 = *v5;
        if (!*v5)
        {
          v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v13 = "adv_record_vec_finalize";
            v14 = 1024;
            *(_DWORD *)v15 = 0;
            *(_WORD *)&v15[4] = 2048;
            *(_QWORD *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(_QWORD *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
            v16 = 1024;
            v17 = 311;
            v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            v11 = v9;
            goto LABEL_19;
          }
LABEL_20:
          abort();
        }
        v7 = global_os_log;
        if (v6 >= 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v13 = "adv_record_vec_finalize";
            v14 = 1024;
            *(_DWORD *)v15 = v6;
            *(_WORD *)&v15[4] = 2048;
            *(_QWORD *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(_QWORD *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
            v16 = 1024;
            v17 = 311;
            v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            v11 = v7;
LABEL_19:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
          }
          goto LABEL_20;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v13 = "adv_record_vec_finalize";
          v14 = 1024;
          *(_DWORD *)v15 = v6;
          *(_WORD *)&v15[4] = 2048;
          *(_QWORD *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(_QWORD *)&v15[16] = "vec->vec[i]";
          *(_WORD *)&v15[24] = 2080;
          *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
          v16 = 1024;
          v17 = 311;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v4 = *(_QWORD *)(a1 + 8);
          v5 = *(int **)(v4 + 8 * i);
          v6 = *v5;
        }
        *v5 = v6 - 1;
        if (v6 == 1)
        {
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v13 = "adv_record_vec_finalize";
            v14 = 2048;
            *(_QWORD *)v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(_QWORD *)&v15[10] = "vec->vec[i]";
            *(_WORD *)&v15[18] = 2080;
            *(_QWORD *)&v15[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 311;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            v5 = *(int **)(*(_QWORD *)(a1 + 8) + 8 * i);
          }
          ++adv_record_finalized;
          adv_record_finalize(v5);
          v4 = *(_QWORD *)(a1 + 8);
        }
        *(_QWORD *)(v4 + 8 * i) = 0;
        v2 = *(_DWORD *)(a1 + 4);
      }
    }
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
}

void adv_instances_cancel(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (*(int *)(a1 + 4) >= 1)
  {
    v2 = 0;
    do
    {
      v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v2);
      if (v3)
      {
        v4 = *(_QWORD *)(v3 + 8);
        if (v4)
        {
          ioloop_dnssd_txn_cancel(v4);
          ioloop_dnssd_txn_release_(*(int **)(v3 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 873);
          *(_QWORD *)(v3 + 8) = 0;
        }
        v5 = *(_QWORD *)(v3 + 40);
        if (v5)
        {
          ioloop_cancel_wake_event(v5);
          ioloop_wakeup_release_(*(_QWORD **)(v3 + 40), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 878);
          *(_QWORD *)(v3 + 40) = 0;
        }
      }
      ++v2;
    }
    while (v2 < *(int *)(a1 + 4));
  }
}

void adv_instance_vec_finalize(uint64_t a1)
{
  int v2;
  uint64_t i;
  uint64_t v4;
  int *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    for (i = 0; i < v2; ++i)
    {
      v4 = *(_QWORD *)(a1 + 8);
      v5 = *(int **)(v4 + 8 * i);
      if (v5)
      {
        v6 = *v5;
        if (!*v5)
        {
          v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v13 = "adv_instance_vec_finalize";
            v14 = 1024;
            *(_DWORD *)v15 = 0;
            *(_WORD *)&v15[4] = 2048;
            *(_QWORD *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(_QWORD *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
            v16 = 1024;
            v17 = 307;
            v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            v11 = v9;
            goto LABEL_19;
          }
LABEL_20:
          abort();
        }
        v7 = global_os_log;
        if (v6 >= 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v13 = "adv_instance_vec_finalize";
            v14 = 1024;
            *(_DWORD *)v15 = v6;
            *(_WORD *)&v15[4] = 2048;
            *(_QWORD *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(_QWORD *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
            v16 = 1024;
            v17 = 307;
            v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            v11 = v7;
LABEL_19:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
          }
          goto LABEL_20;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v13 = "adv_instance_vec_finalize";
          v14 = 1024;
          *(_DWORD *)v15 = v6;
          *(_WORD *)&v15[4] = 2048;
          *(_QWORD *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(_QWORD *)&v15[16] = "vec->vec[i]";
          *(_WORD *)&v15[24] = 2080;
          *(_QWORD *)&v15[26] = "srp-mdns-proxy.c";
          v16 = 1024;
          v17 = 307;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v4 = *(_QWORD *)(a1 + 8);
          v5 = *(int **)(v4 + 8 * i);
          v6 = *v5;
        }
        *v5 = v6 - 1;
        if (v6 == 1)
        {
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v13 = "adv_instance_vec_finalize";
            v14 = 2048;
            *(_QWORD *)v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(_QWORD *)&v15[10] = "vec->vec[i]";
            *(_WORD *)&v15[18] = 2080;
            *(_QWORD *)&v15[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 307;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            v5 = *(int **)(*(_QWORD *)(a1 + 8) + 8 * i);
          }
          ++adv_instance_finalized;
          adv_instance_finalize(v5);
          v4 = *(_QWORD *)(a1 + 8);
        }
        *(_QWORD *)(v4 + 8 * i) = 0;
        v2 = *(_DWORD *)(a1 + 4);
      }
    }
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
}

void adv_instance_finalize(void *a1)
{
  uint64_t v2;
  void *v3;
  void *v4;
  void *v5;
  int *v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  int *v10;
  int *v11;
  int v12;
  NSObject *v13;
  _QWORD *v14;
  uint64_t v15;
  const char *v16;
  NSObject *v17;
  int v18;
  const char *v19;
  __int16 v20;
  _BYTE v21[34];
  __int16 v22;
  int v23;

  v2 = *((_QWORD *)a1 + 1);
  if (v2)
  {
    ioloop_dnssd_txn_cancel(v2);
    ioloop_dnssd_txn_release_(*((int **)a1 + 1), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 186);
  }
  v3 = (void *)*((_QWORD *)a1 + 9);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)a1 + 6);
  if (v4)
    free(v4);
  v5 = (void *)*((_QWORD *)a1 + 7);
  if (v5)
    free(v5);
  v6 = (int *)*((_QWORD *)a1 + 3);
  if (v6)
  {
    v7 = *v6;
    if (!*v6)
    {
      v15 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_45;
      v18 = 136447490;
      v19 = "adv_instance_finalize";
      v20 = 1024;
      *(_DWORD *)v21 = 0;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = v6;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "instance->host";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "srp-mdns-proxy.c";
      v22 = 1024;
      v23 = 198;
      v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_40;
    }
    v8 = global_os_log;
    if (v7 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_45;
      v18 = 136447490;
      v19 = "adv_instance_finalize";
      v20 = 1024;
      *(_DWORD *)v21 = v7;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = v6;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "instance->host";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "srp-mdns-proxy.c";
      v22 = 1024;
      v23 = 198;
      v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_43:
      v17 = v8;
      goto LABEL_44;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136447490;
      v19 = "adv_instance_finalize";
      v20 = 1024;
      *(_DWORD *)v21 = v7;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = v6;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "instance->host";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "srp-mdns-proxy.c";
      v22 = 1024;
      v23 = 198;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
      v6 = (int *)*((_QWORD *)a1 + 3);
      v7 = *v6;
    }
    *v6 = v7 - 1;
    if (v7 == 1)
    {
      v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v18 = 136447234;
        v19 = "adv_instance_finalize";
        v20 = 2048;
        *(_QWORD *)v21 = v6;
        *(_WORD *)&v21[8] = 2080;
        *(_QWORD *)&v21[10] = "instance->host";
        *(_WORD *)&v21[18] = 2080;
        *(_QWORD *)&v21[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v21[28] = 1024;
        *(_DWORD *)&v21[30] = 198;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
        v6 = (int *)*((_QWORD *)a1 + 3);
      }
      ++adv_host_finalized;
      adv_host_finalize(v6);
    }
    *((_QWORD *)a1 + 3) = 0;
  }
  v10 = (int *)*((_QWORD *)a1 + 11);
  if (v10)
  {
    ioloop_message_release_(v10, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 202);
    *((_QWORD *)a1 + 11) = 0;
  }
  v11 = (int *)*((_QWORD *)a1 + 4);
  if (v11)
  {
    v12 = *v11;
    if (*v11)
    {
      v8 = global_os_log;
      if (v12 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v18 = 136447490;
          v19 = "adv_instance_finalize";
          v20 = 1024;
          *(_DWORD *)v21 = v12;
          *(_WORD *)&v21[4] = 2048;
          *(_QWORD *)&v21[6] = v11;
          *(_WORD *)&v21[14] = 2080;
          *(_QWORD *)&v21[16] = "instance->update";
          *(_WORD *)&v21[24] = 2080;
          *(_QWORD *)&v21[26] = "srp-mdns-proxy.c";
          v22 = 1024;
          v23 = 206;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
          v11 = (int *)*((_QWORD *)a1 + 4);
          v12 = *v11;
        }
        *v11 = v12 - 1;
        if (v12 == 1)
        {
          v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v18 = 136447234;
            v19 = "adv_instance_finalize";
            v20 = 2048;
            *(_QWORD *)v21 = v11;
            *(_WORD *)&v21[8] = 2080;
            *(_QWORD *)&v21[10] = "instance->update";
            *(_WORD *)&v21[18] = 2080;
            *(_QWORD *)&v21[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v21[28] = 1024;
            *(_DWORD *)&v21[30] = 206;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
            v11 = (int *)*((_QWORD *)a1 + 4);
          }
          ++adv_update_finalized;
          adv_update_finalize(v11);
        }
        *((_QWORD *)a1 + 4) = 0;
        goto LABEL_31;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_45:
        abort();
      v18 = 136447490;
      v19 = "adv_instance_finalize";
      v20 = 1024;
      *(_DWORD *)v21 = v12;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = v11;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "instance->update";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "srp-mdns-proxy.c";
      v22 = 1024;
      v23 = 206;
      v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_43;
    }
    v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_45;
    v18 = 136447490;
    v19 = "adv_instance_finalize";
    v20 = 1024;
    *(_DWORD *)v21 = 0;
    *(_WORD *)&v21[4] = 2048;
    *(_QWORD *)&v21[6] = v11;
    *(_WORD *)&v21[14] = 2080;
    *(_QWORD *)&v21[16] = "instance->update";
    *(_WORD *)&v21[24] = 2080;
    *(_QWORD *)&v21[26] = "srp-mdns-proxy.c";
    v22 = 1024;
    v23 = 206;
    v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_40:
    v17 = v15;
LABEL_44:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v16, (uint8_t *)&v18, 0x36u);
    goto LABEL_45;
  }
LABEL_31:
  v14 = (_QWORD *)*((_QWORD *)a1 + 5);
  if (v14)
    ioloop_wakeup_release_(v14, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 210);
  free(a1);
}

void adv_record_vec_remove_update(uint64_t a1, int *a2)
{
  int v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v10;
  NSObject *v11;
  int *v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  _BYTE v20[34];
  __int16 v21;
  int v22;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v5 = 0;
    v6 = *(_QWORD *)(a1 + 8);
    do
    {
      v7 = *(_QWORD *)(v6 + 8 * v5);
      if (v7)
      {
        v8 = *(int **)(v7 + 32);
        if (v8 && v8 == a2)
        {
          v10 = *a2;
          if (!*a2)
          {
            v14 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v18 = "adv_record_vec_remove_update";
              v19 = 1024;
              *(_DWORD *)v20 = 0;
              *(_WORD *)&v20[4] = 2048;
              *(_QWORD *)&v20[6] = a2;
              *(_WORD *)&v20[14] = 2080;
              *(_QWORD *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(_QWORD *)&v20[26] = "srp-mdns-proxy.c";
              v21 = 1024;
              v22 = 848;
              v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              v16 = v14;
              goto LABEL_25;
            }
LABEL_26:
            abort();
          }
          v11 = global_os_log;
          if (v10 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v18 = "adv_record_vec_remove_update";
              v19 = 1024;
              *(_DWORD *)v20 = v10;
              *(_WORD *)&v20[4] = 2048;
              *(_QWORD *)&v20[6] = a2;
              *(_WORD *)&v20[14] = 2080;
              *(_QWORD *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(_QWORD *)&v20[26] = "srp-mdns-proxy.c";
              v21 = 1024;
              v22 = 848;
              v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              v16 = v11;
LABEL_25:
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, buf, 0x36u);
            }
            goto LABEL_26;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            v18 = "adv_record_vec_remove_update";
            v19 = 1024;
            *(_DWORD *)v20 = v10;
            *(_WORD *)&v20[4] = 2048;
            *(_QWORD *)&v20[6] = a2;
            *(_WORD *)&v20[14] = 2080;
            *(_QWORD *)&v20[16] = "vec->vec[i]->update";
            *(_WORD *)&v20[24] = 2080;
            *(_QWORD *)&v20[26] = "srp-mdns-proxy.c";
            v21 = 1024;
            v22 = 848;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v6 = *(_QWORD *)(a1 + 8);
            v12 = *(int **)(*(_QWORD *)(v6 + 8 * v5) + 32);
            v10 = *v12;
          }
          else
          {
            v12 = a2;
          }
          *v12 = v10 - 1;
          if (v10 == 1)
          {
            v13 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              v18 = "adv_record_vec_remove_update";
              v19 = 2048;
              *(_QWORD *)v20 = v12;
              *(_WORD *)&v20[8] = 2080;
              *(_QWORD *)&v20[10] = "vec->vec[i]->update";
              *(_WORD *)&v20[18] = 2080;
              *(_QWORD *)&v20[20] = "srp-mdns-proxy.c";
              *(_WORD *)&v20[28] = 1024;
              *(_DWORD *)&v20[30] = 848;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v12 = *(int **)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v5) + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize(v12);
            v6 = *(_QWORD *)(a1 + 8);
          }
          *(_QWORD *)(*(_QWORD *)(v6 + 8 * v5) + 32) = 0;
          v2 = *(_DWORD *)(a1 + 4);
        }
      }
      ++v5;
    }
    while (v5 < v2);
  }
}

void adv_update_free_instance_vectors(uint64_t a1)
{
  uint64_t v2;
  int *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  uint64_t v7;
  int *v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  int *v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int *v16;
  int v17;
  NSObject *v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  int v22;
  const char *v23;
  __int16 v24;
  _BYTE v25[34];
  __int16 v26;
  int v27;

  v2 = *(_QWORD *)(a1 + 56);
  if (v2)
  {
    adv_instance_vec_remove_update(v2, (int *)a1);
    adv_instances_cancel(*(_QWORD *)(a1 + 56));
    v3 = *(int **)(a1 + 56);
    if (v3)
    {
      v4 = *v3;
      if (!*v3)
      {
        v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_65;
        v22 = 136447490;
        v23 = "adv_update_free_instance_vectors";
        v24 = 1024;
        *(_DWORD *)v25 = 0;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = v3;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "update->update_instances";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
        v26 = 1024;
        v27 = 891;
        v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_60;
      }
      v5 = global_os_log;
      if (v4 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_65;
        v22 = 136447490;
        v23 = "adv_update_free_instance_vectors";
        v24 = 1024;
        *(_DWORD *)v25 = v4;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = v3;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "update->update_instances";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
        v26 = 1024;
        v27 = 891;
        v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_63;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v22 = 136447490;
        v23 = "adv_update_free_instance_vectors";
        v24 = 1024;
        *(_DWORD *)v25 = v4;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = v3;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "update->update_instances";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
        v26 = 1024;
        v27 = 891;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        v3 = *(int **)(a1 + 56);
        v4 = *v3;
      }
      *v3 = v4 - 1;
      if (v4 == 1)
      {
        v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v22 = 136447234;
          v23 = "adv_update_free_instance_vectors";
          v24 = 2048;
          *(_QWORD *)v25 = v3;
          *(_WORD *)&v25[8] = 2080;
          *(_QWORD *)&v25[10] = "update->update_instances";
          *(_WORD *)&v25[18] = 2080;
          *(_QWORD *)&v25[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 891;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
          v3 = *(int **)(a1 + 56);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v3);
      }
    }
    *(_QWORD *)(a1 + 56) = 0;
  }
  v7 = *(_QWORD *)(a1 + 64);
  if (v7)
  {
    adv_instance_vec_remove_update(v7, (int *)a1);
    v8 = *(int **)(a1 + 64);
    if (v8)
    {
      v9 = *v8;
      if (!*v8)
      {
        v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_65;
        v22 = 136447490;
        v23 = "adv_update_free_instance_vectors";
        v24 = 1024;
        *(_DWORD *)v25 = 0;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = v8;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "update->remove_instances";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
        v26 = 1024;
        v27 = 896;
        v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_60;
      }
      v5 = global_os_log;
      if (v9 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_65;
        v22 = 136447490;
        v23 = "adv_update_free_instance_vectors";
        v24 = 1024;
        *(_DWORD *)v25 = v9;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = v8;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "update->remove_instances";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
        v26 = 1024;
        v27 = 896;
        v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_63;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v22 = 136447490;
        v23 = "adv_update_free_instance_vectors";
        v24 = 1024;
        *(_DWORD *)v25 = v9;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = v8;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "update->remove_instances";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
        v26 = 1024;
        v27 = 896;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        v8 = *(int **)(a1 + 64);
        v9 = *v8;
      }
      *v8 = v9 - 1;
      if (v9 == 1)
      {
        v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v22 = 136447234;
          v23 = "adv_update_free_instance_vectors";
          v24 = 2048;
          *(_QWORD *)v25 = v8;
          *(_WORD *)&v25[8] = 2080;
          *(_QWORD *)&v25[10] = "update->remove_instances";
          *(_WORD *)&v25[18] = 2080;
          *(_QWORD *)&v25[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 896;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
          v8 = *(int **)(a1 + 64);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v8);
      }
    }
    *(_QWORD *)(a1 + 64) = 0;
  }
  v11 = *(_QWORD *)(a1 + 72);
  if (!v11)
    goto LABEL_34;
  adv_instance_vec_remove_update(v11, (int *)a1);
  v12 = *(int **)(a1 + 72);
  if (v12)
  {
    v13 = *v12;
    if (!*v12)
    {
      v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_65;
      v22 = 136447490;
      v23 = "adv_update_free_instance_vectors";
      v24 = 1024;
      *(_DWORD *)v25 = 0;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = v12;
      *(_WORD *)&v25[14] = 2080;
      *(_QWORD *)&v25[16] = "update->renew_instances";
      *(_WORD *)&v25[24] = 2080;
      *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
      v26 = 1024;
      v27 = 901;
      v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_60;
    }
    v5 = global_os_log;
    if (v13 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v22 = 136447490;
        v23 = "adv_update_free_instance_vectors";
        v24 = 1024;
        *(_DWORD *)v25 = v13;
        *(_WORD *)&v25[4] = 2048;
        *(_QWORD *)&v25[6] = v12;
        *(_WORD *)&v25[14] = 2080;
        *(_QWORD *)&v25[16] = "update->renew_instances";
        *(_WORD *)&v25[24] = 2080;
        *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
        v26 = 1024;
        v27 = 901;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        v12 = *(int **)(a1 + 72);
        v13 = *v12;
      }
      *v12 = v13 - 1;
      if (v13 == 1)
      {
        v14 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v22 = 136447234;
          v23 = "adv_update_free_instance_vectors";
          v24 = 2048;
          *(_QWORD *)v25 = v12;
          *(_WORD *)&v25[8] = 2080;
          *(_QWORD *)&v25[10] = "update->renew_instances";
          *(_WORD *)&v25[18] = 2080;
          *(_QWORD *)&v25[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 901;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
          v12 = *(int **)(a1 + 72);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v12);
      }
      goto LABEL_33;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_65;
    v22 = 136447490;
    v23 = "adv_update_free_instance_vectors";
    v24 = 1024;
    *(_DWORD *)v25 = v13;
    *(_WORD *)&v25[4] = 2048;
    *(_QWORD *)&v25[6] = v12;
    *(_WORD *)&v25[14] = 2080;
    *(_QWORD *)&v25[16] = "update->renew_instances";
    *(_WORD *)&v25[24] = 2080;
    *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
    v26 = 1024;
    v27 = 901;
    v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_63:
    v21 = v5;
    goto LABEL_64;
  }
LABEL_33:
  *(_QWORD *)(a1 + 72) = 0;
LABEL_34:
  v15 = *(_QWORD *)(a1 + 80);
  if (!v15)
    return;
  adv_instance_vec_remove_update(v15, (int *)a1);
  adv_instances_cancel(*(_QWORD *)(a1 + 80));
  v16 = *(int **)(a1 + 80);
  if (v16)
  {
    v17 = *v16;
    if (*v16)
    {
      v5 = global_os_log;
      if (v17 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v22 = 136447490;
          v23 = "adv_update_free_instance_vectors";
          v24 = 1024;
          *(_DWORD *)v25 = v17;
          *(_WORD *)&v25[4] = 2048;
          *(_QWORD *)&v25[6] = v16;
          *(_WORD *)&v25[14] = 2080;
          *(_QWORD *)&v25[16] = "update->add_instances";
          *(_WORD *)&v25[24] = 2080;
          *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
          v26 = 1024;
          v27 = 907;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
          v16 = *(int **)(a1 + 80);
          v17 = *v16;
        }
        *v16 = v17 - 1;
        if (v17 == 1)
        {
          v18 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v22 = 136447234;
            v23 = "adv_update_free_instance_vectors";
            v24 = 2048;
            *(_QWORD *)v25 = v16;
            *(_WORD *)&v25[8] = 2080;
            *(_QWORD *)&v25[10] = "update->add_instances";
            *(_WORD *)&v25[18] = 2080;
            *(_QWORD *)&v25[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v25[28] = 1024;
            *(_DWORD *)&v25[30] = 907;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
            v16 = *(int **)(a1 + 80);
          }
          ++adv_instance_vec_finalized;
          adv_instance_vec_finalize((uint64_t)v16);
        }
        goto LABEL_44;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_65:
        abort();
      v22 = 136447490;
      v23 = "adv_update_free_instance_vectors";
      v24 = 1024;
      *(_DWORD *)v25 = v17;
      *(_WORD *)&v25[4] = 2048;
      *(_QWORD *)&v25[6] = v16;
      *(_WORD *)&v25[14] = 2080;
      *(_QWORD *)&v25[16] = "update->add_instances";
      *(_WORD *)&v25[24] = 2080;
      *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
      v26 = 1024;
      v27 = 907;
      v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_63;
    }
    v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_65;
    v22 = 136447490;
    v23 = "adv_update_free_instance_vectors";
    v24 = 1024;
    *(_DWORD *)v25 = 0;
    *(_WORD *)&v25[4] = 2048;
    *(_QWORD *)&v25[6] = v16;
    *(_WORD *)&v25[14] = 2080;
    *(_QWORD *)&v25[16] = "update->add_instances";
    *(_WORD *)&v25[24] = 2080;
    *(_QWORD *)&v25[26] = "srp-mdns-proxy.c";
    v26 = 1024;
    v27 = 907;
    v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_60:
    v21 = v19;
LABEL_64:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v20, (uint8_t *)&v22, 0x36u);
    goto LABEL_65;
  }
LABEL_44:
  *(_QWORD *)(a1 + 80) = 0;
}

void adv_instance_vec_remove_update(uint64_t a1, int *a2)
{
  int v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  int v10;
  NSObject *v11;
  int *v12;
  NSObject *v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  uint8_t buf[4];
  const char *v18;
  __int16 v19;
  _BYTE v20[34];
  __int16 v21;
  int v22;

  v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    v5 = 0;
    v6 = *(_QWORD *)(a1 + 8);
    do
    {
      v7 = *(_QWORD *)(v6 + 8 * v5);
      if (v7)
      {
        v8 = *(int **)(v7 + 32);
        if (v8 && v8 == a2)
        {
          v10 = *a2;
          if (!*a2)
          {
            v14 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v18 = "adv_instance_vec_remove_update";
              v19 = 1024;
              *(_DWORD *)v20 = 0;
              *(_WORD *)&v20[4] = 2048;
              *(_QWORD *)&v20[6] = a2;
              *(_WORD *)&v20[14] = 2080;
              *(_QWORD *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(_QWORD *)&v20[26] = "srp-mdns-proxy.c";
              v21 = 1024;
              v22 = 859;
              v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              v16 = v14;
              goto LABEL_25;
            }
LABEL_26:
            abort();
          }
          v11 = global_os_log;
          if (v10 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v18 = "adv_instance_vec_remove_update";
              v19 = 1024;
              *(_DWORD *)v20 = v10;
              *(_WORD *)&v20[4] = 2048;
              *(_QWORD *)&v20[6] = a2;
              *(_WORD *)&v20[14] = 2080;
              *(_QWORD *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(_QWORD *)&v20[26] = "srp-mdns-proxy.c";
              v21 = 1024;
              v22 = 859;
              v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              v16 = v11;
LABEL_25:
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, buf, 0x36u);
            }
            goto LABEL_26;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            v18 = "adv_instance_vec_remove_update";
            v19 = 1024;
            *(_DWORD *)v20 = v10;
            *(_WORD *)&v20[4] = 2048;
            *(_QWORD *)&v20[6] = a2;
            *(_WORD *)&v20[14] = 2080;
            *(_QWORD *)&v20[16] = "vec->vec[i]->update";
            *(_WORD *)&v20[24] = 2080;
            *(_QWORD *)&v20[26] = "srp-mdns-proxy.c";
            v21 = 1024;
            v22 = 859;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v6 = *(_QWORD *)(a1 + 8);
            v12 = *(int **)(*(_QWORD *)(v6 + 8 * v5) + 32);
            v10 = *v12;
          }
          else
          {
            v12 = a2;
          }
          *v12 = v10 - 1;
          if (v10 == 1)
          {
            v13 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              v18 = "adv_instance_vec_remove_update";
              v19 = 2048;
              *(_QWORD *)v20 = v12;
              *(_WORD *)&v20[8] = 2080;
              *(_QWORD *)&v20[10] = "vec->vec[i]->update";
              *(_WORD *)&v20[18] = 2080;
              *(_QWORD *)&v20[20] = "srp-mdns-proxy.c";
              *(_WORD *)&v20[28] = 1024;
              *(_DWORD *)&v20[30] = 859;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v12 = *(int **)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v5) + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize(v12);
            v6 = *(_QWORD *)(a1 + 8);
          }
          *(_QWORD *)(*(_QWORD *)(v6 + 8 * v5) + 32) = 0;
          v2 = *(_DWORD *)(a1 + 4);
        }
      }
      ++v5;
    }
    while (v5 < v2);
  }
}

void adv_instance_context_release(int *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *a1;
  if (!*a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "adv_instance_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "instance";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 220;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "adv_instance_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "instance";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 220;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "adv_instance_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "instance";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 220;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "adv_instance_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "instance";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 220;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++adv_instance_finalized;
    adv_instance_finalize(a1);
  }
}

uint64_t srp_mdns_shared_registration_txn_setup(uint64_t a1)
{
  int8x16_t *v3;
  _QWORD *v4;
  _QWORD *v5;
  NSObject *v6;
  NSObject *v7;
  DNSServiceRef sdRef;
  size_t v9;
  _BYTE buf[12];
  __int16 v11;
  _QWORD *v12;
  __int16 v13;
  DNSServiceRef v14;

  if (*(_QWORD *)(a1 + 16))
    return 1;
  sdRef = 0;
  v9 = 0;
  if (!ConnectToServer((uint64_t *)&sdRef, 0, 1, (uint64_t)ConnectionResponse, 0, 0))
  {
    *(_QWORD *)buf = 0;
    v3 = (int8x16_t *)create_hdr(1, &v9, buf, 0, (uint64_t)sdRef);
    if (!deliver_request(v3, (uint64_t)sdRef))
    {
      v4 = ioloop_dnssd_txn_add_((uint64_t)sdRef, a1, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 735);
      *(_QWORD *)(a1 + 16) = v4;
      if (v4)
      {
        v5 = v4;
        dns_service_op_not_to_be_freed = v4[1];
        v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446722;
          *(_QWORD *)&buf[4] = "srp_mdns_shared_registration_txn_setup";
          v11 = 2048;
          v12 = v5;
          v13 = 2048;
          v14 = sdRef;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: server_state->shared_registration_txn = %p  sdref = %p", buf, 0x20u);
        }
        return 1;
      }
      v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "srp_mdns_shared_registration_txn_setup";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s: unable to create shared connection for registration.", buf, 0xCu);
      }
      dns_service_op_not_to_be_freed = 0;
    }
    DNSServiceRefDeallocate(sdRef);
  }
  return 0;
}

void srp_mdns_update_finished(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  _QWORD *v14;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  unsigned __int8 *v23;
  int v24;
  uint64_t v25;
  _BOOL4 v26;
  int v27;
  const char *v28;
  uint64_t v29;
  NSObject *v30;
  const char *v31;
  uint32_t v32;
  uint64_t v33;
  int *v34;
  NSObject *v35;
  int v36;
  int v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  unsigned __int8 *v43;
  int v44;
  uint64_t v45;
  _BOOL4 v46;
  int v47;
  const char *v48;
  uint64_t v49;
  NSObject *v50;
  const char *v51;
  uint32_t v52;
  uint64_t v53;
  int *v54;
  NSObject *v55;
  int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int *v62;
  int v63;
  NSObject *v64;
  NSObject *v65;
  int *v66;
  int v67;
  NSObject *v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  _QWORD *v72;
  uint64_t v74;
  uint64_t v75;
  int v76;
  _QWORD *v77;
  int v79;
  uint64_t v80;
  uint64_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  NSObject *v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  int v93;
  NSObject *v94;
  const char *v95;
  uint64_t v96;
  NSObject *v97;
  uint64_t v98;
  uint64_t v99;
  int v100;
  int *v101;
  NSObject *v102;
  int v103;
  int v104;
  int v105;
  NSObject *v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  int *v111;
  NSObject *v112;
  int v113;
  int v114;
  int v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  int *v119;
  NSObject *v120;
  int v121;
  int v122;
  int v123;
  uint64_t v124;
  int *v125;
  int v126;
  NSObject *v127;
  NSObject *v128;
  int *v129;
  int v130;
  NSObject *v131;
  int *v132;
  uint64_t v133;
  NSObject *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  NSObject *v139;
  NSObject *v140;
  NSObject *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  int *v145;
  NSObject *v146;
  uint64_t v147;
  uint64_t v148;
  int v149;
  uint64_t v150;
  uint64_t i;
  uint64_t v152;
  NSObject *v153;
  uint64_t v154;
  uint64_t v155;
  int v156;
  int *v157;
  NSObject *v158;
  int v159;
  int v160;
  int v161;
  uint64_t v162;
  int *v163;
  int v164;
  NSObject *v165;
  NSObject *v166;
  int *v167;
  int v168;
  NSObject *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  int *v173;
  int v174;
  NSObject *v175;
  uint64_t v176;
  uint64_t j;
  int *v178;
  uint64_t v179;
  _BOOL4 v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  int v184;
  NSObject *v185;
  const char *v186;
  uint32_t v187;
  int v188;
  NSObject *v189;
  uint64_t v190;
  uint64_t v191;
  int *v192;
  int v193;
  NSObject *v194;
  int *v195;
  NSObject *v196;
  int v197;
  int v198;
  int v199;
  const char *v200;
  uint64_t v201;
  int *v202;
  int v203;
  NSObject *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  int *v208;
  int *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  NSObject *v213;
  NSObject *v214;
  NSObject *v215;
  NSObject *v216;
  int v217;
  int v218;
  int v219;
  int *v220;
  int v221;
  NSObject *v222;
  NSObject *v223;
  int v224;
  NSObject *v225;
  int v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  NSObject *v230;
  uint64_t v231;
  uint64_t v232;
  NSObject *v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t k;
  uint64_t v239;
  uint64_t v240;
  NSObject *v241;
  _BOOL4 v242;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  NSObject *v247;
  const char *v248;
  int v249;
  NSObject *v250;
  _BOOL4 v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  unsigned int v266;
  NSObject *v267;
  _BOOL4 v268;
  uint64_t v269;
  uint64_t v270;
  NSObject *v271;
  int v272;
  int v273;
  int v274;
  int v275;
  NSObject *v276;
  NSObject *v277;
  uint64_t v280;
  uint64_t v285;
  uint64_t **v286;
  int *v287;
  uint64_t *v288;
  _QWORD *v289;
  int *v290;
  uint64_t v291;
  _BYTE buf[84];
  __int16 v293;
  int v294;
  __int16 v295;
  unsigned __int8 *v296;
  __int16 v297;
  uint64_t v298;
  __int16 v299;
  uint64_t v300;

  v3 = *(_QWORD **)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  v286 = (uint64_t **)v2;
  if (v2)
    v290 = *(int **)(v2 + 32);
  else
    v290 = 0;
  v4 = v3[12];
  if (v4 && (v5 = *(unsigned int *)(v4 + 4), (int)v5 >= 1))
  {
    v6 = 0;
    v7 = 0;
    v8 = *(_QWORD *)(v4 + 8);
    v9 = 8 * v5;
    do
    {
      if (*(_QWORD *)(v8 + v6))
      {
        v10 = *(_QWORD *)(a1 + 32);
        if (!v10 || !*(_QWORD *)(*(_QWORD *)(v10 + 8) + v6))
          ++v7;
      }
      v6 += 8;
    }
    while (v9 != v6);
  }
  else
  {
    v7 = 0;
  }
  v11 = *(_QWORD *)(a1 + 40);
  if (v11 && (v12 = *(unsigned int *)(v11 + 4), (int)v12 >= 1))
  {
    v13 = 0;
    v14 = *(_QWORD **)(v11 + 8);
    do
    {
      if (*v14++)
        ++v13;
      --v12;
    }
    while (v12);
  }
  else
  {
    v13 = 0;
  }
  v285 = v3[1];
  v291 = *(_QWORD *)(a1 + 8);
  if (v13 + v7 < 1)
  {
    v18 = 0;
  }
  else
  {
    v16 = adv_record_vec_create(v13 + v7);
    if (!v16)
    {
      update_failed(a1, 2u, 1);
      return;
    }
    v17 = v3[12];
    v18 = v16;
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      v19 = 0;
      v20 = 0;
      while (1)
      {
        v21 = *(_QWORD *)(*(_QWORD *)(v17 + 8) + 8 * v19);
        if (v21)
        {
          v22 = *(_QWORD *)(a1 + 32);
          if (!v22 || !*(_QWORD *)(*(_QWORD *)(v22 + 8) + 8 * v19))
            break;
        }
LABEL_49:
        if (++v19 >= *(int *)(v17 + 4))
          goto LABEL_53;
      }
      v23 = *(unsigned __int8 **)(v21 + 40);
      v24 = *(unsigned __int16 *)(v21 + 48);
      v25 = global_os_log;
      v26 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      if (v24 == 28)
      {
        if (v26)
        {
          v27 = *v23;
          v28 = "ULA: ";
          if ((v27 & 0xFE) != 0xFC)
          {
            if (v27 != 254 || (v28 = "LUA: ", (v23[1] & 0xC0) != 0x80))
            {
              v28 = "GUA: ";
              if ((v27 & 0xE0) != 0x20)
                v28 = (const char *)&unk_10007C3B5;
            }
          }
          v29 = *(_QWORD *)(v291 + 64);
          *(_DWORD *)buf = 136449283;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2082;
          *(_QWORD *)&buf[14] = v28;
          *(_WORD *)&buf[22] = 2160;
          *(_QWORD *)&buf[24] = 1752392040;
          *(_WORD *)&buf[32] = 1041;
          *(_DWORD *)&buf[34] = 6;
          *(_WORD *)&buf[38] = 2097;
          *(_QWORD *)&buf[40] = v23;
          *(_WORD *)&buf[48] = 2160;
          *(_QWORD *)&buf[50] = 1752392040;
          *(_WORD *)&buf[58] = 1042;
          *(_DWORD *)&buf[60] = 2;
          *(_WORD *)&buf[64] = 2098;
          *(_QWORD *)&buf[66] = v23 + 6;
          *(_WORD *)&buf[74] = 2160;
          *(_QWORD *)&buf[76] = 1752392040;
          v293 = 1041;
          v294 = 8;
          v295 = 2097;
          v296 = v23 + 8;
          v297 = 2160;
          v298 = 1752392040;
          v299 = 2081;
          v300 = v29;
          v30 = v25;
          v31 = "%{public}s: retaining {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp"
                ":in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}on host %{private, mask.hash}s";
          v32 = 120;
          goto LABEL_40;
        }
      }
      else if (v26)
      {
        v33 = *(_QWORD *)(v291 + 64);
        *(_DWORD *)buf = 136447491;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 1041;
        *(_DWORD *)&buf[24] = 4;
        *(_WORD *)&buf[28] = 2097;
        *(_QWORD *)&buf[30] = v23;
        *(_WORD *)&buf[38] = 2160;
        *(_QWORD *)&buf[40] = 1752392040;
        *(_WORD *)&buf[48] = 2081;
        *(_QWORD *)&buf[50] = v33;
        v30 = v25;
        v31 = "%{public}s: retaining %{private, mask.hash, network:in_addr}.4Pon host %{private, mask.hash}s";
        v32 = 58;
LABEL_40:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, buf, v32);
      }
      *(_QWORD *)(v18[1] + 8 * v20) = v21;
      v34 = *(int **)(v18[1] + 8 * v20);
      if (v34)
      {
        v35 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v36 = *v34;
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v36;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v34;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "addresses->vec[j]";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 1490;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v34 = *(int **)(v18[1] + 8 * v20);
        }
        v37 = *v34;
        if (*v34)
        {
          v38 = v37 + 1;
          *v34 = v37 + 1;
          if (v37 + 1 >= 10001)
          {
            v280 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v38;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v34;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "addresses->vec[j]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1490;
            v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_485;
          }
        }
        else
        {
          ++adv_record_created;
          *v34 = 1;
        }
      }
      ++v20;
      v17 = *(_QWORD *)(v291 + 96);
      goto LABEL_49;
    }
    v20 = 0;
LABEL_53:
    v39 = *(_QWORD *)(a1 + 40);
    if (v39 && *(int *)(v39 + 4) >= 1)
    {
      v40 = 0;
      v41 = v20;
      while (1)
      {
        v42 = *(_QWORD *)(*(_QWORD *)(v39 + 8) + 8 * v40);
        if (!v42)
          goto LABEL_96;
        v43 = *(unsigned __int8 **)(v42 + 40);
        v44 = *(unsigned __int16 *)(v42 + 48);
        v45 = global_os_log;
        v46 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        if (v44 == 28)
        {
          if (v46)
          {
            v47 = *v43;
            v48 = "ULA: ";
            if ((v47 & 0xFE) != 0xFC)
            {
              if (v47 != 254 || (v48 = "LUA: ", (v43[1] & 0xC0) != 0x80))
              {
                v48 = "GUA: ";
                if ((v47 & 0xE0) != 0x20)
                  v48 = (const char *)&unk_10007C3B5;
              }
            }
            v49 = *(_QWORD *)(v291 + 64);
            *(_DWORD *)buf = 136449283;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v48;
            *(_WORD *)&buf[22] = 2160;
            *(_QWORD *)&buf[24] = 1752392040;
            *(_WORD *)&buf[32] = 1041;
            *(_DWORD *)&buf[34] = 6;
            *(_WORD *)&buf[38] = 2097;
            *(_QWORD *)&buf[40] = v43;
            *(_WORD *)&buf[48] = 2160;
            *(_QWORD *)&buf[50] = 1752392040;
            *(_WORD *)&buf[58] = 1042;
            *(_DWORD *)&buf[60] = 2;
            *(_WORD *)&buf[64] = 2098;
            *(_QWORD *)&buf[66] = v43 + 6;
            *(_WORD *)&buf[74] = 2160;
            *(_QWORD *)&buf[76] = 1752392040;
            v293 = 1041;
            v294 = 8;
            v295 = 2097;
            v296 = v43 + 8;
            v297 = 2160;
            v298 = 1752392040;
            v299 = 2081;
            v300 = v49;
            v50 = v45;
            v51 = "%{public}s: adding {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:"
                  "in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}to host %{private, mask.hash}s";
            v52 = 120;
            goto LABEL_67;
          }
        }
        else if (v46)
        {
          v53 = *(_QWORD *)(v291 + 64);
          *(_DWORD *)buf = 136447491;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2160;
          *(_QWORD *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 1041;
          *(_DWORD *)&buf[24] = 4;
          *(_WORD *)&buf[28] = 2097;
          *(_QWORD *)&buf[30] = v43;
          *(_WORD *)&buf[38] = 2160;
          *(_QWORD *)&buf[40] = 1752392040;
          *(_WORD *)&buf[48] = 2081;
          *(_QWORD *)&buf[50] = v53;
          v50 = v45;
          v51 = "%{public}s: adding %{private, mask.hash, network:in_addr}.4Pto host %{private, mask.hash}s";
          v52 = 58;
LABEL_67:
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v51, buf, v52);
        }
        *(_QWORD *)(v18[1] + 8 * v41) = v42;
        v54 = *(int **)(v18[1] + 8 * v41);
        if (v54)
        {
          v55 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v56 = *v54;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v56;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v54;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "addresses->vec[j]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1512;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v54 = *(int **)(v18[1] + 8 * v41);
          }
          v57 = *v54;
          if (*v54)
          {
            v58 = v57 + 1;
            *v54 = v57 + 1;
            if (v57 + 1 >= 10001)
            {
              v280 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_487;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v58;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v54;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "addresses->vec[j]";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1512;
              v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_485;
            }
          }
          else
          {
            ++adv_record_created;
            *v54 = 1;
          }
        }
        v59 = *(_QWORD *)(v42 + 32);
        v60 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        if (v59)
        {
          v61 = *(_QWORD *)(v60 + 8 * v40);
          v62 = *(int **)(v61 + 32);
          if (v62)
          {
            v63 = *v62;
            if (!*v62)
            {
              v280 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_487;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = 0;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v62;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "update->add_addresses->vec[i]->update";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1515;
              v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_485;
            }
            v64 = global_os_log;
            if (v63 >= 10001)
            {
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_487;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v63;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v62;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "update->add_addresses->vec[i]->update";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1515;
              v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_440;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v63;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v62;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "update->add_addresses->vec[i]->update";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1515;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              v60 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
              v61 = *(_QWORD *)(v60 + 8 * v40);
              v62 = *(int **)(v61 + 32);
              v63 = *v62;
            }
            *v62 = v63 - 1;
            if (v63 == 1)
            {
              v65 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
                *(_WORD *)&buf[12] = 2048;
                *(_QWORD *)&buf[14] = v62;
                *(_WORD *)&buf[22] = 2080;
                *(_QWORD *)&buf[24] = "update->add_addresses->vec[i]->update";
                *(_WORD *)&buf[32] = 2080;
                *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[42] = 1024;
                *(_DWORD *)&buf[44] = 1515;
                _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                v62 = *(int **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 8 * v40) + 32);
              }
              ++adv_update_finalized;
              adv_update_finalize((uint64_t)v62);
              v60 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
              v61 = *(_QWORD *)(v60 + 8 * v40);
            }
          }
          *(_QWORD *)(v61 + 32) = 0;
        }
        v66 = *(int **)(v60 + 8 * v40);
        if (v66)
        {
          v67 = *v66;
          if (!*v66)
          {
            v280 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v66;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->add_addresses->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1518;
            v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_485;
          }
          v64 = global_os_log;
          if (v67 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v67;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v66;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->add_addresses->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1518;
            v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_440:
            v277 = v64;
            goto LABEL_486;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v67;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v66;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->add_addresses->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1518;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v60 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
            v66 = *(int **)(v60 + 8 * v40);
            v67 = *v66;
          }
          *v66 = v67 - 1;
          if (v67 == 1)
          {
            v68 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v66;
              *(_WORD *)&buf[22] = 2080;
              *(_QWORD *)&buf[24] = "update->add_addresses->vec[i]";
              *(_WORD *)&buf[32] = 2080;
              *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1518;
              _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v66 = *(int **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 8 * v40);
            }
            ++adv_record_finalized;
            adv_record_finalize((uint64_t)v66);
            v60 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
          }
        }
        ++v41;
        *(_QWORD *)(v60 + 8 * v40) = 0;
LABEL_96:
        ++v40;
        v39 = *(_QWORD *)(a1 + 40);
        if (v40 >= *(int *)(v39 + 4))
          goto LABEL_99;
      }
    }
    v41 = v20;
LABEL_99:
    *((_DWORD *)v18 + 1) = v41;
    v3 = (_QWORD *)v291;
  }
  v69 = v3[14];
  if (v69 && (v70 = *(unsigned int *)(v69 + 4), (int)v70 >= 1))
  {
    v71 = 0;
    v72 = *(_QWORD **)(v69 + 8);
    do
    {
      if (*v72++)
        ++v71;
      --v70;
    }
    while (v70);
  }
  else
  {
    v71 = 0;
  }
  v74 = *(_QWORD *)(a1 + 80);
  v287 = (int *)v18;
  if (v74 && (v75 = *(unsigned int *)(v74 + 4), (int)v75 >= 1))
  {
    v76 = 0;
    v77 = *(_QWORD **)(v74 + 8);
    do
    {
      if (*v77++)
        ++v76;
      --v75;
    }
    while (v75);
  }
  else
  {
    v76 = 0;
  }
  v79 = v76 + v71;
  v289 = adv_instance_vec_create(v76 + v71);
  if (!v289)
  {
    if (v287)
    {
      v138 = *v287;
      if (!*v287)
      {
        v280 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v287;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "addresses";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1549;
        v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_485;
      }
      v139 = global_os_log;
      if (v138 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v138;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v287;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "addresses";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1549;
        v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_478;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v138;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v287;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "addresses";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1549;
        _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v138 = *v287;
      }
      *v287 = v138 - 1;
      if (v138 == 1)
      {
        v140 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v287;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = "addresses";
          *(_WORD *)&buf[32] = 2080;
          *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1549;
          _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v287);
      }
    }
    update_failed(a1, 2u, 1);
    return;
  }
  v80 = v3[14];
  if (!v80 || *(int *)(v80 + 4) < 1)
  {
    v82 = 0;
    goto LABEL_207;
  }
  v81 = 0;
  v82 = 0;
  while (v82 != v79)
  {
    v83 = *(_QWORD *)(a1 + 56);
    if (v83)
    {
      v84 = *(_QWORD *)(*(_QWORD *)(v83 + 8) + 8 * v81);
      v85 = *(_QWORD *)(a1 + 64);
      if (v84)
      {
        if (v85)
        {
          v86 = *(_QWORD *)(*(_QWORD *)(v85 + 8) + 8 * v81);
          v87 = global_os_log;
          if (v86)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v88 = *(_QWORD *)(v86 + 48);
              v89 = *(_QWORD *)(v86 + 56);
              v90 = *(_DWORD *)(v86 + 64);
              *(_DWORD *)buf = 136447491;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2160;
              *(_QWORD *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(_QWORD *)&buf[24] = v88;
              *(_WORD *)&buf[32] = 2160;
              *(_QWORD *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(_QWORD *)&buf[44] = v89;
              *(_WORD *)&buf[52] = 1024;
              *(_DWORD *)&buf[54] = v90;
              _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%{public}s: removed instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
              v87 = global_os_log;
            }
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
            {
              v91 = *(_QWORD *)(v84 + 48);
              v92 = *(_QWORD *)(v84 + 56);
              v93 = *(_DWORD *)(v84 + 64);
              *(_DWORD *)buf = 136447491;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2160;
              *(_QWORD *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(_QWORD *)&buf[24] = v91;
              *(_WORD *)&buf[32] = 2160;
              *(_QWORD *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(_QWORD *)&buf[44] = v92;
              *(_WORD *)&buf[52] = 1024;
              *(_DWORD *)&buf[54] = v93;
              v94 = v87;
              v95 = "%{public}s: added instance %{private, mask.hash}s %{private, mask.hash}s %d";
              goto LABEL_152;
            }
            goto LABEL_153;
          }
        }
        else
        {
          v87 = global_os_log;
        }
        if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
        {
          v116 = *(_QWORD *)(v84 + 48);
          v117 = *(_QWORD *)(v84 + 56);
          v118 = *(_DWORD *)(v84 + 64);
          *(_DWORD *)buf = 136447491;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2160;
          *(_QWORD *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(_QWORD *)&buf[24] = v116;
          *(_WORD *)&buf[32] = 2160;
          *(_QWORD *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(_QWORD *)&buf[44] = v117;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v118;
          v94 = v87;
          v95 = "%{public}s: updated instance %{private, mask.hash}s %{private, mask.hash}s %d";
LABEL_152:
          _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, v95, buf, 0x3Au);
        }
LABEL_153:
        *(_QWORD *)(v289[1] + 8 * v82) = v84;
        v119 = *(int **)(v289[1] + 8 * v82);
        if (v119)
        {
          v120 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v121 = *v119;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v121;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v119;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1576;
            _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v119 = *(int **)(v289[1] + 8 * v82);
          }
          v122 = *v119;
          if (*v119)
          {
            v123 = v122 + 1;
            *v119 = v122 + 1;
            if (v122 + 1 >= 10001)
            {
              v280 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_487;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v123;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v119;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "instances->vec[j]";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1576;
              v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_485;
            }
          }
          else
          {
            ++adv_instance_created;
            *v119 = 1;
          }
        }
        v124 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
        v125 = *(int **)(v124 + 8 * v81);
        if (v125)
        {
          v126 = *v125;
          if (!*v125)
          {
            v280 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v125;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->update_instances->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1578;
            v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_485;
          }
          v127 = global_os_log;
          if (v126 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v126;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v125;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->update_instances->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1578;
            v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            goto LABEL_451;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v126;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v125;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->update_instances->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1578;
            _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v124 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
            v125 = *(int **)(v124 + 8 * v81);
            v126 = *v125;
          }
          *v125 = v126 - 1;
          if (v126 == 1)
          {
            v128 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v125;
              *(_WORD *)&buf[22] = 2080;
              *(_QWORD *)&buf[24] = "update->update_instances->vec[i]";
              *(_WORD *)&buf[32] = 2080;
              *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1578;
              _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v125 = *(int **)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 8 * v81);
            }
            ++adv_instance_finalized;
            adv_instance_finalize(v125);
            v124 = *(_QWORD *)(*(_QWORD *)(a1 + 56) + 8);
          }
        }
        *(_QWORD *)(v124 + 8 * v81) = 0;
        v129 = *(int **)(v84 + 32);
        if (v129)
        {
          v130 = *v129;
          if (!*v129)
          {
            v280 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v129;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instance->update";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1581;
            v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_485;
          }
          v127 = global_os_log;
          if (v130 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v130;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v129;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instance->update";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1581;
            v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_451:
            v277 = v127;
LABEL_486:
            _os_log_impl((void *)&_mh_execute_header, v277, OS_LOG_TYPE_FAULT, v200, buf, 0x36u);
            goto LABEL_487;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v130;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v129;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instance->update";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1581;
            _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v129 = *(int **)(v84 + 32);
            v130 = *v129;
          }
          *v129 = v130 - 1;
          if (v130 == 1)
          {
            v131 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v129;
              *(_WORD *)&buf[22] = 2080;
              *(_QWORD *)&buf[24] = "instance->update";
              *(_WORD *)&buf[32] = 2080;
              *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1581;
              _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v129 = *(int **)(v84 + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize((uint64_t)v129);
          }
          *(_QWORD *)(v84 + 32) = 0;
        }
LABEL_179:
        ++v82;
        set_instance_message(v84, v290);
        goto LABEL_180;
      }
    }
    else
    {
      v85 = *(_QWORD *)(a1 + 64);
    }
    if (v85 && (v96 = *(_QWORD *)(*(_QWORD *)(v85 + 8) + 8 * v81)) != 0)
    {
      v97 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v98 = *(_QWORD *)(v96 + 48);
        v99 = *(_QWORD *)(v96 + 56);
        v100 = *(_DWORD *)(v96 + 64);
        *(_DWORD *)buf = 136447491;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 2081;
        *(_QWORD *)&buf[24] = v98;
        *(_WORD *)&buf[32] = 2160;
        *(_QWORD *)&buf[34] = 1752392040;
        *(_WORD *)&buf[42] = 2081;
        *(_QWORD *)&buf[44] = v99;
        *(_WORD *)&buf[52] = 1024;
        *(_DWORD *)&buf[54] = v100;
        _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "%{public}s: removed instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
      }
      *(_QWORD *)(v289[1] + 8 * v82) = v96;
      v101 = *(int **)(v289[1] + 8 * v82);
      if (v101)
      {
        v102 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v103 = *v101;
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v103;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v101;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "instances->vec[j]";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 1591;
          _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v101 = *(int **)(v289[1] + 8 * v82);
        }
        v104 = *v101;
        if (*v101)
        {
          v105 = v104 + 1;
          *v101 = v104 + 1;
          if (v104 + 1 >= 10001)
          {
            v280 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v105;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v101;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1591;
            v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_485:
            v277 = v280;
            goto LABEL_486;
          }
        }
        else
        {
          ++adv_instance_created;
          *v101 = 1;
        }
      }
      *(_BYTE *)(v96 + 116) = 1;
      if (v290)
      {
        v132 = *(int **)(v96 + 88);
        if (v132)
          ioloop_message_release_(v132, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1596);
        *(_QWORD *)(v96 + 88) = v290;
        ioloop_message_retain_(v290, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1599);
      }
      ++v82;
      v133 = *(_QWORD *)(v96 + 8);
      if (v133)
      {
        ioloop_dnssd_txn_cancel(v133);
        ioloop_dnssd_txn_release_(*(int **)(v96 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1606);
        *(_QWORD *)(v96 + 8) = 0;
      }
      else
      {
        v134 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v135 = *(_QWORD *)(v96 + 48);
          v136 = *(_QWORD *)(v96 + 56);
          v137 = *(_QWORD *)(v291 + 56);
          *(_DWORD *)buf = 136447747;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2160;
          *(_QWORD *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(_QWORD *)&buf[24] = v135;
          *(_WORD *)&buf[32] = 2160;
          *(_QWORD *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(_QWORD *)&buf[44] = v136;
          *(_WORD *)&buf[52] = 2160;
          *(_QWORD *)&buf[54] = 1752392040;
          *(_WORD *)&buf[62] = 2081;
          *(_QWORD *)&buf[64] = v137;
          _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_ERROR, "%{public}s: instance %{private, mask.hash}s.%{private, mask.hash}s for host %{private, mask.hash}s has no connection.", buf, 0x48u);
        }
      }
    }
    else
    {
      v84 = *(_QWORD *)(*(_QWORD *)(v80 + 8) + 8 * v81);
      if (v84)
      {
        v106 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v107 = *(_QWORD *)(v84 + 48);
          v108 = *(_QWORD *)(v84 + 56);
          v109 = *(_DWORD *)(v84 + 64);
          v110 = *(_QWORD *)(v84 + 88);
          *(_DWORD *)buf = 136447747;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2160;
          *(_QWORD *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(_QWORD *)&buf[24] = v107;
          *(_WORD *)&buf[32] = 2160;
          *(_QWORD *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(_QWORD *)&buf[44] = v108;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v109;
          *(_WORD *)&buf[58] = 2048;
          *(_QWORD *)&buf[60] = v110;
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: kept instance %{private, mask.hash}s %{private, mask.hash}s %d, instance->message = %p", buf, 0x44u);
        }
        *(_QWORD *)(v289[1] + 8 * v82) = v84;
        v111 = *(int **)(v289[1] + 8 * v82);
        if (v111)
        {
          v112 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v113 = *v111;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v113;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v111;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1615;
            _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v111 = *(int **)(v289[1] + 8 * v82);
          }
          v114 = *v111;
          if (*v111)
          {
            v115 = v114 + 1;
            *v111 = v114 + 1;
            if (v114 + 1 >= 10001)
            {
              v280 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_487;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v115;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v111;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "instances->vec[j]";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1615;
              v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_485;
            }
          }
          else
          {
            ++adv_instance_created;
            *v111 = 1;
          }
        }
        goto LABEL_179;
      }
    }
LABEL_180:
    ++v81;
    v80 = *(_QWORD *)(v291 + 112);
    if (v81 >= *(int *)(v80 + 4))
      goto LABEL_207;
  }
  v141 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v79;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v79;
    _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_FAULT, "%{public}s: j (%d) == num_instances (%d)", buf, 0x18u);
  }
  v82 = v79;
LABEL_207:
  v142 = *(_QWORD *)(a1 + 72);
  if (v142 && *(int *)(v142 + 4) >= 1)
  {
    v143 = 0;
    do
    {
      v144 = *(_QWORD *)(*(_QWORD *)(v142 + 8) + 8 * v143);
      if (v144)
      {
        if (v290)
        {
          v145 = *(int **)(v144 + 88);
          if (v145)
            ioloop_message_release_(v145, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1631);
          *(_QWORD *)(v144 + 88) = v290;
          ioloop_message_retain_(v290, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1634);
        }
        *(_QWORD *)(v144 + 96) = 0;
        v146 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v147 = *(_QWORD *)(v144 + 48);
          v148 = *(_QWORD *)(v144 + 56);
          v149 = *(_DWORD *)(v144 + 64);
          *(_DWORD *)buf = 136447491;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2160;
          *(_QWORD *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(_QWORD *)&buf[24] = v147;
          *(_WORD *)&buf[32] = 2160;
          *(_QWORD *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(_QWORD *)&buf[44] = v148;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v149;
          _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "%{public}s: renewed instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
        }
      }
      ++v143;
      v142 = *(_QWORD *)(a1 + 72);
    }
    while (v143 < *(int *)(v142 + 4));
  }
  v150 = *(_QWORD *)(a1 + 80);
  if (v150 && *(int *)(v150 + 4) >= 1)
  {
    for (i = 0; i < *(int *)(v150 + 4); ++i)
    {
      v152 = *(_QWORD *)(*(_QWORD *)(v150 + 8) + 8 * i);
      if (v152)
      {
        v153 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v154 = *(_QWORD *)(v152 + 48);
          v155 = *(_QWORD *)(v152 + 56);
          v156 = *(_DWORD *)(v152 + 64);
          *(_DWORD *)buf = 136447491;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2160;
          *(_QWORD *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(_QWORD *)&buf[24] = v154;
          *(_WORD *)&buf[32] = 2160;
          *(_QWORD *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(_QWORD *)&buf[44] = v155;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v156;
          _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "%{public}s: added instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
        }
        *(_QWORD *)(v289[1] + 8 * v82) = v152;
        v157 = *(int **)(v289[1] + 8 * v82);
        if (v157)
        {
          v158 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v159 = *v157;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v159;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v157;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1650;
            _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v157 = *(int **)(v289[1] + 8 * v82);
          }
          v160 = *v157;
          if (*v157)
          {
            v161 = v160 + 1;
            *v157 = v160 + 1;
            if (v160 + 1 >= 10001)
            {
              v280 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_487;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v161;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v157;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "instances->vec[j]";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1650;
              v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_485;
            }
          }
          else
          {
            ++adv_instance_created;
            *v157 = 1;
          }
        }
        v162 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
        v163 = *(int **)(v162 + 8 * i);
        if (v163)
        {
          v164 = *v163;
          if (!*v163)
          {
            v280 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v163;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->add_instances->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1652;
            v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_485;
          }
          v165 = global_os_log;
          if (v164 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v164;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v163;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "update->add_instances->vec[i]";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1652;
              v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_427;
            }
            goto LABEL_487;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v164;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v163;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->add_instances->vec[i]";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1652;
            _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v162 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
            v163 = *(int **)(v162 + 8 * i);
            v164 = *v163;
          }
          *v163 = v164 - 1;
          if (v164 == 1)
          {
            v166 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v163;
              *(_WORD *)&buf[22] = 2080;
              *(_QWORD *)&buf[24] = "update->add_instances->vec[i]";
              *(_WORD *)&buf[32] = 2080;
              *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1652;
              _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v163 = *(int **)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 8 * i);
            }
            ++adv_instance_finalized;
            adv_instance_finalize(v163);
            v162 = *(_QWORD *)(*(_QWORD *)(a1 + 80) + 8);
          }
        }
        *(_QWORD *)(v162 + 8 * i) = 0;
        v167 = *(int **)(v152 + 32);
        if (v167)
        {
          v168 = *v167;
          if (!*v167)
          {
            v280 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_487;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v167;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instance->update";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1655;
            v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_485;
          }
          v165 = global_os_log;
          if (v168 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v168;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v167;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "instance->update";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1655;
              v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_427;
            }
LABEL_487:
            abort();
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v168;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v167;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "instance->update";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1655;
            _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v167 = *(int **)(v152 + 32);
            v168 = *v167;
          }
          *v167 = v168 - 1;
          if (v168 == 1)
          {
            v169 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2048;
              *(_QWORD *)&buf[14] = v167;
              *(_WORD *)&buf[22] = 2080;
              *(_QWORD *)&buf[24] = "instance->update";
              *(_WORD *)&buf[32] = 2080;
              *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1655;
              _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v167 = *(int **)(v152 + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize((uint64_t)v167);
          }
          *(_QWORD *)(v152 + 32) = 0;
        }
        ++v82;
        set_instance_message(v152, v290);
        v150 = *(_QWORD *)(a1 + 80);
      }
    }
  }
  *((_DWORD *)v289 + 1) = v82;
  v170 = v291;
  if (v82 >= 1)
  {
    v171 = v289[1];
    v172 = v82;
    do
    {
      if (*(_QWORD *)v171)
        *(_BYTE *)(*(_QWORD *)v171 + 119) = 0;
      v171 += 8;
      --v172;
    }
    while (v172);
  }
  v173 = *(int **)(v291 + 96);
  if (v173)
  {
    v174 = *v173;
    if (!*v173)
    {
      v280 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_487;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v173;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->addresses";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1673;
      v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_485;
    }
    v165 = global_os_log;
    if (v174 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v174;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v173;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "host->addresses";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1673;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v173 = *(int **)(v291 + 96);
        v174 = *v173;
      }
      *v173 = v174 - 1;
      if (v174 == 1)
      {
        v175 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v173;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = "host->addresses";
          *(_WORD *)&buf[32] = 2080;
          *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1673;
          _os_log_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v173 = *(int **)(v291 + 96);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v173);
      }
      goto LABEL_266;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_487;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v174;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v173;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "host->addresses";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1673;
    v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_427:
    v277 = v165;
    goto LABEL_486;
  }
LABEL_266:
  *(_QWORD *)(v291 + 96) = v287;
  v176 = *(_QWORD *)(v291 + 112);
  if (v176)
  {
    if (*(int *)(v176 + 4) >= 1)
    {
      for (j = 0; j < *(int *)(v176 + 4); ++j)
      {
        v178 = *(int **)(*(_QWORD *)(v176 + 8) + 8 * j);
        v179 = global_os_log;
        v180 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        if (v178)
        {
          if (v180)
          {
            v181 = *((_QWORD *)v178 + 6);
            v182 = *((_QWORD *)v178 + 7);
            v183 = *(_QWORD *)(v291 + 56);
            v184 = *v178;
            *(_DWORD *)buf = 136448259;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = j;
            *(_WORD *)&buf[18] = 2160;
            *(_QWORD *)&buf[20] = 1752392040;
            *(_WORD *)&buf[28] = 2081;
            *(_QWORD *)&buf[30] = v181;
            *(_WORD *)&buf[38] = 2160;
            *(_QWORD *)&buf[40] = 1752392040;
            *(_WORD *)&buf[48] = 2081;
            *(_QWORD *)&buf[50] = v182;
            *(_WORD *)&buf[58] = 2160;
            *(_QWORD *)&buf[60] = 1752392040;
            *(_WORD *)&buf[68] = 2081;
            *(_QWORD *)&buf[70] = v183;
            *(_WORD *)&buf[78] = 1024;
            *(_DWORD *)&buf[80] = v184;
            v185 = v179;
            v186 = "%{public}s: old host instance %d %{private, mask.hash}s.%{private, mask.hash}s for host %{private, ma"
                   "sk.hash}s has ref_count %d";
            v187 = 84;
LABEL_274:
            _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_DEFAULT, v186, buf, v187);
          }
        }
        else if (v180)
        {
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = j;
          v185 = v179;
          v186 = "%{public}s: old host instance %d is NULL";
          v187 = 18;
          goto LABEL_274;
        }
        v176 = *(_QWORD *)(v291 + 112);
      }
    }
    v188 = *(_DWORD *)v176;
    if (!*(_DWORD *)v176)
    {
      v280 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_487;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v176;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->instances";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1687;
      v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_485;
    }
    v165 = global_os_log;
    v170 = v291;
    if (v188 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_487;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v188;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v176;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->instances";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1687;
      v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_427;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v188;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v176;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->instances";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1687;
      _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v176 = *(_QWORD *)(v291 + 112);
      v188 = *(_DWORD *)v176;
    }
    *(_DWORD *)v176 = v188 - 1;
    if (v188 == 1)
    {
      v189 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v176;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = "host->instances";
        *(_WORD *)&buf[32] = 2080;
        *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 1687;
        _os_log_impl((void *)&_mh_execute_header, v189, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v176 = *(_QWORD *)(v291 + 112);
      }
      ++adv_instance_vec_finalized;
      adv_instance_vec_finalize(v176);
    }
  }
  *(_QWORD *)(v170 + 112) = v289;
  v190 = *(_QWORD *)(v170 + 104);
  if (v190)
  {
    v191 = *(_QWORD *)(a1 + 48);
    if (!v191 || v190 == v191)
      goto LABEL_315;
    srp_mdns_shared_record_remove(*(_QWORD *)(v170 + 8), v190);
    v192 = *(int **)(v170 + 104);
    if (v192)
    {
      v193 = *v192;
      if (!*v192)
      {
        v280 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v192;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "host->key_record";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1693;
        v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_485;
      }
      v165 = global_os_log;
      if (v193 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v193;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v192;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "host->key_record";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1693;
        v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_427;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v193;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v192;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "host->key_record";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1693;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v192 = *(int **)(v170 + 104);
        v193 = *v192;
      }
      *v192 = v193 - 1;
      if (v193 == 1)
      {
        v194 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v192;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = "host->key_record";
          *(_WORD *)&buf[32] = 2080;
          *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1693;
          _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v192 = *(int **)(v170 + 104);
        }
        ++adv_record_finalized;
        adv_record_finalize((uint64_t)v192);
      }
    }
    *(_QWORD *)(v170 + 104) = 0;
  }
  v195 = *(int **)(a1 + 48);
  if (v195)
  {
    *(_QWORD *)(v170 + 104) = v195;
    v196 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v197 = *v195;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v197;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v195;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->key_record";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1698;
      _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v195 = *(int **)(v170 + 104);
    }
    v198 = *v195;
    if (*v195)
    {
      v199 = v198 + 1;
      *v195 = v198 + 1;
      if (v198 + 1 >= 10001)
      {
        v280 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v199;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v195;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "host->key_record";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1698;
        v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_485;
      }
    }
    else
    {
      ++adv_record_created;
      *v195 = 1;
    }
    v201 = *(_QWORD *)(a1 + 48);
    v202 = *(int **)(v201 + 32);
    if (v202)
    {
      v203 = *v202;
      if (!*v202)
      {
        v280 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v202;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->key->update";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1700;
        v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_485;
      }
      v165 = global_os_log;
      if (v203 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v203;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v202;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->key->update";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1700;
        v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_427;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v203;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v202;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->key->update";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1700;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v201 = *(_QWORD *)(a1 + 48);
        v202 = *(int **)(v201 + 32);
        v203 = *v202;
      }
      *v202 = v203 - 1;
      if (v203 == 1)
      {
        v204 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v202;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = "update->key->update";
          *(_WORD *)&buf[32] = 2080;
          *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1700;
          _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v202 = *(int **)(*(_QWORD *)(a1 + 48) + 32);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v202);
        v201 = *(_QWORD *)(a1 + 48);
      }
      *(_QWORD *)(v201 + 32) = 0;
    }
  }
LABEL_315:
  v205 = *(_QWORD *)(a1 + 32);
  if (v205 && *(int *)(v205 + 4) >= 1)
  {
    v206 = 0;
    do
    {
      v207 = *(_QWORD *)(*(_QWORD *)(v205 + 8) + 8 * v206);
      if (v207)
      {
        srp_mdns_shared_record_remove(*(_QWORD *)(v170 + 8), v207);
        v205 = *(_QWORD *)(a1 + 32);
      }
      ++v206;
    }
    while (v206 < *(int *)(v205 + 4));
  }
  if (v286)
  {
    v208 = *(int **)(v170 + 72);
    if (v208)
      ioloop_message_release_(v208, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1719);
    v209 = (int *)v286[4];
    *(_QWORD *)(v170 + 72) = v209;
    ioloop_message_retain_(v209, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1722);
    advertise_finished(*(_QWORD *)(v170 + 56), (uint64_t)v286[1], (uint64_t)v286[4], 0, (uint64_t)v286, 1);
    v288 = *v286;
    *v286 = 0;
    srp_parse_client_updates_free_(v286, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1728);
    *(_QWORD *)(a1 + 16) = 0;
    v210 = *(_QWORD *)(*(_QWORD *)(v170 + 72) + 72);
    if (v210)
    {
      *(_QWORD *)(v170 + 200) = v210;
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
      v211 = *(_QWORD *)(v170 + 200);
      v212 = *(_QWORD *)buf - v211;
      v213 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v211;
        *(_WORD *)&buf[22] = 2048;
        *(_QWORD *)&buf[24] = v212;
        _os_log_impl((void *)&_mh_execute_header, v213, OS_LOG_TYPE_DEFAULT, "%{public}s: setting host update time based on message received time: %ld, lease offset = %ld", buf, 0x20u);
      }
    }
    else
    {
      v215 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = 0;
        _os_log_impl((void *)&_mh_execute_header, v215, OS_LOG_TYPE_DEFAULT, "%{public}s: setting host update time based on current time: %ld", buf, 0x16u);
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
      v212 = 0;
      *(_QWORD *)(v170 + 200) = *(_QWORD *)buf;
    }
  }
  else
  {
    v214 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = 0;
      _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, "%{public}s: lease offset = %ld", buf, 0x16u);
    }
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
    v288 = 0;
    v212 = *(_QWORD *)buf - *(_QWORD *)(v170 + 200);
  }
  v216 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v217 = *(_DWORD *)a1;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v217;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1743;
    _os_log_impl((void *)&_mh_execute_header, v216, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v218 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    v219 = v218 + 1;
    *(_DWORD *)a1 = v218 + 1;
    if (v218 + 1 >= 10001)
    {
      v139 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_487;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v219;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = a1;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1743;
      v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_478:
      v277 = v139;
      goto LABEL_486;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)a1 = 1;
  }
  v220 = *(int **)(v170 + 48);
  if (v220)
  {
    v221 = *v220;
    if (!*v220)
    {
      v280 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_487;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v220;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1749;
      v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_485;
    }
    v165 = global_os_log;
    if (v221 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_487;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v221;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v220;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1749;
      v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_427;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v221;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v220;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1749;
      _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v220 = *(int **)(v170 + 48);
      v221 = *v220;
    }
    *v220 = v221 - 1;
    if (v221 == 1)
    {
      v222 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v220;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = "host->update";
        *(_WORD *)&buf[32] = 2080;
        *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 1749;
        _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v220 = *(int **)(v170 + 48);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v220);
    }
    *(_QWORD *)(v170 + 48) = 0;
  }
  else
  {
    v223 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      _os_log_impl((void *)&_mh_execute_header, v223, OS_LOG_TYPE_ERROR, "%{public}s: p_update is null.", buf, 0xCu);
    }
  }
  *(_DWORD *)(v170 + 192) = 0;
  v224 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(v170 + 248) = v224;
  *(_DWORD *)(v170 + 252) = v224;
  v225 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v226 = *(_DWORD *)(*(_QWORD *)(v170 + 72) + 80);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v226;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = v224;
    *(_WORD *)&buf[24] = 1024;
    *(_DWORD *)&buf[26] = v224;
    _os_log_impl((void *)&_mh_execute_header, v225, OS_LOG_TYPE_DEFAULT, "%{public}s: host->message->lease = %d, host->lease_interval = %d, host->key_lease = %d", buf, 0x1Eu);
  }
  v227 = *(_QWORD *)(v170 + 72);
  if (!*(_DWORD *)(v227 + 80))
    *(_QWORD *)(v227 + 80) = *(_QWORD *)(v170 + 248);
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  gettimeofday((timeval *)buf, 0);
  v228 = 1000 * *(_QWORD *)buf + *(_DWORD *)&buf[8] / 1000;
  v229 = *(_QWORD *)(a1 + 112);
  if (!v229)
  {
    v233 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v234 = *(_QWORD *)(v170 + 56);
      v235 = 1000 * (*(unsigned int *)(v170 + 248) - v212);
      *(_DWORD *)buf = 136446979;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 2160;
      *(_QWORD *)&buf[14] = 1752392040;
      *(_WORD *)&buf[22] = 2081;
      *(_QWORD *)&buf[24] = v234;
      *(_WORD *)&buf[32] = 2048;
      *(_QWORD *)&buf[34] = v235;
      _os_log_impl((void *)&_mh_execute_header, v233, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (2) for host %{private, mask.hash}s set to %ld", buf, 0x2Au);
    }
    if (v228 + 1000 * (*(unsigned int *)(v170 + 248) - v212) <= v228)
      v229 = v228;
    else
      v229 = v228 + 1000 * (*(unsigned int *)(v170 + 248) - v212);
    goto LABEL_367;
  }
  v230 = global_os_log;
  if (v229 < v228)
  {
    v231 = 1000 * *(_QWORD *)buf + *(_DWORD *)&buf[8] / 1000;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v232 = *(_QWORD *)(v170 + 64);
      *(_DWORD *)buf = 136446979;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 2160;
      *(_QWORD *)&buf[14] = 1752392040;
      *(_WORD *)&buf[22] = 2081;
      *(_QWORD *)&buf[24] = v232;
      *(_WORD *)&buf[32] = 2048;
      *(_QWORD *)&buf[34] = v228 - v229;
      _os_log_impl((void *)&_mh_execute_header, v230, OS_LOG_TYPE_ERROR, "%{public}s: lease expiry for host %{private, mask.hash}s happened %llu milliseconds ago.", buf, 0x2Au);
      v229 = *(_QWORD *)(a1 + 112);
      v231 = v228;
    }
    goto LABEL_368;
  }
  v231 = *(_QWORD *)(a1 + 112);
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v236 = *(_QWORD *)(v170 + 56);
    *(_DWORD *)buf = 136446979;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 2160;
    *(_QWORD *)&buf[14] = 1752392040;
    *(_WORD *)&buf[22] = 2081;
    *(_QWORD *)&buf[24] = v236;
    *(_WORD *)&buf[32] = 2048;
    *(_QWORD *)&buf[34] = v229 - v228;
    _os_log_impl((void *)&_mh_execute_header, v230, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (1) for host %{private, mask.hash}s set to %lld", buf, 0x2Au);
    v229 = *(_QWORD *)(a1 + 112);
LABEL_367:
    v231 = v229;
  }
LABEL_368:
  *(_QWORD *)(v170 + 256) = v229;
  v237 = *(_QWORD *)(v170 + 112);
  if (*(int *)(v237 + 4) >= 1)
  {
    for (k = 0; k < *(int *)(v237 + 4); ++k)
    {
      v239 = *(_QWORD *)(*(_QWORD *)(v237 + 8) + 8 * k);
      if (v239)
      {
        if (*(int **)(v239 + 88) == v290)
        {
          v249 = *(unsigned __int8 *)(v239 + 116);
          v250 = global_os_log;
          v251 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (!v249)
          {
            v262 = *(_QWORD *)(v291 + 256);
            if (v251)
            {
              v263 = *(_QWORD *)(v291 + 56);
              v264 = *(_QWORD *)(v239 + 48);
              v265 = *(_QWORD *)(v239 + 56);
              *(_DWORD *)buf = 136448003;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2160;
              *(_QWORD *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(_QWORD *)&buf[24] = v263;
              *(_WORD *)&buf[32] = 2160;
              *(_QWORD *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(_QWORD *)&buf[44] = v264;
              *(_WORD *)&buf[52] = 2160;
              *(_QWORD *)&buf[54] = 1752392040;
              *(_WORD *)&buf[62] = 2081;
              *(_QWORD *)&buf[64] = v265;
              *(_WORD *)&buf[72] = 2048;
              *(_QWORD *)&buf[74] = v262 - v228;
              _os_log_impl((void *)&_mh_execute_header, v250, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (4) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s set to %lld", buf, 0x52u);
              v262 = *(_QWORD *)(v291 + 256);
            }
            *(_QWORD *)(v239 + 104) = v262;
            goto LABEL_391;
          }
          if (v251)
          {
            v252 = *(_QWORD *)(v291 + 56);
            v253 = *(_QWORD *)(v239 + 48);
            v254 = *(_QWORD *)(v239 + 56);
            v255 = *(_QWORD *)(v239 + 104) - v228;
            *(_DWORD *)buf = 136448003;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 2160;
            *(_QWORD *)&buf[14] = 1752392040;
            *(_WORD *)&buf[22] = 2081;
            *(_QWORD *)&buf[24] = v252;
            *(_WORD *)&buf[32] = 2160;
            *(_QWORD *)&buf[34] = 1752392040;
            *(_WORD *)&buf[42] = 2081;
            *(_QWORD *)&buf[44] = v253;
            *(_WORD *)&buf[52] = 2160;
            *(_QWORD *)&buf[54] = 1752392040;
            *(_WORD *)&buf[62] = 2081;
            *(_QWORD *)&buf[64] = v254;
            *(_WORD *)&buf[72] = 2048;
            *(_QWORD *)&buf[74] = v255;
            v247 = v250;
            v248 = "%{public}s: lease_expiry (7) for host %{private, mask.hash}s removed instance %{private, mask.hash}s."
                   "%{private, mask.hash}s left at %lld";
            goto LABEL_383;
          }
        }
        else
        {
          v240 = *(_QWORD *)(v239 + 104);
          v241 = global_os_log;
          v242 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (v240 > v228 && v231 > v240)
          {
            v231 = v240;
            if (v242)
            {
              v256 = *(_QWORD *)(v291 + 56);
              v257 = *(_QWORD *)(v239 + 48);
              v258 = *(_QWORD *)(v239 + 56);
              *(_DWORD *)buf = 136448003;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2160;
              *(_QWORD *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(_QWORD *)&buf[24] = v256;
              *(_WORD *)&buf[32] = 2160;
              *(_QWORD *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(_QWORD *)&buf[44] = v257;
              *(_WORD *)&buf[52] = 2160;
              *(_QWORD *)&buf[54] = 1752392040;
              *(_WORD *)&buf[62] = 2081;
              *(_QWORD *)&buf[64] = v258;
              *(_WORD *)&buf[72] = 2048;
              *(_QWORD *)&buf[74] = v240 - v228;
              _os_log_impl((void *)&_mh_execute_header, v241, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (3) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s set to %lld", buf, 0x52u);
              v231 = *(_QWORD *)(v239 + 104);
            }
            goto LABEL_391;
          }
          if (v240 <= v228)
          {
            v231 = v228;
            if (v242)
            {
              v259 = *(_QWORD *)(v291 + 56);
              v260 = *(_QWORD *)(v239 + 48);
              v261 = *(_QWORD *)(v239 + 56);
              *(_DWORD *)buf = 136448003;
              *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&buf[12] = 2160;
              *(_QWORD *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(_QWORD *)&buf[24] = v259;
              *(_WORD *)&buf[32] = 2160;
              *(_QWORD *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(_QWORD *)&buf[44] = v260;
              *(_WORD *)&buf[52] = 2160;
              *(_QWORD *)&buf[54] = 1752392040;
              *(_WORD *)&buf[62] = 2081;
              *(_QWORD *)&buf[64] = v261;
              *(_WORD *)&buf[72] = 2048;
              *(_QWORD *)&buf[74] = v228 - v240;
              _os_log_impl((void *)&_mh_execute_header, v241, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (5) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s in the past at %lld", buf, 0x52u);
              v231 = v228;
            }
            goto LABEL_391;
          }
          if (v242)
          {
            v244 = *(_QWORD *)(v291 + 56);
            v245 = *(_QWORD *)(v239 + 48);
            v246 = *(_QWORD *)(v239 + 56);
            *(_DWORD *)buf = 136448003;
            *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&buf[12] = 2160;
            *(_QWORD *)&buf[14] = 1752392040;
            *(_WORD *)&buf[22] = 2081;
            *(_QWORD *)&buf[24] = v244;
            *(_WORD *)&buf[32] = 2160;
            *(_QWORD *)&buf[34] = 1752392040;
            *(_WORD *)&buf[42] = 2081;
            *(_QWORD *)&buf[44] = v245;
            *(_WORD *)&buf[52] = 2160;
            *(_QWORD *)&buf[54] = 1752392040;
            *(_WORD *)&buf[62] = 2081;
            *(_QWORD *)&buf[64] = v246;
            *(_WORD *)&buf[72] = 2048;
            *(_QWORD *)&buf[74] = v231 - v240;
            v247 = v241;
            v248 = "%{public}s: lease_expiry (6) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{privat"
                   "e, mask.hash}s is later than next_lease_expiry by %lld";
LABEL_383:
            _os_log_impl((void *)&_mh_execute_header, v247, OS_LOG_TYPE_DEFAULT, v248, buf, 0x52u);
          }
        }
      }
LABEL_391:
      v237 = *(_QWORD *)(v291 + 112);
    }
  }
  if ((unint64_t)(v231 - v228) >= 0x7FFFFFFF)
    v266 = 0x7FFFFFFF;
  else
    v266 = v231 - v228;
  v267 = global_os_log;
  v268 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v231 == v228)
  {
    if (v268)
    {
      v269 = *(_QWORD *)(v291 + 56);
      *(_DWORD *)buf = 136446723;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 2160;
      *(_QWORD *)&buf[14] = 1752392040;
      *(_WORD *)&buf[22] = 2081;
      *(_QWORD *)&buf[24] = v269;
      _os_log_impl((void *)&_mh_execute_header, v267, OS_LOG_TYPE_DEFAULT, "%{public}s: scheduling immediate call to lease_callback in the run loop for %{private, mask.hash}s", buf, 0x20u);
    }
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 0x40000000;
    *(_QWORD *)&buf[16] = __ioloop_run_async_block_invoke;
    *(_QWORD *)&buf[24] = &__block_descriptor_tmp_39;
    *(_QWORD *)&buf[32] = lease_callback;
    *(_QWORD *)&buf[40] = v291;
    dispatch_async((dispatch_queue_t)ioloop_main_queue, buf);
  }
  else
  {
    if (v268)
    {
      v270 = *(_QWORD *)(v291 + 56);
      *(_DWORD *)buf = 136446979;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v266 / 0x3E8uLL;
      *(_WORD *)&buf[22] = 2160;
      *(_QWORD *)&buf[24] = 1752392040;
      *(_WORD *)&buf[32] = 2081;
      *(_QWORD *)&buf[34] = v270;
      _os_log_impl((void *)&_mh_execute_header, v267, OS_LOG_TYPE_DEFAULT, "%{public}s: scheduling wakeup to lease_callback in %llu for host %{private, mask.hash}s", buf, 0x2Au);
    }
    ioloop_add_wake_event(*(_QWORD *)(v291 + 32), v291, (uint64_t)lease_callback, (uint64_t)srp_adv_host_context_release, v266);
    v271 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v272 = *(_DWORD *)v291;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v272;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v291;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1888;
      _os_log_impl((void *)&_mh_execute_header, v271, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v273 = *(_DWORD *)v291;
    if (*(_DWORD *)v291)
    {
      v274 = v273 + 1;
      *(_DWORD *)v291 = v273 + 1;
      if (v273 + 1 >= 10001)
      {
        v280 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_487;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v274;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v291;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "host";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1888;
        v200 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_485;
      }
    }
    else
    {
      ++adv_host_created;
      *(_DWORD *)v291 = 1;
    }
  }
  adv_update_free_instance_vectors(a1);
  v275 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v139 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_487;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = 0;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1897;
    v200 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_478;
  }
  v139 = global_os_log;
  if (v275 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_487;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v275;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1897;
    v200 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_478;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v275;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1897;
    _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v275 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v275 - 1;
  if (v275 == 1)
  {
    v276 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = a1;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = "update";
      *(_WORD *)&buf[32] = 2080;
      *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1897;
      _os_log_impl((void *)&_mh_execute_header, v276, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize(a1);
  }
  if (v288)
    srp_update_start(v288);
  else
    srp_dump_server_stats(v285, 0, 0);
}

_QWORD *adv_record_vec_create(unsigned int a1)
{
  _QWORD *v2;
  int v3;
  void *v4;
  NSObject *v5;
  int v6;
  int v7;
  NSObject *v8;
  int v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  _QWORD *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  int v22;

  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  if (v2)
  {
    if (a1 <= 1)
      v3 = 1;
    else
      v3 = a1;
    v4 = malloc_type_calloc(v3, 8uLL, 0x2004093837F09uLL);
    v2[1] = v4;
    if (v4)
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_DWORD *)v2;
        *(_DWORD *)buf = 136447490;
        v12 = "adv_record_vec_create";
        v13 = 1024;
        v14 = v6;
        v15 = 2048;
        v16 = v2;
        v17 = 2080;
        v18 = "vec";
        v19 = 2080;
        v20 = "srp-mdns-proxy.c";
        v21 = 1024;
        v22 = 309;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      if (*(_DWORD *)v2)
      {
        v7 = *(_DWORD *)v2 + 1;
        *(_DWORD *)v2 = v7;
        if (v7 >= 10001)
        {
          v10 = v7;
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v12 = "adv_record_vec_create";
            v13 = 1024;
            v14 = v10;
            v15 = 2048;
            v16 = v2;
            v17 = 2080;
            v18 = "vec";
            v19 = 2080;
            v20 = "srp-mdns-proxy.c";
            v21 = 1024;
            v22 = 309;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++adv_record_vec_created;
        *(_DWORD *)v2 = 1;
      }
    }
    else
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void update_failed(uint64_t a1, unsigned int a2, int a3)
{
  NSObject *v6;
  int v7;
  int v8;
  int v9;
  NSObject *v10;
  const char *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  NSObject *v16;
  int v17;
  _BYTE v18[48];
  __int16 v19;
  int v20;

  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *(_DWORD *)a1;
    *(_DWORD *)v18 = 136447490;
    *(_QWORD *)&v18[4] = "update_failed";
    *(_WORD *)&v18[12] = 1024;
    *(_DWORD *)&v18[14] = v7;
    *(_WORD *)&v18[18] = 2048;
    *(_QWORD *)&v18[20] = a1;
    *(_WORD *)&v18[28] = 2080;
    *(_QWORD *)&v18[30] = "update";
    *(_WORD *)&v18[38] = 2080;
    *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
    v19 = 1024;
    v20 = 1034;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
  }
  v8 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    v9 = v8 + 1;
    *(_DWORD *)a1 = v8 + 1;
    if (v8 + 1 >= 10001)
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_39;
      *(_DWORD *)v18 = 136447490;
      *(_QWORD *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = v9;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(_QWORD *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
      v19 = 1024;
      v20 = 1034;
      v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)a1 = 1;
  }
  v12 = *(_QWORD **)(a1 + 16);
  if (v12)
  {
    v13 = *(_QWORD *)(a1 + 8);
    adv_update_cancel(a1);
    advertise_finished(*(_QWORD *)(v13 + 56), v12[1], v12[4], a2, 0, 1);
    srp_parse_client_updates_free_(v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1044);
    *(_QWORD *)(a1 + 16) = 0;
    if (a3)
    {
      v14 = *(_QWORD *)(v13 + 256);
      if (!v14
        || (*(_QWORD *)v18 = 0,
            *(_QWORD *)&v18[8] = 0,
            gettimeofday((timeval *)v18, 0),
            v14 <= 1000 * *(_QWORD *)v18 + *(_DWORD *)&v18[8] / 1000))
      {
        delete_host(v13);
      }
    }
    v15 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_39;
      *(_DWORD *)v18 = 136447490;
      *(_QWORD *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = 0;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(_QWORD *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
      v19 = 1024;
      v20 = 1053;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    v10 = global_os_log;
    if (v15 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_39;
      *(_DWORD *)v18 = 136447490;
      *(_QWORD *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = v15;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(_QWORD *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
      v19 = 1024;
      v20 = 1053;
      v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v18 = 136447490;
      *(_QWORD *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = v15;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(_QWORD *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
      v19 = 1024;
      v20 = 1053;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
      v15 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v15 - 1;
    if (v15 == 1)
    {
      v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v18 = 136447234;
        *(_QWORD *)&v18[4] = "update_failed";
        *(_WORD *)&v18[12] = 2048;
        *(_QWORD *)&v18[14] = a1;
        *(_WORD *)&v18[22] = 2080;
        *(_QWORD *)&v18[24] = "update";
        *(_WORD *)&v18[32] = 2080;
        *(_QWORD *)&v18[34] = "srp-mdns-proxy.c";
        *(_WORD *)&v18[42] = 1024;
        *(_DWORD *)&v18[44] = 1053;
LABEL_27:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v18, 0x30u);
        goto LABEL_28;
      }
      goto LABEL_28;
    }
  }
  else
  {
    adv_update_cancel(a1);
    v17 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_39;
      *(_DWORD *)v18 = 136447490;
      *(_QWORD *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = 0;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(_QWORD *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
      v19 = 1024;
      v20 = 1057;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    v10 = global_os_log;
    if (v17 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_39;
      *(_DWORD *)v18 = 136447490;
      *(_QWORD *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = v17;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(_QWORD *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
      v19 = 1024;
      v20 = 1057;
      v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_38:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, v11, v18, 0x36u);
LABEL_39:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v18 = 136447490;
      *(_QWORD *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&v18[14] = v17;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(_QWORD *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(_QWORD *)&v18[40] = "srp-mdns-proxy.c";
      v19 = 1024;
      v20 = 1057;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
      v17 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v17 - 1;
    if (v17 == 1)
    {
      v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v18 = 136447234;
        *(_QWORD *)&v18[4] = "update_failed";
        *(_WORD *)&v18[12] = 2048;
        *(_QWORD *)&v18[14] = a1;
        *(_WORD *)&v18[22] = 2080;
        *(_QWORD *)&v18[24] = "update";
        *(_WORD *)&v18[32] = 2080;
        *(_QWORD *)&v18[34] = "srp-mdns-proxy.c";
        *(_WORD *)&v18[42] = 1024;
        *(_DWORD *)&v18[44] = 1057;
        goto LABEL_27;
      }
LABEL_28:
      ++adv_update_finalized;
      adv_update_finalize(a1);
    }
  }
}

_QWORD *adv_instance_vec_create(unsigned int a1)
{
  _QWORD *v2;
  int v3;
  void *v4;
  NSObject *v5;
  int v6;
  int v7;
  NSObject *v8;
  int v10;
  uint8_t buf[4];
  const char *v12;
  __int16 v13;
  int v14;
  __int16 v15;
  _QWORD *v16;
  __int16 v17;
  const char *v18;
  __int16 v19;
  char *v20;
  __int16 v21;
  int v22;

  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  if (v2)
  {
    if (a1 <= 1)
      v3 = 1;
    else
      v3 = a1;
    v4 = malloc_type_calloc(v3, 8uLL, 0x2004093837F09uLL);
    v2[1] = v4;
    if (v4)
    {
      v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v6 = *(_DWORD *)v2;
        *(_DWORD *)buf = 136447490;
        v12 = "adv_instance_vec_create";
        v13 = 1024;
        v14 = v6;
        v15 = 2048;
        v16 = v2;
        v17 = 2080;
        v18 = "vec";
        v19 = 2080;
        v20 = "srp-mdns-proxy.c";
        v21 = 1024;
        v22 = 305;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      if (*(_DWORD *)v2)
      {
        v7 = *(_DWORD *)v2 + 1;
        *(_DWORD *)v2 = v7;
        if (v7 >= 10001)
        {
          v10 = v7;
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v12 = "adv_instance_vec_create";
            v13 = 1024;
            v14 = v10;
            v15 = 2048;
            v16 = v2;
            v17 = 2080;
            v18 = "vec";
            v19 = 2080;
            v20 = "srp-mdns-proxy.c";
            v21 = 1024;
            v22 = 305;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++adv_instance_vec_created;
        *(_DWORD *)v2 = 1;
      }
    }
    else
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void set_instance_message(uint64_t a1, int *a2)
{
  int *v4;

  if (a2 && *(int **)(a1 + 96) == a2)
  {
    v4 = *(int **)(a1 + 88);
    if (v4)
      ioloop_message_release_(v4, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1404);
    *(_QWORD *)(a1 + 88) = a2;
    ioloop_message_retain_(a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1407);
    *(_QWORD *)(a1 + 96) = 0;
  }
}

void advertise_finished(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, char a6)
{
  NSObject *v12;
  const char *v13;
  int v14;
  int v15;
  int64_t v16;
  NSObject *v17;
  NSObject *v18;
  int v19;
  const char *v20;
  _BYTE buf[22];
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  int v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  _WORD v32[2];
  uint64_t v33;
  _OWORD v34[31];
  int v35;
  uint64_t v36;

  v35 = 0;
  memset(v34, 0, sizeof(v34));
  v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a4 > 0x17)
    {
      v13 = "Unknown rcode.";
      if (a5)
        goto LABEL_4;
    }
    else
    {
      v13 = (&off_10008D1C8)[a4];
      if (a5)
      {
LABEL_4:
        v14 = *(_DWORD *)(a5 + 88);
        v15 = *(_DWORD *)(a5 + 92);
LABEL_7:
        *(_DWORD *)buf = 136447747;
        *(_QWORD *)&buf[4] = "advertise_finished";
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        v22 = 2081;
        v23 = a1;
        v24 = 2082;
        v25 = v13;
        v26 = 1024;
        v27 = v14;
        v28 = 1024;
        v29 = v15;
        v30 = 2048;
        v31 = a2;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s: rcode = %{public}s, lease = %d, key_lease = %d  connection = %p", buf, 0x40u);
        goto LABEL_8;
      }
    }
    v14 = 0;
    v15 = 0;
    goto LABEL_7;
  }
LABEL_8:
  if (!a2)
    return;
  if ((a6 & 1) != 0)
  {
    v33 = 0;
    v32[0] = *(_WORD *)(a3 + 88);
    v32[1] = bswap32(a4 | (bswap32(*(_WORD *)(a3 + 90) & 0xF0FF) >> 16) | 0x8000) >> 16;
    *(_QWORD *)buf = v32;
    if (a5)
    {
      v33 = 0x100000000000000;
      *(_QWORD *)&v34[0] = 0x8000008205290000;
      BYTE8(v34[0]) = 0;
      if ((uint64_t *)((char *)v34 + 13) < &v36)
      {
        *(_WORD *)((char *)v34 + 11) = 512;
        if ((uint64_t *)((char *)v34 + 15) < &v36 && (uint64_t *)((char *)&v34[1] + 3) < &v36)
        {
          *(_DWORD *)((char *)v34 + 15) = bswap32(*(_DWORD *)(a5 + 88));
          if ((uint64_t *)((char *)&v34[1] + 7) < &v36)
          {
            *(_DWORD *)((char *)&v34[1] + 3) = bswap32(*(_DWORD *)(a5 + 92));
            if (v32 != (_WORD *)-25)
            {
              *(_WORD *)((char *)v34 + 13) = bswap32(8u) >> 16;
              BYTE9(v34[0]) = (unsigned __int16)((char *)&v34[1] + 7 - ((char *)v34 + 9) - 2) >> 8;
              BYTE10(v34[0]) = (char *)&v34[1] + 7 - ((char *)v34 + 9) - 2;
              v16 = (char *)&v34[1] + 7 - (char *)v32;
LABEL_22:
              *(_QWORD *)&buf[8] = v16;
              ioloop_send_message(a2, a3, (iovec *)buf);
              return;
            }
          }
        }
      }
      v18 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v19 = 136446210;
        v20 = "advertise_finished";
        v16 = 12;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: unexpectedly failed to send EDNS0 lease option.", (uint8_t *)&v19, 0xCu);
        goto LABEL_22;
      }
    }
    v16 = 12;
    goto LABEL_22;
  }
  v17 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "advertise_finished";
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: not sending response.", buf, 0xCu);
  }
}

void lease_callback(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  NSObject *v18;
  _BOOL4 v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int *v23;
  int v24;
  NSObject *v25;
  NSObject *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  NSObject *v36;
  uint64_t v37;
  unsigned int v38;
  NSObject *v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  const char *v44;
  NSObject *v45;
  uint64_t v46;
  _BYTE v47[54];
  uint64_t v48;
  __int16 v49;
  uint64_t v50;

  *(_QWORD *)v47 = 0;
  *(_QWORD *)&v47[8] = 0;
  gettimeofday((timeval *)v47, 0);
  v2 = *(_QWORD *)v47;
  v3 = *(_DWORD *)&v47[8];
  v4 = host_ready(a1);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (!v6)
      return;
    *(_DWORD *)v47 = 136446210;
    *(_QWORD *)&v47[4] = "lease_callback";
    v9 = "%{public}s: host expired";
    v10 = v5;
    goto LABEL_40;
  }
  v7 = 1000 * v2 + v3 / 1000;
  if (v6)
  {
    v8 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)v47 = 136446723;
    *(_QWORD *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 2160;
    *(_QWORD *)&v47[14] = 1752392040;
    *(_WORD *)&v47[22] = 2081;
    *(_QWORD *)&v47[24] = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s", v47, 0x20u);
  }
  if (*(_QWORD *)(a1 + 256) < v7)
  {
    delete_host(a1);
    return;
  }
  v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v12 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)v47 = 136446723;
    *(_QWORD *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 2160;
    *(_QWORD *)&v47[14] = 1752392040;
    *(_WORD *)&v47[22] = 2081;
    *(_QWORD *)&v47[24] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s is still alive", v47, 0x20u);
  }
  v13 = *(_QWORD *)(a1 + 112);
  if (!v13)
  {
    v35 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)v47 = 136446210;
    *(_QWORD *)&v47[4] = "lease_callback";
    v9 = "%{public}s: no instances";
    v10 = v35;
LABEL_40:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, v47, 0xCu);
    return;
  }
  LODWORD(v14) = *(_DWORD *)(v13 + 4);
  if ((int)v14 <= 0)
  {
    v32 = 0;
    v30 = *(_QWORD *)(a1 + 256);
  }
  else
  {
    v15 = 0;
    do
    {
      v16 = *(void **)(*(_QWORD *)(v13 + 8) + 8 * v15);
      if (v16)
      {
        v17 = *((_QWORD *)v16 + 13);
        v18 = global_os_log;
        v19 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        if (v17 >= v7)
        {
          if (v19)
          {
            v27 = *(_QWORD *)(a1 + 56);
            v28 = *((_QWORD *)v16 + 6);
            v29 = *((_QWORD *)v16 + 7);
            *(_DWORD *)v47 = 136447747;
            *(_QWORD *)&v47[4] = "lease_callback";
            *(_WORD *)&v47[12] = 2160;
            *(_QWORD *)&v47[14] = 1752392040;
            *(_WORD *)&v47[22] = 2081;
            *(_QWORD *)&v47[24] = v27;
            *(_WORD *)&v47[32] = 2160;
            *(_QWORD *)&v47[34] = 1752392040;
            *(_WORD *)&v47[42] = 2081;
            *(_QWORD *)&v47[44] = v28;
            *(_WORD *)&v47[52] = 2160;
            v48 = 1752392040;
            v49 = 2081;
            v50 = v29;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s has not expired", v47, 0x48u);
          }
        }
        else
        {
          if (v19)
          {
            v20 = *(_QWORD *)(a1 + 56);
            v21 = *((_QWORD *)v16 + 6);
            v22 = *((_QWORD *)v16 + 7);
            *(_DWORD *)v47 = 136447747;
            *(_QWORD *)&v47[4] = "lease_callback";
            *(_WORD *)&v47[12] = 2160;
            *(_QWORD *)&v47[14] = 1752392040;
            *(_WORD *)&v47[22] = 2081;
            *(_QWORD *)&v47[24] = v20;
            *(_WORD *)&v47[32] = 2160;
            *(_QWORD *)&v47[34] = 1752392040;
            *(_WORD *)&v47[42] = 2081;
            *(_QWORD *)&v47[44] = v21;
            *(_WORD *)&v47[52] = 2160;
            v48 = 1752392040;
            v49 = 2081;
            v50 = v22;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s has expired", v47, 0x48u);
          }
          v23 = (int *)*((_QWORD *)v16 + 1);
          if (v23)
          {
            *((_QWORD *)v16 + 1) = 0;
            ioloop_dnssd_txn_release_(v23, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1323);
          }
          *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 8 * v15) = 0;
          v24 = *(_DWORD *)v16;
          if (!*(_DWORD *)v16)
          {
            v46 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)v47 = 136447490;
              *(_QWORD *)&v47[4] = "lease_callback";
              *(_WORD *)&v47[12] = 1024;
              *(_DWORD *)&v47[14] = 0;
              *(_WORD *)&v47[18] = 2048;
              *(_QWORD *)&v47[20] = v16;
              *(_WORD *)&v47[28] = 2080;
              *(_QWORD *)&v47[30] = "instance";
              *(_WORD *)&v47[38] = 2080;
              *(_QWORD *)&v47[40] = "srp-mdns-proxy.c";
              *(_WORD *)&v47[48] = 1024;
              *(_DWORD *)&v47[50] = 1326;
              v44 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              v45 = v46;
              goto LABEL_60;
            }
LABEL_61:
            abort();
          }
          v25 = global_os_log;
          if (v24 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)v47 = 136447490;
              *(_QWORD *)&v47[4] = "lease_callback";
              *(_WORD *)&v47[12] = 1024;
              *(_DWORD *)&v47[14] = v24;
              *(_WORD *)&v47[18] = 2048;
              *(_QWORD *)&v47[20] = v16;
              *(_WORD *)&v47[28] = 2080;
              *(_QWORD *)&v47[30] = "instance";
              *(_WORD *)&v47[38] = 2080;
              *(_QWORD *)&v47[40] = "srp-mdns-proxy.c";
              *(_WORD *)&v47[48] = 1024;
              *(_DWORD *)&v47[50] = 1326;
              v44 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              v45 = v25;
LABEL_60:
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, v44, v47, 0x36u);
            }
            goto LABEL_61;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v47 = 136447490;
            *(_QWORD *)&v47[4] = "lease_callback";
            *(_WORD *)&v47[12] = 1024;
            *(_DWORD *)&v47[14] = v24;
            *(_WORD *)&v47[18] = 2048;
            *(_QWORD *)&v47[20] = v16;
            *(_WORD *)&v47[28] = 2080;
            *(_QWORD *)&v47[30] = "instance";
            *(_WORD *)&v47[38] = 2080;
            *(_QWORD *)&v47[40] = "srp-mdns-proxy.c";
            *(_WORD *)&v47[48] = 1024;
            *(_DWORD *)&v47[50] = 1326;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v47, 0x36u);
            v24 = *(_DWORD *)v16;
          }
          *(_DWORD *)v16 = v24 - 1;
          if (v24 == 1)
          {
            v26 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v47 = 136447234;
              *(_QWORD *)&v47[4] = "lease_callback";
              *(_WORD *)&v47[12] = 2048;
              *(_QWORD *)&v47[14] = v16;
              *(_WORD *)&v47[22] = 2080;
              *(_QWORD *)&v47[24] = "instance";
              *(_WORD *)&v47[32] = 2080;
              *(_QWORD *)&v47[34] = "srp-mdns-proxy.c";
              *(_WORD *)&v47[42] = 1024;
              *(_DWORD *)&v47[44] = 1326;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v47, 0x30u);
            }
            ++adv_instance_finalized;
            adv_instance_finalize(v16);
          }
        }
      }
      ++v15;
      v13 = *(_QWORD *)(a1 + 112);
      v14 = *(int *)(v13 + 4);
    }
    while (v15 < v14);
    v30 = *(_QWORD *)(a1 + 256);
    if ((int)v14 < 1)
    {
      v32 = 0;
    }
    else
    {
      v31 = 0;
      v32 = 0;
      do
      {
        v33 = *(_QWORD *)(v13 + 8);
        v34 = *(_QWORD *)(v33 + 8 * v31);
        if (v34)
        {
          *(_QWORD *)(v33 + 8 * v32++) = v34;
          if (v30 >= *(_QWORD *)(v34 + 104))
            v30 = *(_QWORD *)(v34 + 104);
          v13 = *(_QWORD *)(a1 + 112);
        }
        ++v31;
        v14 = *(int *)(v13 + 4);
      }
      while (v31 < v14);
    }
  }
  v36 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v37 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)v47 = 136446979;
    *(_QWORD *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 2160;
    *(_QWORD *)&v47[14] = 1752392040;
    *(_WORD *)&v47[22] = 2081;
    *(_QWORD *)&v47[24] = v37;
    *(_WORD *)&v47[32] = 1024;
    *(_DWORD *)&v47[34] = v14 - v32;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s lost %d instances", v47, 0x26u);
    v13 = *(_QWORD *)(a1 + 112);
  }
  *(_DWORD *)(v13 + 4) = v32;
  if ((unint64_t)(v30 - v7) >= 0x7FFFFFFF)
    v38 = 0x7FFFFFFF;
  else
    v38 = v30 - v7;
  ioloop_add_wake_event(*(_QWORD *)(a1 + 32), a1, (uint64_t)lease_callback, (uint64_t)srp_adv_host_context_release, v38);
  v39 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v40 = *(_DWORD *)a1;
    *(_DWORD *)v47 = 136447490;
    *(_QWORD *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 1024;
    *(_DWORD *)&v47[14] = v40;
    *(_WORD *)&v47[18] = 2048;
    *(_QWORD *)&v47[20] = a1;
    *(_WORD *)&v47[28] = 2080;
    *(_QWORD *)&v47[30] = "host";
    *(_WORD *)&v47[38] = 2080;
    *(_QWORD *)&v47[40] = "srp-mdns-proxy.c";
    *(_WORD *)&v47[48] = 1024;
    *(_DWORD *)&v47[50] = 1359;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v47, 0x36u);
  }
  v41 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    v42 = v41 + 1;
    *(_DWORD *)a1 = v41 + 1;
    if (v41 + 1 >= 10001)
    {
      v43 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)v47 = 136447490;
        *(_QWORD *)&v47[4] = "lease_callback";
        *(_WORD *)&v47[12] = 1024;
        *(_DWORD *)&v47[14] = v42;
        *(_WORD *)&v47[18] = 2048;
        *(_QWORD *)&v47[20] = a1;
        *(_WORD *)&v47[28] = 2080;
        *(_QWORD *)&v47[30] = "host";
        *(_WORD *)&v47[38] = 2080;
        *(_QWORD *)&v47[40] = "srp-mdns-proxy.c";
        *(_WORD *)&v47[48] = 1024;
        *(_DWORD *)&v47[50] = 1359;
        v44 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        v45 = v43;
        goto LABEL_60;
      }
      goto LABEL_61;
    }
  }
  else
  {
    ++adv_host_created;
    *(_DWORD *)a1 = 1;
  }
}

void srp_adv_host_context_release(int *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *a1;
  if (!*a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "srp_adv_host_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 686;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "srp_adv_host_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 686;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "srp_adv_host_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 686;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "srp_adv_host_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "host";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 686;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++adv_host_finalized;
    adv_host_finalize((uint64_t)a1);
  }
}

uint64_t srp_update_start(uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  NSObject *v17;
  char *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  char v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  uint64_t *v27;
  const char *v28;
  uint64_t *i;
  int v30;
  uint64_t v31;
  _BOOL4 v32;
  void *v33;
  int v34;
  const char *v35;
  void *v36;
  NSObject *v37;
  const char *v38;
  uint32_t v39;
  _QWORD *v40;
  NSObject *v41;
  uint64_t v42;
  int v43;
  void *v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t *v47;
  uint64_t v48;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  NSObject *v57;
  uint64_t v58;
  uint64_t v60;
  uint64_t *v62;
  uint64_t *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t j;
  uint64_t v67;
  const char *v68;
  int v69;
  NSObject *v70;
  _BOOL4 v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  uint64_t v76;
  const char *v77;
  const char *v78;
  uint64_t *v79;
  NSObject *v80;
  int v81;
  uint64_t v82;
  _DWORD *v83;
  NSObject *v84;
  uint64_t v85;
  NSObject *v86;
  uint64_t v87;
  const char *v88;
  char *v89;
  uint64_t v90;
  int v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t *v99;
  const char *v100;
  int v101;
  void *v102;
  NSObject *v103;
  int v104;
  int v105;
  int v106;
  uint64_t v107;
  const char *v108;
  NSObject *v109;
  NSObject *v110;
  NSObject *v111;
  uint64_t v112;
  uint64_t v113;
  _BOOL4 v114;
  const char *v115;
  NSObject *v116;
  uint32_t v117;
  _QWORD *v118;
  _QWORD *v119;
  int *v120;
  int *v121;
  NSObject *v122;
  int v123;
  NSObject *v124;
  NSObject *v125;
  int v126;
  NSObject *v127;
  NSObject *v128;
  int v129;
  int *v130;
  char *v131;
  _OWORD *v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  _WORD *v136;
  uint64_t v137;
  NSObject *v138;
  int v139;
  int v140;
  NSObject *v141;
  NSObject *v142;
  int v143;
  NSObject *v144;
  int v145;
  unsigned int v146;
  unsigned int v147;
  unsigned int v148;
  NSObject *v149;
  _BOOL4 v150;
  int v151;
  NSObject *v152;
  const char *v153;
  const char *v154;
  int v155;
  unsigned int v156;
  unsigned int v157;
  NSObject *v158;
  int v159;
  int v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  _DWORD *v164;
  uint64_t *v165;
  _QWORD *v166;
  uint64_t *v167;
  int v168;
  uint64_t v169;
  uint8_t v170[4];
  const char *v171;
  __int16 v172;
  uint64_t v173;
  __int16 v174;
  char *v175;
  __int16 v176;
  uint64_t v177;
  __int16 v178;
  _BYTE *v179;
  _BYTE buf[12];
  __int16 v181;
  _BYTE v182[90];
  __int16 v183;
  uint64_t v184;
  __int16 v185;
  int v186;
  __int16 v187;
  uint64_t *v188;
  __int16 v189;
  void *v190;
  char v191[506];
  char __s1[253];
  char v193[1010];
  char __str[200];
  char __s2[1010];

  v1 = a1;
  v2 = a1[5];
  v3 = a1[10];
  dns_name_print_to_limit(*(uint64_t **)v2, 0, (uint64_t)__s2, 0x3F2uLL);
  v4 = 0;
  v5 = v1[4];
  v6 = v1;
  v7 = v1[1];
  do
  {
    v8 = *(_QWORD *)(v6[5] + 16);
    v9 = *(unsigned int *)(v8 + 20);
    if ((_DWORD)v9)
    {
      v10 = 0;
      v11 = 0;
      v12 = *(_QWORD *)(v8 + 24);
      do
      {
        v11 += bswap32(*(_DWORD *)(v12 + v10));
        v10 += 4;
      }
      while (v10 < v9);
    }
    else
    {
      v11 = 0;
    }
    if (v6 == v1)
    {
      v4 = v11;
    }
    else if (v4 != v11)
    {
      v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(_QWORD *)&buf[4] = "srp_update_start";
        v181 = 1024;
        *(_DWORD *)v182 = v4;
        *(_WORD *)&v182[4] = 1024;
        *(_DWORD *)&v182[6] = v11;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%{public}s: update contains multiple key ids %x and %x", buf, 0x18u);
      }
      v19 = __s2;
      v20 = 0;
      v21 = v5;
      v22 = 5;
      v23 = 0;
      goto LABEL_146;
    }
    v6 = (uint64_t *)*v6;
  }
  while (v6);
  v169 = v1[2];
  if (!v169)
  {
    v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_27;
    v16 = &unk_10007C3B5;
    goto LABEL_25;
  }
  v13 = v2;
  v14 = *(_QWORD *)(v3 + 8);
  if (!v14)
  {
LABEL_17:
    v2 = v13;
LABEL_18:
    v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_27;
    v16 = *(void **)(v169 + 16);
LABEL_25:
    *(_DWORD *)buf = 136447235;
    *(_QWORD *)&buf[4] = "srp_update_start";
    v181 = 2160;
    *(_QWORD *)v182 = 1752392040;
    *(_WORD *)&v182[8] = 2081;
    *(_QWORD *)&v182[10] = __s2;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = v4;
    *(_WORD *)&v182[24] = 2082;
    *(_QWORD *)&v182[26] = v16;
    v24 = "%{public}s: host update for %{private, mask.hash}s, key id %x %{public}s";
    v25 = v15;
    v26 = 48;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
    goto LABEL_27;
  }
  while (*(_DWORD *)(v14 + 184) != v4 || strcmp(*(const char **)(v14 + 56), __s2))
  {
    v14 = *(_QWORD *)(v14 + 40);
    if (!v14)
      goto LABEL_17;
  }
  v88 = (const char *)&unk_10007C3B5;
  v89 = __str;
  while (1)
  {
    v90 = *(_QWORD *)(v14 + 72);
    if (!v90 || (v91 = *(unsigned __int16 *)(v90 + 88), v91 != *(unsigned __int16 *)(v1[4] + 88)))
    {
      v93 = *(_QWORD *)(v14 + 112);
      if (!v93 || (v94 = *(unsigned int *)(v93 + 4), (int)v94 < 1))
      {
LABEL_164:
        v2 = v13;
        goto LABEL_165;
      }
      v95 = *(_QWORD *)(v93 + 8);
      while (1)
      {
        if (*(_QWORD *)v95)
        {
          v96 = *(_QWORD *)(*(_QWORD *)v95 + 88);
          if (v96)
          {
            v91 = *(unsigned __int16 *)(v96 + 88);
            if (v91 == *(unsigned __int16 *)(v1[4] + 88))
              break;
          }
        }
        v95 += 8;
        if (!--v94)
          goto LABEL_164;
      }
    }
    v92 = v1;
    v1 = (uint64_t *)*v1;
    if (v89 != __str)
      v88 = "s";
    if (v89 + 6 < __s2)
    {
      snprintf(v89, 6uLL, " %04x", v91);
      v89 += 5;
    }
    *v92 = 0;
    srp_parse_client_updates_free_(v92, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3777);
    if (!v1)
      break;
    v13 = v1[5];
  }
  v2 = 0;
LABEL_165:
  if (v89 == __str)
    goto LABEL_18;
  v97 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v98 = *(_QWORD *)(v169 + 16);
    *(_DWORD *)buf = 136447747;
    *(_QWORD *)&buf[4] = "srp_update_start";
    v181 = 2160;
    *(_QWORD *)v182 = 1752392040;
    *(_WORD *)&v182[8] = 2081;
    *(_QWORD *)&v182[10] = __s2;
    *(_WORD *)&v182[18] = 1024;
    *(_DWORD *)&v182[20] = v4;
    *(_WORD *)&v182[24] = 2082;
    *(_QWORD *)&v182[26] = v98;
    *(_WORD *)&v182[34] = 2082;
    *(_QWORD *)&v182[36] = v88;
    *(_WORD *)&v182[44] = 2082;
    *(_QWORD *)&v182[46] = __str;
    v24 = "%{public}s: host update for %{private, mask.hash}s, key id %x %{public}s (skipped xid%{public}s%{public}s)";
    v25 = v97;
    v26 = 68;
    goto LABEL_26;
  }
LABEL_27:
  if (!v1)
  {
    advertise_finished((uint64_t)__s2, 0, v5, 0, 0, 0);
    return 1;
  }
  v164 = (_DWORD *)v3;
  v165 = v1;
  v161 = v7;
  v162 = v5;
  v166 = (_QWORD *)v1[6];
  v27 = (uint64_t *)v1[8];
  v159 = *((_DWORD *)v1 + 22);
  v160 = v4;
  if (v159)
    v28 = "update";
  else
    v28 = "remove";
  v163 = v2;
  for (i = *(uint64_t **)(v2 + 8); i; i = (uint64_t *)*i)
  {
    v30 = *((unsigned __int16 *)i + 8);
    v31 = global_os_log;
    v32 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v30 == 1)
    {
      if (v32)
      {
        if (v169)
          v33 = *(void **)(v169 + 16);
        else
          v33 = &unk_10007C3B5;
        *(_DWORD *)buf = 136448003;
        *(_QWORD *)&buf[4] = "srp_update_start";
        v181 = 2082;
        *(_QWORD *)v182 = v28;
        *(_WORD *)&v182[8] = 2160;
        *(_QWORD *)&v182[10] = 1752392040;
        *(_WORD *)&v182[18] = 2081;
        *(_QWORD *)&v182[20] = __s2;
        *(_WORD *)&v182[28] = 2160;
        *(_QWORD *)&v182[30] = 1752392040;
        *(_WORD *)&v182[38] = 1041;
        *(_DWORD *)&v182[40] = 4;
        *(_WORD *)&v182[44] = 2097;
        *(_QWORD *)&v182[46] = i + 3;
        *(_WORD *)&v182[54] = 2082;
        *(_QWORD *)&v182[56] = v33;
        v37 = v31;
        v38 = "%{public}s: host %{public}s for %{private, mask.hash}s, address %{private, mask.hash, network:in_addr}.4P %{public}s";
        v39 = 78;
LABEL_48:
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v38, buf, v39);
      }
    }
    else if (v32)
    {
      v34 = *((unsigned __int8 *)i + 24);
      v35 = "ULA: ";
      if ((v34 & 0xFE) != 0xFC)
      {
        if (v34 != 254 || (v35 = "LUA: ", (*((_BYTE *)i + 25) & 0xC0) != 0x80))
        {
          v35 = "GUA: ";
          if ((v34 & 0xE0) != 0x20)
            v35 = (const char *)&unk_10007C3B5;
        }
      }
      if (v169)
        v36 = *(void **)(v169 + 16);
      else
        v36 = &unk_10007C3B5;
      *(_DWORD *)buf = 136449795;
      *(_QWORD *)&buf[4] = "srp_update_start";
      v181 = 2082;
      *(_QWORD *)v182 = v28;
      *(_WORD *)&v182[8] = 2160;
      *(_QWORD *)&v182[10] = 1752392040;
      *(_WORD *)&v182[18] = 2081;
      *(_QWORD *)&v182[20] = __s2;
      *(_WORD *)&v182[28] = 2082;
      *(_QWORD *)&v182[30] = v35;
      *(_WORD *)&v182[38] = 2160;
      *(_QWORD *)&v182[40] = 1752392040;
      *(_WORD *)&v182[48] = 1041;
      *(_DWORD *)&v182[50] = 6;
      *(_WORD *)&v182[54] = 2097;
      *(_QWORD *)&v182[56] = i + 3;
      *(_WORD *)&v182[64] = 2160;
      *(_QWORD *)&v182[66] = 1752392040;
      *(_WORD *)&v182[74] = 1042;
      *(_DWORD *)&v182[76] = 2;
      *(_WORD *)&v182[80] = 2098;
      *(_QWORD *)&v182[82] = (char *)i + 30;
      v183 = 2160;
      v184 = 1752392040;
      v185 = 1041;
      v186 = 8;
      v187 = 2097;
      v188 = i + 4;
      v189 = 2082;
      v190 = v36;
      v37 = v31;
      v38 = "%{public}s: host %{public}s for %{private, mask.hash}s, address {%{public}s%{private, mask.hash, srp:in6_add"
            "r_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} %{public}s";
      v39 = 140;
      goto LABEL_48;
    }
  }
  if (v166)
  {
    v40 = v166;
    do
    {
      extract_instance_name(__s1, 0xFDuLL, v191, (uint64_t)v40);
      v41 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v42 = v40[6];
        if (v42)
          v43 = *(unsigned __int16 *)(v42 + 28);
        else
          v43 = -1;
        if (v169)
          v44 = *(void **)(v169 + 16);
        else
          v44 = &unk_10007C3B5;
        *(_DWORD *)buf = 136448515;
        *(_QWORD *)&buf[4] = "srp_update_start";
        v181 = 2082;
        *(_QWORD *)v182 = v28;
        *(_WORD *)&v182[8] = 2160;
        *(_QWORD *)&v182[10] = 1752392040;
        *(_WORD *)&v182[18] = 2081;
        *(_QWORD *)&v182[20] = __s2;
        *(_WORD *)&v182[28] = 2160;
        *(_QWORD *)&v182[30] = 1752392040;
        *(_WORD *)&v182[38] = 2081;
        *(_QWORD *)&v182[40] = __s1;
        *(_WORD *)&v182[48] = 2160;
        *(_QWORD *)&v182[50] = 1752392040;
        *(_WORD *)&v182[58] = 2081;
        *(_QWORD *)&v182[60] = v191;
        *(_WORD *)&v182[68] = 1024;
        *(_DWORD *)&v182[70] = v43;
        *(_WORD *)&v182[74] = 2082;
        *(_QWORD *)&v182[76] = v44;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{public}s for %{private, mask.hash}s, instance name %{private, mask.hash}s, type %{private, mask.hash}s, port %d %{public}s", buf, 0x62u);
      }
      v45 = v40[7];
      if (v45)
      {
        dns_txt_data_print((unint64_t)buf, *(unsigned __int8 *)(v45 + 16), *(_QWORD *)(v45 + 24));
        v46 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v170 = 136447235;
          v171 = "srp_update_start";
          v172 = 2160;
          v173 = 1752392040;
          v174 = 2081;
          v175 = __s1;
          v176 = 2160;
          v177 = 1752392040;
          v178 = 2081;
          v179 = buf;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: text data for instance %{private, mask.hash}s: %{private, mask.hash}s", v170, 0x34u);
        }
      }
      v40 = (_QWORD *)*v40;
    }
    while (v40);
  }
  v47 = (uint64_t *)(v3 + 8);
  v48 = *(_QWORD *)(v3 + 8);
  if (!v48)
  {
    v167 = (uint64_t *)(v3 + 8);
    v168 = 0;
    goto LABEL_124;
  }
  v1 = v165;
  while (*(_BYTE *)(v48 + 264) || v166 == 0)
  {
LABEL_71:
    v48 = *(_QWORD *)(v48 + 40);
    if (!v48)
    {
      v168 = 0;
      goto LABEL_93;
    }
  }
  v50 = v166;
  while (1)
  {
    extract_instance_name(__s1, 0xFDuLL, v191, (uint64_t)v50);
    v51 = *(_QWORD *)(v48 + 112);
    if (*(int *)(v51 + 4) >= 1)
      break;
LABEL_77:
    v54 = *(_QWORD *)(v48 + 48);
    if (v54)
    {
      v55 = *(_QWORD *)(v54 + 80);
      if (v55)
      {
        if (*(int *)(v55 + 4) >= 1)
        {
          v56 = 0;
          do
          {
            v53 = compare_instance(*(_QWORD *)(*(_QWORD *)(v55 + 8) + 8 * v56), (uint64_t **)v163, v48, __s1, v191);
            if (v53)
              goto LABEL_85;
            ++v56;
            v55 = *(_QWORD *)(*(_QWORD *)(v48 + 48) + 80);
          }
          while (v56 < *(int *)(v55 + 4));
        }
      }
    }
    v50 = (_QWORD *)*v50;
    if (!v50)
      goto LABEL_71;
  }
  v52 = 0;
  while (1)
  {
    v53 = compare_instance(*(_QWORD *)(*(_QWORD *)(v51 + 8) + 8 * v52), (uint64_t **)v163, v48, __s1, v191);
    if (v53)
      break;
    ++v52;
    v51 = *(_QWORD *)(v48 + 112);
    if (v52 >= *(int *)(v51 + 4))
      goto LABEL_77;
  }
LABEL_85:
  if (v53 == 2)
  {
    v57 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v58 = *(_QWORD *)(v48 + 56);
      *(_DWORD *)buf = 136448259;
      *(_QWORD *)&buf[4] = "srp_update_start";
      v181 = 2160;
      *(_QWORD *)v182 = 1752392040;
      *(_WORD *)&v182[8] = 2081;
      *(_QWORD *)&v182[10] = __s1;
      *(_WORD *)&v182[18] = 2160;
      *(_QWORD *)&v182[20] = 1752392040;
      *(_WORD *)&v182[28] = 2081;
      *(_QWORD *)&v182[30] = v191;
      *(_WORD *)&v182[38] = 2160;
      *(_QWORD *)&v182[40] = 1752392040;
      *(_WORD *)&v182[48] = 2081;
      *(_QWORD *)&v182[50] = v58;
      *(_WORD *)&v182[58] = 2160;
      *(_QWORD *)&v182[60] = 1752392040;
      *(_WORD *)&v182[68] = 2081;
      *(_QWORD *)&v182[70] = __s2;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%{public}s: service instance name %{private, mask.hash}s/%{private, mask.hash}s already pointing to host %{private, mask.hash}s, not host %{private, mask.hash}s", buf, 0x5Cu);
    }
    v19 = *(char **)(v48 + 56);
    v20 = v161;
    v21 = v162;
    goto LABEL_144;
  }
  v168 = 1;
LABEL_93:
  v167 = v47;
  v60 = *v47;
  if (!*v47)
  {
LABEL_124:
    while (v27)
    {
      if (!*((_BYTE *)v27 + 24))
      {
        v79 = (uint64_t *)v27[1];
        if (v79)
          dns_name_print_to_limit(v79, 0, (uint64_t)buf, 0x3F2uLL);
        else
          strcpy(buf, "<null>");
        v80 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v170 = 136446723;
          v171 = "srp_update_start";
          v172 = 2160;
          v173 = 1752392040;
          v174 = 2081;
          v175 = buf;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s: remove for %{private, mask.hash}s doesn't match any instance on any host.", v170, 0x20u);
        }
      }
      v27 = (uint64_t *)*v27;
    }
    if (v168)
    {
      v81 = *(_DWORD *)(v48 + 184);
      v1 = v165;
      v82 = v162;
      if (v160 == v81 && dns_keys_rdata_equal(*(_QWORD *)(v163 + 16), v48 + 120))
      {
        v83 = v164;
LABEL_136:
        if (*(_QWORD *)(v48 + 48))
        {
          v84 = global_os_log;
          goto LABEL_138;
        }
        if (v159)
        {
          v113 = *(_QWORD *)(v48 + 56);
          v112 = *(_QWORD *)(v48 + 64);
          v84 = global_os_log;
          v114 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (v112 != v113)
          {
            if (!v114)
              goto LABEL_266;
            *(_DWORD *)buf = 136447491;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 2160;
            *(_QWORD *)v182 = 1752392040;
            *(_WORD *)&v182[8] = 2081;
            *(_QWORD *)&v182[10] = v113;
            *(_WORD *)&v182[18] = 2160;
            *(_QWORD *)&v182[20] = 1752392040;
            *(_WORD *)&v182[28] = 2081;
            *(_QWORD *)&v182[30] = v112;
            *(_WORD *)&v182[38] = 1024;
            *(_DWORD *)&v182[40] = v160;
            v115 = "%{public}s: Renewing host %{private, mask.hash}s, alias %{private, mask.hash}s, key id %x";
            v116 = v84;
            v117 = 58;
            goto LABEL_265;
          }
          if (!v114)
            goto LABEL_266;
          *(_DWORD *)buf = 136446979;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 2160;
          *(_QWORD *)v182 = 1752392040;
          *(_WORD *)&v182[8] = 2081;
          *(_QWORD *)&v182[10] = v112;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = v160;
          v115 = "%{public}s: Renewing host %{private, mask.hash}s, key id %x";
LABEL_264:
          v116 = v84;
          v117 = 38;
LABEL_265:
          _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, v115, buf, v117);
          goto LABEL_266;
        }
        host_invalidate(v48);
        v130 = *(int **)(v48 + 72);
        if (v130)
          ioloop_message_release_(v130, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4197);
        *(_QWORD *)(v48 + 72) = v82;
        *(_QWORD *)(v48 + 208) = *(_QWORD *)(v82 + 72);
        ioloop_message_retain_((int *)v82, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4202);
LABEL_235:
        v19 = __s2;
        v20 = v161;
        v21 = v82;
        v22 = 0;
        goto LABEL_145;
      }
      v86 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v87 = *(_QWORD *)(v48 + 56);
        *(_DWORD *)buf = 136447747;
        *(_QWORD *)&buf[4] = "srp_update_start";
        v181 = 2160;
        *(_QWORD *)v182 = 1752392040;
        *(_WORD *)&v182[8] = 2081;
        *(_QWORD *)&v182[10] = __s2;
        *(_WORD *)&v182[18] = 1024;
        *(_DWORD *)&v182[20] = v160;
        *(_WORD *)&v182[24] = 2160;
        *(_QWORD *)&v182[26] = 1752392040;
        *(_WORD *)&v182[34] = 2081;
        *(_QWORD *)&v182[36] = v87;
        *(_WORD *)&v182[44] = 1024;
        *(_DWORD *)&v182[46] = v81;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%{public}s: new host with name %{private, mask.hash}s and key id %x conflicts with existing host %{private, mask.hash}s with key id %x", buf, 0x40u);
      }
      v19 = *(char **)(v48 + 56);
LABEL_143:
      v20 = v161;
      v21 = v82;
LABEL_144:
      v22 = 6;
      goto LABEL_145;
    }
    v99 = v167;
    v48 = *v167;
    v1 = v165;
    v82 = v162;
    if (*v167)
    {
      v83 = v164;
      while (1)
      {
        v100 = *(const char **)(v48 + 56);
        v101 = strcasecmp(__s2, v100);
        if (!v101)
          break;
        if ((v101 & 0x80000000) == 0)
        {
          v99 = (uint64_t *)(v48 + 40);
          v48 = *(_QWORD *)(v48 + 40);
          if (v48)
            continue;
        }
        goto LABEL_178;
      }
      if (!*(_BYTE *)(v48 + 264))
      {
        v126 = *(_DWORD *)(v48 + 184);
        if (v160 == v126 && dns_keys_rdata_equal(*(_QWORD *)(v163 + 16), v48 + 120))
          goto LABEL_136;
        v127 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447235;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 2160;
          *(_QWORD *)v182 = 1752392040;
          *(_WORD *)&v182[8] = 2081;
          *(_QWORD *)&v182[10] = v100;
          *(_WORD *)&v182[18] = 1024;
          *(_DWORD *)&v182[20] = v160;
          *(_WORD *)&v182[24] = 1024;
          *(_DWORD *)&v182[26] = v126;
          _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, "%{public}s: update for host %{private, mask.hash}s has key id %x which doesn't match host key id %x.", buf, 0x2Cu);
          v100 = *(const char **)(v48 + 56);
        }
        v19 = (char *)v100;
        goto LABEL_143;
      }
      if (v159)
      {
        if (*(_QWORD *)(v48 + 208) > *(_QWORD *)(v165[4] + 72))
        {
          v110 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446723;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 2160;
            *(_QWORD *)v182 = 1752392040;
            *(_WORD *)&v182[8] = 2081;
            *(_QWORD *)&v182[10] = v100;
            _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: update for host %{private, mask.hash}s which has been deleted.", buf, 0x20u);
            v100 = *(const char **)(v48 + 56);
          }
          v19 = (char *)v100;
          goto LABEL_302;
        }
        *v99 = *(_QWORD *)(v48 + 40);
        host_invalidate(v48);
        v140 = *(_DWORD *)v48;
        if (!*(_DWORD *)v48)
        {
          v107 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_336;
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 1024;
          *(_DWORD *)v182 = 0;
          *(_WORD *)&v182[4] = 2048;
          *(_QWORD *)&v182[6] = v48;
          *(_WORD *)&v182[14] = 2080;
          *(_QWORD *)&v182[16] = "host";
          *(_WORD *)&v182[24] = 2080;
          *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v182[34] = 1024;
          *(_DWORD *)&v182[36] = 4008;
          v108 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_334;
        }
        v141 = global_os_log;
        if (v140 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_336;
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 1024;
          *(_DWORD *)v182 = v140;
          *(_WORD *)&v182[4] = 2048;
          *(_QWORD *)&v182[6] = v48;
          *(_WORD *)&v182[14] = 2080;
          *(_QWORD *)&v182[16] = "host";
          *(_WORD *)&v182[24] = 2080;
          *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v182[34] = 1024;
          *(_DWORD *)&v182[36] = 4008;
          v108 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v158 = v141;
          goto LABEL_335;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 1024;
          *(_DWORD *)v182 = v140;
          *(_WORD *)&v182[4] = 2048;
          *(_QWORD *)&v182[6] = v48;
          *(_WORD *)&v182[14] = 2080;
          *(_QWORD *)&v182[16] = "host";
          *(_WORD *)&v182[24] = 2080;
          *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v182[34] = 1024;
          *(_DWORD *)&v182[36] = 4008;
          _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v140 = *(_DWORD *)v48;
        }
        *(_DWORD *)v48 = v140 - 1;
        if (v140 == 1)
        {
          v142 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 2048;
            *(_QWORD *)v182 = v48;
            *(_WORD *)&v182[8] = 2080;
            *(_QWORD *)&v182[10] = "host";
            *(_WORD *)&v182[18] = 2080;
            *(_QWORD *)&v182[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[28] = 1024;
            *(_DWORD *)&v182[30] = 4008;
            _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_host_finalized;
          adv_host_finalize(v48);
        }
LABEL_179:
        v102 = malloc_type_calloc(1uLL, 0x110uLL, 0x10320409BBB0413uLL);
        v103 = global_os_log;
        if (!v102)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "srp_update_start";
            _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_ERROR, "%{public}s: no memory for host data structure.", buf, 0xCu);
          }
          v19 = __s2;
          v20 = v161;
          v21 = v162;
          goto LABEL_303;
        }
        v48 = (uint64_t)v102;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v104 = *(_DWORD *)v48;
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 1024;
          *(_DWORD *)v182 = v104;
          *(_WORD *)&v182[4] = 2048;
          *(_QWORD *)&v182[6] = v48;
          *(_WORD *)&v182[14] = 2080;
          *(_QWORD *)&v182[16] = "host";
          *(_WORD *)&v182[24] = 2080;
          *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v182[34] = 1024;
          *(_DWORD *)&v182[36] = 4066;
          _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        v105 = *(_DWORD *)v48;
        if (*(_DWORD *)v48)
        {
          v106 = v105 + 1;
          *(_DWORD *)v48 = v105 + 1;
          if (v105 + 1 >= 10001)
          {
            v107 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_336;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = v106;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4066;
            v108 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_334:
            v158 = v107;
            goto LABEL_335;
          }
        }
        else
        {
          ++adv_host_created;
          *(_DWORD *)v48 = 1;
        }
        *(_QWORD *)(v48 + 8) = v83;
        v118 = adv_instance_vec_create(0);
        *(_QWORD *)(v48 + 112) = v118;
        if (v118)
        {
          v119 = adv_record_vec_create(0);
          *(_QWORD *)(v48 + 96) = v119;
          if (v119)
          {
            v120 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4087);
            *(_QWORD *)(v48 + 24) = v120;
            if (v120)
            {
              v121 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4089);
              *(_QWORD *)(v48 + 32) = v121;
            }
            else
            {
              v121 = *(int **)(v48 + 32);
            }
            if (v121)
            {
              dns_name_print_to_limit(*(uint64_t **)v163, 0, (uint64_t)v193, 0x3F2uLL);
              v131 = strdup(v193);
              *(_QWORD *)(v48 + 56) = v131;
              if (v131)
              {
                v132 = *(_OWORD **)(v163 + 16);
                v133 = v132[2];
                v134 = v132[3];
                v135 = v132[1];
                *(_OWORD *)(v48 + 120) = *v132;
                *(_OWORD *)(v48 + 168) = v134;
                *(_OWORD *)(v48 + 152) = v133;
                *(_OWORD *)(v48 + 136) = v135;
                *(_QWORD *)(v48 + 120) = 0;
                LOWORD(v132) = *(_WORD *)(*(_QWORD *)(v163 + 16) + 20) + 4;
                *(_WORD *)(v48 + 232) = (_WORD)v132;
                v136 = malloc_type_malloc((unsigned __int16)v132, 0x101BAE9BuLL);
                *(_QWORD *)(v48 + 240) = v136;
                if (v136)
                {
                  *v136 = *(_WORD *)(*(_QWORD *)(v163 + 16) + 16);
                  *(_BYTE *)(*(_QWORD *)(v48 + 240) + 2) = *(_BYTE *)(*(_QWORD *)(v163 + 16) + 18);
                  *(_BYTE *)(*(_QWORD *)(v48 + 240) + 3) = *(_BYTE *)(*(_QWORD *)(v163 + 16) + 19);
                  memcpy((void *)(*(_QWORD *)(v48 + 240) + 4), *(const void **)(*(_QWORD *)(v163 + 16) + 24), *(unsigned int *)(*(_QWORD *)(v163 + 16) + 20));
                  *(_QWORD *)(v48 + 144) = *(_QWORD *)(v48 + 240) + 4;
                  *(_DWORD *)(v48 + 184) = v160;
                  *(_QWORD *)(v48 + 40) = *v99;
                  *v99 = v48;
                  v84 = global_os_log;
                  if (*(_QWORD *)(v48 + 48))
                  {
LABEL_138:
                    if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
                    {
                      v85 = *(_QWORD *)(v48 + 56);
                      *(_DWORD *)buf = 136446723;
                      *(_QWORD *)&buf[4] = "srp_update_start";
                      v181 = 2160;
                      *(_QWORD *)v182 = 1752392040;
                      *(_WORD *)&v182[8] = 2081;
                      *(_QWORD *)&v182[10] = v85;
                      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: dropping retransmission of in-progress update for host %{private, mask.hash}s", buf, 0x20u);
                    }
                    goto LABEL_147;
                  }
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_266:
                    if (!*(_QWORD *)(v48 + 64))
                      *(_QWORD *)(v48 + 64) = *(_QWORD *)(v48 + 56);
                    v143 = *(_DWORD *)(v82 + 80);
                    if (v143)
                    {
                      v144 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        v145 = *(_DWORD *)(v82 + 84);
                        *(_DWORD *)buf = 136446722;
                        *(_QWORD *)&buf[4] = "srp_update_start";
                        v181 = 1024;
                        *(_DWORD *)v182 = v143;
                        *(_WORD *)&v182[4] = 1024;
                        *(_DWORD *)&v182[6] = v145;
                        _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "%{public}s: basing lease time on message: raw_message->lease = %d, raw_message->key_lease = %d", buf, 0x18u);
                        v143 = *(_DWORD *)(v82 + 80);
                      }
                      *((_DWORD *)v1 + 22) = v143;
                      *((_DWORD *)v1 + 23) = *(_DWORD *)(v82 + 84);
LABEL_310:
                      prepare_update((_QWORD *)v48, v1);
                      return 1;
                    }
                    v146 = *((_DWORD *)v1 + 22);
                    v147 = v83[63];
                    if (v146 >= v147)
                    {
                      *((_DWORD *)v1 + 22) = v147;
                      v149 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446466;
                        *(_QWORD *)&buf[4] = "srp_update_start";
                        v181 = 1024;
                        *(_DWORD *)v182 = v147;
                        v154 = "%{public}s: basing lease time on server_state->max_lease_time: %d";
LABEL_306:
                        _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, v154, buf, 0x12u);
                      }
                    }
                    else
                    {
                      v148 = v83[64];
                      v149 = global_os_log;
                      v150 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
                      if (v146 < v148)
                      {
                        if (v150)
                        {
                          *(_DWORD *)buf = 136446466;
                          *(_QWORD *)&buf[4] = "srp_update_start";
                          v181 = 1024;
                          *(_DWORD *)v182 = v148;
                          _os_log_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEFAULT, "%{public}s: basing lease time on server_state->min_lease_time: %d", buf, 0x12u);
                          v148 = v83[64];
                        }
                        *((_DWORD *)v1 + 22) = v148;
                        goto LABEL_307;
                      }
                      if (v150)
                      {
                        *(_DWORD *)buf = 136446466;
                        *(_QWORD *)&buf[4] = "srp_update_start";
                        v181 = 1024;
                        *(_DWORD *)v182 = v146;
                        v154 = "%{public}s: basing lease time on client_update->host_lease: %d";
                        goto LABEL_306;
                      }
                    }
LABEL_307:
                    v156 = *((_DWORD *)v1 + 23);
                    v157 = v83[65];
                    if (v156 >= v157 || (v157 = v83[66], v156 < v157))
                      *((_DWORD *)v1 + 23) = v157;
                    goto LABEL_310;
                  }
                  v137 = *(_QWORD *)(v48 + 56);
                  *(_DWORD *)buf = 136446979;
                  *(_QWORD *)&buf[4] = "srp_update_start";
                  v181 = 2160;
                  *(_QWORD *)v182 = 1752392040;
                  *(_WORD *)&v182[8] = 2081;
                  *(_QWORD *)&v182[10] = v137;
                  *(_WORD *)&v182[18] = 1024;
                  *(_DWORD *)&v182[20] = v160;
                  v115 = "%{public}s: New host %{private, mask.hash}s, key id %x";
                  goto LABEL_264;
                }
                v155 = *(_DWORD *)v48;
                if (!*(_DWORD *)v48)
                {
                  v107 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    goto LABEL_336;
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "srp_update_start";
                  v181 = 1024;
                  *(_DWORD *)v182 = 0;
                  *(_WORD *)&v182[4] = 2048;
                  *(_QWORD *)&v182[6] = v48;
                  *(_WORD *)&v182[14] = 2080;
                  *(_QWORD *)&v182[16] = "host";
                  *(_WORD *)&v182[24] = 2080;
                  *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
                  *(_WORD *)&v182[34] = 1024;
                  *(_DWORD *)&v182[36] = 4117;
                  v108 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_334;
                }
                v152 = global_os_log;
                if (v155 < 10001)
                {
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136447490;
                    *(_QWORD *)&buf[4] = "srp_update_start";
                    v181 = 1024;
                    *(_DWORD *)v182 = v155;
                    *(_WORD *)&v182[4] = 2048;
                    *(_QWORD *)&v182[6] = v48;
                    *(_WORD *)&v182[14] = 2080;
                    *(_QWORD *)&v182[16] = "host";
                    *(_WORD *)&v182[24] = 2080;
                    *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
                    *(_WORD *)&v182[34] = 1024;
                    *(_DWORD *)&v182[36] = 4117;
                    _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                    v155 = *(_DWORD *)v48;
                    v152 = global_os_log;
                  }
                  *(_DWORD *)v48 = v155 - 1;
                  if (v155 == 1)
                  {
                    if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "srp_update_start";
                      v181 = 2048;
                      *(_QWORD *)v182 = v48;
                      *(_WORD *)&v182[8] = 2080;
                      *(_QWORD *)&v182[10] = "host";
                      *(_WORD *)&v182[18] = 2080;
                      *(_QWORD *)&v182[20] = "srp-mdns-proxy.c";
                      *(_WORD *)&v182[28] = 1024;
                      *(_DWORD *)&v182[30] = 4117;
                      _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                    }
                    ++adv_host_finalized;
                    adv_host_finalize(v48);
                    v152 = global_os_log;
                  }
                  if (!os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
                    goto LABEL_301;
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "srp_update_start";
                  v153 = "%{public}s: no memory for host key.";
LABEL_300:
                  _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_ERROR, v153, buf, 0xCu);
LABEL_301:
                  v19 = __s2;
LABEL_302:
                  v20 = v161;
                  v21 = v162;
LABEL_303:
                  v22 = 2;
                  goto LABEL_145;
                }
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_336:
                  abort();
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "srp_update_start";
                v181 = 1024;
                *(_DWORD *)v182 = v155;
                *(_WORD *)&v182[4] = 2048;
                *(_QWORD *)&v182[6] = v48;
                *(_WORD *)&v182[14] = 2080;
                *(_QWORD *)&v182[16] = "host";
                *(_WORD *)&v182[24] = 2080;
                *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
                *(_WORD *)&v182[34] = 1024;
                *(_DWORD *)&v182[36] = 4117;
                v108 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              }
              else
              {
                v151 = *(_DWORD *)v48;
                if (!*(_DWORD *)v48)
                {
                  v107 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    goto LABEL_336;
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "srp_update_start";
                  v181 = 1024;
                  *(_DWORD *)v182 = 0;
                  *(_WORD *)&v182[4] = 2048;
                  *(_QWORD *)&v182[6] = v48;
                  *(_WORD *)&v182[14] = 2080;
                  *(_QWORD *)&v182[16] = "host";
                  *(_WORD *)&v182[24] = 2080;
                  *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
                  *(_WORD *)&v182[34] = 1024;
                  *(_DWORD *)&v182[36] = 4102;
                  v108 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_334;
                }
                v152 = global_os_log;
                if (v151 < 10001)
                {
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136447490;
                    *(_QWORD *)&buf[4] = "srp_update_start";
                    v181 = 1024;
                    *(_DWORD *)v182 = v151;
                    *(_WORD *)&v182[4] = 2048;
                    *(_QWORD *)&v182[6] = v48;
                    *(_WORD *)&v182[14] = 2080;
                    *(_QWORD *)&v182[16] = "host";
                    *(_WORD *)&v182[24] = 2080;
                    *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
                    *(_WORD *)&v182[34] = 1024;
                    *(_DWORD *)&v182[36] = 4102;
                    _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                    v151 = *(_DWORD *)v48;
                    v152 = global_os_log;
                  }
                  *(_DWORD *)v48 = v151 - 1;
                  if (v151 == 1)
                  {
                    if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136447234;
                      *(_QWORD *)&buf[4] = "srp_update_start";
                      v181 = 2048;
                      *(_QWORD *)v182 = v48;
                      *(_WORD *)&v182[8] = 2080;
                      *(_QWORD *)&v182[10] = "host";
                      *(_WORD *)&v182[18] = 2080;
                      *(_QWORD *)&v182[20] = "srp-mdns-proxy.c";
                      *(_WORD *)&v182[28] = 1024;
                      *(_DWORD *)&v182[30] = 4102;
                      _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                    }
                    ++adv_host_finalized;
                    adv_host_finalize(v48);
                    v152 = global_os_log;
                  }
                  if (!os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
                    goto LABEL_301;
                  *(_DWORD *)buf = 136446210;
                  *(_QWORD *)&buf[4] = "srp_update_start";
                  v153 = "%{public}s: no memory for hostname.";
                  goto LABEL_300;
                }
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  goto LABEL_336;
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "srp_update_start";
                v181 = 1024;
                *(_DWORD *)v182 = v151;
                *(_WORD *)&v182[4] = 2048;
                *(_QWORD *)&v182[6] = v48;
                *(_WORD *)&v182[14] = 2080;
                *(_QWORD *)&v182[16] = "host";
                *(_WORD *)&v182[24] = 2080;
                *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
                *(_WORD *)&v182[34] = 1024;
                *(_DWORD *)&v182[36] = 4102;
                v108 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              }
              v158 = v152;
              goto LABEL_335;
            }
            v138 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              *(_QWORD *)&buf[4] = "srp_update_start";
              _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_ERROR, "%{public}s: no memory for wake event on host", buf, 0xCu);
            }
            advertise_finished((uint64_t)__s2, v161, v162, 2u, 0, 1);
            v139 = *(_DWORD *)v48;
            if (!*(_DWORD *)v48)
            {
              v107 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_336;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "srp_update_start";
              v181 = 1024;
              *(_DWORD *)v182 = 0;
              *(_WORD *)&v182[4] = 2048;
              *(_QWORD *)&v182[6] = v48;
              *(_WORD *)&v182[14] = 2080;
              *(_QWORD *)&v182[16] = "host";
              *(_WORD *)&v182[24] = 2080;
              *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
              *(_WORD *)&v182[34] = 1024;
              *(_DWORD *)&v182[36] = 4095;
              v108 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_334;
            }
            v124 = global_os_log;
            if (v139 < 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "srp_update_start";
                v181 = 1024;
                *(_DWORD *)v182 = v139;
                *(_WORD *)&v182[4] = 2048;
                *(_QWORD *)&v182[6] = v48;
                *(_WORD *)&v182[14] = 2080;
                *(_QWORD *)&v182[16] = "host";
                *(_WORD *)&v182[24] = 2080;
                *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
                *(_WORD *)&v182[34] = 1024;
                *(_DWORD *)&v182[36] = 4095;
                _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                v139 = *(_DWORD *)v48;
              }
              *(_DWORD *)v48 = v139 - 1;
              if (v139 != 1)
                goto LABEL_147;
              v125 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                *(_QWORD *)&buf[4] = "srp_update_start";
                v181 = 2048;
                *(_QWORD *)v182 = v48;
                *(_WORD *)&v182[8] = 2080;
                *(_QWORD *)&v182[10] = "host";
                *(_WORD *)&v182[18] = 2080;
                *(_QWORD *)&v182[20] = "srp-mdns-proxy.c";
                *(_WORD *)&v182[28] = 1024;
                *(_DWORD *)&v182[30] = 4095;
                goto LABEL_252;
              }
LABEL_253:
              ++adv_host_finalized;
              adv_host_finalize(v48);
              goto LABEL_147;
            }
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_336;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = v139;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4095;
            v108 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_323:
            v158 = v124;
LABEL_335:
            _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_FAULT, v108, buf, 0x36u);
            goto LABEL_336;
          }
          v128 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "srp_update_start";
            _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_ERROR, "%{public}s: no memory for host address vector.", buf, 0xCu);
          }
          advertise_finished((uint64_t)__s2, v161, v162, 2u, 0, 1);
          v129 = *(_DWORD *)v48;
          if (!*(_DWORD *)v48)
          {
            v107 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_336;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = 0;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4082;
            v108 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_334;
          }
          v124 = global_os_log;
          if (v129 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_336;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = v129;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4082;
            v108 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            goto LABEL_323;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = v129;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4082;
            _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v129 = *(_DWORD *)v48;
          }
          *(_DWORD *)v48 = v129 - 1;
          if (v129 != 1)
            goto LABEL_147;
          v125 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            goto LABEL_253;
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 2048;
          *(_QWORD *)v182 = v48;
          *(_WORD *)&v182[8] = 2080;
          *(_QWORD *)&v182[10] = "host";
          *(_WORD *)&v182[18] = 2080;
          *(_QWORD *)&v182[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v182[28] = 1024;
          *(_DWORD *)&v182[30] = 4082;
        }
        else
        {
          v122 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "srp_update_start";
            _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "%{public}s: no memory for host instance vector.", buf, 0xCu);
          }
          advertise_finished((uint64_t)__s2, v161, v162, 2u, 0, 1);
          v123 = *(_DWORD *)v48;
          if (!*(_DWORD *)v48)
          {
            v107 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_336;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = 0;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4073;
            v108 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_334;
          }
          v124 = global_os_log;
          if (v123 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_336;
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = v123;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4073;
            v108 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            goto LABEL_323;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "srp_update_start";
            v181 = 1024;
            *(_DWORD *)v182 = v123;
            *(_WORD *)&v182[4] = 2048;
            *(_QWORD *)&v182[6] = v48;
            *(_WORD *)&v182[14] = 2080;
            *(_QWORD *)&v182[16] = "host";
            *(_WORD *)&v182[24] = 2080;
            *(_QWORD *)&v182[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v182[34] = 1024;
            *(_DWORD *)&v182[36] = 4073;
            _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v123 = *(_DWORD *)v48;
          }
          *(_DWORD *)v48 = v123 - 1;
          if (v123 != 1)
            goto LABEL_147;
          v125 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            goto LABEL_253;
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "srp_update_start";
          v181 = 2048;
          *(_QWORD *)v182 = v48;
          *(_WORD *)&v182[8] = 2080;
          *(_QWORD *)&v182[10] = "host";
          *(_WORD *)&v182[18] = 2080;
          *(_QWORD *)&v182[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v182[28] = 1024;
          *(_DWORD *)&v182[30] = 4073;
        }
LABEL_252:
        _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        goto LABEL_253;
      }
    }
    else
    {
      v83 = v164;
LABEL_178:
      if (v159)
        goto LABEL_179;
    }
    v111 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446723;
      *(_QWORD *)&buf[4] = "srp_update_start";
      v181 = 2160;
      *(_QWORD *)v182 = 1752392040;
      *(_WORD *)&v182[8] = 2081;
      *(_QWORD *)&v182[10] = __s2;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "%{public}s: Remove for host %{private, mask.hash}s which doesn't exist.", buf, 0x20u);
    }
    goto LABEL_235;
  }
  while (*(_BYTE *)(v60 + 264) || v27 == 0)
  {
LABEL_123:
    v60 = *(_QWORD *)(v60 + 40);
    if (!v60)
      goto LABEL_124;
  }
  v62 = v27;
  while (1)
  {
    v63 = (uint64_t *)v62[1];
    if (v63)
    {
      v64 = (uint64_t *)*v63;
      if (*v63)
      {
        if (*v64)
        {
          dns_name_print_to_limit(v63, v64, (uint64_t)__s1, 0xFDuLL);
          dns_name_print_to_limit(*(uint64_t **)v62[1], ***(uint64_t ****)v62[1], (uint64_t)v191, 0x1FAuLL);
          v65 = *(_QWORD *)(v60 + 112);
          if (*(int *)(v65 + 4) >= 1)
          {
            for (j = 0; j < *(int *)(v65 + 4); ++j)
            {
              v67 = *(_QWORD *)(*(_QWORD *)(v65 + 8) + 8 * j);
              if (v67 && !strcmp(__s1, *(const char **)(v67 + 48)) && service_types_equal(v191, *(char **)(v67 + 56)))
              {
                v68 = *(const char **)(v60 + 56);
                v69 = strcmp(__s2, v68);
                v70 = global_os_log;
                v71 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
                if (v69)
                {
                  if (v71)
                  {
                    *(_DWORD *)buf = 136447747;
                    *(_QWORD *)&buf[4] = "srp_update_start";
                    v181 = 2160;
                    *(_QWORD *)v182 = 1752392040;
                    *(_WORD *)&v182[8] = 2081;
                    *(_QWORD *)&v182[10] = __s1;
                    *(_WORD *)&v182[18] = 2160;
                    *(_QWORD *)&v182[20] = 1752392040;
                    *(_WORD *)&v182[28] = 2081;
                    *(_QWORD *)&v182[30] = v191;
                    *(_WORD *)&v182[38] = 2160;
                    *(_QWORD *)&v182[40] = 1752392040;
                    *(_WORD *)&v182[48] = 2081;
                    *(_QWORD *)&v182[50] = v68;
                    _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "%{public}s: remove for %{private, mask.hash}s.%{private, mask.hash}s conflicts with instance on host %{private, mask.hash}s", buf, 0x48u);
                    v68 = *(const char **)(v60 + 56);
                  }
                  v1 = v165;
                  v20 = v161;
                  v21 = v162;
                  v19 = (char *)v68;
                  v22 = 1;
LABEL_145:
                  v23 = 1;
LABEL_146:
                  advertise_finished((uint64_t)v19, v20, v21, v22, 0, v23);
                  goto LABEL_147;
                }
                if (v71)
                {
                  *(_DWORD *)buf = 136447747;
                  *(_QWORD *)&buf[4] = "srp_update_start";
                  v181 = 2160;
                  *(_QWORD *)v182 = 1752392040;
                  *(_WORD *)&v182[8] = 2081;
                  *(_QWORD *)&v182[10] = __s1;
                  *(_WORD *)&v182[18] = 2160;
                  *(_QWORD *)&v182[20] = 1752392040;
                  *(_WORD *)&v182[28] = 2081;
                  *(_QWORD *)&v182[30] = v191;
                  *(_WORD *)&v182[38] = 2160;
                  *(_QWORD *)&v182[40] = 1752392040;
                  *(_WORD *)&v182[48] = 2081;
                  *(_QWORD *)&v182[50] = v68;
                  _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_ERROR, "%{public}s: remove for %{private, mask.hash}s.%{private, mask.hash}s matches instance on host %{private, mask.hash}s", buf, 0x48u);
                  v65 = *(_QWORD *)(v60 + 112);
                }
                *((_BYTE *)v62 + 24) = 1;
              }
            }
          }
          v72 = *(_QWORD *)(v60 + 48);
          if (v72)
          {
            v73 = *(_QWORD *)(v72 + 80);
            if (v73)
            {
              v74 = *(unsigned int *)(v73 + 4);
              if ((int)v74 >= 1)
                break;
            }
          }
        }
      }
    }
LABEL_122:
    v62 = (uint64_t *)*v62;
    if (!v62)
      goto LABEL_123;
  }
  v75 = *(uint64_t **)(v73 + 8);
  while (1)
  {
    v76 = *v75;
    if (!*v75)
      goto LABEL_121;
    v77 = *(const char **)(v76 + 48);
    if (strcmp(__s1, v77) || !service_types_equal(v191, *(char **)(v76 + 56)))
      goto LABEL_121;
    v78 = *(const char **)(v60 + 56);
    if (strcmp(__s2, v78))
      break;
    *((_BYTE *)v62 + 24) = 1;
LABEL_121:
    ++v75;
    if (!--v74)
      goto LABEL_122;
  }
  v109 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136447235;
    *(_QWORD *)&buf[4] = "srp_update_start";
    v181 = 2160;
    *(_QWORD *)v182 = 1752392040;
    *(_WORD *)&v182[8] = 2081;
    *(_QWORD *)&v182[10] = v77;
    *(_WORD *)&v182[18] = 2160;
    *(_QWORD *)&v182[20] = 1752392040;
    *(_WORD *)&v182[28] = 2081;
    *(_QWORD *)&v182[30] = v78;
    _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_ERROR, "%{public}s: remove for %{private, mask.hash}s conflicts with instance on update to host %{private, mask.hash}s", buf, 0x34u);
    v78 = *(const char **)(v60 + 56);
  }
  advertise_finished((uint64_t)v78, v161, v162, 1u, 0, 1);
  v1 = v165;
LABEL_147:
  srp_parse_client_updates_free_(v1, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4175);
  return 0;
}

void srp_dump_server_stats(uint64_t a1, int a2, int a3)
{
  uint64_t v5;
  NSObject **v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  const char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  uint64_t v26;
  const char *v27;
  NSObject *v28;
  unsigned __int8 *v29;
  int v30;
  const char *v31;
  const char *v32;
  uint64_t v33;
  NSObject **v34;
  uint64_t v35;
  char v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  NSObject *v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  const char *v44;
  NSObject *v45;
  const char *v46;
  double v47;
  double v48;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  char v54;
  int v55;
  uint64_t v56;
  uint8_t buf[4];
  const char *v58;
  __int16 v59;
  const char *v60;
  __int16 v61;
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  uint64_t v66;
  __int16 v67;
  uint64_t v68;
  __int16 v69;
  int v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  _BYTE *v74;
  _BYTE v75[24];
  __int128 v76;
  uint64_t v77;
  _BYTE v78[12];
  double v79;
  void *v80;
  __int16 v81;
  const char *v82;

  *(_QWORD *)v75 = 0;
  *(_QWORD *)&v75[8] = 0;
  gettimeofday((timeval *)v75, 0);
  v56 = a1;
  v5 = *(_QWORD *)(a1 + 8);
  v6 = (NSObject **)&dnssd_client_states;
  if (v5)
  {
    v52 = 0;
    v50 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v55 = 0;
    v53 = 1000 * *(_QWORD *)v75 + *(_DWORD *)&v75[8] / 1000;
    while (1)
    {
      if (*(_BYTE *)(v5 + 264))
        goto LABEL_66;
      v10 = *(_QWORD *)(v5 + 256);
      v11 = v10 < v53;
      v12 = v10 - v53;
      if (v11)
      {
        v13 = -1;
        if (a2)
          goto LABEL_9;
      }
      else
      {
        v13 = v12 / 1000;
        if (a2)
        {
LABEL_9:
          v14 = v6[306];
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            v15 = *(_QWORD *)(v5 + 56);
            v16 = *(_DWORD *)(v5 + 184);
            v17 = *(_QWORD *)(v5 + 224);
            v18 = *(_DWORD *)(v5 + 248);
            v19 = *(_DWORD *)(v5 + 252);
            v20 = " update-pending";
            if (!*(_BYTE *)(v5 + 265))
              v20 = (const char *)&unk_10007C3B5;
            *(_DWORD *)v75 = 136448515;
            *(_QWORD *)&v75[4] = "srp_dump_server_stats";
            *(_WORD *)&v75[12] = 2160;
            *(_QWORD *)&v75[14] = 1752392040;
            *(_WORD *)&v75[22] = 2081;
            *(_QWORD *)&v76 = v15;
            WORD4(v76) = 1024;
            *(_DWORD *)((char *)&v76 + 10) = v16;
            HIWORD(v76) = 2048;
            v77 = v17;
            *(_WORD *)v78 = 1024;
            *(_DWORD *)&v78[2] = v18;
            *(_WORD *)&v78[6] = 1024;
            *(_DWORD *)&v78[8] = v19;
            LOWORD(v79) = 1024;
            *(_DWORD *)((char *)&v79 + 2) = v13;
            HIWORD(v79) = 2082;
            v80 = &unk_10007C3B5;
            v81 = 2082;
            v82 = v20;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s key_id %xu stable %llx lease %d key_lease %d expiry %d%{public}s%{public}s", v75, 0x56u);
          }
        }
      }
      v21 = *(_QWORD *)(v5 + 96);
      if (v21 && *(int *)(v21 + 4) >= 1)
      {
        v22 = 0;
        do
        {
          v23 = *(_QWORD *)(*(_QWORD *)(v21 + 8) + 8 * v22);
          if (v23)
          {
            v24 = *(unsigned __int16 *)(v23 + 48);
            if (v24 == 28)
            {
              if (a2)
              {
                v28 = v6[306];
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                {
                  v29 = *(unsigned __int8 **)(v23 + 40);
                  v30 = *v29;
                  v31 = "ULA: ";
                  if ((v30 & 0xFE) != 0xFC)
                  {
                    if (v30 != 254 || (v31 = "LUA: ", (v29[1] & 0xC0) != 0x80))
                    {
                      v31 = "GUA: ";
                      if ((v30 & 0xE0) != 0x20)
                        v31 = (const char *)&unk_10007C3B5;
                    }
                  }
                  *(double *)&v32 = COERCE_DOUBLE(&unk_10007C3B5);
                  if (*(_QWORD *)(v23 + 24) == *(_QWORD *)(v56 + 16))
                    *(double *)&v32 = COERCE_DOUBLE(" live");
                  *(_DWORD *)v75 = 136447747;
                  *(_QWORD *)&v75[4] = "srp_dump_server_stats";
                  *(_WORD *)&v75[12] = 2082;
                  *(_QWORD *)&v75[14] = v31;
                  *(_WORD *)&v75[22] = 2160;
                  *(_QWORD *)&v76 = 1752392040;
                  WORD4(v76) = 1041;
                  *(_DWORD *)((char *)&v76 + 10) = 16;
                  HIWORD(v76) = 2097;
                  v77 = (uint64_t)v29;
                  strcpy(v78, "p\bhash");
                  v78[7] = 0;
                  *(_DWORD *)&v78[8] = 136380416;
                  v79 = *(double *)&v32;
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s:   IN AAAA %{public}s%{private, mask.hash, network:in6_addr}.16P%{private, mask.hash}s", v75, 0x44u);
                }
              }
              ++v8;
            }
            else if (v24 == 1)
            {
              if (a2)
              {
                v25 = v6[306];
                if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                {
                  v26 = *(_QWORD *)(v23 + 40);
                  v27 = (const char *)&unk_10007C3B5;
                  if (*(_QWORD *)(v23 + 24) == *(_QWORD *)(v56 + 16))
                    v27 = " live";
                  *(_DWORD *)v75 = 136447491;
                  *(_QWORD *)&v75[4] = "srp_dump_server_stats";
                  *(_WORD *)&v75[12] = 2160;
                  *(_QWORD *)&v75[14] = 1752392040;
                  *(_WORD *)&v75[22] = 1041;
                  LODWORD(v76) = 4;
                  WORD2(v76) = 2097;
                  *(_QWORD *)((char *)&v76 + 6) = v26;
                  HIWORD(v76) = 2160;
                  v77 = 1752392040;
                  *(_WORD *)v78 = 2081;
                  *(_QWORD *)&v78[2] = v27;
                  _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s:   IN    A %{private, mask.hash, network:in_addr}.4P%{private, mask.hash}s", v75, 0x3Au);
                }
              }
              ++v9;
            }
          }
          ++v22;
          v21 = *(_QWORD *)(v5 + 96);
        }
        while (v22 < *(int *)(v21 + 4));
      }
      ++v55;
      v33 = *(_QWORD *)(v5 + 112);
      if (!v33)
        goto LABEL_66;
      if (*(int *)(v33 + 4) < 1)
      {
        v36 = 0;
      }
      else
      {
        v51 = v8;
        v34 = v6;
        v35 = 0;
        v36 = 0;
        v54 = 0;
        do
        {
          v37 = *(_QWORD *)(*(_QWORD *)(v33 + 8) + 8 * v35);
          if (v37)
          {
            if (a2)
            {
              v38 = *(_QWORD *)(v37 + 72);
              if (v38)
                dns_txt_data_print((unint64_t)v75, *(unsigned __int16 *)(v37 + 80), v38);
              else
                v75[0] = 0;
              v39 = "removed";
              if (!*(_BYTE *)(v37 + 116))
              {
                if (*(_QWORD *)(v37 + 8))
                {
                  if (*(_QWORD *)(v37 + 16) == *(_QWORD *)(v56 + 16))
                    v39 = "live";
                  else
                    v39 = "stale";
                }
                else
                {
                  v39 = "unregistered";
                }
              }
              v40 = v34[306];
              if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
              {
                v41 = *(_QWORD *)(v37 + 48);
                v42 = *(_QWORD *)(v37 + 56);
                v43 = *(_DWORD *)(v37 + 64);
                *(_DWORD *)buf = 136448259;
                v58 = "srp_dump_server_stats";
                v59 = 2082;
                v60 = v39;
                v61 = 2160;
                v62 = 1752392040;
                v63 = 2081;
                v64 = v41;
                v65 = 2160;
                v66 = 1752392040;
                v67 = 2081;
                v68 = v42;
                v69 = 1024;
                v70 = v43;
                v71 = 2160;
                v72 = 1752392040;
                v73 = 2081;
                v74 = v75;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s:   %{public}s instance %{private, mask.hash}s %{private, mask.hash}s %d (%{private, mask.hash}s)", buf, 0x58u);
              }
            }
            if (!*(_BYTE *)(v37 + 116))
            {
              ++v7;
              v44 = *(const char **)(v37 + 56);
              if (v44)
              {
                if (!strncmp(*(const char **)(v37 + 56), "_matter", 7uLL))
                {
                  v54 = 1;
                }
                else if (!strncmp(v44, "_hap._udp", 9uLL))
                {
                  v36 = 1;
                }
              }
            }
          }
          ++v35;
          v33 = *(_QWORD *)(v5 + 112);
        }
        while (v35 < *(int *)(v33 + 4));
        if ((v54 & 1) != 0)
        {
          ++v50;
          v6 = v34;
          v8 = v51;
          goto LABEL_66;
        }
        v6 = v34;
        v8 = v51;
      }
      v52 += v36 & 1;
LABEL_66:
      v5 = *(_QWORD *)(v5 + 40);
      if (!v5)
        goto LABEL_69;
    }
  }
  v55 = 0;
  v9 = 0;
  v8 = 0;
  v7 = 0;
  v50 = 0;
  v52 = 0;
LABEL_69:
  v45 = v6[306];
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    if (a3)
      v46 = (const char *)&unk_10007C3B5;
    else
      v46 = "after update, ";
    *(_QWORD *)v75 = 0;
    *(_QWORD *)&v75[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v75);
    v47 = (double)*(uint64_t *)v75;
    v48 = (double)*(uint64_t *)&v75[8];
    *(_DWORD *)v75 = 136448258;
    *(_QWORD *)&v75[4] = "srp_dump_server_stats";
    *(_WORD *)&v75[12] = 2082;
    *(_QWORD *)&v75[14] = v46;
    *(_WORD *)&v75[22] = 1024;
    LODWORD(v76) = v55;
    WORD2(v76) = 1024;
    *(_DWORD *)((char *)&v76 + 6) = v50;
    WORD5(v76) = 1024;
    HIDWORD(v76) = v52;
    LOWORD(v77) = 1024;
    *(_DWORD *)((char *)&v77 + 2) = v7;
    HIWORD(v77) = 1024;
    *(_DWORD *)v78 = v9;
    *(_WORD *)&v78[4] = 1024;
    *(_DWORD *)&v78[6] = v8;
    *(_WORD *)&v78[10] = 2048;
    v79 = v48 / 1000000000.0 + v47;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s%d hosts (%d matter, %d hap), %d instances, %d a records, %d aaaa records at %.6lf", v75, 0x44u);
    v45 = v6[306];
  }
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v75 = 136447234;
    *(_QWORD *)&v75[4] = "srp_dump_server_stats";
    *(_WORD *)&v75[12] = 1024;
    *(_DWORD *)&v75[14] = num_push_sessions - srp_dump_server_stats_last_num_push_sessions;
    *(_WORD *)&v75[18] = 1024;
    *(_DWORD *)&v75[20] = dp_num_outstanding_queries - srp_dump_server_stats_last_dp_num_outstanding_queries;
    LOWORD(v76) = 1024;
    *(_DWORD *)((char *)&v76 + 2) = num_push_sessions_dropped_for_load
                                  - srp_dump_server_stats_last_num_push_sessions_dropped_for_load;
    WORD3(v76) = 1024;
    DWORD2(v76) = num_queries_dropped_for_load - srp_dump_server_stats_last_num_queries_dropped_for_load;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: %d push sessions and %d queries added, %d push sessions and %d queries dropped for load", v75, 0x24u);
  }
  srp_dump_server_stats_last_num_push_sessions = num_push_sessions;
  srp_dump_server_stats_last_dp_num_outstanding_queries = dp_num_outstanding_queries;
  srp_dump_server_stats_last_num_push_sessions_dropped_for_load = num_push_sessions_dropped_for_load;
  srp_dump_server_stats_last_num_queries_dropped_for_load = num_queries_dropped_for_load;
}

BOOL extract_instance_name(_BYTE *a1, unint64_t a2, const char *a3, uint64_t a4)
{
  uint64_t *v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t ***v11;
  uint64_t **v12;
  uint64_t *v13;
  size_t v14;
  uint64_t v15;
  size_t v16;
  uint64_t *v17;
  _BOOL8 result;
  NSObject *v19;
  int v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  const char *v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;

  v8 = **(uint64_t ***)(*(_QWORD *)(a4 + 32) + 16);
  v9 = (uint64_t **)*v8;
  if (*v8)
  {
    if (*v9)
      v10 = *v9;
    else
      v10 = (uint64_t *)*v8;
  }
  else
  {
    v10 = 0;
  }
  dns_name_print_to_limit(v8, v10, (uint64_t)a3, 0x1FAuLL);
  v11 = *(uint64_t ****)(a4 + 32);
  v12 = *v11;
  if (*v11)
  {
    v13 = (uint64_t *)v11[1];
    v14 = strlen(a3);
    while (v12[1] == v13)
    {
      v15 = *v12[2];
      if (v14 + *(unsigned __int8 *)(v15 + 8) - 505 <= 0xFFFFFFFFFFFFFE04)
      {
        v19 = global_os_log;
        result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if (result)
        {
          v20 = 136447235;
          v21 = "extract_instance_name";
          v22 = 2160;
          v23 = 1752392040;
          v24 = 2081;
          v25 = a3;
          v26 = 2160;
          v27 = 1752392040;
          v28 = 2081;
          v29 = v15 + 9;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%{public}s: service name: %{private, mask.hash}s is too long for additional subtype %{private, mask.hash}s", (uint8_t *)&v20, 0x34u);
          return 0;
        }
        return result;
      }
      v16 = v14 + 1;
      a3[v14] = 44;
      memcpy((void *)&a3[v14 + 1], (const void *)(*v12[2] + 9), *(unsigned __int8 *)(*v12[2] + 8) + 1);
      v14 = v16 + *(unsigned __int8 *)(*v12[2] + 8);
      v12 = (uint64_t **)*v12;
      if (!v12)
        break;
    }
  }
  v17 = *(uint64_t **)(a4 + 16);
  if (v17)
    dns_name_print_to_limit(v17, (uint64_t *)*v17, (uint64_t)a1, a2);
  else
    *a1 = 0;
  return 1;
}

uint64_t compare_instance(uint64_t result, uint64_t **a2, uint64_t a3, char *__s1, char *a5)
{
  uint64_t v8;

  if (result)
  {
    if (!*(_BYTE *)(a3 + 264) && (v8 = result, !strcmp(__s1, *(const char **)(result + 48))))
    {
      result = service_types_equal(a5, *(char **)(v8 + 56));
      if ((_DWORD)result)
      {
        if (dns_names_equal_text(*a2, *(char **)(a3 + 56)))
          return 1;
        else
          return 2;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL service_types_equal(char *a1, char *a2)
{
  char *v4;
  size_t v5;
  char *v6;
  size_t v7;

  v4 = strchr(a1, 44);
  if (v4)
    v5 = v4 - a1;
  else
    v5 = strlen(a1);
  v6 = strchr(a2, 44);
  if (v6)
    v7 = v6 - a2;
  else
    v7 = strlen(a2);
  return v5 == v7 && memcmp(a2, a1, v5) == 0;
}

void prepare_update(_QWORD *a1, _QWORD *a2)
{
  int *v4;
  void *v5;
  NSObject *v6;
  int v7;
  int v8;
  int v9;
  NSObject *v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  unsigned int v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t **v23;
  int v24;
  uint64_t *v25;
  uint64_t v26;
  char v27;
  uint64_t v28;
  int v29;
  size_t v30;
  int v31;
  int v32;
  unsigned int v33;
  _DWORD *v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  int *v39;
  NSObject *v40;
  int v41;
  int *v42;
  int v43;
  int v44;
  NSObject *v45;
  const char *v46;
  NSObject *v47;
  int *v48;
  int *v49;
  uint64_t v50;
  uint64_t i;
  uint64_t v52;
  uint64_t v53;
  int *v54;
  NSObject *v55;
  int v56;
  int v57;
  int v58;
  uint64_t j;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  size_t v64;
  int v65;
  NSObject *v66;
  NSObject *v67;
  uint64_t v68;
  int *v69;
  int v70;
  NSObject *v71;
  unsigned int v72;
  int *v73;
  _QWORD *v74;
  _QWORD *v75;
  uint64_t **k;
  uint64_t *v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int *v84;
  NSObject *v85;
  int v86;
  int v87;
  int v88;
  _DWORD *v89;
  NSObject *v90;
  int *v91;
  int v92;
  int v93;
  int v94;
  uint64_t *v95;
  uint64_t v96;
  _QWORD *v97;
  _QWORD *v98;
  _QWORD *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int *v103;
  NSObject *v104;
  int *v105;
  int v106;
  int v107;
  int v108;
  int *v109;
  NSObject *v110;
  int v111;
  int v112;
  int v113;
  int *v114;
  int v115;
  int v116;
  int v117;
  uint64_t v118;
  char *v119;
  char *v120;
  uint64_t v121;
  void *v122;
  void *v123;
  uint64_t v124;
  unsigned int v125;
  NSObject *v126;
  int v127;
  const char *v128;
  BOOL v129;
  NSObject *v130;
  NSObject *v131;
  int v132;
  NSObject *v133;
  int v134;
  NSObject *v135;
  NSObject *v136;
  int v137;
  int v138;
  NSObject *v139;
  NSObject *v140;
  int v141;
  int v142;
  NSObject *v143;
  NSObject *v144;
  NSObject *v145;
  NSObject *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  int *v153;
  char *v154;
  char *v155;
  size_t v156;
  int *v157;
  NSObject *v158;
  int v159;
  int v160;
  int v161;
  uint64_t v162;
  int *v163;
  int v164;
  NSObject *v165;
  int v166;
  uint64_t v167;
  void *v168;
  NSObject *v169;
  NSObject *v170;
  int v171;
  int v172;
  int v173;
  uint64_t v174;
  int *v175;
  int v176;
  int v177;
  int v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  _QWORD *v182;
  NSObject *v183;
  int *v184;
  int v185;
  int v186;
  int v187;
  uint64_t v188;
  uint64_t v189;
  _QWORD *v190;
  NSObject *v191;
  int *v192;
  int v193;
  int v194;
  int v195;
  int v196;
  NSObject *v197;
  const char *v198;
  NSObject *v199;
  int v200;
  NSObject *v201;
  NSObject *v202;
  int v203;
  NSObject *v204;
  int v205;
  NSObject *v206;
  int v207;
  int v208;
  uint64_t m;
  uint64_t v210;
  _QWORD *v211;
  NSObject *v213;
  int v214;
  const char *v215;
  int v216;
  const char *v217;
  _QWORD *v218;
  uint64_t v219;
  NSObject *v220;
  int v221;
  int v222;
  int v223;
  NSObject *v224;
  uint8_t *v225;
  NSObject *v226;
  NSObject *v230;
  _QWORD *v236;
  int *v237;
  uint64_t v238;
  uint64_t v239;
  int v240;
  _QWORD *v241;
  int *v242;
  _QWORD *v243;
  uint64_t v244;
  int v245;
  uint64_t v246;
  _QWORD *v247;
  uint8_t v248[4];
  const char *v249;
  __int16 v250;
  _BYTE v251[34];
  __int16 v252;
  int v253;
  _BYTE buf[84];
  __int16 v255;
  _BYTE v256[20];
  int v257;
  __int16 v258;
  _QWORD *v259;
  __int16 v260;
  const char *v261;
  __int16 v262;
  uint64_t v263;
  __int16 v264;
  int v265;
  __int16 v266;
  uint64_t v267;
  __int16 v268;
  uint64_t v269;
  __int16 v270;
  int v271;
  __int16 v272;
  uint64_t v273;
  __int16 v274;
  uint64_t v275;
  __int16 v276;
  int v277;
  __int16 v278;
  uint64_t v279;
  char __s1[506];

  v4 = (int *)malloc_type_calloc(1uLL, 0x88uLL, 0x1020040C5CF03A7uLL);
  v5 = &dnssd_client_states;
  v6 = global_os_log;
  v244 = (uint64_t)v4;
  if (!v4)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_11;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "prepare_update";
    v12 = "%{public}s: no memory for update.";
    goto LABEL_10;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = *v4;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v7;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v4;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3260;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v243 = a2;
  v8 = *v4;
  if (*v4)
  {
    v9 = v8 + 1;
    *v4 = v8 + 1;
    if (v8 + 1 >= 10001)
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_483;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3260;
      v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_474;
    }
  }
  else
  {
    ++adv_update_created;
    *v4 = 1;
  }
  v13 = a1[2];
  a2 = v243;
  if (v13)
    ioloop_cancel_wake_event(v13);
  *((_BYTE *)a1 + 266) = 0;
  *(_QWORD *)buf = 0;
  *(_QWORD *)&buf[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
  *((_QWORD *)v4 + 15) = *(_QWORD *)buf;
  v14 = a1[12];
  if (!v14 || (v15 = *(_DWORD *)(v14 + 4)) == 0)
  {
    v18 = 0;
    v240 = 0;
    goto LABEL_21;
  }
  v16 = *(_DWORD *)(v14 + 4);
  v17 = adv_record_vec_create(v15);
  if (!v17)
  {
    v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
LABEL_11:
      srp_parse_client_updates_free_(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3648);
      if (v4)
        goto LABEL_245;
      return;
    }
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "prepare_update";
    v12 = "%{public}s: no memory for remove_addrs";
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
    goto LABEL_11;
  }
  v18 = (uint64_t)v17;
  v240 = v16;
  *((_DWORD *)v17 + 1) = v16;
LABEL_21:
  v19 = (_QWORD *)(v243[5] + 8);
  v20 = -1;
  do
  {
    v19 = (_QWORD *)*v19;
    ++v20;
  }
  while (v19);
  v21 = adv_record_vec_create(v20);
  v22 = (uint64_t)v21;
  if (!v21)
  {
    v45 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "prepare_update";
      v46 = "%{public}s: no memory for add_addrs";
LABEL_199:
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, v46, buf, 0xCu);
    }
LABEL_200:
    v48 = 0;
LABEL_201:
    v49 = 0;
    v50 = 0;
    goto LABEL_202;
  }
  v23 = *(uint64_t ***)(v243[5] + 8);
  v247 = a1;
  if (v23)
  {
    v24 = 0;
    do
    {
      if (v24 < 1)
        goto LABEL_37;
      v25 = *(uint64_t **)(v22 + 8);
      v26 = v24;
      v27 = 1;
      do
      {
        v28 = *v25;
        if (*v25)
        {
          v29 = *(unsigned __int16 *)(v28 + 48);
          if (v29 == *((unsigned __int16 *)v23 + 8))
          {
            v30 = *(unsigned __int16 *)(v28 + 50);
            v31 = v29 == 1 ? 4 : 16;
            if (v31 == (_DWORD)v30)
              v27 &= memcmp(*(const void **)(v28 + 40), v23 + 3, v30) != 0;
          }
        }
        ++v25;
        --v26;
      }
      while (v26);
      a1 = v247;
      if ((v27 & 1) != 0)
      {
LABEL_37:
        v32 = *((unsigned __int16 *)v23 + 8);
        if (v32 == 1)
          v33 = 4;
        else
          v33 = 16;
        v34 = adv_record_create_(v32, v33, v23 + 3, a1, 3311);
        if (!v34)
        {
          v5 = &dnssd_client_states;
          v47 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            *(_QWORD *)&buf[4] = "prepare_update";
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%{public}s: No memory for prepared address", buf, 0xCu);
          }
          v48 = 0;
          v49 = 0;
          v50 = 0;
          a2 = v243;
          goto LABEL_202;
        }
        *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8 * v24++) = v34;
      }
      v23 = (uint64_t **)*v23;
    }
    while (v23);
    *(_DWORD *)(v22 + 4) = v24;
    v242 = (int *)(v22 + 4);
    if (v24 < 1)
    {
      v245 = 0;
    }
    else
    {
      v35 = 0;
      v36 = *(_QWORD *)(v22 + 8);
      v37 = v24;
      do
      {
        v38 = *(_QWORD *)(v36 + 8 * v35);
        if (v38)
        {
          *(_QWORD *)(v38 + 32) = v4;
          v39 = *(int **)(*(_QWORD *)(v36 + 8 * v35) + 32);
          if (v39)
          {
            v40 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v41 = *v39;
              *(_DWORD *)buf = 136447490;
              *(_QWORD *)&buf[4] = "prepare_update";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v41;
              *(_WORD *)&buf[18] = 2048;
              *(_QWORD *)&buf[20] = v39;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = "add_addrs->vec[i]->update";
              *(_WORD *)&buf[38] = 2080;
              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[48] = 1024;
              *(_DWORD *)&buf[50] = 3323;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              v36 = *(_QWORD *)(v22 + 8);
            }
            v42 = *(int **)(*(_QWORD *)(v36 + 8 * v35) + 32);
            v43 = *v42;
            if (!*v42)
            {
              ++adv_update_created;
              v43 = *v42;
            }
            v44 = v43 + 1;
            *v42 = v43 + 1;
            if (v43 + 1 > 10000)
            {
              v230 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "prepare_update";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v44;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v42;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "add_addrs->vec[i]->update";
                *(_WORD *)&buf[38] = 2080;
                *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3323;
                v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_480;
              }
              goto LABEL_483;
            }
            v37 = *v242;
            v4 = (int *)v244;
          }
        }
        ++v35;
      }
      while (v35 < v37);
      v245 = 1;
      a1 = v247;
    }
  }
  else
  {
    v245 = 0;
    v24 = 0;
    *((_DWORD *)v21 + 1) = 0;
    v242 = (int *)v21 + 1;
  }
  if (v240)
  {
    if (v240 >= 1)
    {
      for (i = 0; i != v240; ++i)
      {
        v52 = a1[12];
        if (v52)
        {
          v53 = *(_QWORD *)(*(_QWORD *)(v52 + 8) + 8 * i);
          if (v53)
          {
            *(_QWORD *)(*(_QWORD *)(v18 + 8) + 8 * i) = v53;
            v54 = *(int **)(*(_QWORD *)(v18 + 8) + 8 * i);
            if (v54)
            {
              v55 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                v56 = *v54;
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "prepare_update";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v56;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v54;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "remove_addrs->vec[i]";
                *(_WORD *)&buf[38] = 2080;
                *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3353;
                _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                v54 = *(int **)(*(_QWORD *)(v18 + 8) + 8 * i);
              }
              v57 = *v54;
              if (!*v54)
              {
                ++adv_record_created;
                v57 = *v54;
              }
              v58 = v57 + 1;
              *v54 = v57 + 1;
              if (v57 + 1 >= 10001)
              {
                v230 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "prepare_update";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v58;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v54;
                  *(_WORD *)&buf[28] = 2080;
                  *(_QWORD *)&buf[30] = "remove_addrs->vec[i]";
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3353;
                  v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_480;
                }
                goto LABEL_483;
              }
            }
          }
        }
        if (v245)
        {
          for (j = 0; v24 != j; ++j)
          {
            v60 = *(_QWORD *)(v18 + 8);
            v61 = *(_QWORD *)(v60 + 8 * i);
            if (v61)
            {
              v62 = *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8 * j);
              if (v62)
              {
                if (*(_QWORD *)(v61 + 8))
                {
                  v63 = a1[1];
                  if (v63)
                  {
                    if (*(_QWORD *)(v61 + 24) == *(_QWORD *)(v63 + 16)
                      && *(unsigned __int16 *)(v62 + 48) == *(unsigned __int16 *)(v61 + 48))
                    {
                      v64 = *(unsigned __int16 *)(v62 + 50);
                      if ((_DWORD)v64 == *(unsigned __int16 *)(v61 + 50)
                        && !memcmp(*(const void **)(v62 + 40), *(const void **)(v61 + 40), v64))
                      {
                        v65 = *(_DWORD *)v61;
                        if (!*(_DWORD *)v61)
                        {
                          v230 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 136447490;
                            *(_QWORD *)&buf[4] = "prepare_update";
                            *(_WORD *)&buf[12] = 1024;
                            *(_DWORD *)&buf[14] = 0;
                            *(_WORD *)&buf[18] = 2048;
                            *(_QWORD *)&buf[20] = v61;
                            *(_WORD *)&buf[28] = 2080;
                            *(_QWORD *)&buf[30] = "remove_addrs->vec[i]";
                            *(_WORD *)&buf[38] = 2080;
                            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                            *(_WORD *)&buf[48] = 1024;
                            *(_DWORD *)&buf[50] = 3366;
                            v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                            goto LABEL_480;
                          }
                          goto LABEL_483;
                        }
                        v66 = global_os_log;
                        if (v65 >= 10001)
                        {
                          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                            goto LABEL_483;
                          *(_DWORD *)buf = 136447490;
                          *(_QWORD *)&buf[4] = "prepare_update";
                          *(_WORD *)&buf[12] = 1024;
                          *(_DWORD *)&buf[14] = v65;
                          *(_WORD *)&buf[18] = 2048;
                          *(_QWORD *)&buf[20] = v61;
                          *(_WORD *)&buf[28] = 2080;
                          *(_QWORD *)&buf[30] = "remove_addrs->vec[i]";
                          *(_WORD *)&buf[38] = 2080;
                          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                          *(_WORD *)&buf[48] = 1024;
                          *(_DWORD *)&buf[50] = 3366;
                          v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_477:
                          v225 = buf;
                          v226 = v66;
                          goto LABEL_482;
                        }
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 136447490;
                          *(_QWORD *)&buf[4] = "prepare_update";
                          *(_WORD *)&buf[12] = 1024;
                          *(_DWORD *)&buf[14] = v65;
                          *(_WORD *)&buf[18] = 2048;
                          *(_QWORD *)&buf[20] = v61;
                          *(_WORD *)&buf[28] = 2080;
                          *(_QWORD *)&buf[30] = "remove_addrs->vec[i]";
                          *(_WORD *)&buf[38] = 2080;
                          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                          *(_WORD *)&buf[48] = 1024;
                          *(_DWORD *)&buf[50] = 3366;
                          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                          v60 = *(_QWORD *)(v18 + 8);
                          v61 = *(_QWORD *)(v60 + 8 * i);
                          v65 = *(_DWORD *)v61;
                        }
                        a1 = v247;
                        *(_DWORD *)v61 = v65 - 1;
                        if (v65 == 1)
                        {
                          v67 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136447234;
                            *(_QWORD *)&buf[4] = "prepare_update";
                            *(_WORD *)&buf[12] = 2048;
                            *(_QWORD *)&buf[14] = v61;
                            *(_WORD *)&buf[22] = 2080;
                            *(_QWORD *)&buf[24] = "remove_addrs->vec[i]";
                            *(_WORD *)&buf[32] = 2080;
                            *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
                            *(_WORD *)&buf[42] = 1024;
                            *(_DWORD *)&buf[44] = 3366;
                            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                            v61 = *(_QWORD *)(*(_QWORD *)(v18 + 8) + 8 * i);
                          }
                          ++adv_record_finalized;
                          adv_record_finalize(v61);
                          v60 = *(_QWORD *)(v18 + 8);
                          a1 = v247;
                        }
                        *(_QWORD *)(v60 + 8 * i) = 0;
                        v68 = *(_QWORD *)(v22 + 8);
                        v69 = *(int **)(v68 + 8 * j);
                        if (v69)
                        {
                          v70 = *v69;
                          if (!*v69)
                          {
                            v230 = global_os_log;
                            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)buf = 136447490;
                              *(_QWORD *)&buf[4] = "prepare_update";
                              *(_WORD *)&buf[12] = 1024;
                              *(_DWORD *)&buf[14] = 0;
                              *(_WORD *)&buf[18] = 2048;
                              *(_QWORD *)&buf[20] = v69;
                              *(_WORD *)&buf[28] = 2080;
                              *(_QWORD *)&buf[30] = "add_addrs->vec[j]";
                              *(_WORD *)&buf[38] = 2080;
                              *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                              *(_WORD *)&buf[48] = 1024;
                              *(_DWORD *)&buf[50] = 3368;
                              v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                              goto LABEL_480;
                            }
                            goto LABEL_483;
                          }
                          v66 = global_os_log;
                          if (v70 >= 10001)
                          {
                            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                              goto LABEL_483;
                            *(_DWORD *)buf = 136447490;
                            *(_QWORD *)&buf[4] = "prepare_update";
                            *(_WORD *)&buf[12] = 1024;
                            *(_DWORD *)&buf[14] = v70;
                            *(_WORD *)&buf[18] = 2048;
                            *(_QWORD *)&buf[20] = v69;
                            *(_WORD *)&buf[28] = 2080;
                            *(_QWORD *)&buf[30] = "add_addrs->vec[j]";
                            *(_WORD *)&buf[38] = 2080;
                            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                            *(_WORD *)&buf[48] = 1024;
                            *(_DWORD *)&buf[50] = 3368;
                            v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                            goto LABEL_477;
                          }
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136447490;
                            *(_QWORD *)&buf[4] = "prepare_update";
                            *(_WORD *)&buf[12] = 1024;
                            *(_DWORD *)&buf[14] = v70;
                            *(_WORD *)&buf[18] = 2048;
                            *(_QWORD *)&buf[20] = v69;
                            *(_WORD *)&buf[28] = 2080;
                            *(_QWORD *)&buf[30] = "add_addrs->vec[j]";
                            *(_WORD *)&buf[38] = 2080;
                            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                            *(_WORD *)&buf[48] = 1024;
                            *(_DWORD *)&buf[50] = 3368;
                            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                            v68 = *(_QWORD *)(v22 + 8);
                            v69 = *(int **)(v68 + 8 * j);
                            v70 = *v69;
                          }
                          a1 = v247;
                          *v69 = v70 - 1;
                          if (v70 == 1)
                          {
                            v71 = global_os_log;
                            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                            {
                              *(_DWORD *)buf = 136447234;
                              *(_QWORD *)&buf[4] = "prepare_update";
                              *(_WORD *)&buf[12] = 2048;
                              *(_QWORD *)&buf[14] = v69;
                              *(_WORD *)&buf[22] = 2080;
                              *(_QWORD *)&buf[24] = "add_addrs->vec[j]";
                              *(_WORD *)&buf[32] = 2080;
                              *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
                              *(_WORD *)&buf[42] = 1024;
                              *(_DWORD *)&buf[44] = 3368;
                              _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                              v69 = *(int **)(*(_QWORD *)(v22 + 8) + 8 * j);
                            }
                            ++adv_record_finalized;
                            adv_record_finalize((uint64_t)v69);
                            v68 = *(_QWORD *)(v22 + 8);
                            a1 = v247;
                          }
                        }
                        *(_QWORD *)(v68 + 8 * j) = 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    *(_DWORD *)(v18 + 4) = v240;
    v4 = (int *)v244;
  }
  a2 = v243;
  if (!a1[13])
  {
    v89 = adv_record_create_(25, *((unsigned __int16 *)a1 + 116), (const void *)a1[30], a1, 3398);
    *((_QWORD *)v4 + 6) = v89;
    if (!v89)
    {
      v5 = &dnssd_client_states;
      v45 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "prepare_update";
        v46 = "%{public}s: no memory for key record";
        goto LABEL_199;
      }
      goto LABEL_200;
    }
    *((_QWORD *)v89 + 4) = v4;
    v90 = global_os_log;
    v91 = v4;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v92 = *v4;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v92;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update->key->update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3404;
      _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v91 = *(int **)(*((_QWORD *)v4 + 6) + 32);
    }
    v93 = *v91;
    if (*v91)
    {
      v94 = v93 + 1;
      *v91 = v93 + 1;
      if (v93 + 1 >= 10001)
      {
        v230 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "prepare_update";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v94;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v91;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "update->key->update";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3404;
          v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_480;
        }
        goto LABEL_483;
      }
    }
    else
    {
      ++adv_update_created;
      *v91 = 1;
    }
  }
  v72 = *(_DWORD *)(a1[14] + 4);
  v73 = (int *)adv_instance_vec_create(v72);
  if (!v73)
  {
    v5 = &dnssd_client_states;
    v45 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "prepare_update";
      v46 = "%{public}s: no memory for update_instances";
      goto LABEL_199;
    }
    goto LABEL_200;
  }
  v48 = v73;
  v73[1] = v72;
  v74 = adv_instance_vec_create(v72);
  v5 = &dnssd_client_states;
  if (!v74)
  {
    v131 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "prepare_update";
      _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_ERROR, "%{public}s: no memory for remove_instances", buf, 0xCu);
    }
    goto LABEL_201;
  }
  v50 = (uint64_t)v74;
  *((_DWORD *)v74 + 1) = v72;
  v75 = adv_instance_vec_create(v72);
  if (!v75)
  {
    v145 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "prepare_update";
      _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_ERROR, "%{public}s: no memory for renew_instances", buf, 0xCu);
    }
    v49 = 0;
    goto LABEL_202;
  }
  v237 = v48;
  v238 = v50;
  v236 = v75;
  *((_DWORD *)v75 + 1) = v72;
  for (k = (uint64_t **)v243[8]; k; k = (uint64_t **)*k)
  {
    v77 = k[1];
    if (v77)
    {
      v78 = (uint64_t *)*v77;
      if (*v77)
      {
        if (*v78)
        {
          dns_name_print_to_limit(v77, v78, (uint64_t)__s1, 0xFDuLL);
          dns_name_print_to_limit((uint64_t *)*k[1], **(uint64_t ***)*k[1], (uint64_t)buf, 0xFEuLL);
          v79 = v247[14];
          v80 = *(unsigned int *)(v79 + 4);
          if ((int)v80 >= 1)
          {
            v81 = 0;
            v82 = *(_QWORD *)(v79 + 8);
            while (1)
            {
              v83 = *(_QWORD *)(v82 + 8 * v81);
              if (v83)
              {
                if (!strcmp(__s1, *(const char **)(v83 + 48)) && service_types_equal(buf, *(char **)(v83 + 56)))
                  break;
              }
              if (v80 == ++v81)
                goto LABEL_120;
            }
            *(_QWORD *)(*(_QWORD *)(v50 + 8) + 8 * v81) = v83;
            v84 = *(int **)(*(_QWORD *)(v50 + 8) + 8 * v81);
            if (v84)
            {
              v85 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                v86 = *v84;
                *(_DWORD *)v248 = 136447490;
                v249 = "prepare_update";
                v250 = 1024;
                *(_DWORD *)v251 = v86;
                *(_WORD *)&v251[4] = 2048;
                *(_QWORD *)&v251[6] = v84;
                *(_WORD *)&v251[14] = 2080;
                *(_QWORD *)&v251[16] = "remove_instances->vec[i]";
                *(_WORD *)&v251[24] = 2080;
                *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
                v252 = 1024;
                v253 = 3455;
                _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
                v84 = *(int **)(*(_QWORD *)(v50 + 8) + 8 * v81);
              }
              v87 = *v84;
              if (*v84)
              {
                v88 = v87 + 1;
                *v84 = v87 + 1;
                if (v87 + 1 >= 10001)
                {
                  v230 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    goto LABEL_483;
                  *(_DWORD *)v248 = 136447490;
                  v249 = "prepare_update";
                  v250 = 1024;
                  *(_DWORD *)v251 = v88;
                  *(_WORD *)&v251[4] = 2048;
                  *(_QWORD *)&v251[6] = v84;
                  *(_WORD *)&v251[14] = 2080;
                  *(_QWORD *)&v251[16] = "remove_instances->vec[i]";
                  *(_WORD *)&v251[24] = 2080;
                  *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
                  v252 = 1024;
                  v253 = 3455;
                  v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_488;
                }
              }
              else
              {
                ++adv_instance_created;
                *v84 = 1;
              }
            }
          }
LABEL_120:
          v4 = (int *)v244;
          v5 = &dnssd_client_states;
        }
      }
    }
  }
  v95 = v243 + 6;
  LODWORD(v96) = -1;
  v97 = v243 + 6;
  do
  {
    v97 = (_QWORD *)*v97;
    v96 = (v96 + 1);
  }
  while (v97);
  v98 = adv_instance_vec_create(v96);
  if (!v98)
  {
    v146 = *((_QWORD *)v5 + 306);
    v50 = v238;
    if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "prepare_update";
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_ERROR, "%{public}s: prepare_update: no memory for add_instances", buf, 0xCu);
    }
    v49 = 0;
    a2 = v243;
    goto LABEL_202;
  }
  v99 = v98;
  v100 = *v95;
  v241 = v98;
  if (!*v95)
  {
    LODWORD(v101) = 0;
LABEL_266:
    *((_DWORD *)v99 + 1) = v101;
    if ((int)v96 >= 1)
    {
      v147 = 0;
      do
      {
        v246 = v147;
        v239 = v99[1];
        v148 = *(_QWORD *)(v239 + 8 * v147);
        if (v148)
        {
          v149 = v247[14];
          v150 = *(unsigned int *)(v149 + 4);
          if ((int)v150 >= 1)
          {
            v151 = 0;
            v152 = *(_QWORD *)(v149 + 8);
            while (1)
            {
              v153 = *(int **)(v152 + 8 * v151);
              if (v153)
              {
                if (!strcmp(*(const char **)(v148 + 48), *((const char **)v153 + 6)))
                {
                  v154 = *(char **)(v148 + 56);
                  v155 = (char *)*((_QWORD *)v153 + 7);
                  if (service_types_equal(v154, v155))
                    break;
                }
              }
              if (v150 == ++v151)
                goto LABEL_275;
            }
            if (!*((_BYTE *)v153 + 116)
              && (v156 = *(unsigned __int16 *)(v148 + 80), (_DWORD)v156 == *((unsigned __int16 *)v153 + 40))
              && *(_DWORD *)(v148 + 64) == v153[16]
              && !strcmp(v154, v155)
              && (!(_DWORD)v156 || !memcmp(*(const void **)(v148 + 72), *((const void **)v153 + 9), v156)))
            {
              v166 = *(_DWORD *)v148;
              if (!*(_DWORD *)v148)
              {
                v230 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  goto LABEL_483;
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "prepare_update";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = 0;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v148;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "add_instances->vec[i]";
                *(_WORD *)&buf[38] = 2080;
                *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3531;
                v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_480:
                v225 = buf;
                goto LABEL_481;
              }
              v110 = global_os_log;
              if (v166 >= 10001)
              {
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  goto LABEL_483;
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "prepare_update";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v166;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v148;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "add_instances->vec[i]";
                *(_WORD *)&buf[38] = 2080;
                *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3531;
                v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_499:
                v225 = buf;
                goto LABEL_500;
              }
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "prepare_update";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v166;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v148;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "add_instances->vec[i]";
                *(_WORD *)&buf[38] = 2080;
                *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3531;
                _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                v167 = v241[1];
                v148 = *(_QWORD *)(v167 + 8 * v246);
                v166 = *(_DWORD *)v148;
                v168 = &dnssd_client_states;
              }
              else
              {
                v168 = &dnssd_client_states;
                v167 = v239;
              }
              *(_DWORD *)v148 = v166 - 1;
              if (v166 == 1)
              {
                v169 = *((_QWORD *)v168 + 306);
                if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136447234;
                  *(_QWORD *)&buf[4] = "prepare_update";
                  *(_WORD *)&buf[12] = 2048;
                  *(_QWORD *)&buf[14] = v148;
                  *(_WORD *)&buf[22] = 2080;
                  *(_QWORD *)&buf[24] = "add_instances->vec[i]";
                  *(_WORD *)&buf[32] = 2080;
                  *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[42] = 1024;
                  *(_DWORD *)&buf[44] = 3531;
                  _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                  v148 = *(_QWORD *)(v241[1] + 8 * v246);
                }
                ++adv_instance_finalized;
                adv_instance_finalize((void *)v148);
                v167 = v241[1];
                v168 = &dnssd_client_states;
              }
              *(_QWORD *)(v167 + 8 * v246) = 0;
              *(_QWORD *)(v236[1] + 8 * v151) = v153;
              v170 = *((_QWORD *)v168 + 306);
              if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
              {
                v171 = *v153;
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "prepare_update";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v171;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v153;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "host_instance";
                *(_WORD *)&buf[38] = 2080;
                *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3534;
                _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              }
              v172 = *v153;
              if (*v153)
              {
                v173 = v172 + 1;
                *v153 = v172 + 1;
                if (v172 + 1 >= 10001)
                {
                  v10 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    goto LABEL_483;
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "prepare_update";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v173;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v153;
                  *(_WORD *)&buf[28] = 2080;
                  *(_QWORD *)&buf[30] = "host_instance";
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3534;
                  v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_474;
                }
              }
              else
              {
                ++adv_instance_created;
                *v153 = 1;
              }
              v174 = v236[1];
              *(_QWORD *)(*(_QWORD *)(v174 + 8 * v151) + 32) = v244;
              v175 = *(int **)(*(_QWORD *)(v174 + 8 * v151) + 32);
              v133 = global_os_log;
              if (v175)
              {
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  v176 = *v175;
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "prepare_update";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v176;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v175;
                  *(_WORD *)&buf[28] = 2080;
                  *(_QWORD *)&buf[30] = "renew_instances->vec[j]->update";
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3536;
                  _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  v175 = *(int **)(*(_QWORD *)(v236[1] + 8 * v151) + 32);
                }
                v177 = *v175;
                if (*v175)
                {
                  v178 = v177 + 1;
                  *v175 = v177 + 1;
                  v133 = global_os_log;
                  if (v177 + 1 >= 10001)
                  {
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      goto LABEL_483;
                    *(_DWORD *)buf = 136447490;
                    *(_QWORD *)&buf[4] = "prepare_update";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v178;
                    *(_WORD *)&buf[18] = 2048;
                    *(_QWORD *)&buf[20] = v175;
                    *(_WORD *)&buf[28] = 2080;
                    *(_QWORD *)&buf[30] = "renew_instances->vec[j]->update";
                    *(_WORD *)&buf[38] = 2080;
                    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                    *(_WORD *)&buf[48] = 1024;
                    *(_DWORD *)&buf[50] = 3536;
                    v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_460:
                    v225 = buf;
LABEL_461:
                    v226 = v133;
LABEL_482:
                    _os_log_impl((void *)&_mh_execute_header, v226, OS_LOG_TYPE_FAULT, v11, v225, 0x36u);
                    goto LABEL_483;
                  }
                }
                else
                {
                  ++adv_update_created;
                  *v175 = 1;
                  v133 = global_os_log;
                }
              }
              if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
              {
                v179 = *((_QWORD *)v153 + 6);
                v180 = *((_QWORD *)v153 + 7);
                v181 = v247[7];
                *(_DWORD *)buf = 136447747;
                *(_QWORD *)&buf[4] = "prepare_update";
                *(_WORD *)&buf[12] = 2160;
                *(_QWORD *)&buf[14] = 1752392040;
                *(_WORD *)&buf[22] = 2081;
                *(_QWORD *)&buf[24] = v179;
                *(_WORD *)&buf[32] = 2160;
                *(_QWORD *)&buf[34] = 1752392040;
                *(_WORD *)&buf[42] = 2081;
                *(_QWORD *)&buf[44] = v180;
                *(_WORD *)&buf[52] = 2160;
                *(_QWORD *)&buf[54] = 1752392040;
                *(_WORD *)&buf[62] = 2081;
                *(_QWORD *)&buf[64] = v181;
                _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s.%{private, mask.hash}s renewed for host %{private, mask.hash}s", buf, 0x48u);
              }
            }
            else
            {
              *(_QWORD *)(*((_QWORD *)v237 + 1) + 8 * v151) = v148;
              v157 = *(int **)(*((_QWORD *)v237 + 1) + 8 * v151);
              if (v157)
              {
                v158 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  v159 = *v157;
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "prepare_update";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v159;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v157;
                  *(_WORD *)&buf[28] = 2080;
                  *(_QWORD *)&buf[30] = "update_instances->vec[j]";
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3541;
                  _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  v157 = *(int **)(*((_QWORD *)v237 + 1) + 8 * v151);
                }
                v160 = *v157;
                if (*v157)
                {
                  v161 = v160 + 1;
                  *v157 = v160 + 1;
                  if (v160 + 1 >= 10001)
                  {
                    v230 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136447490;
                      *(_QWORD *)&buf[4] = "prepare_update";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v161;
                      *(_WORD *)&buf[18] = 2048;
                      *(_QWORD *)&buf[20] = v157;
                      *(_WORD *)&buf[28] = 2080;
                      *(_QWORD *)&buf[30] = "update_instances->vec[j]";
                      *(_WORD *)&buf[38] = 2080;
                      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                      *(_WORD *)&buf[48] = 1024;
                      *(_DWORD *)&buf[50] = 3541;
                      v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                      goto LABEL_480;
                    }
                    goto LABEL_483;
                  }
                }
                else
                {
                  ++adv_instance_created;
                  *v157 = 1;
                }
              }
              v162 = v241[1];
              v163 = *(int **)(v162 + 8 * v246);
              if (v163)
              {
                v164 = *v163;
                if (!*v163)
                {
                  v230 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 136447490;
                    *(_QWORD *)&buf[4] = "prepare_update";
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 0;
                    *(_WORD *)&buf[18] = 2048;
                    *(_QWORD *)&buf[20] = v163;
                    *(_WORD *)&buf[28] = 2080;
                    *(_QWORD *)&buf[30] = "add_instances->vec[i]";
                    *(_WORD *)&buf[38] = 2080;
                    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                    *(_WORD *)&buf[48] = 1024;
                    *(_DWORD *)&buf[50] = 3542;
                    v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                    goto LABEL_480;
                  }
                  goto LABEL_483;
                }
                v110 = global_os_log;
                if (v164 >= 10001)
                {
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    goto LABEL_483;
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "prepare_update";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v164;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v163;
                  *(_WORD *)&buf[28] = 2080;
                  *(_QWORD *)&buf[30] = "add_instances->vec[i]";
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3542;
                  v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_499;
                }
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "prepare_update";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v164;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v163;
                  *(_WORD *)&buf[28] = 2080;
                  *(_QWORD *)&buf[30] = "add_instances->vec[i]";
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3542;
                  _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  v162 = v241[1];
                  v163 = *(int **)(v162 + 8 * v246);
                  v164 = *v163;
                }
                *v163 = v164 - 1;
                if (v164 == 1)
                {
                  v165 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136447234;
                    *(_QWORD *)&buf[4] = "prepare_update";
                    *(_WORD *)&buf[12] = 2048;
                    *(_QWORD *)&buf[14] = v163;
                    *(_WORD *)&buf[22] = 2080;
                    *(_QWORD *)&buf[24] = "add_instances->vec[i]";
                    *(_WORD *)&buf[32] = 2080;
                    *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
                    *(_WORD *)&buf[42] = 1024;
                    *(_DWORD *)&buf[44] = 3542;
                    _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                    v163 = *(int **)(v241[1] + 8 * v246);
                  }
                  ++adv_instance_finalized;
                  adv_instance_finalize(v163);
                  v162 = v241[1];
                }
              }
              *(_QWORD *)(v162 + 8 * v246) = 0;
            }
          }
        }
LABEL_275:
        v147 = v246 + 1;
        v99 = v241;
      }
      while (v246 + 1 != v96);
    }
    v182 = v247;
    *(_QWORD *)(v244 + 8) = v247;
    if (v247)
    {
      v183 = global_os_log;
      v184 = (int *)v247;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v185 = *(_DWORD *)v247;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "prepare_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v185;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v247;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->host";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3574;
        _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v184 = *(int **)(v244 + 8);
      }
      v186 = *v184;
      if (*v184)
      {
        v187 = v186 + 1;
        *v184 = v186 + 1;
        if (v186 + 1 >= 10001)
        {
          v230 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "prepare_update";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v187;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = v184;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "update->host";
            *(_WORD *)&buf[38] = 2080;
            *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[48] = 1024;
            *(_DWORD *)&buf[50] = 3574;
            v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_480;
          }
          goto LABEL_483;
        }
      }
      else
      {
        ++adv_host_created;
        *v184 = 1;
      }
    }
    *(_QWORD *)(v244 + 16) = v243;
    *(_QWORD *)(v244 + 32) = v18;
    *(_QWORD *)(v244 + 40) = v22;
    *(_QWORD *)(v244 + 56) = v237;
    *(_QWORD *)(v244 + 64) = v238;
    *(_QWORD *)(v244 + 72) = v236;
    *(_QWORD *)(v244 + 80) = v99;
    *(_QWORD *)(v244 + 104) = v243[11];
    v188 = v243[4];
    if (v188)
    {
      v189 = *(_QWORD *)(v247[1] + 48);
      if (v189)
      {
        if (*(_BYTE *)(v189 + 258))
        {
          v190 = (_QWORD *)(v188 + 12);
          if (*(_QWORD *)(v189 + 176) == *(_QWORD *)(v188 + 12) && v247[12] && *v242 >= 1)
          {
            for (m = 0; m < *v242; ++m)
            {
              v210 = *(_QWORD *)(*(_QWORD *)(v22 + 8) + 8 * m);
              if (v210 && *(_WORD *)(v210 + 50) == 16)
              {
                v211 = *(_QWORD **)(v210 + 40);
                if (*v190 != *v211 || *(_QWORD *)(v188 + 20) != v211[1])
                {
                  v213 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    v214 = *(unsigned __int8 *)v211;
                    v215 = "ULA: ";
                    if ((v214 & 0xFE) != 0xFC)
                    {
                      if (v214 != 254 || (v215 = "LUA: ", (*((_BYTE *)v211 + 1) & 0xC0) != 0x80))
                      {
                        v215 = (const char *)&unk_10007C3B5;
                        if ((v214 & 0xE0) == 0x20)
                          v215 = "GUA: ";
                      }
                    }
                    v216 = *(unsigned __int8 *)v190;
                    v217 = "ULA: ";
                    if ((v216 & 0xFE) != 0xFC)
                    {
                      if (v216 != 254 || (v217 = "LUA: ", (*(_BYTE *)(v188 + 13) & 0xC0) != 0x80))
                      {
                        v217 = (const char *)&unk_10007C3B5;
                        if ((v216 & 0xE0) == 0x20)
                          v217 = "GUA: ";
                      }
                    }
                    v218 = v247;
                    v219 = v247[7];
                    *(_DWORD *)buf = 136451843;
                    *(_QWORD *)&buf[4] = "prepare_update";
                    *(_WORD *)&buf[12] = 2160;
                    *(_QWORD *)&buf[14] = 1752392040;
                    *(_WORD *)&buf[22] = 2081;
                    *(_QWORD *)&buf[24] = v219;
                    *(_WORD *)&buf[32] = 2082;
                    *(_QWORD *)&buf[34] = v215;
                    *(_WORD *)&buf[42] = 2160;
                    *(_QWORD *)&buf[44] = 1752392040;
                    *(_WORD *)&buf[52] = 1041;
                    *(_DWORD *)&buf[54] = 6;
                    *(_WORD *)&buf[58] = 2097;
                    *(_QWORD *)&buf[60] = v211;
                    *(_WORD *)&buf[68] = 2160;
                    *(_QWORD *)&buf[70] = 1752392040;
                    *(_WORD *)&buf[78] = 1042;
                    *(_DWORD *)&buf[80] = 2;
                    v255 = 2098;
                    *(_QWORD *)v256 = (char *)v211 + 6;
                    *(_WORD *)&v256[8] = 2160;
                    *(_QWORD *)&v256[10] = 1752392040;
                    *(_WORD *)&v256[18] = 1041;
                    v257 = 8;
                    v258 = 2097;
                    v259 = v211 + 1;
                    v260 = 2082;
                    v261 = v217;
                    v262 = 2160;
                    v263 = 1752392040;
                    v264 = 1041;
                    v265 = 6;
                    v266 = 2097;
                    v267 = v188 + 12;
                    v268 = 2160;
                    v269 = 1752392040;
                    v270 = 1042;
                    v271 = 2;
                    v272 = 2098;
                    v273 = v188 + 18;
                    v274 = 2160;
                    v275 = 1752392040;
                    v276 = 1041;
                    v277 = 8;
                    v278 = 2097;
                    v279 = v188 + 20;
                    _os_log_impl((void *)&_mh_execute_header, v213, OS_LOG_TYPE_DEFAULT, "%{public}s: mapping host %{private, mask.hash}s address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} to {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0xD0u);
                    v211 = *(_QWORD **)(v210 + 40);
                  }
                  else
                  {
                    v218 = v247;
                  }
                  v182 = v218;
                  if (!cti_add_ml_eid_mapping_(v210, v211, (const void *)(v188 + 12), (const char *)v218[7]))
                  {
                    v220 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      v221 = *(_DWORD *)v210;
                      *(_DWORD *)buf = 136447490;
                      *(_QWORD *)&buf[4] = "prepare_update";
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v221;
                      *(_WORD *)&buf[18] = 2048;
                      *(_QWORD *)&buf[20] = v210;
                      *(_WORD *)&buf[28] = 2080;
                      *(_QWORD *)&buf[30] = "arec";
                      *(_WORD *)&buf[38] = 2080;
                      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                      *(_WORD *)&buf[48] = 1024;
                      *(_DWORD *)&buf[50] = 3620;
                      _os_log_impl((void *)&_mh_execute_header, v220, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                    }
                    v222 = *(_DWORD *)v210;
                    if (*(_DWORD *)v210)
                    {
                      v223 = v222 + 1;
                      *(_DWORD *)v210 = v222 + 1;
                      v182 = v247;
                      if (v222 + 1 >= 10001)
                      {
                        v230 = global_os_log;
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = 136447490;
                          *(_QWORD *)&buf[4] = "prepare_update";
                          *(_WORD *)&buf[12] = 1024;
                          *(_DWORD *)&buf[14] = v223;
                          *(_WORD *)&buf[18] = 2048;
                          *(_QWORD *)&buf[20] = v210;
                          *(_WORD *)&buf[28] = 2080;
                          *(_QWORD *)&buf[30] = "arec";
                          *(_WORD *)&buf[38] = 2080;
                          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                          *(_WORD *)&buf[48] = 1024;
                          *(_DWORD *)&buf[50] = 3620;
                          v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                          goto LABEL_480;
                        }
LABEL_483:
                        abort();
                      }
                    }
                    else
                    {
                      ++adv_record_created;
                      *(_DWORD *)v210 = 1;
                      v182 = v247;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v182[6] = v244;
    v191 = global_os_log;
    v192 = (int *)v244;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v193 = *(_DWORD *)v244;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v193;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3628;
      _os_log_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v192 = (int *)v182[6];
    }
    v194 = *v192;
    if (*v192)
    {
      v195 = v194 + 1;
      *v192 = v194 + 1;
      if (v194 + 1 >= 10001)
      {
        v230 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "prepare_update";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v195;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v192;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "host->update";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3628;
          v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_480;
        }
        goto LABEL_483;
      }
    }
    else
    {
      ++adv_update_created;
      *v192 = 1;
    }
    v196 = *(_DWORD *)v244;
    if (*(_DWORD *)v244)
    {
      v10 = global_os_log;
      if (v196 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "prepare_update";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v196;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v244;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "update";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3629;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v196 = *(_DWORD *)v244;
        }
        *(_DWORD *)v244 = v196 - 1;
        if (v196 == 1)
        {
          v197 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "prepare_update";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v244;
            *(_WORD *)&buf[22] = 2080;
            *(_QWORD *)&buf[24] = "update";
            *(_WORD *)&buf[32] = 2080;
            *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = 3629;
            _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_update_finalized;
          adv_update_finalize(v244);
        }
        start_host_update(v182);
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_483;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v196;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3629;
      v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_483;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3629;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    goto LABEL_474;
  }
  v101 = 0;
  while (1)
  {
    v102 = v101;
    v103 = (int *)malloc_type_calloc(1uLL, 0x78uLL, 0x10300404874479FuLL);
    v104 = *((_QWORD *)v5 + 306);
    if (!v103)
    {
      a2 = v243;
      v48 = v237;
      if (!os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
        goto LABEL_438;
      *(_DWORD *)v248 = 136446210;
      v249 = "adv_instance_create";
      v198 = "%{public}s: adv_instance:create: unable to allocate raw registration struct.";
      v199 = v104;
      goto LABEL_437;
    }
    v105 = v103;
    if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
    {
      v106 = *v105;
      *(_DWORD *)v248 = 136447490;
      v249 = "adv_instance_create";
      v250 = 1024;
      *(_DWORD *)v251 = v106;
      *(_WORD *)&v251[4] = 2048;
      *(_QWORD *)&v251[6] = v105;
      *(_WORD *)&v251[14] = 2080;
      *(_QWORD *)&v251[16] = "instance";
      *(_WORD *)&v251[24] = 2080;
      *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
      v252 = 1024;
      v253 = 2585;
      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
    }
    v107 = *v105;
    if (*v105)
    {
      v108 = v107 + 1;
      *v105 = v107 + 1;
      if (v107 + 1 >= 10001)
      {
        v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v108;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2585;
        v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
    }
    else
    {
      ++adv_instance_created;
      *v105 = 1;
    }
    v109 = (int *)v247;
    *((_QWORD *)v105 + 3) = v247;
    v110 = global_os_log;
    if (v247)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v111 = *(_DWORD *)v247;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v111;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v247;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance->host";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2587;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        v109 = (int *)*((_QWORD *)v105 + 3);
      }
      v112 = *v109;
      if (*v109)
      {
        v113 = v112 + 1;
        *v109 = v112 + 1;
        v110 = global_os_log;
        if (v112 + 1 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_483;
          *(_DWORD *)v248 = 136447490;
          v249 = "adv_instance_create";
          v250 = 1024;
          *(_DWORD *)v251 = v113;
          *(_WORD *)&v251[4] = 2048;
          *(_QWORD *)&v251[6] = v109;
          *(_WORD *)&v251[14] = 2080;
          *(_QWORD *)&v251[16] = "instance->host";
          *(_WORD *)&v251[24] = 2080;
          *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
          v252 = 1024;
          v253 = 2587;
          v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          v225 = v248;
LABEL_500:
          v226 = v110;
          goto LABEL_482;
        }
      }
      else
      {
        ++adv_host_created;
        *v109 = 1;
        v110 = global_os_log;
      }
    }
    *((_QWORD *)v105 + 4) = v4;
    v114 = v4;
    if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
    {
      v115 = *v4;
      *(_DWORD *)v248 = 136447490;
      v249 = "adv_instance_create";
      v250 = 1024;
      *(_DWORD *)v251 = v115;
      *(_WORD *)&v251[4] = 2048;
      *(_QWORD *)&v251[6] = v4;
      *(_WORD *)&v251[14] = 2080;
      *(_QWORD *)&v251[16] = "instance->update";
      *(_WORD *)&v251[24] = 2080;
      *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
      v252 = 1024;
      v253 = 2589;
      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
      v114 = (int *)*((_QWORD *)v105 + 4);
    }
    v116 = *v114;
    if (*v114)
    {
      v117 = v116 + 1;
      *v114 = v116 + 1;
      if (v116 + 1 >= 10001)
      {
        v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v117;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v114;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance->update";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2589;
        v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
    }
    else
    {
      ++adv_update_created;
      *v114 = 1;
    }
    v118 = *(_QWORD *)(v100 + 48);
    if (v118)
      LODWORD(v118) = *(unsigned __int16 *)(v118 + 28);
    v5 = &dnssd_client_states;
    v105[16] = v118;
    if (!extract_instance_name(buf, 0x3F2uLL, __s1, v100))
    {
      v200 = *v105;
      if (*v105)
      {
        v133 = global_os_log;
        v48 = v237;
        if (v200 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v248 = 136447490;
            v249 = "adv_instance_create";
            v250 = 1024;
            *(_DWORD *)v251 = v200;
            *(_WORD *)&v251[4] = 2048;
            *(_QWORD *)&v251[6] = v105;
            *(_WORD *)&v251[14] = 2080;
            *(_QWORD *)&v251[16] = "instance";
            *(_WORD *)&v251[24] = 2080;
            *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
            v252 = 1024;
            v253 = 2596;
            _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
            v200 = *v105;
          }
          v129 = v200 == 1;
          *v105 = v200 - 1;
          a2 = v243;
          if (!v129)
          {
LABEL_438:
            v5 = &dnssd_client_states;
            goto LABEL_439;
          }
          v201 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v248 = 136447234;
            v249 = "adv_instance_create";
            v250 = 2048;
            *(_QWORD *)v251 = v105;
            *(_WORD *)&v251[8] = 2080;
            *(_QWORD *)&v251[10] = "instance";
            *(_WORD *)&v251[18] = 2080;
            *(_QWORD *)&v251[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v251[28] = 1024;
            *(_DWORD *)&v251[30] = 2596;
            goto LABEL_382;
          }
LABEL_383:
          ++adv_instance_finalized;
          adv_instance_finalize(v105);
          goto LABEL_438;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v200;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2596;
        v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_525:
        v225 = v248;
        goto LABEL_461;
      }
      v230 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_483;
      *(_DWORD *)v248 = 136447490;
      v249 = "adv_instance_create";
      v250 = 1024;
      *(_DWORD *)v251 = 0;
      *(_WORD *)&v251[4] = 2048;
      *(_QWORD *)&v251[6] = v105;
      *(_WORD *)&v251[14] = 2080;
      *(_QWORD *)&v251[16] = "instance";
      *(_WORD *)&v251[24] = 2080;
      *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
      v252 = 1024;
      v253 = 2596;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_488:
      v225 = v248;
LABEL_481:
      v226 = v230;
      goto LABEL_482;
    }
    v119 = strdup(buf);
    *((_QWORD *)v105 + 6) = v119;
    if (!v119)
    {
      v202 = global_os_log;
      v48 = v237;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v248 = 136446210;
        v249 = "adv_instance_create";
        _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_ERROR, "%{public}s: adv_instance:create: unable to allocate instance name.", v248, 0xCu);
      }
      v203 = *v105;
      if (!*v105)
      {
        v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = 0;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2603;
        v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      v133 = global_os_log;
      if (v203 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v203;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2603;
        v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_525;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v203;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2603;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        v203 = *v105;
      }
      v129 = v203 == 1;
      *v105 = v203 - 1;
      a2 = v243;
      if (!v129)
        goto LABEL_438;
      v201 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_383;
      *(_DWORD *)v248 = 136447234;
      v249 = "adv_instance_create";
      v250 = 2048;
      *(_QWORD *)v251 = v105;
      *(_WORD *)&v251[8] = 2080;
      *(_QWORD *)&v251[10] = "instance";
      *(_WORD *)&v251[18] = 2080;
      *(_QWORD *)&v251[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v251[28] = 1024;
      *(_DWORD *)&v251[30] = 2603;
LABEL_382:
      _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v248, 0x30u);
      goto LABEL_383;
    }
    v120 = strdup(__s1);
    *((_QWORD *)v105 + 7) = v120;
    if (!v120)
    {
      v204 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v248 = 136446210;
        v249 = "adv_instance_create";
        _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_ERROR, "%{public}s: adv_instance:create: unable to allocate instance type.", v248, 0xCu);
      }
      v205 = *v105;
      v48 = v237;
      if (!*v105)
      {
        v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = 0;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2609;
        v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      v133 = global_os_log;
      if (v205 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v205;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2609;
        v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_525;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v205;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2609;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        v205 = *v105;
      }
      v129 = v205 == 1;
      *v105 = v205 - 1;
      a2 = v243;
      if (!v129)
        goto LABEL_438;
      v201 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_383;
      *(_DWORD *)v248 = 136447234;
      v249 = "adv_instance_create";
      v250 = 2048;
      *(_QWORD *)v251 = v105;
      *(_WORD *)&v251[8] = 2080;
      *(_QWORD *)&v251[10] = "instance";
      *(_WORD *)&v251[18] = 2080;
      *(_QWORD *)&v251[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v251[28] = 1024;
      *(_DWORD *)&v251[30] = 2609;
      goto LABEL_382;
    }
    v121 = *(_QWORD *)(v100 + 56);
    if (v121)
    {
      v122 = malloc_type_malloc(*(unsigned __int8 *)(v121 + 16), 0xE630E6A3uLL);
      if (v122)
      {
        v123 = v122;
        memcpy(v122, *(const void **)(*(_QWORD *)(v100 + 56) + 24), *(unsigned __int8 *)(*(_QWORD *)(v100 + 56) + 16));
        *((_QWORD *)v105 + 9) = v123;
        LOWORD(v121) = *(unsigned __int8 *)(*(_QWORD *)(v100 + 56) + 16);
        v5 = &dnssd_client_states;
        goto LABEL_173;
      }
      v208 = *v105;
      if (!*v105)
      {
        v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = 0;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2617;
        v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      v133 = global_os_log;
      v48 = v237;
      if (v208 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v208;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2617;
        v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_525;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v248 = 136447490;
        v249 = "adv_instance_create";
        v250 = 1024;
        *(_DWORD *)v251 = v208;
        *(_WORD *)&v251[4] = 2048;
        *(_QWORD *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(_QWORD *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(_QWORD *)&v251[26] = "srp-mdns-proxy.c";
        v252 = 1024;
        v253 = 2617;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        v208 = *v105;
        v133 = global_os_log;
      }
      *v105 = v208 - 1;
      if (v208 == 1)
      {
        a2 = v243;
        if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v248 = 136447234;
          v249 = "adv_instance_create";
          v250 = 2048;
          *(_QWORD *)v251 = v105;
          *(_WORD *)&v251[8] = 2080;
          *(_QWORD *)&v251[10] = "instance";
          *(_WORD *)&v251[18] = 2080;
          *(_QWORD *)&v251[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v251[28] = 1024;
          *(_DWORD *)&v251[30] = 2617;
          _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v248, 0x30u);
        }
        ++adv_instance_finalized;
        adv_instance_finalize(v105);
        v133 = global_os_log;
      }
      else
      {
        a2 = v243;
      }
      if (!os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
        goto LABEL_438;
      *(_DWORD *)v248 = 136446210;
      v249 = "adv_instance_create";
      v198 = "%{public}s: adv_instance:create: unable to allocate txt_data buffer";
      v199 = v133;
LABEL_437:
      _os_log_impl((void *)&_mh_execute_header, v199, OS_LOG_TYPE_ERROR, v198, v248, 0xCu);
      goto LABEL_438;
    }
    *((_QWORD *)v105 + 9) = 0;
LABEL_173:
    *((_WORD *)v105 + 40) = v121;
    *((_BYTE *)v105 + 119) = *(_BYTE *)(v100 + 64);
    if ((v96 & ~((int)v96 >> 31)) == v102)
      break;
    *((_BYTE *)v105 + 118) = 0;
    if (v243[1])
    {
      v124 = v243[4];
      if (v124)
      {
        if (*(_BYTE *)(v124 + 33) == 30)
        {
          v125 = *(unsigned __int16 *)(v124 + 34);
          v126 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v127 = *(unsigned __int8 *)(v124 + 40);
            v128 = "ULA: ";
            if ((v127 & 0xFE) != 0xFC)
            {
              if (v127 != 254 || (v128 = "LUA: ", (*(_BYTE *)(v124 + 41) & 0xC0) != 0x80))
              {
                v128 = "GUA: ";
                if ((v127 & 0xE0) != 0x20)
                  v128 = (const char *)&unk_10007C3B5;
              }
            }
            *(_DWORD *)buf = 136449027;
            *(_QWORD *)&buf[4] = "prepare_update";
            *(_WORD *)&buf[12] = 2082;
            *(_QWORD *)&buf[14] = v128;
            *(_WORD *)&buf[22] = 2160;
            *(_QWORD *)&buf[24] = 1752392040;
            *(_WORD *)&buf[32] = 1041;
            *(_DWORD *)&buf[34] = 6;
            *(_WORD *)&buf[38] = 2097;
            *(_QWORD *)&buf[40] = v124 + 40;
            *(_WORD *)&buf[48] = 2160;
            *(_QWORD *)&buf[50] = 1752392040;
            *(_WORD *)&buf[58] = 1042;
            *(_DWORD *)&buf[60] = 2;
            *(_WORD *)&buf[64] = 2098;
            *(_QWORD *)&buf[66] = v124 + 46;
            *(_WORD *)&buf[74] = 2160;
            *(_QWORD *)&buf[76] = 1752392040;
            v255 = 1041;
            *(_DWORD *)v256 = 8;
            *(_WORD *)&v256[4] = 2097;
            *(_QWORD *)&v256[6] = v124 + 48;
            *(_WORD *)&v256[14] = 1024;
            *(_DWORD *)&v256[16] = __rev16(v125);
            _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "%{public}s: server address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}; server port %d",
              buf,
              0x6Au);
          }
          v129 = *(_DWORD *)(v124 + 48) == -16777216 && *(_DWORD *)(v124 + 51) == -67043585;
          if (v129 && v125 == 13568)
            *((_BYTE *)v105 + 118) = 1;
        }
      }
      else
      {
        v130 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(_QWORD *)&buf[4] = "connection_get_local_address";
          _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_ERROR, "%{public}s: message is NULL.", buf, 0xCu);
        }
      }
    }
    v101 = v102 + 1;
    *(_QWORD *)(v241[1] + 8 * v102) = v105;
    v100 = *(_QWORD *)v100;
    v4 = (int *)v244;
    v5 = &dnssd_client_states;
    if (!v100)
    {
      v99 = v241;
      goto LABEL_266;
    }
  }
  v206 = *((_QWORD *)v5 + 306);
  if (os_log_type_enabled(v206, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "prepare_update";
    _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_FAULT, "%{public}s: while preparing client update instances, i >= num_add_instances", buf, 0xCu);
  }
  v207 = *v105;
  v48 = v237;
  if (!*v105)
  {
    v230 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v105;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "prepared_instance";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3485;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  v133 = *((_QWORD *)v5 + 306);
  if (v207 >= 10001)
  {
    if (!os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
      goto LABEL_483;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v207;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v105;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "prepared_instance";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3485;
    v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_460;
  }
  if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v207;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v105;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "prepared_instance";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3485;
    _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v207 = *v105;
  }
  *v105 = v207 - 1;
  if (v207 == 1)
  {
    v224 = *((_QWORD *)v5 + 306);
    a2 = v243;
    if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v105;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = "prepared_instance";
      *(_WORD *)&buf[32] = 2080;
      *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 3485;
      _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_instance_finalized;
    adv_instance_finalize(v105);
  }
  else
  {
    a2 = v243;
  }
LABEL_439:
  v50 = v238;
  v49 = (int *)v241;
LABEL_202:
  srp_parse_client_updates_free_(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3648);
  if (!v18)
    goto LABEL_208;
  v132 = *(_DWORD *)v18;
  if (!*(_DWORD *)v18)
  {
    v230 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v18;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "remove_addrs";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3653;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  v133 = *((_QWORD *)v5 + 306);
  if (v132 >= 10001)
  {
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT))
      goto LABEL_483;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v132;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v18;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "remove_addrs";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3653;
    v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_460;
  }
  if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v132;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v18;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "remove_addrs";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3653;
    _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v132 = *(_DWORD *)v18;
  }
  *(_DWORD *)v18 = v132 - 1;
  if (v132 == 1)
  {
    v136 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v18;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = "remove_addrs";
      *(_WORD *)&buf[32] = 2080;
      *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 3653;
      _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_record_vec_finalized;
    adv_record_vec_finalize(v18);
    if (v22)
    {
LABEL_209:
      v134 = *(_DWORD *)v22;
      if (!*(_DWORD *)v22)
      {
        v230 = *((_QWORD *)v5 + 306);
        if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "prepare_update";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = 0;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v22;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "add_addrs";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3657;
          v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_480;
        }
        goto LABEL_483;
      }
      v133 = *((_QWORD *)v5 + 306);
      if (v134 >= 10001)
      {
        if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT))
          goto LABEL_483;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "prepare_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v134;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v22;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "add_addrs";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3657;
        v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_460;
      }
      if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "prepare_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v134;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v22;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "add_addrs";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3657;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v134 = *(_DWORD *)v22;
      }
      *(_DWORD *)v22 = v134 - 1;
      if (v134 == 1)
      {
        v135 = *((_QWORD *)v5 + 306);
        if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "prepare_update";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v22;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = "add_addrs";
          *(_WORD *)&buf[32] = 2080;
          *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 3657;
          _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize(v22);
      }
    }
  }
  else
  {
LABEL_208:
    if (v22)
      goto LABEL_209;
  }
  if (!v49)
  {
LABEL_226:
    if (!v50)
      goto LABEL_238;
LABEL_227:
    v138 = *(_DWORD *)v50;
    if (!*(_DWORD *)v50)
    {
      v230 = *((_QWORD *)v5 + 306);
      if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "prepare_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v50;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "remove_instances";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3665;
        v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_480;
      }
      goto LABEL_483;
    }
    v10 = *((_QWORD *)v5 + 306);
    if (v138 < 10001)
    {
      if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "prepare_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v138;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v50;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "remove_instances";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3665;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v138 = *(_DWORD *)v50;
      }
      *(_DWORD *)v50 = v138 - 1;
      if (v138 == 1)
      {
        v139 = *((_QWORD *)v5 + 306);
        if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "prepare_update";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v50;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = "remove_instances";
          *(_WORD *)&buf[32] = 2080;
          *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 3665;
          _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize(v50);
      }
      goto LABEL_238;
    }
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT))
      goto LABEL_483;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v138;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v50;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "remove_instances";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3665;
    v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_474;
  }
  v137 = *v49;
  if (!*v49)
  {
    v230 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v49;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "add_instances";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3661;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  v10 = *((_QWORD *)v5 + 306);
  if (v137 >= 10001)
  {
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT))
      goto LABEL_483;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v137;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v49;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "add_instances";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3661;
    v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_474;
  }
  if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v137;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v49;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "add_instances";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3661;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v137 = *v49;
  }
  *v49 = v137 - 1;
  if (v137 != 1)
    goto LABEL_226;
  v140 = *((_QWORD *)v5 + 306);
  if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447234;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = v49;
    *(_WORD *)&buf[22] = 2080;
    *(_QWORD *)&buf[24] = "add_instances";
    *(_WORD *)&buf[32] = 2080;
    *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[42] = 1024;
    *(_DWORD *)&buf[44] = 3661;
    _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
  }
  ++adv_instance_vec_finalized;
  adv_instance_vec_finalize((uint64_t)v49);
  if (v50)
    goto LABEL_227;
LABEL_238:
  if (!v48)
    goto LABEL_244;
  v141 = *v48;
  if (!*v48)
  {
    v230 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v48;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update_instances";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3669;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  v10 = *((_QWORD *)v5 + 306);
  if (v141 >= 10001)
  {
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT))
      goto LABEL_483;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v141;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v48;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update_instances";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3669;
    v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_474;
  }
  if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "prepare_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v141;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v48;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update_instances";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3669;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v141 = *v48;
  }
  *v48 = v141 - 1;
  if (v141 == 1)
  {
    v144 = *((_QWORD *)v5 + 306);
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 2048;
      *(_QWORD *)&buf[14] = v48;
      *(_WORD *)&buf[22] = 2080;
      *(_QWORD *)&buf[24] = "update_instances";
      *(_WORD *)&buf[32] = 2080;
      *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 3669;
      _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_instance_vec_finalized;
    adv_instance_vec_finalize((uint64_t)v48);
    if (!v4)
      return;
LABEL_245:
    v142 = *v4;
    if (*v4)
    {
      v10 = *((_QWORD *)v5 + 306);
      if (v142 < 10001)
      {
        if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(_QWORD *)&buf[4] = "prepare_update";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v142;
          *(_WORD *)&buf[18] = 2048;
          *(_QWORD *)&buf[20] = v4;
          *(_WORD *)&buf[28] = 2080;
          *(_QWORD *)&buf[30] = "update";
          *(_WORD *)&buf[38] = 2080;
          *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3673;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v142 = *v4;
        }
        *v4 = v142 - 1;
        if (v142 == 1)
        {
          v143 = *((_QWORD *)v5 + 306);
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            *(_QWORD *)&buf[4] = "prepare_update";
            *(_WORD *)&buf[12] = 2048;
            *(_QWORD *)&buf[14] = v4;
            *(_WORD *)&buf[22] = 2080;
            *(_QWORD *)&buf[24] = "update";
            *(_WORD *)&buf[32] = 2080;
            *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = 3673;
            _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_update_finalized;
          adv_update_finalize((uint64_t)v4);
        }
        return;
      }
      if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT))
        goto LABEL_483;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v142;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3673;
      v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v10 = *((_QWORD *)v5 + 306);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        goto LABEL_483;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "prepare_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3673;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
LABEL_474:
    v225 = buf;
    v226 = v10;
    goto LABEL_482;
  }
LABEL_244:
  if (v4)
    goto LABEL_245;
}

_DWORD *adv_record_create_(__int16 a1, unsigned int a2, const void *a3, _DWORD *a4, int a5)
{
  __int16 v8;
  size_t v10;
  _DWORD *v11;
  _DWORD *v12;
  void *v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  NSObject *v20;
  NSObject *v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v27;
  const char *v28;
  __int16 v29;
  int v30;
  __int16 v31;
  _DWORD *v32;
  __int16 v33;
  const char *v34;
  __int16 v35;
  char *v36;
  __int16 v37;
  int v38;

  v8 = a2;
  v10 = a2;
  v11 = malloc_type_calloc(1uLL, a2 + 55, 0xB9A43D48uLL);
  if (!v11)
  {
    v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v27 = 136446210;
      v28 = "adv_record_create_";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: no memory for new_record", (uint8_t *)&v27, 0xCu);
    }
    return 0;
  }
  v12 = v11;
  v13 = malloc_type_malloc(v10, 0xF75754B5uLL);
  *((_QWORD *)v12 + 5) = v13;
  if (!v13)
  {
    v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v27 = 136446210;
      v28 = "adv_record_create_";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: no memory for new_record->rdata", (uint8_t *)&v27, 0xCu);
    }
    free(v12);
    return 0;
  }
  *((_QWORD *)v12 + 2) = a4;
  v14 = global_os_log;
  if (a4)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v15 = *a4;
      v27 = 136447490;
      v28 = "adv_record_create_";
      v29 = 1024;
      v30 = v15;
      v31 = 2048;
      v32 = a4;
      v33 = 2080;
      v34 = "host";
      v35 = 2080;
      v36 = "srp-mdns-proxy.c";
      v37 = 1024;
      v38 = a5;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
    }
    v16 = *a4;
    if (*a4)
    {
      v17 = v16 + 1;
      *a4 = v16 + 1;
      if (v16 + 1 > 10000)
      {
        v18 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_25;
        v27 = 136447490;
        v28 = "adv_record_create_";
        v29 = 1024;
        v30 = v17;
        v31 = 2048;
        v32 = a4;
        v33 = 2080;
        v34 = "host";
        v35 = 2080;
        v36 = "srp-mdns-proxy.c";
        v37 = 1024;
        v38 = a5;
        v19 = v18;
        goto LABEL_24;
      }
    }
    else
    {
      ++adv_host_created;
      *a4 = 1;
    }
    v13 = (void *)*((_QWORD *)v12 + 5);
    v14 = global_os_log;
  }
  *((_WORD *)v12 + 24) = a1;
  *((_WORD *)v12 + 25) = v8;
  memcpy(v13, a3, v10);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    v22 = *v12;
    v27 = 136447490;
    v28 = "adv_record_create_";
    v29 = 1024;
    v30 = v22;
    v31 = 2048;
    v32 = v12;
    v33 = 2080;
    v34 = "new_record";
    v35 = 2080;
    v36 = "srp-mdns-proxy.c";
    v37 = 1024;
    v38 = a5;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
  }
  v23 = *v12;
  if (*v12)
  {
    v24 = v23 + 1;
    *v12 = v23 + 1;
    if (v23 + 1 >= 10001)
    {
      v25 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_25;
      v27 = 136447490;
      v28 = "adv_record_create_";
      v29 = 1024;
      v30 = v24;
      v31 = 2048;
      v32 = v12;
      v33 = 2080;
      v34 = "new_record";
      v35 = 2080;
      v36 = "srp-mdns-proxy.c";
      v37 = 1024;
      v38 = a5;
      v19 = v25;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
LABEL_25:
      abort();
    }
  }
  else
  {
    ++adv_record_created;
    *v12 = 1;
  }
  return v12;
}

void srp_ml_eid_mapping_callback(uint64_t a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  _BOOL4 v6;
  unsigned __int8 *v7;
  int v8;
  const char *v9;
  unsigned __int8 *v10;
  int v11;
  const char *v12;
  unsigned __int8 *v13;
  int v14;
  const char *v15;
  unsigned __int8 *v16;
  int v17;
  const char *v18;
  uint64_t v19;
  const char *v20;
  NSObject *v21;
  uint32_t v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  NSObject *v26;
  const char *v27;
  int v28;
  const char *v29;
  __int16 v30;
  _BYTE v31[34];
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  int v35;
  __int16 v36;
  unsigned __int8 *v37;
  __int16 v38;
  uint64_t v39;
  __int16 v40;
  int v41;
  __int16 v42;
  unsigned __int8 *v43;
  __int16 v44;
  uint64_t v45;
  __int16 v46;
  uint64_t v47;
  __int16 v48;
  int v49;

  v4 = *(_QWORD *)(a1 + 16);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v4)
    {
      if (!v6)
        goto LABEL_45;
      v7 = *(unsigned __int8 **)(a1 + 40);
      v8 = *v7;
      if ((v8 & 0xFE) == 0xFC)
      {
        v9 = "ULA: ";
      }
      else if (v8 == 254 && (v7[1] & 0xC0) == 0x80)
      {
        v9 = "LUA: ";
      }
      else if ((v8 & 0xE0) == 0x20)
      {
        v9 = "GUA: ";
      }
      else
      {
        v9 = (const char *)&unk_10007C3B5;
      }
      v19 = *(_QWORD *)(v4 + 56);
      v28 = 136449539;
      v29 = "srp_ml_eid_mapping_callback";
      v30 = 2082;
      *(_QWORD *)v31 = v9;
      *(_WORD *)&v31[8] = 2160;
      *(_QWORD *)&v31[10] = 1752392040;
      *(_WORD *)&v31[18] = 1041;
      *(_DWORD *)&v31[20] = 6;
      *(_WORD *)&v31[24] = 2097;
      *(_QWORD *)&v31[26] = v7;
      v32 = 2160;
      v33 = 1752392040;
      v34 = 1042;
      v35 = 2;
      v36 = 2098;
      v37 = v7 + 6;
      v38 = 2160;
      v39 = 1752392040;
      v40 = 1041;
      v41 = 8;
      v42 = 2097;
      v43 = v7 + 8;
      v44 = 2160;
      v45 = 1752392040;
      v46 = 2081;
      v47 = v19;
      v48 = 1024;
      v49 = a2;
      v20 = "%{public}s: mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.has"
            "h, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} to host %{private, mask.hash}s failed: %d";
      v21 = v5;
      v22 = 126;
    }
    else
    {
      if (!v6)
        goto LABEL_45;
      v13 = *(unsigned __int8 **)(a1 + 40);
      v14 = *v13;
      if ((v14 & 0xFE) == 0xFC)
      {
        v15 = "ULA: ";
      }
      else if (v14 == 254 && (v13[1] & 0xC0) == 0x80)
      {
        v15 = "LUA: ";
      }
      else if ((v14 & 0xE0) == 0x20)
      {
        v15 = "GUA: ";
      }
      else
      {
        v15 = (const char *)&unk_10007C3B5;
      }
      v28 = 136449027;
      v29 = "srp_ml_eid_mapping_callback";
      v30 = 2082;
      *(_QWORD *)v31 = v15;
      *(_WORD *)&v31[8] = 2160;
      *(_QWORD *)&v31[10] = 1752392040;
      *(_WORD *)&v31[18] = 1041;
      *(_DWORD *)&v31[20] = 6;
      *(_WORD *)&v31[24] = 2097;
      *(_QWORD *)&v31[26] = v13;
      v32 = 2160;
      v33 = 1752392040;
      v34 = 1042;
      v35 = 2;
      v36 = 2098;
      v37 = v13 + 6;
      v38 = 2160;
      v39 = 1752392040;
      v40 = 1041;
      v41 = 8;
      v42 = 2097;
      v43 = v13 + 8;
      v44 = 1024;
      LODWORD(v45) = a2;
      v20 = "%{public}s: orphaned mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public,"
            " mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} failed: %d";
      v21 = v5;
      v22 = 106;
    }
  }
  else if (v4)
  {
    if (!v6)
      goto LABEL_45;
    v10 = *(unsigned __int8 **)(a1 + 40);
    v11 = *v10;
    if ((v11 & 0xFE) == 0xFC)
    {
      v12 = "ULA: ";
    }
    else if (v11 == 254 && (v10[1] & 0xC0) == 0x80)
    {
      v12 = "LUA: ";
    }
    else if ((v11 & 0xE0) == 0x20)
    {
      v12 = "GUA: ";
    }
    else
    {
      v12 = (const char *)&unk_10007C3B5;
    }
    v23 = *(_QWORD *)(v4 + 56);
    v28 = 136449283;
    v29 = "srp_ml_eid_mapping_callback";
    v30 = 2082;
    *(_QWORD *)v31 = v12;
    *(_WORD *)&v31[8] = 2160;
    *(_QWORD *)&v31[10] = 1752392040;
    *(_WORD *)&v31[18] = 1041;
    *(_DWORD *)&v31[20] = 6;
    *(_WORD *)&v31[24] = 2097;
    *(_QWORD *)&v31[26] = v10;
    v32 = 2160;
    v33 = 1752392040;
    v34 = 1042;
    v35 = 2;
    v36 = 2098;
    v37 = v10 + 6;
    v38 = 2160;
    v39 = 1752392040;
    v40 = 1041;
    v41 = 8;
    v42 = 2097;
    v43 = v10 + 8;
    v44 = 2160;
    v45 = 1752392040;
    v46 = 2081;
    v47 = v23;
    v20 = "%{public}s: mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash,"
          " srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} to host %{private, mask.hash}s succeeded";
    v21 = v5;
    v22 = 120;
  }
  else
  {
    if (!v6)
      goto LABEL_45;
    v16 = *(unsigned __int8 **)(a1 + 40);
    v17 = *v16;
    if ((v17 & 0xFE) == 0xFC)
    {
      v18 = "ULA: ";
    }
    else if (v17 == 254 && (v16[1] & 0xC0) == 0x80)
    {
      v18 = "LUA: ";
    }
    else if ((v17 & 0xE0) == 0x20)
    {
      v18 = "GUA: ";
    }
    else
    {
      v18 = (const char *)&unk_10007C3B5;
    }
    v28 = 136448771;
    v29 = "srp_ml_eid_mapping_callback";
    v30 = 2082;
    *(_QWORD *)v31 = v18;
    *(_WORD *)&v31[8] = 2160;
    *(_QWORD *)&v31[10] = 1752392040;
    *(_WORD *)&v31[18] = 1041;
    *(_DWORD *)&v31[20] = 6;
    *(_WORD *)&v31[24] = 2097;
    *(_QWORD *)&v31[26] = v16;
    v32 = 2160;
    v33 = 1752392040;
    v34 = 1042;
    v35 = 2;
    v36 = 2098;
    v37 = v16 + 6;
    v38 = 2160;
    v39 = 1752392040;
    v40 = 1041;
    v41 = 8;
    v42 = 2097;
    v43 = v16 + 8;
    v20 = "%{public}s: mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash,"
          " srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} was orphaned.";
    v21 = v5;
    v22 = 100;
  }
  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v28, v22);
LABEL_45:
  v24 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v25 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_59;
    v28 = 136447490;
    v29 = "srp_ml_eid_mapping_callback";
    v30 = 1024;
    *(_DWORD *)v31 = 0;
    *(_WORD *)&v31[4] = 2048;
    *(_QWORD *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(_QWORD *)&v31[16] = "arec";
    *(_WORD *)&v31[24] = 2080;
    *(_QWORD *)&v31[26] = "srp-mdns-proxy.c";
    v32 = 1024;
    LODWORD(v33) = 595;
    v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_58;
  }
  v25 = global_os_log;
  if (v24 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_59;
    v28 = 136447490;
    v29 = "srp_ml_eid_mapping_callback";
    v30 = 1024;
    *(_DWORD *)v31 = v24;
    *(_WORD *)&v31[4] = 2048;
    *(_QWORD *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(_QWORD *)&v31[16] = "arec";
    *(_WORD *)&v31[24] = 2080;
    *(_QWORD *)&v31[26] = "srp-mdns-proxy.c";
    v32 = 1024;
    LODWORD(v33) = 595;
    v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_58:
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, v27, (uint8_t *)&v28, 0x36u);
LABEL_59:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v28 = 136447490;
    v29 = "srp_ml_eid_mapping_callback";
    v30 = 1024;
    *(_DWORD *)v31 = v24;
    *(_WORD *)&v31[4] = 2048;
    *(_QWORD *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(_QWORD *)&v31[16] = "arec";
    *(_WORD *)&v31[24] = 2080;
    *(_QWORD *)&v31[26] = "srp-mdns-proxy.c";
    v32 = 1024;
    LODWORD(v33) = 595;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
    v24 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v24 - 1;
  if (v24 == 1)
  {
    v26 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v28 = 136447234;
      v29 = "srp_ml_eid_mapping_callback";
      v30 = 2048;
      *(_QWORD *)v31 = a1;
      *(_WORD *)&v31[8] = 2080;
      *(_QWORD *)&v31[10] = "arec";
      *(_WORD *)&v31[18] = 2080;
      *(_QWORD *)&v31[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v31[28] = 1024;
      *(_DWORD *)&v31[30] = 595;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
    }
    ++adv_record_finalized;
    adv_record_finalize(a1);
  }
}

void start_host_update(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _BOOL4 v4;
  NSObject *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int *v15;
  NSObject *v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  int *v21;
  NSObject *v22;
  int v23;
  int v24;
  int v25;
  uint64_t v26;
  const char *v27;
  int *v28;
  int v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  NSObject *v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  _DWORD *v41;
  uint64_t v42;
  uint64_t j;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  NSObject *v47;
  uint64_t v48;
  NSObject *v49;
  uint64_t v50;
  uint64_t v51;
  NSObject *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  int v60;
  uint64_t v61;
  const char *v62;
  NSObject *v63;
  os_log_type_t v64;
  uint32_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int *v72;
  int v73;
  NSObject *v74;
  NSObject *v75;
  NSObject *v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  const char *v88;
  NSObject *v89;
  os_log_type_t v90;
  uint32_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  int updated;
  uint64_t v96;
  _BOOL4 v97;
  uint64_t v98;
  uint64_t v99;
  const char *v100;
  uint64_t v101;
  _BYTE buf[54];
  uint64_t v103;
  char v104[28];

  v2 = a1[6];
  if (!v2)
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v6 = a1[8];
      *(_DWORD *)buf = 136446723;
      *(_QWORD *)&buf[4] = "start_host_update";
      *(_WORD *)&buf[12] = 2160;
      *(_QWORD *)&buf[14] = 1752392040;
      *(_WORD *)&buf[22] = 2081;
      *(_QWORD *)&buf[24] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: start_host_update: no work to do for host %{private, mask.hash}s", buf, 0x20u);
    }
    return;
  }
  v3 = *(_QWORD *)(v2 + 16);
  if (v3)
    v4 = *(unsigned __int8 *)(v3 + 103) != 0;
  else
    v4 = 0;
  *(_DWORD *)(v2 + 96) = 0;
  v7 = *(_QWORD *)(v2 + 40);
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    v8 = 0;
    do
    {
      v9 = *(_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * v8);
      if (v9)
      {
        if ((register_host_record((uint64_t)a1, v9, v4) & 1) == 0)
        {
          update_failed(v2, 2u, 1);
          return;
        }
        if (!v4)
          ++*(_DWORD *)(v2 + 96);
      }
      ++v8;
      v7 = *(_QWORD *)(v2 + 40);
    }
    while (v8 < *(int *)(v7 + 4));
  }
  v10 = a1[12];
  if (v10 && *(int *)(v10 + 4) >= 1)
  {
    for (i = 0; i < *(int *)(v10 + 4); ++i)
    {
      v12 = *(_QWORD *)(v2 + 32);
      if (v12)
        v12 = *(_QWORD *)(*(_QWORD *)(v12 + 8) + 8 * i);
      if (!v12)
      {
        v13 = *(_QWORD *)(v10 + 8);
        v14 = *(_QWORD *)(v13 + 8 * i);
        if (v14)
        {
          if (!*(_QWORD *)(v14 + 8))
          {
            *(_QWORD *)(v14 + 32) = v2;
            v15 = *(int **)(*(_QWORD *)(v13 + 8 * i) + 32);
            if (v15)
            {
              v16 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                v17 = *v15;
                *(_DWORD *)buf = 136447490;
                *(_QWORD *)&buf[4] = "start_host_update";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v17;
                *(_WORD *)&buf[18] = 2048;
                *(_QWORD *)&buf[20] = v15;
                *(_WORD *)&buf[28] = 2080;
                *(_QWORD *)&buf[30] = "host->addresses->vec[i]->update";
                *(_WORD *)&buf[38] = 2080;
                *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3007;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                v15 = *(int **)(*(_QWORD *)(*(_QWORD *)(a1[12] + 8) + 8 * i) + 32);
              }
              v18 = *v15;
              if (!*v15)
              {
                ++adv_update_created;
                v18 = *v15;
              }
              v19 = v18 + 1;
              *v15 = v18 + 1;
              if (v18 + 1 >= 10001)
              {
                v26 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136447490;
                  *(_QWORD *)&buf[4] = "start_host_update";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v19;
                  *(_WORD *)&buf[18] = 2048;
                  *(_QWORD *)&buf[20] = v15;
                  *(_WORD *)&buf[28] = 2080;
                  *(_QWORD *)&buf[30] = "host->addresses->vec[i]->update";
                  *(_WORD *)&buf[38] = 2080;
                  *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3007;
                  v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_181;
                }
LABEL_183:
                abort();
              }
            }
            if ((register_host_record((uint64_t)a1, v14, v4) & 1) == 0)
              goto LABEL_159;
            if (!v4)
              ++*(_DWORD *)(v2 + 96);
          }
        }
      }
      v10 = a1[12];
    }
  }
  v20 = *(_QWORD *)(v2 + 48);
  if (v20)
  {
    if ((register_host_record((uint64_t)a1, v20, v4) & 1) == 0)
      goto LABEL_159;
    if (!v4)
      ++*(_DWORD *)(v2 + 96);
    if (*(_QWORD *)(v2 + 48))
      goto LABEL_194;
  }
  v21 = (int *)a1[13];
  if (!v21 || *((_QWORD *)v21 + 3) == *(_QWORD *)(a1[1] + 16) && *((_QWORD *)v21 + 1))
    goto LABEL_194;
  *(_QWORD *)(v2 + 48) = v21;
  v22 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v23 = *v21;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "start_host_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v23;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v21;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update->key";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3033;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v21 = *(int **)(v2 + 48);
  }
  v24 = *v21;
  if (*v21)
  {
    v25 = v24 + 1;
    *v21 = v24 + 1;
    if (v24 + 1 >= 10001)
    {
      v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "start_host_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v25;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v21;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->key";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3033;
        v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_181;
      }
      goto LABEL_183;
    }
  }
  else
  {
    ++adv_record_created;
    *v21 = 1;
  }
  v28 = (int *)a1[13];
  if (v28)
  {
    v29 = *v28;
    if (!*v28)
    {
      v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_183;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "start_host_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v28;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->key_record";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3034;
      v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_181:
      v38 = v26;
      goto LABEL_182;
    }
    v30 = global_os_log;
    if (v29 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_183;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "start_host_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v29;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v28;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->key_record";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3034;
      v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v38 = v30;
      goto LABEL_182;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "start_host_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v29;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v28;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "host->key_record";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3034;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v28 = (int *)a1[13];
      v29 = *v28;
    }
    *v28 = v29 - 1;
    if (v29 == 1)
    {
      v31 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        *(_QWORD *)&buf[4] = "start_host_update";
        *(_WORD *)&buf[12] = 2048;
        *(_QWORD *)&buf[14] = v28;
        *(_WORD *)&buf[22] = 2080;
        *(_QWORD *)&buf[24] = "host->key_record";
        *(_WORD *)&buf[32] = 2080;
        *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 3034;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v28 = (int *)a1[13];
      }
      ++adv_record_finalized;
      adv_record_finalize((uint64_t)v28);
    }
  }
  a1[13] = 0;
  v32 = *(_QWORD *)(v2 + 48);
  *(_QWORD *)(v32 + 8) = 0;
  *(_QWORD *)(v32 + 32) = v2;
  v33 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v34 = *(_DWORD *)v2;
    *(_DWORD *)buf = 136447490;
    *(_QWORD *)&buf[4] = "start_host_update";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v34;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v2;
    *(_WORD *)&buf[28] = 2080;
    *(_QWORD *)&buf[30] = "update";
    *(_WORD *)&buf[38] = 2080;
    *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3038;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v35 = *(_DWORD *)v2;
  if (*(_DWORD *)v2)
  {
    v36 = v35 + 1;
    *(_DWORD *)v2 = v35 + 1;
    if (v35 + 1 >= 10001)
    {
      v37 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_183;
      *(_DWORD *)buf = 136447490;
      *(_QWORD *)&buf[4] = "start_host_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v36;
      *(_WORD *)&buf[18] = 2048;
      *(_QWORD *)&buf[20] = v2;
      *(_WORD *)&buf[28] = 2080;
      *(_QWORD *)&buf[30] = "update";
      *(_WORD *)&buf[38] = 2080;
      *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3038;
      v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      v38 = v37;
      goto LABEL_182;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)v2 = 1;
  }
  if ((register_host_record((uint64_t)a1, *(_QWORD *)(v2 + 48), v4) & 1) == 0)
    goto LABEL_159;
  if (v4)
  {
LABEL_194:
    if (*(_DWORD *)(v2 + 96))
      goto LABEL_68;
  }
  else
  {
    v77 = *(_DWORD *)(v2 + 96) + 1;
    *(_DWORD *)(v2 + 96) = v77;
    if (v77)
      goto LABEL_68;
  }
  v78 = *(_QWORD *)(v2 + 48);
  if (!v78)
  {
    v78 = a1[13];
    if (!v78)
      goto LABEL_68;
  }
  v79 = *(_QWORD *)(v78 + 8);
  if (!v79)
  {
    if ((register_host_record((uint64_t)a1, v78, v4) & 1) == 0)
      goto LABEL_159;
    if (!v4)
      ++*(_DWORD *)(v2 + 96);
    goto LABEL_68;
  }
  if (v4)
    goto LABEL_68;
  v80 = *(_QWORD *)(v78 + 16);
  if (!v80)
  {
    v87 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_68;
    *(_DWORD *)buf = 136446722;
    *(_QWORD *)&buf[4] = "update_host_tsr";
    *(_WORD *)&buf[12] = 2048;
    *(_QWORD *)&buf[14] = 0;
    *(_WORD *)&buf[22] = 2048;
    *(_QWORD *)&buf[24] = v79;
    v88 = "%{public}s: record->host[%p], record->rref[%p] when we update host TSR.";
    v89 = v87;
    v90 = OS_LOG_TYPE_ERROR;
    v91 = 32;
    goto LABEL_172;
  }
  v81 = *(_QWORD *)(*(_QWORD *)(v80 + 8) + 16);
  if (!v81)
  {
    v93 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_68;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "update_host_tsr";
    v88 = "%{public}s: shared_txn is NULL when we update host TSR.";
LABEL_171:
    v89 = v93;
    v90 = OS_LOG_TYPE_ERROR;
    v91 = 12;
LABEL_172:
    _os_log_impl((void *)&_mh_execute_header, v89, v90, v88, buf, v91);
    goto LABEL_68;
  }
  if (!*(_QWORD *)(v81 + 8))
  {
    v93 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_68;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "update_host_tsr";
    v88 = "%{public}s: shared_txn->sdref is NULL when we update host TSR.";
    goto LABEL_171;
  }
  ++saref_created;
  v82 = malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (!v82)
    __break(1u);
  v83 = (uint64_t)v82;
  v84 = *(_QWORD *)(v2 + 16);
  if (v84 && (v85 = *(_QWORD *)(v84 + 32)) != 0 && *(_QWORD *)(v85 + 72))
  {
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
    v86 = *(_DWORD *)buf - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 16) + 32) + 72);
    srp_format_time_offset(v104, v86);
  }
  else
  {
    v86 = 0;
    *(_DWORD *)v104 = 7827310;
  }
  if (__isPlatformVersionAtLeast(2, 18, 0, 0))
  {
    v94 = *(_DWORD *)(*(_QWORD *)(v78 + 16) + 184);
    *(_BYTE *)(v83 + 12) = 1;
    *(_DWORD *)(v83 + 4) = v94;
  }
  *(_BYTE *)(v83 + 13) = 1;
  *(_DWORD *)(v83 + 8) = v86;
  updated = DNSServiceUpdateRecordInternal(*(_QWORD *)(v81 + 8), *(_QWORD *)(v78 + 8), 0, 0, v83);
  DNSServiceAttributeDeallocate((DNSServiceAttributeRef)v83);
  v96 = global_os_log;
  v97 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (updated)
  {
    if (!v97)
      goto LABEL_68;
    v98 = *(_QWORD *)(v78 + 8);
    *(_DWORD *)buf = 136446978;
    *(_QWORD *)&buf[4] = "update_host_tsr";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = updated;
    *(_WORD *)&buf[18] = 2048;
    *(_QWORD *)&buf[20] = v78;
    *(_WORD *)&buf[28] = 2048;
    *(_QWORD *)&buf[30] = v98;
    v88 = "%{public}s: DNSServiceUpdateRecordWithAttribute for host tsr failed: %d (record %p rref %p)";
    v89 = v96;
    v90 = OS_LOG_TYPE_DEFAULT;
    v91 = 38;
    goto LABEL_172;
  }
  if (v97)
  {
    v99 = *(_QWORD *)(v78 + 16);
    if (v99)
      v100 = *(const char **)(v99 + 56);
    else
      v100 = "<null>";
    v101 = *(_QWORD *)(v78 + 8);
    *(_DWORD *)buf = 136447491;
    *(_QWORD *)&buf[4] = "update_host_tsr";
    *(_WORD *)&buf[12] = 2160;
    *(_QWORD *)&buf[14] = 1752392040;
    *(_WORD *)&buf[22] = 2081;
    *(_QWORD *)&buf[24] = v100;
    *(_WORD *)&buf[32] = 2082;
    *(_QWORD *)&buf[34] = v104;
    *(_WORD *)&buf[42] = 2048;
    *(_QWORD *)&buf[44] = v78;
    *(_WORD *)&buf[52] = 2048;
    v103 = v101;
    v88 = "%{public}s: DNSServiceUpdateRecord TSR for %{private, mask.hash}s set to %{public}s (record %p rref %p)";
    v89 = v96;
    v90 = OS_LOG_TYPE_DEFAULT;
    v91 = 62;
    goto LABEL_172;
  }
LABEL_68:
  if (!a1[14])
    goto LABEL_134;
  v39 = *(_QWORD *)(v2 + 80);
  if (v39 && *(int *)(v39 + 4) >= 1)
  {
    v40 = 0;
    do
    {
      v41 = *(_DWORD **)(*(_QWORD *)(v39 + 8) + 8 * v40);
      if (v41)
      {
        if (!register_instance(v41))
          goto LABEL_159;
        v39 = *(_QWORD *)(v2 + 80);
      }
      ++v40;
    }
    while (v40 < *(int *)(v39 + 4));
  }
  v42 = *(_QWORD *)(v2 + 72);
  if (v42 && *(int *)(v42 + 4) >= 1)
  {
    for (j = 0; j < *(int *)(v42 + 4); ++j)
    {
      v44 = *(_QWORD *)(*(_QWORD *)(v42 + 8) + 8 * j);
      if (v44)
      {
        v45 = *(_QWORD *)(v44 + 8);
        if (!v45)
          goto LABEL_94;
        if (!*(_QWORD *)(v45 + 8))
          goto LABEL_92;
        v46 = *(_QWORD *)(v44 + 16);
        if (v46 != *(_QWORD *)(a1[1] + 16))
        {
          v47 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v48 = *(_QWORD *)(v44 + 48);
            *(_DWORD *)buf = 136447235;
            *(_QWORD *)&buf[4] = "start_host_update";
            *(_WORD *)&buf[12] = 2160;
            *(_QWORD *)&buf[14] = 1752392040;
            *(_WORD *)&buf[22] = 2081;
            *(_QWORD *)&buf[24] = v48;
            *(_WORD *)&buf[32] = 2048;
            *(_QWORD *)&buf[34] = v44;
            *(_WORD *)&buf[42] = 2048;
            *(_QWORD *)&buf[44] = v46;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%{public}s: instance %{private, mask.hash}s (%p) shared connection (%lx) is stale, re-registering", buf, 0x34u);
            v45 = *(_QWORD *)(v44 + 8);
          }
          *(_QWORD *)(v45 + 8) = 0;
          ioloop_dnssd_txn_cancel(v45);
          ioloop_dnssd_txn_release_(*(int **)(v44 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3114);
          *(_QWORD *)(v44 + 8) = 0;
          goto LABEL_94;
        }
        if (!update_instance_tsr(v44, 0))
        {
          v49 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v50 = *(_QWORD *)(v44 + 48);
            *(_DWORD *)buf = 136446979;
            *(_QWORD *)&buf[4] = "start_host_update";
            *(_WORD *)&buf[12] = 2160;
            *(_QWORD *)&buf[14] = 1752392040;
            *(_WORD *)&buf[22] = 2081;
            *(_QWORD *)&buf[24] = v50;
            *(_WORD *)&buf[32] = 2048;
            *(_QWORD *)&buf[34] = v44;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: instance %{private, mask.hash}s (%p) tsr update failed, re-registering", buf, 0x2Au);
          }
          v51 = *(_QWORD *)(v44 + 8);
          if (v51)
          {
            ioloop_dnssd_txn_cancel(v51);
            ioloop_dnssd_txn_release_(*(int **)(v44 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3114);
            *(_QWORD *)(v44 + 8) = 0;
          }
LABEL_92:
          v52 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v53 = *(_QWORD *)(v44 + 48);
            *(_DWORD *)buf = 136446979;
            *(_QWORD *)&buf[4] = "start_host_update";
            *(_WORD *)&buf[12] = 2160;
            *(_QWORD *)&buf[14] = 1752392040;
            *(_WORD *)&buf[22] = 2081;
            *(_QWORD *)&buf[24] = v53;
            *(_WORD *)&buf[32] = 2048;
            *(_QWORD *)&buf[34] = v44;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p): failed to update TSR, re-registering", buf, 0x2Au);
          }
LABEL_94:
          if ((register_instance(*(_DWORD **)(*(_QWORD *)(*(_QWORD *)(v2 + 72) + 8) + 8 * j)) & 1) == 0)
            goto LABEL_159;
          goto LABEL_95;
        }
        *(_QWORD *)(v44 + 96) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 32);
      }
LABEL_95:
      v42 = *(_QWORD *)(v2 + 72);
    }
  }
  v54 = *(_QWORD *)(v2 + 56);
  v55 = a1[14];
  if (v54)
  {
    v56 = *(_DWORD *)(v54 + 4);
    v57 = *(_DWORD *)(v55 + 4);
    if (v56 != v57)
    {
      v61 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_159;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "start_host_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v56;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v57;
      v62 = "%{public}s: update instance count %d differs from host instance count %d";
LABEL_104:
      v63 = v61;
      v64 = OS_LOG_TYPE_FAULT;
      v65 = 24;
      goto LABEL_105;
    }
  }
  v58 = *(_QWORD *)(v2 + 64);
  if (v58)
  {
    v59 = *(_DWORD *)(v58 + 4);
    v60 = *(_DWORD *)(v55 + 4);
    if (v59 != v60)
    {
      v61 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_159;
      *(_DWORD *)buf = 136446722;
      *(_QWORD *)&buf[4] = "start_host_update";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v59;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v60;
      v62 = "%{public}s: delete instance count %d differs from host instance count %d";
      goto LABEL_104;
    }
  }
  else
  {
    v59 = *(_DWORD *)(v55 + 4);
  }
  if (v59 < 1)
  {
LABEL_134:
    if (!*(_DWORD *)(v2 + 88) && !*(_DWORD *)(v2 + 96))
    {
      v76 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(_QWORD *)&buf[4] = "start_host_update";
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "%{public}s: no service or record updates, so we're finished.", buf, 0xCu);
      }
      srp_mdns_update_finished(v2);
    }
    return;
  }
  v66 = 0;
  while (1)
  {
    v67 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 56) + 8) + 8 * v66);
    if (!v67 || *(_BYTE *)(v67 + 116))
      goto LABEL_133;
    v68 = *(_QWORD *)(*(_QWORD *)(v55 + 8) + 8 * v66);
    v69 = *(_QWORD *)(v68 + 8);
    if (!v69)
      goto LABEL_132;
    if (!*(_QWORD *)(v69 + 8))
      goto LABEL_131;
    v70 = a1[1];
    if (!v70
      || *(_QWORD *)(v68 + 16) != *(_QWORD *)(v70 + 16)
      || *(_DWORD *)(v67 + 64) != *(_DWORD *)(v68 + 64)
      || !*(_WORD *)(v67 + 80)
      || !memcmp(*(const void **)(v67 + 72), *(const void **)(v68 + 72), *(unsigned __int16 *)(v67 + 80)))
    {
      goto LABEL_131;
    }
    if (!update_instance_tsr(v68, v67))
      break;
    *(_QWORD *)(v68 + 96) = *(_QWORD *)(*(_QWORD *)(v2 + 16) + 32);
    v71 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8);
    v72 = *(int **)(v71 + 8 * v66);
    if (v72)
    {
      v73 = *v72;
      if (!*v72)
      {
        v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_183;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "start_host_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v72;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->update_instances->vec[i]";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3165;
        v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_181;
      }
      v74 = global_os_log;
      if (v73 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_183;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "start_host_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v73;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v72;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->update_instances->vec[i]";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3165;
        v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v38 = v74;
LABEL_182:
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, v27, buf, 0x36u);
        goto LABEL_183;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "start_host_update";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v73;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = v72;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "update->update_instances->vec[i]";
        *(_WORD *)&buf[38] = 2080;
        *(_QWORD *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3165;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v71 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8);
        v72 = *(int **)(v71 + 8 * v66);
        v73 = *v72;
      }
      *v72 = v73 - 1;
      if (v73 == 1)
      {
        v75 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          *(_QWORD *)&buf[4] = "start_host_update";
          *(_WORD *)&buf[12] = 2048;
          *(_QWORD *)&buf[14] = v72;
          *(_WORD *)&buf[22] = 2080;
          *(_QWORD *)&buf[24] = "update->update_instances->vec[i]";
          *(_WORD *)&buf[32] = 2080;
          *(_QWORD *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 3165;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v72 = *(int **)(*(_QWORD *)(*(_QWORD *)(v2 + 56) + 8) + 8 * v66);
        }
        ++adv_instance_finalized;
        adv_instance_finalize(v72);
        v71 = *(_QWORD *)(*(_QWORD *)(v2 + 56) + 8);
      }
    }
    *(_QWORD *)(v71 + 8 * v66) = 0;
LABEL_133:
    ++v66;
    v55 = a1[14];
    if (v66 >= *(int *)(v55 + 4))
      goto LABEL_134;
  }
  if (*(_QWORD *)(v68 + 8))
  {
    v69 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[14] + 8) + 8 * v66) + 8);
LABEL_131:
    ioloop_dnssd_txn_cancel(v69);
    ioloop_dnssd_txn_release_(*(int **)(*(_QWORD *)(*(_QWORD *)(a1[14] + 8) + 8 * v66) + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3175);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[14] + 8) + 8 * v66) + 8) = 0;
  }
LABEL_132:
  if ((register_instance(*(_DWORD **)(*(_QWORD *)(*(_QWORD *)(v2 + 56) + 8) + 8 * v66)) & 1) != 0)
    goto LABEL_133;
  v92 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "start_host_update";
    v62 = "%{public}s: register instance failed.";
    v63 = v92;
    v64 = OS_LOG_TYPE_DEFAULT;
    v65 = 12;
LABEL_105:
    _os_log_impl((void *)&_mh_execute_header, v63, v64, v62, buf, v65);
  }
LABEL_159:
  update_failed(v2, 2u, 1);
}

uint64_t register_host_record(uint64_t a1, uint64_t a2, int a3)
{
  DNSRecordRef *v6;
  uint64_t v7;
  _DNSServiceRef_t *v8;
  int v9;
  uint64_t v10;
  int v11;
  const char *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  const char *v16;
  NSObject *v17;
  uint32_t v18;
  _BOOL8 v19;
  uint64_t v20;
  const char *v21;
  int v22;
  uint64_t v23;
  int v24;
  unsigned __int8 *v25;
  int v26;
  const char *v27;
  uint64_t v28;
  int v29;
  const char *v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  DNSServiceAttribute *v37;
  DNSServiceErrorType v38;
  NSObject *v40;
  uint64_t v41;
  const char *v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  int v48;
  NSObject *v49;
  NSObject *v50;
  NSObject *v52;
  DNSServiceAttributeRef v53[4];
  uint8_t buf[4];
  const char *v55;
  __int16 v56;
  _BYTE v57[40];
  _BYTE v58[10];
  __int16 v59;
  int v60;
  __int16 v61;
  int v62;
  __int16 v63;
  int v64;
  __int16 v65;
  uint64_t v66;
  __int16 v67;
  _BYTE v68[14];
  __int16 v69;
  _BYTE v70[24];
  __int16 v71;
  unsigned __int8 *v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  int v76;
  __int16 v77;
  unsigned __int8 *v78;
  __int16 v79;
  int v80;
  __int16 v81;
  void (*v82)(uint64_t, uint64_t, uint64_t, int, uint64_t);
  __int16 v83;
  uint64_t v84;

  v6 = (DNSRecordRef *)(a2 + 8);
  if (*(_QWORD *)(a2 + 8) && (a3 & 1) == 0)
    srp_mdns_shared_record_remove(*(_QWORD *)(a1 + 8), a2);
  if (!srp_mdns_shared_registration_txn_setup(*(_QWORD *)(a1 + 8)))
    return 0;
  v7 = *(_QWORD *)(a1 + 8);
  v8 = *(_DNSServiceRef_t **)(*(_QWORD *)(v7 + 16) + 8);
  v9 = *(unsigned __int16 *)(a2 + 48);
  if (v9 == 28)
  {
    v20 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_30;
    if (a3)
      v21 = "skipping ";
    else
      v21 = (const char *)&unk_10007C3B5;
    v22 = *(_DWORD *)(v7 + 248);
    v23 = *(_QWORD *)(a1 + 64);
    v24 = *(unsigned __int16 *)(a2 + 50);
    v25 = *(unsigned __int8 **)(a2 + 40);
    v26 = *v25;
    if ((v26 & 0xFE) == 0xFC)
    {
      v27 = "ULA: ";
    }
    else if (v26 == 254 && (v25[1] & 0xC0) == 0x80)
    {
      v27 = "LUA: ";
    }
    else if ((v26 & 0xE0) == 0x20)
    {
      v27 = "GUA: ";
    }
    else
    {
      v27 = (const char *)&unk_10007C3B5;
    }
    *(_DWORD *)buf = 136451843;
    v55 = "register_host_record";
    v56 = 2082;
    *(_QWORD *)v57 = v21;
    *(_WORD *)&v57[8] = 2048;
    *(_QWORD *)&v57[10] = v8;
    *(_WORD *)&v57[18] = 2048;
    *(_QWORD *)&v57[20] = v6;
    *(_WORD *)&v57[28] = 1024;
    *(_DWORD *)&v57[30] = 16;
    *(_WORD *)&v57[34] = 1024;
    *(_DWORD *)&v57[36] = v22;
    *(_WORD *)v58 = 2080;
    *(_QWORD *)&v58[2] = v23;
    v59 = 1024;
    v60 = 28;
    v61 = 1024;
    v62 = 1;
    v63 = 1024;
    v64 = v24;
    v65 = 2082;
    v66 = (uint64_t)v27;
    v67 = 2160;
    *(_QWORD *)v68 = 1752392040;
    *(_WORD *)&v68[8] = 1041;
    *(_DWORD *)&v68[10] = 6;
    v69 = 2097;
    *(_QWORD *)v70 = v25;
    *(_WORD *)&v70[8] = 2160;
    *(_QWORD *)&v70[10] = 1752392040;
    *(_WORD *)&v70[18] = 1042;
    *(_DWORD *)&v70[20] = 2;
    v71 = 2098;
    v72 = v25 + 6;
    v73 = 2160;
    v74 = 1752392040;
    v75 = 1041;
    v76 = 8;
    v77 = 2097;
    v78 = v25 + 8;
    v79 = 1024;
    v80 = 4500;
    v81 = 2048;
    v82 = register_host_record_completion;
    v83 = 2048;
    v84 = a2;
    v16 = "%{public}s: %{public}sDNSServiceRegisterRecord(%p %p %d %d %s %d %d %d {%{public}s%{private, mask.hash, srp:in"
          "6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} %d %p %p)";
    v17 = v20;
    v18 = 196;
  }
  else if (v9 == 1)
  {
    v10 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_30;
    v11 = *(_DWORD *)(v7 + 248);
    v12 = (const char *)&unk_10007C3B5;
    v13 = *(_QWORD *)(a1 + 64);
    v14 = *(unsigned __int16 *)(a2 + 50);
    if (a3)
      v12 = "skipping ";
    v15 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)buf = 136450051;
    v55 = "register_host_record";
    v56 = 2082;
    *(_QWORD *)v57 = v12;
    *(_WORD *)&v57[8] = 2048;
    *(_QWORD *)&v57[10] = v8;
    *(_WORD *)&v57[18] = 2048;
    *(_QWORD *)&v57[20] = v6;
    *(_WORD *)&v57[28] = 1024;
    *(_DWORD *)&v57[30] = 16;
    *(_WORD *)&v57[34] = 1024;
    *(_DWORD *)&v57[36] = v11;
    *(_WORD *)v58 = 2080;
    *(_QWORD *)&v58[2] = v13;
    v59 = 1024;
    v60 = 1;
    v61 = 1024;
    v62 = 1;
    v63 = 1024;
    v64 = v14;
    v65 = 2160;
    v66 = 1752392040;
    v67 = 1041;
    *(_DWORD *)v68 = 4;
    *(_WORD *)&v68[4] = 2097;
    *(_QWORD *)&v68[6] = v15;
    v69 = 1024;
    *(_DWORD *)v70 = 4500;
    *(_WORD *)&v70[4] = 2048;
    *(_QWORD *)&v70[6] = register_host_record_completion;
    *(_WORD *)&v70[14] = 2048;
    *(_QWORD *)&v70[16] = a2;
    v16 = "%{public}s: %{public}sDNSServiceRegisterRecord(%p %p %d %d %s %d %d %d %{private, mask.hash, network:in_addr}.4P %d %p %p)";
    v17 = v10;
    v18 = 134;
  }
  else
  {
    v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_30;
    v29 = *(_DWORD *)(v7 + 248);
    v30 = (const char *)&unk_10007C3B5;
    v31 = *(_QWORD *)(a1 + 64);
    v32 = *(unsigned __int16 *)(a2 + 50);
    if (a3)
      v30 = "skipping ";
    v33 = *(_QWORD *)(a2 + 40);
    *(_DWORD *)buf = 136449538;
    v55 = "register_host_record";
    v56 = 2082;
    *(_QWORD *)v57 = v30;
    *(_WORD *)&v57[8] = 2048;
    *(_QWORD *)&v57[10] = v8;
    *(_WORD *)&v57[18] = 2048;
    *(_QWORD *)&v57[20] = v6;
    *(_WORD *)&v57[28] = 1024;
    *(_DWORD *)&v57[30] = 16;
    *(_WORD *)&v57[34] = 1024;
    *(_DWORD *)&v57[36] = v29;
    *(_WORD *)v58 = 2080;
    *(_QWORD *)&v58[2] = v31;
    v59 = 1024;
    v60 = v9;
    v61 = 1024;
    v62 = 1;
    v63 = 1024;
    v64 = v32;
    v65 = 2048;
    v66 = v33;
    v67 = 1024;
    *(_DWORD *)v68 = 4500;
    *(_WORD *)&v68[4] = 2048;
    *(_QWORD *)&v68[6] = register_host_record_completion;
    v69 = 2048;
    *(_QWORD *)v70 = a2;
    v16 = "%{public}s: %{public}sDNSServiceRegisterRecord(%p %p %d %d %s %d %d %d %p %d %p %p)";
    v17 = v28;
    v18 = 118;
  }
  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
LABEL_30:
  if ((a3 & 1) != 0)
    return 1;
  v34 = *(_QWORD *)(a1 + 48);
  if (v34)
  {
    v35 = *(_QWORD *)(v34 + 16);
    if (!v35 || (v36 = *(_QWORD *)(v35 + 32)) == 0)
      v36 = 0;
  }
  else
  {
    v36 = *(_QWORD *)(a1 + 72);
  }
  v37 = (DNSServiceAttribute *)srp_message_tsr_attribute_generate(v36, *(_DWORD *)(a1 + 184), (char *)v53 + 4);
  v38 = DNSServiceRegisterRecordWithAttribute(v8, v6, *(_DWORD *)(*(_QWORD *)(a1 + 8) + 248), *(_QWORD *)(a1 + 64), (const char *)*(unsigned __int16 *)(a2 + 48), *(_WORD *)(a2 + 50), *(_QWORD *)(a2 + 40), (uint16_t)v37, register_host_record_completion, a2, v53[0], (DNSServiceRegisterRecordReply)v53[1], v53[2]);
  DNSServiceAttributeDeallocate(v37);
  v19 = v38 == 0;
  if (v38)
  {
    if ((v38 + 65569) <= 0x1D && ((1 << (v38 + 33)) & 0x30000041) != 0)
    {
LABEL_42:
      v40 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v41 = *(_QWORD *)(a1 + 56);
        v42 = "defunct";
        *(_DWORD *)buf = 136446978;
        v55 = "register_host_record";
        v56 = 2082;
        if (v38 == -65563)
          v42 = "not running";
        *(_QWORD *)v57 = v41;
        *(_WORD *)&v57[8] = 2082;
        *(_QWORD *)&v57[10] = v42;
        *(_WORD *)&v57[18] = 2048;
        *(_QWORD *)&v57[20] = a2;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord failed on host %{public}s: %{public}s (record %p)", buf, 0x2Au);
      }
      service_disconnected(*(_QWORD *)(a1 + 8), *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16));
      return v19;
    }
    if (v38 == 1)
    {
      v50 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136446210;
        v55 = "register_host_record";
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, "%{public}s: bogus error code 1", buf, 0xCu);
      }
      goto LABEL_42;
    }
    v52 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      v55 = "register_host_record";
      v56 = 1024;
      *(_DWORD *)v57 = v38;
      *(_WORD *)&v57[4] = 2048;
      *(_QWORD *)&v57[6] = a2;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord failed: %d (record %p)", buf, 0x1Cu);
    }
  }
  else
  {
    v43 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v44 = *(_QWORD *)(a1 + 56);
      v45 = *(_QWORD *)(a2 + 8);
      *(_DWORD *)buf = 136447491;
      v55 = "register_host_record";
      v56 = 2160;
      *(_QWORD *)v57 = 1752392040;
      *(_WORD *)&v57[8] = 2081;
      *(_QWORD *)&v57[10] = v44;
      *(_WORD *)&v57[18] = 2082;
      *(_QWORD *)&v57[20] = (char *)v53 + 4;
      *(_WORD *)&v57[28] = 2048;
      *(_QWORD *)&v57[30] = a2;
      *(_WORD *)&v57[38] = 2048;
      *(_QWORD *)v58 = v45;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord for %{private, mask.hash}s, TSR set to %{public}s (record %p rref %p)", buf, 0x3Eu);
      v43 = global_os_log;
    }
    *(_QWORD *)(a2 + 24) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 16);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      v46 = *(_DWORD *)a2;
      *(_DWORD *)buf = 136447490;
      v55 = "register_host_record";
      v56 = 1024;
      *(_DWORD *)v57 = v46;
      *(_WORD *)&v57[4] = 2048;
      *(_QWORD *)&v57[6] = a2;
      *(_WORD *)&v57[14] = 2080;
      *(_QWORD *)&v57[16] = "record";
      *(_WORD *)&v57[24] = 2080;
      *(_QWORD *)&v57[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v57[34] = 1024;
      *(_DWORD *)&v57[36] = 2793;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v47 = *(_DWORD *)a2;
    if (*(_DWORD *)a2)
    {
      v48 = v47 + 1;
      *(_DWORD *)a2 = v47 + 1;
      if (v47 + 1 >= 10001)
      {
        v49 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v55 = "register_host_record";
          v56 = 1024;
          *(_DWORD *)v57 = v48;
          *(_WORD *)&v57[4] = 2048;
          *(_QWORD *)&v57[6] = a2;
          *(_WORD *)&v57[14] = 2080;
          *(_QWORD *)&v57[16] = "record";
          *(_WORD *)&v57[24] = 2080;
          *(_QWORD *)&v57[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v57[34] = 1024;
          *(_DWORD *)&v57[36] = 2793;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++adv_record_created;
      *(_DWORD *)a2 = 1;
    }
    if (*(_QWORD *)(a1 + 48))
      *(_BYTE *)(a2 + 52) = 1;
  }
  return v19;
}

uint64_t register_instance(_DWORD *a1)
{
  uint64_t v2;
  uint64_t result;
  _DNSServiceRef_t *v4;
  NSObject *v5;
  uint64_t v6;
  _DWORD *v7;
  const char *v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  DNSServiceAttribute *v15;
  DNSServiceFlags v16;
  DNSServiceErrorType v17;
  NSObject *v19;
  const char *v20;
  NSObject *v21;
  uint64_t v22;
  const char *v23;
  uint64_t v24;
  _QWORD *v25;
  NSObject *v26;
  int v27;
  int v28;
  int v29;
  NSObject *v30;
  NSObject *v31;
  uint64_t v32;
  const char *v33;
  NSObject *v34;
  os_log_type_t v35;
  uint32_t v36;
  uint64_t v37;
  _BOOL4 v38;
  DNSServiceRef sdRef;
  char v40[28];
  uint8_t buf[4];
  const char *v42;
  __int16 v43;
  _BYTE v44[40];
  uint64_t v45;
  __int16 v46;
  _DWORD *v47;
  __int16 v48;
  uint64_t v49;
  __int16 v50;
  uint64_t v51;
  __int16 v52;
  int v53;
  __int16 v54;
  _DWORD *v55;

  v2 = *(_QWORD *)(*((_QWORD *)a1 + 3) + 8);
  result = srp_mdns_shared_registration_txn_setup(v2);
  if ((_DWORD)result)
  {
    v4 = *(_DNSServiceRef_t **)(*(_QWORD *)(v2 + 16) + 8);
    sdRef = v4;
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *((_QWORD *)a1 + 6);
      v7 = (_DWORD *)*((_QWORD *)a1 + 7);
      if (*((_BYTE *)a1 + 119))
        v8 = "skipping ";
      else
        v8 = (const char *)&unk_10007C3B5;
      v9 = *(_QWORD *)(*((_QWORD *)a1 + 3) + 64);
      v10 = a1[16];
      *(_DWORD *)buf = 136448771;
      v42 = "register_instance";
      v43 = 2082;
      *(_QWORD *)v44 = v8;
      *(_WORD *)&v44[8] = 2048;
      *(_QWORD *)&v44[10] = v4;
      *(_WORD *)&v44[18] = 2160;
      *(_QWORD *)&v44[20] = 1752392040;
      *(_WORD *)&v44[28] = 2081;
      *(_QWORD *)&v44[30] = v6;
      *(_WORD *)&v44[38] = 2160;
      v45 = 1752392040;
      v46 = 2081;
      v47 = v7;
      v48 = 2160;
      v49 = 1752392040;
      v50 = 2081;
      v51 = v9;
      v52 = 1024;
      v53 = v10;
      v54 = 2048;
      v55 = a1;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}sDNSServiceRegister(%p, %{private, mask.hash}s, %{private, mask.hash}s, %{private, mask.hash}s, %d, %p)", buf, 0x6Cu);
    }
    v11 = *((_QWORD *)a1 + 4);
    if (*((_BYTE *)a1 + 119))
    {
      v12 = *(_QWORD *)(v11 + 16);
      if (v12)
        *((_QWORD *)a1 + 12) = *(_QWORD *)(v12 + 32);
      return 1;
    }
    if (v11)
    {
      v13 = *(_QWORD *)(v11 + 16);
      if (!v13 || (v14 = *(_QWORD *)(v13 + 32)) == 0)
        v14 = 0;
    }
    else
    {
      v14 = *((_QWORD *)a1 + 11);
    }
    v15 = (DNSServiceAttribute *)srp_message_tsr_attribute_generate(v14, *(_DWORD *)(*((_QWORD *)a1 + 3) + 184), v40);
    if (__isPlatformVersionAtLeast(2, 18, 0, 0))
      v16 = 18440;
    else
      v16 = 16392;
    v17 = DNSServiceRegisterWithAttribute(&sdRef, v16, *(_DWORD *)(v2 + 248), *((const char **)a1 + 6), *((const char **)a1 + 7), "local", *(const char **)(*((_QWORD *)a1 + 3) + 64), bswap32(*((unsigned __int16 *)a1 + 32)) >> 16, *((_WORD *)a1 + 40), *((const void **)a1 + 9), v15, (DNSServiceRegisterReply)register_instance_completion, a1);
    DNSServiceAttributeDeallocate(v15);
    if (v17)
    {
      if ((v17 + 65569) <= 0x1D && ((1 << (v17 + 33)) & 0x30000041) != 0)
      {
LABEL_24:
        v19 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v20 = "defunct";
          v42 = "register_instance";
          *(_DWORD *)buf = 136446722;
          if (v17 == -65563)
            v20 = "not running";
          v43 = 2082;
          *(_QWORD *)v44 = v20;
          *(_WORD *)&v44[8] = 2048;
          *(_QWORD *)&v44[10] = a1;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister failed: %{public}s (instance %p)", buf, 0x20u);
        }
        service_disconnected(v2, *(_QWORD *)(v2 + 16));
        return 0;
      }
      if (v17 == 1)
      {
        v31 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446210;
          v42 = "register_instance";
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "%{public}s: bogus error code 1", buf, 0xCu);
        }
        goto LABEL_24;
      }
      v37 = global_os_log;
      v38 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (v38)
      {
        *(_DWORD *)buf = 136446722;
        v42 = "register_instance";
        v43 = 1024;
        *(_DWORD *)v44 = v17;
        *(_WORD *)&v44[4] = 2048;
        *(_QWORD *)&v44[6] = a1;
        v33 = "%{public}s: DNSServiceRegister failed: %d (instance %p)";
        v34 = v37;
        v35 = OS_LOG_TYPE_DEFAULT;
        v36 = 28;
        goto LABEL_52;
      }
    }
    else
    {
      v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v22 = *((_QWORD *)a1 + 6);
        v23 = *(const char **)(*((_QWORD *)a1 + 3) + 56);
        if (!v23)
          v23 = "<null>";
        *(_DWORD *)buf = 136448003;
        v42 = "register_instance";
        v43 = 2160;
        *(_QWORD *)v44 = 1752392040;
        *(_WORD *)&v44[8] = 2081;
        *(_QWORD *)&v44[10] = v22;
        *(_WORD *)&v44[18] = 2160;
        *(_QWORD *)&v44[20] = 1752392040;
        *(_WORD *)&v44[28] = 2081;
        *(_QWORD *)&v44[30] = v23;
        *(_WORD *)&v44[38] = 2082;
        v45 = (uint64_t)v40;
        v46 = 2048;
        v47 = a1;
        v48 = 2048;
        v49 = (uint64_t)sdRef;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister, TSR for instance %{private, mask.hash}s host %{private, mask.hash}s set to %{public}s(instance %p sdref %p)", buf, 0x52u);
      }
      v24 = *((_QWORD *)a1 + 4);
      if (v24)
      {
        ++*(_DWORD *)(v24 + 88);
        *((_BYTE *)a1 + 117) = 1;
      }
      v25 = ioloop_dnssd_txn_add_subordinate_((uint64_t)sdRef, (uint64_t)a1, (uint64_t)adv_instance_context_release, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2314);
      *((_QWORD *)a1 + 1) = v25;
      if (v25)
      {
        *((_QWORD *)a1 + 2) = *(_QWORD *)(v2 + 16);
        v26 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v27 = *a1;
          *(_DWORD *)buf = 136447490;
          v42 = "register_instance";
          v43 = 1024;
          *(_DWORD *)v44 = v27;
          *(_WORD *)&v44[4] = 2048;
          *(_QWORD *)&v44[6] = a1;
          *(_WORD *)&v44[14] = 2080;
          *(_QWORD *)&v44[16] = "instance";
          *(_WORD *)&v44[24] = 2080;
          *(_QWORD *)&v44[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v44[34] = 1024;
          *(_DWORD *)&v44[36] = 2320;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        v28 = *a1;
        if (*a1)
        {
          v29 = v28 + 1;
          *a1 = v28 + 1;
          if (v28 + 1 >= 10001)
          {
            v30 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v42 = "register_instance";
              v43 = 1024;
              *(_DWORD *)v44 = v29;
              *(_WORD *)&v44[4] = 2048;
              *(_QWORD *)&v44[6] = a1;
              *(_WORD *)&v44[14] = 2080;
              *(_QWORD *)&v44[16] = "instance";
              *(_WORD *)&v44[24] = 2080;
              *(_QWORD *)&v44[26] = "srp-mdns-proxy.c";
              *(_WORD *)&v44[34] = 1024;
              *(_DWORD *)&v44[36] = 2320;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            }
            abort();
          }
        }
        else
        {
          ++adv_instance_created;
          *a1 = 1;
        }
        return 1;
      }
      v32 = global_os_log;
      result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
      if ((_DWORD)result)
      {
        *(_DWORD *)buf = 136446210;
        v42 = "register_instance";
        v33 = "%{public}s: no memory for instance transaction.";
        v34 = v32;
        v35 = OS_LOG_TYPE_ERROR;
        v36 = 12;
LABEL_52:
        _os_log_impl((void *)&_mh_execute_header, v34, v35, v33, buf, v36);
        return 0;
      }
    }
  }
  return result;
}

BOOL update_instance_tsr(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  NSObject *v6;
  const char *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  const char *v11;
  NSObject *v12;
  _BOOL8 result;
  const char *v14;
  int updated;
  uint64_t v16;
  NSObject *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  NSObject *v25;
  _BOOL4 v26;
  const char *v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  int v32;
  uint64_t v33;
  const char *v34;
  uint64_t v35;
  const char *v36;
  uint64_t v37;
  char v38[28];
  _BYTE buf[22];
  __int16 v40;
  const char *v41;
  __int16 v42;
  _BYTE v43[28];
  __int16 v44;
  uint64_t v45;

  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
  {
    v12 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result)
      return result;
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "update_instance_tsr";
    v14 = "%{public}s: txn is NULL updating instance TSR.";
    goto LABEL_15;
  }
  v4 = *(_QWORD *)(v3 + 8);
  if (!v4)
  {
    v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
LABEL_16:
      updated = 0;
      goto LABEL_17;
    }
    *(_DWORD *)buf = 136446210;
    *(_QWORD *)&buf[4] = "update_instance_tsr";
    v14 = "%{public}s: sdref is NULL when updating instance TSR.";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
    goto LABEL_16;
  }
  if (!a2)
    goto LABEL_7;
  if (*(_BYTE *)(a1 + 119)
    || (v32 = DNSServiceUpdateRecordInternal(v4, 0, *(unsigned __int16 *)(a2 + 80), *(const void **)(a2 + 72), 0)) == 0)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(const char **)(a1 + 48);
      v8 = *(_QWORD *)(a1 + 56);
      v9 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
      *(_DWORD *)buf = 136447747;
      *(_QWORD *)&buf[4] = "update_instance_tsr";
      *(_WORD *)&buf[12] = 2160;
      *(_QWORD *)&buf[14] = 1752392040;
      v40 = 2081;
      v41 = v7;
      v42 = 2160;
      *(_QWORD *)v43 = 1752392040;
      *(_WORD *)&v43[8] = 2081;
      *(_QWORD *)&v43[10] = v8;
      *(_WORD *)&v43[18] = 2048;
      *(_QWORD *)&v43[20] = a1;
      v44 = 2048;
      v45 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: updated TXT record for %{private, mask.hash}s . %{private, mask.hash}s (instance %p sdref %p).", buf, 0x48u);
    }
LABEL_7:
    if (*(_BYTE *)(a1 + 119))
    {
      v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v11 = *(const char **)(a1 + 48);
        *(_DWORD *)buf = 136446979;
        *(_QWORD *)&buf[4] = "update_instance_tsr";
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        v40 = 2081;
        v41 = v11;
        v42 = 2048;
        *(_QWORD *)v43 = a1;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: skipping DNSServiceUpdateRecord for instance %{private, mask.hash}s TSR (instance %p)", buf, 0x2Au);
        if (!a2)
          goto LABEL_16;
      }
      else if (!a2)
      {
        goto LABEL_16;
      }
    }
    else
    {
      ++saref_created;
      v18 = malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
      if (!v18)
        __break(1u);
      v19 = (uint64_t)v18;
      v20 = *(_QWORD *)(a1 + 32);
      if (v20 && (v21 = *(_QWORD *)(v20 + 16)) != 0 && (v22 = *(_QWORD *)(v21 + 32)) != 0 && *(_QWORD *)(v22 + 72))
      {
        *(_QWORD *)buf = 0;
        *(_QWORD *)&buf[8] = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
        v23 = *(_DWORD *)buf - *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) + 32) + 72);
        srp_format_time_offset(v38, v23);
      }
      else
      {
        v23 = 0;
        *(_DWORD *)v38 = 7827310;
      }
      if (__isPlatformVersionAtLeast(2, 18, 0, 0))
      {
        v24 = *(_DWORD *)(*(_QWORD *)(a1 + 24) + 184);
        *(_BYTE *)(v19 + 12) = 1;
        *(_DWORD *)(v19 + 4) = v24;
      }
      *(_BYTE *)(v19 + 13) = 1;
      *(_DWORD *)(v19 + 8) = v23;
      updated = DNSServiceUpdateRecordInternal(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8), 0, 0, 0, v19);
      DNSServiceAttributeDeallocate((DNSServiceAttributeRef)v19);
      v25 = global_os_log;
      v26 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      if (updated)
      {
        if (!v26)
          goto LABEL_17;
        v27 = *(const char **)(a1 + 48);
        v28 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
        *(_DWORD *)buf = 136447491;
        *(_QWORD *)&buf[4] = "update_instance_tsr";
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        v40 = 2081;
        v41 = v27;
        v42 = 1024;
        *(_DWORD *)v43 = updated;
        *(_WORD *)&v43[4] = 2048;
        *(_QWORD *)&v43[6] = a1;
        *(_WORD *)&v43[14] = 2048;
        *(_QWORD *)&v43[16] = v28;
        v29 = "%{public}s: DNSServiceUpdateRecord for instance %{private, mask.hash}s, TSR failed: %d (instance %p sdref %p)";
        v30 = v25;
        v31 = 58;
        goto LABEL_40;
      }
      if (v26)
      {
        v35 = *(_QWORD *)(a1 + 24);
        if (v35)
          v36 = *(const char **)(v35 + 56);
        else
          v36 = "<null>";
        v37 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
        *(_DWORD *)buf = 136447491;
        *(_QWORD *)&buf[4] = "update_instance_tsr";
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        v40 = 2081;
        v41 = v36;
        v42 = 2082;
        *(_QWORD *)v43 = v38;
        *(_WORD *)&v43[8] = 2048;
        *(_QWORD *)&v43[10] = a1;
        *(_WORD *)&v43[18] = 2048;
        *(_QWORD *)&v43[20] = v37;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceUpdateRecord for %{private, mask.hash}s, TSR set to %{public}s (instance %p sdref %p)", buf, 0x3Eu);
      }
      if (!a2)
        return 1;
    }
    free(*(void **)(a1 + 72));
    *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 72);
    *(_WORD *)(a1 + 80) = *(_WORD *)(a2 + 80);
    *(_QWORD *)(a2 + 72) = 0;
    *(_WORD *)(a2 + 80) = 0;
    return 1;
  }
  updated = v32;
  v33 = global_os_log;
  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    goto LABEL_17;
  v34 = *(const char **)(a1 + 48);
  *(_DWORD *)buf = 136447235;
  *(_QWORD *)&buf[4] = "update_instance_tsr";
  *(_WORD *)&buf[12] = 2160;
  *(_QWORD *)&buf[14] = 1752392040;
  v40 = 2081;
  v41 = v34;
  v42 = 1024;
  *(_DWORD *)v43 = updated;
  *(_WORD *)&v43[4] = 2048;
  *(_QWORD *)&v43[6] = a1;
  v29 = "%{public}s: DNSServiceUpdateRecord for instance %{private, mask.hash}s TXT record failed: %d (instance %p)";
  v30 = v33;
  v31 = 48;
LABEL_40:
  _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
LABEL_17:
  v16 = *(_QWORD *)(a1 + 8);
  if (!v16)
    return 0;
  if ((updated + 65541) <= 1)
  {
    v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "update_instance_tsr";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%{public}s: we got a bad reference error: why?", buf, 0xCu);
      v16 = *(_QWORD *)(a1 + 8);
    }
  }
  ioloop_dnssd_txn_cancel(v16);
  ioloop_dnssd_txn_release_(*(int **)(a1 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2885);
  result = 0;
  *(_QWORD *)(a1 + 8) = 0;
  return result;
}

size_t srp_format_time_offset(char *a1, uint64_t a2)
{
  time_t v4;
  tm v5;

  memset(&v5, 0, sizeof(v5));
  v4 = time(0) - a2;
  localtime_r(&v4, &v5);
  return strftime(a1, 0x1CuLL, "%F %T", &v5);
}

void register_instance_completion(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v12;
  uint64_t *v13;
  NSObject *v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  NSObject *v19;
  _BOOL4 v20;
  int *v21;
  int v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  NSObject *v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  const char *v32;
  int *v33;
  int v34;
  NSObject *v35;
  NSObject *v36;
  NSObject *v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  NSObject *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  NSObject *v50;
  int *v51;
  int v52;
  unsigned int v53;
  uint32_t v54;
  unsigned int v55;
  NSObject *v56;
  int v57;
  int v58;
  int v59;
  unsigned int v60;
  uint64_t v61;
  const char *v62;
  NSObject *v63;
  os_log_type_t v64;
  uint32_t v65;
  uint64_t v66;
  int v67;
  int v68;
  int v69;
  NSObject *v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  NSObject *v74;
  os_log_type_t v75;
  uint32_t v76;
  uint64_t v77;
  int v78;
  int *v79;
  int v80;
  NSObject *v81;
  NSObject *v82;
  int v83;
  NSObject *v84;
  uint64_t v85;
  NSObject *v86;
  uint64_t v87;
  uint8_t buf[4];
  const char *v89;
  __int16 v90;
  _BYTE v91[40];
  uint64_t v92;
  __int16 v93;
  uint64_t v94;
  __int16 v95;
  uint64_t v96;
  __int16 v97;
  uint64_t v98;
  __int16 v99;
  const char *v100;

  v13 = *(uint64_t **)(a7 + 24);
  v12 = *(_QWORD *)(a7 + 32);
  v14 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v15 = *(_DWORD *)a7;
    *(_DWORD *)buf = 136447490;
    v89 = "register_instance_completion";
    v90 = 1024;
    *(_DWORD *)v91 = v15;
    *(_WORD *)&v91[4] = 2048;
    *(_QWORD *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(_QWORD *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2034;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v16 = *(_DWORD *)a7;
  if (!*(_DWORD *)a7)
  {
    ++adv_instance_created;
    *(_DWORD *)a7 = 1;
    if (v12)
      goto LABEL_6;
LABEL_26:
    if (a3)
      goto LABEL_45;
LABEL_46:
    v37 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v38 = *(_QWORD *)(a7 + 48);
      v39 = *(_QWORD *)(a7 + 56);
      v40 = " with a conflict";
      v41 = v13[8];
      if (!a3)
        v40 = ":";
      *(_DWORD *)buf = 136448515;
      v89 = "register_instance_completion";
      v90 = 2160;
      *(_QWORD *)v91 = 1752392040;
      *(_WORD *)&v91[8] = 2081;
      *(_QWORD *)&v91[10] = v38;
      *(_WORD *)&v91[18] = 2160;
      *(_QWORD *)&v91[20] = 1752392040;
      *(_WORD *)&v91[28] = 2081;
      *(_QWORD *)&v91[30] = v39;
      *(_WORD *)&v91[38] = 2160;
      v92 = 1752392040;
      v93 = 2081;
      v94 = a6;
      v95 = 2160;
      v96 = 1752392040;
      v97 = 2081;
      v98 = v41;
      v99 = 2082;
      v100 = v40;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for service %{private, mask.hash}s.%{private, mask.hash}s.%{private, mask.hash}s -> %{private, mask.hash}s has completed%{public}s.", buf, 0x66u);
      v37 = global_os_log;
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447747;
      v89 = "register_instance_completion";
      v90 = 2160;
      *(_QWORD *)v91 = 1752392040;
      *(_WORD *)&v91[8] = 2081;
      *(_QWORD *)&v91[10] = a4;
      *(_WORD *)&v91[18] = 2160;
      *(_QWORD *)&v91[20] = 1752392040;
      *(_WORD *)&v91[28] = 2081;
      *(_QWORD *)&v91[30] = a5;
      *(_WORD *)&v91[38] = 2160;
      v92 = 1752392040;
      v93 = 2081;
      v94 = a6;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: registration is under %{private, mask.hash}s.%{private, mask.hash}s%{private, mask.hash}s", buf, 0x48u);
    }
    if (!a3)
      goto LABEL_79;
    v87 = a6;
    v42 = a4;
    v43 = *(_QWORD *)(a7 + 8);
    if (v43)
    {
      v44 = a5;
      ioloop_dnssd_txn_cancel(v43);
      ioloop_dnssd_txn_release_(*(int **)(a7 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2068);
      *(_QWORD *)(a7 + 8) = 0;
    }
    else
    {
      v44 = a5;
      v50 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136446466;
        v89 = "register_instance_completion";
        v90 = 2048;
        *(_QWORD *)v91 = a7;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, "%{public}s: instance->txn is NULL for instance %p!", buf, 0x16u);
      }
    }
    if (*(_QWORD *)(a7 + 40)
      || (v51 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1953), (*(_QWORD *)(a7 + 40) = v51) != 0))
    {
      v52 = *(_DWORD *)(a7 + 112);
      if (v52)
        v53 = 2 * v52;
      else
        v53 = 5000;
      *(_DWORD *)(a7 + 112) = v53;
      v54 = arc4random();
      v55 = *(_DWORD *)(a7 + 112);
      v56 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v57 = *(_DWORD *)a7;
        *(_DWORD *)buf = 136447490;
        v89 = "srp_schedule_instance_retry";
        v90 = 1024;
        *(_DWORD *)v91 = v57;
        *(_WORD *)&v91[4] = 2048;
        *(_QWORD *)&v91[6] = a7;
        *(_WORD *)&v91[14] = 2080;
        *(_QWORD *)&v91[16] = "instance";
        *(_WORD *)&v91[24] = 2080;
        *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 1960;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      v58 = *(_DWORD *)a7;
      if (*(_DWORD *)a7)
      {
        v59 = v58 + 1;
        *(_DWORD *)a7 = v58 + 1;
        if (v58 + 1 >= 10001)
        {
          v26 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_163;
          *(_DWORD *)buf = 136447490;
          v89 = "srp_schedule_instance_retry";
          v90 = 1024;
          *(_DWORD *)v91 = v59;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = a7;
          *(_WORD *)&v91[14] = 2080;
          *(_QWORD *)&v91[16] = "instance";
          *(_WORD *)&v91[24] = 2080;
          *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 1960;
          v32 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_141;
        }
      }
      else
      {
        ++adv_instance_created;
        *(_DWORD *)a7 = 1;
      }
      v60 = -((double)(v54 % v55) - (double)v53 * 1.5);
      ioloop_add_wake_event(*(_QWORD *)(a7 + 40), a7, (uint64_t)srp_instance_retry_callback, (uint64_t)adv_instance_context_release, v60);
      v61 = global_os_log;
      a5 = v44;
      a4 = v42;
      a6 = v87;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_79;
      *(_DWORD *)buf = 136446722;
      v89 = "srp_schedule_instance_retry";
      v90 = 2048;
      *(_QWORD *)v91 = a7;
      *(_WORD *)&v91[8] = 2048;
      *(double *)&v91[10] = (double)v60 / 1000.0;
      v62 = "%{public}s: will attempt to reregister instance %p in %.3lf seconds";
      v63 = v61;
      v64 = OS_LOG_TYPE_DEFAULT;
      v65 = 32;
    }
    else
    {
      v85 = global_os_log;
      a5 = v44;
      a4 = v42;
      a6 = v87;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_79;
      *(_DWORD *)buf = 136446210;
      v89 = "srp_schedule_instance_retry";
      v62 = "%{public}s: unable to make wakeup &instance->retry_wakeup";
      v63 = v85;
      v64 = OS_LOG_TYPE_ERROR;
      v65 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v63, v64, v62, buf, v65);
LABEL_79:
    if (v12)
    {
      if (*(_BYTE *)(a7 + 117))
      {
        v66 = *(_QWORD *)(v12 + 16);
        if (v66)
          *(_QWORD *)(a7 + 96) = *(_QWORD *)(v66 + 32);
        v67 = *(_DWORD *)(v12 + 96);
        v68 = *(_DWORD *)(v12 + 92) + 1;
        *(_DWORD *)(v12 + 92) = v68;
        if (*(_DWORD *)(v12 + 100) == v67 && v68 == *(_DWORD *)(v12 + 88))
          srp_mdns_update_finished(v12);
        v69 = *(_DWORD *)v12;
        if (!*(_DWORD *)v12)
        {
          v31 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_163;
          *(_DWORD *)buf = 136447490;
          v89 = "register_instance_completion";
          v90 = 1024;
          *(_DWORD *)v91 = 0;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = v12;
          *(_WORD *)&v91[14] = 2080;
          *(_QWORD *)&v91[16] = "update";
          *(_WORD *)&v91[24] = 2080;
          *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2087;
          v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_161;
        }
        v23 = global_os_log;
        if (v69 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_163;
          *(_DWORD *)buf = 136447490;
          v89 = "register_instance_completion";
          v90 = 1024;
          *(_DWORD *)v91 = v69;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = v12;
          *(_WORD *)&v91[14] = 2080;
          *(_QWORD *)&v91[16] = "update";
          *(_WORD *)&v91[24] = 2080;
          *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2087;
          v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_158;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v89 = "register_instance_completion";
          v90 = 1024;
          *(_DWORD *)v91 = v69;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = v12;
          *(_WORD *)&v91[14] = 2080;
          *(_QWORD *)&v91[16] = "update";
          *(_WORD *)&v91[24] = 2080;
          *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2087;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v69 = *(_DWORD *)v12;
        }
        *(_DWORD *)v12 = v69 - 1;
        if (v69 == 1)
        {
          v70 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v89 = "register_instance_completion";
            v90 = 2048;
            *(_QWORD *)v91 = v12;
            *(_WORD *)&v91[8] = 2080;
            *(_QWORD *)&v91[10] = "update";
            *(_WORD *)&v91[18] = 2080;
            *(_QWORD *)&v91[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v91[28] = 1024;
            *(_DWORD *)&v91[30] = 2087;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_update_finalized;
          adv_update_finalize(v12);
        }
        *(_BYTE *)(a7 + 117) = 0;
      }
      goto LABEL_100;
    }
    v71 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_100;
    v72 = *(_QWORD *)(a7 + 48);
    *(_DWORD *)buf = 136448259;
    v89 = "register_instance_completion";
    v90 = 2160;
    *(_QWORD *)v91 = 1752392040;
    *(_WORD *)&v91[8] = 2081;
    *(_QWORD *)&v91[10] = v72;
    *(_WORD *)&v91[18] = 2160;
    *(_QWORD *)&v91[20] = 1752392040;
    *(_WORD *)&v91[28] = 2081;
    *(_QWORD *)&v91[30] = a4;
    *(_WORD *)&v91[38] = 2160;
    v92 = 1752392040;
    v93 = 2081;
    v94 = a5;
    v95 = 2160;
    v96 = 1752392040;
    v97 = 2081;
    v98 = a6;
    v73 = "%{public}s: re-update succeeded for instance %{private, mask.hash}s (%{private, mask.hash}s %{private, mask.ha"
          "sh}s %{private, mask.hash}s)";
    v74 = v71;
    v75 = OS_LOG_TYPE_DEFAULT;
    v76 = 92;
LABEL_99:
    _os_log_impl((void *)&_mh_execute_header, v74, v75, v73, buf, v76);
    goto LABEL_100;
  }
  v17 = v16 + 1;
  *(_DWORD *)a7 = v16 + 1;
  if (v16 + 1 >= 10001)
  {
    v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_163;
    *(_DWORD *)buf = 136447490;
    v89 = "register_instance_completion";
    v90 = 1024;
    *(_DWORD *)v91 = v17;
    *(_WORD *)&v91[4] = 2048;
    *(_QWORD *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(_QWORD *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2034;
    v32 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
    goto LABEL_141;
  }
  if (!v12)
    goto LABEL_26;
LABEL_6:
  v18 = v13[6];
  v19 = global_os_log;
  v20 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v18 != v12)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136447235;
      v89 = "register_instance_completion";
      v90 = 2160;
      *(_QWORD *)v91 = 1752392040;
      *(_WORD *)&v91[8] = 2081;
      *(_QWORD *)&v91[10] = a4;
      *(_WORD *)&v91[18] = 2160;
      *(_QWORD *)&v91[20] = 1752392040;
      *(_WORD *)&v91[28] = 2081;
      *(_QWORD *)&v91[30] = a5;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for service %{private, mask.hash}s.%{private, mask.hash}s completed with invalid state.", buf, 0x34u);
    }
    v21 = *(int **)(a7 + 32);
    if (!v21)
    {
LABEL_18:
      *(_QWORD *)(a7 + 32) = 0;
      v25 = *(_DWORD *)a7;
      if (!*(_DWORD *)a7)
      {
        v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_163;
        *(_DWORD *)buf = 136447490;
        v89 = "register_instance_completion";
        v90 = 1024;
        *(_DWORD *)v91 = 0;
        *(_WORD *)&v91[4] = 2048;
        *(_QWORD *)&v91[6] = a7;
        *(_WORD *)&v91[14] = 2080;
        *(_QWORD *)&v91[16] = "instance";
        *(_WORD *)&v91[24] = 2080;
        *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2043;
        v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_141;
      }
      v26 = global_os_log;
      if (v25 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v89 = "register_instance_completion";
          v90 = 1024;
          *(_DWORD *)v91 = v25;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = a7;
          *(_WORD *)&v91[14] = 2080;
          *(_QWORD *)&v91[16] = "instance";
          *(_WORD *)&v91[24] = 2080;
          *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2043;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v25 = *(_DWORD *)a7;
        }
        *(_DWORD *)a7 = v25 - 1;
        if (v25 == 1)
        {
          v27 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v89 = "register_instance_completion";
            v90 = 2048;
            *(_QWORD *)v91 = a7;
            *(_WORD *)&v91[8] = 2080;
            *(_QWORD *)&v91[10] = "instance";
            *(_WORD *)&v91[18] = 2080;
            *(_QWORD *)&v91[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v91[28] = 1024;
            *(_DWORD *)&v91[30] = 2043;
LABEL_107:
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            goto LABEL_108;
          }
          goto LABEL_108;
        }
        return;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v89 = "register_instance_completion";
        v90 = 1024;
        *(_DWORD *)v91 = v25;
        *(_WORD *)&v91[4] = 2048;
        *(_QWORD *)&v91[6] = a7;
        *(_WORD *)&v91[14] = 2080;
        *(_QWORD *)&v91[16] = "instance";
        *(_WORD *)&v91[24] = 2080;
        *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2043;
        v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_141:
        v86 = v26;
LABEL_162:
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_FAULT, v32, buf, 0x36u);
      }
LABEL_163:
      abort();
    }
    v22 = *v21;
    if (*v21)
    {
      v23 = global_os_log;
      if (v22 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v89 = "register_instance_completion";
          v90 = 1024;
          *(_DWORD *)v91 = v22;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = v21;
          *(_WORD *)&v91[14] = 2080;
          *(_QWORD *)&v91[16] = "instance->update";
          *(_WORD *)&v91[24] = 2080;
          *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2041;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v21 = *(int **)(a7 + 32);
          v22 = *v21;
        }
        *v21 = v22 - 1;
        if (v22 == 1)
        {
          v24 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v89 = "register_instance_completion";
            v90 = 2048;
            *(_QWORD *)v91 = v21;
            *(_WORD *)&v91[8] = 2080;
            *(_QWORD *)&v91[10] = "instance->update";
            *(_WORD *)&v91[18] = 2080;
            *(_QWORD *)&v91[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v91[28] = 1024;
            *(_DWORD *)&v91[30] = 2041;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            v21 = *(int **)(a7 + 32);
          }
          ++adv_update_finalized;
          adv_update_finalize((uint64_t)v21);
        }
        goto LABEL_18;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_163;
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = v22;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v21;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2041;
      v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_158:
      v86 = v23;
      goto LABEL_162;
    }
    v31 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_163;
    *(_DWORD *)buf = 136447490;
    v89 = "register_instance_completion";
    v90 = 1024;
    *(_DWORD *)v91 = 0;
    *(_WORD *)&v91[4] = 2048;
    *(_QWORD *)&v91[6] = v21;
    *(_WORD *)&v91[14] = 2080;
    *(_QWORD *)&v91[16] = "instance->update";
    *(_WORD *)&v91[24] = 2080;
    *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2041;
    v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_161:
    v86 = v31;
    goto LABEL_162;
  }
  if (v20)
  {
    v28 = *(_DWORD *)v12;
    *(_DWORD *)buf = 136447490;
    v89 = "register_instance_completion";
    v90 = 1024;
    *(_DWORD *)v91 = v28;
    *(_WORD *)&v91[4] = 2048;
    *(_QWORD *)&v91[6] = v12;
    *(_WORD *)&v91[14] = 2080;
    *(_QWORD *)&v91[16] = "update";
    *(_WORD *)&v91[24] = 2080;
    *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2051;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v29 = *(_DWORD *)v12;
  if (*(_DWORD *)v12)
  {
    v30 = v29 + 1;
    *(_DWORD *)v12 = v29 + 1;
    if (v29 + 1 >= 10001)
    {
      v31 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_163;
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = v30;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2051;
      v32 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_161;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)v12 = 1;
  }
  v33 = *(int **)(a7 + 32);
  if (v33)
  {
    v34 = *v33;
    if (!*v33)
    {
      v31 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_163;
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = 0;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v33;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2052;
      v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_161;
    }
    v35 = global_os_log;
    if (v34 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_163;
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = v34;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v33;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2052;
      v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v86 = v35;
      goto LABEL_162;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = v34;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v33;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2052;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v33 = *(int **)(a7 + 32);
      v34 = *v33;
    }
    *v33 = v34 - 1;
    if (v34 == 1)
    {
      v36 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v89 = "register_instance_completion";
        v90 = 2048;
        *(_QWORD *)v91 = v33;
        *(_WORD *)&v91[8] = 2080;
        *(_QWORD *)&v91[10] = "instance->update";
        *(_WORD *)&v91[18] = 2080;
        *(_QWORD *)&v91[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[28] = 1024;
        *(_DWORD *)&v91[30] = 2052;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v33 = *(int **)(a7 + 32);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v33);
    }
  }
  *(_QWORD *)(a7 + 32) = 0;
  if (!a3)
    goto LABEL_46;
LABEL_45:
  if (a3 == -65548)
    goto LABEL_46;
  v45 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v46 = *(_QWORD *)(a7 + 48);
    v47 = *(_QWORD *)(a7 + 56);
    v48 = v13[8];
    *(_DWORD *)buf = 136448515;
    v89 = "register_instance_completion";
    v90 = 2160;
    *(_QWORD *)v91 = 1752392040;
    *(_WORD *)&v91[8] = 2081;
    *(_QWORD *)&v91[10] = v46;
    *(_WORD *)&v91[18] = 2160;
    *(_QWORD *)&v91[20] = 1752392040;
    *(_WORD *)&v91[28] = 2081;
    *(_QWORD *)&v91[30] = v47;
    *(_WORD *)&v91[38] = 2160;
    v92 = 1752392040;
    v93 = 2081;
    v94 = a6;
    v95 = 2160;
    v96 = 1752392040;
    v97 = 2081;
    v98 = v48;
    v99 = 1024;
    LODWORD(v100) = a3;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for service %{private, mask.hash}s.%{private, mask.hash}s.%{private, mask.hash}s -> %{private, mask.hash}s failed with code %d", buf, 0x62u);
  }
  if (a3 == -65563 || a3 == -65569)
  {
    service_disconnected(v13[1], *(_QWORD *)(a7 + 16));
    *(_QWORD *)(a7 + 16) = 0;
    wait_retry((uint64_t)v13);
  }
  else if (v12)
  {
    update_failed(v12, 2u, 1);
    v79 = *(int **)(a7 + 32);
    if (v79)
    {
      v80 = *v79;
      if (!*v79)
      {
        v31 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_163;
        *(_DWORD *)buf = 136447490;
        v89 = "register_instance_completion";
        v90 = 1024;
        *(_DWORD *)v91 = 0;
        *(_WORD *)&v91[4] = 2048;
        *(_QWORD *)&v91[6] = v79;
        *(_WORD *)&v91[14] = 2080;
        *(_QWORD *)&v91[16] = "instance->update";
        *(_WORD *)&v91[24] = 2080;
        *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2117;
        v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_161;
      }
      v81 = global_os_log;
      if (v80 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v89 = "register_instance_completion";
          v90 = 1024;
          *(_DWORD *)v91 = v80;
          *(_WORD *)&v91[4] = 2048;
          *(_QWORD *)&v91[6] = v79;
          *(_WORD *)&v91[14] = 2080;
          *(_QWORD *)&v91[16] = "instance->update";
          *(_WORD *)&v91[24] = 2080;
          *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2117;
          v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v86 = v81;
          goto LABEL_162;
        }
        goto LABEL_163;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v89 = "register_instance_completion";
        v90 = 1024;
        *(_DWORD *)v91 = v80;
        *(_WORD *)&v91[4] = 2048;
        *(_QWORD *)&v91[6] = v79;
        *(_WORD *)&v91[14] = 2080;
        *(_QWORD *)&v91[16] = "instance->update";
        *(_WORD *)&v91[24] = 2080;
        *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2117;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v79 = *(int **)(a7 + 32);
        v80 = *v79;
      }
      *v79 = v80 - 1;
      if (v80 == 1)
      {
        v82 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v89 = "register_instance_completion";
          v90 = 2048;
          *(_QWORD *)v91 = v79;
          *(_WORD *)&v91[8] = 2080;
          *(_QWORD *)&v91[10] = "instance->update";
          *(_WORD *)&v91[18] = 2080;
          *(_QWORD *)&v91[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[28] = 1024;
          *(_DWORD *)&v91[30] = 2117;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v79 = *(int **)(a7 + 32);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v79);
      }
      *(_QWORD *)(a7 + 32) = 0;
    }
    v83 = *(_DWORD *)v12;
    if (!*(_DWORD *)v12)
    {
      v31 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_163;
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = 0;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2120;
      v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_161;
    }
    v23 = global_os_log;
    if (v83 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_163;
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = v83;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2120;
      v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_158;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v89 = "register_instance_completion";
      v90 = 1024;
      *(_DWORD *)v91 = v83;
      *(_WORD *)&v91[4] = 2048;
      *(_QWORD *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(_QWORD *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2120;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v83 = *(_DWORD *)v12;
    }
    *(_DWORD *)v12 = v83 - 1;
    if (v83 == 1)
    {
      v84 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v89 = "register_instance_completion";
        v90 = 2048;
        *(_QWORD *)v91 = v12;
        *(_WORD *)&v91[8] = 2080;
        *(_QWORD *)&v91[10] = "update";
        *(_WORD *)&v91[18] = 2080;
        *(_QWORD *)&v91[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[28] = 1024;
        *(_DWORD *)&v91[30] = 2120;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++adv_update_finalized;
      adv_update_finalize(v12);
    }
  }
  v49 = *(_QWORD *)(a7 + 8);
  if (v49)
  {
    ioloop_dnssd_txn_cancel(v49);
    ioloop_dnssd_txn_release_(*(int **)(a7 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2147);
    *(_QWORD *)(a7 + 8) = 0;
    goto LABEL_100;
  }
  v77 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446466;
    v89 = "register_instance_completion";
    v90 = 2048;
    *(_QWORD *)v91 = a7;
    v73 = "%{public}s: instance->txn is NULL for instance %p!";
    v74 = v77;
    v75 = OS_LOG_TYPE_FAULT;
    v76 = 22;
    goto LABEL_99;
  }
LABEL_100:
  v78 = *(_DWORD *)a7;
  if (!*(_DWORD *)a7)
  {
    v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_163;
    *(_DWORD *)buf = 136447490;
    v89 = "register_instance_completion";
    v90 = 1024;
    *(_DWORD *)v91 = 0;
    *(_WORD *)&v91[4] = 2048;
    *(_QWORD *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(_QWORD *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2151;
    v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_141;
  }
  v26 = global_os_log;
  if (v78 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_163;
    *(_DWORD *)buf = 136447490;
    v89 = "register_instance_completion";
    v90 = 1024;
    *(_DWORD *)v91 = v78;
    *(_WORD *)&v91[4] = 2048;
    *(_QWORD *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(_QWORD *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2151;
    v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_141;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v89 = "register_instance_completion";
    v90 = 1024;
    *(_DWORD *)v91 = v78;
    *(_WORD *)&v91[4] = 2048;
    *(_QWORD *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(_QWORD *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(_QWORD *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2151;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v78 = *(_DWORD *)a7;
  }
  *(_DWORD *)a7 = v78 - 1;
  if (v78 == 1)
  {
    v27 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v89 = "register_instance_completion";
      v90 = 2048;
      *(_QWORD *)v91 = a7;
      *(_WORD *)&v91[8] = 2080;
      *(_QWORD *)&v91[10] = "instance";
      *(_WORD *)&v91[18] = 2080;
      *(_QWORD *)&v91[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[28] = 1024;
      *(_DWORD *)&v91[30] = 2151;
      goto LABEL_107;
    }
LABEL_108:
    ++adv_instance_finalized;
    adv_instance_finalize((void *)a7);
  }
}

void service_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  BOOL v3;
  NSObject *v6;
  uint64_t v7;
  _QWORD *i;
  uint64_t v9;
  uint8_t buf[4];
  const char *v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  uint64_t v15;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
    v3 = v2 == a2;
  else
    v3 = 0;
  if (v3)
  {
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v7 = *(_QWORD *)(v2 + 8);
      *(_DWORD *)buf = 136446722;
      v11 = "service_disconnected";
      v12 = 2048;
      v13 = a2;
      v14 = 2048;
      v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: server_state->shared_registration_txn = %p  sdref = %p", buf, 0x20u);
    }
    for (i = *(_QWORD **)(a1 + 8); i; i = (_QWORD *)i[5])
    {
      record_vec_txns_forget(i[12], a2, (uint64_t)"host", (uint64_t)i, i[7]);
      instance_vec_txns_forget(i[14], a2, (uint64_t)"host", (uint64_t)i, i[7]);
      record_txn_forget(i[13], a2, (uint64_t)"host key", (uint64_t)i, i[7]);
      v9 = i[6];
      if (v9)
      {
        record_vec_txns_forget(*(_QWORD *)(v9 + 32), a2, (uint64_t)"host update remove addresses", v9, i[7]);
        record_vec_txns_forget(*(_QWORD *)(i[6] + 40), a2, (uint64_t)"host update add addresses", i[6], i[7]);
        record_txn_forget(*(_QWORD *)(i[6] + 48), a2, (uint64_t)"host update key", i[6], i[7]);
        instance_vec_txns_forget(*(_QWORD *)(i[6] + 56), a2, (uint64_t)"host update update instances", i[6], i[7]);
        instance_vec_txns_forget(*(_QWORD *)(i[6] + 64), a2, (uint64_t)"host update remove instances", i[6], i[7]);
        instance_vec_txns_forget(*(_QWORD *)(i[6] + 72), a2, (uint64_t)"host update renew instances", i[6], i[7]);
        instance_vec_txns_forget(*(_QWORD *)(i[6] + 80), a2, (uint64_t)"host update add instances", i[6], i[7]);
      }
    }
    dns_service_op_not_to_be_freed = 0;
    ioloop_dnssd_txn_cancel(*(_QWORD *)(a1 + 16));
    ioloop_dnssd_txn_release_(*(int **)(a1 + 16), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 838);
    *(_QWORD *)(a1 + 16) = 0;
  }
}

void record_vec_txns_forget(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;

  if (a1 && *(int *)(a1 + 4) >= 1)
  {
    v10 = 0;
    do
      record_txn_forget(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8 * v10++), a2, a3, a4, a5);
    while (v10 < *(int *)(a1 + 4));
  }
}

void instance_vec_txns_forget(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v6;
  uint64_t i;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  uint8_t buf[4];
  const char *v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;

  if (a1)
  {
    v6 = *(_DWORD *)(a1 + 4);
    if (v6 >= 1)
    {
      for (i = 0; i < v6; ++i)
      {
        v11 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * i);
        if (v11)
        {
          v12 = v11[1];
          if (v12)
          {
            v13 = *(_QWORD *)(v12 + 8);
            if (v13)
            {
              if (v11[2] == a2)
              {
                v14 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  v15 = v11[6];
                  v16 = v11[7];
                  *(_DWORD *)buf = 136448515;
                  v19 = "instance_vec_txns_forget";
                  v20 = 2048;
                  v21 = v13;
                  v22 = 2082;
                  v23 = a3;
                  v24 = 2048;
                  v25 = a4;
                  v26 = 2160;
                  v27 = 1752392040;
                  v28 = 2081;
                  v29 = a5;
                  v30 = 2160;
                  v31 = 1752392040;
                  v32 = 2081;
                  v33 = v15;
                  v34 = 2160;
                  v35 = 1752392040;
                  v36 = 2081;
                  v37 = v16;
                  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: forgetting sdref %p on %{public}s %p %{private, mask.hash}s instance %{private, mask.hash}s . %{private, mask.hash}s", buf, 0x66u);
                  v12 = v11[1];
                  v6 = *(_DWORD *)(a1 + 4);
                }
                *(_QWORD *)(v12 + 8) = 0;
              }
            }
          }
        }
      }
    }
  }
}

void record_txn_forget(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  NSObject *v10;
  int v11;
  const char *v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;

  if (a1)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6)
    {
      if (*(_QWORD *)(a1 + 24) == a2)
      {
        v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v11 = 136447491;
          v12 = "record_txn_forget";
          v13 = 2048;
          v14 = v6;
          v15 = 2082;
          v16 = a3;
          v17 = 2048;
          v18 = a4;
          v19 = 2160;
          v20 = 1752392040;
          v21 = 2081;
          v22 = a5;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: forgetting rref %p on %{public}s %p %{private, mask.hash}s", (uint8_t *)&v11, 0x3Eu);
        }
        *(_QWORD *)(a1 + 8) = 0;
      }
    }
  }
}

void srp_instance_retry_callback(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  NSObject *v4;
  int v5;
  const char *v6;
  __int16 v7;
  uint64_t v8;

  v2 = *(_QWORD *)(a1 + 24);
  if (v2 && !*(_BYTE *)(v2 + 264))
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136446466;
      v6 = "srp_instance_retry_callback";
      v7 = 2048;
      v8 = a1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registering updating instance %p.", (uint8_t *)&v5, 0x16u);
    }
    register_instance(a1);
  }
  else
  {
    v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 136446466;
      v6 = "srp_instance_retry_callback";
      v7 = 2048;
      v8 = a1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: no longer updating instance %p because host is no longer valid.", (uint8_t *)&v5, 0x16u);
    }
  }
}

void wait_retry(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  NSObject *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  int v9;
  int v10;
  int v11;
  NSObject *v12;
  _BYTE v13[48];
  __int16 v14;
  int v15;

  *(_QWORD *)v13 = 0;
  *(_QWORD *)&v13[8] = 0;
  gettimeofday((timeval *)v13, 0);
  v2 = 1000 * *(_QWORD *)v13 + *(_DWORD *)&v13[8] / 1000;
  v3 = *(_QWORD *)(a1 + 256);
  if (v3)
    v4 = v3 < v2;
  else
    v4 = 1;
  if (!v4)
  {
    v6 = *(_DWORD *)(a1 + 192);
    if (v6)
    {
      if (v6 > 119)
      {
LABEL_14:
        v7 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)v13 = 136446466;
          *(_QWORD *)&v13[4] = "wait_retry";
          *(_WORD *)&v13[12] = 1024;
          *(_DWORD *)&v13[14] = v6;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: waiting %d seconds...", v13, 0x12u);
          v6 = *(_DWORD *)(a1 + 192);
        }
        ioloop_add_wake_event(*(_QWORD *)(a1 + 24), a1, (uint64_t)retry_callback, (uint64_t)srp_adv_host_context_release, 1000 * v6);
        v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v9 = *(_DWORD *)a1;
          *(_DWORD *)v13 = 136447490;
          *(_QWORD *)&v13[4] = "wait_retry";
          *(_WORD *)&v13[12] = 1024;
          *(_DWORD *)&v13[14] = v9;
          *(_WORD *)&v13[18] = 2048;
          *(_QWORD *)&v13[20] = a1;
          *(_WORD *)&v13[28] = 2080;
          *(_QWORD *)&v13[30] = "host";
          *(_WORD *)&v13[38] = 2080;
          *(_QWORD *)&v13[40] = "srp-mdns-proxy.c";
          v14 = 1024;
          v15 = 709;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v13, 0x36u);
        }
        v10 = *(_DWORD *)a1;
        if (*(_DWORD *)a1)
        {
          v11 = v10 + 1;
          *(_DWORD *)a1 = v10 + 1;
          if (v10 + 1 >= 10001)
          {
            v12 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)v13 = 136447490;
              *(_QWORD *)&v13[4] = "wait_retry";
              *(_WORD *)&v13[12] = 1024;
              *(_DWORD *)&v13[14] = v11;
              *(_WORD *)&v13[18] = 2048;
              *(_QWORD *)&v13[20] = a1;
              *(_WORD *)&v13[28] = 2080;
              *(_QWORD *)&v13[30] = "host";
              *(_WORD *)&v13[38] = 2080;
              *(_QWORD *)&v13[40] = "srp-mdns-proxy.c";
              v14 = 1024;
              v15 = 709;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", v13, 0x36u);
            }
            abort();
          }
        }
        else
        {
          ++adv_host_created;
          *(_DWORD *)a1 = 1;
        }
        return;
      }
      v6 *= 2;
    }
    else
    {
      v6 = 15;
    }
    *(_DWORD *)(a1 + 192) = v6;
    goto LABEL_14;
  }
  v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v13 = 136446978;
    *(_QWORD *)&v13[4] = "wait_retry";
    *(_WORD *)&v13[12] = 2048;
    *(_QWORD *)&v13[14] = v3;
    *(_WORD *)&v13[22] = 2048;
    *(_QWORD *)&v13[24] = v2;
    *(_WORD *)&v13[32] = 2048;
    *(_QWORD *)&v13[34] = v3 - v2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: host lease has expired, not retrying: lease_expiry = %lld now = %lld difference = %lld", v13, 0x2Au);
  }
  delete_host(a1);
}

void delete_host(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  const char *v7;
  __int16 v8;
  uint64_t v9;
  __int16 v10;
  uint64_t v11;

  v2 = host_ready(a1);
  if (v2)
  {
    v3 = v2;
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v5 = *(_QWORD *)(a1 + 56);
      v6 = 136446723;
      v7 = "delete_host";
      v8 = 2160;
      v9 = 1752392040;
      v10 = 2081;
      v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: deleting host %{private, mask.hash}s", (uint8_t *)&v6, 0x20u);
    }
    *v3 = *(_QWORD *)(a1 + 40);
    host_remove((int *)a1);
  }
}

uint64_t retry_callback(int *a1)
{
  void *v3;
  NSObject *v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  int v14;
  uint64_t i;
  uint64_t v16;
  int *v17;
  NSObject *v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  NSObject *v24;
  _BOOL4 v25;
  int v26;
  int v27;
  NSObject *v28;
  const char *v29;
  uint64_t v30;
  _QWORD *v31;
  _QWORD *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  NSObject *v37;
  int v38;
  int v39;
  int v40;
  uint64_t j;
  uint64_t v42;
  NSObject *v43;
  _BOOL4 v44;
  int v45;
  int v46;
  _QWORD *v47;
  uint64_t v48;
  _QWORD *v49;
  NSObject *v50;
  int *v51;
  int v52;
  int v53;
  int v54;
  NSObject *v55;
  int *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  NSObject *v61;
  NSObject *v62;
  int v63;
  NSObject *v64;
  uint64_t v65;
  NSObject *v69;
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  _BYTE v74[34];
  __int16 v75;
  int v76;

  if (*((_QWORD *)a1 + 6))
    return start_host_update(a1);
  v3 = malloc_type_calloc(1uLL, 0x88uLL, 0x1020040C5CF03A7uLL);
  v4 = global_os_log;
  if (!v3)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v72 = "update_from_host";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: no memory for update.", buf, 0xCu);
    }
    return wait_retry(a1);
  }
  v5 = (uint64_t)v3;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = *(_DWORD *)v5;
    *(_DWORD *)buf = 136447490;
    v72 = "update_from_host";
    v73 = 1024;
    *(_DWORD *)v74 = v6;
    *(_WORD *)&v74[4] = 2048;
    *(_QWORD *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(_QWORD *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
    v75 = 1024;
    v76 = 2346;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v7 = *(_DWORD *)v5;
  if (*(_DWORD *)v5)
  {
    v8 = v7 + 1;
    *(_DWORD *)v5 = v7 + 1;
    if (v7 + 1 >= 10001)
    {
      v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v72 = "update_from_host";
        v73 = 1024;
        *(_DWORD *)v74 = v8;
        *(_WORD *)&v74[4] = 2048;
        *(_QWORD *)&v74[6] = v5;
        *(_WORD *)&v74[14] = 2080;
        *(_QWORD *)&v74[16] = "update";
        *(_WORD *)&v74[24] = 2080;
        *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
        v75 = 1024;
        v76 = 2346;
        v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_127;
      }
      goto LABEL_129;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)v5 = 1;
  }
  v11 = *((_QWORD *)a1 + 12);
  if (!v11)
    goto LABEL_42;
  v12 = adv_record_vec_create(*(_DWORD *)(v11 + 4));
  if (!v12)
  {
    *(_QWORD *)(v5 + 40) = 0;
    v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_102;
    *(_DWORD *)buf = 136446210;
    v72 = "update_from_host";
    v29 = "%{public}s: no memory for addresses";
LABEL_101:
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
    goto LABEL_102;
  }
  v13 = v12;
  v14 = *(_DWORD *)(v11 + 4);
  if (v14 <= 0)
  {
    *((_DWORD *)v12 + 1) = v14;
    *(_QWORD *)(v5 + 40) = v12;
    goto LABEL_42;
  }
  for (i = 0; i < v14; ++i)
  {
    v16 = *(_QWORD *)(*(_QWORD *)(v11 + 8) + 8 * i);
    if (v16)
    {
      *(_QWORD *)(v13[1] + 8 * i) = v16;
      v17 = *(int **)(v13[1] + 8 * i);
      if (v17)
      {
        v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v19 = *v17;
          *(_DWORD *)buf = 136447490;
          v72 = "adv_record_vec_copy";
          v73 = 1024;
          *(_DWORD *)v74 = v19;
          *(_WORD *)&v74[4] = 2048;
          *(_QWORD *)&v74[6] = v17;
          *(_WORD *)&v74[14] = 2080;
          *(_QWORD *)&v74[16] = "new_vec->vec[i]";
          *(_WORD *)&v74[24] = 2080;
          *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
          v75 = 1024;
          v76 = 310;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v17 = *(int **)(v13[1] + 8 * i);
        }
        v20 = *v17;
        if (*v17)
        {
          v21 = v20 + 1;
          *v17 = v20 + 1;
          if (v20 + 1 > 10000)
          {
            v65 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_129;
            *(_DWORD *)buf = 136447490;
            v72 = "adv_record_vec_copy";
            v73 = 1024;
            *(_DWORD *)v74 = v21;
            *(_WORD *)&v74[4] = 2048;
            *(_QWORD *)&v74[6] = v17;
            *(_WORD *)&v74[14] = 2080;
            *(_QWORD *)&v74[16] = "new_vec->vec[i]";
            *(_WORD *)&v74[24] = 2080;
            *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
            v75 = 1024;
            v76 = 310;
            v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_118;
          }
        }
        else
        {
          ++adv_record_created;
          *v17 = 1;
        }
        v14 = *(_DWORD *)(v11 + 4);
      }
    }
  }
  *((_DWORD *)v13 + 1) = v14;
  *(_QWORD *)(v5 + 40) = v13;
  if (v14 >= 1)
  {
    v22 = 0;
    do
    {
      v23 = *(_QWORD *)(v13[1] + 8 * v22);
      if (v23)
      {
        *(_QWORD *)(v23 + 32) = v5;
        v24 = global_os_log;
        v25 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        v26 = *(_DWORD *)v5;
        if (v25)
        {
          *(_DWORD *)buf = 136447490;
          v72 = "update_from_host";
          v73 = 1024;
          *(_DWORD *)v74 = v26;
          *(_WORD *)&v74[4] = 2048;
          *(_QWORD *)&v74[6] = v5;
          *(_WORD *)&v74[14] = 2080;
          *(_QWORD *)&v74[16] = "update";
          *(_WORD *)&v74[24] = 2080;
          *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
          v75 = 1024;
          v76 = 2357;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v26 = *(_DWORD *)v5;
        }
        if (v26)
        {
          v27 = v26 + 1;
          *(_DWORD *)v5 = v26 + 1;
          if (v26 + 1 > 10000)
          {
            v9 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v72 = "update_from_host";
              v73 = 1024;
              *(_DWORD *)v74 = v27;
              *(_WORD *)&v74[4] = 2048;
              *(_QWORD *)&v74[6] = v5;
              *(_WORD *)&v74[14] = 2080;
              *(_QWORD *)&v74[16] = "update";
              *(_WORD *)&v74[24] = 2080;
              *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
              v75 = 1024;
              v76 = 2357;
              v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_127;
            }
            goto LABEL_129;
          }
        }
        else
        {
          ++adv_update_created;
          *(_DWORD *)v5 = 1;
        }
        v13 = *(_QWORD **)(v5 + 40);
      }
      ++v22;
    }
    while (v22 < *((int *)v13 + 1));
  }
LABEL_42:
  v30 = *((_QWORD *)a1 + 14);
  if (!v30)
    goto LABEL_74;
  v31 = adv_instance_vec_create(*(_DWORD *)(v30 + 4));
  if (!v31)
  {
    *(_QWORD *)(v5 + 56) = 0;
    v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_102;
    *(_DWORD *)buf = 136446210;
    v72 = "update_from_host";
    v29 = "%{public}s: no memory for update_instances";
    goto LABEL_101;
  }
  v32 = v31;
  v33 = *(_DWORD *)(v30 + 4);
  if (v33 <= 0)
  {
    *((_DWORD *)v31 + 1) = v33;
    *(_QWORD *)(v5 + 56) = v31;
    goto LABEL_71;
  }
  v34 = 0;
  while (2)
  {
    v35 = *(_QWORD *)(*(_QWORD *)(v30 + 8) + 8 * v34);
    if (v35)
    {
      *(_QWORD *)(v32[1] + 8 * v34) = v35;
      v36 = *(int **)(v32[1] + 8 * v34);
      if (v36)
      {
        v37 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v38 = *v36;
          *(_DWORD *)buf = 136447490;
          v72 = "adv_instance_vec_copy";
          v73 = 1024;
          *(_DWORD *)v74 = v38;
          *(_WORD *)&v74[4] = 2048;
          *(_QWORD *)&v74[6] = v36;
          *(_WORD *)&v74[14] = 2080;
          *(_QWORD *)&v74[16] = "new_vec->vec[i]";
          *(_WORD *)&v74[24] = 2080;
          *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
          v75 = 1024;
          v76 = 306;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v36 = *(int **)(v32[1] + 8 * v34);
        }
        v39 = *v36;
        if (*v36)
        {
          v40 = v39 + 1;
          *v36 = v39 + 1;
          if (v39 + 1 > 10000)
          {
            v65 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_129;
            *(_DWORD *)buf = 136447490;
            v72 = "adv_instance_vec_copy";
            v73 = 1024;
            *(_DWORD *)v74 = v40;
            *(_WORD *)&v74[4] = 2048;
            *(_QWORD *)&v74[6] = v36;
            *(_WORD *)&v74[14] = 2080;
            *(_QWORD *)&v74[16] = "new_vec->vec[i]";
            *(_WORD *)&v74[24] = 2080;
            *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
            v75 = 1024;
            v76 = 306;
            v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_118:
            v69 = v65;
LABEL_128:
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
            goto LABEL_129;
          }
        }
        else
        {
          ++adv_instance_created;
          *v36 = 1;
        }
        v33 = *(_DWORD *)(v30 + 4);
      }
    }
    if (++v34 < v33)
      continue;
    break;
  }
  *((_DWORD *)v32 + 1) = v33;
  *(_QWORD *)(v5 + 56) = v32;
  if (v33 >= 1)
  {
    for (j = 0; j < *((int *)v32 + 1); ++j)
    {
      v42 = *(_QWORD *)(v32[1] + 8 * j);
      if (v42)
      {
        *(_QWORD *)(v42 + 32) = v5;
        v43 = global_os_log;
        v44 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        v45 = *(_DWORD *)v5;
        if (v44)
        {
          *(_DWORD *)buf = 136447490;
          v72 = "update_from_host";
          v73 = 1024;
          *(_DWORD *)v74 = v45;
          *(_WORD *)&v74[4] = 2048;
          *(_QWORD *)&v74[6] = v5;
          *(_WORD *)&v74[14] = 2080;
          *(_QWORD *)&v74[16] = "update";
          *(_WORD *)&v74[24] = 2080;
          *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
          v75 = 1024;
          v76 = 2372;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v45 = *(_DWORD *)v5;
        }
        if (v45)
        {
          v46 = v45 + 1;
          *(_DWORD *)v5 = v45 + 1;
          if (v45 + 1 > 10000)
          {
            v9 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v72 = "update_from_host";
              v73 = 1024;
              *(_DWORD *)v74 = v46;
              *(_WORD *)&v74[4] = 2048;
              *(_QWORD *)&v74[6] = v5;
              *(_WORD *)&v74[14] = 2080;
              *(_QWORD *)&v74[16] = "update";
              *(_WORD *)&v74[24] = 2080;
              *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
              v75 = 1024;
              v76 = 2372;
              v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_127;
            }
LABEL_129:
            abort();
          }
        }
        else
        {
          ++adv_update_created;
          *(_DWORD *)v5 = 1;
        }
        v32 = *(_QWORD **)(v5 + 56);
      }
    }
  }
LABEL_71:
  v47 = adv_instance_vec_create(*(_DWORD *)(*((_QWORD *)a1 + 14) + 4));
  *(_QWORD *)(v5 + 64) = v47;
  if (!v47)
  {
    v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_102;
    *(_DWORD *)buf = 136446210;
    v72 = "update_from_host";
    v29 = "%{public}s: no memory for remove_instances";
    goto LABEL_101;
  }
  v48 = *((_QWORD *)a1 + 14);
  *((_DWORD *)v47 + 1) = *(_DWORD *)(v48 + 4);
  v49 = adv_instance_vec_create(*(_DWORD *)(v48 + 4));
  *(_QWORD *)(v5 + 80) = v49;
  if (!v49)
  {
    v28 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v72 = "update_from_host";
      v29 = "%{public}s: no memory for add_instances";
      goto LABEL_101;
    }
LABEL_102:
    adv_update_cancel(v5);
    v63 = *(_DWORD *)v5;
    if (!*(_DWORD *)v5)
    {
      v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_129;
      *(_DWORD *)buf = 136447490;
      v72 = "update_from_host";
      v73 = 1024;
      *(_DWORD *)v74 = 0;
      *(_WORD *)&v74[4] = 2048;
      *(_QWORD *)&v74[6] = v5;
      *(_WORD *)&v74[14] = 2080;
      *(_QWORD *)&v74[16] = "update";
      *(_WORD *)&v74[24] = 2080;
      *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
      v75 = 1024;
      v76 = 2410;
      v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_127:
      v69 = v9;
      goto LABEL_128;
    }
    v61 = global_os_log;
    if (v63 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_129;
      *(_DWORD *)buf = 136447490;
      v72 = "update_from_host";
      v73 = 1024;
      *(_DWORD *)v74 = v63;
      *(_WORD *)&v74[4] = 2048;
      *(_QWORD *)&v74[6] = v5;
      *(_WORD *)&v74[14] = 2080;
      *(_QWORD *)&v74[16] = "update";
      *(_WORD *)&v74[24] = 2080;
      *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
      v75 = 1024;
      v76 = 2410;
      v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_132:
      v69 = v61;
      goto LABEL_128;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v72 = "update_from_host";
      v73 = 1024;
      *(_DWORD *)v74 = v63;
      *(_WORD *)&v74[4] = 2048;
      *(_QWORD *)&v74[6] = v5;
      *(_WORD *)&v74[14] = 2080;
      *(_QWORD *)&v74[16] = "update";
      *(_WORD *)&v74[24] = 2080;
      *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
      v75 = 1024;
      v76 = 2410;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v63 = *(_DWORD *)v5;
    }
    *(_DWORD *)v5 = v63 - 1;
    if (v63 == 1)
    {
      v64 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v72 = "update_from_host";
        v73 = 2048;
        *(_QWORD *)v74 = v5;
        *(_WORD *)&v74[8] = 2080;
        *(_QWORD *)&v74[10] = "update";
        *(_WORD *)&v74[18] = 2080;
        *(_QWORD *)&v74[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v74[28] = 1024;
        *(_DWORD *)&v74[30] = 2410;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++adv_update_finalized;
      adv_update_finalize(v5);
    }
    return wait_retry(a1);
  }
  *((_DWORD *)v49 + 1) = *(_DWORD *)(*((_QWORD *)a1 + 14) + 4);
LABEL_74:
  *(_QWORD *)(v5 + 8) = a1;
  v50 = global_os_log;
  v51 = a1;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v52 = *a1;
    *(_DWORD *)buf = 136447490;
    v72 = "update_from_host";
    v73 = 1024;
    *(_DWORD *)v74 = v52;
    *(_WORD *)&v74[4] = 2048;
    *(_QWORD *)&v74[6] = a1;
    *(_WORD *)&v74[14] = 2080;
    *(_QWORD *)&v74[16] = "update->host";
    *(_WORD *)&v74[24] = 2080;
    *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
    v75 = 1024;
    v76 = 2395;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v51 = *(int **)(v5 + 8);
  }
  v53 = *v51;
  if (*v51)
  {
    v54 = v53 + 1;
    *v51 = v53 + 1;
    if (v53 + 1 >= 10001)
    {
      v65 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_129;
      *(_DWORD *)buf = 136447490;
      v72 = "update_from_host";
      v73 = 1024;
      *(_DWORD *)v74 = v54;
      *(_WORD *)&v74[4] = 2048;
      *(_QWORD *)&v74[6] = v51;
      *(_WORD *)&v74[14] = 2080;
      *(_QWORD *)&v74[16] = "update->host";
      *(_WORD *)&v74[24] = 2080;
      *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
      v75 = 1024;
      v76 = 2395;
      v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_118;
    }
  }
  else
  {
    ++adv_host_created;
    *v51 = 1;
  }
  *(_QWORD *)(v5 + 104) = *((_QWORD *)a1 + 31);
  *(_QWORD *)(v5 + 112) = *((_QWORD *)a1 + 32);
  *((_QWORD *)a1 + 6) = v5;
  v55 = global_os_log;
  v56 = (int *)v5;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v57 = *(_DWORD *)v5;
    *(_DWORD *)buf = 136447490;
    v72 = "update_from_host";
    v73 = 1024;
    *(_DWORD *)v74 = v57;
    *(_WORD *)&v74[4] = 2048;
    *(_QWORD *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(_QWORD *)&v74[16] = "host->update";
    *(_WORD *)&v74[24] = 2080;
    *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
    v75 = 1024;
    v76 = 2402;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v56 = (int *)*((_QWORD *)a1 + 6);
  }
  v58 = *v56;
  if (*v56)
  {
    v59 = v58 + 1;
    *v56 = v58 + 1;
    if (v58 + 1 >= 10001)
    {
      v65 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_129;
      *(_DWORD *)buf = 136447490;
      v72 = "update_from_host";
      v73 = 1024;
      *(_DWORD *)v74 = v59;
      *(_WORD *)&v74[4] = 2048;
      *(_QWORD *)&v74[6] = v56;
      *(_WORD *)&v74[14] = 2080;
      *(_QWORD *)&v74[16] = "host->update";
      *(_WORD *)&v74[24] = 2080;
      *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
      v75 = 1024;
      v76 = 2402;
      v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_118;
    }
  }
  else
  {
    ++adv_update_created;
    *v56 = 1;
  }
  v60 = *(_DWORD *)v5;
  if (!*(_DWORD *)v5)
  {
    v9 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_129;
    *(_DWORD *)buf = 136447490;
    v72 = "update_from_host";
    v73 = 1024;
    *(_DWORD *)v74 = 0;
    *(_WORD *)&v74[4] = 2048;
    *(_QWORD *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(_QWORD *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
    v75 = 1024;
    v76 = 2403;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_127;
  }
  v61 = global_os_log;
  if (v60 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_129;
    *(_DWORD *)buf = 136447490;
    v72 = "update_from_host";
    v73 = 1024;
    *(_DWORD *)v74 = v60;
    *(_WORD *)&v74[4] = 2048;
    *(_QWORD *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(_QWORD *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
    v75 = 1024;
    v76 = 2403;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_132;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v72 = "update_from_host";
    v73 = 1024;
    *(_DWORD *)v74 = v60;
    *(_WORD *)&v74[4] = 2048;
    *(_QWORD *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(_QWORD *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(_QWORD *)&v74[26] = "srp-mdns-proxy.c";
    v75 = 1024;
    v76 = 2403;
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v60 = *(_DWORD *)v5;
  }
  *(_DWORD *)v5 = v60 - 1;
  if (v60 == 1)
  {
    v62 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v72 = "update_from_host";
      v73 = 2048;
      *(_QWORD *)v74 = v5;
      *(_WORD *)&v74[8] = 2080;
      *(_QWORD *)&v74[10] = "update";
      *(_WORD *)&v74[18] = 2080;
      *(_QWORD *)&v74[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v74[28] = 1024;
      *(_DWORD *)&v74[30] = 2403;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize(v5);
  }
  return start_host_update(a1);
}

void adv_update_cancel(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int v4;
  int v5;
  int v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  _BOOL4 v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  int *v15;
  int v16;
  NSObject *v17;
  NSObject *v18;
  NSObject *v19;
  uint64_t v20;
  int v21;
  NSObject *v22;
  int *v23;
  NSObject *v24;
  uint64_t v25;
  uint64_t i;
  uint64_t v27;
  int v28;
  NSObject *v29;
  int *v30;
  NSObject *v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  uint64_t v35;
  NSObject *v36;
  char v37;
  int *v38;
  int v39;
  NSObject *v40;
  uint64_t v41;
  int *v42;
  int v43;
  NSObject *v44;
  uint64_t v45;
  int *v46;
  int v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  int v51;
  NSObject *v52;
  int v53;
  NSObject *v54;
  int v55;
  NSObject *v56;
  NSObject *v57;
  uint8_t buf[4];
  const char *v59;
  __int16 v60;
  _BYTE v61[34];
  __int16 v62;
  int v63;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_DWORD *)a1;
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = v4;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 947;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v5 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    v6 = v5 + 1;
    *(_DWORD *)a1 = v5 + 1;
    if (v5 + 1 >= 10001)
    {
      v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_174;
      *(_DWORD *)buf = 136447490;
      v59 = "adv_update_cancel";
      v60 = 1024;
      *(_DWORD *)v61 = v6;
      *(_WORD *)&v61[4] = 2048;
      *(_QWORD *)&v61[6] = a1;
      *(_WORD *)&v61[14] = 2080;
      *(_QWORD *)&v61[16] = "update";
      *(_WORD *)&v61[24] = 2080;
      *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
      v62 = 1024;
      v63 = 947;
      v8 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_172;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)a1 = 1;
  }
  v9 = global_os_log;
  v10 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v10)
    {
      v11 = *(_DWORD *)v2;
      *(_DWORD *)buf = 136447490;
      v59 = "adv_update_cancel";
      v60 = 1024;
      *(_DWORD *)v61 = v11;
      *(_WORD *)&v61[4] = 2048;
      *(_QWORD *)&v61[6] = v2;
      *(_WORD *)&v61[14] = 2080;
      *(_QWORD *)&v61[16] = "host";
      *(_WORD *)&v61[24] = 2080;
      *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
      v62 = 1024;
      v63 = 950;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v12 = *(_DWORD *)v2;
    if (*(_DWORD *)v2)
    {
      v13 = v12 + 1;
      *(_DWORD *)v2 = v12 + 1;
      if (v12 + 1 >= 10001)
      {
        v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v13;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v2;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "host";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 950;
        v8 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_167:
        v57 = v14;
        goto LABEL_173;
      }
    }
    else
    {
      ++adv_host_created;
      *(_DWORD *)v2 = 1;
    }
    v15 = *(int **)(a1 + 8);
    if (v15)
    {
      v16 = *v15;
      if (!*v15)
      {
        v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = 0;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v15;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->host";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 951;
        v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_167;
      }
      v17 = global_os_log;
      if (v16 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v16;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v15;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->host";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 951;
        v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_164;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v16;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v15;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->host";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 951;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v15 = *(int **)(a1 + 8);
        v16 = *v15;
      }
      *v15 = v16 - 1;
      if (v16 == 1)
      {
        v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v59 = "adv_update_cancel";
          v60 = 2048;
          *(_QWORD *)v61 = v15;
          *(_WORD *)&v61[8] = 2080;
          *(_QWORD *)&v61[10] = "update->host";
          *(_WORD *)&v61[18] = 2080;
          *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 951;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v15 = *(int **)(a1 + 8);
        }
        ++adv_host_finalized;
        adv_host_finalize((uint64_t)v15);
      }
    }
    *(_QWORD *)(a1 + 8) = 0;
    v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v20 = *(_QWORD *)(v2 + 64);
      *(_DWORD *)buf = 136446979;
      v59 = "adv_update_cancel";
      v60 = 2048;
      *(_QWORD *)v61 = a1;
      *(_WORD *)&v61[8] = 2160;
      *(_QWORD *)&v61[10] = 1752392040;
      *(_WORD *)&v61[18] = 2081;
      *(_QWORD *)&v61[20] = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: cancelling update %p for host %{private, mask.hash}s", buf, 0x2Au);
    }
    if (*(_QWORD *)(v2 + 48) == a1)
    {
      v21 = *(_DWORD *)a1;
      if (!*(_DWORD *)a1)
      {
        v7 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = 0;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = a1;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "host->update";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 957;
        v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_172;
      }
      v22 = global_os_log;
      if (v21 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v21;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = a1;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "host->update";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 957;
        v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_177;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v21;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = a1;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "host->update";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 957;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v23 = *(int **)(v2 + 48);
        v21 = *v23;
      }
      else
      {
        v23 = (int *)a1;
      }
      *v23 = v21 - 1;
      if (v21 == 1)
      {
        v24 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v59 = "adv_update_cancel";
          v60 = 2048;
          *(_QWORD *)v61 = v23;
          *(_WORD *)&v61[8] = 2080;
          *(_QWORD *)&v61[10] = "host->update";
          *(_WORD *)&v61[18] = 2080;
          *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 957;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v23 = *(int **)(v2 + 48);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v23);
      }
      *(_QWORD *)(v2 + 48) = 0;
    }
    v25 = *(_QWORD *)(v2 + 96);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      for (i = 0; i < *(int *)(v25 + 4); ++i)
      {
        v27 = *(_QWORD *)(*(_QWORD *)(v25 + 8) + 8 * i);
        if (*(_QWORD *)(v27 + 32) == a1)
        {
          v28 = *(_DWORD *)a1;
          if (!*(_DWORD *)a1)
          {
            v7 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_174;
            *(_DWORD *)buf = 136447490;
            v59 = "adv_update_cancel";
            v60 = 1024;
            *(_DWORD *)v61 = 0;
            *(_WORD *)&v61[4] = 2048;
            *(_QWORD *)&v61[6] = a1;
            *(_WORD *)&v61[14] = 2080;
            *(_QWORD *)&v61[16] = "host->addresses->vec[i]->update";
            *(_WORD *)&v61[24] = 2080;
            *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
            v62 = 1024;
            v63 = 966;
            v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_172;
          }
          v29 = global_os_log;
          if (v28 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              v59 = "adv_update_cancel";
              v60 = 1024;
              *(_DWORD *)v61 = v28;
              *(_WORD *)&v61[4] = 2048;
              *(_QWORD *)&v61[6] = a1;
              *(_WORD *)&v61[14] = 2080;
              *(_QWORD *)&v61[16] = "host->addresses->vec[i]->update";
              *(_WORD *)&v61[24] = 2080;
              *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
              v62 = 1024;
              v63 = 966;
              v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              v57 = v29;
              goto LABEL_173;
            }
LABEL_174:
            abort();
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            v59 = "adv_update_cancel";
            v60 = 1024;
            *(_DWORD *)v61 = v28;
            *(_WORD *)&v61[4] = 2048;
            *(_QWORD *)&v61[6] = a1;
            *(_WORD *)&v61[14] = 2080;
            *(_QWORD *)&v61[16] = "host->addresses->vec[i]->update";
            *(_WORD *)&v61[24] = 2080;
            *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
            v62 = 1024;
            v63 = 966;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            v25 = *(_QWORD *)(v2 + 96);
            v30 = *(int **)(*(_QWORD *)(*(_QWORD *)(v25 + 8) + 8 * i) + 32);
            v28 = *v30;
          }
          else
          {
            v30 = (int *)a1;
          }
          *v30 = v28 - 1;
          if (v28 == 1)
          {
            v31 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              v59 = "adv_update_cancel";
              v60 = 2048;
              *(_QWORD *)v61 = v30;
              *(_WORD *)&v61[8] = 2080;
              *(_QWORD *)&v61[10] = "host->addresses->vec[i]->update";
              *(_WORD *)&v61[18] = 2080;
              *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
              *(_WORD *)&v61[28] = 1024;
              *(_DWORD *)&v61[30] = 966;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              v30 = *(int **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 96) + 8) + 8 * i) + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize((uint64_t)v30);
            v25 = *(_QWORD *)(v2 + 96);
          }
          *(_QWORD *)(v27 + 32) = 0;
        }
      }
    }
  }
  else if (v10)
  {
    *(_DWORD *)buf = 136446210;
    v59 = "adv_update_cancel";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: canceling update with no host.", buf, 0xCu);
  }
  adv_update_free_instance_vectors(a1);
  v32 = *(_QWORD *)(a1 + 40);
  if (v32)
  {
    if (*(int *)(v32 + 4) < 1)
    {
      v34 = 0;
    }
    else
    {
      v33 = 0;
      v34 = 0;
      do
      {
        v35 = *(_QWORD *)(*(_QWORD *)(v32 + 8) + 8 * v33);
        if (v35)
        {
          if (v2)
          {
            if (*(_QWORD *)(v35 + 8))
              srp_mdns_shared_record_remove(*(_QWORD *)(v2 + 8), v35);
          }
          else if ((v34 & 1) == 0)
          {
            v36 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136446210;
              v59 = "adv_update_cancel";
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_FAULT, "%{public}s: unable to clean up host address registration because host object is gone from update.", buf, 0xCu);
            }
            v34 = 1;
          }
        }
        ++v33;
        v32 = *(_QWORD *)(a1 + 40);
      }
      while (v33 < *(int *)(v32 + 4));
    }
    adv_record_vec_remove_update(v32, (int *)a1);
    v38 = *(int **)(a1 + 40);
    if (v38)
    {
      v39 = *v38;
      if (!*v38)
      {
        v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = 0;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v38;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->add_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 995;
        v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_167;
      }
      v17 = global_os_log;
      if (v39 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v39;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v38;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->add_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 995;
        v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_164;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v39;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v38;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->add_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 995;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v38 = *(int **)(a1 + 40);
        v39 = *v38;
      }
      *v38 = v39 - 1;
      if (v39 == 1)
      {
        v40 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v59 = "adv_update_cancel";
          v60 = 2048;
          *(_QWORD *)v61 = v38;
          *(_WORD *)&v61[8] = 2080;
          *(_QWORD *)&v61[10] = "update->add_addresses";
          *(_WORD *)&v61[18] = 2080;
          *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 995;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v38 = *(int **)(a1 + 40);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v38);
      }
    }
    *(_QWORD *)(a1 + 40) = 0;
    v37 = v34 & 1;
  }
  else
  {
    v37 = 0;
  }
  v41 = *(_QWORD *)(a1 + 32);
  if (v41)
  {
    adv_record_vec_remove_update(v41, (int *)a1);
    v42 = *(int **)(a1 + 32);
    if (v42)
    {
      v43 = *v42;
      if (!*v42)
      {
        v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = 0;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v42;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->remove_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 1001;
        v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_167;
      }
      v17 = global_os_log;
      if (v43 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_174;
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v43;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v42;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->remove_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 1001;
        v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_164;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v43;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v42;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->remove_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 1001;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v42 = *(int **)(a1 + 32);
        v43 = *v42;
      }
      *v42 = v43 - 1;
      if (v43 == 1)
      {
        v44 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v59 = "adv_update_cancel";
          v60 = 2048;
          *(_QWORD *)v61 = v42;
          *(_WORD *)&v61[8] = 2080;
          *(_QWORD *)&v61[10] = "update->remove_addresses";
          *(_WORD *)&v61[18] = 2080;
          *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 1001;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v42 = *(int **)(a1 + 32);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v42);
      }
    }
    *(_QWORD *)(a1 + 32) = 0;
  }
  v45 = *(_QWORD *)(a1 + 48);
  if (!v45)
    goto LABEL_118;
  v46 = *(int **)(v45 + 32);
  if (v46)
  {
    v47 = *v46;
    if (!*v46)
    {
      v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_174;
      *(_DWORD *)buf = 136447490;
      v59 = "adv_update_cancel";
      v60 = 1024;
      *(_DWORD *)v61 = 0;
      *(_WORD *)&v61[4] = 2048;
      *(_QWORD *)&v61[6] = v46;
      *(_WORD *)&v61[14] = 2080;
      *(_QWORD *)&v61[16] = "update->key->update";
      *(_WORD *)&v61[24] = 2080;
      *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
      v62 = 1024;
      v63 = 1007;
      v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_167;
    }
    v48 = global_os_log;
    if (v47 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_174;
      *(_DWORD *)buf = 136447490;
      v59 = "adv_update_cancel";
      v60 = 1024;
      *(_DWORD *)v61 = v47;
      *(_WORD *)&v61[4] = 2048;
      *(_QWORD *)&v61[6] = v46;
      *(_WORD *)&v61[14] = 2080;
      *(_QWORD *)&v61[16] = "update->key->update";
      *(_WORD *)&v61[24] = 2080;
      *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
      v62 = 1024;
      v63 = 1007;
      v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v57 = v48;
      goto LABEL_173;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v59 = "adv_update_cancel";
      v60 = 1024;
      *(_DWORD *)v61 = v47;
      *(_WORD *)&v61[4] = 2048;
      *(_QWORD *)&v61[6] = v46;
      *(_WORD *)&v61[14] = 2080;
      *(_QWORD *)&v61[16] = "update->key->update";
      *(_WORD *)&v61[24] = 2080;
      *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
      v62 = 1024;
      v63 = 1007;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v45 = *(_QWORD *)(a1 + 48);
      v46 = *(int **)(v45 + 32);
      v47 = *v46;
    }
    *v46 = v47 - 1;
    if (v47 == 1)
    {
      v49 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v59 = "adv_update_cancel";
        v60 = 2048;
        *(_QWORD *)v61 = v46;
        *(_WORD *)&v61[8] = 2080;
        *(_QWORD *)&v61[10] = "update->key->update";
        *(_WORD *)&v61[18] = 2080;
        *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v61[28] = 1024;
        *(_DWORD *)&v61[30] = 1007;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        v46 = *(int **)(*(_QWORD *)(a1 + 48) + 32);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v46);
      v45 = *(_QWORD *)(a1 + 48);
    }
    *(_QWORD *)(v45 + 32) = 0;
  }
  if (!*(_QWORD *)(v45 + 8))
    goto LABEL_109;
  if (v2)
  {
    srp_mdns_shared_record_remove(*(_QWORD *)(v2 + 8), v45);
  }
  else if ((v37 & 1) == 0)
  {
    v50 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446210;
      v59 = "adv_update_cancel";
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, "%{public}s: unable to clean up host key registration because host object is gone from update.", buf, 0xCu);
    }
  }
  v45 = *(_QWORD *)(a1 + 48);
  if (v45)
  {
LABEL_109:
    v51 = *(_DWORD *)v45;
    if (!*(_DWORD *)v45)
    {
      v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_174;
      *(_DWORD *)buf = 136447490;
      v59 = "adv_update_cancel";
      v60 = 1024;
      *(_DWORD *)v61 = 0;
      *(_WORD *)&v61[4] = 2048;
      *(_QWORD *)&v61[6] = v45;
      *(_WORD *)&v61[14] = 2080;
      *(_QWORD *)&v61[16] = "update->key";
      *(_WORD *)&v61[24] = 2080;
      *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
      v62 = 1024;
      v63 = 1021;
      v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_167;
    }
    v17 = global_os_log;
    if (v51 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v59 = "adv_update_cancel";
        v60 = 1024;
        *(_DWORD *)v61 = v51;
        *(_WORD *)&v61[4] = 2048;
        *(_QWORD *)&v61[6] = v45;
        *(_WORD *)&v61[14] = 2080;
        *(_QWORD *)&v61[16] = "update->key";
        *(_WORD *)&v61[24] = 2080;
        *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
        v62 = 1024;
        v63 = 1021;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v45 = *(_QWORD *)(a1 + 48);
        v51 = *(_DWORD *)v45;
      }
      *(_DWORD *)v45 = v51 - 1;
      if (v51 == 1)
      {
        v52 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v59 = "adv_update_cancel";
          v60 = 2048;
          *(_QWORD *)v61 = v45;
          *(_WORD *)&v61[8] = 2080;
          *(_QWORD *)&v61[10] = "update->key";
          *(_WORD *)&v61[18] = 2080;
          *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 1021;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          v45 = *(_QWORD *)(a1 + 48);
        }
        ++adv_record_finalized;
        adv_record_finalize(v45);
      }
      goto LABEL_117;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_174;
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = v51;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = v45;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "update->key";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 1021;
    v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_164:
    v57 = v17;
LABEL_173:
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_FAULT, v8, buf, 0x36u);
    goto LABEL_174;
  }
LABEL_117:
  *(_QWORD *)(a1 + 48) = 0;
LABEL_118:
  if (!v2)
    goto LABEL_127;
  v53 = *(_DWORD *)v2;
  if (!*(_DWORD *)v2)
  {
    v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_174;
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = 0;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = v2;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "host";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 1025;
    v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_167;
  }
  v22 = global_os_log;
  if (v53 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_174;
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = v53;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = v2;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "host";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 1025;
    v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_177:
    v57 = v22;
    goto LABEL_173;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = v53;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = v2;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "host";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 1025;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v53 = *(_DWORD *)v2;
  }
  *(_DWORD *)v2 = v53 - 1;
  if (v53 == 1)
  {
    v54 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v59 = "adv_update_cancel";
      v60 = 2048;
      *(_QWORD *)v61 = v2;
      *(_WORD *)&v61[8] = 2080;
      *(_QWORD *)&v61[10] = "host";
      *(_WORD *)&v61[18] = 2080;
      *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v61[28] = 1024;
      *(_DWORD *)&v61[30] = 1025;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_host_finalized;
    adv_host_finalize(v2);
  }
LABEL_127:
  v55 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_174;
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = 0;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 1027;
    v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_172:
    v57 = v7;
    goto LABEL_173;
  }
  v7 = global_os_log;
  if (v55 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_174;
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = v55;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 1027;
    v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_172;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v59 = "adv_update_cancel";
    v60 = 1024;
    *(_DWORD *)v61 = v55;
    *(_WORD *)&v61[4] = 2048;
    *(_QWORD *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(_QWORD *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(_QWORD *)&v61[26] = "srp-mdns-proxy.c";
    v62 = 1024;
    v63 = 1027;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v55 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v55 - 1;
  if (v55 == 1)
  {
    v56 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v59 = "adv_update_cancel";
      v60 = 2048;
      *(_QWORD *)v61 = a1;
      *(_WORD *)&v61[8] = 2080;
      *(_QWORD *)&v61[10] = "update";
      *(_WORD *)&v61[18] = 2080;
      *(_QWORD *)&v61[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v61[28] = 1024;
      *(_DWORD *)&v61[30] = 1027;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize(a1);
  }
}

_QWORD *host_ready(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *result;
  uint64_t v4;
  BOOL v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  int v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  int v13;
  _BYTE buf[38];
  __int16 v15;
  char *v16;
  __int16 v17;
  int v18;

  v2 = (_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  do
  {
    result = v2;
    v4 = *v2;
    v2 = (_QWORD *)(*v2 + 40);
    if (v4)
      v5 = v4 == a1;
    else
      v5 = 1;
  }
  while (!v5);
  if (v4)
  {
    if (*(_QWORD *)(a1 + 48))
    {
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v7 = *(_QWORD *)(a1 + 64);
        *(_DWORD *)buf = 136446723;
        *(_QWORD *)&buf[4] = "host_ready";
        *(_WORD *)&buf[12] = 2160;
        *(_QWORD *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 2081;
        *(_QWORD *)&buf[24] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: reached with pending updates on host %{private, mask.hash}s.", buf, 0x20u);
      }
      ioloop_add_wake_event(*(_QWORD *)(a1 + 32), a1, (uint64_t)lease_callback, (uint64_t)srp_adv_host_context_release, 0x2710u);
      v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v9 = *(_DWORD *)a1;
        *(_DWORD *)buf = 136447490;
        *(_QWORD *)&buf[4] = "host_ready";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v9;
        *(_WORD *)&buf[18] = 2048;
        *(_QWORD *)&buf[20] = a1;
        *(_WORD *)&buf[28] = 2080;
        *(_QWORD *)&buf[30] = "host";
        v15 = 2080;
        v16 = "srp-mdns-proxy.c";
        v17 = 1024;
        v18 = 1274;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      if (*(_DWORD *)a1)
      {
        v10 = *(_DWORD *)a1 + 1;
        *(_DWORD *)a1 = v10;
        if (v10 >= 10001)
        {
          v13 = v10;
          v11 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(_QWORD *)&buf[4] = "host_ready";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v13;
            *(_WORD *)&buf[18] = 2048;
            *(_QWORD *)&buf[20] = a1;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = "host";
            v15 = 2080;
            v16 = "srp-mdns-proxy.c";
            v17 = 1024;
            v18 = 1274;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++adv_host_created;
        *(_DWORD *)a1 = 1;
      }
      *(_QWORD *)buf = 0;
      *(_QWORD *)&buf[8] = 0;
      gettimeofday((timeval *)buf, 0);
      result = 0;
      *(_QWORD *)(a1 + 256) = 1000 * *(_QWORD *)buf + *(_DWORD *)&buf[8] / 1000 + 10000;
    }
  }
  else
  {
    v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "host_ready";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: called with nonexistent host.", buf, 0xCu);
    }
    return 0;
  }
  return result;
}

void host_remove(int *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  host_invalidate((uint64_t)a1);
  if (!a1)
    return;
  v2 = *a1;
  if (!*a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "host_remove";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 1249;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "host_remove";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 1249;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "host_remove";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "srp-mdns-proxy.c";
    v10 = 1024;
    v11 = 1249;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "host_remove";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "host";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 1249;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++adv_host_finalized;
    adv_host_finalize((uint64_t)a1);
  }
}

_BYTE *srp_message_tsr_attribute_generate(uint64_t a1, int a2, char *a3)
{
  _BYTE *result;
  _BYTE *v7;
  unsigned int v8;
  timespec v9;

  ++saref_created;
  result = malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (result)
  {
    v7 = result;
    if (a1 && *(_QWORD *)(a1 + 72))
    {
      v9.tv_sec = 0;
      v9.tv_nsec = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, &v9);
      v8 = LODWORD(v9.tv_sec) - *(_QWORD *)(a1 + 72);
      srp_format_time_offset(a3, v8);
    }
    else
    {
      v8 = 0;
      *(_DWORD *)a3 = 7827310;
    }
    if (__isPlatformVersionAtLeast(2, 18, 0, 0))
    {
      v7[12] = 1;
      *((_DWORD *)v7 + 1) = a2;
    }
    v7[13] = 1;
    *((_DWORD *)v7 + 2) = v8;
    return v7;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void register_host_record_completion(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t *v6;
  NSObject *v7;
  int v9;
  int v10;
  int v11;
  NSObject *v12;
  const char *v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  int *v17;
  int *v18;
  NSObject *v19;
  _BOOL4 v20;
  int *v21;
  int v22;
  NSObject *v23;
  NSObject *v24;
  int v25;
  int v26;
  NSObject *v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  const char *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  NSObject *v39;
  uint32_t v40;
  uint64_t v41;
  uint64_t v42;
  const char *v43;
  NSObject *v44;
  os_log_type_t v45;
  uint32_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  NSObject *v52;
  uint32_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned __int8 *v56;
  int v57;
  const char *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  int v66;
  const char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int *v72;
  int v73;
  unsigned int v74;
  uint32_t v75;
  unsigned int v76;
  NSObject *v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  NSObject *v83;
  NSObject *v84;
  int v85;
  unsigned int v86;
  uint64_t v87;
  uint64_t v88;
  NSObject *v89;
  int v90;
  const char *v91;
  __int16 v92;
  _BYTE v93[44];
  __int16 v94;
  const char *v95;
  __int16 v96;
  uint64_t v97;
  __int16 v98;
  int v99;
  __int16 v100;
  unsigned __int8 *v101;
  __int16 v102;
  uint64_t v103;
  __int16 v104;
  int v105;
  __int16 v106;
  unsigned __int8 *v107;
  __int16 v108;
  const char *v109;

  if (!*(_QWORD *)(a5 + 8))
  {
    v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v90 = 136446210;
    v91 = "register_host_record_completion";
    v15 = "%{public}s: null rref";
    v16 = v14;
    goto LABEL_13;
  }
  v6 = *(uint64_t **)(a5 + 16);
  v7 = global_os_log;
  if (!v6)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v90 = 136446210;
    v91 = "register_host_record_completion";
    v15 = "%{public}s: no host";
    v16 = v7;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v90, 0xCu);
    return;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v9 = *(_DWORD *)a5;
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = v9;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2448;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
  }
  v10 = *(_DWORD *)a5;
  if (*(_DWORD *)a5)
  {
    v11 = v10 + 1;
    *(_DWORD *)a5 = v10 + 1;
    if (v10 + 1 >= 10001)
    {
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_173;
      v90 = 136447490;
      v91 = "register_host_record_completion";
      v92 = 1024;
      *(_DWORD *)v93 = v11;
      *(_WORD *)&v93[4] = 2048;
      *(_QWORD *)&v93[6] = a5;
      *(_WORD *)&v93[14] = 2080;
      *(_QWORD *)&v93[16] = "record";
      *(_WORD *)&v93[24] = 2080;
      *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[34] = 1024;
      *(_DWORD *)&v93[36] = 2448;
      v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_171:
      v89 = v12;
LABEL_172:
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_FAULT, v13, (uint8_t *)&v90, 0x36u);
      goto LABEL_173;
    }
  }
  else
  {
    ++adv_record_created;
    *(_DWORD *)a5 = 1;
  }
  v17 = *(int **)(a5 + 32);
  if (!v17)
    goto LABEL_46;
  v18 = (int *)v6[6];
  v19 = global_os_log;
  v20 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v18 != v17)
  {
    if (v20)
    {
      v90 = 136446210;
      v91 = "register_host_record_completion";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for host record completed with invalid state.", (uint8_t *)&v90, 0xCu);
      v17 = *(int **)(a5 + 32);
    }
    adv_update_cancel((uint64_t)v17);
    v21 = *(int **)(a5 + 32);
    if (!v21)
      goto LABEL_28;
    v22 = *v21;
    if (*v21)
    {
      v23 = global_os_log;
      if (v22 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_173;
        v90 = 136447490;
        v91 = "register_host_record_completion";
        v92 = 1024;
        *(_DWORD *)v93 = v22;
        *(_WORD *)&v93[4] = 2048;
        *(_QWORD *)&v93[6] = v21;
        *(_WORD *)&v93[14] = 2080;
        *(_QWORD *)&v93[16] = "record->update";
        *(_WORD *)&v93[24] = 2080;
        *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2456;
        v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v89 = v23;
        goto LABEL_172;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v90 = 136447490;
        v91 = "register_host_record_completion";
        v92 = 1024;
        *(_DWORD *)v93 = v22;
        *(_WORD *)&v93[4] = 2048;
        *(_QWORD *)&v93[6] = v21;
        *(_WORD *)&v93[14] = 2080;
        *(_QWORD *)&v93[16] = "record->update";
        *(_WORD *)&v93[24] = 2080;
        *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2456;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
        v21 = *(int **)(a5 + 32);
        v22 = *v21;
      }
      *v21 = v22 - 1;
      if (v22 == 1)
      {
        v24 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v90 = 136447234;
          v91 = "register_host_record_completion";
          v92 = 2048;
          *(_QWORD *)v93 = v21;
          *(_WORD *)&v93[8] = 2080;
          *(_QWORD *)&v93[10] = "record->update";
          *(_WORD *)&v93[18] = 2080;
          *(_QWORD *)&v93[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[28] = 1024;
          *(_DWORD *)&v93[30] = 2456;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
          v21 = *(int **)(a5 + 32);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v21);
      }
LABEL_28:
      *(_QWORD *)(a5 + 32) = 0;
      srp_mdns_shared_record_remove(v6[1], a5);
      v25 = *(_DWORD *)a5;
      if (!*(_DWORD *)a5)
      {
        v12 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_173;
        v90 = 136447490;
        v91 = "register_host_record_completion";
        v92 = 1024;
        *(_DWORD *)v93 = 0;
        *(_WORD *)&v93[4] = 2048;
        *(_QWORD *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(_QWORD *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2459;
        v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_171;
      }
      v12 = global_os_log;
      if (v25 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          goto LABEL_173;
        v90 = 136447490;
        v91 = "register_host_record_completion";
        v92 = 1024;
        *(_DWORD *)v93 = v25;
        *(_WORD *)&v93[4] = 2048;
        *(_QWORD *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(_QWORD *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2459;
        v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_171;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v90 = 136447490;
        v91 = "register_host_record_completion";
        v92 = 1024;
        *(_DWORD *)v93 = v25;
        *(_WORD *)&v93[4] = 2048;
        *(_QWORD *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(_QWORD *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2459;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
        v25 = *(_DWORD *)a5;
        v12 = global_os_log;
      }
      v26 = v25 - 1;
      *(_DWORD *)a5 = v26;
      if (!v26)
      {
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          v90 = 136447234;
          v91 = "register_host_record_completion";
          v92 = 2048;
          *(_QWORD *)v93 = a5;
          *(_WORD *)&v93[8] = 2080;
          *(_QWORD *)&v93[10] = "record";
          *(_WORD *)&v93[18] = 2080;
          *(_QWORD *)&v93[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[28] = 1024;
          *(_DWORD *)&v93[30] = 2459;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
        }
        ++adv_record_finalized;
        adv_record_finalize(a5);
        v26 = *(_DWORD *)a5;
        v12 = global_os_log;
        if (!*(_DWORD *)a5)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            goto LABEL_173;
          v90 = 136447490;
          v91 = "register_host_record_completion";
          v92 = 1024;
          *(_DWORD *)v93 = 0;
          *(_WORD *)&v93[4] = 2048;
          *(_QWORD *)&v93[6] = a5;
          *(_WORD *)&v93[14] = 2080;
          *(_QWORD *)&v93[16] = "record";
          *(_WORD *)&v93[24] = 2080;
          *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[34] = 1024;
          *(_DWORD *)&v93[36] = 2460;
          v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_171;
        }
      }
      if (v26 >= 10001)
      {
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
          goto LABEL_173;
        v90 = 136447490;
        v91 = "register_host_record_completion";
        v92 = 1024;
        *(_DWORD *)v93 = v26;
        *(_WORD *)&v93[4] = 2048;
        *(_QWORD *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(_QWORD *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2460;
        v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_171;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        v90 = 136447490;
        v91 = "register_host_record_completion";
        v92 = 1024;
        *(_DWORD *)v93 = v26;
        *(_WORD *)&v93[4] = 2048;
        *(_QWORD *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(_QWORD *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2460;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
        v26 = *(_DWORD *)a5;
      }
      *(_DWORD *)a5 = v26 - 1;
      if (v26 == 1)
      {
        v27 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v90 = 136447234;
          v91 = "register_host_record_completion";
          v92 = 2048;
          *(_QWORD *)v93 = a5;
          *(_WORD *)&v93[8] = 2080;
          *(_QWORD *)&v93[10] = "record";
          *(_WORD *)&v93[18] = 2080;
          *(_QWORD *)&v93[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[28] = 1024;
          *(_DWORD *)&v93[30] = 2460;
LABEL_143:
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
          goto LABEL_144;
        }
        goto LABEL_144;
      }
      return;
    }
    v81 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_173;
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = 0;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = v21;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "record->update";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2456;
    v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_176:
    v89 = v81;
    goto LABEL_172;
  }
  if (v20)
  {
    v28 = *v17;
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = v28;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2466;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
  }
  v29 = *v17;
  if (*v17)
  {
    v30 = v29 + 1;
    *v17 = v29 + 1;
    if (v29 + 1 >= 10001)
    {
      v81 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_173:
        abort();
      v90 = 136447490;
      v91 = "register_host_record_completion";
      v92 = 1024;
      *(_DWORD *)v93 = v30;
      *(_WORD *)&v93[4] = 2048;
      *(_QWORD *)&v93[6] = v17;
      *(_WORD *)&v93[14] = 2080;
      *(_QWORD *)&v93[16] = "update";
      *(_WORD *)&v93[24] = 2080;
      *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[34] = 1024;
      *(_DWORD *)&v93[36] = 2466;
      v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_176;
    }
LABEL_46:
    if (!a4)
      goto LABEL_48;
LABEL_47:
    if (a4 == -65548)
      goto LABEL_48;
    v34 = *(unsigned __int16 *)(a5 + 48);
    switch(v34)
    {
      case 28:
        v63 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v64 = v6[8];
          v65 = *(unsigned __int8 **)(a5 + 40);
          v66 = *v65;
          if ((v66 & 0xFE) == 0xFC)
          {
            v67 = "ULA: ";
          }
          else if (v66 == 254 && (v65[1] & 0xC0) == 0x80)
          {
            v67 = "LUA: ";
          }
          else if ((v66 & 0xE0) == 0x20)
          {
            v67 = "GUA: ";
          }
          else
          {
            v67 = (const char *)&unk_10007C3B5;
          }
          v90 = 136449539;
          v91 = "register_host_record_completion";
          v92 = 2160;
          *(_QWORD *)v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(_QWORD *)&v93[10] = v64;
          *(_WORD *)&v93[18] = 2082;
          *(_QWORD *)&v93[20] = v67;
          *(_WORD *)&v93[28] = 2160;
          *(_QWORD *)&v93[30] = 1752392040;
          *(_WORD *)&v93[38] = 1041;
          *(_DWORD *)&v93[40] = 6;
          v94 = 2097;
          v95 = (const char *)v65;
          v96 = 2160;
          v97 = 1752392040;
          v98 = 1042;
          v99 = 2;
          v100 = 2098;
          v101 = v65 + 6;
          v102 = 2160;
          v103 = 1752392040;
          v104 = 1041;
          v105 = 8;
          v106 = 2097;
          v107 = v65 + 8;
          v108 = 1024;
          LODWORD(v109) = a4;
          v38 = "%{public}s: registration for host %{private, mask.hash}s address {%{public}s%{private, mask.hash, srp:in"
                "6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segm"
                "ent}.8P} failed, error code = %d.";
          v39 = v63;
          v40 = 126;
          goto LABEL_120;
        }
        break;
      case 25:
        v68 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v69 = v6[8];
          v90 = 136446979;
          v91 = "register_host_record_completion";
          v92 = 2160;
          *(_QWORD *)v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(_QWORD *)&v93[10] = v69;
          *(_WORD *)&v93[18] = 1024;
          *(_DWORD *)&v93[20] = a4;
          v38 = "%{public}s: registration for host %{private, mask.hash}s key failed, error code = %d.";
          v39 = v68;
          v40 = 38;
          goto LABEL_120;
        }
        break;
      case 1:
        v35 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v36 = v6[8];
          v37 = *(_QWORD *)(a5 + 40);
          v90 = 136447747;
          v91 = "register_host_record_completion";
          v92 = 2160;
          *(_QWORD *)v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(_QWORD *)&v93[10] = v36;
          *(_WORD *)&v93[18] = 2160;
          *(_QWORD *)&v93[20] = 1752392040;
          *(_WORD *)&v93[28] = 1041;
          *(_DWORD *)&v93[30] = 4;
          *(_WORD *)&v93[34] = 2097;
          *(_QWORD *)&v93[36] = v37;
          v94 = 1024;
          LODWORD(v95) = a4;
          v38 = "%{public}s: registration for host %{private, mask.hash}s address %{private, mask.hash, network:in_addr}."
                "4P failed, error code = %d.";
          v39 = v35;
          v40 = 64;
LABEL_120:
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v38, (uint8_t *)&v90, v40);
        }
        break;
      default:
        v70 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v71 = v6[8];
          v90 = 136447235;
          v91 = "register_host_record_completion";
          v92 = 2160;
          *(_QWORD *)v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(_QWORD *)&v93[10] = v71;
          *(_WORD *)&v93[18] = 1024;
          *(_DWORD *)&v93[20] = v34;
          *(_WORD *)&v93[24] = 1024;
          *(_DWORD *)&v93[26] = a4;
          v38 = "%{public}s: registration for host %{private, mask.hash}s unknown record type %d failed, error code = %d.";
          v39 = v70;
          v40 = 44;
          goto LABEL_120;
        }
        break;
    }
    if (a4 == -65563 || a4 == -65569)
    {
      service_disconnected(v6[1], *(_QWORD *)(a5 + 24));
      if (v17)
        wait_retry((uint64_t)v6);
    }
    else if (v17)
    {
      update_failed((uint64_t)v17, 2u, 1);
    }
    srp_mdns_shared_record_remove(v6[1], a5);
    if (!v17)
      goto LABEL_136;
    goto LABEL_128;
  }
  ++adv_update_created;
  *v17 = 1;
  if (a4)
    goto LABEL_47;
LABEL_48:
  if (!*(_BYTE *)(a5 + 52))
  {
    v33 = " got spurious success callback after completion.";
    if (!a4)
      goto LABEL_68;
LABEL_61:
    srp_mdns_shared_record_remove(v6[1], a5);
    v41 = *(_QWORD *)(a5 + 16);
    if (v41 && !*(_BYTE *)(v41 + 264))
    {
      if (!*(_BYTE *)(v41 + 266))
      {
        if (*(_QWORD *)(v41 + 16)
          || (v72 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2007), (*(_QWORD *)(v41 + 16) = v72) != 0))
        {
          v73 = *(_DWORD *)(v41 + 188);
          if (v73)
            v74 = 2 * v73;
          else
            v74 = 5000;
          *(_DWORD *)(v41 + 188) = v74;
          v75 = arc4random();
          v76 = *(_DWORD *)(v41 + 188);
          v77 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v78 = *(_DWORD *)v41;
            v90 = 136447490;
            v91 = "srp_schedule_host_record_retry";
            v92 = 1024;
            *(_DWORD *)v93 = v78;
            *(_WORD *)&v93[4] = 2048;
            *(_QWORD *)&v93[6] = v41;
            *(_WORD *)&v93[14] = 2080;
            *(_QWORD *)&v93[16] = "host";
            *(_WORD *)&v93[24] = 2080;
            *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v93[34] = 1024;
            *(_DWORD *)&v93[36] = 2014;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
          }
          v79 = *(_DWORD *)v41;
          if (*(_DWORD *)v41)
          {
            v80 = v79 + 1;
            *(_DWORD *)v41 = v79 + 1;
            if (v79 + 1 >= 10001)
            {
              v81 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                goto LABEL_173;
              v90 = 136447490;
              v91 = "srp_schedule_host_record_retry";
              v92 = 1024;
              *(_DWORD *)v93 = v80;
              *(_WORD *)&v93[4] = 2048;
              *(_QWORD *)&v93[6] = v41;
              *(_WORD *)&v93[14] = 2080;
              *(_QWORD *)&v93[16] = "host";
              *(_WORD *)&v93[24] = 2080;
              *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
              *(_WORD *)&v93[34] = 1024;
              *(_DWORD *)&v93[36] = 2014;
              v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_176;
            }
          }
          else
          {
            ++adv_host_created;
            *(_DWORD *)v41 = 1;
          }
          v86 = -((double)(v75 % v76) - (double)v74 * 1.5);
          ioloop_add_wake_event(*(_QWORD *)(v41 + 16), v41, (uint64_t)srp_host_record_retry_callback, (uint64_t)srp_adv_host_context_release, v86);
          v87 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            goto LABEL_67;
          v90 = 136446722;
          v91 = "srp_schedule_host_record_retry";
          v92 = 2048;
          *(_QWORD *)v93 = a5;
          *(_WORD *)&v93[8] = 2048;
          *(double *)&v93[10] = (double)v86 / 1000.0;
          v43 = "%{public}s: will attempt to reregister record %p in %.3lf seconds";
          v44 = v87;
          v45 = OS_LOG_TYPE_DEFAULT;
          v46 = 32;
        }
        else
        {
          v88 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_67;
          v90 = 136446210;
          v91 = "srp_schedule_host_record_retry";
          v43 = "%{public}s: unable to make wakeup &host->re_register_wakeup";
          v44 = v88;
          v45 = OS_LOG_TYPE_ERROR;
          v46 = 12;
        }
        goto LABEL_66;
      }
      v42 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_67;
      v90 = 136446466;
      v91 = "srp_schedule_host_record_retry";
      v92 = 2048;
      *(_QWORD *)v93 = a5;
      v43 = "%{public}s: already scheduled attempt to reregister record %p";
    }
    else
    {
      v42 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
LABEL_67:
        v33 = " completed with conflict.";
        goto LABEL_68;
      }
      v90 = 136446466;
      v91 = "srp_schedule_host_record_retry";
      v92 = 2048;
      *(_QWORD *)v93 = a5;
      v43 = "%{public}s: will not attempt to reregister record %p";
    }
    v44 = v42;
    v45 = OS_LOG_TYPE_DEFAULT;
    v46 = 22;
LABEL_66:
    _os_log_impl((void *)&_mh_execute_header, v44, v45, v43, (uint8_t *)&v90, v46);
    goto LABEL_67;
  }
  *(_BYTE *)(a5 + 52) = 0;
  if (v17)
  {
    v31 = v17[24];
    v32 = v17[25] + 1;
    v17[25] = v32;
    if (v32 == v31 && v17[23] == v17[22])
      srp_mdns_update_finished(v17);
  }
  v33 = " has completed.";
  if (a4)
    goto LABEL_61;
LABEL_68:
  v47 = *(unsigned __int16 *)(a5 + 48);
  switch(v47)
  {
    case 28:
      v54 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_111;
      v55 = v6[8];
      v56 = *(unsigned __int8 **)(a5 + 40);
      v57 = *v56;
      if ((v57 & 0xFE) == 0xFC)
      {
        v58 = "ULA: ";
      }
      else if (v57 == 254 && (v56[1] & 0xC0) == 0x80)
      {
        v58 = "LUA: ";
      }
      else if ((v57 & 0xE0) == 0x20)
      {
        v58 = "GUA: ";
      }
      else
      {
        v58 = (const char *)&unk_10007C3B5;
      }
      v90 = 136449539;
      v91 = "register_host_record_completion";
      v92 = 2160;
      *(_QWORD *)v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(_QWORD *)&v93[10] = v55;
      *(_WORD *)&v93[18] = 2082;
      *(_QWORD *)&v93[20] = v58;
      *(_WORD *)&v93[28] = 2160;
      *(_QWORD *)&v93[30] = 1752392040;
      *(_WORD *)&v93[38] = 1041;
      *(_DWORD *)&v93[40] = 6;
      v94 = 2097;
      v95 = (const char *)v56;
      v96 = 2160;
      v97 = 1752392040;
      v98 = 1042;
      v99 = 2;
      v100 = 2098;
      v101 = v56 + 6;
      v102 = 2160;
      v103 = 1752392040;
      v104 = 1041;
      v105 = 8;
      v106 = 2097;
      v107 = v56 + 8;
      v108 = 2082;
      v109 = v33;
      v51 = "%{public}s: registration for host %{private, mask.hash}s address {%{public}s%{private, mask.hash, srp:in6_ad"
            "dr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}%{public}s";
      v52 = v54;
      v53 = 130;
      break;
    case 25:
      v59 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_111;
      v60 = v6[8];
      v90 = 136446979;
      v91 = "register_host_record_completion";
      v92 = 2160;
      *(_QWORD *)v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(_QWORD *)&v93[10] = v60;
      *(_WORD *)&v93[18] = 2082;
      *(_QWORD *)&v93[20] = v33;
      v51 = "%{public}s: registration for host %{private, mask.hash}s key%{public}s";
      v52 = v59;
      v53 = 42;
      break;
    case 1:
      v48 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_111;
      v49 = v6[8];
      v50 = *(_QWORD *)(a5 + 40);
      v90 = 136447747;
      v91 = "register_host_record_completion";
      v92 = 2160;
      *(_QWORD *)v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(_QWORD *)&v93[10] = v49;
      *(_WORD *)&v93[18] = 2160;
      *(_QWORD *)&v93[20] = 1752392040;
      *(_WORD *)&v93[28] = 1041;
      *(_DWORD *)&v93[30] = 4;
      *(_WORD *)&v93[34] = 2097;
      *(_QWORD *)&v93[36] = v50;
      v94 = 2082;
      v95 = v33;
      v51 = "%{public}s: registration for host %{private, mask.hash}s address %{private, mask.hash, network:in_addr}.4P%{public}s";
      v52 = v48;
      v53 = 68;
      break;
    default:
      v61 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_111;
      v62 = v6[8];
      v90 = 136447235;
      v91 = "register_host_record_completion";
      v92 = 2160;
      *(_QWORD *)v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(_QWORD *)&v93[10] = v62;
      *(_WORD *)&v93[18] = 1024;
      *(_DWORD *)&v93[20] = v47;
      *(_WORD *)&v93[24] = 2082;
      *(_QWORD *)&v93[26] = v33;
      v51 = "%{public}s: registration for host %{private, mask.hash}s unknown record type %d %{public}s";
      v52 = v61;
      v53 = 48;
      break;
  }
  _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v51, (uint8_t *)&v90, v53);
LABEL_111:
  if (!v17)
    goto LABEL_136;
LABEL_128:
  v82 = *v17;
  if (!*v17)
  {
    v81 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_173;
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = 0;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2567;
    v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_176;
  }
  v83 = global_os_log;
  if (v82 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_173;
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = v82;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2567;
    v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    v89 = v83;
    goto LABEL_172;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = v82;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2567;
    _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
    v82 = *v17;
  }
  *v17 = v82 - 1;
  if (v82 == 1)
  {
    v84 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v90 = 136447234;
      v91 = "register_host_record_completion";
      v92 = 2048;
      *(_QWORD *)v93 = v17;
      *(_WORD *)&v93[8] = 2080;
      *(_QWORD *)&v93[10] = "update";
      *(_WORD *)&v93[18] = 2080;
      *(_QWORD *)&v93[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[28] = 1024;
      *(_DWORD *)&v93[30] = 2567;
      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize((uint64_t)v17);
  }
LABEL_136:
  v85 = *(_DWORD *)a5;
  if (!*(_DWORD *)a5)
  {
    v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_173;
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = 0;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2569;
    v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_171;
  }
  v12 = global_os_log;
  if (v85 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_173;
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = v85;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2569;
    v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_171;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v90 = 136447490;
    v91 = "register_host_record_completion";
    v92 = 1024;
    *(_DWORD *)v93 = v85;
    *(_WORD *)&v93[4] = 2048;
    *(_QWORD *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(_QWORD *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(_QWORD *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2569;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
    v85 = *(_DWORD *)a5;
  }
  *(_DWORD *)a5 = v85 - 1;
  if (v85 == 1)
  {
    v27 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v90 = 136447234;
      v91 = "register_host_record_completion";
      v92 = 2048;
      *(_QWORD *)v93 = a5;
      *(_WORD *)&v93[8] = 2080;
      *(_QWORD *)&v93[10] = "record";
      *(_WORD *)&v93[18] = 2080;
      *(_QWORD *)&v93[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[28] = 1024;
      *(_DWORD *)&v93[30] = 2569;
      goto LABEL_143;
    }
LABEL_144:
    ++adv_record_finalized;
    adv_record_finalize(a5);
  }
}

void srp_host_record_retry_callback(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  uint64_t v12;

  if (a1 && (*(_BYTE *)(a1 + 266) = 0, !*(_BYTE *)(a1 + 264)))
  {
    v3 = *(_QWORD *)(a1 + 96);
    if (v3 && *(int *)(v3 + 4) >= 1)
    {
      v4 = 0;
      do
      {
        v5 = *(_QWORD *)(*(_QWORD *)(v3 + 8) + 8 * v4);
        if (v5)
        {
          v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            v10 = "srp_host_record_retry_callback";
            v11 = 2048;
            v12 = v5;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registering host record %p.", buf, 0x16u);
          }
          register_host_record(a1, v5, 0);
          v3 = *(_QWORD *)(a1 + 96);
        }
        ++v4;
      }
      while (v4 < *(int *)(v3 + 4));
    }
    v7 = *(_QWORD *)(a1 + 104);
    if (v7)
    {
      v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v10 = "srp_host_record_retry_callback";
        v11 = 2048;
        v12 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registering host record %p.", buf, 0x16u);
        v7 = *(_QWORD *)(a1 + 104);
      }
      register_host_record(a1, v7, 0);
    }
  }
  else
  {
    v2 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v10 = "srp_host_record_retry_callback";
      v11 = 2048;
      v12 = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: no longer updating host %p because host is no longer valid.", buf, 0x16u);
    }
  }
}

void srp_mdns_flush(uint64_t a1)
{
  NSObject *v2;
  uint64_t v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  uint64_t v12;
  __int16 v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  __int16 v17;
  uint64_t v18;

  v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    v10 = "srp_mdns_flush";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: flushing all host entries.", buf, 0xCu);
  }
  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    do
    {
      v4 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v5 = *(_QWORD *)(v3 + 56);
        v6 = *(_QWORD *)(v3 + 64);
        *(_DWORD *)buf = 136447235;
        v10 = "srp_mdns_flush";
        v11 = 2160;
        v12 = 1752392040;
        v13 = 2081;
        v14 = v5;
        v15 = 2160;
        v16 = 1752392040;
        v17 = 2081;
        v18 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: Flushing services and host entry for %{private, mask.hash}s (%{private, mask.hash}s)", buf, 0x34u);
      }
      v7 = *(_QWORD *)(v3 + 48);
      if (v7)
        update_failed(v7, 5u, 0);
      v8 = *(_QWORD *)(v3 + 40);
      host_remove((int *)v3);
      v3 = v8;
    }
    while (v8);
  }
  *(_QWORD *)(a1 + 8) = 0;
}

int main(int argc, const char **argv, const char **envp)
{
  _QWORD *v5;
  char *v6;
  NSObject *v7;
  int v8;
  NSObject *v9;
  const char *v10;
  int v11;
  NSObject *v12;
  const char *v13;
  unsigned int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  const char *v19;
  int v20;
  int v21;
  char *v22;
  const char *v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  NSObject *v27;
  NSObject *v28;
  uint64_t v29;
  _xpc_connection_s *xpc_service;
  NSObject *v31;
  NSObject *v32;
  int *v33;
  char *v34;
  rlim_t rlim_cur;
  rlim_t rlim_max;
  NSObject *v37;
  NSObject *v38;
  NSObject *v40;
  int *v41;
  char *v42;
  int *v43;
  uint64_t v44;
  NSObject *v45;
  rlimit v46;
  char *__endptr;
  uint8_t buf[4];
  const char *v49;
  __int16 v50;
  const char *v51;
  __int16 v52;
  const char *v53;

  __endptr = 0;
  v5 = malloc_type_calloc(1uLL, 0x128uLL, 0x10B0040518C6F66uLL);
  if (!v5 || (v6 = strdup("srp-mdns-proxy"), (*v5 = v6) == 0))
  {
    v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v49 = "server_state_create";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%{public}s: no memory for server state", buf, 0xCu);
    }
    free(v5);
    srp_servers = 0;
    return 1;
  }
  *(_OWORD *)((char *)v5 + 252) = xmmword_10007C760;
  *((_DWORD *)v5 + 68) = 0;
  v7 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v49 = "server_state_create";
    v50 = 1024;
    LODWORD(v51) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: priority set to %d", buf, 0x12u);
  }
  srp_servers = (uint64_t)v5;
  v8 = _os_feature_enabled_impl("mDNSResponder", "srp_replication");
  *(_BYTE *)(srp_servers + 280) = v8;
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = "disabled";
    if (v8)
      v10 = "enabled";
    *(_DWORD *)buf = 136446466;
    v49 = "main";
    v50 = 2082;
    v51 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: srp replication is %{public}s", buf, 0x16u);
  }
  v11 = _os_feature_enabled_impl("mDNSResponder", "srp_replication");
  *(_BYTE *)(srp_servers + 287) = v11;
  v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v13 = "disabled";
    if (v11)
      v13 = "enabled";
    *(_DWORD *)buf = 136446466;
    v49 = "main";
    v50 = 2082;
    v51 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: srp on demand is %{public}s", buf, 0x16u);
  }
  _os_feature_enabled_impl("mDNSResponder", "srp_device_mode");
  v14 = if_nametoindex("lo0");
  v15 = srp_servers;
  *(_DWORD *)(srp_servers + 248) = v14;
  if (argc < 2)
    goto LABEL_40;
  v16 = 0;
  LODWORD(v17) = 1;
  do
  {
    while (1)
    {
      v18 = v17;
      v19 = argv[(int)v17];
      if (!strcmp(v19, "--max-lease-time"))
        break;
      if (!strcmp(v19, "--min-lease-time"))
      {
        v17 = (int)v17 + 1;
        if (v18 + 1 == argc)
          goto LABEL_62;
        v21 = strtoul(argv[v17], &__endptr, 10);
        v15 = srp_servers;
        *(_DWORD *)(srp_servers + 256) = v21;
        v22 = __endptr;
        v23 = argv[v17];
LABEL_31:
        if (v22 == v23 || *v22)
          goto LABEL_62;
        goto LABEL_37;
      }
      if (strcmp(v19, "--log-stderr"))
      {
        if (!strcmp(v19, "--enable-replication"))
        {
          v26 = 1;
        }
        else
        {
          if (strcmp(v19, "--disable-replication"))
          {
            if (strcmp(v19, "--fake-xpanid"))
              goto LABEL_62;
            v24 = (int)v17 + 1;
            if ((_DWORD)v24 == argc)
              goto LABEL_62;
            v25 = strtoul(argv[v24], &__endptr, 16);
            v15 = srp_servers;
            *(_QWORD *)(srp_servers + 240) = v25;
            v22 = __endptr;
            v23 = argv[v24];
            goto LABEL_31;
          }
          v26 = 0;
        }
        *(_BYTE *)(v15 + 280) = v26;
        goto LABEL_37;
      }
      LODWORD(v17) = v17 + 1;
      v16 = 1;
      if ((int)v17 >= argc)
        goto LABEL_39;
    }
    v17 = (int)v17 + 1;
    if (v18 + 1 == argc
      || (v20 = strtoul(argv[v17], &__endptr, 10),
          v15 = srp_servers,
          *(_DWORD *)(srp_servers + 252) = v20,
          __endptr == argv[v17])
      || *__endptr)
    {
LABEL_62:
      usage();
    }
LABEL_37:
    LODWORD(v17) = v17 + 1;
  }
  while ((int)v17 < argc);
  if (v16)
LABEL_39:
    putenv("ACTIVITY_LOG_STDERR=1");
LABEL_40:
  v27 = os_log_create("com.apple.srp-mdns-proxy", "0");
  global_os_log = (uint64_t)v27;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446722;
    v49 = "main";
    v50 = 2082;
    v51 = "Aug  3 2024";
    v52 = 2082;
    v53 = "11:54:06";
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: --------------------------------srp-mdns-proxy starting, compiled on %{public}s, %{public}s--------------------------------", buf, 0x20u);
  }
  ioloop_main_queue = (uint64_t)&_dispatch_main_q;
  dispatch_retain((dispatch_object_t)&_dispatch_main_q);
  ifpermit_add_permitted_interface_to_server_(srp_servers, "lo0", "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4565);
  if (srp_mdns_shared_registration_txn_setup(srp_servers))
  {
    dns_service_op_not_to_be_freed = *(_QWORD *)(*(_QWORD *)(srp_servers + 16) + 8);
    if (!init_dnssd_proxy(srp_servers))
    {
      v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "main";
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s: failed to setup dnssd-proxy", buf, 0xCu);
      }
    }
    v29 = srp_servers;
    xpc_service = ioloop_create_xpc_service(srp_servers);
    *(_QWORD *)(v29 + 136) = xpc_service;
    if (!xpc_service)
    {
      v31 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "main";
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%{public}s: Can't start advertising proxy control server.", buf, 0xCu);
      }
    }
    v46.rlim_cur = 0;
    v46.rlim_max = 0;
    if (getrlimit(8, &v46) < 0)
    {
      v32 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v33 = __error();
        v34 = strerror(*v33);
        *(_DWORD *)buf = 136446466;
        v49 = "main";
        v50 = 2082;
        v51 = v34;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%{public}s: getrlimit failed: %{public}s", buf, 0x16u);
      }
    }
    rlim_cur = v46.rlim_cur;
    if (v46.rlim_cur <= 0x3FF)
    {
      rlim_max = v46.rlim_max;
      if (v46.rlim_max > 0x3FF)
      {
        v46.rlim_cur = 1024;
      }
      else
      {
        v37 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          v49 = "main";
          v50 = 2048;
          v51 = (const char *)rlim_max;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: file descriptor hard limit is %llu", buf, 0x16u);
          rlim_cur = v46.rlim_cur;
          rlim_max = v46.rlim_max;
        }
        if (rlim_cur != rlim_max)
          v46.rlim_cur = rlim_max;
      }
      if (setrlimit(8, &v46) < 0)
      {
        v40 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v41 = __error();
          v42 = strerror(*v41);
          *(_DWORD *)buf = 136446466;
          v49 = "main";
          v50 = 2082;
          v51 = v42;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%{public}s: setrlimit failed: %{public}s", buf, 0x16u);
        }
      }
    }
    srp_proxy_init();
    v43 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4677);
    v44 = srp_servers;
    *(_QWORD *)(srp_servers + 216) = v43;
    if (v43)
    {
      *(_DWORD *)(v44 + 268) = 1;
      object_allocation_stats_dump_callback(v44);
    }
    else
    {
      v45 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        v49 = "main";
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: no memory for srp_servers->object_allocation_stats_dump_wakeup", buf, 0xCu);
        ioloop();
      }
    }
    ioloop();
  }
  return 1;
}

void usage()
{
  NSObject *v0;
  int v1;
  const char *v2;

  v0 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v1 = 136446210;
    v2 = "usage";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s: srp-mdns-proxy [--max-lease-time <seconds>] [--min-lease-time <seconds>] [--log-stderr]", (uint8_t *)&v1, 0xCu);
    v0 = global_os_log;
  }
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    v1 = 136446210;
    v2 = "usage";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s:                [--enable-replication | --disable-replication]", (uint8_t *)&v1, 0xCu);
  }
  exit(1);
}

BOOL object_allocation_stats_dump_callback(uint64_t a1)
{
  int v2;

  ioloop_dump_object_allocation_stats();
  if (*(_DWORD *)(a1 + 268))
  {
    srp_dump_server_stats(a1, 0, 1);
    v2 = *(_DWORD *)(a1 + 268) - 1;
  }
  else
  {
    srp_dump_server_stats(a1, 1, 1);
    v2 = 11;
  }
  *(_DWORD *)(a1 + 268) = v2;
  return ioloop_add_wake_event(*(_QWORD *)(a1 + 216), a1, (uint64_t)object_allocation_stats_dump_callback, 0, 0x493E0u);
}

void service_publisher_unadvertise_all(uint64_t a1)
{
  uint64_t v1;
  _QWORD *i;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  NSObject *v7;
  unsigned __int8 *v8;
  int v9;
  const char *v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  NSObject *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  uint64_t v32;
  __int16 v33;
  _BYTE v34[24];
  __int16 v35;
  int v36;
  __int16 v37;
  unsigned __int8 *v38;
  __int16 v39;
  uint64_t v40;
  __int16 v41;
  int v42;
  __int16 v43;
  unsigned __int8 *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  uint64_t v48;

  v1 = *(_QWORD *)(a1 + 88);
  *(_BYTE *)(a1 + 268) = 0;
  for (i = *(_QWORD **)(v1 + 8); i; i = (_QWORD *)i[5])
  {
    v3 = i[6];
    if (v3)
      srp_mdns_update_finished(v3);
    v4 = i[12];
    if (v4 && *(int *)(v4 + 4) >= 1)
    {
      v5 = 0;
      do
      {
        v6 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * v5);
        if (v6)
        {
          if (*(_WORD *)(v6 + 48) == 28 && *(_WORD *)(v6 + 50) == 16)
          {
            v7 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v8 = *(unsigned __int8 **)(v6 + 40);
              v9 = *v8;
              v10 = "ULA: ";
              if ((v9 & 0xFE) != 0xFC)
              {
                if (v9 != 254 || (v10 = "LUA: ", (v8[1] & 0xC0) != 0x80))
                {
                  v10 = (const char *)&unk_10007C3B5;
                  if ((v9 & 0xE0) == 0x20)
                    v10 = "GUA: ";
                }
              }
              v11 = i[7];
              v12 = *(_QWORD *)(v6 + 8);
              *(_DWORD *)buf = 136449795;
              v24 = "service_publisher_unadvertise_all";
              v25 = 2160;
              v26 = 1752392040;
              v27 = 2081;
              v28 = v11;
              v29 = 2082;
              v30 = (uint64_t)v10;
              v31 = 2160;
              v32 = 1752392040;
              v33 = 1041;
              *(_DWORD *)v34 = 6;
              *(_WORD *)&v34[4] = 2097;
              *(_QWORD *)&v34[6] = v8;
              *(_WORD *)&v34[14] = 2160;
              *(_QWORD *)&v34[16] = 1752392040;
              v35 = 1042;
              v36 = 2;
              v37 = 2098;
              v38 = v8 + 6;
              v39 = 2160;
              v40 = 1752392040;
              v41 = 1041;
              v42 = 8;
              v43 = 2097;
              v44 = v8 + 8;
              v45 = 2048;
              v46 = v6;
              v47 = 2048;
              v48 = v12;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: unadvertising %{private, mask.hash}s IN AAAA {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} rec %p rref %p", buf, 0x8Cu);
            }
          }
          srp_mdns_shared_record_remove(v1, v6);
          DNSServiceReconfirmRecord(*(_DWORD *)(v1 + 248), i[7], (const char *)*(unsigned __int16 *)(v6 + 48), 1u, *(_WORD *)(v6 + 50), *(_QWORD *)(v6 + 40), v13);
          v4 = i[12];
        }
        ++v5;
      }
      while (v5 < *(int *)(v4 + 4));
    }
    v14 = i[13];
    if (v14)
      srp_mdns_shared_record_remove(v1, v14);
    v15 = i[14];
    if (v15 && *(int *)(v15 + 4) >= 1)
    {
      v16 = 0;
      do
      {
        v17 = *(uint64_t **)(*(_QWORD *)(v15 + 8) + 8 * v16);
        if (v17)
        {
          v18 = v17[1];
          if (v18)
          {
            v19 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              v20 = v17[6];
              v21 = v17[7];
              v22 = *(_QWORD *)(v18 + 8);
              *(_DWORD *)buf = 136447747;
              v24 = "service_publisher_unadvertise_all";
              v25 = 2160;
              v26 = 1752392040;
              v27 = 2081;
              v28 = v20;
              v29 = 2160;
              v30 = 1752392040;
              v31 = 2081;
              v32 = v21;
              v33 = 2048;
              *(_QWORD *)v34 = v17;
              *(_WORD *)&v34[8] = 2048;
              *(_QWORD *)&v34[10] = v22;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: unadvertising %{private, mask.hash}s.%{private, mask.hash}s instance %p sdref %p", buf, 0x48u);
              v18 = v17[1];
            }
            ioloop_dnssd_txn_cancel(v18);
            ioloop_dnssd_txn_release_((int *)v17[1], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 193);
            v17[1] = 0;
            v15 = i[14];
          }
        }
        ++v16;
      }
      while (v16 < *(int *)(v15 + 4));
    }
  }
}

void service_publisher_re_advertise_matching(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  unsigned __int8 *v8;
  NSObject *v10;
  int v11;
  const char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  DNSServiceAttribute *v18;
  DNSServiceErrorType v19;
  NSObject *v20;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  NSObject *v29;
  int v30;
  int v31;
  int v32;
  NSObject *v33;
  NSObject *v34;
  NSObject *v35;
  DNSServiceRef sdRef;
  uint8_t buf[4];
  const char *v39;
  __int16 v40;
  _BYTE v41[40];
  _BYTE v42[30];
  __int16 v43;
  unsigned __int8 *v44;
  __int16 v45;
  uint64_t v46;
  __int16 v47;
  int v48;
  __int16 v49;
  unsigned __int8 *v50;
  char v51[28];

  if (*(_DWORD *)(a1 + 56))
  {
    v2 = *(_QWORD *)(a1 + 88);
    if (srp_mdns_shared_registration_txn_setup(v2))
    {
      v3 = *(_QWORD *)(v2 + 8);
      if (!v3)
        goto LABEL_53;
      while (1)
      {
        v4 = *(_QWORD *)(v3 + 96);
        if (!v4 || *(int *)(v4 + 4) < 1)
          goto LABEL_52;
        v5 = 0;
        v6 = 0;
        do
        {
          v7 = *(_QWORD *)(*(_QWORD *)(v4 + 8) + 8 * v5);
          if (!v7 || *(_WORD *)(v7 + 48) != 28 || *(_WORD *)(v7 + 50) != 16)
            goto LABEL_26;
          v8 = *(unsigned __int8 **)(v7 + 40);
          if (*(_QWORD *)(a1 + 232))
          {
            if (*(_QWORD *)(a1 + 192) != *(_QWORD *)v8 || *(_QWORD *)(a1 + 200) != *((_QWORD *)v8 + 1))
              goto LABEL_26;
          }
          else if (*(_QWORD *)(a1 + 176) != *(_QWORD *)v8)
          {
            goto LABEL_26;
          }
          v10 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v11 = *v8;
            v12 = "ULA: ";
            if ((v11 & 0xFE) != 0xFC)
            {
              if (v11 != 254 || (v12 = "LUA: ", (v8[1] & 0xC0) != 0x80))
              {
                v12 = (const char *)&unk_10007C3B5;
                if ((v11 & 0xE0) == 0x20)
                  v12 = "GUA: ";
              }
            }
            v13 = *(_QWORD *)(v3 + 56);
            *(_DWORD *)buf = 136449283;
            v39 = "service_publisher_re_advertise_matching";
            v40 = 2160;
            *(_QWORD *)v41 = 1752392040;
            *(_WORD *)&v41[8] = 2081;
            *(_QWORD *)&v41[10] = v13;
            *(_WORD *)&v41[18] = 2082;
            *(_QWORD *)&v41[20] = v12;
            *(_WORD *)&v41[28] = 2160;
            *(_QWORD *)&v41[30] = 1752392040;
            *(_WORD *)&v41[38] = 1041;
            *(_DWORD *)v42 = 6;
            *(_WORD *)&v42[4] = 2097;
            *(_QWORD *)&v42[6] = v8;
            *(_WORD *)&v42[14] = 2160;
            *(_QWORD *)&v42[16] = 1752392040;
            *(_WORD *)&v42[24] = 1042;
            *(_DWORD *)&v42[26] = 2;
            v43 = 2098;
            v44 = v8 + 6;
            v45 = 2160;
            v46 = 1752392040;
            v47 = 1041;
            v48 = 8;
            v49 = 2097;
            v50 = v8 + 8;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: re-advertising %{private, mask.hash}s IN AAAA {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x78u);
          }
          service_publisher_re_advertise_record(v2, v3, v7);
          v4 = *(_QWORD *)(v3 + 96);
          v6 = 1;
LABEL_26:
          ++v5;
        }
        while (v5 < *(int *)(v4 + 4));
        if ((v6 & 1) != 0)
        {
          v14 = *(_QWORD *)(v3 + 104);
          if (v14)
            service_publisher_re_advertise_record(v2, v3, v14);
          v15 = *(_QWORD *)(v3 + 112);
          if (v15 && *(int *)(v15 + 4) >= 1)
          {
            v16 = 0;
            do
            {
              v17 = *(_DWORD **)(*(_QWORD *)(v15 + 8) + 8 * v16);
              if (v17 && !*((_QWORD *)v17 + 1))
              {
                sdRef = *(DNSServiceRef *)(*(_QWORD *)(v2 + 16) + 8);
                v18 = (DNSServiceAttribute *)srp_message_tsr_attribute_generate(0, *(_DWORD *)(v3 + 184), v51);
                v19 = DNSServiceRegisterWithAttribute(&sdRef, 0x4808u, *(_DWORD *)(v2 + 248), *((const char **)v17 + 6), *((const char **)v17 + 7), 0, *(const char **)(v3 + 64), bswap32(*((unsigned __int16 *)v17 + 32)) >> 16, *((_WORD *)v17 + 40), *((const void **)v17 + 9), v18, (DNSServiceRegisterReply)service_publisher_instance_callback, v17);
                v20 = global_os_log;
                v21 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
                if (v19)
                {
                  if (v21)
                  {
                    v22 = *((_QWORD *)v17 + 6);
                    v23 = *((_QWORD *)v17 + 7);
                    v24 = *(_QWORD *)(v3 + 64);
                    *(_DWORD *)buf = 136447747;
                    v39 = "service_publisher_re_advertise_instance";
                    v40 = 2082;
                    *(_QWORD *)v41 = v22;
                    *(_WORD *)&v41[8] = 2082;
                    *(_QWORD *)&v41[10] = v23;
                    *(_WORD *)&v41[18] = 2160;
                    *(_QWORD *)&v41[20] = 1752392040;
                    *(_WORD *)&v41[28] = 2081;
                    *(_QWORD *)&v41[30] = v24;
                    *(_WORD *)&v41[38] = 1024;
                    *(_DWORD *)v42 = v19;
                    *(_WORD *)&v42[4] = 2048;
                    *(_QWORD *)&v42[6] = v17;
                    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister failed: %{public}s.%{public}s host %{private, mask.hash}s: %d (instance %p)", buf, 0x44u);
                  }
                }
                else
                {
                  if (v21)
                  {
                    v25 = *((_QWORD *)v17 + 6);
                    v26 = *((_QWORD *)v17 + 7);
                    v27 = *(_QWORD *)(v3 + 64);
                    *(_DWORD *)buf = 136448003;
                    v39 = "service_publisher_re_advertise_instance";
                    v40 = 2082;
                    *(_QWORD *)v41 = v25;
                    *(_WORD *)&v41[8] = 2082;
                    *(_QWORD *)&v41[10] = v26;
                    *(_WORD *)&v41[18] = 2160;
                    *(_QWORD *)&v41[20] = 1752392040;
                    *(_WORD *)&v41[28] = 2081;
                    *(_QWORD *)&v41[30] = v27;
                    *(_WORD *)&v41[38] = 2082;
                    *(_QWORD *)v42 = v51;
                    *(_WORD *)&v42[8] = 2048;
                    *(_QWORD *)&v42[10] = v17;
                    *(_WORD *)&v42[18] = 2048;
                    *(_QWORD *)&v42[20] = sdRef;
                    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister succeeded: %{public}s.%{public}s host %{private, mask.hash}s at %{public}s (instance %p sdref %p)", buf, 0x52u);
                  }
                  v28 = ioloop_dnssd_txn_add_subordinate_((uint64_t)sdRef, (uint64_t)v17, (uint64_t)adv_instance_context_release, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 266);
                  *((_QWORD *)v17 + 1) = v28;
                  if (v28)
                  {
                    *((_QWORD *)v17 + 2) = *(_QWORD *)(v2 + 16);
                    v29 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      v30 = *v17;
                      *(_DWORD *)buf = 136447490;
                      v39 = "adv_instance_retain_";
                      v40 = 1024;
                      *(_DWORD *)v41 = v30;
                      *(_WORD *)&v41[4] = 2048;
                      *(_QWORD *)&v41[6] = v17;
                      *(_WORD *)&v41[14] = 2080;
                      *(_QWORD *)&v41[16] = "instance";
                      *(_WORD *)&v41[24] = 2080;
                      *(_QWORD *)&v41[26] = "service-publisher.c";
                      *(_WORD *)&v41[34] = 1024;
                      *(_DWORD *)&v41[36] = 273;
                      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                    }
                    v31 = *v17;
                    if (!*v17)
                    {
                      ++adv_instance_created;
                      v31 = *v17;
                    }
                    v32 = v31 + 1;
                    *v17 = v31 + 1;
                    if (v31 + 1 >= 10001)
                    {
                      v35 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 136447490;
                        v39 = "adv_instance_retain_";
                        v40 = 1024;
                        *(_DWORD *)v41 = v32;
                        *(_WORD *)&v41[4] = 2048;
                        *(_QWORD *)&v41[6] = v17;
                        *(_WORD *)&v41[14] = 2080;
                        *(_QWORD *)&v41[16] = "instance";
                        *(_WORD *)&v41[24] = 2080;
                        *(_QWORD *)&v41[26] = "service-publisher.c";
                        *(_WORD *)&v41[34] = 1024;
                        *(_DWORD *)&v41[36] = 273;
                        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                      }
                      abort();
                    }
                  }
                  else
                  {
                    v33 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446210;
                      v39 = "service_publisher_re_advertise_instance";
                      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%{public}s: no memory for instance transaction.", buf, 0xCu);
                    }
                    DNSServiceRefDeallocate(sdRef);
                  }
                }
                v15 = *(_QWORD *)(v3 + 112);
              }
              ++v16;
            }
            while (v16 < *(int *)(v15 + 4));
          }
        }
LABEL_52:
        v3 = *(_QWORD *)(v3 + 40);
        if (!v3)
        {
LABEL_53:
          *(_BYTE *)(a1 + 268) = 1;
          return;
        }
      }
    }
  }
  else
  {
    v34 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v39 = "service_publisher_re_advertise_matching";
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: publisher is in an invalid state, so we shouldn't re-advertise anything.", buf, 0xCu);
    }
  }
}

void service_publisher_re_advertise_record(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  _DNSServiceRef_t *v7;
  DNSRecordRef *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  NSObject *v12;
  _BOOL4 v13;
  uint64_t v14;
  const char *v15;
  NSObject *v16;
  uint32_t v17;
  uint64_t v18;
  uint16_t v19;
  DNSServiceErrorType v20;
  NSObject *v21;
  _BOOL4 v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  NSObject *v29;
  DNSServiceAttributeRef v30[4];
  uint8_t buf[4];
  const char *v32;
  __int16 v33;
  _BYTE v34[40];

  v6 = *(_QWORD *)(a2 + 8);
  v7 = *(_DNSServiceRef_t **)(*(_QWORD *)(v6 + 16) + 8);
  v8 = (DNSRecordRef *)(a3 + 8);
  v9 = *(_QWORD *)(a3 + 8);
  if (v9)
  {
    v10 = *(_QWORD *)(a3 + 24);
    v11 = *(_QWORD *)(a1 + 16);
    v12 = global_os_log;
    v13 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v10 == v11)
    {
      if (!v13)
        return;
      v14 = *(_QWORD *)(a2 + 64);
      *(_DWORD *)buf = 136446978;
      v32 = "service_publisher_re_advertise_record";
      v33 = 2082;
      *(_QWORD *)v34 = v14;
      *(_WORD *)&v34[8] = 2048;
      *(_QWORD *)&v34[10] = a3;
      *(_WORD *)&v34[18] = 2048;
      *(_QWORD *)&v34[20] = v9;
      v15 = "%{public}s: host is already registered: %{public}s (record %p rref %p)";
      v16 = v12;
      v17 = 42;
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      return;
    }
    if (v13)
    {
      v18 = *(_QWORD *)(a2 + 64);
      *(_DWORD *)buf = 136446978;
      v32 = "service_publisher_re_advertise_record";
      v33 = 2082;
      *(_QWORD *)v34 = v18;
      *(_WORD *)&v34[8] = 2048;
      *(_QWORD *)&v34[10] = a3;
      *(_WORD *)&v34[18] = 2048;
      *(_QWORD *)&v34[20] = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: host registration is stale: %{public}s (record %p rref %p)", buf, 0x2Au);
      v6 = *(_QWORD *)(a2 + 8);
    }
    srp_mdns_shared_record_remove(v6, a3);
  }
  v19 = (unsigned __int16)srp_message_tsr_attribute_generate(0, *(_DWORD *)(a2 + 184), (char *)v30 + 4);
  v20 = DNSServiceRegisterRecordWithAttribute(v7, v8, *(_DWORD *)(a1 + 248), *(_QWORD *)(a2 + 64), (const char *)*(unsigned __int16 *)(a3 + 48), *(_WORD *)(a3 + 50), *(_QWORD *)(a3 + 40), v19, service_publisher_record_callback, a3, v30[0], (DNSServiceRegisterRecordReply)v30[1], v30[2]);
  v21 = global_os_log;
  v22 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v20)
  {
    if (!v22)
      return;
    v23 = *(_QWORD *)(a2 + 56);
    *(_DWORD *)buf = 136446978;
    v32 = "service_publisher_re_advertise_record";
    v33 = 2082;
    *(_QWORD *)v34 = v23;
    *(_WORD *)&v34[8] = 1024;
    *(_DWORD *)&v34[10] = v20;
    *(_WORD *)&v34[14] = 2048;
    *(_QWORD *)&v34[16] = a3;
    v15 = "%{public}s: DNSServiceRegisterRecord failed on host %{public}s: %d (record %p)";
    v16 = v21;
    v17 = 38;
    goto LABEL_11;
  }
  if (v22)
  {
    v24 = *(_QWORD *)(a2 + 56);
    v25 = *(_QWORD *)(a3 + 8);
    *(_DWORD *)buf = 136447234;
    v32 = "service_publisher_re_advertise_record";
    v33 = 2082;
    *(_QWORD *)v34 = v24;
    *(_WORD *)&v34[8] = 2082;
    *(_QWORD *)&v34[10] = (char *)v30 + 4;
    *(_WORD *)&v34[18] = 2048;
    *(_QWORD *)&v34[20] = a3;
    *(_WORD *)&v34[28] = 2048;
    *(_QWORD *)&v34[30] = v25;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord succeeded on host %{public}s at %{public}s (record %p rref %p)", buf, 0x34u);
    v21 = global_os_log;
  }
  *(_QWORD *)(a3 + 24) = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 16);
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    v26 = *(_DWORD *)a3;
    *(_DWORD *)buf = 136447490;
    v32 = "adv_record_retain_";
    v33 = 1024;
    *(_DWORD *)v34 = v26;
    *(_WORD *)&v34[4] = 2048;
    *(_QWORD *)&v34[6] = a3;
    *(_WORD *)&v34[14] = 2080;
    *(_QWORD *)&v34[16] = "record";
    *(_WORD *)&v34[24] = 2080;
    *(_QWORD *)&v34[26] = "service-publisher.c";
    *(_WORD *)&v34[34] = 1024;
    *(_DWORD *)&v34[36] = 327;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  v27 = *(_DWORD *)a3;
  if (*(_DWORD *)a3)
  {
    v28 = v27 + 1;
    *(_DWORD *)a3 = v27 + 1;
    if (v27 + 1 >= 10001)
    {
      v29 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v32 = "adv_record_retain_";
        v33 = 1024;
        *(_DWORD *)v34 = v28;
        *(_WORD *)&v34[4] = 2048;
        *(_QWORD *)&v34[6] = a3;
        *(_WORD *)&v34[14] = 2080;
        *(_QWORD *)&v34[16] = "record";
        *(_WORD *)&v34[24] = 2080;
        *(_QWORD *)&v34[26] = "service-publisher.c";
        *(_WORD *)&v34[34] = 1024;
        *(_DWORD *)&v34[36] = 327;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      abort();
    }
  }
  else
  {
    ++adv_record_created;
    *(_DWORD *)a3 = 1;
  }
}

void service_publisher_instance_callback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  NSObject *v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  _BYTE v30[24];

  v12 = global_os_log;
  v13 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a3)
  {
    if (v13)
    {
      v14 = a7[1];
      if (v14)
        v14 = *(_QWORD *)(v14 + 8);
      v19 = 136448003;
      v20 = "service_publisher_instance_callback";
      v21 = 2082;
      v22 = a4;
      v23 = 2082;
      v24 = a5;
      v25 = 2160;
      v26 = 1752392040;
      v27 = 2081;
      v28 = a6;
      v29 = 1024;
      *(_DWORD *)v30 = a3;
      *(_WORD *)&v30[4] = 2048;
      *(_QWORD *)&v30[6] = a7;
      *(_WORD *)&v30[14] = 2048;
      *(_QWORD *)&v30[16] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister failed: %{public}s.%{public}s host %{private, mask.hash}s: %d (instance %p sdref %p)", (uint8_t *)&v19, 0x4Eu);
    }
    ioloop_dnssd_txn_cancel(a7[1]);
    ioloop_dnssd_txn_release_((int *)a7[1], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 210);
    a7[1] = 0;
  }
  else if (v13)
  {
    v16 = a7[6];
    v15 = a7[7];
    v17 = *(_QWORD *)(a7[3] + 64);
    v18 = a7[1];
    if (v18)
      v18 = *(_QWORD *)(v18 + 8);
    v19 = 136447747;
    v20 = "service_publisher_instance_callback";
    v21 = 2082;
    v22 = v16;
    v23 = 2082;
    v24 = v15;
    v25 = 2160;
    v26 = 1752392040;
    v27 = 2081;
    v28 = v17;
    v29 = 2048;
    *(_QWORD *)v30 = a7;
    *(_WORD *)&v30[8] = 2048;
    *(_QWORD *)&v30[10] = v18;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister succeeded: %{public}s.%{public}s host %{private, mask.hash}s (instance %p sdref %p)", (uint8_t *)&v19, 0x48u);
  }
}

void service_publisher_record_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v8;
  const char *v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  NSObject *v13;
  const char *v14;
  int v15;
  const char *v16;
  __int16 v17;
  _BYTE v18[40];
  int v19;

  v8 = *(_QWORD *)(a5 + 16);
  if (v8)
    v9 = *(const char **)(v8 + 56);
  else
    v9 = "<null>";
  v10 = global_os_log;
  if (a4)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v15 = 136447491;
      v16 = "service_publisher_record_callback";
      v17 = 2160;
      *(_QWORD *)v18 = 1752392040;
      *(_WORD *)&v18[8] = 2081;
      *(_QWORD *)&v18[10] = v9;
      *(_WORD *)&v18[18] = 2048;
      *(_QWORD *)&v18[20] = a5;
      *(_WORD *)&v18[28] = 2048;
      *(_QWORD *)&v18[30] = a2;
      *(_WORD *)&v18[38] = 1024;
      v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: re-registration for %{private, mask.hash}s (record %p rref %p) failed with code %d", (uint8_t *)&v15, 0x3Au);
    }
    *(_QWORD *)(a5 + 8) = 0;
    *(_QWORD *)(a5 + 24) = 0;
    v11 = *(_DWORD *)a5;
    if (*(_DWORD *)a5)
    {
      v12 = global_os_log;
      if (v11 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v15 = 136447490;
          v16 = "adv_record_release_";
          v17 = 1024;
          *(_DWORD *)v18 = v11;
          *(_WORD *)&v18[4] = 2048;
          *(_QWORD *)&v18[6] = a5;
          *(_WORD *)&v18[14] = 2080;
          *(_QWORD *)&v18[16] = "record";
          *(_WORD *)&v18[24] = 2080;
          *(_QWORD *)&v18[26] = "service-publisher.c";
          *(_WORD *)&v18[34] = 1024;
          *(_DWORD *)&v18[36] = 288;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v15, 0x36u);
          v11 = *(_DWORD *)a5;
        }
        *(_DWORD *)a5 = v11 - 1;
        if (v11 == 1)
        {
          v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v15 = 136447234;
            v16 = "adv_record_release_";
            v17 = 2048;
            *(_QWORD *)v18 = a5;
            *(_WORD *)&v18[8] = 2080;
            *(_QWORD *)&v18[10] = "record";
            *(_WORD *)&v18[18] = 2080;
            *(_QWORD *)&v18[20] = "service-publisher.c";
            *(_WORD *)&v18[28] = 1024;
            *(_DWORD *)&v18[30] = 288;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v15, 0x30u);
          }
          ++adv_record_finalized;
          adv_record_finalize(a5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_23:
        abort();
      v15 = 136447490;
      v16 = "adv_record_release_";
      v17 = 1024;
      *(_DWORD *)v18 = v11;
      *(_WORD *)&v18[4] = 2048;
      *(_QWORD *)&v18[6] = a5;
      *(_WORD *)&v18[14] = 2080;
      *(_QWORD *)&v18[16] = "record";
      *(_WORD *)&v18[24] = 2080;
      *(_QWORD *)&v18[26] = "service-publisher.c";
      *(_WORD *)&v18[34] = 1024;
      *(_DWORD *)&v18[36] = 288;
      v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_23;
      v15 = 136447490;
      v16 = "adv_record_release_";
      v17 = 1024;
      *(_DWORD *)v18 = 0;
      *(_WORD *)&v18[4] = 2048;
      *(_QWORD *)&v18[6] = a5;
      *(_WORD *)&v18[14] = 2080;
      *(_QWORD *)&v18[16] = "record";
      *(_WORD *)&v18[24] = 2080;
      *(_QWORD *)&v18[26] = "service-publisher.c";
      *(_WORD *)&v18[34] = 1024;
      *(_DWORD *)&v18[36] = 288;
      v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v14, (uint8_t *)&v15, 0x36u);
    goto LABEL_23;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v15 = 136447235;
    v16 = "service_publisher_record_callback";
    v17 = 2160;
    *(_QWORD *)v18 = 1752392040;
    *(_WORD *)&v18[8] = 2081;
    *(_QWORD *)&v18[10] = v9;
    *(_WORD *)&v18[18] = 2048;
    *(_QWORD *)&v18[20] = a5;
    *(_WORD *)&v18[28] = 2048;
    *(_QWORD *)&v18[30] = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registration for %{private, mask.hash}s (record %p rref %p) succeeded.", (uint8_t *)&v15, 0x34u);
  }
}

void service_publisher_release_(int *a1, char *a2, int a3)
{
  int v6;
  NSObject *v7;
  NSObject *v8;
  char *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  if (!a1)
    return;
  v6 = *a1;
  if (!*a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "service_publisher_release_";
    v13 = 1024;
    *(_DWORD *)v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v11 = 136447490;
    v12 = "service_publisher_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = 136447490;
    v12 = "service_publisher_release_";
    v13 = 1024;
    *(_DWORD *)v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(_QWORD *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(_QWORD *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(_QWORD *)&v14[26] = strrchr(a2, 47) + 1;
    v15 = 1024;
    v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      v11 = 136447234;
      v12 = "service_publisher_release_";
      v13 = 2048;
      *(_QWORD *)v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(_QWORD *)&v14[10] = "omw";
      *(_WORD *)&v14[18] = 2080;
      *(_QWORD *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize((uint64_t)a1);
  }
}

void service_publisher_finalize(uint64_t a1)
{
  _QWORD *v2;
  int v3;
  NSObject *v4;
  NSObject *v5;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint8_t buf[4];
  const char *v10;
  __int16 v11;
  _BYTE v12[34];
  __int16 v13;
  int v14;

  thread_service_release_(*(int **)(a1 + 128), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 444);
  thread_service_release_(*(int **)(a1 + 136), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 445);
  v2 = *(_QWORD **)(a1 + 144);
  if (v2)
  {
    while (1)
    {
      *(_QWORD *)(a1 + 144) = v2[1];
      v3 = *(_DWORD *)v2;
      if (!*(_DWORD *)v2)
        break;
      v4 = global_os_log;
      if (v3 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v10 = "thread_service_list_release";
          v11 = 1024;
          *(_DWORD *)v12 = v3;
          *(_WORD *)&v12[4] = 2048;
          *(_QWORD *)&v12[6] = v2;
          *(_WORD *)&v12[14] = 2080;
          *(_QWORD *)&v12[16] = "service";
          *(_WORD *)&v12[24] = 2080;
          *(_QWORD *)&v12[26] = "thread-service.c";
          v13 = 1024;
          v14 = 89;
          v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v8 = v4;
LABEL_16:
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v7, buf, 0x36u);
        }
        goto LABEL_17;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        v10 = "thread_service_list_release";
        v11 = 1024;
        *(_DWORD *)v12 = v3;
        *(_WORD *)&v12[4] = 2048;
        *(_QWORD *)&v12[6] = v2;
        *(_WORD *)&v12[14] = 2080;
        *(_QWORD *)&v12[16] = "service";
        *(_WORD *)&v12[24] = 2080;
        *(_QWORD *)&v12[26] = "thread-service.c";
        v13 = 1024;
        v14 = 89;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        v3 = *(_DWORD *)v2;
      }
      *(_DWORD *)v2 = v3 - 1;
      if (v3 == 1)
      {
        v5 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v10 = "thread_service_list_release";
          v11 = 2048;
          *(_QWORD *)v12 = v2;
          *(_WORD *)&v12[8] = 2080;
          *(_QWORD *)&v12[10] = "service";
          *(_WORD *)&v12[18] = 2080;
          *(_QWORD *)&v12[20] = "thread-service.c";
          *(_WORD *)&v12[28] = 1024;
          *(_DWORD *)&v12[30] = 89;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++thread_service_finalized;
        free(v2);
      }
      v2 = *(_QWORD **)(a1 + 144);
      if (!v2)
        goto LABEL_11;
    }
    v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      v10 = "thread_service_list_release";
      v11 = 1024;
      *(_DWORD *)v12 = 0;
      *(_WORD *)&v12[4] = 2048;
      *(_QWORD *)&v12[6] = v2;
      *(_WORD *)&v12[14] = 2080;
      *(_QWORD *)&v12[16] = "service";
      *(_WORD *)&v12[24] = 2080;
      *(_QWORD *)&v12[26] = "thread-service.c";
      v13 = 1024;
      v14 = 89;
      v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v8 = v6;
      goto LABEL_16;
    }
LABEL_17:
    abort();
  }
LABEL_11:
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 224));
  free(*(void **)(a1 + 232));
  free(*(void **)(a1 + 240));
  free(*(void **)(a1 + 72));
  ioloop_wakeup_release_(*(_QWORD **)(a1 + 96), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 453);
  free((void *)a1);
}

void service_publisher_wanted_service_added(uint64_t a1)
{
  int *v2;
  int *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  void (*v7)(int *);
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = state_machine_event_create(19);
  if (v2)
  {
    v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    v4 = *v3;
    if (*v3)
    {
      v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136447490;
          v11 = "service_publisher_wanted_service_added";
          v12 = 1024;
          *(_DWORD *)v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(_QWORD *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(_QWORD *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(_QWORD *)&v13[26] = "service-publisher.c";
          v14 = 1024;
          v15 = 806;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          v4 = *v3;
        }
        *v3 = v4 - 1;
        if (v4 == 1)
        {
          v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136447234;
            v11 = "service_publisher_wanted_service_added";
            v12 = 2048;
            *(_QWORD *)v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(_QWORD *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(_QWORD *)&v13[20] = "service-publisher.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 806;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          v7 = (void (*)(int *))*((_QWORD *)v3 + 4);
          if (v7)
            v7(v3);
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_20:
        abort();
      v10 = 136447490;
      v11 = "service_publisher_wanted_service_added";
      v12 = 1024;
      *(_DWORD *)v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "service-publisher.c";
      v14 = 1024;
      v15 = 806;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_20;
      v10 = 136447490;
      v11 = "service_publisher_wanted_service_added";
      v12 = 1024;
      *(_DWORD *)v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "service-publisher.c";
      v14 = 1024;
      v15 = 806;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v10 = 136446210;
    v11 = "service_publisher_wanted_service_added";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

void service_publisher_cancel(uint64_t a1)
{
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  void (*v5)(_QWORD);
  uint64_t v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  int v14;
  NSObject *v15;
  char *v16;
  const char *v17;
  int v18;
  const char *v19;
  __int16 v20;
  _BYTE v21[34];
  __int16 v22;
  int v23;

  ioloop_cancel_wake_event(*(_QWORD *)(a1 + 96));
  service_publisher_listener_cancel(a1);
  service_tracker_callback_cancel(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 40), a1);
  thread_tracker_callback_cancel(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 56), a1);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 64);
  if (v2)
  {
    v3 = (_QWORD *)(v2 + 48);
    while (1)
    {
      v4 = v3;
      v3 = (_QWORD *)*v3;
      if (!v3)
        break;
      if (v3[3] == a1)
      {
        *v4 = *v3;
        v5 = (void (*)(_QWORD))v3[1];
        if (v5)
          v5(v3[3]);
        free(v3);
        break;
      }
    }
  }
  v6 = *(_QWORD *)(a1 + 152);
  if (v6)
  {
    cti_events_discontinue(v6);
    *(_QWORD *)(a1 + 152) = 0;
    v7 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      v8 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_51;
      v18 = 136447490;
      v19 = "service_publisher_cancel";
      v20 = 1024;
      *(_DWORD *)v21 = 0;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = a1;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "publisher";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "service-publisher.c";
      v22 = 1024;
      v23 = 1455;
      v17 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_50;
    }
    v8 = global_os_log;
    if (v7 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_51;
      v18 = 136447490;
      v19 = "service_publisher_cancel";
      v20 = 1024;
      *(_DWORD *)v21 = v7;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = a1;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "publisher";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "service-publisher.c";
      v22 = 1024;
      v23 = 1455;
      v17 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_50;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136447490;
      v19 = "service_publisher_cancel";
      v20 = 1024;
      *(_DWORD *)v21 = v7;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = a1;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "publisher";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "service-publisher.c";
      v22 = 1024;
      v23 = 1455;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
      v7 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v7 - 1;
    if (v7 == 1)
    {
      v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v18 = 136447234;
        v19 = "service_publisher_cancel";
        v20 = 2048;
        *(_QWORD *)v21 = a1;
        *(_WORD *)&v21[8] = 2080;
        *(_QWORD *)&v21[10] = "publisher";
        *(_WORD *)&v21[18] = 2080;
        *(_QWORD *)&v21[20] = "service-publisher.c";
        *(_WORD *)&v21[28] = 1024;
        *(_DWORD *)&v21[30] = 1455;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
      }
      ++service_publisher_finalized;
      service_publisher_finalize(a1);
    }
  }
  v10 = *(_QWORD *)(a1 + 160);
  if (v10)
  {
    cti_events_discontinue(v10);
    *(_QWORD *)(a1 + 160) = 0;
    v11 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      v8 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_51;
      v18 = 136447490;
      v19 = "service_publisher_cancel";
      v20 = 1024;
      *(_DWORD *)v21 = 0;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = a1;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "publisher";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "service-publisher.c";
      v22 = 1024;
      v23 = 1460;
      v17 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_50;
    }
    v8 = global_os_log;
    if (v11 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_51;
      v18 = 136447490;
      v19 = "service_publisher_cancel";
      v20 = 1024;
      *(_DWORD *)v21 = v11;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = a1;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "publisher";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "service-publisher.c";
      v22 = 1024;
      v23 = 1460;
      v17 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_50;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136447490;
      v19 = "service_publisher_cancel";
      v20 = 1024;
      *(_DWORD *)v21 = v11;
      *(_WORD *)&v21[4] = 2048;
      *(_QWORD *)&v21[6] = a1;
      *(_WORD *)&v21[14] = 2080;
      *(_QWORD *)&v21[16] = "publisher";
      *(_WORD *)&v21[24] = 2080;
      *(_QWORD *)&v21[26] = "service-publisher.c";
      v22 = 1024;
      v23 = 1460;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
      v11 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v11 - 1;
    if (v11 == 1)
    {
      v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v18 = 136447234;
        v19 = "service_publisher_cancel";
        v20 = 2048;
        *(_QWORD *)v21 = a1;
        *(_WORD *)&v21[8] = 2080;
        *(_QWORD *)&v21[10] = "publisher";
        *(_WORD *)&v21[18] = 2080;
        *(_QWORD *)&v21[20] = "service-publisher.c";
        *(_WORD *)&v21[28] = 1024;
        *(_DWORD *)&v21[30] = 1460;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
      }
      ++service_publisher_finalized;
      service_publisher_finalize(a1);
    }
  }
  v13 = *(_QWORD *)(a1 + 168);
  if (!v13)
    goto LABEL_35;
  cti_events_discontinue(v13);
  *(_QWORD *)(a1 + 168) = 0;
  v14 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_51;
    v18 = 136447490;
    v19 = "service_publisher_cancel";
    v20 = 1024;
    *(_DWORD *)v21 = 0;
    *(_WORD *)&v21[4] = 2048;
    *(_QWORD *)&v21[6] = a1;
    *(_WORD *)&v21[14] = 2080;
    *(_QWORD *)&v21[16] = "publisher";
    *(_WORD *)&v21[24] = 2080;
    *(_QWORD *)&v21[26] = "service-publisher.c";
    v22 = 1024;
    v23 = 1465;
    v17 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_50;
  }
  v8 = global_os_log;
  if (v14 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_51;
    v18 = 136447490;
    v19 = "service_publisher_cancel";
    v20 = 1024;
    *(_DWORD *)v21 = v14;
    *(_WORD *)&v21[4] = 2048;
    *(_QWORD *)&v21[6] = a1;
    *(_WORD *)&v21[14] = 2080;
    *(_QWORD *)&v21[16] = "publisher";
    *(_WORD *)&v21[24] = 2080;
    *(_QWORD *)&v21[26] = "service-publisher.c";
    v22 = 1024;
    v23 = 1465;
    v17 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_50:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v17, (uint8_t *)&v18, 0x36u);
LABEL_51:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v18 = 136447490;
    v19 = "service_publisher_cancel";
    v20 = 1024;
    *(_DWORD *)v21 = v14;
    *(_WORD *)&v21[4] = 2048;
    *(_QWORD *)&v21[6] = a1;
    *(_WORD *)&v21[14] = 2080;
    *(_QWORD *)&v21[16] = "publisher";
    *(_WORD *)&v21[24] = 2080;
    *(_QWORD *)&v21[26] = "service-publisher.c";
    v22 = 1024;
    v23 = 1465;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
    v14 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v14 - 1;
  if (v14 == 1)
  {
    v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v18 = 136447234;
      v19 = "service_publisher_cancel";
      v20 = 2048;
      *(_QWORD *)v21 = a1;
      *(_WORD *)&v21[8] = 2080;
      *(_QWORD *)&v21[10] = "publisher";
      *(_WORD *)&v21[18] = 2080;
      *(_QWORD *)&v21[20] = "service-publisher.c";
      *(_WORD *)&v21[28] = 1024;
      *(_DWORD *)&v21[30] = 1465;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
LABEL_35:
  v16 = *(char **)(a1 + 80);
  if (v16)
    ifpermit_list_remove(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 72), v16);
  state_machine_cancel((uint64_t *)(a1 + 8));
}

void service_publisher_listener_cancel(uint64_t a1)
{
  uint64_t v2;
  __int16 v3;
  NSObject *v4;
  NSObject *v5;
  int v6;
  int v7;
  int v8;
  NSObject *v9;
  NSObject *v10;
  uint64_t v11;
  _BYTE v12[40];
  char *v13;
  __int16 v14;
  int v15;

  v2 = *(_QWORD *)(a1 + 112);
  if (v2)
  {
    if ((*(_WORD *)(v2 + 416) & 0x400) != 0)
    {
      v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v11 = *(_QWORD *)(v2 + 192);
        *(_DWORD *)v12 = 136446723;
        *(_QWORD *)&v12[4] = "ioloop_listener_cancel";
        *(_WORD *)&v12[12] = 2160;
        *(_QWORD *)&v12[14] = 1752392040;
        *(_WORD *)&v12[22] = 2081;
        *(_QWORD *)&v12[24] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: cancel on canceled connection %{private, mask.hash}s", v12, 0x20u);
      }
    }
    else
    {
      v3 = *(_WORD *)(v2 + 416) | 0x400;
      *(_WORD *)(v2 + 416) = v3;
      v4 = *(NSObject **)(v2 + 8);
      if (v4)
      {
        nw_listener_cancel(v4);
        v3 = *(_WORD *)(v2 + 416);
      }
      if ((v3 & 0x20) == 0 && !*(_QWORD *)v2 && *(_DWORD *)(v2 + 148) != -1)
      {
        ioloop_close(v2 + 56);
        if (*(_QWORD *)(v2 + 248))
        {
          v5 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v6 = *(_DWORD *)(v2 + 32);
            *(_DWORD *)v12 = 136447490;
            *(_QWORD *)&v12[4] = "ioloop_listener_cancel";
            *(_WORD *)&v12[12] = 1024;
            *(_DWORD *)&v12[14] = v6;
            *(_WORD *)&v12[18] = 2048;
            *(_QWORD *)&v12[20] = v2;
            *(_WORD *)&v12[28] = 2080;
            *(_QWORD *)&v12[30] = "connection";
            *(_WORD *)&v12[38] = 2080;
            v13 = "macos-ioloop.c";
            v14 = 1024;
            v15 = 1151;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v12, 0x36u);
          }
          v7 = *(_DWORD *)(v2 + 32);
          if (v7)
          {
            v8 = v7 + 1;
            *(_DWORD *)(v2 + 32) = v7 + 1;
            if (v7 + 1 >= 10001)
            {
              v9 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)v12 = 136447490;
                *(_QWORD *)&v12[4] = "ioloop_listener_cancel";
                *(_WORD *)&v12[12] = 1024;
                *(_DWORD *)&v12[14] = v8;
                *(_WORD *)&v12[18] = 2048;
                *(_QWORD *)&v12[20] = v2;
                *(_WORD *)&v12[28] = 2080;
                *(_QWORD *)&v12[30] = "connection";
                *(_WORD *)&v12[38] = 2080;
                v13 = "macos-ioloop.c";
                v14 = 1024;
                v15 = 1151;
                _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", v12, 0x36u);
              }
              abort();
            }
          }
          else
          {
            ++listener_created;
            *(_DWORD *)(v2 + 32) = 1;
          }
          *(_QWORD *)v12 = _NSConcreteStackBlock;
          *(_QWORD *)&v12[8] = 0x40000000;
          *(_QWORD *)&v12[16] = __ioloop_listener_cancel_block_invoke;
          *(_QWORD *)&v12[24] = &__block_descriptor_tmp_8_1131;
          *(_QWORD *)&v12[32] = v2;
          dispatch_async((dispatch_queue_t)ioloop_main_queue, v12);
        }
      }
    }
    ioloop_comm_release_(*(_QWORD *)(a1 + 112), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1195);
    *(_QWORD *)(a1 + 112) = 0;
  }
  *(_BYTE *)(a1 + 262) = 0;
  service_publisher_unadvertise_all(a1);
}

void service_publisher_service_tracker_callback(uint64_t a1)
{
  uint64_t v2;
  NSObject *v3;
  int *v4;
  int *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  void (*v9)(int *);
  NSObject *v10;
  const char *v11;
  int v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 56);
  if (v2 && *(_BYTE *)(v2 + 72))
  {
    v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v12 = 136446210;
      v13 = "service_publisher_service_tracker_callback";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: setting seen_service_list to true", (uint8_t *)&v12, 0xCu);
    }
    *(_BYTE *)(a1 + 263) = 1;
  }
  v4 = state_machine_event_create(4);
  if (v4)
  {
    v5 = v4;
    state_machine_event_deliver(a1 + 8, (uint64_t)v4);
    v6 = *v5;
    if (*v5)
    {
      v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136447490;
          v13 = "service_publisher_service_tracker_callback";
          v14 = 1024;
          *(_DWORD *)v15 = v6;
          *(_WORD *)&v15[4] = 2048;
          *(_QWORD *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(_QWORD *)&v15[16] = "event";
          *(_WORD *)&v15[24] = 2080;
          *(_QWORD *)&v15[26] = "service-publisher.c";
          v16 = 1024;
          v17 = 849;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
          v6 = *v5;
        }
        *v5 = v6 - 1;
        if (v6 == 1)
        {
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v12 = 136447234;
            v13 = "service_publisher_service_tracker_callback";
            v14 = 2048;
            *(_QWORD *)v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(_QWORD *)&v15[10] = "event";
            *(_WORD *)&v15[18] = 2080;
            *(_QWORD *)&v15[20] = "service-publisher.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 849;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
          }
          ++state_machine_event_finalized;
          v9 = (void (*)(int *))*((_QWORD *)v5 + 4);
          if (v9)
            v9(v5);
          free(v5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_25:
        abort();
      v12 = 136447490;
      v13 = "service_publisher_service_tracker_callback";
      v14 = 1024;
      *(_DWORD *)v15 = v6;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "service-publisher.c";
      v16 = 1024;
      v17 = 849;
      v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_25;
      v12 = 136447490;
      v13 = "service_publisher_service_tracker_callback";
      v14 = 1024;
      *(_DWORD *)v15 = 0;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "service-publisher.c";
      v16 = 1024;
      v17 = 849;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
    goto LABEL_25;
  }
  v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v12 = 136446210;
    v13 = "service_publisher_service_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v12, 0xCu);
  }
}

void service_publisher_context_release(int *a1)
{
  int v2;
  NSObject *v3;
  NSObject *v4;
  const char *v5;
  int v6;
  const char *v7;
  __int16 v8;
  _BYTE v9[34];
  __int16 v10;
  int v11;

  if (!a1)
    return;
  v2 = *a1;
  if (!*a1)
  {
    v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "service_publisher_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "publisher";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "service-publisher.c";
    v10 = 1024;
    v11 = 463;
    v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_16;
    v6 = 136447490;
    v7 = "service_publisher_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "publisher";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "service-publisher.c";
    v10 = 1024;
    v11 = 463;
    v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v6 = 136447490;
    v7 = "service_publisher_context_release";
    v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(_QWORD *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(_QWORD *)&v9[16] = "publisher";
    *(_WORD *)&v9[24] = 2080;
    *(_QWORD *)&v9[26] = "service-publisher.c";
    v10 = 1024;
    v11 = 463;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v6 = 136447234;
      v7 = "service_publisher_context_release";
      v8 = 2048;
      *(_QWORD *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(_QWORD *)&v9[10] = "publisher";
      *(_WORD *)&v9[18] = 2080;
      *(_QWORD *)&v9[20] = "service-publisher.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 463;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize((uint64_t)a1);
  }
}

void service_publisher_thread_tracker_callback(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  int *v5;
  int *v6;
  int v7;
  NSObject *v8;
  NSObject *v9;
  void (*v10)(int *);
  NSObject *v11;
  const char *v12;
  int v13;
  const char *v14;
  __int16 v15;
  _BYTE v16[34];
  __int16 v17;
  int v18;

  v2 = *(_QWORD *)(a1 + 88);
  v3 = *(_QWORD *)(v2 + 56);
  if (v3)
  {
    v4 = *(_QWORD **)(v2 + 40);
    if (*(_BYTE *)(v3 + 72))
    {
      service_tracker_start(v4);
      goto LABEL_6;
    }
  }
  else
  {
    v4 = *(_QWORD **)(v2 + 40);
  }
  service_tracker_stop(v4);
LABEL_6:
  v5 = state_machine_event_create(9);
  if (v5)
  {
    v6 = v5;
    state_machine_event_deliver(a1 + 8, (uint64_t)v5);
    v7 = *v6;
    if (*v6)
    {
      v8 = global_os_log;
      if (v7 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v13 = 136447490;
          v14 = "service_publisher_thread_tracker_callback";
          v15 = 1024;
          *(_DWORD *)v16 = v7;
          *(_WORD *)&v16[4] = 2048;
          *(_QWORD *)&v16[6] = v6;
          *(_WORD *)&v16[14] = 2080;
          *(_QWORD *)&v16[16] = "event";
          *(_WORD *)&v16[24] = 2080;
          *(_QWORD *)&v16[26] = "service-publisher.c";
          v17 = 1024;
          v18 = 875;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v13, 0x36u);
          v7 = *v6;
        }
        *v6 = v7 - 1;
        if (v7 == 1)
        {
          v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v13 = 136447234;
            v14 = "service_publisher_thread_tracker_callback";
            v15 = 2048;
            *(_QWORD *)v16 = v6;
            *(_WORD *)&v16[8] = 2080;
            *(_QWORD *)&v16[10] = "event";
            *(_WORD *)&v16[18] = 2080;
            *(_QWORD *)&v16[20] = "service-publisher.c";
            *(_WORD *)&v16[28] = 1024;
            *(_DWORD *)&v16[30] = 875;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v13, 0x30u);
          }
          ++state_machine_event_finalized;
          v10 = (void (*)(int *))*((_QWORD *)v6 + 4);
          if (v10)
            v10(v6);
          free(v6);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_25:
        abort();
      v13 = 136447490;
      v14 = "service_publisher_thread_tracker_callback";
      v15 = 1024;
      *(_DWORD *)v16 = v7;
      *(_WORD *)&v16[4] = 2048;
      *(_QWORD *)&v16[6] = v6;
      *(_WORD *)&v16[14] = 2080;
      *(_QWORD *)&v16[16] = "event";
      *(_WORD *)&v16[24] = 2080;
      *(_QWORD *)&v16[26] = "service-publisher.c";
      v17 = 1024;
      v18 = 875;
      v12 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v8 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_25;
      v13 = 136447490;
      v14 = "service_publisher_thread_tracker_callback";
      v15 = 1024;
      *(_DWORD *)v16 = 0;
      *(_WORD *)&v16[4] = 2048;
      *(_QWORD *)&v16[6] = v6;
      *(_WORD *)&v16[14] = 2080;
      *(_QWORD *)&v16[16] = "event";
      *(_WORD *)&v16[24] = 2080;
      *(_QWORD *)&v16[26] = "service-publisher.c";
      v17 = 1024;
      v18 = 875;
      v12 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v13, 0x36u);
    goto LABEL_25;
  }
  v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v13 = 136446210;
    v14 = "service_publisher_thread_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v13, 0xCu);
  }
}

void service_publisher_node_type_tracker_callback(uint64_t a1)
{
  int *v2;
  int *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  void (*v7)(int *);
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = state_machine_event_create(10);
  if (v2)
  {
    v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    v4 = *v3;
    if (*v3)
    {
      v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136447490;
          v11 = "service_publisher_node_type_tracker_callback";
          v12 = 1024;
          *(_DWORD *)v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(_QWORD *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(_QWORD *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(_QWORD *)&v13[26] = "service-publisher.c";
          v14 = 1024;
          v15 = 888;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          v4 = *v3;
        }
        *v3 = v4 - 1;
        if (v4 == 1)
        {
          v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136447234;
            v11 = "service_publisher_node_type_tracker_callback";
            v12 = 2048;
            *(_QWORD *)v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(_QWORD *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(_QWORD *)&v13[20] = "service-publisher.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 888;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          v7 = (void (*)(int *))*((_QWORD *)v3 + 4);
          if (v7)
            v7(v3);
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_20:
        abort();
      v10 = 136447490;
      v11 = "service_publisher_node_type_tracker_callback";
      v12 = 1024;
      *(_DWORD *)v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "service-publisher.c";
      v14 = 1024;
      v15 = 888;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_20;
      v10 = 136447490;
      v11 = "service_publisher_node_type_tracker_callback";
      v12 = 1024;
      *(_DWORD *)v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "service-publisher.c";
      v14 = 1024;
      v15 = 888;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v10 = 136446210;
    v11 = "service_publisher_node_type_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

uint64_t service_publisher_action_startup(uint64_t a1, uint64_t a2)
{
  int v2;
  _QWORD *v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t result;
  const char *v13;
  NSObject *v14;
  uint32_t v15;
  uint64_t v16;
  const char *v17;
  NSObject *v18;
  os_log_type_t v19;
  uint32_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  const char *v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;
  __int16 v38;
  uint64_t v39;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    v16 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v28 = 136446466;
    v29 = "service_publisher_action_startup";
    v30 = 1024;
    LODWORD(v31) = v2;
    v17 = "%{public}s: state header type isn't service_publisher: %d";
    v18 = v16;
    v19 = OS_LOG_TYPE_ERROR;
    v20 = 18;
    goto LABEL_16;
  }
  v4 = *(_QWORD **)(a1 + 8);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      v21 = v4[5];
      v22 = v4[1];
      v23 = v4[3];
      v28 = 136447235;
      v29 = "service_publisher_action_startup";
      v30 = 2082;
      v31 = v21;
      v32 = 2160;
      v33 = 1752392040;
      v34 = 2081;
      v35 = v22;
      v36 = 2082;
      v37 = v23;
      v13 = "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s";
      v14 = v5;
      v15 = 52;
      goto LABEL_12;
    }
    return 2;
  }
  if (v6)
  {
    v7 = v4[5];
    v8 = v4[1];
    v9 = *(_QWORD *)(a2 + 8);
    v10 = v4[3];
    v28 = 136447491;
    v29 = "service_publisher_action_startup";
    v30 = 2082;
    v31 = v7;
    v32 = 2160;
    v33 = 1752392040;
    v34 = 2081;
    v35 = v8;
    v36 = 2082;
    v37 = v9;
    v38 = 2082;
    v39 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", (uint8_t *)&v28, 0x3Eu);
    v5 = global_os_log;
  }
  v11 = *(_DWORD *)(a2 + 16);
  result = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v11 == 1)
  {
    if ((_DWORD)result)
    {
      v28 = 136446210;
      v29 = "service_publisher_action_startup";
      v13 = "%{public}s: startup timeout";
      v14 = v5;
      v15 = 12;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v28, v15);
      return 2;
    }
    return 2;
  }
  if ((_DWORD)result)
  {
    v24 = v4[5];
    v25 = v4[1];
    v26 = *(_QWORD *)(a2 + 8);
    v27 = v4[3];
    v28 = 136447491;
    v29 = "service_publisher_action_startup";
    v30 = 2082;
    v31 = v24;
    v32 = 2160;
    v33 = 1752392040;
    v34 = 2081;
    v35 = v25;
    v36 = 2082;
    v37 = v26;
    v38 = 2082;
    v39 = v27;
    v17 = "%{public}s: %{public}s/%{private, mask.hash}s: unexpected event %{public}s in state %{public}s";
    v18 = v5;
    v19 = OS_LOG_TYPE_DEFAULT;
    v20 = 62;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, (uint8_t *)&v28, v20);
    return 0;
  }
  return result;
}

uint64_t service_publisher_action_waiting_to_publish(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  uint64_t v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  uint32_t v13;
  NSObject *v14;
  uint64_t result;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  const char *v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  uint64_t v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    v14 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v19 = 136446466;
    v20 = "service_publisher_action_waiting_to_publish";
    v21 = 1024;
    LODWORD(v22) = v2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't service_publisher: %d", (uint8_t *)&v19, 0x12u);
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (!v6)
      goto LABEL_11;
    v7 = *(_QWORD *)(v4 + 40);
    v8 = *(_QWORD *)(v4 + 8);
    v9 = *(_QWORD *)(a2 + 8);
    v10 = *(_QWORD *)(v4 + 24);
    v19 = 136447491;
    v20 = "service_publisher_action_waiting_to_publish";
    v21 = 2082;
    v22 = v7;
    v23 = 2160;
    v24 = 1752392040;
    v25 = 2081;
    v26 = v8;
    v27 = 2082;
    v28 = v9;
    v29 = 2082;
    v30 = v10;
    v11 = "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s";
    v12 = v5;
    v13 = 62;
  }
  else
  {
    if (!v6)
      goto LABEL_11;
    v16 = *(_QWORD *)(v4 + 40);
    v17 = *(_QWORD *)(v4 + 8);
    v18 = *(_QWORD *)(v4 + 24);
    v19 = 136447235;
    v20 = "service_publisher_action_waiting_to_publish";
    v21 = 2082;
    v22 = v16;
    v23 = 2160;
    v24 = 1752392040;
    v25 = 2081;
    v26 = v17;
    v27 = 2082;
    v28 = v18;
    v11 = "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s";
    v12 = v5;
    v13 = 52;
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v19, v13);
LABEL_11:
  if (service_publisher_can_publish(v4))
  {
    ioloop_cancel_wake_event(*(_QWORD *)(v4 + 96));
    *(_BYTE *)(v4 + 269) = 0;
    return 4;
  }
  if (!service_publisher_have_competing_unicast_service(v4, 1))
  {
    if (a2 && *(_DWORD *)(a2 + 16) == 1 && !*(_BYTE *)(v4 + 268))
      service_publisher_re_advertise_matching(v4);
    return 0;
  }
  ioloop_cancel_wake_event(*(_QWORD *)(v4 + 96));
  *(_BYTE *)(v4 + 269) = 0;
  return 3;
}

uint64_t service_publisher_action_not_publishing(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    v12 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    v16 = 136446466;
    v17 = "service_publisher_action_not_publishing";
    v18 = 1024;
    LODWORD(v19) = v2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't service_publisher: %d", (uint8_t *)&v16, 0x12u);
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      v13 = *(_QWORD *)(v4 + 40);
      v14 = *(_QWORD *)(v4 + 8);
      v15 = *(_QWORD *)(v4 + 24);
      v16 = 136447235;
      v17 = "service_publisher_action_not_publishing";
      v18 = 2082;
      v19 = v13;
      v20 = 2160;
      v21 = 1752392040;
      v22 = 2081;
      v23 = v14;
      v24 = 2082;
      v25 = v15;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", (uint8_t *)&v16, 0x34u);
    }
    if (*(_QWORD *)(v4 + 128))
      service_publisher_service_unpublish(v4, 1);
    return 0;
  }
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 40);
    v8 = *(_QWORD *)(v4 + 8);
    v9 = *(_QWORD *)(a2 + 8);
    v10 = *(_QWORD *)(v4 + 24);
    v16 = 136447491;
    v17 = "service_publisher_action_not_publishing";
    v18 = 2082;
    v19 = v7;
    v20 = 2160;
    v21 = 1752392040;
    v22 = 2081;
    v23 = v8;
    v24 = 2082;
    v25 = v9;
    v26 = 2082;
    v27 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", (uint8_t *)&v16, 0x3Eu);
  }
  result = service_publisher_can_publish(v4);
  if ((_DWORD)result)
  {
    *(_DWORD *)(v4 + 248) = 5000;
    return 1;
  }
  return result;
}

uint64_t service_publisher_action_start_listeners(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  NSObject *v16;
  NSObject *v17;
  const char *v18;
  uint64_t v19;
  _DWORD *v20;
  NSObject *v21;
  uint8_t buf[4];
  const char *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    v12 = global_os_log;
    result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!(_DWORD)result)
      return result;
    *(_DWORD *)buf = 136446466;
    v23 = "service_publisher_action_start_listeners";
    v24 = 1024;
    LODWORD(v25) = v2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't service_publisher: %d", buf, 0x12u);
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 8);
  v5 = global_os_log;
  v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      v13 = *(_QWORD *)(v4 + 40);
      v14 = *(_QWORD *)(v4 + 8);
      v15 = *(_QWORD *)(v4 + 24);
      *(_DWORD *)buf = 136447235;
      v23 = "service_publisher_action_start_listeners";
      v24 = 2082;
      v25 = v13;
      v26 = 2160;
      v27 = 1752392040;
      v28 = 2081;
      v29 = v14;
      v30 = 2082;
      v31 = v15;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
    }
    if (*(_BYTE *)(v4 + 262))
    {
      if (*(_QWORD *)(v4 + 112))
        return 5;
      v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "service_publisher_action_start_listeners";
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "%{public}s: have_srp_listener is true but there's no listener!", buf, 0xCu);
      }
      *(_BYTE *)(v4 + 262) = 0;
    }
    if (*(_QWORD *)(v4 + 112))
    {
      v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136446210;
        v23 = "service_publisher_listener_start";
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%{public}s: listener still present", buf, 0xCu);
      }
      service_publisher_listener_cancel(v4);
    }
    v18 = *(const char **)(v4 + 80);
    v19 = *(_QWORD *)(v4 + 88);
    if (v18 && (LODWORD(v18) = if_nametoindex(v18), !(_DWORD)v18))
    {
      *(_QWORD *)(v4 + 112) = 0;
    }
    else
    {
      v20 = ioloop_listener_create(0, 0, 0, 0, "SRP UDP listener", (uint64_t)dns_input, (uint64_t)service_publisher_listener_cancel_callback, (uint64_t)service_publisher_listener_ready, 0, (int)v18, v19);
      *(_QWORD *)(v4 + 112) = v20;
      if (v20)
      {
LABEL_31:
        service_publisher_re_advertise_matching(v4);
        ioloop_listener_permitted_interface_list_set(*(_QWORD *)(v4 + 112), *(int **)(*(_QWORD *)(v4 + 88) + 72));
        return 0;
      }
    }
    v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v23 = "service_publisher_listener_start";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: failed to setup SRP listener", buf, 0xCu);
    }
    goto LABEL_31;
  }
  if (v6)
  {
    v7 = *(_QWORD *)(v4 + 40);
    v8 = *(_QWORD *)(v4 + 8);
    v9 = *(_QWORD *)(a2 + 8);
    v10 = *(_QWORD *)(v4 + 24);
    *(_DWORD *)buf = 136447491;
    v23 = "service_publisher_action_start_listeners";
    v24 = 2082;
    v25 = v7;
    v26 = 2160;
    v27 = 1752392040;
    v28 = 2081;
    v29 = v8;
    v30 = 2082;
    v31 = v9;
    v32 = 2082;
    v33 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
  }
  if ((service_publisher_can_publish(v4) & 1) != 0)
  {
    if (*(_DWORD *)(a2 + 16) == 5)
      return 5;
    else
      return 0;
  }
  else
  {
    service_publisher_listener_cancel(v4);
    return 3;
  }
}

uint64_t service_publisher_action_publishing(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v4;
  NSObject *v5;
  _BOOL4 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  NSObject *v15;
  os_log_type_t v16;
  uint32_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  const char *v24;
  NSObject *v25;
  uint32_t v26;
  int *v27;
  int v28;
  uint32_t v29;
  uint64_t **v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  char *v37;
  char *v38;
  size_t v39;
  char *v40;
  char *v41;
  int v42;
  NSObject *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint8_t buf[4];
  const char *v72;
  __int16 v73;
  uint64_t v74;
  __int16 v75;
  uint64_t v76;
  __int16 v77;
  uint64_t v78;
  __int16 v79;
  uint64_t *v80;
  __int16 v81;
  uint64_t v82;
  __int16 v83;
  uint64_t v84;

  v2 = *(_DWORD *)(a1 + 52);
  if (v2 == 2)
  {
    v4 = *(_QWORD *)(a1 + 8);
    v5 = global_os_log;
    v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v6)
      {
        v7 = *(_QWORD *)(v4 + 40);
        v8 = *(_QWORD *)(v4 + 8);
        v9 = *(uint64_t **)(a2 + 8);
        v10 = *(_QWORD *)(v4 + 24);
        *(_DWORD *)buf = 136447491;
        v72 = "service_publisher_action_publishing";
        v73 = 2082;
        v74 = v7;
        v75 = 2160;
        v76 = 1752392040;
        v77 = 2081;
        v78 = v8;
        v79 = 2082;
        v80 = v9;
        v81 = 2082;
        v82 = v10;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
      }
      v11 = *(_DWORD *)(a2 + 16);
      if (v11 > 6)
      {
        if (v11 == 7)
        {
          service_publisher_listener_cancel(v4);
          v12 = 1;
          service_publisher_service_unpublish(v4, 1);
          return v12;
        }
        if (v11 != 19)
          goto LABEL_67;
      }
      else if (v11 != 1)
      {
        if (v11 == 6)
        {
          v12 = 1;
          service_publisher_service_unpublish(v4, 1);
          *(_DWORD *)(v4 + 248) = 1;
          return v12;
        }
LABEL_67:
        if ((service_publisher_can_publish(v4) & 1) == 0)
        {
          service_publisher_listener_cancel(v4);
          service_publisher_service_unpublish(v4, 1);
          return 3;
        }
        if (*(_DWORD *)(a2 + 16) != 4)
          return 0;
        v52 = *(_QWORD *)(v4 + 128);
        if ((!v52 || *(_BYTE *)(v4 + 266)) && (!*(_QWORD *)(v4 + 136) || *(_BYTE *)(v4 + 267)))
          return 0;
        *(_WORD *)(v4 + 266) = 0;
        v53 = *(_QWORD *)(v4 + 88);
        v54 = *(_QWORD *)(v53 + 40);
        if (v54)
        {
          v55 = *(_QWORD *)(v54 + 48);
          if (v55)
          {
            LODWORD(v54) = 0;
            v56 = 0;
            do
            {
              v57 = *(_DWORD *)(v55 + 20);
              if (v57 == 3)
              {
                if (*(_BYTE *)(v55 + 25))
                {
                  if (*(_BYTE *)(v53 + 278))
                  {
                    if (*(unsigned __int16 *)(v55 + 16) == *(unsigned __int16 *)(v53 + 276))
                    {
                      v60 = *(_QWORD *)(v4 + 136);
                      if (v60)
                      {
                        if (*(unsigned __int8 *)(v55 + 80) == *(unsigned __int8 *)(v60 + 80))
                        {
                          LODWORD(v54) = 1;
                          *(_BYTE *)(v4 + 267) = 1;
                        }
                      }
                    }
                  }
                }
              }
              else if (v57 == 2 && *(_BYTE *)(v55 + 25) && v52 != 0)
              {
                v59 = *(_QWORD *)(v55 + 64) == *(_QWORD *)(v52 + 64) && *(_QWORD *)(v55 + 72) == *(_QWORD *)(v52 + 72);
                if (v59 && *(unsigned __int16 *)(v55 + 80) == *(unsigned __int16 *)(v52 + 80))
                {
                  v56 = 1;
                  *(_BYTE *)(v4 + 266) = 1;
                }
              }
              v55 = *(_QWORD *)(v55 + 8);
            }
            while (v55);
            goto LABEL_106;
          }
          LODWORD(v54) = 0;
        }
        v56 = 0;
LABEL_106:
        if ((!v52 || v56) && (!*(_QWORD *)(v4 + 136) || (_DWORD)v54))
          ioloop_cancel_wake_event(*(_QWORD *)(v4 + 96));
        return 0;
      }
      if (!*(_QWORD *)(v4 + 128))
      {
LABEL_21:
        v22 = *(_QWORD *)(v4 + 88);
        if (!*(_BYTE *)(v22 + 287))
          goto LABEL_26;
        if (*(_BYTE *)(v22 + 288))
        {
          v23 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446210;
            v72 = "service_publisher_wanted_service_missing";
            v24 = "%{public}s: srp_service_needed == true -> true";
            v25 = v23;
            v26 = 12;
            goto LABEL_25;
          }
          goto LABEL_26;
        }
        v31 = *(uint64_t ***)(v22 + 80);
        if (!v31)
          goto LABEL_65;
        v70 = *(_QWORD *)(v4 + 88);
LABEL_36:
        v32 = *(_QWORD **)(v22 + 8);
        if (v32)
        {
          while (1)
          {
            v33 = v32[14];
            if (v33)
            {
              if (*(int *)(v33 + 4) >= 1)
                break;
            }
LABEL_52:
            v32 = (_QWORD *)v32[5];
            if (!v32)
              goto LABEL_101;
          }
          v34 = 0;
          while (1)
          {
            v35 = *(_QWORD *)(*(_QWORD *)(v33 + 8) + 8 * v34);
            if (v35 && !strcasecmp(*(const char **)(v35 + 48), (const char *)v31[1]))
            {
              v36 = (const char *)v31[2];
              v37 = *(char **)(v35 + 56);
              v38 = strchr(v37, 44);
              if (v38)
              {
                v39 = v38 - v37;
                v40 = (char *)malloc_type_malloc(v38 - v37 + 1, 0xC28C7701uLL);
                if (v40)
                {
                  v41 = v40;
                  memcpy(v40, v37, v39);
                  v41[v39] = 0;
                  v42 = strcasecmp(v36, v41);
                  free(v41);
                  if (!v42)
                    goto LABEL_54;
                }
                else
                {
                  v43 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)buf = 136446210;
                    v72 = "adv_ctl_service_types_compare";
                    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%{public}s: no memory for base_type, comparison can't be done.", buf, 0xCu);
                  }
                }
              }
              else if (!strcasecmp(v36, v37))
              {
LABEL_54:
                v44 = v32[12];
                if (v44)
                {
                  v45 = *(unsigned int *)(v44 + 4);
                  if ((int)v45 >= 1)
                  {
                    v46 = *(uint64_t **)(v44 + 8);
                    while (1)
                    {
                      v47 = *v46;
                      if (*v46)
                      {
                        if (*(_WORD *)(v47 + 50) == 16 && **(_QWORD **)(v47 + 40) == *(_QWORD *)(v4 + 176))
                          break;
                      }
                      ++v46;
                      if (!--v45)
                        goto LABEL_99;
                    }
                    v48 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      v49 = (uint64_t)v31[1];
                      v50 = v31[2];
                      *(_DWORD *)buf = 136447235;
                      v72 = "service_publisher_wanted_service_missing";
                      v73 = 2160;
                      v74 = 1752392040;
                      v75 = 2081;
                      v76 = v49;
                      v77 = 2160;
                      v78 = 1752392040;
                      v79 = 2081;
                      v80 = v50;
                      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%{public}s: service %{private, mask.hash}s.%{private, mask.hash}s is present", buf, 0x34u);
                    }
                    v31 = (uint64_t **)*v31;
                    v22 = v70;
                    if (!v31)
                    {
LABEL_65:
                      v51 = global_os_log;
                      v12 = 0;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446210;
                        v72 = "service_publisher_wanted_service_missing";
                        v14 = "%{public}s: all needed services present -> false";
                        v15 = v51;
                        v16 = OS_LOG_TYPE_DEFAULT;
                        v17 = 12;
LABEL_11:
                        _os_log_impl((void *)&_mh_execute_header, v15, v16, v14, buf, v17);
                        return 0;
                      }
                      return v12;
                    }
                    goto LABEL_36;
                  }
LABEL_99:
                  v61 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    v62 = (uint64_t)v31[1];
                    v63 = v31[2];
                    v64 = *(_QWORD *)(v35 + 48);
                    *(_DWORD *)buf = 136447747;
                    v72 = "service_publisher_wanted_service_missing";
                    v73 = 2160;
                    v74 = 1752392040;
                    v75 = 2081;
                    v76 = v62;
                    v77 = 2160;
                    v78 = 1752392040;
                    v79 = 2081;
                    v80 = v63;
                    v81 = 2160;
                    v82 = 1752392040;
                    v83 = 2081;
                    v84 = v64;
                    v24 = "%{public}s: srp service %{private, mask.hash}s.%{private, mask.hash}s present as %{private, ma"
                          "sk.hash}s but has no address on local mesh -> true";
                    v25 = v61;
                    v26 = 72;
                    goto LABEL_25;
                  }
LABEL_26:
                  *(_WORD *)buf = bswap32(*(unsigned __int16 *)(v4 + 256)) >> 16;
                  v27 = thread_service_unicast_create_(*(_WORD *)(*(_QWORD *)(v4 + 88) + 276), (_OWORD *)(v4 + 176), buf, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1367);
                  service_publisher_queue_update(v4, (uint64_t)v27, 6);
                  thread_service_release_(v27, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1369);
                  if (a2)
                  {
                    service_tracker_start(*(_QWORD **)(*(_QWORD *)(v4 + 88) + 40));
                    v28 = *(_DWORD *)(v4 + 252);
                    if (v28 <= 3599)
                    {
                      v28 *= 2;
                      goto LABEL_30;
                    }
                  }
                  else
                  {
                    v28 = 5;
LABEL_30:
                    *(_DWORD *)(v4 + 252) = v28;
                  }
                  v29 = arc4random();
                  service_publisher_start_wait(v4, ((v29 % (unint64_t)(1000 * *(int *)(v4 + 252))) >> 1) + 1000 * v28);
                  return 0;
                }
                v65 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  goto LABEL_26;
                v68 = (uint64_t)v31[1];
                v69 = v31[2];
                *(_DWORD *)buf = 136447235;
                v72 = "service_publisher_wanted_service_missing";
                v73 = 2160;
                v74 = 1752392040;
                v75 = 2081;
                v76 = v68;
                v77 = 2160;
                v78 = 1752392040;
                v79 = 2081;
                v80 = v69;
                v24 = "%{public}s: srp service %{private, mask.hash}s.%{private, mask.hash}s present but no addresses -> true";
LABEL_103:
                v25 = v65;
                v26 = 52;
LABEL_25:
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
                goto LABEL_26;
              }
              v33 = v32[14];
            }
            if (++v34 >= *(int *)(v33 + 4))
              goto LABEL_52;
          }
        }
LABEL_101:
        v65 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          goto LABEL_26;
        v66 = (uint64_t)v31[1];
        v67 = v31[2];
        *(_DWORD *)buf = 136447235;
        v72 = "service_publisher_wanted_service_missing";
        v73 = 2160;
        v74 = 1752392040;
        v75 = 2081;
        v76 = v66;
        v77 = 2160;
        v78 = 1752392040;
        v79 = 2081;
        v80 = v67;
        v24 = "%{public}s: service %{private, mask.hash}s.%{private, mask.hash}s host not present -> true";
        goto LABEL_103;
      }
    }
    else
    {
      if (v6)
      {
        v18 = *(_QWORD *)(v4 + 40);
        v19 = *(_QWORD *)(v4 + 8);
        v20 = *(uint64_t **)(v4 + 24);
        *(_DWORD *)buf = 136447235;
        v72 = "service_publisher_action_publishing";
        v73 = 2082;
        v74 = v18;
        v75 = 2160;
        v76 = 1752392040;
        v77 = 2081;
        v78 = v19;
        v79 = 2082;
        v80 = v20;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
      }
      if (!*(_QWORD *)(v4 + 128))
        goto LABEL_21;
      v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v72 = "service_publisher_action_publishing";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: unicast service still published!", buf, 0xCu);
      }
    }
    service_publisher_service_unpublish(v4, a2 == 0);
    goto LABEL_21;
  }
  v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v72 = "service_publisher_action_publishing";
    v73 = 1024;
    LODWORD(v74) = v2;
    v14 = "%{public}s: state header type isn't service_publisher: %d";
    v15 = v13;
    v16 = OS_LOG_TYPE_ERROR;
    v17 = 18;
    goto LABEL_11;
  }
  return 0;
}

void service_publisher_service_unpublish(uint64_t a1, int a2)
{
  int *v2;
  int *service_for_queue;
  NSObject *v5;
  int v6;
  const char *v7;

  v2 = *(int **)(a1 + 128);
  *(_QWORD *)(a1 + 128) = 0;
  if (v2)
  {
    if (a2)
    {
      service_for_queue = service_publisher_create_service_for_queue((uint64_t)v2);
      service_publisher_queue_update(a1, (uint64_t)service_for_queue, 7);
      thread_service_release_(service_for_queue, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 660);
      thread_service_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 661);
    }
  }
  else
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v6 = 136446210;
      v7 = "service_publisher_service_unpublish";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: request to unpublished service that's not present", (uint8_t *)&v6, 0xCu);
    }
  }
}

void service_publisher_queue_update(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v7;
  BOOL v8;
  NSObject *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  NSObject *v14;
  int v15;
  const char *v16;
  __int16 v17;
  uint64_t v18;

  v3 = *(_DWORD *)(a2 + 20);
  if (v3 == 2)
  {
    v7 = *(_QWORD *)(a1 + 128);
    if (v7)
      v8 = a2 == 0;
    else
      v8 = 1;
    if (!v8
      && *(_DWORD *)(v7 + 20) == 2
      && *(_QWORD *)(v7 + 64) == *(_QWORD *)(a2 + 64)
      && *(_QWORD *)(v7 + 72) == *(_QWORD *)(a2 + 72)
      && *(unsigned __int16 *)(v7 + 80) == *(unsigned __int16 *)(a2 + 80))
    {
      v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v15 = 136446466;
        v16 = "service_publisher_queue_update";
        v17 = 2048;
        v18 = v7;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: published service still present: %p", (uint8_t *)&v15, 0x16u);
      }
    }
    *(_DWORD *)(a2 + 32) = a3;
    if (a3 == 6)
    {
      *(_QWORD *)(a1 + 128) = a2;
      thread_service_retain_((int *)a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 603);
    }
    v11 = (_QWORD *)(a1 + 144);
    do
    {
      v12 = v11;
      v13 = *v11;
      v11 = (_QWORD *)(*v11 + 8);
    }
    while (v13);
    *v12 = a2;
    thread_service_retain_((int *)a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 610);
    service_publisher_queue_run(a1);
  }
  else
  {
    v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      v15 = 136446466;
      v16 = "service_publisher_queue_update";
      v17 = 1024;
      LODWORD(v18) = v3;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: unsupported service type %d", (uint8_t *)&v15, 0x12u);
    }
  }
}

void service_publisher_start_wait(uint64_t a1, unsigned int a2)
{
  NSObject *v3;
  int v4;
  int v5;
  NSObject *v6;
  int v7;
  uint8_t buf[4];
  const char *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  char *v17;
  __int16 v18;
  int v19;

  ioloop_add_wake_event(*(_QWORD *)(a1 + 96), a1, (uint64_t)service_publisher_wait_expired, (uint64_t)service_publisher_context_release, a2);
  v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v4 = *(_DWORD *)a1;
    *(_DWORD *)buf = 136447490;
    v9 = "service_publisher_start_wait";
    v10 = 1024;
    v11 = v4;
    v12 = 2048;
    v13 = a1;
    v14 = 2080;
    v15 = "publisher";
    v16 = 2080;
    v17 = "service-publisher.c";
    v18 = 1024;
    v19 = 701;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  if (*(_DWORD *)a1)
  {
    v5 = *(_DWORD *)a1 + 1;
    *(_DWORD *)a1 = v5;
    if (v5 >= 10001)
    {
      v7 = v5;
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v9 = "service_publisher_start_wait";
        v10 = 1024;
        v11 = v7;
        v12 = 2048;
        v13 = a1;
        v14 = 2080;
        v15 = "publisher";
        v16 = 2080;
        v17 = "service-publisher.c";
        v18 = 1024;
        v19 = 701;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      abort();
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)a1 = 1;
  }
}

uint64_t service_publisher_can_publish(uint64_t a1)
{
  int have_competing_unicast_service;
  int v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  const char *v12;
  NSObject *v13;
  uint64_t v14;
  int v15;
  int v16;
  const char *v17;
  const char *v18;
  int v19;
  int v20;
  BOOL v21;
  int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  const char *v28;
  const char *v29;
  NSObject *v30;
  int v31;
  const char *v32;
  int v33;
  const char *v34;
  const char *v35;
  const char *v36;
  const char *v37;
  const char *v38;
  const char *v39;
  const char *v40;
  int *v42;
  NSObject *v43;
  int v44;
  int v45;
  int v46;
  NSObject *v47;
  const char *v48;
  const char *v49;
  const char *v50;
  const char *v51;
  int v52;
  uint8_t buf[4];
  const char *v54;
  __int16 v55;
  _BYTE v56[40];
  const char *v57;
  __int16 v58;
  const char *v59;
  __int16 v60;
  const char *v61;
  __int16 v62;
  const char *v63;
  __int16 v64;
  const char *v65;
  __int16 v66;
  const char *v67;
  __int16 v68;
  const char *v69;
  __int16 v70;
  const char *v71;
  __int16 v72;
  const char *v73;
  __int16 v74;
  const char *v75;

  have_competing_unicast_service = service_publisher_have_competing_unicast_service(a1, 0);
  v3 = have_competing_unicast_service;
  v4 = *(_QWORD **)(a1 + 88);
  v5 = v4[5];
  if (v5)
  {
    v6 = *(_QWORD *)(v5 + 48);
    v7 = (const char *)&unk_10007C3B5;
    if (v6)
    {
      v8 = 0;
      do
      {
        if (!*(_BYTE *)(v6 + 27) && *(_DWORD *)(v6 + 20) == 3)
        {
          thread_service_note(*(_QWORD *)(a1 + 72), v6, (uint64_t)"is present and supersedes our unicast service");
          v8 = 1;
        }
        v6 = *(_QWORD *)(v6 + 8);
      }
      while (v6);
      v9 = v8 | v3;
      if ((v8 & 1) != 0)
        v7 = " anycast service present";
      v4 = *(_QWORD **)(a1 + 88);
    }
    else
    {
      v9 = have_competing_unicast_service;
    }
  }
  else
  {
    v9 = have_competing_unicast_service;
    v7 = (const char *)&unk_10007C3B5;
  }
  v10 = v4[7];
  if (v10 && *(_BYTE *)(v10 + 72))
  {
    v11 = v9 ^ 1;
    v12 = (const char *)&unk_10007C3B5;
  }
  else
  {
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v54 = "service_publisher_can_publish";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: setting seen_service_list to false", buf, 0xCu);
    }
    v11 = 0;
    *(_BYTE *)(a1 + 263) = 0;
    v12 = " not associated ";
  }
  v51 = v7;
  v52 = v3;
  v14 = v4[8];
  if (v14)
  {
    v15 = 0;
    v16 = 0;
    v17 = (const char *)&unk_10007C3B5;
    v18 = (const char *)&unk_10007C3B5;
    switch(*(_DWORD *)(v14 + 64))
    {
      case 0:
        goto LABEL_22;
      case 1:
      case 7:
        break;
      case 3:
      case 4:
        v15 = 0;
        v18 = (const char *)&unk_10007C3B5;
        v16 = 1;
        goto LABEL_23;
      case 8:
        v16 = 0;
        v18 = (const char *)&unk_10007C3B5;
        v15 = 1;
        goto LABEL_23;
      default:
        v15 = 0;
        v16 = 0;
        v18 = (const char *)&unk_10007C3B5;
        goto LABEL_23;
    }
  }
  else
  {
LABEL_22:
    v11 = 0;
    v15 = 0;
    v16 = 0;
    v18 = " don't have node type";
LABEL_23:
    v17 = " not a router ";
  }
  v19 = *(unsigned __int8 *)(a1 + 258);
  v20 = *(unsigned __int8 *)(a1 + 265);
  if (*(_BYTE *)(a1 + 263))
    v21 = *(_BYTE *)(a1 + 264) == 0;
  else
    v21 = 0;
  v24 = v21 && v19 != 0 && v20 != 0;
  v25 = v24 & v11;
  v26 = *(_QWORD *)(a1 + 240);
  if (*(_QWORD *)(a1 + 232))
    v27 = v25;
  else
    v27 = v25 & ~v15;
  if (*(_QWORD *)(a1 + 232))
    v28 = (const char *)&unk_10007C3B5;
  else
    v28 = " no wed ml-eid ";
  if (v26)
    v29 = (const char *)&unk_10007C3B5;
  else
    v29 = " no neighbor ml-eid ";
  v49 = v18;
  v50 = v12;
  v48 = v28;
  if (v16 && !v26)
  {
    if (!*(_QWORD *)(a1 + 104))
    {
      v42 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1060);
      *(_QWORD *)(a1 + 104) = v42;
      if (v42)
      {
        ioloop_add_wake_event((uint64_t)v42, a1, (uint64_t)service_publisher_sed_timeout_expired, (uint64_t)service_publisher_context_release, 0x1F4u);
        v43 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v44 = *(_DWORD *)a1;
          *(_DWORD *)buf = 136447490;
          v54 = "service_publisher_can_publish";
          v55 = 1024;
          *(_DWORD *)v56 = v44;
          *(_WORD *)&v56[4] = 2048;
          *(_QWORD *)&v56[6] = a1;
          *(_WORD *)&v56[14] = 2080;
          *(_QWORD *)&v56[16] = "publisher";
          *(_WORD *)&v56[24] = 2080;
          *(_QWORD *)&v56[26] = "service-publisher.c";
          *(_WORD *)&v56[34] = 1024;
          *(_DWORD *)&v56[36] = 1064;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        v45 = *(_DWORD *)a1;
        if (!*(_DWORD *)a1)
        {
          v27 = 0;
          ++service_publisher_created;
          *(_DWORD *)a1 = 1;
          goto LABEL_49;
        }
        v46 = v45 + 1;
        *(_DWORD *)a1 = v45 + 1;
        if (v45 + 1 >= 10001)
        {
          v47 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            v54 = "service_publisher_can_publish";
            v55 = 1024;
            *(_DWORD *)v56 = v46;
            *(_WORD *)&v56[4] = 2048;
            *(_QWORD *)&v56[6] = a1;
            *(_WORD *)&v56[14] = 2080;
            *(_QWORD *)&v56[16] = "publisher";
            *(_WORD *)&v56[24] = 2080;
            *(_QWORD *)&v56[26] = "service-publisher.c";
            *(_WORD *)&v56[34] = 1024;
            *(_DWORD *)&v56[36] = 1064;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
    }
    v27 = 0;
LABEL_49:
    v29 = " no neighbor ml-eid ";
  }
  v30 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v31 = *(unsigned __int8 *)(a1 + 263);
    v32 = "can't publish";
    v33 = *(unsigned __int8 *)(a1 + 264);
    if ((_DWORD)v27)
      v32 = "can publish";
    *(_DWORD *)buf = 136449794;
    v54 = "service_publisher_can_publish";
    v55 = 2082;
    v34 = " have not seen service list";
    *(_QWORD *)v56 = v32;
    v35 = " competing service present";
    *(_WORD *)&v56[8] = 2082;
    if (v31)
      v34 = (const char *)&unk_10007C3B5;
    *(_QWORD *)&v56[10] = v34;
    v36 = " not a sleepy router";
    *(_WORD *)&v56[18] = 2082;
    if (!v52)
      v35 = (const char *)&unk_10007C3B5;
    *(_QWORD *)&v56[20] = v35;
    v37 = " not a sleepy end device";
    *(_WORD *)&v56[28] = 2082;
    if (v15)
      v36 = (const char *)&unk_10007C3B5;
    *(_QWORD *)&v56[30] = v51;
    v38 = " no ml-eid ";
    *(_WORD *)&v56[38] = 2082;
    if (v16)
      v37 = (const char *)&unk_10007C3B5;
    v57 = v50;
    v39 = " no thread interface name ";
    v58 = 2082;
    if (v19)
      v38 = (const char *)&unk_10007C3B5;
    v59 = v17;
    v60 = 2082;
    if (v20)
      v39 = (const char *)&unk_10007C3B5;
    v61 = v36;
    if (v33)
      v40 = " stopped";
    else
      v40 = (const char *)&unk_10007C3B5;
    v62 = 2082;
    v63 = v37;
    v64 = 2082;
    v65 = v49;
    v66 = 2082;
    v67 = v38;
    v68 = 2082;
    v69 = v48;
    v70 = 2082;
    v71 = v29;
    v72 = 2082;
    v73 = v39;
    v74 = 2082;
    v75 = v40;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s", buf, 0x98u);
  }
  return v27;
}

uint64_t service_publisher_have_competing_unicast_service(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  char v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  NSObject *v12;
  unint64_t v13;
  unint64_t v14;
  const char *v15;
  BOOL v16;
  int v17;
  const char *v18;
  uint8_t buf[4];
  const char *v21;

  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 40);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 48);
    if (v3)
    {
      v6 = 0;
      v7 = *(_QWORD *)(a1 + 128);
      v8 = &dnssd_client_states;
      while (1)
      {
        if (*(_BYTE *)(v3 + 27) || *(_DWORD *)(v3 + 20) != 2)
          goto LABEL_27;
        if (v7)
        {
          if (*(_QWORD *)(v3 + 64) == *(_QWORD *)(v7 + 64))
          {
            v13 = bswap64(*(_QWORD *)(v3 + 64));
            v14 = bswap64(*(_QWORD *)(v7 + 64));
            if (v13 == v14)
            {
              v13 = bswap64(*(_QWORD *)(v3 + 72));
              v14 = bswap64(*(_QWORD *)(v7 + 72));
              if (v13 == v14)
              {
                v9 = *(_QWORD *)(a1 + 72);
                v10 = v3;
                if (*(unsigned __int16 *)(v3 + 80) == *(unsigned __int16 *)(v7 + 80))
                {
                  v18 = "is the one we are publishing.";
                  goto LABEL_38;
                }
                v15 = "is on our ml-eid but is not the one we are publishing, so it's stale.";
                goto LABEL_34;
              }
            }
            if (v13 < v14)
              v17 = -1;
            else
              v17 = 1;
            if (*(unsigned __int16 *)(v3 + 16) == *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 276))
            {
              v9 = *(_QWORD *)(a1 + 72);
              v10 = v3;
              v15 = "is a stale service published on our rloc16 with a different ml-eid.";
LABEL_34:
              thread_service_note(v9, v10, (uint64_t)v15);
              service_publisher_unpublish_stale_service(a1, v3);
              goto LABEL_27;
            }
            v9 = *(_QWORD *)(a1 + 72);
            v10 = v3;
            if ((v17 & 0x80000000) == 0)
            {
              v18 = "is not ours and loses against ours.";
LABEL_38:
              thread_service_note(v9, v10, (uint64_t)v18);
              goto LABEL_27;
            }
            v11 = "is not ours and wins against ours.";
          }
          else
          {
            v9 = *(_QWORD *)(a1 + 72);
            v10 = v3;
            v11 = "is a competing service.";
          }
        }
        else
        {
          if (*(unsigned __int16 *)(v3 + 16) == *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 276)
            || *(_BYTE *)(a1 + 258)
            && (*(_QWORD *)(v3 + 64) == *(_QWORD *)(a1 + 176)
              ? (v16 = *(_QWORD *)(v3 + 72) == *(_QWORD *)(a1 + 184))
              : (v16 = 0),
                v16))
          {
            thread_service_note(*(_QWORD *)(a1 + 72), v3, (uint64_t)"is on our ml-eid or rloc16 but we aren't publishing it, so it's stale.");
            service_publisher_unpublish_stale_service(a1, v3);
            if (a2 && !*(_BYTE *)(a1 + 268) && !*(_BYTE *)(a1 + 269))
            {
              v12 = *((_QWORD *)v8 + 306);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446210;
                v21 = "service_publisher_have_competing_unicast_service";
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: starting wakeup timer to publish cached services after stale service timeout.", buf, 0xCu);
              }
              *(_BYTE *)(a1 + 269) = 1;
              service_publisher_start_wait(a1, 0x7D0u);
              v8 = &dnssd_client_states;
            }
            goto LABEL_27;
          }
          v9 = *(_QWORD *)(a1 + 72);
          v10 = v3;
          v11 = "is not ours and we aren't publishing.";
        }
        thread_service_note(v9, v10, (uint64_t)v11);
        v6 = 1;
LABEL_27:
        v3 = *(_QWORD *)(v3 + 8);
        if (!v3)
          return v6 & 1;
      }
    }
  }
  v6 = 0;
  return v6 & 1;
}

void service_publisher_sed_timeout_expired(_QWORD *a1)
{
  _QWORD *v2;
  int *v3;
  int *v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  void (*v8)(int *);
  NSObject *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  v2 = (_QWORD *)a1[13];
  if (v2)
  {
    ioloop_wakeup_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 815);
    a1[13] = 0;
  }
  if (!a1[30])
  {
    a1[30] = strdup("none");
    a1[26] = 0;
    a1[27] = 0;
  }
  v3 = state_machine_event_create(18);
  if (v3)
  {
    v4 = v3;
    state_machine_event_deliver((uint64_t)(a1 + 1), (uint64_t)v3);
    v5 = *v4;
    if (*v4)
    {
      v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v11 = 136447490;
          v12 = "service_publisher_sed_timeout_expired";
          v13 = 1024;
          *(_DWORD *)v14 = v5;
          *(_WORD *)&v14[4] = 2048;
          *(_QWORD *)&v14[6] = v4;
          *(_WORD *)&v14[14] = 2080;
          *(_QWORD *)&v14[16] = "event";
          *(_WORD *)&v14[24] = 2080;
          *(_QWORD *)&v14[26] = "service-publisher.c";
          v15 = 1024;
          v16 = 827;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
          v5 = *v4;
        }
        *v4 = v5 - 1;
        if (v5 == 1)
        {
          v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v11 = 136447234;
            v12 = "service_publisher_sed_timeout_expired";
            v13 = 2048;
            *(_QWORD *)v14 = v4;
            *(_WORD *)&v14[8] = 2080;
            *(_QWORD *)&v14[10] = "event";
            *(_WORD *)&v14[18] = 2080;
            *(_QWORD *)&v14[20] = "service-publisher.c";
            *(_WORD *)&v14[28] = 1024;
            *(_DWORD *)&v14[30] = 827;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
          }
          ++state_machine_event_finalized;
          v8 = (void (*)(int *))*((_QWORD *)v4 + 4);
          if (v8)
            v8(v4);
          free(v4);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_24:
        abort();
      v11 = 136447490;
      v12 = "service_publisher_sed_timeout_expired";
      v13 = 1024;
      *(_DWORD *)v14 = v5;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(_QWORD *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(_QWORD *)&v14[26] = "service-publisher.c";
      v15 = 1024;
      v16 = 827;
      v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_24;
      v11 = 136447490;
      v12 = "service_publisher_sed_timeout_expired";
      v13 = 1024;
      *(_DWORD *)v14 = 0;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(_QWORD *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(_QWORD *)&v14[26] = "service-publisher.c";
      v15 = 1024;
      v16 = 827;
      v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
    goto LABEL_24;
  }
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v11 = 136446210;
    v12 = "service_publisher_sed_timeout_expired";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v11, 0xCu);
  }
}

void service_publisher_unpublish_stale_service(uint64_t a1, uint64_t a2)
{
  NSObject *v4;
  int *service_for_queue;
  int *v6;
  int v7;
  const char *v8;

  v4 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v7 = 136446210;
    v8 = "service_publisher_unpublish_stale_service";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: setting seen_service_list to false", (uint8_t *)&v7, 0xCu);
  }
  *(_BYTE *)(a1 + 263) = 0;
  service_for_queue = service_publisher_create_service_for_queue(a2);
  if (service_for_queue)
  {
    v6 = service_for_queue;
    service_publisher_queue_update(a1, (uint64_t)service_for_queue, 7);
    thread_service_release_(v6, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 678);
    *(_BYTE *)(a2 + 27) = 1;
  }
  else
  {
    thread_service_note(*(_QWORD *)(a1 + 72), a2, (uint64_t)"no memory for service to delete");
  }
}

_DWORD *service_publisher_create_service_for_queue(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 20);
  switch(v1)
  {
    case 1:
      return thread_service_pref_id_create_(*(_WORD *)(a1 + 16), (_DWORD *)(a1 + 64), (int *)(a1 + 68), *(_BYTE *)(a1 + 18), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 625);
    case 3:
      return thread_service_anycast_create_(*(_WORD *)(a1 + 16), *(_BYTE *)(a1 + 80), *(_BYTE *)(a1 + 18), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 622);
    case 2:
      return thread_service_unicast_create_(*(_WORD *)(a1 + 16), (_OWORD *)(a1 + 64), (_WORD *)(a1 + 80), *(_BYTE *)(a1 + 18), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 620);
  }
  return 0;
}

void service_publisher_wait_expired(uint64_t a1)
{
  int *v2;
  int *v3;
  int v4;
  NSObject *v5;
  NSObject *v6;
  void (*v7)(int *);
  NSObject *v8;
  const char *v9;
  int v10;
  const char *v11;
  __int16 v12;
  _BYTE v13[34];
  __int16 v14;
  int v15;

  v2 = state_machine_event_create(1);
  if (v2)
  {
    v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    v4 = *v3;
    if (*v3)
    {
      v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v10 = 136447490;
          v11 = "service_publisher_wait_expired";
          v12 = 1024;
          *(_DWORD *)v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(_QWORD *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(_QWORD *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(_QWORD *)&v13[26] = "service-publisher.c";
          v14 = 1024;
          v15 = 693;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          v4 = *v3;
        }
        *v3 = v4 - 1;
        if (v4 == 1)
        {
          v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v10 = 136447234;
            v11 = "service_publisher_wait_expired";
            v12 = 2048;
            *(_QWORD *)v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(_QWORD *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(_QWORD *)&v13[20] = "service-publisher.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 693;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          v7 = (void (*)(int *))*((_QWORD *)v3 + 4);
          if (v7)
            v7(v3);
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_20:
        abort();
      v10 = 136447490;
      v11 = "service_publisher_wait_expired";
      v12 = 1024;
      *(_DWORD *)v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "service-publisher.c";
      v14 = 1024;
      v15 = 693;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_20;
      v10 = 136447490;
      v11 = "service_publisher_wait_expired";
      v12 = 1024;
      *(_DWORD *)v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(_QWORD *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(_QWORD *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(_QWORD *)&v13[26] = "service-publisher.c";
      v14 = 1024;
      v15 = 693;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v10 = 136446210;
    v11 = "service_publisher_wait_expired";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

void service_publisher_queue_run(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v4;
  int v5;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  os_log_type_t v9;
  uint32_t v10;
  uint64_t v11;
  int v12;
  int v13;
  NSObject *v14;
  int *v15;
  int v16;
  const char *v17;
  NSObject *v18;
  int v19;
  int v20;
  int v21;
  NSObject *v22;
  NSObject *v23;
  int v24;
  int v25;
  uint8_t buf[4];
  const char *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  uint64_t v31;
  __int16 v32;
  const char *v33;
  __int16 v34;
  char *v35;
  __int16 v36;
  int v37;

  v1 = *(_QWORD *)(a1 + 144);
  if (!v1)
  {
    v11 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136446210;
    v27 = "service_publisher_queue_run";
    v7 = "%{public}s: the queue is empty.";
    goto LABEL_12;
  }
  v2 = *(unsigned int *)(v1 + 32);
  if ((v2 - 4) < 2)
  {
    v11 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return;
    *(_DWORD *)buf = 136446210;
    v27 = "service_publisher_queue_run";
    v7 = "%{public}s: there is a pending update at the head of the queue.";
LABEL_12:
    v8 = v11;
    v9 = OS_LOG_TYPE_DEFAULT;
    v10 = 12;
    goto LABEL_13;
  }
  if ((_DWORD)v2 == 6)
  {
    v12 = service_publisher_service_update(a1, *(_QWORD *)(a1 + 144), 1);
    if (!v12)
    {
      *(_DWORD *)(v1 + 32) = 4;
      v23 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        v24 = *(_DWORD *)a1;
        *(_DWORD *)buf = 136447490;
        v27 = "service_publisher_queue_run";
        v28 = 1024;
        v29 = v24;
        v30 = 2048;
        v31 = a1;
        v32 = 2080;
        v33 = "publisher";
        v34 = 2080;
        v35 = "service-publisher.c";
        v36 = 1024;
        v37 = 570;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      v20 = *(_DWORD *)a1;
      if (*(_DWORD *)a1)
      {
        v25 = v20 + 1;
        *(_DWORD *)a1 = v20 + 1;
        if (v20 + 1 < 10001)
          return;
        v22 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          v27 = "service_publisher_queue_run";
          v28 = 1024;
          v29 = v25;
          v30 = 2048;
          v31 = a1;
          v32 = 2080;
          v33 = "publisher";
          v34 = 2080;
          v35 = "service-publisher.c";
          v36 = 1024;
          v37 = 570;
          goto LABEL_36;
        }
LABEL_37:
        abort();
      }
LABEL_38:
      ++service_publisher_created;
      *(_DWORD *)a1 = v20 + 1;
      return;
    }
    v13 = v12;
    v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v27 = "service_publisher_queue_run";
      v28 = 1024;
      v29 = v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: cti_add_service failed: %d", buf, 0x12u);
    }
    *(_QWORD *)(a1 + 144) = *(_QWORD *)(v1 + 8);
    v15 = (int *)v1;
    v16 = 567;
LABEL_22:
    thread_service_release_(v15, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", v16);
    return;
  }
  if ((_DWORD)v2 != 7)
  {
    if (v2 > 7)
      v17 = "<unknown>";
    else
      v17 = off_10008CF88[v2];
    snprintf((char *)buf, 0x100uLL, "is in unexpected state %s on the publication queue", v17);
    thread_service_note(*(_QWORD *)(a1 + 72), v1, (uint64_t)buf);
    *(_QWORD *)(a1 + 144) = *(_QWORD *)(v1 + 8);
    v15 = (int *)v1;
    v16 = 578;
    goto LABEL_22;
  }
  v4 = service_publisher_service_update(a1, *(_QWORD *)(a1 + 144), 0);
  if (!v4)
  {
    *(_DWORD *)(v1 + 32) = 5;
    v18 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v19 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      v27 = "service_publisher_queue_run";
      v28 = 1024;
      v29 = v19;
      v30 = 2048;
      v31 = a1;
      v32 = 2080;
      v33 = "publisher";
      v34 = 2080;
      v35 = "service-publisher.c";
      v36 = 1024;
      v37 = 560;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v20 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v21 = v20 + 1;
      *(_DWORD *)a1 = v20 + 1;
      if (v20 + 1 < 10001)
        return;
      v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v27 = "service_publisher_queue_run";
        v28 = 1024;
        v29 = v21;
        v30 = 2048;
        v31 = a1;
        v32 = 2080;
        v33 = "publisher";
        v34 = 2080;
        v35 = "service-publisher.c";
        v36 = 1024;
        v37 = 560;
LABEL_36:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        goto LABEL_37;
      }
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  v5 = v4;
  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    v27 = "service_publisher_queue_run";
    v28 = 1024;
    v29 = v5;
    v7 = "%{public}s: cti_remove_service failed: %d";
    v8 = v6;
    v9 = OS_LOG_TYPE_ERROR;
    v10 = 18;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v8, v9, v7, buf, v10);
  }
}

uint64_t service_publisher_service_update(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  size_t v7;
  size_t v8;
  xpc_object_t v9;
  uint64_t v10;
  __int128 v12;
  __int16 v13;
  _BYTE bytes[20];

  v3 = 4294901747;
  v4 = *(_DWORD *)(a2 + 20);
  switch(v4)
  {
    case 1:
      return 4294901756;
    case 3:
      v7 = 0;
      bytes[0] = 92;
      bytes[1] = *(_BYTE *)(a2 + 80);
      v8 = 2;
      break;
    case 2:
      bytes[0] = 93;
      v12 = *(_OWORD *)(a2 + 64);
      v13 = *(_WORD *)(a2 + 80);
      v7 = 18;
      v8 = 1;
      break;
    default:
      return v3;
  }
  v9 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_data(v9, "service_data", bytes, v8);
  if (a3)
  {
    xpc_dictionary_set_data(v9, "server_data", &v12, v7);
    xpc_dictionary_set_uint64(v9, "enterprise_number", 0xAFAAuLL);
    xpc_dictionary_set_string(v9, "interface", "org.wpantund.v1");
    xpc_dictionary_set_string(v9, "path", "/org/wpantund/utun2");
    xpc_dictionary_set_string(v9, "method", "ServiceAdd");
    xpc_dictionary_set_BOOL(v9, "stable", 1);
    v10 = setup_for_command(0, (uint64_t)"add_service", 0, 0, v9, a1, (uint64_t)service_publisher_update_callback, (uint64_t)cti_internal_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 534);
  }
  else
  {
    xpc_dictionary_set_uint64(v9, "enterprise_number", 0xAFAAuLL);
    xpc_dictionary_set_string(v9, "interface", "org.wpantund.v1");
    xpc_dictionary_set_string(v9, "path", "/org/wpantund/utun2");
    xpc_dictionary_set_string(v9, "method", "ServiceRemove");
    v10 = setup_for_command(0, (uint64_t)"remove_service", 0, 0, v9, a1, (uint64_t)service_publisher_update_callback, (uint64_t)cti_internal_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 537);
  }
  v3 = v10;
  xpc_release(v9);
  return v3;
}

void service_publisher_update_callback(uint64_t a1, int a2)
{
  int v3;
  NSObject *v4;
  NSObject *v5;
  uint8_t *v6;
  uint64_t v7;
  uint64_t v9;
  const char *v10;
  NSObject *v11;
  int v12;
  int v13;
  int v14;
  const char *v15;
  uint8_t *v16;
  uint8_t v17[4];
  const char *v18;
  __int16 v19;
  _BYTE v20[34];
  __int16 v21;
  int v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  _BYTE v26[34];
  __int16 v27;
  int v28;

  if (*(_BYTE *)(a1 + 261))
  {
    v3 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v4 = global_os_log;
      if (v3 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v24 = "service_publisher_update_callback";
          v25 = 1024;
          *(_DWORD *)v26 = v3;
          *(_WORD *)&v26[4] = 2048;
          *(_QWORD *)&v26[6] = a1;
          *(_WORD *)&v26[14] = 2080;
          *(_QWORD *)&v26[16] = "publisher";
          *(_WORD *)&v26[24] = 2080;
          *(_QWORD *)&v26[26] = "service-publisher.c";
          v27 = 1024;
          v28 = 473;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v3 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v3 - 1;
        if (v3 == 1)
        {
          v5 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v24 = "service_publisher_update_callback";
            v25 = 2048;
            *(_QWORD *)v26 = a1;
            *(_WORD *)&v26[8] = 2080;
            *(_QWORD *)&v26[10] = "publisher";
            *(_WORD *)&v26[18] = 2080;
            *(_QWORD *)&v26[20] = "service-publisher.c";
            *(_WORD *)&v26[28] = 1024;
            *(_DWORD *)&v26[30] = 473;
            v6 = buf;
LABEL_34:
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v6, 0x30u);
            goto LABEL_35;
          }
          goto LABEL_35;
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_48:
        abort();
      *(_DWORD *)buf = 136447490;
      v24 = "service_publisher_update_callback";
      v25 = 1024;
      *(_DWORD *)v26 = v3;
      *(_WORD *)&v26[4] = 2048;
      *(_QWORD *)&v26[6] = a1;
      *(_WORD *)&v26[14] = 2080;
      *(_QWORD *)&v26[16] = "publisher";
      *(_WORD *)&v26[24] = 2080;
      *(_QWORD *)&v26[26] = "service-publisher.c";
      v27 = 1024;
      v28 = 473;
      v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v4 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_48;
      *(_DWORD *)buf = 136447490;
      v24 = "service_publisher_update_callback";
      v25 = 1024;
      *(_DWORD *)v26 = 0;
      *(_WORD *)&v26[4] = 2048;
      *(_QWORD *)&v26[6] = a1;
      *(_WORD *)&v26[14] = 2080;
      *(_QWORD *)&v26[16] = "publisher";
      *(_WORD *)&v26[24] = 2080;
      *(_QWORD *)&v26[26] = "service-publisher.c";
      v27 = 1024;
      v28 = 473;
      v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    v16 = buf;
LABEL_47:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, v15, v16, 0x36u);
    goto LABEL_48;
  }
  v7 = *(_QWORD *)(a1 + 144);
  if (!v7)
  {
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      v24 = "service_publisher_update_callback";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: no pending service update", buf, 0xCu);
    }
    return;
  }
  v9 = *(unsigned int *)(v7 + 32);
  if (v9 > 7)
    v10 = "<unknown>";
  else
    v10 = off_10008CF88[v9];
  snprintf((char *)buf, 0x100uLL, "is in state %s, status = %d", v10, a2);
  thread_service_note(*(_QWORD *)(a1 + 72), v7, (uint64_t)buf);
  v12 = *(_DWORD *)(v7 + 32);
  if (a2)
  {
    if (v12 == 4)
    {
      v13 = 2;
    }
    else
    {
      if (v12 != 5)
        goto LABEL_25;
      v13 = 3;
    }
  }
  else if (v12 == 4)
  {
    v13 = 0;
  }
  else
  {
    if (v12 != 5)
      goto LABEL_25;
    v13 = 1;
  }
  *(_DWORD *)(v7 + 32) = v13;
LABEL_25:
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(v7 + 8);
  thread_service_release_((int *)v7, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 499);
  if (!*(_BYTE *)(a1 + 261))
    service_publisher_queue_run(a1);
  v14 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_48;
    *(_DWORD *)v17 = 136447490;
    v18 = "service_publisher_update_callback";
    v19 = 1024;
    *(_DWORD *)v20 = 0;
    *(_WORD *)&v20[4] = 2048;
    *(_QWORD *)&v20[6] = a1;
    *(_WORD *)&v20[14] = 2080;
    *(_QWORD *)&v20[16] = "publisher";
    *(_WORD *)&v20[24] = 2080;
    *(_QWORD *)&v20[26] = "service-publisher.c";
    v21 = 1024;
    v22 = 503;
    v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_46:
    v16 = v17;
    goto LABEL_47;
  }
  v4 = global_os_log;
  if (v14 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_48;
    *(_DWORD *)v17 = 136447490;
    v18 = "service_publisher_update_callback";
    v19 = 1024;
    *(_DWORD *)v20 = v14;
    *(_WORD *)&v20[4] = 2048;
    *(_QWORD *)&v20[6] = a1;
    *(_WORD *)&v20[14] = 2080;
    *(_QWORD *)&v20[16] = "publisher";
    *(_WORD *)&v20[24] = 2080;
    *(_QWORD *)&v20[26] = "service-publisher.c";
    v21 = 1024;
    v22 = 503;
    v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_46;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v17 = 136447490;
    v18 = "service_publisher_update_callback";
    v19 = 1024;
    *(_DWORD *)v20 = v14;
    *(_WORD *)&v20[4] = 2048;
    *(_QWORD *)&v20[6] = a1;
    *(_WORD *)&v20[14] = 2080;
    *(_QWORD *)&v20[16] = "publisher";
    *(_WORD *)&v20[24] = 2080;
    *(_QWORD *)&v20[26] = "service-publisher.c";
    v21 = 1024;
    v22 = 503;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v17, 0x36u);
    v14 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v14 - 1;
  if (v14 == 1)
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v17 = 136447234;
      v18 = "service_publisher_update_callback";
      v19 = 2048;
      *(_QWORD *)v20 = a1;
      *(_WORD *)&v20[8] = 2080;
      *(_QWORD *)&v20[10] = "publisher";
      *(_WORD *)&v20[18] = 2080;
      *(_QWORD *)&v20[20] = "service-publisher.c";
      *(_WORD *)&v20[28] = 1024;
      *(_DWORD *)&v20[30] = 503;
      v6 = v17;
      goto LABEL_34;
    }
LABEL_35:
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
}

void service_publisher_listener_ready(uint64_t a1, __int16 a2)
{
  uint64_t v2;
  int *v4;
  int *v5;
  int v6;
  NSObject *v7;
  NSObject *v8;
  void (*v9)(int *);
  NSObject *v10;
  const char *v11;
  int v12;
  const char *v13;
  __int16 v14;
  _BYTE v15[34];
  __int16 v16;
  int v17;

  v2 = *(_QWORD *)(a1 + 48);
  if (!v2)
    return;
  v4 = state_machine_event_create(5);
  if (v4)
  {
    v5 = v4;
    *(_BYTE *)(v2 + 262) = 1;
    *(_WORD *)(v2 + 256) = a2;
    state_machine_event_deliver(v2 + 8, (uint64_t)v4);
    v6 = *v5;
    if (*v5)
    {
      v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v12 = 136447490;
          v13 = "service_publisher_listener_ready";
          v14 = 1024;
          *(_DWORD *)v15 = v6;
          *(_WORD *)&v15[4] = 2048;
          *(_QWORD *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(_QWORD *)&v15[16] = "event";
          *(_WORD *)&v15[24] = 2080;
          *(_QWORD *)&v15[26] = "service-publisher.c";
          v16 = 1024;
          v17 = 1216;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
          v6 = *v5;
        }
        *v5 = v6 - 1;
        if (v6 == 1)
        {
          v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v12 = 136447234;
            v13 = "service_publisher_listener_ready";
            v14 = 2048;
            *(_QWORD *)v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(_QWORD *)&v15[10] = "event";
            *(_WORD *)&v15[18] = 2080;
            *(_QWORD *)&v15[20] = "service-publisher.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 1216;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
          }
          ++state_machine_event_finalized;
          v9 = (void (*)(int *))*((_QWORD *)v5 + 4);
          if (v9)
            v9(v5);
          free(v5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_21:
        abort();
      v12 = 136447490;
      v13 = "service_publisher_listener_ready";
      v14 = 1024;
      *(_DWORD *)v15 = v6;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "service-publisher.c";
      v16 = 1024;
      v17 = 1216;
      v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_21;
      v12 = 136447490;
      v13 = "service_publisher_listener_ready";
      v14 = 1024;
      *(_DWORD *)v15 = 0;
      *(_WORD *)&v15[4] = 2048;
      *(_QWORD *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(_QWORD *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(_QWORD *)&v15[26] = "service-publisher.c";
      v16 = 1024;
      v17 = 1216;
      v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
    goto LABEL_21;
  }
  v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v12 = 136446210;
    v13 = "service_publisher_listener_ready";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v12, 0xCu);
  }
}

void service_publisher_listener_cancel_callback(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int *v3;
  int *v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  void (*v8)(int *);
  NSObject *v9;
  const char *v10;
  int v11;
  const char *v12;
  __int16 v13;
  _BYTE v14[34];
  __int16 v15;
  int v16;

  v2 = *(_QWORD *)(a2 + 48);
  if (!v2)
    return;
  v3 = state_machine_event_create(6);
  if (v3)
  {
    v4 = v3;
    state_machine_event_deliver(v2 + 8, (uint64_t)v3);
    v5 = *v4;
    if (*v4)
    {
      v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v11 = 136447490;
          v12 = "service_publisher_listener_cancel_callback";
          v13 = 1024;
          *(_DWORD *)v14 = v5;
          *(_WORD *)&v14[4] = 2048;
          *(_QWORD *)&v14[6] = v4;
          *(_WORD *)&v14[14] = 2080;
          *(_QWORD *)&v14[16] = "event";
          *(_WORD *)&v14[24] = 2080;
          *(_QWORD *)&v14[26] = "service-publisher.c";
          v15 = 1024;
          v16 = 1186;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
          v5 = *v4;
        }
        *v4 = v5 - 1;
        if (v5 == 1)
        {
          v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v11 = 136447234;
            v12 = "service_publisher_listener_cancel_callback";
            v13 = 2048;
            *(_QWORD *)v14 = v4;
            *(_WORD *)&v14[8] = 2080;
            *(_QWORD *)&v14[10] = "event";
            *(_WORD *)&v14[18] = 2080;
            *(_QWORD *)&v14[20] = "service-publisher.c";
            *(_WORD *)&v14[28] = 1024;
            *(_DWORD *)&v14[30] = 1186;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
          }
          ++state_machine_event_finalized;
          v8 = (void (*)(int *))*((_QWORD *)v4 + 4);
          if (v8)
            v8(v4);
          free(v4);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_21:
        abort();
      v11 = 136447490;
      v12 = "service_publisher_listener_cancel_callback";
      v13 = 1024;
      *(_DWORD *)v14 = v5;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(_QWORD *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(_QWORD *)&v14[26] = "service-publisher.c";
      v15 = 1024;
      v16 = 1186;
      v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_21;
      v11 = 136447490;
      v12 = "service_publisher_listener_cancel_callback";
      v13 = 1024;
      *(_DWORD *)v14 = 0;
      *(_WORD *)&v14[4] = 2048;
      *(_QWORD *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(_QWORD *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(_QWORD *)&v14[26] = "service-publisher.c";
      v15 = 1024;
      v16 = 1186;
      v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
    goto LABEL_21;
  }
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v11 = 136446210;
    v12 = "service_publisher_listener_cancel_callback";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v11, 0xCu);
  }
}

void service_publisher_active_data_set_changed_callback(uint64_t a1, int a2)
{
  NSObject *v4;
  int v5;
  NSObject *v6;
  NSObject *v7;
  xpc_object_t v8;
  int v9;
  NSObject *v10;
  int v11;
  int v12;
  int v13;
  const char *v14;
  uint8_t buf[4];
  const char *v16;
  __int16 v17;
  _BYTE v18[34];
  __int16 v19;
  int v20;

  if (a2)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v16 = "service_publisher_active_data_set_changed_callback";
      v17 = 1024;
      *(_DWORD *)v18 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: error %d", buf, 0x12u);
    }
    if (!a1)
      goto LABEL_13;
    v5 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v16 = "service_publisher_active_data_set_changed_callback";
          v17 = 1024;
          *(_DWORD *)v18 = v5;
          *(_WORD *)&v18[4] = 2048;
          *(_QWORD *)&v18[6] = a1;
          *(_WORD *)&v18[14] = 2080;
          *(_QWORD *)&v18[16] = "publisher";
          *(_WORD *)&v18[24] = 2080;
          *(_QWORD *)&v18[26] = "service-publisher.c";
          v19 = 1024;
          v20 = 1614;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v5 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v5 - 1;
        if (v5 == 1)
        {
          v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v16 = "service_publisher_active_data_set_changed_callback";
            v17 = 2048;
            *(_QWORD *)v18 = a1;
            *(_WORD *)&v18[8] = 2080;
            *(_QWORD *)&v18[10] = "publisher";
            *(_WORD *)&v18[18] = 2080;
            *(_QWORD *)&v18[20] = "service-publisher.c";
            *(_WORD *)&v18[28] = 1024;
            *(_DWORD *)&v18[30] = 1614;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++service_publisher_finalized;
          service_publisher_finalize(a1);
        }
LABEL_13:
        cti_events_discontinue(*(_QWORD *)(a1 + 152));
        *(_QWORD *)(a1 + 152) = 0;
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_30:
        abort();
      *(_DWORD *)buf = 136447490;
      v16 = "service_publisher_active_data_set_changed_callback";
      v17 = 1024;
      *(_DWORD *)v18 = v5;
      *(_WORD *)&v18[4] = 2048;
      *(_QWORD *)&v18[6] = a1;
      *(_WORD *)&v18[14] = 2080;
      *(_QWORD *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(_QWORD *)&v18[26] = "service-publisher.c";
      v19 = 1024;
      v20 = 1614;
      v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_30;
      *(_DWORD *)buf = 136447490;
      v16 = "service_publisher_active_data_set_changed_callback";
      v17 = 1024;
      *(_DWORD *)v18 = 0;
      *(_WORD *)&v18[4] = 2048;
      *(_QWORD *)&v18[6] = a1;
      *(_WORD *)&v18[14] = 2080;
      *(_QWORD *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(_QWORD *)&v18[26] = "service-publisher.c";
      v19 = 1024;
      v20 = 1614;
      v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
LABEL_29:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v14, buf, 0x36u);
    goto LABEL_30;
  }
  v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "PropGet");
  xpc_dictionary_set_string(v8, "property_name", "IPv6:MeshLocalAddress");
  v9 = setup_for_command(0, (uint64_t)"get_mesh_local_address", 0, (uint64_t)"IPv6:MeshLocalAddress", v8, a1, (uint64_t)service_publisher_get_mesh_local_address_callback, (uint64_t)cti_internal_string_property_reply, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1621);
  xpc_release(v8);
  v10 = global_os_log;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v16 = "service_publisher_active_data_set_changed_callback";
      v17 = 1024;
      *(_DWORD *)v18 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: cti_get_mesh_local_address failed with status %d", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      v16 = "service_publisher_active_data_set_changed_callback";
      v17 = 1024;
      *(_DWORD *)v18 = v11;
      *(_WORD *)&v18[4] = 2048;
      *(_QWORD *)&v18[6] = a1;
      *(_WORD *)&v18[14] = 2080;
      *(_QWORD *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(_QWORD *)&v18[26] = "service-publisher.c";
      v19 = 1024;
      v20 = 1625;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    v12 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      ++service_publisher_created;
      *(_DWORD *)a1 = 1;
      return;
    }
    v13 = v12 + 1;
    *(_DWORD *)a1 = v12 + 1;
    if (v12 + 1 >= 10001)
    {
      v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_30;
      *(_DWORD *)buf = 136447490;
      v16 = "service_publisher_active_data_set_changed_callback";
      v17 = 1024;
      *(_DWORD *)v18 = v13;
      *(_WORD *)&v18[4] = 2048;
      *(_QWORD *)&v18[6] = a1;
      *(_WORD *)&v18[14] = 2080;
      *(_QWORD *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(_QWORD *)&v18[26] = "service-publisher.c";
      v19 = 1024;
      v20 = 1625;
      v14 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_29;
    }
  }
}

void service_publisher_tunnel_name_callback(uint64_t a1, char *__s1, int a3)
{
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint32_t v9;
  char *v10;
  NSObject *v11;
  NSObject *v12;
  int *v13;
  int *v14;
  int v15;
  NSObject *v16;
  NSObject *v17;
  void (*v18)(int *);
  uint64_t v19;
  const char *v20;
  int v21;
  NSObject *v22;
  NSObject *v23;
  NSObject *v24;
  const char *v25;
  NSObject *v26;
  uint64_t v27;
  int v28;
  const char *v29;
  __int16 v30;
  _BYTE v31[34];
  __int16 v32;
  int v33;

  if (a3 == -65569)
    goto LABEL_4;
  if (a3)
  {
    if (a3 != -65563)
    {
      v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_30;
      v20 = "<null>";
      v28 = 136446722;
      v29 = "service_publisher_tunnel_name_callback";
      if (__s1)
        v20 = __s1;
      v30 = 2082;
      *(_QWORD *)v31 = v20;
      *(_WORD *)&v31[8] = 1024;
      *(_DWORD *)&v31[10] = a3;
      v7 = "%{public}s: %{public}s %d";
      v8 = v19;
      v9 = 28;
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v28, v9);
LABEL_30:
      if (!a1)
        return;
      goto LABEL_31;
    }
LABEL_4:
    v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      goto LABEL_30;
    v28 = 136446210;
    v29 = "service_publisher_tunnel_name_callback";
    v7 = "%{public}s: disconnected";
    v8 = v6;
    v9 = 12;
    goto LABEL_29;
  }
  *(_BYTE *)(a1 + 265) = 1;
  v10 = *(char **)(a1 + 80);
  if (!v10)
    goto LABEL_9;
  if (strcmp(__s1, *(const char **)(a1 + 80)))
  {
    ifpermit_list_remove(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 72), v10);
    free(*(void **)(a1 + 80));
    *(_QWORD *)(a1 + 80) = 0;
LABEL_9:
    *(_QWORD *)(a1 + 80) = strdup(__s1);
    ifpermit_list_add(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 72), __s1);
    v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v28 = 136446466;
      v29 = "service_publisher_tunnel_name_callback";
      v30 = 2082;
      *(_QWORD *)v31 = __s1;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: thread interface at %{public}s", (uint8_t *)&v28, 0x16u);
    }
    if (!*(_QWORD *)(a1 + 80))
    {
      v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v28 = 136446466;
        v29 = "service_publisher_tunnel_name_callback";
        v30 = 2082;
        *(_QWORD *)v31 = __s1;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: No memory to save thread interface name %{public}s", (uint8_t *)&v28, 0x16u);
      }
    }
  }
  v13 = state_machine_event_create(16);
  if (v13)
  {
    v14 = v13;
    state_machine_event_deliver(a1 + 8, (uint64_t)v13);
    v15 = *v14;
    if (*v14)
    {
      v16 = global_os_log;
      if (v15 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          v28 = 136447490;
          v29 = "service_publisher_tunnel_name_callback";
          v30 = 1024;
          *(_DWORD *)v31 = v15;
          *(_WORD *)&v31[4] = 2048;
          *(_QWORD *)&v31[6] = v14;
          *(_WORD *)&v31[14] = 2080;
          *(_QWORD *)&v31[16] = "event";
          *(_WORD *)&v31[24] = 2080;
          *(_QWORD *)&v31[26] = "service-publisher.c";
          v32 = 1024;
          v33 = 1679;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
          v15 = *v14;
        }
        *v14 = v15 - 1;
        if (v15 == 1)
        {
          v17 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            v28 = 136447234;
            v29 = "service_publisher_tunnel_name_callback";
            v30 = 2048;
            *(_QWORD *)v31 = v14;
            *(_WORD *)&v31[8] = 2080;
            *(_QWORD *)&v31[10] = "event";
            *(_WORD *)&v31[18] = 2080;
            *(_QWORD *)&v31[20] = "service-publisher.c";
            *(_WORD *)&v31[28] = 1024;
            *(_DWORD *)&v31[30] = 1679;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
          }
          ++state_machine_event_finalized;
          v18 = (void (*)(int *))*((_QWORD *)v14 + 4);
          if (v18)
            v18(v14);
          free(v14);
        }
        goto LABEL_31;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v28 = 136447490;
        v29 = "service_publisher_tunnel_name_callback";
        v30 = 1024;
        *(_DWORD *)v31 = v15;
        *(_WORD *)&v31[4] = 2048;
        *(_QWORD *)&v31[6] = v14;
        *(_WORD *)&v31[14] = 2080;
        *(_QWORD *)&v31[16] = "event";
        *(_WORD *)&v31[24] = 2080;
        *(_QWORD *)&v31[26] = "service-publisher.c";
        v32 = 1024;
        v33 = 1679;
        v25 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v26 = v16;
        goto LABEL_47;
      }
    }
    else
    {
      v27 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        v28 = 136447490;
        v29 = "service_publisher_tunnel_name_callback";
        v30 = 1024;
        *(_DWORD *)v31 = 0;
        *(_WORD *)&v31[4] = 2048;
        *(_QWORD *)&v31[6] = v14;
        *(_WORD *)&v31[14] = 2080;
        *(_QWORD *)&v31[16] = "event";
        *(_WORD *)&v31[24] = 2080;
        *(_QWORD *)&v31[26] = "service-publisher.c";
        v32 = 1024;
        v33 = 1679;
        v25 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        v26 = v27;
        goto LABEL_47;
      }
    }
LABEL_48:
    abort();
  }
  v24 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    v28 = 136446210;
    v29 = "service_publisher_tunnel_name_callback";
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v28, 0xCu);
  }
LABEL_31:
  v21 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    v22 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_48;
    v28 = 136447490;
    v29 = "service_publisher_tunnel_name_callback";
    v30 = 1024;
    *(_DWORD *)v31 = 0;
    *(_WORD *)&v31[4] = 2048;
    *(_QWORD *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(_QWORD *)&v31[16] = "publisher";
    *(_WORD *)&v31[24] = 2080;
    *(_QWORD *)&v31[26] = "service-publisher.c";
    v32 = 1024;
    v33 = 1681;
    v25 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_46:
    v26 = v22;
LABEL_47:
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v25, (uint8_t *)&v28, 0x36u);
    goto LABEL_48;
  }
  v22 = global_os_log;
  if (v21 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      goto LABEL_48;
    v28 = 136447490;
    v29 = "service_publisher_tunnel_name_callback";
    v30 = 1024;
    *(_DWORD *)v31 = v21;
    *(_WORD *)&v31[4] = 2048;
    *(_QWORD *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(_QWORD *)&v31[16] = "publisher";
    *(_WORD *)&v31[24] = 2080;
    *(_QWORD *)&v31[26] = "service-publisher.c";
    v32 = 1024;
    v33 = 1681;
    v25 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_46;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v28 = 136447490;
    v29 = "service_publisher_tunnel_name_callback";
    v30 = 1024;
    *(_DWORD *)v31 = v21;
    *(_WORD *)&v31[4] = 2048;
    *(_QWORD *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(_QWORD *)&v31[16] = "publisher";
    *(_WORD *)&v31[24] = 2080;
    *(_QWORD *)&v31[26] = "service-publisher.c";
    v32 = 1024;
    v33 = 1681;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
    v21 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v21 - 1;
  if (v21 == 1)
  {
    v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v28 = 136447234;
      v29 = "service_publisher_tunnel_name_callback";
      v30 = 2048;
      *(_QWORD *)v31 = a1;
      *(_WORD *)&v31[8] = 2080;
      *(_QWORD *)&v31[10] = "publisher";
      *(_WORD *)&v31[18] = 2080;
      *(_QWORD *)&v31[20] = "service-publisher.c";
      *(_WORD *)&v31[28] = 1024;
      *(_DWORD *)&v31[30] = 1681;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
}

void service_publisher_wed_callback(_QWORD *a1, const char *a2, char *a3, int a4, int a5)
{
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  os_log_type_t v9;
  const char *v12;
  const char *v14;
  NSObject *v15;
  const char *v16;
  void *v17;
  void *v18;
  char *v19;
  NSObject *v20;
  char *v21;
  NSObject *v22;
  int *v23;
  int *v24;
  int v25;
  NSObject *v26;
  NSObject *v27;
  void (*v28)(int *);
  uint64_t v29;
  const char *v30;
  int v31;
  const char *v32;
  __int16 v33;
  _BYTE v34[40];
  const char *v35;
  __int16 v36;
  int v37;

  if (a5 == -65563 || a5 == -65569)
  {
    v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return;
    v31 = 136446210;
    v32 = "service_publisher_wed_callback";
    v7 = "%{public}s: disconnected";
    v8 = v6;
    v9 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_8;
  }
  v12 = a3;
  if (a2)
    v14 = a2;
  else
    v14 = "<none>";
  if (a3)
  {
    if (!inet_pton(30, a3, a1 + 24))
      v12 = "<none>";
  }
  else
  {
    v12 = "<none>";
  }
  v15 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v16 = " removed";
    v31 = 136447747;
    v32 = "service_publisher_wed_callback";
    v33 = 2160;
    *(_QWORD *)v34 = 1752392040;
    if (a4)
      v16 = " added";
    *(_WORD *)&v34[8] = 2081;
    *(_QWORD *)&v34[10] = v14;
    *(_WORD *)&v34[18] = 2160;
    *(_QWORD *)&v34[20] = 1752392040;
    *(_WORD *)&v34[28] = 2081;
    *(_QWORD *)&v34[30] = v12;
    *(_WORD *)&v34[38] = 2082;
    v35 = v16;
    v36 = 1024;
    v37 = a5;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ext_address: %{private, mask.hash}s  ml_eid: %{private, mask.hash}s%{public}s %d", (uint8_t *)&v31, 0x44u);
  }
  if (!a5)
  {
    v17 = (void *)a1[28];
    if (v17)
    {
      free(v17);
      a1[28] = 0;
    }
    v18 = (void *)a1[29];
    if (v18)
    {
      free(v18);
      a1[29] = 0;
    }
    if (!a4)
      goto LABEL_37;
    if (v14 != "<none>")
    {
      v19 = strdup(v14);
      a1[28] = v19;
      if (!v19)
      {
        v20 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v31 = 136446210;
          v32 = "service_publisher_wed_callback";
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: no memory for wed_ext_address string!", (uint8_t *)&v31, 0xCu);
        }
      }
    }
    if (v12 != "<none>")
    {
      v21 = strdup(v12);
      a1[29] = v21;
      if (v21)
      {
LABEL_37:
        v23 = state_machine_event_create(17);
        if (v23)
        {
          v24 = v23;
          state_machine_event_deliver((uint64_t)(a1 + 1), (uint64_t)v23);
          v25 = *v24;
          if (*v24)
          {
            v26 = global_os_log;
            if (v25 < 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                v31 = 136447490;
                v32 = "service_publisher_wed_callback";
                v33 = 1024;
                *(_DWORD *)v34 = v25;
                *(_WORD *)&v34[4] = 2048;
                *(_QWORD *)&v34[6] = v24;
                *(_WORD *)&v34[14] = 2080;
                *(_QWORD *)&v34[16] = "event";
                *(_WORD *)&v34[24] = 2080;
                *(_QWORD *)&v34[26] = "service-publisher.c";
                *(_WORD *)&v34[34] = 1024;
                *(_DWORD *)&v34[36] = 1745;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v31, 0x36u);
                v25 = *v24;
              }
              *v24 = v25 - 1;
              if (v25 == 1)
              {
                v27 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  v31 = 136447234;
                  v32 = "service_publisher_wed_callback";
                  v33 = 2048;
                  *(_QWORD *)v34 = v24;
                  *(_WORD *)&v34[8] = 2080;
                  *(_QWORD *)&v34[10] = "event";
                  *(_WORD *)&v34[18] = 2080;
                  *(_QWORD *)&v34[20] = "service-publisher.c";
                  *(_WORD *)&v34[28] = 1024;
                  *(_DWORD *)&v34[30] = 1745;
                  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v31, 0x30u);
                }
                ++state_machine_event_finalized;
                v28 = (void (*)(int *))*((_QWORD *)v24 + 4);
                if (v28)
                  v28(v24);
                free(v24);
              }
              return;
            }
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_55:
              abort();
            v31 = 136447490;
            v32 = "service_publisher_wed_callback";
            v33 = 1024;
            *(_DWORD *)v34 = v25;
            *(_WORD *)&v34[4] = 2048;
            *(_QWORD *)&v34[6] = v24;
            *(_WORD *)&v34[14] = 2080;
            *(_QWORD *)&v34[16] = "event";
            *(_WORD *)&v34[24] = 2080;
            *(_QWORD *)&v34[26] = "service-publisher.c";
            *(_WORD *)&v34[34] = 1024;
            *(_DWORD *)&v34[36] = 1745;
            v30 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          }
          else
          {
            v26 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_55;
            v31 = 136447490;
            v32 = "service_publisher_wed_callback";
            v33 = 1024;
            *(_DWORD *)v34 = 0;
            *(_WORD *)&v34[4] = 2048;
            *(_QWORD *)&v34[6] = v24;
            *(_WORD *)&v34[14] = 2080;
            *(_QWORD *)&v34[16] = "event";
            *(_WORD *)&v34[24] = 2080;
            *(_QWORD *)&v34[26] = "service-publisher.c";
            *(_WORD *)&v34[34] = 1024;
            *(_DWORD *)&v34[36] = 1745;
            v30 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          }
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v30, (uint8_t *)&v31, 0x36u);
          goto LABEL_55;
        }
        v29 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          return;
        v31 = 136446210;
        v32 = "service_publisher_wed_callback";
        v7 = "%{public}s: unable to allocate event to deliver";
        v8 = v29;
        v9 = OS_LOG_TYPE_ERROR;
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v8, v9, v7, (uint8_t *)&v31, 0xCu);
        return;
      }
      v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v31 = 136446210;
        v32 = "service_publisher_wed_callback";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%{public}s: no memory for wed_ml_eid string!", (uint8_t *)&v31, 0xCu);
      }
    }
    a1[24] = 0;
    a1[25] = 0;
    goto LABEL_37;
  }
}

void service_publisher_neighbor_callback(_QWORD *a1, char *__s1, int a3)
{
  uint64_t v4;
  const char *v5;
  NSObject *v6;
  os_log_type_t v7;
  const char *v9;
  int v11;
  _QWORD *v12;
  NSObject *v13;
  void *v14;
  char *v15;
  NSObject *v16;
  int *v17;
  int *v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  void (*v22)(int *);
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  NSObject *v27;
  int v28;
  const char *v29;
  __int16 v30;
  _BYTE v31[34];
  __int16 v32;
  int v33;

  if (a3 == -65563 || a3 == -65569)
  {
    v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      return;
    v28 = 136446210;
    v29 = "service_publisher_neighbor_callback";
    v5 = "%{public}s: disconnected";
    v6 = v4;
    v7 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_8;
  }
  v9 = __s1;
  if (__s1)
  {
    v11 = strcmp(__s1, "none");
    v12 = a1 + 26;
    if (v11)
    {
      if (!inet_pton(30, v9, v12))
        v9 = "<none>";
    }
    else
    {
      *v12 = 0;
      a1[27] = 0;
    }
  }
  else
  {
    v9 = "<none>";
  }
  v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v28 = 136446979;
    v29 = "service_publisher_neighbor_callback";
    v30 = 2160;
    *(_QWORD *)v31 = 1752392040;
    *(_WORD *)&v31[8] = 2081;
    *(_QWORD *)&v31[10] = v9;
    *(_WORD *)&v31[18] = 1024;
    *(_DWORD *)&v31[20] = a3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ml_eid: %{private, mask.hash}s, status %d", (uint8_t *)&v28, 0x26u);
  }
  if (!a3)
  {
    v14 = (void *)a1[30];
    if (v14)
    {
      free(v14);
      a1[30] = 0;
    }
    if (v9 != "<none>")
    {
      v15 = strdup(v9);
      a1[30] = v15;
      if (v15)
      {
LABEL_27:
        v17 = state_machine_event_create(18);
        if (v17)
        {
          v18 = v17;
          state_machine_event_deliver((uint64_t)(a1 + 1), (uint64_t)v17);
          v19 = *v18;
          if (*v18)
          {
            v20 = global_os_log;
            if (v19 < 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                v28 = 136447490;
                v29 = "service_publisher_neighbor_callback";
                v30 = 1024;
                *(_DWORD *)v31 = v19;
                *(_WORD *)&v31[4] = 2048;
                *(_QWORD *)&v31[6] = v18;
                *(_WORD *)&v31[14] = 2080;
                *(_QWORD *)&v31[16] = "event";
                *(_WORD *)&v31[24] = 2080;
                *(_QWORD *)&v31[26] = "service-publisher.c";
                v32 = 1024;
                v33 = 1799;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
                v19 = *v18;
              }
              *v18 = v19 - 1;
              if (v19 == 1)
              {
                v21 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  v28 = 136447234;
                  v29 = "service_publisher_neighbor_callback";
                  v30 = 2048;
                  *(_QWORD *)v31 = v18;
                  *(_WORD *)&v31[8] = 2080;
                  *(_QWORD *)&v31[10] = "event";
                  *(_WORD *)&v31[18] = 2080;
                  *(_QWORD *)&v31[20] = "service-publisher.c";
                  *(_WORD *)&v31[28] = 1024;
                  *(_DWORD *)&v31[30] = 1799;
                  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
                }
                ++state_machine_event_finalized;
                v22 = (void (*)(int *))*((_QWORD *)v18 + 4);
                if (v22)
                  v22(v18);
                free(v18);
              }
              v23 = a1[13];
              if (v23)
              {
                ioloop_cancel_wake_event(v23);
                ioloop_wakeup_release_((_QWORD *)a1[13], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1803);
                a1[13] = 0;
              }
              return;
            }
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
LABEL_47:
              abort();
            v28 = 136447490;
            v29 = "service_publisher_neighbor_callback";
            v30 = 1024;
            *(_DWORD *)v31 = v19;
            *(_WORD *)&v31[4] = 2048;
            *(_QWORD *)&v31[6] = v18;
            *(_WORD *)&v31[14] = 2080;
            *(_QWORD *)&v31[16] = "event";
            *(_WORD *)&v31[24] = 2080;
            *(_QWORD *)&v31[26] = "service-publisher.c";
            v32 = 1024;
            v33 = 1799;
            v26 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            v27 = v20;
          }
          else
          {
            v25 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              goto LABEL_47;
            v28 = 136447490;
            v29 = "service_publisher_neighbor_callback";
            v30 = 1024;
            *(_DWORD *)v31 = 0;
            *(_WORD *)&v31[4] = 2048;
            *(_QWORD *)&v31[6] = v18;
            *(_WORD *)&v31[14] = 2080;
            *(_QWORD *)&v31[16] = "event";
            *(_WORD *)&v31[24] = 2080;
            *(_QWORD *)&v31[26] = "service-publisher.c";
            v32 = 1024;
            v33 = 1799;
            v26 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            v27 = v25;
          }
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, v26, (uint8_t *)&v28, 0x36u);
          goto LABEL_47;
        }
        v24 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          return;
        v28 = 136446210;
        v29 = "service_publisher_neighbor_callback";
        v5 = "%{public}s: unable to allocate event to deliver";
        v6 = v24;
        v7 = OS_LOG_TYPE_ERROR;
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v6, v7, v5, (uint8_t *)&v28, 0xCu);
        return;
      }
      v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v28 = 136446210;
        v29 = "service_publisher_neighbor_callback";
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s: no memory for neighbor_ml_eid string!", (uint8_t *)&v28, 0xCu);
      }
    }
    a1[26] = 0;
    a1[27] = 0;
    goto LABEL_27;
  }
}

void service_publisher_get_mesh_local_address_callback(uint64_t a1, const char *a2, int a3)
{
  NSObject *v5;
  void (*v6)(_QWORD);
  NSObject *v9;
  const char *v11;
  uint64_t v13;
  uint64_t i;
  BOOL v15;
  int *v16;
  int *v17;
  int v18;
  NSObject *v19;
  NSObject *v20;
  void (*v21)(int *);
  int v22;
  NSObject *v23;
  NSObject *v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  uint64_t v28;
  const char *v29;
  NSObject *v30;
  os_log_type_t v31;
  uint64_t v32;
  const char *v33;
  NSObject *v34;
  uint64_t v35;
  __int128 v36;
  uint8_t buf[4];
  const char *v38;
  __int16 v39;
  _BYTE v40[34];
  __int16 v41;
  int v42;

  if (a3 == -65563 || a3 == -65569)
  {
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v38 = "service_publisher_get_mesh_local_address_callback";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: disconnected", buf, 0xCu);
    }
    v6 = *(void (**)(_QWORD))(a1 + 120);
    if (v6)
      v6(*(_QWORD *)(a1 + 88));
LABEL_58:
    v26 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_79;
      *(_DWORD *)buf = 136447490;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v39 = 1024;
      *(_DWORD *)v40 = 0;
      *(_WORD *)&v40[4] = 2048;
      *(_QWORD *)&v40[6] = a1;
      *(_WORD *)&v40[14] = 2080;
      *(_QWORD *)&v40[16] = "publisher";
      *(_WORD *)&v40[24] = 2080;
      *(_QWORD *)&v40[26] = "service-publisher.c";
      v41 = 1024;
      v42 = 1602;
      v33 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_77;
    }
    v23 = global_os_log;
    if (v26 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        goto LABEL_79;
      *(_DWORD *)buf = 136447490;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v39 = 1024;
      *(_DWORD *)v40 = v26;
      *(_WORD *)&v40[4] = 2048;
      *(_QWORD *)&v40[6] = a1;
      *(_WORD *)&v40[14] = 2080;
      *(_QWORD *)&v40[16] = "publisher";
      *(_WORD *)&v40[24] = 2080;
      *(_QWORD *)&v40[26] = "service-publisher.c";
      v41 = 1024;
      v42 = 1602;
      v33 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_77;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v39 = 1024;
      *(_DWORD *)v40 = v26;
      *(_WORD *)&v40[4] = 2048;
      *(_QWORD *)&v40[6] = a1;
      *(_WORD *)&v40[14] = 2080;
      *(_QWORD *)&v40[16] = "publisher";
      *(_WORD *)&v40[24] = 2080;
      *(_QWORD *)&v40[26] = "service-publisher.c";
      v41 = 1024;
      v42 = 1602;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      v26 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v26 - 1;
    if (v26 == 1)
    {
      v27 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        v38 = "service_publisher_get_mesh_local_address_callback";
        v39 = 2048;
        *(_QWORD *)v40 = a1;
        *(_WORD *)&v40[8] = 2080;
        *(_QWORD *)&v40[10] = "publisher";
        *(_WORD *)&v40[18] = 2080;
        *(_QWORD *)&v40[20] = "service-publisher.c";
        *(_WORD *)&v40[28] = 1024;
        *(_DWORD *)&v40[30] = 1602;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++service_publisher_finalized;
      service_publisher_finalize(a1);
    }
LABEL_66:
    *(_BYTE *)(a1 + 258) = 0;
    return;
  }
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v11 = "<null>";
    *(_DWORD *)buf = 136446722;
    v38 = "service_publisher_get_mesh_local_address_callback";
    if (a2)
      v11 = a2;
    v39 = 2082;
    *(_QWORD *)v40 = v11;
    *(_WORD *)&v40[8] = 1024;
    *(_DWORD *)&v40[10] = a3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s %d", buf, 0x1Cu);
  }
  if (!a2 || a3)
  {
LABEL_57:
    if (!a1)
      goto LABEL_66;
    goto LABEL_58;
  }
  v36 = 0uLL;
  if (!inet_pton(30, a2, &v36))
  {
    v25 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446723;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v39 = 2160;
      *(_QWORD *)v40 = 1752392040;
      *(_WORD *)&v40[8] = 2081;
      *(_QWORD *)&v40[10] = a2;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%{public}s: address syntax incorrect: %{private, mask.hash}s", buf, 0x20u);
    }
    goto LABEL_57;
  }
  if (*(_BYTE *)(a1 + 258))
  {
    if ((_QWORD)v36 == *(_QWORD *)(a1 + 176) && *((_QWORD *)&v36 + 1) == *(_QWORD *)(a1 + 184))
    {
      v32 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        return;
      *(_DWORD *)buf = 136446210;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v29 = "%{public}s: address didn't change";
      v30 = v32;
      v31 = OS_LOG_TYPE_DEFAULT;
LABEL_72:
      _os_log_impl((void *)&_mh_execute_header, v30, v31, v29, buf, 0xCu);
      return;
    }
  }
  *(_OWORD *)(a1 + 176) = v36;
  *(_BYTE *)(a1 + 258) = 1;
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 40);
  if (v13)
  {
    for (i = *(_QWORD *)(v13 + 48); i; i = *(_QWORD *)(i + 8))
    {
      if (!*(_BYTE *)(i + 27) && *(_DWORD *)(i + 20) == 2 && !*(_QWORD *)(a1 + 128))
      {
        if (*(unsigned __int16 *)(i + 16) == *(unsigned __int16 *)(*(_QWORD *)(a1 + 88) + 276)
          || *(_BYTE *)(a1 + 258)
          && (*(_QWORD *)(i + 64) == *(_QWORD *)(a1 + 176)
            ? (v15 = *(_QWORD *)(i + 72) == *(_QWORD *)(a1 + 184))
            : (v15 = 0),
              v15))
        {
          thread_service_note(*(_QWORD *)(a1 + 72), i, (uint64_t)"is on our ml-eid or rloc16 but we aren't publishing it, so it's stale.");
          service_publisher_unpublish_stale_service(a1, i);
        }
      }
    }
  }
  v16 = state_machine_event_create(7);
  if (!v16)
  {
    v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    v38 = "service_publisher_get_mesh_local_address_callback";
    v29 = "%{public}s: unable to allocate event to deliver";
    v30 = v28;
    v31 = OS_LOG_TYPE_ERROR;
    goto LABEL_72;
  }
  v17 = v16;
  state_machine_event_deliver(a1 + 8, (uint64_t)v16);
  v18 = *v17;
  if (!*v17)
  {
    v35 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v39 = 1024;
      *(_DWORD *)v40 = 0;
      *(_WORD *)&v40[4] = 2048;
      *(_QWORD *)&v40[6] = v17;
      *(_WORD *)&v40[14] = 2080;
      *(_QWORD *)&v40[16] = "event";
      *(_WORD *)&v40[24] = 2080;
      *(_QWORD *)&v40[26] = "service-publisher.c";
      v41 = 1024;
      v42 = 1598;
      v33 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      v34 = v35;
      goto LABEL_78;
    }
    goto LABEL_79;
  }
  v19 = global_os_log;
  if (v18 >= 10001)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136447490;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v39 = 1024;
      *(_DWORD *)v40 = v18;
      *(_WORD *)&v40[4] = 2048;
      *(_QWORD *)&v40[6] = v17;
      *(_WORD *)&v40[14] = 2080;
      *(_QWORD *)&v40[16] = "event";
      *(_WORD *)&v40[24] = 2080;
      *(_QWORD *)&v40[26] = "service-publisher.c";
      v41 = 1024;
      v42 = 1598;
      v33 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      v34 = v19;
      goto LABEL_78;
    }
    goto LABEL_79;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136447490;
    v38 = "service_publisher_get_mesh_local_address_callback";
    v39 = 1024;
    *(_DWORD *)v40 = v18;
    *(_WORD *)&v40[4] = 2048;
    *(_QWORD *)&v40[6] = v17;
    *(_WORD *)&v40[14] = 2080;
    *(_QWORD *)&v40[16] = "event";
    *(_WORD *)&v40[24] = 2080;
    *(_QWORD *)&v40[26] = "service-publisher.c";
    v41 = 1024;
    v42 = 1598;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    v18 = *v17;
  }
  *v17 = v18 - 1;
  if (v18 == 1)
  {
    v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447234;
      v38 = "service_publisher_get_mesh_local_address_callback";
      v39 = 2048;
      *(_QWORD *)v40 = v17;
      *(_WORD *)&v40[8] = 2080;
      *(_QWORD *)&v40[10] = "event";
      *(_WORD *)&v40[18] = 2080;
      *(_QWORD *)&v40[20] = "service-publisher.c";
      *(_WORD *)&v40[28] = 1024;
      *(_DWORD *)&v40[30] = 1598;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++state_machine_event_finalized;
    v21 = (void (*)(int *))*((_QWORD *)v17 + 4);
    if (v21)
      v21(v17);
    free(v17);
  }
  if (a1)
  {
    v22 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v23 = global_os_log;
      if (v22 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          v38 = "service_publisher_get_mesh_local_address_callback";
          v39 = 1024;
          *(_DWORD *)v40 = v22;
          *(_WORD *)&v40[4] = 2048;
          *(_QWORD *)&v40[6] = a1;
          *(_WORD *)&v40[14] = 2080;
          *(_QWORD *)&v40[16] = "publisher";
          *(_WORD *)&v40[24] = 2080;
          *(_QWORD *)&v40[26] = "service-publisher.c";
          v41 = 1024;
          v42 = 1599;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          v22 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v22 - 1;
        if (v22 == 1)
        {
          v24 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            v38 = "service_publisher_get_mesh_local_address_callback";
            v39 = 2048;
            *(_QWORD *)v40 = a1;
            *(_WORD *)&v40[8] = 2080;
            *(_QWORD *)&v40[10] = "publisher";
            *(_WORD *)&v40[18] = 2080;
            *(_QWORD *)&v40[20] = "service-publisher.c";
            *(_WORD *)&v40[28] = 1024;
            *(_DWORD *)&v40[30] = 1599;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++service_publisher_finalized;
          service_publisher_finalize(a1);
        }
        return;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v38 = "service_publisher_get_mesh_local_address_callback";
        v39 = 1024;
        *(_DWORD *)v40 = v22;
        *(_WORD *)&v40[4] = 2048;
        *(_QWORD *)&v40[6] = a1;
        *(_WORD *)&v40[14] = 2080;
        *(_QWORD *)&v40[16] = "publisher";
        *(_WORD *)&v40[24] = 2080;
        *(_QWORD *)&v40[26] = "service-publisher.c";
        v41 = 1024;
        v42 = 1599;
        v33 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_77;
      }
    }
    else
    {
      v23 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        v38 = "service_publisher_get_mesh_local_address_callback";
        v39 = 1024;
        *(_DWORD *)v40 = 0;
        *(_WORD *)&v40[4] = 2048;
        *(_QWORD *)&v40[6] = a1;
        *(_WORD *)&v40[14] = 2080;
        *(_QWORD *)&v40[16] = "publisher";
        *(_WORD *)&v40[24] = 2080;
        *(_QWORD *)&v40[26] = "service-publisher.c";
        v41 = 1024;
        v42 = 1599;
        v33 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_77:
        v34 = v23;
LABEL_78:
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_FAULT, v33, buf, 0x36u);
      }
    }
LABEL_79:
    abort();
  }
}

void srp_parse_client_updates_free_(_QWORD *a1, uint64_t a2, int a3)
{
  _QWORD *v5;
  NSObject *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  int *v18;
  uint64_t v19;
  uint8_t buf[4];
  const char *v21;
  __int16 v22;
  _QWORD *v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;

  if (a1)
  {
    v5 = a1;
    do
    {
      v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446978;
        v21 = "srp_parse_client_updates_free_";
        v22 = 2048;
        v23 = v5;
        v24 = 2082;
        v25 = a2;
        v26 = 1024;
        v27 = a3;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %p at %{public}s:%d", buf, 0x26u);
      }
      v7 = (_QWORD *)*v5;
      v8 = (_QWORD *)v5[6];
      if (v8)
      {
        do
        {
          v9 = (_QWORD *)*v8;
          free(v8);
          v8 = v9;
        }
        while (v9);
      }
      v10 = (_QWORD *)v5[7];
      if (v10)
      {
        do
        {
          v11 = (_QWORD *)*v10;
          free(v10);
          v10 = v11;
        }
        while (v11);
      }
      v12 = (_QWORD *)v5[8];
      if (v12)
      {
        do
        {
          v13 = (_QWORD *)*v12;
          free(v12);
          v12 = v13;
        }
        while (v13);
      }
      v14 = (_QWORD *)v5[5];
      if (v14)
      {
        v15 = (_QWORD *)v14[1];
        if (v15)
        {
          do
          {
            v16 = (_QWORD *)*v15;
            free(v15);
            v15 = v16;
          }
          while (v16);
          v14 = (_QWORD *)v5[5];
        }
        free(v14);
      }
      v17 = (_QWORD *)v5[3];
      if (v17)
        dns_message_free(v17);
      v18 = (int *)v5[4];
      if (v18)
        ioloop_message_release_(v18, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 88);
      v19 = v5[1];
      if (v19)
        ioloop_comm_release_(v19, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 97);
      free(v5);
      v5 = v7;
    }
    while (v7);
  }
}

uint64_t make_delete(_QWORD *a1, _QWORD *a2, uint64_t **a3, uint64_t **a4)
{
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t result;
  NSObject *v13;
  NSObject *v14;
  NSObject *v15;
  int v16;
  const char *v17;
  __int16 v18;
  uint64_t v19;
  __int16 v20;
  uint8_t *v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  _BYTE *v25;
  _BYTE v26[12];
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint8_t *v30;
  uint8_t buf[1016];

  while (1)
  {
    v8 = (_QWORD *)*a1;
    if (!*a1)
      break;
    a1 = (_QWORD *)*a1;
    if (dns_names_equal((uint64_t *)v8[1], (uint64_t **)*a3))
    {
      if (*a3)
        dns_name_print_to_limit(*a3, 0, (uint64_t)buf, 0x3F2uLL);
      else
        strcpy((char *)buf, "<null>");
      v14 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)v26 = 136446723;
        *(_QWORD *)&v26[4] = "make_delete";
        v27 = 2160;
        v28 = 1752392040;
        v29 = 2081;
        v30 = buf;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: two deletes for the same name: %{private, mask.hash}s", v26, 0x20u);
      }
      return 1;
    }
  }
  v9 = malloc_type_calloc(1uLL, 0x20uLL, 0x102004034AC6F07uLL);
  if (v9)
  {
    v10 = v9;
    *a1 = v9;
    v11 = dns_name_subdomain_of(*a3, a4);
    v10[2] = v11;
    if (!v11)
    {
      if (a4)
        dns_name_print_to_limit((uint64_t *)a4, 0, (uint64_t)buf, 0x3F2uLL);
      else
        strcpy((char *)buf, "<null>");
      if (*a3)
        dns_name_print_to_limit(*a3, 0, (uint64_t)v26, 0x3F2uLL);
      else
        strcpy(v26, "<null>");
      v15 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        v16 = 136447235;
        v17 = "make_delete";
        v18 = 2160;
        v19 = 1752392040;
        v20 = 2081;
        v21 = buf;
        v22 = 2160;
        v23 = 1752392040;
        v24 = 2081;
        v25 = v26;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s: delete for record not in update zone %{private, mask.hash}s: %{private, mask.hash}s", (uint8_t *)&v16, 0x34u);
      }
      free(v10);
      return 1;
    }
    v10[1] = *a3;
    result = 0;
    if (a2)
      *a2 = v10;
  }
  else
  {
    v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(_QWORD *)&buf[4] = "make_delete";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: no memory.", buf, 0xCu);
    }
    return 2;
  }
  return result;
}

void replace_zone_name(_QWORD *a1, _QWORD *a2, uint64_t *a3)
{
  _QWORD *v4;
  BOOL v5;
  _QWORD *v6;
  uint8_t *v7;
  uint8_t *v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  const char *v12;
  _QWORD *v13;
  _QWORD *v14;
  uint8_t v15[24];

  do
  {
    v4 = a1;
    a1 = (_QWORD *)*a1;
    if (a1)
      v5 = a1 == a2;
    else
      v5 = 1;
  }
  while (!v5);
  if (!a1)
  {
    v11 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)v15 = 136446210;
    *(_QWORD *)&v15[4] = "replace_zone_name";
    v12 = "%{public}s: replace_zone: dns_name_subdomain_of returned bogus pointer.";
    goto LABEL_23;
  }
  do
  {
    v6 = (_QWORD *)*a1;
    free(a1);
    a1 = v6;
  }
  while (v6);
  *(_QWORD *)v15 = 0;
  v7 = v15;
  do
  {
    v8 = (uint8_t *)malloc_type_calloc(1uLL, *((unsigned __int8 *)a3 + 8) + 10, 0x7B23CD92uLL);
    *(_QWORD *)v7 = v8;
    if (!v8)
    {
      v13 = *(_QWORD **)v15;
      if (*(_QWORD *)v15)
      {
        do
        {
          v14 = (_QWORD *)*v13;
          free(v13);
          v13 = v14;
        }
        while (v14);
      }
      *v4 = 0;
      goto LABEL_21;
    }
    v9 = *((unsigned __int8 *)a3 + 8);
    if (*((_BYTE *)a3 + 8))
    {
      memcpy(v8 + 9, (char *)a3 + 9, v9 + 1);
      LOBYTE(v9) = *((_BYTE *)a3 + 8);
      v7 = *(uint8_t **)v7;
    }
    else
    {
      v7 = v8;
    }
    v7[8] = v9;
    a3 = (uint64_t *)*a3;
  }
  while (a3);
  v10 = *(_QWORD *)v15;
  *v4 = *(_QWORD *)v15;
  if (v10)
    return;
LABEL_21:
  v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v15 = 136446210;
    *(_QWORD *)&v15[4] = "replace_zone_name";
    v12 = "%{public}s: replace_zone_name: no memory for replacement zone";
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v12, v15, 0xCu);
  }
}

uint64_t send_fail_response(uint64_t a1, uint64_t a2, unsigned int a3)
{
  NSObject *v6;
  const char *v7;
  _BYTE v9[22];
  _WORD v10[2];
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  int v43;

  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v28 = 0u;
  v43 = 0;
  v27 = 0u;
  v26 = 0u;
  v25 = 0u;
  v24 = 0u;
  v23 = 0u;
  v22 = 0u;
  v21 = 0u;
  v20 = 0u;
  v19 = 0u;
  v18 = 0u;
  v17 = 0u;
  v16 = 0u;
  v15 = 0u;
  v14 = 0u;
  v13 = 0u;
  v12 = 0u;
  v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a3 > 0x17)
      v7 = "Unknown rcode.";
    else
      v7 = (&off_10008D1C8)[a3];
    *(_DWORD *)v9 = 136446466;
    *(_QWORD *)&v9[4] = "send_fail_response";
    *(_WORD *)&v9[12] = 2082;
    *(_QWORD *)&v9[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: rcode = %{public}s", v9, 0x16u);
  }
  v11 = 0;
  v10[0] = *(_WORD *)(a2 + 88);
  v10[1] = bswap32(a3 | (bswap32(*(_WORD *)(a2 + 90) & 0xF0FF) >> 16) | 0x8000) >> 16;
  *(_QWORD *)v9 = v10;
  *(_QWORD *)&v9[8] = 12;
  return ioloop_send_message(a1, a2, (iovec *)v9);
}

void dns_input(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  uint64_t v6;
  const char *v7;
  NSObject *v8;
  uint64_t *v10;
  uint64_t *v11;
  NSObject *v12;
  int *v13;
  CC_LONG v14;
  int v15;
  CC_LONG v16;
  NSObject *v17;
  uint64_t v18;
  int v19;
  NSObject *v20;
  NSObject *v21;
  _QWORD *v22;
  uint64_t **v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  char v27;
  CC_LONG v28;
  int v30;
  uint64_t v31;
  const char *v32;
  uint64_t v33;
  const char *v34;
  NSObject *v35;
  uint32_t v36;
  void **v37;
  _BYTE *v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t **v41;
  unsigned int v42;
  NSObject *v43;
  uint32_t v44;
  CC_LONG v45;
  _BOOL4 v46;
  uint64_t v47;
  uint64_t v48;
  size_t v49;
  size_t v50;
  uint64_t v51;
  __int128 *v52;
  unsigned __int16 *v53;
  unsigned int v54;
  size_t v55;
  void **v56;
  uint64_t **v57;
  int v58;
  _QWORD *v59;
  uint64_t *v60;
  uint64_t *v61;
  _QWORD *v62;
  uint64_t *v63;
  uint64_t v64;
  __SecKey *v65;
  _QWORD *v66;
  size_t v67;
  __SecKey *v68;
  __SecKey *v69;
  __SecKey *v70;
  uint64_t *v71;
  _QWORD *v72;
  _BYTE *v73;
  int v74;
  int v75;
  char *v77;
  _QWORD *v78;
  _QWORD *v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  uint64_t v83;
  NSObject *v85;
  const char *v86;
  uint64_t *v87;
  _QWORD *v88;
  _QWORD *v89;
  uint64_t **v90;
  uint64_t v91;
  char v92;
  uint64_t v93;
  _QWORD *v94;
  uint64_t **v95;
  void **v96;
  uint64_t *v97;
  NSObject *v98;
  int v99;
  uint64_t v100;
  size_t v101;
  size_t v102;
  uint64_t v103;
  __darwin_time_t tv_sec;
  uint64_t *v105;
  NSObject *v106;
  uint64_t *v107;
  uint64_t v108;
  const char *v109;
  uint8_t *v110;
  NSObject *v111;
  uint32_t v112;
  NSObject *v113;
  NSObject *v114;
  const char *v115;
  NSObject *v116;
  uint64_t v117;
  uint64_t *v118;
  uint64_t v119;
  uint64_t *v120;
  _BYTE *v121;
  uint64_t *v122;
  uint64_t v123;
  uint64_t *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  const char *v128;
  NSObject *v129;
  uint32_t v130;
  uint64_t v131;
  CC_LONG v132;
  size_t v133;
  CC_LONG v134;
  CC_LONG v135;
  size_t v136;
  CC_LONG v137;
  unsigned int *v138;
  CC_LONG v139;
  __CFData *Mutable;
  __CFData *v141;
  const __CFDictionary *v142;
  const __CFDictionary *v143;
  int v144;
  size_t v145;
  uint64_t **v146;
  uint64_t ***v147;
  uint64_t **v148;
  uint64_t v149;
  const char *v150;
  NSObject *v151;
  os_log_type_t v152;
  uint64_t **v153;
  uint64_t v154;
  size_t v155;
  char *v156;
  size_t v157;
  char *v158;
  uint64_t v159;
  uint64_t v160;
  CFDataRef v161;
  CFDataRef v162;
  CC_LONG v163;
  _BYTE *i;
  uint64_t v165;
  const char *v166;
  NSObject *v167;
  uint32_t v168;
  NSObject *v169;
  NSObject *v170;
  uint64_t j;
  uint64_t **v172;
  uint64_t *v173;
  _QWORD *v174;
  uint64_t *v175;
  const __CFString *v176;
  NSObject *v177;
  uint64_t v178;
  NSObject *v179;
  CC_LONG v180;
  CC_LONG v181;
  CC_LONG v182;
  CC_LONG v183;
  uint64_t v184;
  const char *v185;
  NSObject *v186;
  uint32_t v187;
  uint64_t v188;
  NSObject *v189;
  NSObject *v190;
  uint64_t v191;
  NSObject *v192;
  uint64_t v193;
  uint32_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t **v197;
  uint64_t ***v198;
  _QWORD *v199;
  _DWORD *v200;
  size_t signature;
  CFDataRef signaturea;
  NSObject *signatureb;
  _QWORD *data;
  unsigned __int8 *dataa;
  char *datab;
  SecKeyRef key;
  SecKeyRef keya;
  unsigned int allocator;
  unsigned __int16 *v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t **v213;
  uint64_t *v214;
  size_t size;
  size_t sizea;
  size_t sizeb;
  size_t sizec;
  char sized;
  uint64_t ***sizee;
  size_t sizef;
  size_t sizeg;
  _QWORD *v223;
  timeval v224;
  __SecKey *v225;
  _QWORD *v226;
  uint64_t v227;
  _BYTE *v228;
  void *v229;
  CFErrorRef err;
  UInt8 bytes;
  CFErrorRef error;
  char v233[28];
  char v234[1012];
  uint8_t v235[4];
  const char *v236;
  __int16 v237;
  uint64_t v238;
  __int16 v239;
  CC_SHA256_CTX *v240;
  __int16 v241;
  uint64_t v242;
  __int16 v243;
  _BYTE *v244;
  _BYTE md[988];
  CC_SHA256_CTX buf[9];

  v3 = *(unsigned __int16 *)(a2 + 90);
  if ((v3 & 0x80) != 0)
  {
    v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
    buf[0].count[0] = 136446466;
    *(_QWORD *)&buf[0].count[1] = "srp_dns_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = (v3 >> 3) & 0xF;
    v7 = "%{public}s: received a message that was a DNS response: %d";
    v8 = v6;
    goto LABEL_18;
  }
  if ((v3 & 0x78) != 0x28)
  {
    if ((v3 & 0x78) == 0)
    {
      dns_proxy_input_for_server(a1, a2, 0);
LABEL_19:
      v11 = 0;
LABEL_20:
      srp_parse_client_updates_free_(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 922);
      return;
    }
    send_fail_response(a1, a2, 5u);
    v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_19;
    v19 = (*(unsigned __int16 *)(a2 + 90) >> 3) & 0xF;
    buf[0].count[0] = 136446466;
    *(_QWORD *)&buf[0].count[1] = "srp_dns_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v19;
    v7 = "%{public}s: received a message that was not a DNS update: %d";
    v8 = v18;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v7, (uint8_t *)buf, 0x12u);
    goto LABEL_19;
  }
  v228 = 0;
  v229 = 0;
  v226 = 0;
  v227 = 0;
  *(_QWORD *)&v224.tv_usec = 0;
  v225 = 0;
  v224.tv_sec = 0;
  v10 = (uint64_t *)malloc_type_calloc(1uLL, 0x68uLL, 0x10200408B6E1FCBuLL);
  if (!v10)
  {
    v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: no memory for client update", (uint8_t *)buf, 0xCu);
    }
    send_fail_response(a1, a2, 2u);
    goto LABEL_19;
  }
  v11 = v10;
  *((_BYTE *)v10 + 102) = 0;
  *((_BYTE *)v10 + 100) = 2;
  if (!dns_wire_parse_(v10 + 3, (unsigned __int16 *)(a2 + 88), *(unsigned __int16 *)(a2 + 64)))
  {
    v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: dns_wire_parse failed.", (uint8_t *)buf, 0xCu);
    }
    v22 = 0;
    v23 = 0;
    v24 = 0;
    goto LABEL_53;
  }
  v11[4] = a2;
  v12 = global_os_log;
  v13 = (int *)a2;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v14 = *(_DWORD *)a2;
    buf[0].count[0] = 136447490;
    *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v14;
    HIWORD(buf[0].hash[2]) = 2048;
    *(_QWORD *)&buf[0].hash[3] = a2;
    LOWORD(buf[0].hash[5]) = 2080;
    *(_QWORD *)((char *)&buf[0].hash[5] + 2) = "ret->message";
    HIWORD(buf[0].hash[7]) = 2080;
    *(_QWORD *)buf[0].wbuf = "srp-parse.c";
    LOWORD(buf[0].wbuf[2]) = 1024;
    *(CC_LONG *)((char *)&buf[0].wbuf[2] + 2) = 303;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)buf, 0x36u);
    v13 = (int *)v11[4];
  }
  v15 = *v13;
  if (*v13)
  {
    v16 = v15 + 1;
    *v13 = v15 + 1;
    if (v15 + 1 >= 10001)
    {
      v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        buf[0].count[0] = 136447490;
        *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
        LOWORD(buf[0].hash[1]) = 1024;
        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v16;
        HIWORD(buf[0].hash[2]) = 2048;
        *(_QWORD *)&buf[0].hash[3] = v13;
        LOWORD(buf[0].hash[5]) = 2080;
        *(_QWORD *)((char *)&buf[0].hash[5] + 2) = "ret->message";
        HIWORD(buf[0].hash[7]) = 2080;
        *(_QWORD *)buf[0].wbuf = "srp-parse.c";
        LOWORD(buf[0].wbuf[2]) = 1024;
        *(CC_LONG *)((char *)&buf[0].wbuf[2] + 2) = 303;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)buf, 0x36u);
      }
      abort();
    }
  }
  else
  {
    ++message_created;
    *v13 = 1;
  }
  v25 = v11[3];
  *(_DWORD *)md = 3600;
  *(_DWORD *)v235 = 604800;
  v26 = *(uint64_t **)(v25 + 56);
  if (!v26)
    goto LABEL_48;
  v27 = 0;
  do
  {
    while (*((_WORD *)v26 + 5) == 2)
    {
      LODWORD(error) = 0;
      v28 = *((unsigned __int16 *)v26 + 4);
      if (v28 != 4 && v28 != 8)
      {
        v83 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          buf[0].count[0] = 136446466;
          *(_QWORD *)&buf[0].count[1] = "srp_parse_lease_times";
          LOWORD(buf[0].hash[1]) = 1024;
          *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v28;
          v34 = "%{public}s: edns0 update-lease option length bogus: %d";
          v35 = v83;
          v36 = 18;
LABEL_50:
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v34, (uint8_t *)buf, v36);
        }
LABEL_51:
        v22 = 0;
        v23 = 0;
        v24 = 0;
LABEL_52:
        *((_BYTE *)v11 + 100) = 1;
        goto LABEL_53;
      }
      dns_u32_parse((uint64_t)v26 + 12, *((unsigned __int16 *)v26 + 4), (unsigned int *)&error, (int *)md);
      if (*((_WORD *)v26 + 4) == 8)
        dns_u32_parse((uint64_t)v26 + 12, 8u, (unsigned int *)&error, (int *)v235);
      else
        *(_DWORD *)v235 = 7 * *(_DWORD *)md;
      v26 = (uint64_t *)*v26;
      v27 = 1;
      if (!v26)
        goto LABEL_44;
    }
    v26 = (uint64_t *)*v26;
  }
  while (v26);
  if ((v27 & 1) == 0)
  {
LABEL_48:
    v33 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_parse_lease_times";
      v34 = "%{public}s: no update-lease edns0 option found in supposed SRP update";
      v35 = v33;
      v36 = 12;
      goto LABEL_50;
    }
    goto LABEL_51;
  }
LABEL_44:
  v30 = *(_DWORD *)v235;
  *((_DWORD *)v11 + 22) = *(_DWORD *)md;
  *((_DWORD *)v11 + 23) = v30;
  if (*(_DWORD *)(v25 + 4) != 1)
  {
    v31 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
      v32 = "%{public}s: update received with qdcount > 1";
      goto LABEL_62;
    }
LABEL_64:
    v42 = 1;
    *((_BYTE *)v11 + 100) = 1;
LABEL_65:
    if (!*((_BYTE *)v11 + 102))
      send_fail_response(a1, a2, v42);
    goto LABEL_20;
  }
  if (*(_DWORD *)(v25 + 8))
  {
    v31 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
      v32 = "%{public}s: update received with ancount > 0";
LABEL_62:
      v43 = v31;
      v44 = 12;
LABEL_63:
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, v32, (uint8_t *)buf, v44);
      goto LABEL_64;
    }
    goto LABEL_64;
  }
  v45 = *(unsigned __int16 *)(*(_QWORD *)(v25 + 24) + 8);
  if (v45 != 6)
  {
    v48 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_64;
    buf[0].count[0] = 136446466;
    *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v45;
    v32 = "%{public}s: update received with rrtype %d instead of SOA in question section.";
    v43 = v48;
    v44 = 18;
    goto LABEL_63;
  }
  *(_QWORD *)buf[0].hash = 0;
  *(_QWORD *)buf[0].count = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
  *(_QWORD *)(a2 + 72) = *(_QWORD *)buf[0].count;
  v23 = **(uint64_t ****)(v25 + 24);
  if (service_update_zone)
  {
    v46 = dns_names_equal_text(**(uint64_t ***)(v25 + 24), "default.service.arpa.");
    v47 = service_update_zone;
    if (!v46)
      v47 = 0;
    v214 = (uint64_t *)v47;
  }
  else
  {
    v214 = 0;
  }
  LODWORD(v49) = *(_DWORD *)(v25 + 12);
  if (!(_DWORD)v49)
  {
LABEL_227:
    v106 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_ERROR, "%{public}s: SRP update does not include a host description.", (uint8_t *)buf, 0xCu);
    }
    v22 = 0;
    *((_BYTE *)v11 + 100) = 1;
    v24 = v214;
    goto LABEL_53;
  }
  v50 = 0;
  allocator = 0;
  v22 = 0;
  v198 = 0;
  v199 = &v226;
  data = 0;
  key = (SecKeyRef)&v225;
  LODWORD(signature) = 1;
  v213 = v23;
  do
  {
    v223 = v22;
    v51 = *(_QWORD *)(v25 + 40);
    v52 = (__int128 *)(v51 + (v50 << 6));
    v53 = (unsigned __int16 *)v52 + 4;
    v54 = *((unsigned __int16 *)v52 + 4);
    if (v54 <= 0x18)
    {
      if (v54 == 1)
        goto LABEL_93;
      if (v54 == 12)
      {
        v63 = *(uint64_t **)v52;
        size = v50;
        v211 = *(_QWORD *)(v25 + 40);
        if (*(_QWORD *)v52 && (v64 = *v63) != 0 && (v197 = *(uint64_t ***)v64) != 0)
        {
          if (!strcmp((const char *)(v64 + 9), "_sub"))
          {
            v65 = v225;
            if (!v225)
              goto LABEL_158;
            do
            {
              if (dns_names_equal(*(uint64_t **)(*((_QWORD *)v65 + 2) + 16), *(uint64_t ***)(v211 + (size << 6) + 16))&& (dns_names_equal(**((uint64_t ***)v65 + 2), v197) & 1) != 0)
              {
                goto LABEL_115;
              }
              v65 = *(__SecKey **)v65;
            }
            while (v65);
            v63 = *(uint64_t **)v52;
            if (!*(_QWORD *)v52)
              strcpy((char *)buf, "<null>");
            else
LABEL_158:
              dns_name_print_to_limit(v63, 0, (uint64_t)buf, 0x3F2uLL);
            v118 = *(uint64_t **)(v211 + (size << 6) + 16);
            if (v118)
              dns_name_print_to_limit(v118, 0, (uint64_t)md, 0x3F2uLL);
            else
              strcpy(md, "<null>");
            v119 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_309;
            *(_DWORD *)v235 = 136447235;
            v236 = "srp_evaluate";
            v237 = 2160;
            v238 = 1752392040;
            v239 = 2081;
            v240 = buf;
            v241 = 2160;
            v242 = 1752392040;
            v243 = 2081;
            v244 = md;
            v109 = "%{public}s: service subtype %{private, mask.hash}s for %{private, mask.hash}s has no preceding base type ";
LABEL_276:
            v110 = v235;
            v111 = v119;
            v112 = 52;
LABEL_308:
            _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, v109, v110, v112);
            goto LABEL_309;
          }
          v65 = 0;
LABEL_115:
          v50 = size;
          v51 = v211;
        }
        else
        {
          v65 = 0;
        }
        v67 = v51 + (v50 << 6);
        if (*(_WORD *)(v67 + 10) != 254 || *(_DWORD *)(v67 + 12))
        {
          v68 = (__SecKey *)malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
          if (!v68)
          {
            v114 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_310;
            buf[0].count[0] = 136446210;
            *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
            v115 = "%{public}s: no memory";
LABEL_263:
            _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, v115, (uint8_t *)buf, 0xCu);
            goto LABEL_310;
          }
          v69 = v68;
          *(_QWORD *)key = v68;
          if (v65)
            v70 = v65;
          else
            v70 = v68;
          *((_QWORD *)v68 + 1) = v70;
          *((_QWORD *)v68 + 2) = v52;
          v23 = v213;
          v71 = dns_name_subdomain_of(*(uint64_t **)v52, v213);
          *((_QWORD *)v69 + 3) = v71;
          if (!v71)
          {
            if (*(_QWORD *)v52)
              dns_name_print_to_limit(*(uint64_t **)v52, 0, (uint64_t)buf, 0x3F2uLL);
            else
              strcpy((char *)buf, "<null>");
            v122 = *(uint64_t **)(v211 + (size << 6) + 16);
            if (v122)
              dns_name_print_to_limit(v122, 0, (uint64_t)md, 0x3F2uLL);
            else
              strcpy(md, "<null>");
            v119 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_309;
            *(_DWORD *)v235 = 136447235;
            v236 = "srp_evaluate";
            v237 = 2160;
            v238 = 1752392040;
            v239 = 2081;
            v240 = buf;
            v241 = 2160;
            v242 = 1752392040;
            v243 = 2081;
            v244 = md;
            v109 = "%{public}s: service name %{private, mask.hash}s for %{private, mask.hash}s is not in the update zone";
            goto LABEL_276;
          }
          key = v69;
          goto LABEL_129;
        }
        v56 = (void **)&v228;
        v57 = (uint64_t **)v52;
        v23 = v213;
LABEL_91:
        v58 = make_delete(&v229, v56, v57, v23);
        if (v58)
        {
          *((_BYTE *)v11 + 100) = v58;
          goto LABEL_311;
        }
LABEL_129:
        v50 = size;
        v22 = v223;
        goto LABEL_150;
      }
      if (v54 != 16)
        goto LABEL_219;
LABEL_100:
      sizeb = v50;
      v61 = (uint64_t *)v229;
      if (!v229)
      {
LABEL_159:
        v228 = 0;
        if (*(_QWORD *)v52)
          dns_name_print_to_limit(*(uint64_t **)v52, 0, (uint64_t)buf, 0x3F2uLL);
        else
          strcpy((char *)buf, "<null>");
        v23 = v213;
        v24 = v214;
        v85 = global_os_log;
        v22 = v223;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_52;
        *(_DWORD *)md = 136446723;
        *(_QWORD *)&md[4] = "srp_evaluate";
        *(_WORD *)&md[12] = 2160;
        *(_QWORD *)&md[14] = 1752392040;
        *(_WORD *)&md[22] = 2081;
        *(_QWORD *)&md[24] = buf;
        v86 = "%{public}s: ADD for service instance not preceded by delete: %{private, mask.hash}s";
LABEL_218:
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, v86, md, 0x20u);
        goto LABEL_52;
      }
      while ((dns_names_equal((uint64_t *)v61[1], *(uint64_t ***)v52) & 1) == 0)
      {
        v61 = (uint64_t *)*v61;
        if (!v61)
          goto LABEL_159;
      }
      v228 = v61;
      v66 = &v226;
      v23 = v213;
      while (1)
      {
        v66 = (_QWORD *)*v66;
        if (!v66)
          break;
        if ((dns_names_equal((uint64_t *)v66[2], *(uint64_t ***)v52) & 1) != 0)
          goto LABEL_132;
      }
      v72 = malloc_type_calloc(1uLL, 0x48uLL, 0x10200400D7E17FBuLL);
      if (!v72)
      {
        v114 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_310;
        buf[0].count[0] = 136446210;
        *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
        v115 = "%{public}s: no memory";
        goto LABEL_263;
      }
      v66 = v72;
      v73 = v228;
      v72[3] = v228;
      v73[24] = 1;
      v72[2] = *((_QWORD *)v73 + 1);
      *v199 = v72;
      v199 = v72;
LABEL_132:
      v50 = sizeb;
      v74 = *((unsigned __int16 *)v52 + 4);
      if (v74 == 16)
      {
        if (!v66[7])
        {
          v66[7] = v52;
          goto LABEL_149;
        }
        if (*(_QWORD *)v52)
          dns_name_print_to_limit(*(uint64_t **)v52, 0, (uint64_t)buf, 0x3F2uLL);
        else
          strcpy((char *)buf, "<null>");
        v117 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_309;
        *(_DWORD *)md = 136446723;
        *(_QWORD *)&md[4] = "srp_evaluate";
        *(_WORD *)&md[12] = 2160;
        *(_QWORD *)&md[14] = 1752392040;
        *(_WORD *)&md[22] = 2081;
        *(_QWORD *)&md[24] = buf;
        v109 = "%{public}s: more than one TXT rr received for service instance: %{private, mask.hash}s";
      }
      else
      {
        if (v74 != 33)
          goto LABEL_149;
        if (!v66[6])
        {
          v66[6] = v52;
          goto LABEL_149;
        }
        if (*(_QWORD *)v52)
          dns_name_print_to_limit(*(uint64_t **)v52, 0, (uint64_t)buf, 0x3F2uLL);
        else
          strcpy((char *)buf, "<null>");
        v117 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_309;
        *(_DWORD *)md = 136446723;
        *(_QWORD *)&md[4] = "srp_evaluate";
        *(_WORD *)&md[12] = 2160;
        *(_QWORD *)&md[14] = 1752392040;
        *(_WORD *)&md[22] = 2081;
        *(_QWORD *)&md[24] = buf;
        v109 = "%{public}s: more than one SRV rr received for service instance: %{private, mask.hash}s";
      }
LABEL_307:
      v110 = md;
      v111 = v117;
      v112 = 32;
      goto LABEL_308;
    }
    if (*((unsigned __int16 *)v52 + 4) > 0x20u)
    {
      if (v54 != 33)
      {
        if (v54 != 255 || (v55 = v51 + (v50 << 6), *(_WORD *)(v55 + 10) != 255) || *(_DWORD *)(v55 + 12))
        {
LABEL_219:
          if (*(_QWORD *)v52)
            dns_name_print_to_limit(*(uint64_t **)v52, 0, (uint64_t)buf, 0x3F2uLL);
          else
            strcpy((char *)buf, "<null>");
          v108 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_309;
          *(_DWORD *)md = 136446979;
          *(_QWORD *)&md[4] = "srp_evaluate";
          *(_WORD *)&md[12] = 1024;
          *(_DWORD *)&md[14] = v54;
          *(_WORD *)&md[18] = 2160;
          *(_QWORD *)&md[20] = 1752392040;
          *(_WORD *)&md[28] = 2081;
          *(_QWORD *)&md[30] = buf;
          v109 = "%{public}s: unexpected rrtype %d on %{private, mask.hash}s in update.";
          v110 = md;
          v111 = v108;
          v112 = 38;
          goto LABEL_308;
        }
        size = v50;
        v56 = 0;
        v57 = (uint64_t **)(v51 + (v50 << 6));
        goto LABEL_91;
      }
      goto LABEL_100;
    }
    if (v54 == 25)
    {
      if (allocator)
      {
        if (allocator == 1)
        {
          sizec = v50;
          signature = (v49 - v50 + 1);
          v62 = malloc_type_calloc(signature, 8uLL, 0x2004093837F09uLL);
          if (!v62)
          {
            v114 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              goto LABEL_310;
            buf[0].count[0] = 136446210;
            *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
            v115 = "%{public}s: no memory";
            goto LABEL_263;
          }
          data = v62;
          *v62 = v198;
          v50 = sizec;
        }
        v22 = v223;
        if (allocator >= signature)
        {
          v114 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            goto LABEL_310;
          buf[0].count[0] = 136446210;
          *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
          v115 = "%{public}s: coding error in key allocation";
          goto LABEL_263;
        }
        data[allocator++] = v52;
        goto LABEL_150;
      }
      allocator = 1;
      v198 = (uint64_t ***)(v51 + (v50 << 6));
LABEL_149:
      v22 = v223;
      goto LABEL_150;
    }
    if (v54 != 28)
      goto LABEL_219;
LABEL_93:
    v22 = v223;
    sizea = v50;
    if (!v223)
    {
      v59 = malloc_type_calloc(1uLL, 0x28uLL, 0x10200401C8C6399uLL);
      v53 = (unsigned __int16 *)v52 + 4;
      v50 = sizea;
      v22 = v59;
      if (!v59)
      {
        v116 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          buf[0].count[0] = 136446210;
          *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
          goto LABEL_241;
        }
LABEL_242:
        v22 = 0;
LABEL_243:
        v23 = v213;
        v24 = v214;
        goto LABEL_53;
      }
    }
    if (v22[3])
      goto LABEL_137;
    v210 = v53;
    v60 = (uint64_t *)v229;
    if (!v229)
    {
LABEL_166:
      v228 = 0;
      if (*(_QWORD *)v52)
        dns_name_print_to_limit(*(uint64_t **)v52, 0, (uint64_t)buf, 0x3F2uLL);
      else
        strcpy((char *)buf, "<null>");
      v23 = v213;
      v85 = global_os_log;
      v24 = v214;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_52;
      *(_DWORD *)md = 136446723;
      *(_QWORD *)&md[4] = "srp_evaluate";
      *(_WORD *)&md[12] = 2160;
      *(_QWORD *)&md[14] = 1752392040;
      *(_WORD *)&md[22] = 2081;
      *(_QWORD *)&md[24] = buf;
      v86 = "%{public}s: ADD for hostname %{private, mask.hash}s without a preceding delete.";
      goto LABEL_218;
    }
    while ((dns_names_equal((uint64_t *)v60[1], *(uint64_t ***)v52) & 1) == 0)
    {
      v60 = (uint64_t *)*v60;
      if (!v60)
        goto LABEL_166;
    }
    v228 = v60;
    v22[3] = v60;
    *v22 = v60[1];
    v228[24] = 1;
    v23 = v213;
    v50 = sizea;
    v53 = v210;
LABEL_137:
    v75 = *v53;
    if (v75 == 28 || v75 == 1)
    {
      v77 = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0x103204052D25189uLL);
      if (!v77)
      {
        v113 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          buf[0].count[0] = 136446210;
          *(_QWORD *)&buf[0].count[1] = "add_host_addr";
          _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_ERROR, "%{public}s: add_host_addr: no memory for record", (uint8_t *)buf, 0xCu);
        }
        goto LABEL_243;
      }
      v78 = v22 + 1;
      v50 = sizea;
      do
      {
        v79 = v78;
        v78 = (_QWORD *)*v78;
      }
      while (v78);
      *v79 = v77;
      v80 = *v52;
      v81 = v52[1];
      v82 = v52[2];
      *(_OWORD *)(v77 + 56) = v52[3];
      *(_OWORD *)(v77 + 40) = v82;
      *(_OWORD *)(v77 + 24) = v81;
      *(_OWORD *)(v77 + 8) = v80;
    }
LABEL_150:
    ++v50;
    v49 = *(unsigned int *)(v25 + 12);
  }
  while (v50 < v49);
  v223 = v22;
  if (v22)
    goto LABEL_169;
  v23 = v213;
  if (*((_DWORD *)v11 + 22) || !v198)
    goto LABEL_227;
  v105 = (uint64_t *)v229;
  if (!v229)
  {
LABEL_226:
    v228 = 0;
    v23 = v213;
    goto LABEL_227;
  }
  while ((dns_names_equal((uint64_t *)v105[1], *v198) & 1) == 0)
  {
    v105 = (uint64_t *)*v105;
    if (!v105)
      goto LABEL_226;
  }
  v228 = v105;
  v223 = malloc_type_calloc(1uLL, 0x28uLL, 0x10200401C8C6399uLL);
  if (!v223)
  {
    v116 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
LABEL_241:
      _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_ERROR, "%{public}s: no memory", (uint8_t *)buf, 0xCu);
    }
    goto LABEL_242;
  }
  v121 = v228;
  v223[3] = v228;
  *v223 = *((_QWORD *)v121 + 1);
  v121[24] = 1;
LABEL_169:
  v87 = (uint64_t *)v225;
  if (!v225)
    goto LABEL_176;
  do
  {
    if ((uint64_t *)v87[1] != v87)
      goto LABEL_175;
    v88 = &v226;
    do
    {
      v88 = (_QWORD *)*v88;
      if (!v88)
      {
        v107 = *(uint64_t **)v87[2];
        if (v107)
          dns_name_print_to_limit(v107, 0, (uint64_t)buf, 0x3F2uLL);
        else
          strcpy((char *)buf, "<null>");
        v117 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_309;
        *(_DWORD *)md = 136446723;
        *(_QWORD *)&md[4] = "srp_evaluate";
        *(_WORD *)&md[12] = 2160;
        *(_QWORD *)&md[14] = 1752392040;
        *(_WORD *)&md[22] = 2081;
        *(_QWORD *)&md[24] = buf;
        v109 = "%{public}s: service points to an instance that's not included: %{private, mask.hash}s";
        goto LABEL_307;
      }
    }
    while (!dns_names_equal((uint64_t *)v88[2], *(uint64_t ***)(v87[2] + 16)));
    v88[4] = v87;
    ++*((_DWORD *)v88 + 10);
LABEL_175:
    v87 = (uint64_t *)*v87;
  }
  while (v87);
LABEL_176:
  v89 = v226;
  if (v226)
  {
    while (*((_DWORD *)v89 + 10))
    {
      if (dns_names_equal((uint64_t *)*v223, *(uint64_t ***)(v89[6] + 16)))
      {
        v89[1] = v223;
        ++*((_DWORD *)v223 + 8);
      }
      v89 = (_QWORD *)*v89;
      if (!v89)
        goto LABEL_181;
    }
    v120 = (uint64_t *)v89[2];
    if (v120)
      dns_name_print_to_limit(v120, 0, (uint64_t)buf, 0x3F2uLL);
    else
      strcpy((char *)buf, "<null>");
    v117 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      goto LABEL_309;
    *(_DWORD *)md = 136446723;
    *(_QWORD *)&md[4] = "srp_evaluate";
    *(_WORD *)&md[12] = 2160;
    *(_QWORD *)&md[14] = 1752392040;
    *(_WORD *)&md[22] = 2081;
    *(_QWORD *)&md[24] = buf;
    v109 = "%{public}s: service instance update for %{private, mask.hash}s is not referenced by a service update.";
    goto LABEL_307;
  }
LABEL_181:
  v90 = (uint64_t **)v198;
  if (!allocator)
  {
LABEL_194:
    if (data)
      free(data);
    if (!v223[2])
    {
      if (*v223)
        dns_name_print_to_limit((uint64_t *)*v223, 0, (uint64_t)buf, 0x3F2uLL);
      else
        strcpy((char *)buf, "<null>");
      v117 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_309;
      *(_DWORD *)md = 136446723;
      *(_QWORD *)&md[4] = "srp_evaluate";
      *(_WORD *)&md[12] = 2160;
      *(_QWORD *)&md[14] = 1752392040;
      *(_WORD *)&md[22] = 2081;
      *(_QWORD *)&md[24] = buf;
      v109 = "%{public}s: host description %{private, mask.hash}s doesn't contain a key.";
      goto LABEL_307;
    }
    v95 = (uint64_t **)v229;
    if (v229)
    {
      v96 = &v229;
      sizee = (uint64_t ***)&v227;
      do
      {
        v228 = v95;
        if (*((_BYTE *)v95 + 24))
        {
          v96 = (void **)v95;
        }
        else
        {
          v97 = v95[1];
          if (v97)
            dns_name_print_to_limit(v97, 0, (uint64_t)buf, 0x3F2uLL);
          else
            strcpy((char *)buf, "<null>");
          v98 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)md = 136446723;
            *(_QWORD *)&md[4] = "srp_evaluate";
            *(_WORD *)&md[12] = 2160;
            *(_QWORD *)&md[14] = 1752392040;
            *(_WORD *)&md[22] = 2081;
            *(_QWORD *)&md[24] = buf;
            _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "%{public}s: delete for presumably previously-registered instance which is being withdrawn: %{private, mask.hash}s", md, 0x20u);
            v95 = (uint64_t **)v228;
          }
          *sizee = v95;
          sizee = (uint64_t ***)v228;
          *v96 = *(void **)v228;
          *(_QWORD *)v228 = 0;
        }
        v95 = (uint64_t **)*v96;
      }
      while (*v96);
    }
    v99 = *(_DWORD *)(v25 + 16);
    if (!v99)
    {
      v123 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_309;
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
      v109 = "%{public}s: signature not present";
      goto LABEL_288;
    }
    v100 = (v99 - 1);
    sizef = *(_QWORD *)(v25 + 48);
    v101 = sizef + (v100 << 6);
    if (*(_WORD *)(v101 + 8) != 24)
    {
      v123 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_309;
      buf[0].count[0] = 136446210;
      *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
      v109 = "%{public}s: signature is not at the end or is not present";
      goto LABEL_288;
    }
    v102 = v101 + 16;
    if ((dns_names_equal(*(uint64_t **)(v101 + 40), (uint64_t **)*v223) & 1) == 0)
    {
      v124 = *(uint64_t **)(v102 + 24);
      if (v124)
        dns_name_print_to_limit(v124, 0, (uint64_t)buf, 0x3F2uLL);
      else
        strcpy((char *)buf, "<null>");
      if (*v223)
        dns_name_print_to_limit((uint64_t *)*v223, 0, (uint64_t)md, 0x3F2uLL);
      else
        strcpy(md, "<null>");
      v119 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_309;
      *(_DWORD *)v235 = 136447235;
      v236 = "srp_evaluate";
      v237 = 2160;
      v238 = 1752392040;
      v239 = 2081;
      v240 = buf;
      v241 = 2160;
      v242 = 1752392040;
      v243 = 2081;
      v244 = md;
      v109 = "%{public}s: signer %{private, mask.hash}s doesn't match host %{private, mask.hash}s";
      goto LABEL_276;
    }
    if (*(_DWORD *)(v102 + 12) || *(_DWORD *)(v102 + 8))
    {
      gettimeofday(&v224, 0);
      v103 = *(_QWORD *)(a2 + 72);
      if (v103)
      {
        *(_QWORD *)buf[0].hash = 0;
        *(_QWORD *)buf[0].count = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
        tv_sec = v103 - *(_QWORD *)buf[0].count + v224.tv_sec;
        v224.tv_sec = tv_sec;
        v224.tv_usec = 0;
      }
      else
      {
        tv_sec = v224.tv_sec;
      }
      v125 = *(unsigned int *)(v102 + 8);
      if (v125 < tv_sec || *(_DWORD *)(v102 + 12) > tv_sec)
      {
        v126 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          v127 = *(unsigned int *)(v102 + 12);
          buf[0].count[0] = 136446978;
          *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
          LOWORD(buf[0].hash[1]) = 2048;
          *(_QWORD *)((char *)&buf[0].hash[1] + 2) = v127;
          HIWORD(buf[0].hash[3]) = 2048;
          *(_QWORD *)&buf[0].hash[4] = tv_sec;
          LOWORD(buf[0].hash[6]) = 2048;
          *(_QWORD *)((char *)&buf[0].hash[6] + 2) = v125;
          v128 = "%{public}s: signature is not timely: %lu < %lu < %lu does not hold";
          v129 = v126;
          v130 = 42;
LABEL_382:
          _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_ERROR, v128, (uint8_t *)buf, v130);
          goto LABEL_383;
        }
        goto LABEL_383;
      }
    }
    v131 = v223[2];
    err = 0;
    v212 = v131;
    v132 = *(unsigned __int8 *)(v131 + 19);
    v133 = sizef + (v100 << 6);
    v134 = *(unsigned __int8 *)(v133 + 18);
    dataa = (unsigned __int8 *)(v133 + 18);
    if (v132 != v134)
    {
      v184 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_380;
      buf[0].count[0] = 136446722;
      *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
      LOWORD(buf[0].hash[1]) = 1024;
      *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v132;
      HIWORD(buf[0].hash[2]) = 1024;
      buf[0].hash[3] = v134;
      v185 = "%{public}s: KEY algorithm does not match the SIG(0) algorithm - KEY algorithm: %u, SIG(0) algorithm: %u";
      v186 = v184;
      v187 = 24;
      goto LABEL_411;
    }
    if (v132 == 13)
    {
      v135 = *(_DWORD *)(v212 + 20);
      if (v135 == 64)
      {
        v136 = sizef + (v100 << 6);
        v139 = *(_DWORD *)(v136 + 52);
        v138 = (unsigned int *)(v136 + 52);
        v137 = v139;
        if (v139 == 64)
        {
          error = 0;
          bytes = 4;
          *(_QWORD *)buf[0].count = kSecAttrKeyType;
          *(_QWORD *)buf[0].hash = kSecAttrKeyClass;
          *(_QWORD *)md = kSecAttrKeyTypeECSECPrimeRandom;
          *(_QWORD *)&md[8] = kSecAttrKeyClassPublic;
          Mutable = CFDataCreateMutable(kCFAllocatorDefault, 65);
          if (Mutable)
          {
            v141 = Mutable;
            CFDataAppendBytes(Mutable, &bytes, 1);
            CFDataAppendBytes(v141, *(const UInt8 **)(v212 + 24), *(unsigned int *)(v212 + 20));
            v142 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)md, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (v142)
            {
              v143 = v142;
              keya = SecKeyCreateWithData(v141, v142, &error);
              if (!keya)
              {
                signatureb = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v235 = 136446210;
                  v236 = "create_public_sec_key";
                  _os_log_impl((void *)&_mh_execute_header, signatureb, OS_LOG_TYPE_ERROR, "%{public}s: SecKeyCreateWithData failed when creating public key SecKeyRef", v235, 0xCu);
                }
              }
              CFRelease(v141);
              CFRelease(v143);
              if (error)
                CFRelease(error);
              if (keya)
              {
                signaturea = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)(sizef + (v100 << 6) + 56), *v138);
                if (!signaturea)
                {
                  v192 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    buf[0].count[0] = 136446210;
                    *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
                    _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_ERROR, "%{public}s: CFDataCreate failed when creating sig_to_match_cfdata", (uint8_t *)buf, 0xCu);
                  }
LABEL_379:
                  CFRelease(keya);
                  goto LABEL_380;
                }
                v144 = *dataa;
                if (v144 != 13)
                {
                  v193 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)v235 = 136446466;
                    v236 = "create_data_to_verify";
                    v237 = 1024;
                    LODWORD(v238) = v144;
                    v150 = "%{public}s: Unsupported SIG(0) algorithm - SIG(0) algorithm: %u";
                    v151 = v193;
                    v152 = OS_LOG_TYPE_FAULT;
                    v194 = 18;
LABEL_421:
                    _os_log_impl((void *)&_mh_execute_header, v151, v152, v150, v235, v194);
                    goto LABEL_359;
                  }
                  goto LABEL_359;
                }
                memset(buf, 0, 104);
                CC_SHA256_Init(buf);
                v145 = sizef + (v100 << 6);
                v200 = (_DWORD *)(v145 + 48);
                CC_SHA256_Update(buf, (const void *)(a2 + (*(_DWORD *)(v145 + 48) + 11) + 100), 0x12u);
                v148 = *(uint64_t ***)(v145 + 40);
                v147 = (uint64_t ***)(v145 + 40);
                v146 = v148;
                if (v148)
                {
                  sizeg = 0;
                  do
                  {
                    sizeg += *((unsigned __int8 *)v146 + 8) + 1;
                    v146 = (uint64_t **)*v146;
                  }
                  while (v146);
                  if (sizeg >= 0x101)
                  {
                    v149 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)v235 = 136446466;
                      v236 = "create_data_to_verify";
                      v237 = 2048;
                      v238 = sizeg;
                      v150 = "%{public}s: Invalid signer name length - signer name length: %zu";
                      v151 = v149;
                      v152 = OS_LOG_TYPE_FAULT;
LABEL_420:
                      v194 = 22;
                      goto LABEL_421;
                    }
                    goto LABEL_359;
                  }
                }
                else
                {
                  sizeg = 0;
                }
                datab = (char *)malloc_type_malloc(sizeg, 0xD87643A6uLL);
                if (!datab)
                {
                  v195 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v235 = 136446466;
                    v236 = "create_data_to_verify";
                    v237 = 2048;
                    v238 = sizeg;
                    v150 = "%{public}s: malloc failed when allocating memory - for canonical_signer_name, len: %lu";
                    v151 = v195;
                    v152 = OS_LOG_TYPE_ERROR;
                    goto LABEL_420;
                  }
LABEL_359:
                  v169 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    buf[0].count[0] = 136446210;
                    *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
                    _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_ERROR, "%{public}s: Failed to data_to_verify_cfdata", (uint8_t *)buf, 0xCu);
                  }
LABEL_378:
                  CFRelease(signaturea);
                  goto LABEL_379;
                }
                v153 = *v147;
                if (v153)
                {
                  v154 = 0;
                  v155 = sizeg;
                  v156 = datab;
                  do
                  {
                    v157 = *((unsigned __int8 *)v153 + 8);
                    if (v155 <= v157)
                      goto LABEL_355;
                    *v156 = v157;
                    v158 = v156 + 1;
                    memcpy(v158, (char *)v153 + 9, *((unsigned __int8 *)v153 + 8));
                    v159 = *((unsigned __int8 *)v153 + 8);
                    v156 = &v158[v159];
                    v155 += ~v159;
                    v160 = v154 + v159;
                    v154 = v160 + 1;
                    v153 = (uint64_t **)*v153;
                  }
                  while (v153);
                  if (v160 == -1)
                    goto LABEL_355;
                  CC_SHA256_Update(buf, datab, sizeg);
                  *(_WORD *)(a2 + 98) = bswap32((bswap32(*(unsigned __int16 *)(a2 + 98)) >> 16) - 1) >> 16;
                  CC_SHA256_Update(buf, (const void *)(a2 + 88), *v200 + 12);
                  *(_WORD *)(a2 + 98) = bswap32((bswap32(*(unsigned __int16 *)(a2 + 98)) >> 16) + 1) >> 16;
                  CC_SHA256_Final(md, buf);
                  v161 = CFDataCreate(kCFAllocatorDefault, md, 32);
                  if (v161)
                  {
                    v162 = v161;
                    free(datab);
                    v163 = *(unsigned __int8 *)(v212 + 19);
                    if (v163 == 13)
                    {
                      if (SecKeyVerifySignature(keya, kSecKeyAlgorithmECDSASignatureDigestRFC4754, v162, signaturea, &err))
                      {
                        CFRelease(v162);
                        CFRelease(signaturea);
                        CFRelease(keya);
                        if (!v214)
                          goto LABEL_372;
                        for (i = v229; ; i = *(_BYTE **)v228)
                        {
                          v228 = i;
                          if (!i)
                            break;
                          replace_zone_name((_QWORD *)i + 1, *((_QWORD **)i + 2), v214);
                        }
                        for (j = v227; ; j = *(_QWORD *)v228)
                        {
                          v228 = (_BYTE *)j;
                          if (!j)
                            break;
                          replace_zone_name((_QWORD *)(j + 8), *(_QWORD **)(j + 16), v214);
                        }
                        v172 = (uint64_t **)v225;
                        if (v225)
                        {
                          while (1)
                          {
                            replace_zone_name(v172[2], v172[3], v214);
                            v173 = dns_name_subdomain_of((uint64_t *)v172[2][2], v213);
                            if (!v173)
                              break;
                            replace_zone_name(v172[2] + 2, v173, v214);
                            v172 = (uint64_t **)*v172;
                            if (!v172)
                              goto LABEL_369;
                          }
                          v123 = global_os_log;
                          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                            goto LABEL_309;
                          buf[0].count[0] = 136446210;
                          *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
                          v109 = "%{public}s: service PTR record zone match fail!!";
                          goto LABEL_288;
                        }
LABEL_369:
                        v174 = v226;
                        if (!v226)
                        {
LABEL_372:
                          if (*v223)
                            dns_name_print_to_limit((uint64_t *)*v223, 0, (uint64_t)v234, 0x3F2uLL);
                          else
                            strcpy(v234, "<null>");
                          if (*(_QWORD *)(a2 + 72))
                          {
                            *(_QWORD *)buf[0].hash = 0;
                            *(_QWORD *)buf[0].count = 0;
                            clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
                            srp_format_time_offset(v233, *(_QWORD *)buf[0].count - *(_QWORD *)(a2 + 72));
                          }
                          else
                          {
                            *(_QWORD *)v233 = 0x74657320746F6ELL;
                          }
                          v179 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            v180 = *(unsigned __int16 *)(a2 + 88);
                            v182 = *((_DWORD *)v11 + 22);
                            v181 = *((_DWORD *)v11 + 23);
                            v183 = *(_DWORD *)(a2 + 80);
                            buf[0].count[0] = 136449027;
                            *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
                            LOWORD(buf[0].hash[1]) = 2160;
                            *(_QWORD *)((char *)&buf[0].hash[1] + 2) = 1752392040;
                            HIWORD(buf[0].hash[3]) = 2081;
                            *(_QWORD *)&buf[0].hash[4] = v234;
                            LOWORD(buf[0].hash[6]) = 1024;
                            *(CC_LONG *)((char *)&buf[0].hash[6] + 2) = 0;
                            HIWORD(buf[0].hash[7]) = 1024;
                            buf[0].wbuf[0] = v180;
                            LOWORD(buf[0].wbuf[1]) = 1024;
                            *(CC_LONG *)((char *)&buf[0].wbuf[1] + 2) = v181;
                            HIWORD(buf[0].wbuf[2]) = 1024;
                            buf[0].wbuf[3] = v182;
                            LOWORD(buf[0].wbuf[4]) = 1024;
                            *(CC_LONG *)((char *)&buf[0].wbuf[4] + 2) = v183;
                            HIWORD(buf[0].wbuf[5]) = 2082;
                            *(_QWORD *)&buf[0].wbuf[6] = v233;
                            LOWORD(buf[0].wbuf[8]) = 2160;
                            *(_QWORD *)((char *)&buf[0].wbuf[8] + 2) = 1752392040;
                            HIWORD(buf[0].wbuf[10]) = 2081;
                            *(_QWORD *)&buf[0].wbuf[11] = "(none)";
                            LOWORD(buf[0].wbuf[13]) = 2048;
                            *(_QWORD *)((char *)&buf[0].wbuf[13] + 2) = v11;
                            _os_log_impl((void *)&_mh_execute_header, v179, OS_LOG_TYPE_DEFAULT, "%{public}s: update for %{private, mask.hash}s #%d, xid %x validates, key lease %d, host lease %d, message lease %d, receive_time %{public}s, remote %{private, mask.hash}s -> %p.", (uint8_t *)buf, 0x66u);
                          }
                          *((_BYTE *)v11 + 100) = 0;
                          goto LABEL_310;
                        }
                        while (1)
                        {
                          v175 = dns_name_subdomain_of(*(uint64_t **)(v174[6] + 16), v213);
                          if (!v175)
                            break;
                          replace_zone_name((_QWORD *)(v174[6] + 16), v175, v214);
                          v174 = (_QWORD *)*v174;
                          if (!v174)
                            goto LABEL_372;
                        }
                        v123 = global_os_log;
                        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                          goto LABEL_309;
                        buf[0].count[0] = 136446210;
                        *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
                        v109 = "%{public}s: service instance SRV record zone match fail!!";
LABEL_288:
                        v110 = (uint8_t *)buf;
                        v111 = v123;
                        v112 = 12;
                        goto LABEL_308;
                      }
                      v176 = CFErrorCopyDescription(err);
                      CFStringGetCString(v176, (char *)buf, 200, 0x8000100u);
                      v177 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)md = 136446466;
                        *(_QWORD *)&md[4] = "srp_sig0_verify";
                        *(_WORD *)&md[12] = 2080;
                        *(_QWORD *)&md[14] = buf;
                        _os_log_impl((void *)&_mh_execute_header, v177, OS_LOG_TYPE_ERROR, "%{public}s: SecKeyVerifySignature failed to validate - Error Description: %s", md, 0x16u);
                      }
                      CFRelease(v176);
                      CFRelease(err);
                      err = 0;
                    }
                    else
                    {
                      v170 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      {
                        buf[0].count[0] = 136446466;
                        *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
                        LOWORD(buf[0].hash[1]) = 1024;
                        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v163;
                        _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_FAULT, "%{public}s: Unsupported KEY algorithm - KEY algorithm: %u", (uint8_t *)buf, 0x12u);
                      }
                    }
                    CFRelease(v162);
                    goto LABEL_378;
                  }
                  v196 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v235 = 136446210;
                    v236 = "create_data_to_verify";
                    v166 = "%{public}s: CFDataCreate failed when creating data_to_verify_cfdata";
                    v167 = v196;
                    v168 = 12;
                    goto LABEL_357;
                  }
                }
                else
                {
LABEL_355:
                  v165 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)v235 = 136446466;
                    v236 = "create_data_to_verify";
                    v237 = 2048;
                    v238 = sizeg;
                    v166 = "%{public}s: Failed to write canonical name - canonical_signer_name_length: %lu";
                    v167 = v165;
                    v168 = 22;
LABEL_357:
                    _os_log_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_ERROR, v166, v235, v168);
                  }
                }
                free(datab);
                goto LABEL_359;
              }
            }
            else
            {
              v190 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)v235 = 136446210;
                v236 = "create_public_sec_key";
                _os_log_impl((void *)&_mh_execute_header, v190, OS_LOG_TYPE_ERROR, "%{public}s: CFDictionaryCreate failed when creating public key options CFDictionaryRef", v235, 0xCu);
              }
              CFRelease(v141);
            }
          }
          else
          {
            v189 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v235 = 136446210;
              v236 = "create_public_sec_key";
              _os_log_impl((void *)&_mh_execute_header, v189, OS_LOG_TYPE_ERROR, "%{public}s: CFDataCreateMutable failed when creating public key CFMutableDataRef", v235, 0xCu);
            }
          }
          v191 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
LABEL_380:
            v178 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              buf[0].count[0] = 136446210;
              *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
              v128 = "%{public}s: signature is not valid";
              v129 = v178;
              v130 = 12;
              goto LABEL_382;
            }
LABEL_383:
            *((_BYTE *)v11 + 102) = 1;
            goto LABEL_310;
          }
          buf[0].count[0] = 136446210;
          *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
          v185 = "%{public}s: Failed to create public_key";
          v186 = v191;
          v187 = 12;
LABEL_411:
          _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_ERROR, v185, (uint8_t *)buf, v187);
          goto LABEL_380;
        }
        v188 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_380;
        buf[0].count[0] = 136446466;
        *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
        LOWORD(buf[0].hash[1]) = 1024;
        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v137;
        v185 = "%{public}s: Invalid SIG(0) length - SIG(0) length: %d";
      }
      else
      {
        v188 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_380;
        buf[0].count[0] = 136446466;
        *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
        LOWORD(buf[0].hash[1]) = 1024;
        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v135;
        v185 = "%{public}s: Invalid KEY length - KEY len: %d";
      }
    }
    else
    {
      v188 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        goto LABEL_380;
      buf[0].count[0] = 136446466;
      *(_QWORD *)&buf[0].count[1] = "srp_sig0_verify";
      LOWORD(buf[0].hash[1]) = 1024;
      *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v132;
      v185 = "%{public}s: Unsupported KEY algorithm - KEY algorithm: %u";
    }
    v186 = v188;
    v187 = 18;
    goto LABEL_411;
  }
  v91 = 0;
  v92 = 0;
  while (1)
  {
    sized = v92;
    if (v91)
    {
      v93 = (uint64_t)v90;
      v90 = (uint64_t **)data[v91];
      if (!dns_keys_rdata_equal(v93, (uint64_t)v90))
      {
        v123 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          goto LABEL_309;
        buf[0].count[0] = 136446210;
        *(_QWORD *)&buf[0].count[1] = "srp_evaluate";
        v109 = "%{public}s: more than one key presented";
        goto LABEL_288;
      }
    }
    if (v223[2] || !dns_names_equal(*v90, (uint64_t **)*v223))
      break;
    v223[2] = v90;
LABEL_193:
    ++v91;
    v92 = 1;
    if (v91 == allocator)
      goto LABEL_194;
  }
  v94 = &v226;
  while (1)
  {
    v94 = (_QWORD *)*v94;
    if (!v94)
      break;
    if ((dns_names_equal((uint64_t *)v94[2], (uint64_t **)*v90) & 1) != 0)
      goto LABEL_193;
  }
  if ((sized & 1) != 0)
    goto LABEL_193;
  if (*v90)
    dns_name_print_to_limit(*v90, 0, (uint64_t)buf, 0x3F2uLL);
  else
    strcpy((char *)buf, "<null>");
  v117 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)md = 136446723;
    *(_QWORD *)&md[4] = "srp_evaluate";
    *(_WORD *)&md[12] = 2160;
    *(_QWORD *)&md[14] = 1752392040;
    *(_WORD *)&md[22] = 2081;
    *(_QWORD *)&md[24] = buf;
    v109 = "%{public}s: key present for name %{private, mask.hash}s which is neither a host nor an instance name.";
    goto LABEL_307;
  }
LABEL_309:
  *((_BYTE *)v11 + 100) = 1;
LABEL_310:
  v23 = v213;
LABEL_311:
  v24 = v214;
  v22 = v223;
LABEL_53:
  v37 = (void **)v229;
  v228 = v229;
  if (v229)
  {
    do
    {
      v38 = *v37;
      free(v37);
      v228 = v38;
      v37 = (void **)v38;
    }
    while (v38);
  }
  v39 = v226;
  v40 = v227;
  v11[5] = (uint64_t)v22;
  v11[6] = (uint64_t)v39;
  v11[7] = (uint64_t)v225;
  v11[8] = v40;
  if (v24)
    v41 = (uint64_t **)v24;
  else
    v41 = v23;
  v11[9] = (uint64_t)v41;
  v42 = *((unsigned __int8 *)v11 + 100);
  if (*((_BYTE *)v11 + 100))
    goto LABEL_65;
  v11[1] = a1;
  ioloop_comm_retain_(a1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 916);
  v11[10] = a3;
  srp_update_start(v11);
}

_QWORD *srp_proxy_init()
{
  _QWORD *v0;
  _QWORD *v1;
  _QWORD *result;

  v0 = (_QWORD *)service_update_zone;
  if (service_update_zone)
  {
    do
    {
      v1 = (_QWORD *)*v0;
      free(v0);
      v0 = v1;
    }
    while (v1);
  }
  result = dns_pres_name_parse("local");
  service_update_zone = (uint64_t)result;
  return result;
}

void ioloop_udp_read_callback(uint64_t a1, uint64_t a2)
{
  ssize_t v3;
  size_t v4;
  _OWORD *v5;
  _OWORD *v6;
  __int128 v7;
  uint64_t v8;
  const char *v9;
  int *v10;
  char *v11;
  NSObject *v12;
  uint32_t v13;
  uint64_t v14;
  int v15;
  unsigned int *msg_control;
  unsigned int v17;
  __int128 v18;
  unsigned int v19;
  int v20;
  uint64_t v21;
  _BOOL4 v22;
  const char *v23;
  const char *v24;
  int v25;
  NSObject *v26;
  const char *v27;
  uint32_t v28;
  int v29;
  unint64_t v31;
  int v32;
  uint64_t v33;
  const char *v34;
  NSObject *v35;
  os_log_type_t v36;
  uint32_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  _OWORD v45[2];
  _QWORD v46[2];
  msghdr v47;
  _OWORD v48[2];
  uint8_t buf[4];
  const char *v50;
  __int16 v51;
  size_t v52;
  __int16 v53;
  int v54;
  __int16 v55;
  uint64_t v56;
  __int16 v57;
  _BYTE v58[14];
  __int16 v59;
  _BYTE v60[20];
  __int128 v61;
  uint64_t v62;
  __int16 v63;
  int v64;
  __int16 v65;
  uint64_t *v66;
  __int16 v67;
  unsigned int v68;
  __int16 v69;
  const char *v70;
  __int16 v71;
  uint64_t v72;
  __int16 v73;
  int v74;
  __int16 v75;
  char *v76;
  __int16 v77;
  uint64_t v78;
  __int16 v79;
  int v80;
  __int16 v81;
  char *v82;
  __int16 v83;
  uint64_t v84;
  __int16 v85;
  int v86;
  __int16 v87;
  _OWORD *v88;
  __int16 v89;
  unsigned int v90;
  char v91;
  _BYTE __src[1410];

  memset(v48, 0, 28);
  *(&v47.msg_iovlen + 1) = 0;
  *(&v47.msg_namelen + 1) = 0;
  v46[0] = __src;
  v46[1] = 1410;
  v47.msg_iov = (iovec *)v46;
  v47.msg_iovlen = 1;
  v47.msg_name = v48;
  v47.msg_namelen = 28;
  v47.msg_control = &v91;
  v47.msg_flags = 0;
  v47.msg_controllen = 128;
  v3 = recvmsg(*(_DWORD *)(a1 + 92), &v47, 0);
  if (v3 < 0)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    v10 = __error();
    v11 = strerror(*v10);
    *(_DWORD *)buf = 136446466;
    v50 = "ioloop_udp_read_callback";
    v51 = 2080;
    v52 = (size_t)v11;
    v9 = "%{public}s: %s";
    goto LABEL_8;
  }
  v4 = v3;
  v5 = ioloop_message_create_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/ioloop.c", 600);
  if (!v5)
  {
    v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446210;
    v50 = "ioloop_udp_read_callback";
    v9 = "%{public}s: out of memory";
    v12 = v14;
    v13 = 12;
    goto LABEL_11;
  }
  v6 = v5;
  v7 = v48[0];
  v5[1] = *(_OWORD *)((char *)v48 + 12);
  *(_OWORD *)((char *)v5 + 4) = v7;
  if (v4 >= 0x10000)
  {
    v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      return;
    *(_DWORD *)buf = 136446466;
    v50 = "ioloop_udp_read_callback";
    v51 = 2048;
    v52 = v4;
    v9 = "%{public}s: message is surprisingly large: %zd";
LABEL_8:
    v12 = v8;
    v13 = 22;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v9, buf, v13);
    return;
  }
  *((_WORD *)v5 + 32) = v4;
  memcpy((char *)v5 + 88, __src, v4);
  v15 = 0;
  if (v47.msg_controllen >= 0xC)
  {
    msg_control = (unsigned int *)v47.msg_control;
    if (v47.msg_control)
    {
      LOBYTE(v15) = 0;
      do
      {
        memset(v45, 0, 28);
        v41 = 0;
        v42 = 0;
        v44 = 0;
        v43 = 0;
        v17 = msg_control[1];
        if (v17)
        {
          if (v17 == 41 && msg_control[2] == 46)
          {
            v18 = *(_OWORD *)(msg_control + 3);
            *((_DWORD *)v6 + 15) = msg_control[7];
            *((_BYTE *)v6 + 33) = 30;
            *((_WORD *)v6 + 17) = bswap32(*(unsigned __int16 *)(a2 + 160)) >> 16;
            *(_OWORD *)((char *)v6 + 40) = v18;
            *((_BYTE *)v6 + 32) = 28;
LABEL_22:
            if (*((_QWORD *)&v48[0] + 1) || LOWORD(v48[1]) || WORD1(v48[1]) != 0xFFFF)
            {
              v45[0] = v48[0];
              *(_OWORD *)((char *)v45 + 12) = *(_OWORD *)((char *)v48 + 12);
              v20 = BYTE1(v48[0]);
            }
            else
            {
              v20 = 2;
              BYTE1(v45[0]) = 2;
              DWORD1(v45[0]) = DWORD1(v48[1]);
              WORD1(v45[0]) = WORD1(v48[0]);
            }
            ioloop_normalize_address((uint64_t)&v41, v6 + 2);
            v21 = global_os_log;
            v22 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
            if (v20 == 30)
            {
              if (v22)
              {
                v23 = "ULA: ";
                if ((v42 & 0xFE) != 0xFC)
                {
                  if (v42 != 254 || (v23 = "LUA: ", (BYTE1(v42) & 0xC0) != 0x80))
                  {
                    v23 = (const char *)&unk_10007C3B5;
                    if ((v42 & 0xE0) == 0x20)
                      v23 = "GUA: ";
                  }
                }
                v24 = "ULA: ";
                if ((BYTE8(v45[0]) & 0xFE) != 0xFC)
                {
                  if (BYTE8(v45[0]) != 254 || (v24 = "LUA: ", (BYTE9(v45[0]) & 0xC0) != 0x80))
                  {
                    v24 = (const char *)&unk_10007C3B5;
                    if ((BYTE8(v45[0]) & 0xE0) == 0x20)
                      v24 = "GUA: ";
                  }
                }
                v25 = *((_DWORD *)v6 + 15);
                *(_DWORD *)buf = 136452355;
                v50 = "ioloop_udp_read_callback";
                v51 = 2048;
                v52 = v4;
                v53 = 1024;
                v54 = v25;
                v55 = 2082;
                v56 = (uint64_t)v23;
                v57 = 2160;
                *(_QWORD *)v58 = 1752392040;
                *(_WORD *)&v58[8] = 1041;
                *(_DWORD *)&v58[10] = 6;
                v59 = 2097;
                *(_QWORD *)v60 = &v42;
                *(_WORD *)&v60[8] = 2160;
                *(_QWORD *)&v60[10] = 1752392040;
                *(_WORD *)&v60[18] = 1042;
                LODWORD(v61) = 2;
                WORD2(v61) = 2098;
                *(_QWORD *)((char *)&v61 + 6) = (char *)&v42 + 6;
                HIWORD(v61) = 2160;
                v62 = 1752392040;
                v63 = 1041;
                v64 = 8;
                v65 = 2097;
                v66 = &v43;
                v67 = 1024;
                v68 = bswap32(WORD1(v41)) >> 16;
                v69 = 2082;
                v70 = v24;
                v71 = 2160;
                v72 = 1752392040;
                v73 = 1041;
                v74 = 6;
                v75 = 2097;
                v76 = (char *)v45 + 8;
                v77 = 2160;
                v78 = 1752392040;
                v79 = 1042;
                v80 = 2;
                v81 = 2098;
                v82 = (char *)v45 + 14;
                v83 = 2160;
                v84 = 1752392040;
                v85 = 1041;
                v86 = 8;
                v87 = 2097;
                v88 = &v45[1];
                v89 = 1024;
                v90 = bswap32(WORD1(v45[0])) >> 16;
                v26 = v21;
                v27 = "%{public}s: received %zd byte UDP message on index %d to {%{public}s%{private, mask.hash, srp:in6_"
                      "addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_"
                      "segment}.8P}#%d from {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash"
                      ", srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d";
                v28 = 216;
LABEL_43:
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v27, buf, v28);
              }
            }
            else if (v22)
            {
              v29 = *((_DWORD *)v6 + 15);
              *(_DWORD *)buf = 136448771;
              v50 = "ioloop_udp_read_callback";
              v51 = 2048;
              v52 = v4;
              v53 = 1024;
              v54 = v29;
              v55 = 2160;
              v56 = 1752392040;
              v57 = 1041;
              *(_DWORD *)v58 = 4;
              *(_WORD *)&v58[4] = 2097;
              *(_QWORD *)&v58[6] = (char *)&v41 + 4;
              v59 = 1024;
              *(_DWORD *)v60 = bswap32(WORD1(v41)) >> 16;
              *(_WORD *)&v60[4] = 2160;
              *(_QWORD *)&v60[6] = 1752392040;
              *(_WORD *)&v60[14] = 1041;
              *(_DWORD *)&v60[16] = 4;
              LOWORD(v61) = 2097;
              *(_QWORD *)((char *)&v61 + 2) = (char *)&v41 + 4;
              WORD5(v61) = 1024;
              HIDWORD(v61) = bswap32(WORD1(v45[0])) >> 16;
              v26 = v21;
              v27 = "%{public}s: received %zd byte UDP message on index %d to %{private, mask.hash, network:in_addr}.4P#%"
                    "d from %{private, mask.hash, network:in_addr}.4P#%d";
              v28 = 92;
              goto LABEL_43;
            }
            v15 = 1;
            goto LABEL_45;
          }
        }
        else if (msg_control[2] == 26)
        {
          v19 = msg_control[5];
          *((_DWORD *)v6 + 15) = msg_control[3];
          *((_DWORD *)v6 + 9) = v19;
          *((_WORD *)v6 + 16) = 540;
          *((_WORD *)v6 + 17) = bswap32(*(unsigned __int16 *)(a2 + 160)) >> 16;
          goto LABEL_22;
        }
        if ((v15 & 1) != 0)
          goto LABEL_22;
        v15 = 0;
LABEL_45:
        msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
      }
      while ((char *)(msg_control + 3) <= (char *)v47.msg_control + v47.msg_controllen && msg_control != 0);
    }
  }
  v31 = *(_QWORD *)(a2 + 408);
  if (v31)
  {
    v32 = *((_DWORD *)v6 + 15);
    if (v32)
    {
      if (v31 >= 2)
      {
        v39 = v31 + 8;
        while (1)
        {
          v39 = *(_QWORD *)v39;
          if (!v39)
            break;
          if (*(_DWORD *)(v39 + 16) == v32)
            goto LABEL_60;
        }
      }
      v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        goto LABEL_66;
      *(_DWORD *)buf = 136446466;
      v50 = "ioloop_udp_read_callback";
      v51 = 1024;
      LODWORD(v52) = v32;
      v34 = "%{public}s: dropping message because it arrived on interface index %d which is not permitted";
      v35 = v33;
      v36 = OS_LOG_TYPE_DEFAULT;
      v37 = 18;
      goto LABEL_65;
    }
    v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v50 = "ioloop_udp_read_callback";
      v34 = "%{public}s: dropping message because we didn't receive an interface index";
      v35 = v38;
      v36 = OS_LOG_TYPE_DEFAULT;
LABEL_64:
      v37 = 12;
LABEL_65:
      _os_log_impl((void *)&_mh_execute_header, v35, v36, v34, buf, v37);
    }
  }
  else
  {
LABEL_60:
    if (v15)
    {
      (*(void (**)(uint64_t, _OWORD *, _QWORD))(a2 + 208))(a2, v6, *(_QWORD *)(a2 + 200));
    }
    else
    {
      v40 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v50 = "ioloop_udp_read_callback";
        v34 = "%{public}s: dropping incoming packet because we didn't get a destination address.";
        v35 = v40;
        v36 = OS_LOG_TYPE_ERROR;
        goto LABEL_64;
      }
    }
  }
LABEL_66:
  ioloop_message_release_((int *)v6, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/ioloop.c", 695);
}

uint64_t ioloop_normalize_address(uint64_t result, __int128 *a2)
{
  __int128 v2;

  if (*((_WORD *)a2 + 4)
    || *((_WORD *)a2 + 5)
    || *((_WORD *)a2 + 6)
    || *((_WORD *)a2 + 7)
    || *((_WORD *)a2 + 8)
    || *((__int16 *)a2 + 9) != -1)
  {
    v2 = *a2;
    *(_OWORD *)(result + 12) = *(__int128 *)((char *)a2 + 12);
    *(_OWORD *)result = v2;
  }
  else
  {
    *(_BYTE *)(result + 1) = 2;
    *(_DWORD *)(result + 4) = *((_DWORD *)a2 + 5);
    *(_WORD *)(result + 2) = *((_WORD *)a2 + 1);
  }
  return result;
}
