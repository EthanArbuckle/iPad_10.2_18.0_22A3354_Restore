#error "1000027E0: too big function (funcsize=0)"

int *sub_100022CA8()
{
  __int16 v0;
  char v1;
  int v2;
  NSObject *v3;
  int v4;
  const __CFString *v5;
  const __CFString *v6;
  const char *CStringPtr;
  char *v8;
  char *v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  FILE *v18;
  FILE *v19;
  int v20;
  NSObject *v21;
  int v22;
  const __CFString *v23;
  const __CFString *v24;
  const char *v25;
  char *v26;
  char *v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  FILE *v36;
  FILE *v37;
  int v38;
  NSObject *v39;
  int v40;
  const __CFString *v41;
  const __CFString *v42;
  const char *v43;
  char *v44;
  char *v45;
  NSObject *v46;
  FILE *v47;
  FILE *v48;
  double v49;
  double v50;
  int v51;
  NSObject *v52;
  int v53;
  const __CFString *v54;
  const __CFString *v55;
  const char *v56;
  char *v57;
  char *v58;
  NSObject *v59;
  FILE *v60;
  FILE *v61;
  int v62;
  NSObject *v63;
  int v64;
  const __CFString *v65;
  const __CFString *v66;
  const char *v67;
  char *v68;
  char *v69;
  NSObject *v70;
  FILE *v71;
  FILE *v72;
  int v73;
  NSObject *v74;
  int v75;
  const __CFString *v76;
  const __CFString *v77;
  const char *v78;
  char *v79;
  char *v80;
  NSObject *v81;
  FILE *v82;
  FILE *v83;
  int v84;
  NSObject *v85;
  int v86;
  const __CFString *v87;
  const __CFString *v88;
  const char *v89;
  char *v90;
  char *v91;
  NSObject *v92;
  FILE *v93;
  FILE *v94;
  int v95;
  NSObject *v96;
  int v97;
  const __CFString *v98;
  const __CFString *v99;
  const char *v100;
  char *v101;
  char *v102;
  NSObject *v103;
  FILE *v104;
  FILE *v105;
  char v106;
  int v107;
  NSObject *v108;
  int v109;
  const __CFString *v110;
  const __CFString *v111;
  const char *v112;
  char *v113;
  char *v114;
  NSObject *v115;
  FILE *v116;
  FILE *v117;
  int v118;
  NSObject *v119;
  int v120;
  const __CFString *v121;
  const __CFString *v122;
  const char *v123;
  char *v124;
  char *v125;
  NSObject *v126;
  FILE *v127;
  FILE *v128;
  int v129;
  NSObject *v130;
  int v131;
  const __CFString *v132;
  const __CFString *v133;
  const char *v134;
  char *v135;
  char *v136;
  NSObject *v137;
  FILE *v138;
  FILE *v139;
  int *result;
  char v141;
  int v142;
  NSObject *v143;
  int v144;
  const __CFString *v145;
  const __CFString *v146;
  const char *v147;
  char *v148;
  char *v149;
  NSObject *v150;
  FILE *v151;
  FILE *v152;
  uint8_t buf[4];
  _BYTE v154[10];
  __int16 v155;
  int v156;
  __int16 v157;
  int v158;

  if (sub_10002D658("/var/db/.spindump_ignore_thermal_pressure"))
    v0 = 2;
  else
    v0 = 0;
  word_1000EBD78 = word_1000EBD78 & 0xFFFD | v0;
  if (qword_1000EBC20 != -1)
    dispatch_once(&qword_1000EBC20, &stru_1000DD0D0);
  word_1000EBD78 = word_1000EBD78 & 0xFFFE | byte_1000EBC18;
  if (qword_1000EBC30 != -1)
    dispatch_once(&qword_1000EBC30, &stru_1000DD0F0);
  word_1000EBD78 = word_1000EBD78 & 0xFFFB | (4 * byte_1000EBC28);
  if (qword_1000EBC40 != -1)
    dispatch_once(&qword_1000EBC40, &stru_1000DD110);
  v1 = word_1000EBD78;
  word_1000EBD78 = word_1000EBD78 & 0xFFF7 | (8 * byte_1000EBC38);
  if ((v1 & 4) != 0)
  {
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Submissions suppressed", buf, 2u);
      }
      *__error() = v2;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
    {
      v4 = *__error();
      v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Submissions suppressed"));
      if (v5)
      {
        v6 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (CStringPtr)
        {
          v8 = (char *)CStringPtr;
          v9 = 0;
        }
        else
        {
          v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C895723uLL);
          CFStringGetCString(v6, v8, 1024, 0x8000100u);
          v9 = v8;
        }
        if (qword_1000EBD40)
          v19 = (FILE *)qword_1000EBD40;
        else
          v19 = __stderrp;
        fprintf(v19, "%s\n", v8);
        if (v9)
          free(v9);
        CFRelease(v6);
      }
      else
      {
        v10 = sub_100030318();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
          sub_100088A20(v10, v11, v12, v13, v14, v15, v16, v17);
        if (qword_1000EBD40)
          v18 = (FILE *)qword_1000EBD40;
        else
          v18 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
      }
      *__error() = v4;
    }
  }
  if ((word_1000EBD78 & 8) != 0)
  {
    if (byte_1000EBD38)
    {
      v20 = *__error();
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Submissions forced enabled", buf, 2u);
      }
      *__error() = v20;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
    {
      v22 = *__error();
      v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Submissions forced enabled"));
      if (v23)
      {
        v24 = v23;
        v25 = CFStringGetCStringPtr(v23, 0x8000100u);
        if (v25)
        {
          v26 = (char *)v25;
          v27 = 0;
        }
        else
        {
          v26 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4DE31EA0uLL);
          CFStringGetCString(v24, v26, 1024, 0x8000100u);
          v27 = v26;
        }
        if (qword_1000EBD40)
          v37 = (FILE *)qword_1000EBD40;
        else
          v37 = __stderrp;
        fprintf(v37, "%s\n", v26);
        if (v27)
          free(v27);
        CFRelease(v24);
      }
      else
      {
        v28 = sub_100030318();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
          sub_1000889F0(v28, v29, v30, v31, v32, v33, v34, v35);
        if (qword_1000EBD40)
          v36 = (FILE *)qword_1000EBD40;
        else
          v36 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
      }
      *__error() = v22;
    }
  }
  if ((word_1000EBD78 & 1) != 0)
  {
    qword_1000EBD50 = 0x4059000000000000;
    if (byte_1000EBD38)
    {
      v38 = *__error();
      v39 = sub_100030318();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)v154 = qword_1000EBD50;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_INFO, "Apple Internal: reporting full spins %.1f%% of the time", buf, 0xCu);
      }
      *__error() = v38;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
    {
      v40 = *__error();
      v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Apple Internal: reporting full spins %.1f%% of the time"), qword_1000EBD50);
      if (v41)
      {
        v42 = v41;
        v43 = CFStringGetCStringPtr(v41, 0x8000100u);
        if (v43)
        {
          v44 = (char *)v43;
          v45 = 0;
        }
        else
        {
          v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x631A51D4uLL);
          CFStringGetCString(v42, v44, 1024, 0x8000100u);
          v45 = v44;
        }
        if (qword_1000EBD40)
          v48 = (FILE *)qword_1000EBD40;
        else
          v48 = __stderrp;
        fprintf(v48, "%s\n", v44);
        if (v45)
          free(v45);
        CFRelease(v42);
      }
      else
      {
        v46 = sub_100030318();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
          sub_100088984();
        if (qword_1000EBD40)
          v47 = (FILE *)qword_1000EBD40;
        else
          v47 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
      }
      *__error() = v40;
    }
  }
  else
  {
    sub_100048CB8((uint64_t)CFSTR("spindump_percent_full_spin_reports"), (uint64_t)&qword_1000EBD50, 0.0);
  }
  v49 = 25.0;
  if ((word_1000EBD78 & 1) != 0)
    v49 = 100.0;
  sub_100048CB8((uint64_t)CFSTR("io_exception_sampling_percentage"), (uint64_t)&qword_1000EBD68, v49);
  v50 = 5.0;
  if ((word_1000EBD78 & 1) != 0)
    v50 = 100.0;
  sub_100048CB8((uint64_t)CFSTR("cpu_resource_1st_party_sampling_percentage"), (uint64_t)&qword_1000EBD70, v50);
  sub_100048CB8((uint64_t)CFSTR("spindump_percent_short_spins_reported"), (uint64_t)&unk_1000EBD58, 10.0);
  sub_100048CB8((uint64_t)CFSTR("spindump_threshold_defining_short_spins_s"), (uint64_t)&unk_1000EBD60, 2.0);
  word_1000EBD78 &= 0xFF9Fu;
  if (byte_1000EBD38)
  {
    v51 = *__error();
    v52 = sub_100030318();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
      sub_100088914();
    *__error() = v51;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
  {
    v53 = *__error();
    v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Submit spins:%d hangs:%d unavilable on this platform"), ((unsigned __int16)word_1000EBD78 >> 5) & 1, ((unsigned __int16)word_1000EBD78 >> 6) & 1);
    if (v54)
    {
      v55 = v54;
      v56 = CFStringGetCStringPtr(v54, 0x8000100u);
      if (v56)
      {
        v57 = (char *)v56;
        v58 = 0;
      }
      else
      {
        v57 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x14529887uLL);
        CFStringGetCString(v55, v57, 1024, 0x8000100u);
        v58 = v57;
      }
      if (qword_1000EBD40)
        v61 = (FILE *)qword_1000EBD40;
      else
        v61 = __stderrp;
      fprintf(v61, "%s\n", v57);
      if (v58)
        free(v58);
      CFRelease(v55);
    }
    else
    {
      v59 = sub_100030318();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
        sub_1000888B0();
      if (qword_1000EBD40)
        v60 = (FILE *)qword_1000EBD40;
      else
        v60 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
    }
    *__error() = v53;
  }
  word_1000EBD78 = (word_1000EBD78 & 0xDE7F | ((((unsigned __int16)word_1000EBD78 >> 2) & 1) << 7) & 0xDEFF | ((((unsigned __int16)word_1000EBD78 >> 2) & 1) << 13) | ((((unsigned __int16)word_1000EBD78 >> 2) & 1) << 8)) ^ 0x2180;
  if (byte_1000EBD38)
  {
    v62 = *__error();
    v63 = sub_100030318();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109632;
      *(_DWORD *)v154 = ((unsigned __int16)word_1000EBD78 >> 7) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = HIBYTE(word_1000EBD78) & 1;
      v155 = 1024;
      v156 = ((unsigned __int16)word_1000EBD78 >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_INFO, "Submit resource reports cpu:%d io:%d due to suppression:%d", buf, 0x14u);
    }
    *__error() = v62;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v64 = *__error();
    v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Submit resource reports cpu:%d io:%d due to suppression:%d"), ((unsigned __int16)word_1000EBD78 >> 7) & 1, HIBYTE(word_1000EBD78) & 1, ((unsigned __int16)word_1000EBD78 >> 2) & 1);
    if (v65)
    {
      v66 = v65;
      v67 = CFStringGetCStringPtr(v65, 0x8000100u);
      if (v67)
      {
        v68 = (char *)v67;
        v69 = 0;
      }
      else
      {
        v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFE16B315uLL);
        CFStringGetCString(v66, v68, 1024, 0x8000100u);
        v69 = v68;
      }
      if (qword_1000EBD40)
        v72 = (FILE *)qword_1000EBD40;
      else
        v72 = __stderrp;
      fprintf(v72, "%s\n", v68);
      if (v69)
        free(v69);
      CFRelease(v66);
    }
    else
    {
      v70 = sub_100030318();
      if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
        sub_100088828();
      if (qword_1000EBD40)
        v71 = (FILE *)qword_1000EBD40;
      else
        v71 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
    }
    *__error() = v64;
  }
  word_1000EBD78 = ((word_1000EBD78 << 8) & 0x400 | word_1000EBD78 & 0xF1FF | (word_1000EBD78 << 7) & 0x200 | (word_1000EBD78 << 9) & 0x800) ^ 0xE00;
  if (byte_1000EBD38)
  {
    v73 = *__error();
    v74 = sub_100030318();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109888;
      *(_DWORD *)v154 = ((unsigned __int16)word_1000EBD78 >> 9) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = ((unsigned __int16)word_1000EBD78 >> 10) & 1;
      v155 = 1024;
      v156 = ((unsigned __int16)word_1000EBD78 >> 11) & 1;
      v157 = 1024;
      v158 = ((unsigned __int16)word_1000EBD78 >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_INFO, "Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d", buf, 0x1Au);
    }
    *__error() = v73;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v75 = *__error();
    v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d"), ((unsigned __int16)word_1000EBD78 >> 9) & 1, ((unsigned __int16)word_1000EBD78 >> 10) & 1, ((unsigned __int16)word_1000EBD78 >> 11) & 1, ((unsigned __int16)word_1000EBD78 >> 2) & 1);
    if (v76)
    {
      v77 = v76;
      v78 = CFStringGetCStringPtr(v76, 0x8000100u);
      if (v78)
      {
        v79 = (char *)v78;
        v80 = 0;
      }
      else
      {
        v79 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x27FCBE94uLL);
        CFStringGetCString(v77, v79, 1024, 0x8000100u);
        v80 = v79;
      }
      if (qword_1000EBD40)
        v83 = (FILE *)qword_1000EBD40;
      else
        v83 = __stderrp;
      fprintf(v83, "%s\n", v79);
      if (v80)
        free(v80);
      CFRelease(v77);
    }
    else
    {
      v81 = sub_100030318();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT))
        sub_100088794();
      if (qword_1000EBD40)
        v82 = (FILE *)qword_1000EBD40;
      else
        v82 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v82);
    }
    *__error() = v75;
  }
  word_1000EBD78 &= ~0x1000u;
  if (byte_1000EBD38)
  {
    v84 = *__error();
    v85 = sub_100030318();
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
      sub_100088730();
    *__error() = v84;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
  {
    v86 = *__error();
    v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Submit service watchdog:%d unavilable on this platform"), ((unsigned __int16)word_1000EBD78 >> 12) & 1);
    if (v87)
    {
      v88 = v87;
      v89 = CFStringGetCStringPtr(v87, 0x8000100u);
      if (v89)
      {
        v90 = (char *)v89;
        v91 = 0;
      }
      else
      {
        v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x108F8061uLL);
        CFStringGetCString(v88, v90, 1024, 0x8000100u);
        v91 = v90;
      }
      if (qword_1000EBD40)
        v94 = (FILE *)qword_1000EBD40;
      else
        v94 = __stderrp;
      fprintf(v94, "%s\n", v90);
      if (v91)
        free(v91);
      CFRelease(v88);
    }
    else
    {
      v92 = sub_100030318();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
        sub_1000886CC();
      if (qword_1000EBD40)
        v93 = (FILE *)qword_1000EBD40;
      else
        v93 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
    }
    *__error() = v86;
  }
  byte_1000EBD4C = (byte_1000EBD4C & 0xFC | (2 * (word_1000EBD78 & 1))) ^ 2;
  if (byte_1000EBD38)
  {
    v95 = *__error();
    v96 = sub_100030318();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v154 = (byte_1000EBD4C >> 1) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = word_1000EBD78 & 1;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_INFO, "Avoid affecting audio:%d due to internal:%d", buf, 0xEu);
    }
    *__error() = v95;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v97 = *__error();
    v98 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Avoid affecting audio:%d due to internal:%d"), (byte_1000EBD4C >> 1) & 1, word_1000EBD78 & 1);
    if (v98)
    {
      v99 = v98;
      v100 = CFStringGetCStringPtr(v98, 0x8000100u);
      if (v100)
      {
        v101 = (char *)v100;
        v102 = 0;
      }
      else
      {
        v101 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xEC869ACuLL);
        CFStringGetCString(v99, v101, 1024, 0x8000100u);
        v102 = v101;
      }
      if (qword_1000EBD40)
        v105 = (FILE *)qword_1000EBD40;
      else
        v105 = __stderrp;
      fprintf(v105, "%s\n", v101);
      if (v102)
        free(v102);
      CFRelease(v99);
    }
    else
    {
      v103 = sub_100030318();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT))
        sub_100088644();
      if (qword_1000EBD40)
        v104 = (FILE *)qword_1000EBD40;
      else
        v104 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v104);
    }
    *__error() = v97;
  }
  if (sub_10002D658("/var/db/.spindump_enable_symbolication"))
    v106 = 8;
  else
    v106 = 0;
  byte_1000EBD4C = byte_1000EBD4C & 0xF7 | v106;
  if (byte_1000EBD38)
  {
    v107 = *__error();
    v108 = sub_100030318();
    if (os_log_type_enabled(v108, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109376;
      *(_DWORD *)v154 = (byte_1000EBD4C >> 3) & 1;
      *(_WORD *)&v154[4] = 1024;
      *(_DWORD *)&v154[6] = *(_DWORD *)v154;
      _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_INFO, "Symbolicate:%d due to enable symbolication file existing:%d", buf, 0xEu);
    }
    *__error() = v107;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v109 = *__error();
    v110 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Symbolicate:%d due to enable symbolication file existing:%d"), (byte_1000EBD4C >> 3) & 1, (byte_1000EBD4C >> 3) & 1);
    if (v110)
    {
      v111 = v110;
      v112 = CFStringGetCStringPtr(v110, 0x8000100u);
      if (v112)
      {
        v113 = (char *)v112;
        v114 = 0;
      }
      else
      {
        v113 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2FA5331EuLL);
        CFStringGetCString(v111, v113, 1024, 0x8000100u);
        v114 = v113;
      }
      if (qword_1000EBD40)
        v117 = (FILE *)qword_1000EBD40;
      else
        v117 = __stderrp;
      fprintf(v117, "%s\n", v113);
      if (v114)
        free(v114);
      CFRelease(v111);
    }
    else
    {
      v115 = sub_100030318();
      if (os_log_type_enabled(v115, OS_LOG_TYPE_FAULT))
        sub_1000885C8();
      if (qword_1000EBD40)
        v116 = (FILE *)qword_1000EBD40;
      else
        v116 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v116);
    }
    *__error() = v109;
  }
  byte_1000EBD4C |= 0x10u;
  if (byte_1000EBD38)
  {
    v118 = *__error();
    v119 = sub_100030318();
    if (os_log_type_enabled(v119, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000EBD4C >> 4) & 1;
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_INFO, "NoBulkSymbolication:%d", buf, 8u);
    }
    *__error() = v118;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v120 = *__error();
    v121 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("NoBulkSymbolication:%d"), (byte_1000EBD4C >> 4) & 1);
    if (v121)
    {
      v122 = v121;
      v123 = CFStringGetCStringPtr(v121, 0x8000100u);
      if (v123)
      {
        v124 = (char *)v123;
        v125 = 0;
      }
      else
      {
        v124 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBEB0062AuLL);
        CFStringGetCString(v122, v124, 1024, 0x8000100u);
        v125 = v124;
      }
      if (qword_1000EBD40)
        v128 = (FILE *)qword_1000EBD40;
      else
        v128 = __stderrp;
      fprintf(v128, "%s\n", v124);
      if (v125)
        free(v125);
      CFRelease(v122);
    }
    else
    {
      v126 = sub_100030318();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT))
        sub_100088560();
      if (qword_1000EBD40)
        v127 = (FILE *)qword_1000EBD40;
      else
        v127 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
    }
    *__error() = v120;
  }
  byte_1000EBD4C &= ~4u;
  if (byte_1000EBD38)
  {
    v129 = *__error();
    v130 = sub_100030318();
    if (os_log_type_enabled(v130, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000EBD4C >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_INFO, "UseDsymForUUID:%d", buf, 8u);
    }
    *__error() = v129;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v131 = *__error();
    v132 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UseDsymForUUID:%d"), (byte_1000EBD4C >> 2) & 1);
    if (v132)
    {
      v133 = v132;
      v134 = CFStringGetCStringPtr(v132, 0x8000100u);
      if (v134)
      {
        v135 = (char *)v134;
        v136 = 0;
      }
      else
      {
        v135 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8C1902D4uLL);
        CFStringGetCString(v133, v135, 1024, 0x8000100u);
        v136 = v135;
      }
      if (qword_1000EBD40)
        v139 = (FILE *)qword_1000EBD40;
      else
        v139 = __stderrp;
      fprintf(v139, "%s\n", v135);
      if (v136)
        free(v136);
      CFRelease(v133);
    }
    else
    {
      v137 = sub_100030318();
      if (os_log_type_enabled(v137, OS_LOG_TYPE_FAULT))
        sub_1000884F8();
      if (qword_1000EBD40)
        v138 = (FILE *)qword_1000EBD40;
      else
        v138 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v138);
    }
    *__error() = v131;
  }
  result = (int *)sub_10002D658("/var/db/.spindump_disable_exclaves");
  if ((_DWORD)result)
    v141 = 32;
  else
    v141 = 0;
  byte_1000EBD4C = byte_1000EBD4C & 0xDF | v141;
  if (byte_1000EBD38)
  {
    v142 = *__error();
    v143 = sub_100030318();
    if (os_log_type_enabled(v143, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)v154 = (byte_1000EBD4C >> 5) & 1;
      _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_INFO, "NoExclaves:%d", buf, 8u);
    }
    result = __error();
    *result = v142;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v144 = *__error();
    v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("NoExclaves:%d"), (byte_1000EBD4C >> 5) & 1);
    if (v145)
    {
      v146 = v145;
      v147 = CFStringGetCStringPtr(v145, 0x8000100u);
      if (v147)
      {
        v148 = (char *)v147;
        v149 = 0;
      }
      else
      {
        v148 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x98B21CFCuLL);
        CFStringGetCString(v146, v148, 1024, 0x8000100u);
        v149 = v148;
      }
      if (qword_1000EBD40)
        v152 = (FILE *)qword_1000EBD40;
      else
        v152 = __stderrp;
      fprintf(v152, "%s\n", v148);
      if (v149)
        free(v149);
      CFRelease(v146);
    }
    else
    {
      v150 = sub_100030318();
      if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT))
        sub_100088490();
      if (qword_1000EBD40)
        v151 = (FILE *)qword_1000EBD40;
      else
        v151 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
    }
    result = __error();
    *result = v144;
  }
  return result;
}

uint64_t sub_10002438C(uint64_t a1)
{
  _QWORD v2[2];
  void (*v3)(uint64_t, int);
  void *v4;
  uint64_t v5;

  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v3 = sub_10002440C;
  v4 = &unk_1000DD160;
  v5 = a1;
  sub_10002440C((uint64_t)v2, 2);
  sub_10002440C((uint64_t)v2, 15);
  v3((uint64_t)v2, 1);
  return ((uint64_t (*)(_QWORD *, uint64_t))v3)(v2, 3);
}

void sub_10002440C(uint64_t a1, int a2)
{
  uintptr_t v4;
  NSObject *global_queue;
  dispatch_source_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  NSObject *v11;
  uint64_t v12;
  int v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  int v18;
  const __CFString *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  FILE *v23;
  const char *CStringPtr;
  char *v25;
  char *v26;
  FILE *v27;
  int v28;
  const __CFString *theString;
  _QWORD handler[6];

  v4 = a2;
  global_queue = dispatch_get_global_queue(25, 2uLL);
  v6 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, v4, 0, global_queue);
  if (!v6)
  {
    if (byte_1000EBD38)
    {
      v13 = *__error();
      v14 = sub_100030318();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        sub_100091840(v14, v15, v16);
      *__error() = v13;
    }
    if (byte_1000EBD39)
      v17 = dword_1000EB4E8 <= 3;
    else
      v17 = 0;
    if (v17)
    {
      v18 = *__error();
      v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: unable to allocate source"), "source");
      if (v19)
      {
        v28 = v18;
        theString = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          v25 = (char *)CStringPtr;
          v26 = 0;
        }
        else
        {
          v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6B7D9D72uLL);
          CFStringGetCString(theString, v25, 1024, 0x8000100u);
          v26 = v25;
        }
        if (qword_1000EBD40)
          v27 = (FILE *)qword_1000EBD40;
        else
          v27 = __stderrp;
        fprintf(v27, "%s\n", v25);
        if (v26)
          free(v26);
        CFRelease(theString);
        v18 = v28;
      }
      else
      {
        v20 = sub_100030318();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
          sub_1000917CC(v20, v21, v22);
        if (qword_1000EBD40)
          v23 = (FILE *)qword_1000EBD40;
        else
          v23 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
      }
      *__error() = v18;
    }
    sub_1000301F0("RegisterExitHandlers_block_invoke", "spindump.m", 4145, "%s: unable to allocate source", v7, v8, v9, v10, (char)"source");
    abort();
  }
  v11 = v6;
  signal(a2, (void (__cdecl *)(int))1);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10005EEC8;
  handler[3] = &unk_1000DD780;
  v12 = *(_QWORD *)(a1 + 32);
  handler[4] = v11;
  handler[5] = v12;
  dispatch_source_set_event_handler(v11, handler);
  dispatch_resume(v11);
}

void sub_100024678()
{
  NSObject *v0;
  NSObject *v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _xpc_connection_s *mach_service;
  int v8;
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  int v18;
  const __CFString *v19;
  NSObject *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  FILE *v28;
  const char *CStringPtr;
  char *v30;
  char *v31;
  FILE *v32;
  int v33;
  const __CFString *theString;
  _QWORD handler[5];

  v0 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v1 = dispatch_queue_attr_make_with_qos_class(v0, QOS_CLASS_USER_INITIATED, 0);
  v2 = dispatch_queue_create("com.apple.spindump.communication", v1);
  dispatch_release(v1);
  dispatch_release(v0);
  if (!v2)
  {
    if (byte_1000EBD38)
    {
      v8 = *__error();
      v9 = sub_100030318();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        sub_10008942C(v9, v10, v11, v12, v13, v14, v15, v16);
      *__error() = v8;
    }
    if (byte_1000EBD39)
      v17 = dword_1000EB4E8 <= 3;
    else
      v17 = 0;
    if (v17)
    {
      v18 = *__error();
      v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: unable to allocate communication queue"), "communication_queue");
      if (v19)
      {
        v33 = v18;
        theString = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          v30 = (char *)CStringPtr;
          v31 = 0;
        }
        else
        {
          v30 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x70E88092uLL);
          CFStringGetCString(theString, v30, 1024, 0x8000100u);
          v31 = v30;
        }
        if (qword_1000EBD40)
          v32 = (FILE *)qword_1000EBD40;
        else
          v32 = __stderrp;
        fprintf(v32, "%s\n", v30);
        if (v31)
          free(v31);
        CFRelease(theString);
        v18 = v33;
      }
      else
      {
        v20 = sub_100030318();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
          sub_1000893BC(v20, v21, v22, v23, v24, v25, v26, v27);
        if (qword_1000EBD40)
          v28 = (FILE *)qword_1000EBD40;
        else
          v28 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
      }
      *__error() = v18;
    }
    sub_1000301F0("startup_ports", "reading.m", 99, "%s: unable to allocate communication queue", v3, v4, v5, v6, (char)"communication_queue");
    abort();
  }
  mach_service = xpc_connection_create_mach_service("com.apple.spindump", v2, 1uLL);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_1000263CC;
  handler[3] = &unk_1000DD1A8;
  handler[4] = v2;
  xpc_connection_set_event_handler(mach_service, handler);
  xpc_connection_resume(mach_service);
  dispatch_release(v2);
  sub_10004EFF8();
}

_DWORD *sub_100024904(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  void *v15;
  _DWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _DWORD *v22;
  id v23;
  int v24;
  NSObject *v25;
  int v26;
  const __CFString *v27;
  const __CFString *v28;
  const char *v29;
  char *v30;
  char *v31;
  NSObject *v32;
  FILE *v33;
  FILE *v34;
  __int16 v35;
  __int16 *v36;
  int v37;
  NSObject *v38;
  unsigned int v39;
  int v40;
  const __CFString *v41;
  const __CFString *v42;
  const char *v43;
  char *v44;
  char *v45;
  NSObject *v46;
  FILE *v47;
  FILE *v48;
  int v49;
  NSObject *v50;
  int v51;
  const __CFString *v52;
  const __CFString *v53;
  const char *v54;
  char *v55;
  char *v56;
  NSObject *v57;
  FILE *v58;
  FILE *v59;
  __int16 v60;
  int v61;
  int v62;
  NSObject *v63;
  unsigned int v64;
  int v65;
  const __CFString *v66;
  const __CFString *v67;
  const char *v68;
  char *v69;
  char *v70;
  NSObject *v71;
  FILE *v72;
  FILE *v73;
  int v74;
  NSObject *v75;
  unsigned int v76;
  int v77;
  const __CFString *v78;
  const __CFString *v79;
  const char *v80;
  char *v81;
  char *v82;
  NSObject *v83;
  FILE *v84;
  FILE *v85;
  __int16 v86;
  __int16 v87;
  int v88;
  NSObject *v89;
  unsigned int v90;
  int v91;
  const __CFString *v92;
  const __CFString *v93;
  const char *v94;
  char *v95;
  char *v96;
  NSObject *v97;
  FILE *v98;
  FILE *v99;
  int v100;
  NSObject *v101;
  int v102;
  int v103;
  const __CFString *v104;
  const __CFString *v105;
  const char *v106;
  char *v107;
  char *v108;
  NSObject *v109;
  FILE *v110;
  FILE *v111;
  int v112;
  NSObject *v113;
  unsigned int v114;
  int v115;
  const __CFString *v116;
  const __CFString *v117;
  const char *v118;
  char *v119;
  char *v120;
  NSObject *v121;
  FILE *v122;
  FILE *v123;
  int v124;
  NSObject *v125;
  BOOL v126;
  int v127;
  const __CFString *v128;
  NSObject *v129;
  FILE *v130;
  int v131;
  NSObject *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  BOOL v140;
  int v141;
  const __CFString *v142;
  NSObject *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  FILE *v151;
  int v152;
  NSObject *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  BOOL v161;
  int v162;
  const __CFString *v163;
  NSObject *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  FILE *v172;
  const __CFString *v173;
  const char *CStringPtr;
  char *v175;
  char *v176;
  const __CFString *v177;
  const char *v178;
  char *v179;
  char *v180;
  FILE *v181;
  const __CFString *v182;
  const char *v183;
  char *v184;
  char *v185;
  FILE *v186;
  FILE *v187;
  uint8_t buf[4];
  int v189;
  __int16 v190;
  int v191;
  __int16 v192;
  int v193;
  __int16 v194;
  int v195;
  __int16 v196;
  int v197;

  if ((byte_1000EBD4C & 1) != 0)
  {
    if (byte_1000EBD38)
    {
      v124 = *__error();
      v125 = sub_100030318();
      if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
        sub_100088418();
      *__error() = v124;
    }
    if (byte_1000EBD39)
      v126 = dword_1000EB4E8 <= 3;
    else
      v126 = 0;
    if (v126)
    {
      v127 = *__error();
      v128 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Getting prefs for user %d as command-line"), "!global_preferences.command_line", a1);
      if (v128)
      {
        v173 = v128;
        CStringPtr = CFStringGetCStringPtr(v128, 0x8000100u);
        if (CStringPtr)
        {
          v175 = (char *)CStringPtr;
          v176 = 0;
        }
        else
        {
          v175 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5F9EAF6uLL);
          CFStringGetCString(v173, v175, 1024, 0x8000100u);
          v176 = v175;
        }
        if (qword_1000EBD40)
          v181 = (FILE *)qword_1000EBD40;
        else
          v181 = __stderrp;
        fprintf(v181, "%s\n", v175);
        if (v176)
          free(v176);
        CFRelease(v173);
      }
      else
      {
        v129 = sub_100030318();
        if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT))
          sub_1000883A0();
        if (qword_1000EBD40)
          v130 = (FILE *)qword_1000EBD40;
        else
          v130 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v130);
      }
      *__error() = v127;
    }
    sub_1000301F0("get_user_preferences", "preferences.m", 98, "%s: Getting prefs for user %d as command-line", a5, a6, a7, a8, (char)"!global_preferences.command_line");
LABEL_279:
    abort();
  }
  os_unfair_lock_lock((os_unfair_lock_t)&unk_1000EBBF8);
  v9 = (id)qword_1000EBC00;
  if (!qword_1000EBC00)
  {
    v9 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithCapacity:", 1);
    qword_1000EBC00 = (uint64_t)v9;
    if (!v9)
    {
      if (byte_1000EBD38)
      {
        v152 = *__error();
        v153 = sub_100030318();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
          sub_100087DC4(v153, v154, v155, v156, v157, v158, v159, v160);
        *__error() = v152;
      }
      if (byte_1000EBD39)
        v161 = dword_1000EB4E8 <= 3;
      else
        v161 = 0;
      if (v161)
      {
        v162 = *__error();
        v163 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: unable to allocate prefs dict"), "user_preferences_dict");
        if (v163)
        {
          v182 = v163;
          v183 = CFStringGetCStringPtr(v163, 0x8000100u);
          if (v183)
          {
            v184 = (char *)v183;
            v185 = 0;
          }
          else
          {
            v184 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x30812793uLL);
            CFStringGetCString(v182, v184, 1024, 0x8000100u);
            v185 = v184;
          }
          if (qword_1000EBD40)
            v187 = (FILE *)qword_1000EBD40;
          else
            v187 = __stderrp;
          fprintf(v187, "%s\n", v184);
          if (v185)
            free(v185);
          CFRelease(v182);
        }
        else
        {
          v164 = sub_100030318();
          if (os_log_type_enabled(v164, OS_LOG_TYPE_FAULT))
            sub_100087D54(v164, v165, v166, v167, v168, v169, v170, v171);
          if (qword_1000EBD40)
            v172 = (FILE *)qword_1000EBD40;
          else
            v172 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v172);
        }
        *__error() = v162;
      }
      sub_1000301F0("get_user_preferences", "preferences.m", 106, "%s: unable to allocate prefs dict", v10, v11, v12, v13, (char)"user_preferences_dict");
      goto LABEL_279;
    }
  }
  v14 = objc_msgSend(v9, "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1));
  if (v14)
  {
    v15 = v14;
    os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000EBBF8);
    return objc_msgSend(v15, "bytes");
  }
  v17 = malloc_type_calloc(1uLL, 0xCuLL, 0x1000040261CCB9FuLL);
  if (!v17)
  {
    if (byte_1000EBD38)
    {
      v131 = *__error();
      v132 = sub_100030318();
      if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
        sub_100087EA4(v132, v133, v134, v135, v136, v137, v138, v139);
      *__error() = v131;
    }
    if (byte_1000EBD39)
      v140 = dword_1000EB4E8 <= 3;
    else
      v140 = 0;
    if (v140)
    {
      v141 = *__error();
      v142 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: unable to allocate prefs"), "prefs_for_uid");
      if (v142)
      {
        v177 = v142;
        v178 = CFStringGetCStringPtr(v142, 0x8000100u);
        if (v178)
        {
          v179 = (char *)v178;
          v180 = 0;
        }
        else
        {
          v179 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x59946E74uLL);
          CFStringGetCString(v177, v179, 1024, 0x8000100u);
          v180 = v179;
        }
        if (qword_1000EBD40)
          v186 = (FILE *)qword_1000EBD40;
        else
          v186 = __stderrp;
        fprintf(v186, "%s\n", v179);
        if (v180)
          free(v180);
        CFRelease(v177);
      }
      else
      {
        v143 = sub_100030318();
        if (os_log_type_enabled(v143, OS_LOG_TYPE_FAULT))
          sub_100087E34(v143, v144, v145, v146, v147, v148, v149, v150);
        if (qword_1000EBD40)
          v151 = (FILE *)qword_1000EBD40;
        else
          v151 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
      }
      *__error() = v141;
    }
    sub_1000301F0("get_user_preferences", "preferences.m", 116, "%s: unable to allocate prefs", v18, v19, v20, v21, (char)"prefs_for_uid");
    goto LABEL_279;
  }
  v22 = v17;
  *v17 = a1;
  v23 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytesNoCopy:length:freeWhenDone:", v17, 12, 1);
  objc_msgSend((id)qword_1000EBC00, "setObject:forKeyedSubscript:", v23, +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", a1));
  if (byte_1000EBD38)
  {
    v24 = *__error();
    v25 = sub_100030318();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      sub_100088340();
    *__error() = v24;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
  {
    v26 = *__error();
    v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Initializing prefs for user %d"), a1);
    if (v27)
    {
      v28 = v27;
      v29 = CFStringGetCStringPtr(v27, 0x8000100u);
      if (v29)
      {
        v30 = (char *)v29;
        v31 = 0;
      }
      else
      {
        v30 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1696F1BDuLL);
        CFStringGetCString(v28, v30, 1024, 0x8000100u);
        v31 = v30;
      }
      if (qword_1000EBD40)
        v34 = (FILE *)qword_1000EBD40;
      else
        v34 = __stderrp;
      fprintf(v34, "%s\n", v30);
      if (v31)
        free(v31);
      CFRelease(v28);
    }
    else
    {
      v32 = sub_100030318();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
        sub_1000882E0();
      if (qword_1000EBD40)
        v33 = (FILE *)qword_1000EBD40;
      else
        v33 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
    }
    *__error() = v26;
  }
  v36 = (__int16 *)(v22 + 2);
  v35 = *((_WORD *)v22 + 4);
  v22[1] = -1;
  *((_WORD *)v22 + 4) = v35 & 0xFFC0 | 8;
  if (byte_1000EBD38)
  {
    v37 = *__error();
    v38 = sub_100030318();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
    {
      v39 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      v189 = a1;
      v190 = 1024;
      v191 = (v39 >> 5) & 1;
      v192 = 1024;
      v193 = (v39 >> 3) & 1;
      v194 = 1024;
      v195 = (v39 >> 2) & 1;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_INFO, "UID %d: Present UI:%d due to server mode:%d admin:%d", buf, 0x1Au);
    }
    *__error() = v37;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v40 = *__error();
    v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UID %d: Present UI:%d due to server mode:%d admin:%d"), a1, ((unsigned __int16)*v36 >> 5) & 1, ((unsigned __int16)*v36 >> 3) & 1, ((unsigned __int16)*v36 >> 2) & 1);
    if (v41)
    {
      v42 = v41;
      v43 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v43)
      {
        v44 = (char *)v43;
        v45 = 0;
      }
      else
      {
        v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x13FE1A5DuLL);
        CFStringGetCString(v42, v44, 1024, 0x8000100u);
        v45 = v44;
      }
      if (qword_1000EBD40)
        v48 = (FILE *)qword_1000EBD40;
      else
        v48 = __stderrp;
      fprintf(v48, "%s\n", v44);
      if (v45)
        free(v45);
      CFRelease(v42);
    }
    else
    {
      v46 = sub_100030318();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
        sub_100088270();
      if (qword_1000EBD40)
        v47 = (FILE *)qword_1000EBD40;
      else
        v47 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
    }
    *__error() = v40;
  }
  *v36 &= 0xFF3Fu;
  if (byte_1000EBD38)
  {
    v49 = *__error();
    v50 = sub_100030318();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
      sub_100088200();
    *__error() = v49;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
  {
    v51 = *__error();
    v52 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UID %d: User requested spins:%d hangs:%d unavilable on this platform"), a1, ((unsigned __int16)*v36 >> 6) & 1, ((unsigned __int16)*v36 >> 7) & 1);
    if (v52)
    {
      v53 = v52;
      v54 = CFStringGetCStringPtr(v52, 0x8000100u);
      if (v54)
      {
        v55 = (char *)v54;
        v56 = 0;
      }
      else
      {
        v55 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFD96B4FFuLL);
        CFStringGetCString(v53, v55, 1024, 0x8000100u);
        v56 = v55;
      }
      if (qword_1000EBD40)
        v59 = (FILE *)qword_1000EBD40;
      else
        v59 = __stderrp;
      fprintf(v59, "%s\n", v55);
      if (v56)
        free(v56);
      CFRelease(v53);
    }
    else
    {
      v57 = sub_100030318();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT))
        sub_100088198();
      if (qword_1000EBD40)
        v58 = (FILE *)qword_1000EBD40;
      else
        v58 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
    }
    *__error() = v51;
  }
  v60 = *v36;
  if ((*v36 & 0x20) != 0 || (v61 = v60 & 0x80 | word_1000EBD78 & 0x40) != 0)
    LOWORD(v61) = 256;
  *v36 = v61 | v60 & 0xFEFF;
  if (byte_1000EBD38)
  {
    v62 = *__error();
    v63 = sub_100030318();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_INFO))
    {
      v64 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67110144;
      v189 = a1;
      v190 = 1024;
      v191 = (v64 >> 8) & 1;
      v192 = 1024;
      v193 = (v64 >> 5) & 1;
      v194 = 1024;
      v195 = ((unsigned __int16)word_1000EBD78 >> 6) & 1;
      v196 = 1024;
      v197 = (v64 >> 7) & 1;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_INFO, "UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d", buf, 0x20u);
    }
    *__error() = v62;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v65 = *__error();
    v66 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d"), a1, HIBYTE(*v36) & 1, ((unsigned __int16)*v36 >> 5) & 1, ((unsigned __int16)word_1000EBD78 >> 6) & 1, ((unsigned __int16)*v36 >> 7) & 1);
    if (v66)
    {
      v67 = v66;
      v68 = CFStringGetCStringPtr(v66, 0x8000100u);
      if (v68)
      {
        v69 = (char *)v68;
        v70 = 0;
      }
      else
      {
        v69 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4C2359A4uLL);
        CFStringGetCString(v67, v69, 1024, 0x8000100u);
        v70 = v69;
      }
      if (qword_1000EBD40)
        v73 = (FILE *)qword_1000EBD40;
      else
        v73 = __stderrp;
      fprintf(v73, "%s\n", v69);
      if (v70)
        free(v70);
      CFRelease(v67);
    }
    else
    {
      v71 = sub_100030318();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
        sub_10008811C();
      if (qword_1000EBD40)
        v72 = (FILE *)qword_1000EBD40;
      else
        v72 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
    }
    *__error() = v65;
  }
  *v36 = *v36 & 0xFDFF | (((word_1000EBD78 & 0x20 | *v36 & 0x40) != 0) << 9);
  if (byte_1000EBD38)
  {
    v74 = *__error();
    v75 = sub_100030318();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_INFO))
    {
      v76 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      v189 = a1;
      v190 = 1024;
      v191 = (v76 >> 9) & 1;
      v192 = 1024;
      v193 = ((unsigned __int16)word_1000EBD78 >> 5) & 1;
      v194 = 1024;
      v195 = (v76 >> 6) & 1;
      _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_INFO, "UID %d: Gather samples for spins:%d due to submit:%d user requested:%d", buf, 0x1Au);
    }
    *__error() = v74;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v77 = *__error();
    v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UID %d: Gather samples for spins:%d due to submit:%d user requested:%d"), a1, ((unsigned __int16)*v36 >> 9) & 1, ((unsigned __int16)word_1000EBD78 >> 5) & 1, ((unsigned __int16)*v36 >> 6) & 1);
    if (v78)
    {
      v79 = v78;
      v80 = CFStringGetCStringPtr(v78, 0x8000100u);
      if (v80)
      {
        v81 = (char *)v80;
        v82 = 0;
      }
      else
      {
        v81 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6CBB54A9uLL);
        CFStringGetCString(v79, v81, 1024, 0x8000100u);
        v82 = v81;
      }
      if (qword_1000EBD40)
        v85 = (FILE *)qword_1000EBD40;
      else
        v85 = __stderrp;
      fprintf(v85, "%s\n", v81);
      if (v82)
        free(v82);
      CFRelease(v79);
    }
    else
    {
      v83 = sub_100030318();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT))
        sub_100088090();
      if (qword_1000EBD40)
        v84 = (FILE *)qword_1000EBD40;
      else
        v84 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
    }
    *__error() = v77;
  }
  if ((word_1000EBD78 & 1) != 0)
  {
    v87 = *v36;
    v86 = ((word_1000EBD78 & 0x20 | *v36 & 0x40) != 0) << 10;
  }
  else
  {
    v86 = 0;
    v87 = *v36;
  }
  *v36 = v87 & 0xFBFF | v86;
  if (byte_1000EBD38)
  {
    v88 = *__error();
    v89 = sub_100030318();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_INFO))
    {
      v90 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67110144;
      v189 = a1;
      v190 = 1024;
      v191 = (v90 >> 10) & 1;
      v192 = 1024;
      v193 = word_1000EBD78 & 1;
      v194 = 1024;
      v195 = ((unsigned __int16)word_1000EBD78 >> 5) & 1;
      v196 = 1024;
      v197 = (v90 >> 6) & 1;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_INFO, "UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d", buf, 0x20u);
    }
    *__error() = v88;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v91 = *__error();
    v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d"), a1, ((unsigned __int16)*v36 >> 10) & 1, word_1000EBD78 & 1, ((unsigned __int16)word_1000EBD78 >> 5) & 1, ((unsigned __int16)*v36 >> 6) & 1);
    if (v92)
    {
      v93 = v92;
      v94 = CFStringGetCStringPtr(v92, 0x8000100u);
      if (v94)
      {
        v95 = (char *)v94;
        v96 = 0;
      }
      else
      {
        v95 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB8DDEB4AuLL);
        CFStringGetCString(v93, v95, 1024, 0x8000100u);
        v96 = v95;
      }
      if (qword_1000EBD40)
        v99 = (FILE *)qword_1000EBD40;
      else
        v99 = __stderrp;
      fprintf(v99, "%s\n", v95);
      if (v96)
        free(v96);
      CFRelease(v93);
    }
    else
    {
      v97 = sub_100030318();
      if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
        sub_100088014();
      if (qword_1000EBD40)
        v98 = (FILE *)qword_1000EBD40;
      else
        v98 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
    }
    *__error() = v91;
  }
  *v36 = *v36 & 0xF7FF | ((unsigned __int16)word_1000EBD78 >> 1) & 0x800;
  if (byte_1000EBD38)
  {
    v100 = *__error();
    v101 = sub_100030318();
    if (os_log_type_enabled(v101, OS_LOG_TYPE_INFO))
    {
      v102 = ((unsigned __int16)*v36 >> 11) & 1;
      *(_DWORD *)buf = 67109632;
      v189 = a1;
      v190 = 1024;
      v191 = v102;
      v192 = 1024;
      v193 = ((unsigned __int16)word_1000EBD78 >> 12) & 1;
      _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_INFO, "UID %d: Gather samples for service watchdog:%d due to submit:%d", buf, 0x14u);
    }
    *__error() = v100;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v103 = *__error();
    v104 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UID %d: Gather samples for service watchdog:%d due to submit:%d"), a1, ((unsigned __int16)*v36 >> 11) & 1, ((unsigned __int16)word_1000EBD78 >> 12) & 1);
    if (v104)
    {
      v105 = v104;
      v106 = CFStringGetCStringPtr(v104, 0x8000100u);
      if (v106)
      {
        v107 = (char *)v106;
        v108 = 0;
      }
      else
      {
        v107 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x500B269uLL);
        CFStringGetCString(v105, v107, 1024, 0x8000100u);
        v108 = v107;
      }
      if (qword_1000EBD40)
        v111 = (FILE *)qword_1000EBD40;
      else
        v111 = __stderrp;
      fprintf(v111, "%s\n", v107);
      if (v108)
        free(v108);
      CFRelease(v105);
    }
    else
    {
      v109 = sub_100030318();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT))
        sub_100087F84();
      if (qword_1000EBD40)
        v110 = (FILE *)qword_1000EBD40;
      else
        v110 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v110);
    }
    *__error() = v103;
  }
  *v36 = (*v36 << 12) & (*v36 << 11) & 0x1000 | *v36 & 0xEFFF;
  if (byte_1000EBD38)
  {
    v112 = *__error();
    v113 = sub_100030318();
    if (os_log_type_enabled(v113, OS_LOG_TYPE_INFO))
    {
      v114 = (unsigned __int16)*v36;
      *(_DWORD *)buf = 67109888;
      v189 = a1;
      v190 = 1024;
      v191 = (v114 >> 12) & 1;
      v192 = 1024;
      v193 = v114 & 1;
      v194 = 1024;
      v195 = (v114 >> 1) & 1;
      _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_INFO, "UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d", buf, 0x1Au);
    }
    *__error() = v112;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
  {
    v115 = *__error();
    v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d"), a1, ((unsigned __int16)*v36 >> 12) & 1, *v36 & 1, ((unsigned __int16)*v36 >> 1) & 1);
    if (v116)
    {
      v117 = v116;
      v118 = CFStringGetCStringPtr(v116, 0x8000100u);
      if (v118)
      {
        v119 = (char *)v118;
        v120 = 0;
      }
      else
      {
        v119 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDB399A88uLL);
        CFStringGetCString(v117, v119, 1024, 0x8000100u);
        v120 = v119;
      }
      if (qword_1000EBD40)
        v123 = (FILE *)qword_1000EBD40;
      else
        v123 = __stderrp;
      fprintf(v123, "%s\n", v119);
      if (v120)
        free(v120);
      CFRelease(v117);
    }
    else
    {
      v121 = sub_100030318();
      if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
        sub_100087F14();
      if (qword_1000EBD40)
        v122 = (FILE *)qword_1000EBD40;
      else
        v122 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
    }
    *__error() = v115;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_1000EBBF8);
  return v22;
}

BOOL sub_100025F88(pid_t a1)
{
  return !a1 || kill(a1, 0) == 0;
}

uint64_t sub_100025FB4()
{
  int v1;
  NSObject *v2;
  int v3;
  uint64_t v4;
  int *v5;
  char *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  FILE *v12;
  FILE *v13;
  const __CFString *theString;
  size_t v15;
  int v16;

  if (qword_1000EBC88 != -1)
    dispatch_once(&qword_1000EBC88, &stru_1000DD7A0);
  if (qword_1000EB4F8)
  {
    v16 = 0;
    v15 = 4;
    if (sysctl(dword_1000EBC74, qword_1000EB4F8, &v16, &v15, 0, 0))
    {
      v1 = *__error();
      v2 = sub_100030318();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
        sub_10009175C();
      *__error() = v1;
      if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
      {
        v3 = *__error();
        v4 = *__error();
        v5 = __error();
        v6 = strerror(*v5);
        v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("sysctl for security.mac.sandbox.audio_active failed: %d (%s)"), v4, v6);
        if (v7)
        {
          theString = v7;
          CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
          if (CStringPtr)
          {
            v9 = (char *)CStringPtr;
            v10 = 0;
          }
          else
          {
            v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x92D6838EuLL);
            CFStringGetCString(theString, v9, 1024, 0x8000100u);
            v10 = v9;
          }
          if (qword_1000EBD40)
            v13 = (FILE *)qword_1000EBD40;
          else
            v13 = __stderrp;
          fprintf(v13, "%s\n", v9);
          if (v10)
            free(v10);
          CFRelease(theString);
        }
        else
        {
          v11 = sub_100030318();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
            sub_1000916EC();
          if (qword_1000EBD40)
            v12 = (FILE *)qword_1000EBD40;
          else
            v12 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
        }
        *__error() = v3;
      }
      qword_1000EB4F8 = 0;
    }
    else if (v16)
    {
      return 1;
    }
  }
  return 0;
}

void sub_1000261E8(id a1)
{
  int v1;
  NSObject *v2;
  BOOL v3;
  uint64_t v4;
  int *v5;
  char *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  FILE *v12;
  FILE *v13;
  const __CFString *theString;
  int v15;

  if (sysctlnametomib("security.mac.sandbox.audio_active", dword_1000EBC74, (size_t *)&qword_1000EB4F8))
  {
    v1 = *__error();
    v2 = sub_100030318();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      sub_100091924();
    *__error() = v1;
    if (byte_1000EBD39)
      v3 = dword_1000EB4E8 <= 4;
    else
      v3 = 0;
    if (v3)
    {
      v15 = *__error();
      v4 = *__error();
      v5 = __error();
      v6 = strerror(*v5);
      v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)"), v4, v6);
      if (v7)
      {
        theString = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          v9 = (char *)CStringPtr;
          v10 = 0;
        }
        else
        {
          v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF32869A9uLL);
          CFStringGetCString(theString, v9, 1024, 0x8000100u);
          v10 = v9;
        }
        if (qword_1000EBD40)
          v13 = (FILE *)qword_1000EBD40;
        else
          v13 = __stderrp;
        fprintf(v13, "%s\n", v9);
        if (v10)
          free(v10);
        CFRelease(theString);
      }
      else
      {
        v11 = sub_100030318();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
          sub_1000918B4();
        if (qword_1000EBD40)
          v12 = (FILE *)qword_1000EBD40;
        else
          v12 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
      }
      *__error() = v15;
    }
    qword_1000EB4F8 = 0;
  }
}

void sub_1000263CC(uint64_t a1, xpc_object_t object)
{
  pid_t pid;
  uid_t euid;
  void *v6;
  void *v7;
  BOOL v8;
  int v9;
  NSObject *v10;
  BOOL v11;
  int v12;
  const char *string;
  const __CFString *v14;
  const __CFString *v15;
  const char *CStringPtr;
  char *v17;
  char *v18;
  NSObject *v19;
  FILE *v20;
  FILE *v21;
  _QWORD handler[4];
  pid_t v23;
  uid_t v24;
  BOOL v25;
  __int16 v26;
  char v27;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
  {
    if (byte_1000EBD38)
    {
      v9 = *__error();
      v10 = sub_100030318();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        sub_100089510(object);
      *__error() = v9;
    }
    if (byte_1000EBD39)
      v11 = dword_1000EB4E8 <= 0;
    else
      v11 = 0;
    if (v11)
    {
      v12 = *__error();
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Got xpc error for peer: %s"), string);
      if (v14)
      {
        v15 = v14;
        CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
        if (CStringPtr)
        {
          v17 = (char *)CStringPtr;
          v18 = 0;
        }
        else
        {
          v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB3D357ACuLL);
          CFStringGetCString(v15, v17, 1024, 0x8000100u);
          v18 = v17;
        }
        if (qword_1000EBD40)
          v21 = (FILE *)qword_1000EBD40;
        else
          v21 = __stderrp;
        fprintf(v21, "%s\n", v17);
        if (v18)
          free(v18);
        CFRelease(v15);
      }
      else
      {
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          sub_10008949C(object, _xpc_error_key_description, v19);
        if (qword_1000EBD40)
          v20 = (FILE *)qword_1000EBD40;
        else
          v20 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }
      *__error() = v12;
    }
  }
  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_connection)
  {
    pid = xpc_connection_get_pid((xpc_connection_t)object);
    euid = xpc_connection_get_euid((xpc_connection_t)object);
    v6 = (void *)xpc_connection_copy_entitlement_value(object, "com.apple.private.spindump.generatespindump");
    if (v6)
    {
      v7 = v6;
      v8 = xpc_get_type(v6) == (xpc_type_t)&_xpc_type_BOOL && xpc_BOOL_get_value(v7);
      xpc_release(v7);
    }
    else
    {
      v8 = 0;
    }
    xpc_connection_set_target_queue((xpc_connection_t)object, *(dispatch_queue_t *)(a1 + 32));
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_100049C50;
    handler[3] = &unk_1000DD180;
    v23 = pid;
    v24 = euid;
    v25 = v8;
    v26 = 0;
    v27 = 0;
    xpc_connection_set_event_handler((xpc_connection_t)object, handler);
    xpc_connection_resume((xpc_connection_t)object);
  }
}

size_t sub_1000266AC(char *a1, size_t a2, int a3, long double a4)
{
  size_t result;
  size_t v9;
  char *v10;
  size_t v11;
  double v12;
  size_t v13;
  BOOL v14;
  size_t v15;
  time_t v16;
  tm v17;
  char __str;
  char v19[15];

  result = 0;
  if (a1 && a2)
  {
    memset(&v17, 0, sizeof(v17));
    v16 = (uint64_t)(kCFAbsoluteTimeIntervalSince1970 + a4);
    localtime_r(&v16, &v17);
    result = strftime(a1, a2, "%Y-%m-%d %T", &v17);
    if (result)
    {
      v9 = result;
      v10 = &a1[result];
      v11 = a2 - result;
      if (a3)
      {
        v12 = fmod(a4, 1.0);
        if (v12 > 0.0)
        {
          snprintf(&__str, 0x10uLL, "%f", v12);
          v13 = strlcpy(v10, v19, v11);
          v14 = v11 > v13;
          v11 -= v13;
          if (!v14)
            return a2 - 1;
          v9 += v13;
          v10 += v13;
        }
      }
      v15 = strftime(v10, v11, " %z", &v17);
      if (!v15)
        v10[v9] = 0;
      return v15 + v9;
    }
    else
    {
      *a1 = 0;
    }
  }
  return result;
}

const char *sub_100026810(unsigned int a1, int a2)
{
  const char *v2;
  char **v3;

  v2 = "hang";
  if (a2)
    v2 = "hang-lite";
  if (a1 <= 0xE)
  {
    v3 = &off_1000DD378;
    if (a2)
      v3 = &off_1000DD300;
    return v3[a1];
  }
  return v2;
}

void sub_100026854(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  int v20;
  NSObject *v21;
  BOOL v22;
  int v23;
  _DWORD *v24;
  const __CFString *v25;
  const __CFString *v26;
  const char *CStringPtr;
  char *v28;
  char *v29;
  int v30;
  NSObject *v31;
  BOOL v32;
  const __CFString *v33;
  const char *v34;
  char *v35;
  char *v36;
  NSObject *v37;
  FILE *v38;
  FILE *v39;
  NSObject *v40;
  FILE *v41;
  uint64_t v42;
  int v43;
  NSObject *v44;
  int v45;
  _DWORD *v46;
  const __CFString *v47;
  NSObject *v48;
  int v49;
  NSObject *v50;
  const __CFString *v51;
  uint64_t v52;
  const char *v53;
  char *v54;
  char *v55;
  FILE *v56;
  NSObject *v57;
  FILE *v58;
  int v59;
  NSObject *v60;
  int v61;
  _DWORD *v62;
  const __CFString *v63;
  NSObject *v64;
  uint64_t v65;
  uint64_t v66;
  NSObject *global_queue;
  uint64_t v68;
  int v69;
  NSObject *v70;
  _DWORD *v71;
  int v72;
  _DWORD *v73;
  const __CFString *v74;
  NSObject *v75;
  int v76;
  NSObject *v77;
  const __CFString *v78;
  const char *v79;
  char *v80;
  char *v81;
  uint64_t v82;
  int v83;
  NSObject *v84;
  int v85;
  _DWORD *v86;
  const __CFString *v87;
  NSObject *v88;
  FILE *v89;
  uint64_t v90;
  int v91;
  NSObject *v92;
  const __CFString *v93;
  id v94;
  uint64_t v95;
  const char *v96;
  char *v97;
  char *v98;
  uint64_t v99;
  int v100;
  NSObject *v101;
  const __CFString *v102;
  id v103;
  uint64_t v104;
  const char *v105;
  char *v106;
  char *v107;
  NSObject *v108;
  FILE *v109;
  int v110;
  NSObject *v111;
  _DWORD *v112;
  int v113;
  _DWORD *v114;
  const __CFString *v115;
  NSObject *v116;
  int v117;
  NSObject *v118;
  const __CFString *v119;
  const char *v120;
  char *v121;
  char *v122;
  FILE *v123;
  NSObject *v124;
  FILE *v125;
  uint64_t v126;
  double v127;
  char v128;
  int v129;
  void *v130;
  uint64_t v131;
  uint64_t v132;
  FILE *v133;
  FILE *v134;
  _DWORD *v135;
  NSObject *v136;
  FILE *v137;
  NSObject *v138;
  FILE *v139;
  uint64_t v140;
  id v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  _QWORD block[16];
  int v146;
  uint64_t v147;
  uint8_t buf[4];
  _DWORD *v149;
  __int16 v150;
  _BYTE v151[34];
  __int16 v152;
  uint64_t v153;

  if ((a1 & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v20 = *__error();
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447490;
        v149 = sub_1000302B4(a1);
        v150 = 1024;
        *(_DWORD *)v151 = a1;
        *(_WORD *)&v151[4] = 2048;
        *(_QWORD *)&v151[6] = a3;
        *(_WORD *)&v151[14] = 2048;
        *(double *)&v151[16] = a6;
        *(_WORD *)&v151[24] = 2048;
        *(double *)&v151[26] = a7;
        v152 = 2048;
        v153 = a4;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "%{public}s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x3Au);
      }
      *__error() = v20;
    }
    if (byte_1000EBD39)
      v22 = dword_1000EB4E8 <= 1;
    else
      v22 = 0;
    if (!v22)
      goto LABEL_52;
    v23 = *__error();
    v24 = sub_1000302B4(a1);
    v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx"), v24, a1, a3, *(_QWORD *)&a6, *(_QWORD *)&a7, a4);
    if (v25)
    {
      v26 = v25;
      CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
      if (CStringPtr)
      {
        v28 = (char *)CStringPtr;
        v29 = 0;
      }
      else
      {
        v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x106C1392uLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        v29 = v28;
      }
      if (qword_1000EBD40)
        v39 = (FILE *)qword_1000EBD40;
      else
        v39 = __stderrp;
      fprintf(v39, "%s\n", v28);
      if (v29)
        free(v29);
LABEL_50:
      CFRelease(v26);
      goto LABEL_51;
    }
    v37 = sub_100030318();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      v135 = sub_1000302B4(a1);
      *(_DWORD *)buf = 136316418;
      v149 = v135;
      v150 = 1024;
      *(_DWORD *)v151 = a1;
      *(_WORD *)&v151[4] = 2048;
      *(_QWORD *)&v151[6] = a3;
      *(_WORD *)&v151[14] = 2048;
      *(double *)&v151[16] = a6;
      *(_WORD *)&v151[24] = 2048;
      *(double *)&v151[26] = a7;
      v152 = 2048;
      v153 = a4;
      _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x3Au);
    }
    if (qword_1000EBD40)
      v38 = (FILE *)qword_1000EBD40;
    else
      v38 = __stderrp;
    goto LABEL_31;
  }
  if (byte_1000EBD38)
  {
    v30 = *__error();
    v31 = sub_100030318();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134218752;
      v149 = (_DWORD *)a3;
      v150 = 2048;
      *(double *)v151 = a6;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = a7;
      *(_WORD *)&v151[18] = 2048;
      *(_QWORD *)&v151[20] = a4;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x2Au);
    }
    *__error() = v30;
  }
  if (byte_1000EBD39)
    v32 = dword_1000EB4E8 <= 1;
  else
    v32 = 0;
  if (v32)
  {
    v23 = *__error();
    v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx"), a3, *(_QWORD *)&a6, *(_QWORD *)&a7, a4);
    if (v33)
    {
      v26 = v33;
      v34 = CFStringGetCStringPtr(v33, 0x8000100u);
      if (v34)
      {
        v35 = (char *)v34;
        v36 = 0;
      }
      else
      {
        v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x106C1392uLL);
        CFStringGetCString(v26, v35, 1024, 0x8000100u);
        v36 = v35;
      }
      if (qword_1000EBD40)
        v41 = (FILE *)qword_1000EBD40;
      else
        v41 = __stderrp;
      fprintf(v41, "%s\n", v35);
      if (v36)
        free(v36);
      goto LABEL_50;
    }
    v40 = sub_100030318();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218752;
      v149 = (_DWORD *)a3;
      v150 = 2048;
      *(double *)v151 = a6;
      *(_WORD *)&v151[8] = 2048;
      *(double *)&v151[10] = a7;
      *(_WORD *)&v151[18] = 2048;
      *(_QWORD *)&v151[20] = a4;
      _os_log_fault_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "Unable to format: cpu resource: thread %#llx using %.0fs cpu over the last %.0f seconds with flags %#llx", buf, 0x2Au);
    }
    if (qword_1000EBD40)
      v38 = (FILE *)qword_1000EBD40;
    else
      v38 = __stderrp;
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
LABEL_51:
    *__error() = v23;
  }
LABEL_52:
  v144 = sub_10003038C(a1);
  if (!a2)
    a2 = sub_1000303D0(a1);
  v147 = 0;
  v42 = sub_100042198(a1, (uint64_t)"cpu resource", 160, &v147);
  if ((word_1000EBD78 & 0x80) == 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v49 = *__error();
        v50 = sub_100030318();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
          sub_100085FC0();
        *__error() = v49;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_88;
      v45 = *__error();
      v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: not monitoring due to suppression cookie file"));
      if (!v47)
      {
        v57 = sub_100030318();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT))
          sub_100085F94();
        goto LABEL_83;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v43 = *__error();
        v44 = sub_100030318();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          sub_100085F2C();
        *__error() = v43;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_88;
      v45 = *__error();
      v46 = sub_1000302B4(a1);
      v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: not monitoring due to suppression cookie file"), v46, a1);
      if (!v47)
      {
        v48 = sub_100030318();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
          sub_100085EC4();
LABEL_83:
        if (qword_1000EBD40)
          v58 = (FILE *)qword_1000EBD40;
        else
          v58 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
LABEL_87:
        *__error() = v45;
LABEL_88:
        v42 |= 0x8000uLL;
        goto LABEL_89;
      }
    }
    v51 = v47;
    v140 = a5;
    v141 = a2;
    v52 = a4;
    v53 = CFStringGetCStringPtr(v47, 0x8000100u);
    if (v53)
    {
      v54 = (char *)v53;
      v55 = 0;
    }
    else
    {
      v54 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9E1CCB7FuLL);
      CFStringGetCString(v51, v54, 1024, 0x8000100u);
      v55 = v54;
    }
    if (qword_1000EBD40)
      v56 = (FILE *)qword_1000EBD40;
    else
      v56 = __stderrp;
    fprintf(v56, "%s\n", v54);
    if (v55)
      free(v55);
    CFRelease(v51);
    a4 = v52;
    a5 = v140;
    a2 = v141;
    goto LABEL_87;
  }
LABEL_89:
  if ((sub_10004C768((const char *)objc_msgSend(a2, "UTF8String"), 1) & 1) != 0
    || !sub_100042A24(*(double *)&qword_1000EBD70))
  {
    if (v42)
      goto LABEL_167;
    v65 = v147;
    if ((v147 & 0x80000000000) == 0)
    {
LABEL_103:
      v66 = sub_100030160("CPU resource for [%d] thread %#llx", a1, a3);
      global_queue = dispatch_get_global_queue(9, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100042D54;
      block[3] = &unk_1000DCFB8;
      v146 = a1;
      block[7] = a3;
      block[8] = a4;
      block[4] = a2;
      block[5] = a5;
      *(double *)&block[9] = a6;
      *(double *)&block[10] = a7;
      *(double *)&block[11] = a8;
      *(double *)&block[12] = a9;
      *(double *)&block[13] = a10;
      block[14] = v144;
      block[15] = v65;
      block[6] = v66;
      dispatch_async(global_queue, block);
      return;
    }
    if (sub_10004EFD4())
    {
      if ((a1 & 0x80000000) != 0)
      {
        if (byte_1000EBD38)
        {
          v90 = a3;
          v91 = *__error();
          v92 = sub_100030318();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "cpu resource: deferring report generation due to game mode", buf, 2u);
          }
          *__error() = v91;
          a3 = v90;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
          goto LABEL_223;
        v142 = a3;
        v72 = *__error();
        v74 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: deferring report generation due to game mode"));
        if (!v74)
        {
          v136 = sub_100030318();
          if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
            sub_100085B7C();
          goto LABEL_218;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v68 = a3;
          v69 = *__error();
          v70 = sub_100030318();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
          {
            v71 = sub_1000302B4(a1);
            *(_DWORD *)buf = 136446466;
            v149 = v71;
            v150 = 1024;
            *(_DWORD *)v151 = a1;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: cpu resource: deferring report generation due to game mode", buf, 0x12u);
          }
          *__error() = v69;
          a3 = v68;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
          goto LABEL_223;
        v142 = a3;
        v72 = *__error();
        v73 = sub_1000302B4(a1);
        v74 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: deferring report generation due to game mode"), v73, a1);
        if (!v74)
        {
          v75 = sub_100030318();
          if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT))
            sub_100085B14();
LABEL_218:
          if (qword_1000EBD40)
            v137 = (FILE *)qword_1000EBD40;
          else
            v137 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v137);
LABEL_222:
          *__error() = v72;
          a3 = v142;
LABEL_223:
          sub_10004F7A0(a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9, a10);
          v126 = v65 | 0x100000000000;
          v127 = a8 - a7;
          v128 = a4 & 1;
          v129 = a1;
          v130 = a2;
          v131 = v144;
          v132 = 0;
          goto LABEL_201;
        }
      }
      v93 = v74;
      v94 = a2;
      v95 = a5;
      v96 = CFStringGetCStringPtr(v74, 0x8000100u);
      if (v96)
      {
        v97 = (char *)v96;
        v98 = 0;
      }
      else
      {
        v97 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3D2B23ABuLL);
        CFStringGetCString(v93, v97, 1024, 0x8000100u);
        v98 = v97;
      }
      if (qword_1000EBD40)
        v133 = (FILE *)qword_1000EBD40;
      else
        v133 = __stderrp;
      fprintf(v133, "%s\n", v97);
      if (v98)
        free(v98);
      CFRelease(v93);
      a5 = v95;
      a2 = v94;
      goto LABEL_222;
    }
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v99 = a3;
        v100 = *__error();
        v101 = sub_100030318();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
          sub_100085CA4();
        *__error() = v100;
        a3 = v99;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_103;
      v143 = a3;
      v85 = *__error();
      v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: cannot defer report generation for game mode"));
      if (!v87)
      {
        v138 = sub_100030318();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT))
          sub_100085C78();
        goto LABEL_226;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v82 = a3;
        v83 = *__error();
        v84 = sub_100030318();
        if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
          sub_100085C10();
        *__error() = v83;
        a3 = v82;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_103;
      v143 = a3;
      v85 = *__error();
      v86 = sub_1000302B4(a1);
      v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: cannot defer report generation for game mode"), v86, a1);
      if (!v87)
      {
        v88 = sub_100030318();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT))
          sub_100085BA8();
LABEL_226:
        if (qword_1000EBD40)
          v139 = (FILE *)qword_1000EBD40;
        else
          v139 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v139);
LABEL_230:
        *__error() = v85;
        a3 = v143;
        goto LABEL_103;
      }
    }
    v102 = v87;
    v103 = a2;
    v104 = a5;
    v105 = CFStringGetCStringPtr(v87, 0x8000100u);
    if (v105)
    {
      v106 = (char *)v105;
      v107 = 0;
    }
    else
    {
      v106 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x62FF9B49uLL);
      CFStringGetCString(v102, v106, 1024, 0x8000100u);
      v107 = v106;
    }
    if (qword_1000EBD40)
      v134 = (FILE *)qword_1000EBD40;
    else
      v134 = __stderrp;
    fprintf(v134, "%s\n", v106);
    if (v107)
      free(v107);
    CFRelease(v102);
    a5 = v104;
    a2 = v103;
    goto LABEL_230;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v76 = *__error();
      v77 = sub_100030318();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
        sub_100085E98();
      *__error() = v76;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
      goto LABEL_166;
    v61 = *__error();
    v63 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes"));
    if (!v63)
    {
      v108 = sub_100030318();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_FAULT))
        sub_100085E6C();
      goto LABEL_161;
    }
LABEL_122:
    v78 = v63;
    v79 = CFStringGetCStringPtr(v63, 0x8000100u);
    if (v79)
    {
      v80 = (char *)v79;
      v81 = 0;
    }
    else
    {
      v80 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA0003A0uLL);
      CFStringGetCString(v78, v80, 1024, 0x8000100u);
      v81 = v80;
    }
    if (qword_1000EBD40)
      v89 = (FILE *)qword_1000EBD40;
    else
      v89 = __stderrp;
    fprintf(v89, "%s\n", v80);
    if (v81)
      free(v81);
    CFRelease(v78);
    goto LABEL_165;
  }
  if (byte_1000EBD38)
  {
    v59 = *__error();
    v60 = sub_100030318();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
      sub_100085E04();
    *__error() = v59;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
    goto LABEL_166;
  v61 = *__error();
  v62 = sub_1000302B4(a1);
  v63 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes"), v62, a1);
  if (v63)
    goto LABEL_122;
  v64 = sub_100030318();
  if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
    sub_100085D9C();
LABEL_161:
  if (qword_1000EBD40)
    v109 = (FILE *)qword_1000EBD40;
  else
    v109 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v109);
LABEL_165:
  *__error() = v61;
LABEL_166:
  v42 |= 0x200000uLL;
LABEL_167:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v117 = *__error();
      v118 = sub_100030318();
      if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v149 = (_DWORD *)v42;
        _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "cpu resource: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v117;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
      goto LABEL_200;
    v113 = *__error();
    v115 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: not monitoring due to conditions %#llx"), v42);
    if (!v115)
    {
      v124 = sub_100030318();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT))
        sub_100085D3C();
      goto LABEL_195;
    }
LABEL_184:
    v119 = v115;
    v120 = CFStringGetCStringPtr(v115, 0x8000100u);
    if (v120)
    {
      v121 = (char *)v120;
      v122 = 0;
    }
    else
    {
      v121 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9B6BF6C9uLL);
      CFStringGetCString(v119, v121, 1024, 0x8000100u);
      v122 = v121;
    }
    if (qword_1000EBD40)
      v123 = (FILE *)qword_1000EBD40;
    else
      v123 = __stderrp;
    fprintf(v123, "%s\n", v121);
    if (v122)
      free(v122);
    CFRelease(v119);
    goto LABEL_199;
  }
  if (byte_1000EBD38)
  {
    v110 = *__error();
    v111 = sub_100030318();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      v112 = sub_1000302B4(a1);
      *(_DWORD *)buf = 136446722;
      v149 = v112;
      v150 = 1024;
      *(_DWORD *)v151 = a1;
      *(_WORD *)&v151[4] = 2048;
      *(_QWORD *)&v151[6] = v42;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: cpu resource: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v110;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
    goto LABEL_200;
  v113 = *__error();
  v114 = sub_1000302B4(a1);
  v115 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: not monitoring due to conditions %#llx"), v114, a1, v42);
  if (v115)
    goto LABEL_184;
  v116 = sub_100030318();
  if (os_log_type_enabled(v116, OS_LOG_TYPE_FAULT))
    sub_100085CD0();
LABEL_195:
  if (qword_1000EBD40)
    v125 = (FILE *)qword_1000EBD40;
  else
    v125 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
LABEL_199:
  *__error() = v113;
LABEL_200:
  v126 = v147;
  v127 = a8 - a7;
  v128 = a4 & 1;
  v129 = a1;
  v130 = a2;
  v131 = v144;
  v132 = v42;
LABEL_201:
  sub_100030CDC(v129, v130, v131, v132, v126, v128, v127, a8, a6);
}

uint64_t sub_100027B80(char *a1, off_t a2, uint64_t a3, _BYTE *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14, double a15, unsigned int a16, unsigned __int8 a17, uint64_t a18, uint64_t a19, char a20,int a21,unsigned int a22,char a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,unsigned int a29,unsigned int a30,void *a31,uint64_t a32)
{
  unsigned int v33;
  id v46;
  id v47;
  id v48;
  uint64_t v49;
  int v50;
  int v51;
  id v52;
  id v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  id v57;
  int v58;
  NSObject *v59;
  int v60;
  _DWORD *v61;
  const __CFString *v62;
  NSObject *v63;
  int v64;
  NSObject *v65;
  const __CFString *v66;
  const char *v67;
  char *v68;
  char *v69;
  _BOOL4 v71;
  id v72;
  id v73;
  uint64_t v74;
  void *i;
  id v76;
  void *v77;
  id v78;
  void *v79;
  double v80;
  double v81;
  double v82;
  double v83;
  double v84;
  FILE *v85;
  double v86;
  double v87;
  double v88;
  int v89;
  NSObject *v90;
  int v91;
  const __CFString *v92;
  const __CFString *v93;
  const char *v94;
  malloc_type_id_t v95;
  NSObject *v96;
  FILE *v97;
  double v99;
  double v100;
  double v101;
  SATimestamp *v102;
  id v103;
  id v104;
  _UNKNOWN **v105;
  id v106;
  unsigned int v107;
  const __CFString *v108;
  uint64_t v109;
  int v110;
  NSObject *v111;
  _DWORD *v112;
  id v113;
  int v114;
  _DWORD *v115;
  const __CFString *v116;
  NSObject *v117;
  FILE *v118;
  int v119;
  NSObject *v120;
  _DWORD *v121;
  id v122;
  int v123;
  _DWORD *v124;
  const __CFString *v125;
  NSObject *v126;
  FILE *v127;
  int v128;
  NSObject *v129;
  int v130;
  _DWORD *v131;
  const __CFString *v132;
  NSObject *v133;
  int v134;
  NSObject *v135;
  _DWORD *v136;
  const __CFString *v137;
  NSObject *v138;
  int v139;
  NSObject *v140;
  const __CFString *v141;
  const char *v142;
  char *v143;
  char *v144;
  int v145;
  NSObject *v146;
  const __CFString *v147;
  char *v148;
  char *v149;
  int v150;
  NSObject *v151;
  _DWORD *v152;
  const __CFString *v153;
  NSObject *v154;
  int v155;
  NSObject *v156;
  const __CFString *v157;
  const char *v158;
  malloc_type_id_t v159;
  int v160;
  NSObject *v161;
  NSObject *v162;
  int v163;
  NSObject *v164;
  const __CFString *v165;
  const char *v166;
  char *v167;
  char *v168;
  FILE *v169;
  void *v170;
  uint64_t v171;
  int v172;
  NSObject *v173;
  char *v174;
  char *v175;
  NSObject *v176;
  FILE *v177;
  NSObject *v178;
  FILE *v179;
  FILE *v180;
  NSObject *v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  NSObject *v188;
  FILE *v189;
  NSObject *v190;
  FILE *v191;
  FILE *v192;
  NSObject *v193;
  FILE *v194;
  id v195;
  int v196;
  NSObject *v197;
  id v198;
  int v199;
  const __CFString *v200;
  const __CFString *v201;
  const char *v202;
  malloc_type_id_t v203;
  int v204;
  NSObject *v205;
  int v206;
  const __CFString *v207;
  const __CFString *v208;
  const char *v209;
  char *v210;
  char *v211;
  int v212;
  NSObject *v213;
  const __CFString *v214;
  char *v215;
  char *v216;
  NSObject *v217;
  NSObject *v218;
  FILE *v219;
  FILE *v220;
  NSObject *v221;
  FILE *v222;
  FILE *v223;
  long double v224;
  uint64_t v225;
  int v226;
  const char *v227;
  uint64_t v228;
  NSString *v229;
  NSString *v230;
  uid_t v231;
  int v232;
  int v233;
  FILE *v234;
  FILE *v235;
  int v236;
  NSObject *v237;
  int v238;
  const __CFString *v239;
  const __CFString *v240;
  const char *v241;
  malloc_type_id_t v242;
  int v243;
  NSObject *v244;
  _DWORD *v245;
  id v246;
  uint64_t v247;
  int *v248;
  char *v249;
  const __CFString *v250;
  NSObject *v251;
  int v252;
  NSObject *v253;
  _DWORD *v254;
  id v255;
  uint64_t v256;
  int *v257;
  char *v258;
  const __CFString *v259;
  NSObject *v260;
  int v261;
  NSObject *v262;
  id v263;
  uint64_t v264;
  int *v265;
  char *v266;
  const __CFString *v267;
  const char *v268;
  char *v269;
  char *v270;
  int v271;
  NSObject *v272;
  id v273;
  uint64_t v274;
  int *v275;
  char *v276;
  const __CFString *v277;
  const char *v278;
  char *v279;
  char *v280;
  NSObject *v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  FILE *v288;
  int v289;
  FILE *v290;
  NSObject *v291;
  FILE *v292;
  NSObject *v293;
  FILE *v294;
  int v295;
  NSObject *v296;
  _DWORD *v297;
  id v298;
  uint64_t v299;
  int *v300;
  char *v301;
  const __CFString *v302;
  NSObject *v303;
  int v304;
  NSObject *v305;
  id v306;
  uint64_t v307;
  int *v308;
  char *v309;
  char *v310;
  char *v311;
  FILE *v312;
  NSObject *v313;
  FILE *v314;
  int v315;
  NSObject *v316;
  int v317;
  _DWORD *v318;
  const __CFString *v319;
  NSObject *v320;
  _DWORD *v321;
  unsigned int v322;
  FILE *v323;
  int v324;
  NSObject *v325;
  int v326;
  const __CFString *v327;
  NSObject *v328;
  FILE *v329;
  const __CFString *v330;
  const char *v331;
  char *v332;
  char *v333;
  const __CFString *v334;
  const char *v335;
  char *v336;
  char *v337;
  FILE *v338;
  unsigned __int8 v339;
  const char *v340;
  FILE *v341;
  int v342;
  int v343;
  NSObject *v344;
  int v345;
  _DWORD *v346;
  const __CFString *v347;
  NSObject *v348;
  FILE *v349;
  int v350;
  NSObject *v351;
  int v352;
  const __CFString *v353;
  NSObject *v354;
  FILE *v355;
  const __CFString *v356;
  const char *v357;
  char *v358;
  char *v359;
  const __CFString *v360;
  const char *v361;
  char *v362;
  char *v363;
  int v364;
  NSObject *v365;
  int v366;
  _DWORD *v367;
  const __CFString *v368;
  NSObject *v369;
  FILE *v370;
  FILE *v371;
  FILE *v372;
  int v373;
  NSObject *v374;
  int v375;
  const __CFString *v376;
  NSObject *v377;
  FILE *v378;
  const __CFString *v379;
  const char *v380;
  char *v381;
  char *v382;
  const __CFString *v383;
  const char *CStringPtr;
  char *v385;
  char *v386;
  FILE *v387;
  FILE *v388;
  const char *v389;
  uint64_t v390;
  unsigned int v393;
  uint64_t v394;
  unsigned int v395;
  int v396;
  id v397;
  __int128 v398;
  __int128 v399;
  __int128 v400;
  __int128 v401;
  _BYTE v402[128];
  _BYTE buf[12];
  __int16 v404;
  int v405;
  __int16 v406;
  const char *v407;
  __int16 v408;
  unsigned int v409;
  __int16 v410;
  unsigned int v411;

  if (a16 - 5 >= 6)
  {
    if ((a3 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v373 = *__error();
        v374 = sub_100030318();
        if (os_log_type_enabled(v374, OS_LOG_TYPE_ERROR))
          sub_10008C404();
        *__error() = v373;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v375 = *__error();
        v376 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Bad report type for microstackshots %d"), "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || report_type == DID_DISK_WRITES_RESOURCE", a16);
        if (v376)
        {
          v383 = v376;
          CStringPtr = CFStringGetCStringPtr(v376, 0x8000100u);
          if (CStringPtr)
          {
            v385 = (char *)CStringPtr;
            v386 = 0;
          }
          else
          {
            v385 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x626963BuLL);
            CFStringGetCString(v383, v385, 1024, 0x8000100u);
            v386 = v385;
          }
          if (qword_1000EBD40)
            v388 = (FILE *)qword_1000EBD40;
          else
            v388 = __stderrp;
          fprintf(v388, "%s\n", v385);
          if (v386)
            free(v386);
          CFRelease(v383);
        }
        else
        {
          v377 = sub_100030318();
          if (os_log_type_enabled(v377, OS_LOG_TYPE_FAULT))
            sub_10008C394();
          if (qword_1000EBD40)
            v378 = (FILE *)qword_1000EBD40;
          else
            v378 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v378);
        }
        *__error() = v375;
      }
      v389 = "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICROSTA"
             "CKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || report_type ="
             "= DID_DISK_WRITES_RESOURCE";
      v340 = "%s: Bad report type for microstackshots %d";
    }
    else
    {
      if (byte_1000EBD38)
      {
        v364 = *__error();
        v365 = sub_100030318();
        if (os_log_type_enabled(v365, OS_LOG_TYPE_ERROR))
          sub_10008C31C();
        *__error() = v364;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v366 = *__error();
        v367 = sub_1000302B4(a3);
        v368 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: Bad report type for microstackshots %d"), v367, a3, "report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS || report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_CPU_RESOURCE || report_type == DID_DISK_WRITES_RESOURCE", a16);
        if (v368)
        {
          v379 = v368;
          v380 = CFStringGetCStringPtr(v368, 0x8000100u);
          if (v380)
          {
            v381 = (char *)v380;
            v382 = 0;
          }
          else
          {
            v381 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x626963BuLL);
            CFStringGetCString(v379, v381, 1024, 0x8000100u);
            v382 = v381;
          }
          if (qword_1000EBD40)
            v387 = (FILE *)qword_1000EBD40;
          else
            v387 = __stderrp;
          fprintf(v387, "%s\n", v381);
          if (v382)
            free(v382);
          CFRelease(v379);
        }
        else
        {
          v369 = sub_100030318();
          if (os_log_type_enabled(v369, OS_LOG_TYPE_FAULT))
            sub_10008C2A4();
          if (qword_1000EBD40)
            v370 = (FILE *)qword_1000EBD40;
          else
            v370 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v370);
        }
        *__error() = v366;
      }
      LOBYTE(v389) = sub_1000302B4(a3);
      v340 = "%s [%d]: %s: Bad report type for microstackshots %d";
    }
    v342 = 153;
LABEL_554:
    sub_1000301F0("DoMicrostackshotsOnly", "microstackshot.m", v342, v340, a5, a6, a7, a8, (char)v389);
    abort();
  }
  if (a16 - 7 < 2 != objc_msgSend(a24, "systemstatsFormat"))
  {
    if ((a3 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v324 = *__error();
        v325 = sub_100030318();
        if (os_log_type_enabled(v325, OS_LOG_TYPE_ERROR))
          sub_10008AFA8(a24, a16, v325);
        *__error() = v324;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v326 = *__error();
        v327 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: report_type %d, but systemstatsFormat %d"), "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))", a16, objc_msgSend(a24, "systemstatsFormat"));
        if (v327)
        {
          v334 = v327;
          v335 = CFStringGetCStringPtr(v327, 0x8000100u);
          if (v335)
          {
            v336 = (char *)v335;
            v337 = 0;
          }
          else
          {
            v336 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBFB587AEuLL);
            CFStringGetCString(v334, v336, 1024, 0x8000100u);
            v337 = v336;
          }
          if (qword_1000EBD40)
            v341 = (FILE *)qword_1000EBD40;
          else
            v341 = __stderrp;
          fprintf(v341, "%s\n", v336);
          if (v337)
            free(v337);
          CFRelease(v334);
        }
        else
        {
          v328 = sub_100030318();
          if (os_log_type_enabled(v328, OS_LOG_TYPE_FAULT))
            sub_10008AF2C(a24);
          if (qword_1000EBD40)
            v329 = (FILE *)qword_1000EBD40;
          else
            v329 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v329);
        }
        *__error() = v326;
      }
      objc_msgSend(a24, "systemstatsFormat");
      v389 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
      v340 = "%s: report_type %d, but systemstatsFormat %d";
    }
    else
    {
      if (byte_1000EBD38)
      {
        v315 = *__error();
        v316 = sub_100030318();
        if (os_log_type_enabled(v316, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136316162;
          *(_QWORD *)&buf[4] = sub_1000302B4(a3);
          v404 = 1024;
          v406 = 2080;
          v405 = a3;
          v407 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
          v408 = 1024;
          v409 = a16;
          v410 = 1024;
          v411 = objc_msgSend(a24, "systemstatsFormat");
          _os_log_error_impl((void *)&_mh_execute_header, v316, OS_LOG_TYPE_ERROR, "%s [%d]: %s: report_type %d, but systemstatsFormat %d", buf, 0x28u);
        }
        *__error() = v315;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v317 = *__error();
        v318 = sub_1000302B4(a3);
        v319 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: report_type %d, but systemstatsFormat %d"), v318, a3, "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))", a16, objc_msgSend(a24, "systemstatsFormat"));
        if (v319)
        {
          v330 = v319;
          v331 = CFStringGetCStringPtr(v319, 0x8000100u);
          if (v331)
          {
            v332 = (char *)v331;
            v333 = 0;
          }
          else
          {
            v332 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBFB587AEuLL);
            CFStringGetCString(v330, v332, 1024, 0x8000100u);
            v333 = v332;
          }
          if (qword_1000EBD40)
            v338 = (FILE *)qword_1000EBD40;
          else
            v338 = __stderrp;
          fprintf(v338, "%s\n", v332);
          if (v333)
            free(v333);
          CFRelease(v330);
        }
        else
        {
          v320 = sub_100030318();
          if (os_log_type_enabled(v320, OS_LOG_TYPE_FAULT))
          {
            v321 = sub_1000302B4(a3);
            v322 = objc_msgSend(a24, "systemstatsFormat");
            *(_DWORD *)buf = 136316162;
            *(_QWORD *)&buf[4] = v321;
            v404 = 1024;
            v405 = a3;
            v406 = 2080;
            v407 = "((!!(report_type == DID_SYSTEM_STATS || report_type == DID_SYSTEM_STATS_IO)) == (!!printOptions.systemstatsFormat))";
            v408 = 1024;
            v409 = a16;
            v410 = 1024;
            v411 = v322;
            _os_log_fault_impl((void *)&_mh_execute_header, v320, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: %s: report_type %d, but systemstatsFormat %d", buf, 0x28u);
          }
          if (qword_1000EBD40)
            v323 = (FILE *)qword_1000EBD40;
          else
            v323 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v323);
        }
        *__error() = v317;
      }
      v339 = sub_1000302B4(a3);
      objc_msgSend(a24, "systemstatsFormat");
      LOBYTE(v389) = v339;
      v340 = "%s [%d]: %s: report_type %d, but systemstatsFormat %d";
    }
    v342 = 155;
    goto LABEL_554;
  }
  v33 = a16 - 5;
  v395 = a16 - 5;
  if (a16 == 5 && (_DWORD)a6)
  {
    v46 = +[SAAuxiliaryData auxiliaryDataForTimestamp:](SAAuxiliaryData, "auxiliaryDataForTimestamp:", +[SATimestamp timestamp](SATimestamp, "timestamp"));
    v47 = sub_10004CFA0(a3, a4, 1);
LABEL_7:
    v51 = sub_10004C768((const char *)objc_msgSend(v47, "UTF8String"), a6);
    v49 = 0;
    if (v51)
      v50 = a3;
    else
      v50 = -1;
    v48 = v46;
    goto LABEL_11;
  }
  v47 = sub_10004CFA0(a3, a4, a6);
  v46 = 0;
  v48 = 0;
  v49 = a5;
  v50 = a3;
  if (v33 <= 1)
    goto LABEL_7;
LABEL_11:
  v52 = v48;
  v53 = sub_10002AEAC(a1, a2, v50, v49, a6, 1, 0, a22, a9, a10, a27, a28, a29, a30, a32);
  v54 = v53;
  v55 = a3;
  v56 = a16;
  if (!v53)
    goto LABEL_24;
  if ((v55 & 0x80000000) == 0)
    objc_msgSend(v53, "setTargetProcessId:", v55);
  if (a5)
    objc_msgSend(v54, "setTargetThreadId:", a5);
  if (v47)
  {
    if ((objc_msgSend(objc_msgSend(objc_msgSend(v54, "targetProcess"), "mainBinaryPath"), "isAbsolutePath") & 1) == 0)
    {
      v57 = objc_msgSend(v54, "targetProcess");
      if (v57)
      {
        objc_msgSend(v57, "setMainBinaryPath:", v47);
        objc_msgSend(v54, "postprocess");
      }
    }
  }
  if (!objc_msgSend(objc_msgSend(v54, "tasksByPid"), "count"))
  {
LABEL_24:
    if ((v55 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          sub_10008B138();
        *__error() = v64;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_92;
      v60 = *__error();
      v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No microstackshots found"));
      if (!v62)
      {
        v96 = sub_100030318();
        if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT))
          sub_10008B10C();
        goto LABEL_87;
      }
LABEL_41:
      v66 = v62;
      v67 = CFStringGetCStringPtr(v62, 0x8000100u);
      if (v67)
      {
        v68 = (char *)v67;
        v69 = 0;
      }
      else
      {
        v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF8B452BuLL);
        CFStringGetCString(v66, v68, 1024, 0x8000100u);
        v69 = v68;
      }
      if (qword_1000EBD40)
        v85 = (FILE *)qword_1000EBD40;
      else
        v85 = __stderrp;
      fprintf(v85, "%s\n", v68);
      if (v69)
        free(v69);
      CFRelease(v66);
      goto LABEL_91;
    }
LABEL_25:
    if (byte_1000EBD38)
    {
      v58 = *__error();
      v59 = sub_100030318();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
        sub_10008B09C();
      *__error() = v58;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_92;
    v60 = *__error();
    v61 = sub_1000302B4(v55);
    v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: No microstackshots found"), v61, v55);
    if (!v62)
    {
      v63 = sub_100030318();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT))
        sub_10008B034();
LABEL_87:
      if (qword_1000EBD40)
        v97 = (FILE *)qword_1000EBD40;
      else
        v97 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v97);
LABEL_91:
      *__error() = v60;
LABEL_92:

      return 0x800000;
    }
    goto LABEL_41;
  }
  if (a5 && v33 <= 1)
  {
    if (!objc_msgSend(objc_msgSend(objc_msgSend(v54, "targetProcess"), "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a5)))goto LABEL_24;
  }
  else if ((v55 & 0x80000000) == 0 && !a5 && v33 <= 1 && !objc_msgSend(v54, "targetProcess"))
  {
    goto LABEL_25;
  }
  v394 = v55;
  v393 = a16 - 9;
  v71 = (byte_1000EBD4C & 0x10) == 0 && a16 - 9 < 2;
  sub_10005993C(v54, (byte_1000EBD4C >> 3) & 1, (byte_1000EBD4C >> 2) & 1, v71);
  v400 = 0u;
  v401 = 0u;
  v398 = 0u;
  v399 = 0u;
  v72 = objc_msgSend(a31, "countByEnumeratingWithState:objects:count:", &v398, v402, 16);
  if (v72)
  {
    v73 = v72;
    v74 = *(_QWORD *)v399;
    do
    {
      for (i = 0; i != v73; i = (char *)i + 1)
      {
        if (*(_QWORD *)v399 != v74)
          objc_enumerationMutation(a31);
        objc_msgSend(v54, "useDsymForUUIDFor:", *(_QWORD *)(*((_QWORD *)&v398 + 1) + 8 * (_QWORD)i));
      }
      v73 = objc_msgSend(a31, "countByEnumeratingWithState:objects:count:", &v398, v402, 16);
    }
    while (v73);
  }
  v76 = objc_msgSend(objc_alloc((Class)SASamplePrinter), "initWithSampleStore:", v54);
  v77 = v76;
  if (a24)
    objc_msgSend(v76, "setOptions:");
  if (a11 != 0.0)
  {
    v78 = objc_msgSend(v54, "endTime");
    if (v78)
    {
      v79 = v78;
      objc_msgSend(v78, "machContTimeSeconds");
      if (v80 != 0.0)
      {
        objc_msgSend(v79, "machContTimeSeconds");
        if (v81 > a11)
        {
          objc_msgSend(v79, "machContTimeSeconds");
          v83 = v82 - a11;
          v84 = 0.0;
LABEL_96:
          v88 = 0.0;
LABEL_97:
          v102 = +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, v84, v83, v88);
          if (v102)
          {
            v103 = objc_msgSend(v54, "indexOfFirstSampleOnOrAfterTimestamp:", v102);
            if (v103 == (id)0x7FFFFFFFFFFFFFFFLL)
            {
              v104 = objc_msgSend(v54, "endTime");
              if (!v104)
              {
                v104 = objc_msgSend(v54, "startTime");
                if (!v104)
                  goto LABEL_104;
              }
            }
            else
            {
              v104 = objc_msgSend(objc_msgSend(v54, "sampleTimestamps"), "objectAtIndexedSubscript:", v103);
            }
            -[SATimestamp guessMissingTimesBasedOnTimestamp:](v102, "guessMissingTimesBasedOnTimestamp:", v104);
          }
LABEL_104:
          objc_msgSend(v77, "filterToTimestampRangeStart:end:", v102, 0);
          goto LABEL_105;
        }
      }
      objc_msgSend(v79, "wallTime");
      if (v86 != 0.0)
      {
        objc_msgSend(v79, "wallTime");
        v88 = v87 - a11;
        v84 = 0.0;
        v83 = 0.0;
        goto LABEL_97;
      }
      objc_msgSend(v79, "machAbsTimeSeconds");
      if (v99 != 0.0)
      {
        objc_msgSend(v79, "machAbsTimeSeconds");
        if (v100 > a11)
        {
          objc_msgSend(v79, "machAbsTimeSeconds");
          v84 = v101 - a11;
          v83 = 0.0;
          goto LABEL_96;
        }
      }
      if (byte_1000EBD38)
      {
        v145 = *__error();
        v146 = sub_100030318();
        if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
          sub_10008C218(v79, v146, a11);
        *__error() = v145;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      {
LABEL_290:

        goto LABEL_92;
      }
      v91 = *__error();
      v147 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("-last provided, but unable to calculate %.0f seconds earlier than %@"), *(_QWORD *)&a11, objc_msgSend(v79, "debugDescription"));
      if (v147)
      {
        v93 = v147;
        v94 = CFStringGetCStringPtr(v147, 0x8000100u);
        if (v94)
          goto LABEL_197;
        v95 = 434494585;
        goto LABEL_282;
      }
      v178 = sub_100030318();
      if (os_log_type_enabled(v178, OS_LOG_TYPE_FAULT))
        sub_10008C18C(v79, v178, a11);
    }
    else
    {
      if (byte_1000EBD38)
      {
        v89 = *__error();
        v90 = sub_100030318();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
          sub_10008B1E0(v54, v90);
        *__error() = v89;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_290;
      v91 = *__error();
      v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("-last provided, but unable to get data end time (%lu samples)"), objc_msgSend(v54, "numSamples"));
      if (v92)
      {
        v93 = v92;
        v94 = CFStringGetCStringPtr(v92, 0x8000100u);
        if (v94)
        {
LABEL_197:
          v148 = (char *)v94;
          v149 = 0;
LABEL_283:
          if (qword_1000EBD40)
            v189 = (FILE *)qword_1000EBD40;
          else
            v189 = __stderrp;
          fprintf(v189, "%s\n", v148);
          if (v149)
            free(v149);
          CFRelease(v93);
          goto LABEL_289;
        }
        v95 = 3859832266;
LABEL_282:
        v148 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v95);
        CFStringGetCString(v93, v148, 1024, 0x8000100u);
        v149 = v148;
        goto LABEL_283;
      }
      v162 = sub_100030318();
      if (os_log_type_enabled(v162, OS_LOG_TYPE_FAULT))
        sub_10008B164(v54, v162);
    }
    if (qword_1000EBD40)
      v179 = (FILE *)qword_1000EBD40;
    else
      v179 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v179);
LABEL_289:
    *__error() = v91;
    goto LABEL_290;
  }
LABEL_105:
  if (v52)
    objc_msgSend(v54, "addAuxiliaryData:", v52);
  v105 = &AnalyticsIsEventUsed_ptr;
  v106 = objc_msgSend(v54, "setEvent:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", sub_100026810(a16, 0)));
  v107 = a16 - 5;
  if (a16 != 5)
  {
    if (a16 == 6)
    {
      objc_msgSend(v54, "setBytesWritten:", a18);
      objc_msgSend(v54, "setBytesWrittenLimit:", a19);
      objc_msgSend(v54, "setWriteDuration:", a13);
      objc_msgSend(v54, "setWriteLimitDuration:", a15);
      objc_msgSend(objc_msgSend(v77, "options"), "setPrintSpinSignatureStack:", 1);
    }
    else if ((a16 | 2) != 0xA)
    {
      goto LABEL_113;
    }
    v106 = objc_msgSend(v54, "setStepsNote:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s/step"), objc_msgSend((id)SAFormattedBytes(10485760, 0, 0), "UTF8String")));
    goto LABEL_113;
  }
  objc_msgSend(v54, "setCpuUsed:", a12);
  objc_msgSend(v54, "setCpuLimit:", a14);
  objc_msgSend(v54, "setCpuDuration:", a13);
  objc_msgSend(v54, "setCpuLimitDuration:", a15);
  v106 = objc_msgSend(objc_msgSend(v77, "options"), "setPrintSpinSignatureStack:", 1);
LABEL_113:
  if (a9 > 0.0 && a10 > 0.0)
  {
    v56 = a16;
    v106 = objc_msgSend(v54, "setEventTimeRange:", +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, a9), +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0,
                 0.0,
                 a10)));
  }
  if (a7)
  {
    v108 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  }
  else
  {
    if (v395 > 1)
      goto LABEL_121;
    v108 = CFSTR("none");
  }
  v106 = objc_msgSend(v54, "setActionTaken:", v108);
LABEL_121:
  if (a25)
    v106 = objc_msgSend(v54, "setSignature:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a25));
  if (v393 >= 2)
    v106 = objc_msgSend(v54, "setSanitizePaths:", 1);
  if (v395 > 1)
  {
    v109 = 0;
  }
  else
  {
    v106 = objc_msgSend(v77, "setIncidentUUID:", +[NSUUID UUID](NSUUID, "UUID"));
    v109 = 5;
  }
  objc_msgSend(v77, "setShareWithAppDevs:", AppAnalyticsEnabled(v106));
  objc_msgSend(objc_msgSend(v77, "options"), "setMicrostackshotsFormat:", 1);
  objc_msgSend(objc_msgSend(v77, "options"), "setOmitTasksBelowPercentOfTotalSamples:", v109);
  if ((_DWORD)v56 != 5)
  {
    if ((_DWORD)v56 != 6)
    {
      if ((v394 & 0x80000000) != 0)
      {
        if (byte_1000EBD38)
        {
          v155 = *__error();
          v156 = sub_100030318();
          if (os_log_type_enabled(v156, OS_LOG_TYPE_DEBUG))
            sub_10008C11C(v56, v156);
          *__error() = v155;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
          goto LABEL_313;
        v130 = *__error();
        v132 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Not providing unsupported report type (%d) to MetricKit"), v56);
        if (!v132)
        {
          v181 = sub_100030318();
          if (os_log_type_enabled(v181, OS_LOG_TYPE_FAULT))
            sub_10008C0B8(v56, v181, v182, v183, v184, v185, v186, v187);
          goto LABEL_307;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v128 = *__error();
          v129 = sub_100030318();
          if (os_log_type_enabled(v129, OS_LOG_TYPE_DEBUG))
            sub_10008C034();
          *__error() = v128;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
          goto LABEL_313;
        v130 = *__error();
        v131 = sub_1000302B4(v394);
        v132 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Not providing unsupported report type (%d) to MetricKit"), v131, v394, v56);
        if (!v132)
        {
          v133 = sub_100030318();
          if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
            sub_10008BFC0();
          goto LABEL_307;
        }
      }
      v157 = v132;
      v158 = CFStringGetCStringPtr(v132, 0x8000100u);
      if (!v158)
      {
        v159 = 1502923171;
LABEL_298:
        v174 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v159);
        CFStringGetCString(v157, v174, 1024, 0x8000100u);
        v175 = v174;
        goto LABEL_299;
      }
LABEL_254:
      v174 = (char *)v158;
      v175 = 0;
LABEL_299:
      if (qword_1000EBD40)
        v192 = (FILE *)qword_1000EBD40;
      else
        v192 = __stderrp;
      fprintf(v192, "%s\n", v174);
      if (v175)
        free(v175);
      CFRelease(v157);
      v56 = a16;
      v107 = a16 - 5;
      goto LABEL_311;
    }
    if (!objc_opt_class(MXSampleAnalysisParser))
    {
      if ((v394 & 0x80000000) != 0)
      {
        v105 = &AnalyticsIsEventUsed_ptr;
        if (byte_1000EBD38)
        {
          v172 = *__error();
          v173 = sub_100030318();
          if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
            sub_10008BF00();
          *__error() = v172;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
          goto LABEL_313;
        v130 = *__error();
        v153 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("MetricKit unavailable, not providing disk writes report"));
        if (!v153)
        {
          v193 = sub_100030318();
          if (os_log_type_enabled(v193, OS_LOG_TYPE_FAULT))
            sub_10008BED4();
          goto LABEL_307;
        }
      }
      else
      {
        v105 = &AnalyticsIsEventUsed_ptr;
        if (byte_1000EBD38)
        {
          v150 = *__error();
          v151 = sub_100030318();
          if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
            sub_10008BE64();
          *__error() = v150;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
          goto LABEL_313;
        v130 = *__error();
        v152 = sub_1000302B4(v394);
        v153 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: MetricKit unavailable, not providing disk writes report"), v152, v394);
        if (!v153)
        {
          v154 = sub_100030318();
          if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT))
            sub_10008BDFC();
          goto LABEL_307;
        }
      }
      v157 = v153;
      v158 = CFStringGetCStringPtr(v153, 0x8000100u);
      if (!v158)
      {
        v159 = 1407155682;
        goto LABEL_298;
      }
      goto LABEL_254;
    }
    if ((v394 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v163 = *__error();
        v164 = sub_100030318();
        if (os_log_type_enabled(v164, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v164, OS_LOG_TYPE_INFO, "Providing disk writes report to MetricKit", buf, 2u);
        }
        *__error() = v163;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 1)
        goto LABEL_275;
      v122 = v47;
      v123 = *__error();
      v125 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Providing disk writes report to MetricKit"));
      if (!v125)
      {
        v190 = sub_100030318();
        if (os_log_type_enabled(v190, OS_LOG_TYPE_FAULT))
          sub_10008BF94();
        if (qword_1000EBD40)
          v191 = (FILE *)qword_1000EBD40;
        else
          v191 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v191);
        goto LABEL_274;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v119 = *__error();
        v120 = sub_100030318();
        if (os_log_type_enabled(v120, OS_LOG_TYPE_INFO))
        {
          v121 = sub_1000302B4(v394);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v121;
          v404 = 1024;
          v405 = v394;
          v56 = a16;
          _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_INFO, "%{public}s [%d]: Providing disk writes report to MetricKit", buf, 0x12u);
        }
        *__error() = v119;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 1)
        goto LABEL_275;
      v122 = v47;
      v123 = *__error();
      v124 = sub_1000302B4(v394);
      v125 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Providing disk writes report to MetricKit"), v124, v394);
      if (!v125)
      {
        v126 = sub_100030318();
        if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT))
          sub_10008BF2C();
        if (qword_1000EBD40)
          v127 = (FILE *)qword_1000EBD40;
        else
          v127 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
        v56 = a16;
LABEL_274:
        *__error() = v123;
        v47 = v122;
LABEL_275:
        v170 = v77;
        v171 = 1;
        goto LABEL_276;
      }
    }
    v165 = v125;
    v166 = CFStringGetCStringPtr(v125, 0x8000100u);
    if (v166)
    {
      v167 = (char *)v166;
      v168 = 0;
    }
    else
    {
      v167 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF02548F1uLL);
      CFStringGetCString(v165, v167, 1024, 0x8000100u);
      v168 = v167;
    }
    if (qword_1000EBD40)
      v180 = (FILE *)qword_1000EBD40;
    else
      v180 = __stderrp;
    fprintf(v180, "%s\n", v167);
    if (v168)
      free(v168);
    CFRelease(v165);
    v56 = a16;
    v107 = a16 - 5;
    goto LABEL_274;
  }
  if (objc_opt_class(MXSampleAnalysisParser))
  {
    if ((v394 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v139 = *__error();
        v140 = sub_100030318();
        if (os_log_type_enabled(v140, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_INFO, "Providing cpu usage report to MetricKit", buf, 2u);
        }
        *__error() = v139;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 1)
        goto LABEL_245;
      v113 = v47;
      v114 = *__error();
      v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Providing cpu usage report to MetricKit"));
      if (!v116)
      {
        v176 = sub_100030318();
        if (os_log_type_enabled(v176, OS_LOG_TYPE_FAULT))
          sub_10008BDD0();
        if (qword_1000EBD40)
          v177 = (FILE *)qword_1000EBD40;
        else
          v177 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v177);
        goto LABEL_244;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v110 = *__error();
        v111 = sub_100030318();
        if (os_log_type_enabled(v111, OS_LOG_TYPE_INFO))
        {
          v112 = sub_1000302B4(v394);
          *(_DWORD *)buf = 136446466;
          *(_QWORD *)&buf[4] = v112;
          v404 = 1024;
          v405 = v394;
          v56 = a16;
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_INFO, "%{public}s [%d]: Providing cpu usage report to MetricKit", buf, 0x12u);
        }
        *__error() = v110;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 1)
        goto LABEL_245;
      v113 = v47;
      v114 = *__error();
      v115 = sub_1000302B4(v394);
      v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Providing cpu usage report to MetricKit"), v115, v394);
      if (!v116)
      {
        v117 = sub_100030318();
        if (os_log_type_enabled(v117, OS_LOG_TYPE_FAULT))
          sub_10008BD68();
        if (qword_1000EBD40)
          v118 = (FILE *)qword_1000EBD40;
        else
          v118 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v118);
        v56 = a16;
LABEL_244:
        *__error() = v114;
        v47 = v113;
LABEL_245:
        v170 = v77;
        v171 = 0;
LABEL_276:
        +[MXSampleAnalysisParser sendDiagnosticReport:forType:forSourceID:](MXSampleAnalysisParser, "sendDiagnosticReport:forType:forSourceID:", v170, v171, 4);
LABEL_312:
        v105 = &AnalyticsIsEventUsed_ptr;
        goto LABEL_313;
      }
    }
    v141 = v116;
    v142 = CFStringGetCStringPtr(v116, 0x8000100u);
    if (v142)
    {
      v143 = (char *)v142;
      v144 = 0;
    }
    else
    {
      v143 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x60328999uLL);
      CFStringGetCString(v141, v143, 1024, 0x8000100u);
      v144 = v143;
    }
    if (qword_1000EBD40)
      v169 = (FILE *)qword_1000EBD40;
    else
      v169 = __stderrp;
    fprintf(v169, "%s\n", v143);
    if (v144)
      free(v144);
    CFRelease(v141);
    v56 = a16;
    v107 = a16 - 5;
    goto LABEL_244;
  }
  if ((v394 & 0x80000000) != 0)
  {
    v105 = &AnalyticsIsEventUsed_ptr;
    if (byte_1000EBD38)
    {
      v160 = *__error();
      v161 = sub_100030318();
      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
        sub_10008BD3C();
      *__error() = v160;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v130 = *__error();
      v137 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("MetricKit unavailable, not providing cpu usage report"));
      if (!v137)
      {
        v188 = sub_100030318();
        if (os_log_type_enabled(v188, OS_LOG_TYPE_FAULT))
          sub_10008BD10();
        goto LABEL_307;
      }
LABEL_224:
      v157 = v137;
      v158 = CFStringGetCStringPtr(v137, 0x8000100u);
      if (!v158)
      {
        v159 = 3490226989;
        goto LABEL_298;
      }
      goto LABEL_254;
    }
  }
  else
  {
    v105 = &AnalyticsIsEventUsed_ptr;
    if (byte_1000EBD38)
    {
      v134 = *__error();
      v135 = sub_100030318();
      if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
        sub_10008BCA0();
      *__error() = v134;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v130 = *__error();
      v136 = sub_1000302B4(v394);
      v137 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: MetricKit unavailable, not providing cpu usage report"), v136, v394);
      if (!v137)
      {
        v138 = sub_100030318();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT))
          sub_10008BC38();
LABEL_307:
        if (qword_1000EBD40)
          v194 = (FILE *)qword_1000EBD40;
        else
          v194 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v194);
LABEL_311:
        *__error() = v130;
        goto LABEL_312;
      }
      goto LABEL_224;
    }
  }
LABEL_313:
  if (a26)
  {
    *(_QWORD *)buf = 0;
    v195 = objc_msgSend(objc_alloc((Class)NSData), "initWithContentsOfFile:options:error:", objc_msgSend(v105[39], "stringWithUTF8String:", a26), 1, buf);
    if (v195)
    {
      if (byte_1000EBD38)
      {
        v196 = *__error();
        v197 = sub_100030318();
        if (os_log_type_enabled(v197, OS_LOG_TYPE_DEBUG))
          sub_10008BBCC();
        *__error() = v196;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
      {
        v198 = v47;
        v199 = *__error();
        v200 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Appending data file %s"), a26);
        if (v200)
        {
          v201 = v200;
          v202 = CFStringGetCStringPtr(v200, 0x8000100u);
          if (!v202)
          {
            v203 = 2124346485;
LABEL_365:
            v215 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v203);
            CFStringGetCString(v201, v215, 1024, 0x8000100u);
            v216 = v215;
            goto LABEL_366;
          }
          goto LABEL_341;
        }
        v217 = sub_100030318();
        if (os_log_type_enabled(v217, OS_LOG_TYPE_FAULT))
          sub_10008BB6C();
        goto LABEL_360;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v212 = *__error();
        v213 = sub_100030318();
        if (os_log_type_enabled(v213, OS_LOG_TYPE_ERROR))
          sub_10008BAF0(a26, (id *)buf, v213);
        *__error() = v212;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v198 = v47;
        v199 = *__error();
        v214 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("reading in data file %s failed: %@"), a26, objc_msgSend(*(id *)buf, "localizedDescription"));
        if (v214)
        {
          v201 = v214;
          v202 = CFStringGetCStringPtr(v214, 0x8000100u);
          if (!v202)
          {
            v203 = 3841089587;
            goto LABEL_365;
          }
LABEL_341:
          v215 = (char *)v202;
          v216 = 0;
LABEL_366:
          if (qword_1000EBD40)
            v223 = (FILE *)qword_1000EBD40;
          else
            v223 = __stderrp;
          fprintf(v223, "%s\n", v215);
          if (v216)
            free(v216);
          CFRelease(v201);
          v56 = a16;
          v107 = a16 - 5;
          goto LABEL_372;
        }
        v221 = sub_100030318();
        if (os_log_type_enabled(v221, OS_LOG_TYPE_FAULT))
          sub_10008BA74(a26, (id *)buf, v221);
LABEL_360:
        if (qword_1000EBD40)
          v222 = (FILE *)qword_1000EBD40;
        else
          v222 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v222);
LABEL_372:
        *__error() = v199;
        v47 = v198;
      }
    }
  }
  else
  {
    if (byte_1000EBD38)
    {
      v204 = *__error();
      v205 = sub_100030318();
      if (os_log_type_enabled(v205, OS_LOG_TYPE_DEBUG))
        sub_10008BA48();
      *__error() = v204;
    }
    v195 = 0;
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v206 = *__error();
      v207 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No file to append"));
      if (v207)
      {
        v208 = v207;
        v209 = CFStringGetCStringPtr(v207, 0x8000100u);
        if (v209)
        {
          v210 = (char *)v209;
          v211 = 0;
        }
        else
        {
          v210 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9AFC83C5uLL);
          CFStringGetCString(v208, v210, 1024, 0x8000100u);
          v211 = v210;
        }
        if (qword_1000EBD40)
          v220 = (FILE *)qword_1000EBD40;
        else
          v220 = __stderrp;
        fprintf(v220, "%s\n", v210);
        if (v211)
          free(v211);
        CFRelease(v208);
        v56 = a16;
        v107 = a16 - 5;
      }
      else
      {
        v218 = sub_100030318();
        if (os_log_type_enabled(v218, OS_LOG_TYPE_FAULT))
          sub_10008BA1C();
        if (qword_1000EBD40)
          v219 = (FILE *)qword_1000EBD40;
        else
          v219 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v219);
      }
      v195 = 0;
      *__error() = v206;
    }
  }
  if (v107 <= 3)
  {
    if (v107 > 1)
    {
      v225 = 0;
      v224 = 0.0;
    }
    else
    {
      objc_msgSend(objc_msgSend(v54, "startTime"), "wallTime");
      v225 = a20 & 1;
    }
    v226 = sub_10004D06C(v77, 0, (uint64_t)v195, v56, 0, v225, a17, 0, v224, a13, 0, 0);
    goto LABEL_501;
  }
  if (a23)
  {
    objc_msgSend(v77, "printToStream:", __stdoutp);
    v226 = 1;
    goto LABEL_501;
  }
  if (v393 >= 2)
  {
    if ((v394 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v350 = *__error();
        v351 = sub_100030318();
        if (os_log_type_enabled(v351, OS_LOG_TYPE_ERROR))
          sub_10008B9AC();
        *__error() = v350;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v352 = *__error();
        v353 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Bad report type %d"), "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS", a16);
        if (v353)
        {
          v360 = v353;
          v361 = CFStringGetCStringPtr(v353, 0x8000100u);
          if (v361)
          {
            v362 = (char *)v361;
            v363 = 0;
          }
          else
          {
            v362 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x95521467uLL);
            CFStringGetCString(v360, v362, 1024, 0x8000100u);
            v363 = v362;
          }
          if (qword_1000EBD40)
            v372 = (FILE *)qword_1000EBD40;
          else
            v372 = __stderrp;
          fprintf(v372, "%s\n", v362);
          if (v363)
            free(v363);
          CFRelease(v360);
        }
        else
        {
          v354 = sub_100030318();
          if (os_log_type_enabled(v354, OS_LOG_TYPE_FAULT))
            sub_10008B93C();
          if (qword_1000EBD40)
            v355 = (FILE *)qword_1000EBD40;
          else
            v355 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v355);
        }
        *__error() = v352;
      }
      v389 = "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS";
      v340 = "%s: Bad report type %d";
    }
    else
    {
      if (byte_1000EBD38)
      {
        v343 = *__error();
        v344 = sub_100030318();
        if (os_log_type_enabled(v344, OS_LOG_TYPE_ERROR))
          sub_10008B8C4();
        *__error() = v343;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v345 = *__error();
        v346 = sub_1000302B4(v394);
        v347 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: Bad report type %d"), v346, v394, "report_type == DID_MANUAL_MICROSTACKSHOTS_IO || report_type == DID_MANUAL_MICROSTACKSHOTS", a16);
        if (v347)
        {
          v356 = v347;
          v357 = CFStringGetCStringPtr(v347, 0x8000100u);
          if (v357)
          {
            v358 = (char *)v357;
            v359 = 0;
          }
          else
          {
            v358 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x95521467uLL);
            CFStringGetCString(v356, v358, 1024, 0x8000100u);
            v359 = v358;
          }
          if (qword_1000EBD40)
            v371 = (FILE *)qword_1000EBD40;
          else
            v371 = __stderrp;
          fprintf(v371, "%s\n", v358);
          if (v359)
            free(v359);
          CFRelease(v356);
        }
        else
        {
          v348 = sub_100030318();
          if (os_log_type_enabled(v348, OS_LOG_TYPE_FAULT))
            sub_10008B84C();
          if (qword_1000EBD40)
            v349 = (FILE *)qword_1000EBD40;
          else
            v349 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v349);
        }
        *__error() = v345;
      }
      LOBYTE(v389) = sub_1000302B4(v394);
      v340 = "%s [%d]: %s: Bad report type %d";
    }
    v342 = 397;
    goto LABEL_554;
  }
  if ((_DWORD)v56 == 9)
    v227 = "Powerstats";
  else
    v227 = "IOStats";
  v397 = 0;
  v228 = v394;
  if (a8)
    v229 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  else
    v229 = 0;
  v230 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v227);
  v231 = geteuid();
  v232 = sub_10004EDCC(v229, v230, 0xFFFFFFFFLL, 1537, v231, 0x1A4u, &v397);
  if (v232 != -1)
  {
    v233 = v232;
    v234 = fdopen(v232, "w");
    v226 = v234 != 0;
    if (v234)
    {
      v235 = v234;
      objc_msgSend(v77, "printToStream:", v234);
      fclose(v235);
      if (byte_1000EBD38)
      {
        v236 = *__error();
        v237 = sub_100030318();
        if (os_log_type_enabled(v237, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = v397;
          _os_log_impl((void *)&_mh_execute_header, v237, OS_LOG_TYPE_DEFAULT, "Spindump analysis written to file %@", buf, 0xCu);
        }
        *__error() = v236;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
        goto LABEL_500;
      v238 = *__error();
      v239 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Spindump analysis written to file %@"), v397);
      if (v239)
      {
        v240 = v239;
        v241 = CFStringGetCStringPtr(v239, 0x8000100u);
        if (!v241)
        {
          v242 = 3008392109;
LABEL_486:
          v310 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v242);
          CFStringGetCString(v240, v310, 1024, 0x8000100u);
          v311 = v310;
          goto LABEL_487;
        }
        goto LABEL_484;
      }
      v281 = sub_100030318();
      if (os_log_type_enabled(v281, OS_LOG_TYPE_FAULT))
        sub_10008B434((uint64_t)&v397, v281, v282, v283, v284, v285, v286, v287);
      goto LABEL_495;
    }
    if ((v394 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v271 = *__error();
        v272 = sub_100030318();
        if (os_log_type_enabled(v272, OS_LOG_TYPE_ERROR))
          sub_10008B7D8();
        *__error() = v271;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v396 = *__error();
        v273 = v397;
        v274 = *__error();
        v275 = __error();
        v276 = strerror(*v275);
        v259 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("could not fdopen log file %@: %d (%s)"), v273, v274, v276);
        if (!v259)
        {
          v293 = sub_100030318();
          if (os_log_type_enabled(v293, OS_LOG_TYPE_FAULT))
            sub_10008B764();
          goto LABEL_461;
        }
LABEL_434:
        v277 = v259;
        v278 = CFStringGetCStringPtr(v259, 0x8000100u);
        if (v278)
        {
          v279 = (char *)v278;
          v280 = 0;
        }
        else
        {
          v279 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x23CB35F5uLL);
          CFStringGetCString(v277, v279, 1024, 0x8000100u);
          v280 = v279;
        }
        v289 = v396;
        if (qword_1000EBD40)
          v290 = (FILE *)qword_1000EBD40;
        else
          v290 = __stderrp;
        fprintf(v290, "%s\n", v279);
        if (v280)
          free(v280);
        CFRelease(v277);
        v228 = v394;
        goto LABEL_465;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v252 = *__error();
        v253 = sub_100030318();
        if (os_log_type_enabled(v253, OS_LOG_TYPE_ERROR))
          sub_10008B6EC(v394, &v397, v253);
        *__error() = v252;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v396 = *__error();
        v254 = sub_1000302B4(v394);
        v255 = v397;
        v256 = *__error();
        v257 = __error();
        v258 = strerror(*v257);
        v390 = v256;
        v228 = v394;
        v259 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: could not fdopen log file %@: %d (%s)"), v254, v394, v255, v390, v258);
        if (!v259)
        {
          v260 = sub_100030318();
          if (os_log_type_enabled(v260, OS_LOG_TYPE_FAULT))
            sub_10008B674(v394, &v397, v260);
LABEL_461:
          if (qword_1000EBD40)
            v294 = (FILE *)qword_1000EBD40;
          else
            v294 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v294);
          v289 = v396;
LABEL_465:
          *__error() = v289;
          goto LABEL_466;
        }
        goto LABEL_434;
      }
    }
LABEL_466:

    close(v233);
    if ((v228 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v304 = *__error();
        v305 = sub_100030318();
        if (os_log_type_enabled(v305, OS_LOG_TYPE_ERROR))
          sub_10008B600();
        *__error() = v304;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_500;
      v238 = *__error();
      v306 = v397;
      v307 = *__error();
      v308 = __error();
      v309 = strerror(*v308);
      v302 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("could not write to file %@: %d (%s)"), v306, v307, v309);
      if (!v302)
      {
        v313 = sub_100030318();
        if (os_log_type_enabled(v313, OS_LOG_TYPE_FAULT))
          sub_10008B58C();
        goto LABEL_495;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v295 = *__error();
        v296 = sub_100030318();
        if (os_log_type_enabled(v296, OS_LOG_TYPE_ERROR))
          sub_10008B514(v228, &v397, v296);
        *__error() = v295;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_500;
      v238 = *__error();
      v297 = sub_1000302B4(v228);
      v298 = v397;
      v299 = *__error();
      v300 = __error();
      v301 = strerror(*v300);
      v302 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: could not write to file %@: %d (%s)"), v297, v394, v298, v299, v301);
      if (!v302)
      {
        v303 = sub_100030318();
        if (os_log_type_enabled(v303, OS_LOG_TYPE_FAULT))
          sub_10008B49C(v394, &v397, v303);
LABEL_495:
        if (qword_1000EBD40)
          v314 = (FILE *)qword_1000EBD40;
        else
          v314 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v314);
        goto LABEL_499;
      }
    }
    v240 = v302;
    v241 = CFStringGetCStringPtr(v302, 0x8000100u);
    if (!v241)
    {
      v242 = 1573601823;
      goto LABEL_486;
    }
LABEL_484:
    v310 = (char *)v241;
    v311 = 0;
LABEL_487:
    if (qword_1000EBD40)
      v312 = (FILE *)qword_1000EBD40;
    else
      v312 = __stderrp;
    fprintf(v312, "%s\n", v310);
    if (v311)
      free(v311);
    CFRelease(v240);
    goto LABEL_499;
  }
  if ((v394 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v261 = *__error();
      v262 = sub_100030318();
      if (os_log_type_enabled(v262, OS_LOG_TYPE_ERROR))
        sub_10008B3C0();
      *__error() = v261;
    }
    v226 = 0;
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_500;
    v238 = *__error();
    v263 = v397;
    v264 = *__error();
    v265 = __error();
    v266 = strerror(*v265);
    v250 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("could not open log file %@: %d (%s)"), v263, v264, v266);
    if (!v250)
    {
      v291 = sub_100030318();
      if (os_log_type_enabled(v291, OS_LOG_TYPE_FAULT))
        sub_10008B34C();
      goto LABEL_454;
    }
LABEL_425:
    v267 = v250;
    v268 = CFStringGetCStringPtr(v250, 0x8000100u);
    if (v268)
    {
      v269 = (char *)v268;
      v270 = 0;
    }
    else
    {
      v269 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDD127B48uLL);
      CFStringGetCString(v267, v269, 1024, 0x8000100u);
      v270 = v269;
    }
    if (qword_1000EBD40)
      v288 = (FILE *)qword_1000EBD40;
    else
      v288 = __stderrp;
    fprintf(v288, "%s\n", v269);
    if (v270)
      free(v270);
    CFRelease(v267);
    goto LABEL_458;
  }
  if (byte_1000EBD38)
  {
    v243 = *__error();
    v244 = sub_100030318();
    if (os_log_type_enabled(v244, OS_LOG_TYPE_ERROR))
      sub_10008B2D4(v394, &v397, v244);
    *__error() = v243;
  }
  v226 = 0;
  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
    goto LABEL_500;
  v238 = *__error();
  v245 = sub_1000302B4(v394);
  v246 = v397;
  v247 = *__error();
  v248 = __error();
  v249 = strerror(*v248);
  v250 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: could not open log file %@: %d (%s)"), v245, v394, v246, v247, v249);
  if (v250)
    goto LABEL_425;
  v251 = sub_100030318();
  if (os_log_type_enabled(v251, OS_LOG_TYPE_FAULT))
    sub_10008B25C(v394, &v397, v251);
LABEL_454:
  if (qword_1000EBD40)
    v292 = (FILE *)qword_1000EBD40;
  else
    v292 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v292);
LABEL_458:
  v226 = 0;
LABEL_499:
  *__error() = v238;
LABEL_500:

LABEL_501:
  +[SABinary clearCoreSymbolicationCaches](SABinary, "clearCoreSymbolicationCaches");

  if (v226)
    return 0;
  else
    return 0x1000000;
}

id sub_10002AEAC(char *a1, off_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11, uint64_t a12, unsigned int a13, unsigned int a14, uint64_t a15)
{
  uint64_t v15;
  int v16;
  int v17;
  int v22;
  int v23;
  int v25;
  int v26;
  gzFile v27;
  gzFile_s *v28;
  id v29;
  id v30;
  uid_t v31;
  int v32;
  NSObject *v33;
  uint64_t v34;
  int *v35;
  char *v36;
  const __CFString *v37;
  char *v38;
  char *v39;
  int v40;
  NSObject *v41;
  BOOL v42;
  int v43;
  uint64_t v44;
  int *v45;
  char *v46;
  const __CFString *v47;
  const __CFString *v48;
  char *v49;
  char *v50;
  int v51;
  int v52;
  NSObject *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  int v62;
  NSObject *v63;
  int v64;
  uint64_t v65;
  int *v66;
  char *v67;
  const __CFString *v68;
  const __CFString *v69;
  char *v70;
  char *v71;
  int v72;
  NSObject *v73;
  int v74;
  const __CFString *v75;
  const __CFString *v76;
  char *v77;
  char *v78;
  int v79;
  NSObject *v80;
  int v81;
  uint64_t v82;
  int *v83;
  char *v84;
  const __CFString *v85;
  const __CFString *v86;
  char *v87;
  char *v88;
  NSObject *v89;
  FILE *v90;
  FILE *v91;
  NSObject *v92;
  FILE *v93;
  NSObject *v94;
  FILE *v95;
  FILE *v96;
  NSObject *v97;
  FILE *v98;
  FILE *v99;
  NSObject *v100;
  FILE *v101;
  FILE *v102;
  NSObject *v103;
  uint64_t v104;
  int *v105;
  char *v106;
  const __CFString *v107;
  char *v108;
  char *v109;
  NSObject *v110;
  FILE *v111;
  FILE *v112;
  FILE *v113;
  xpc_object_t empty;
  void *v115;
  id v116;
  int v117;
  NSObject *v118;
  int v119;
  const __CFString *v120;
  const __CFString *v121;
  char *v122;
  char *v123;
  NSObject *v124;
  FILE *v125;
  FILE *v126;
  NSObject *v127;
  xpc_object_t v128;
  void *v129;
  NSObject *v130;
  NSObject *v131;
  dispatch_time_t v132;
  int v133;
  NSObject *v134;
  int v135;
  char *v136;
  BOOL v137;
  int v138;
  uint64_t v139;
  char *v140;
  const __CFString *v141;
  const __CFString *v142;
  char *v143;
  char *v144;
  NSObject *v145;
  int v146;
  char *v147;
  FILE *v148;
  FILE *v149;
  int v151;
  NSObject *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  BOOL v160;
  int v161;
  NSObject *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  BOOL v170;
  int v171;
  const __CFString *v172;
  const __CFString *v173;
  NSObject *v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  FILE *v182;
  int v183;
  const __CFString *v184;
  const __CFString *v185;
  NSObject *v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  FILE *v194;
  char *CStringPtr;
  char *v196;
  char *v197;
  char *v198;
  int v199;
  const __CFString *v200;
  const __CFString *v201;
  NSObject *v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  FILE *v210;
  FILE *v211;
  FILE *v212;
  char *v213;
  char *v214;
  FILE *v215;
  int v216;
  int v217;
  const __CFString *theString;
  int theStringa;
  const __CFString *theStringb;
  int v221;
  unsigned int v222;
  int value;
  _QWORD value_4[6];
  uint64_t v226;
  uint64_t *v227;
  uint64_t v228;
  char v229;
  _QWORD v230[13];
  qos_class_t v231;
  int v232;
  int v233;
  _QWORD v234[3];
  int v235;
  uint8_t buf[8];
  uint8_t *v237;
  uint64_t v238;
  uint64_t v239;
  _BYTE v240[32];
  _BYTE v241[32];

  v15 = a8;
  v16 = a6;
  v17 = a5;
  value = a3;
  if ((a6 & 1) == 0 && (a7 & 1) == 0)
  {
    if (byte_1000EBD38)
    {
      v151 = *__error();
      v152 = sub_100030318();
      if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
        sub_10008AEBC(v152, v153, v154, v155, v156, v157, v158, v159);
      *__error() = v151;
    }
    if (byte_1000EBD39)
      v160 = dword_1000EB4E8 <= 3;
    else
      v160 = 0;
    if (v160)
    {
      v171 = *__error();
      v172 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Nothing to do"), "report || save");
      v173 = v172;
      if (v172)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v172, 0x8000100u);
        if (CStringPtr)
        {
          v196 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4D2EE15AuLL);
          CFStringGetCString(v173, CStringPtr, 1024, 0x8000100u);
          v196 = CStringPtr;
        }
        if (qword_1000EBD40)
          v211 = (FILE *)qword_1000EBD40;
        else
          v211 = __stderrp;
        fprintf(v211, "%s\n", CStringPtr);
        if (v196)
          free(v196);
        CFRelease(v173);
      }
      else
      {
        v174 = sub_100030318();
        if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT))
          sub_10008AE4C(v174, v175, v176, v177, v178, v179, v180, v181);
        if (qword_1000EBD40)
          v182 = (FILE *)qword_1000EBD40;
        else
          v182 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v182);
      }
      *__error() = v171;
    }
    sub_1000301F0("_HandleMicrostackshots", "microstackshot.m", 450, "%s: Nothing to do", a5, a6, a7, a8, (char)"report || save");
    abort();
  }
  v22 = a7 ^ 1;
  if (!a1 && (v22 & 1) == 0)
  {
    if (byte_1000EBD38)
    {
      v161 = *__error();
      v162 = sub_100030318();
      if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
        sub_10008ADDC(v162, v163, v164, v165, v166, v167, v168, v169);
      *__error() = v161;
    }
    if (byte_1000EBD39)
      v170 = dword_1000EB4E8 <= 3;
    else
      v170 = 0;
    if (v170)
    {
      v183 = *__error();
      v184 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No datastore path provided for saving"), "!save || datastorePath");
      v185 = v184;
      if (v184)
      {
        v197 = (char *)CFStringGetCStringPtr(v184, 0x8000100u);
        if (v197)
        {
          v198 = 0;
        }
        else
        {
          v197 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x730FC77uLL);
          CFStringGetCString(v185, v197, 1024, 0x8000100u);
          v198 = v197;
        }
        if (qword_1000EBD40)
          v212 = (FILE *)qword_1000EBD40;
        else
          v212 = __stderrp;
        fprintf(v212, "%s\n", v197);
        if (v198)
          free(v198);
        CFRelease(v185);
      }
      else
      {
        v186 = sub_100030318();
        if (os_log_type_enabled(v186, OS_LOG_TYPE_FAULT))
          sub_10008AD6C(v186, v187, v188, v189, v190, v191, v192, v193);
        if (qword_1000EBD40)
          v194 = (FILE *)qword_1000EBD40;
        else
          v194 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v194);
      }
      *__error() = v183;
    }
    sub_1000301F0("_HandleMicrostackshots", "microstackshot.m", 451, "%s: No datastore path provided for saving", a5, a6, a7, a8, (char)"!save || datastorePath");
    abort();
  }
  if (a1)
    v23 = a6;
  else
    v23 = 0;
  if ((v23 & v22) != 1)
  {
    if (!&_systemstats_copy_microstackshots_to_file)
      return 0;
    if (a1 && (_DWORD)a7)
    {
      v31 = geteuid();
      v222 = sub_10002D718(a1, 1537, v31, 0x1A4u);
      if (v222 == -1)
      {
        v221 = v15;
        if (byte_1000EBD38)
        {
          v32 = *__error();
          v33 = sub_100030318();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            sub_10008AC18();
          *__error() = v32;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v216 = *__error();
          v34 = *__error();
          v35 = __error();
          v36 = strerror(*v35);
          v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to open datastore file %s: %d (%s)"), a1, v34, v36);
          theString = v37;
          if (v37)
          {
            v38 = (char *)CFStringGetCStringPtr(v37, 0x8000100u);
            if (v38)
            {
              v39 = 0;
            }
            else
            {
              v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD0D3A15AuLL);
              CFStringGetCString(theString, v38, 1024, 0x8000100u);
              v39 = v38;
            }
            if (qword_1000EBD40)
              v102 = (FILE *)qword_1000EBD40;
            else
              v102 = __stderrp;
            fprintf(v102, "%s\n", v38);
            if (v39)
              free(v39);
            CFRelease(theString);
          }
          else
          {
            v97 = sub_100030318();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
              sub_10008AB94();
            if (qword_1000EBD40)
              v98 = (FILE *)qword_1000EBD40;
            else
              v98 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
          }
          *__error() = v216;
          LODWORD(v15) = v221;
        }
        if (!v16)
          return 0;
      }
      v51 = v15;
      if (a2 && lseek(v222, a2, 0) == -1)
      {
        if (byte_1000EBD38)
        {
          theStringa = *__error();
          v103 = sub_100030318();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
            sub_10008AB10();
          *__error() = theStringa;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v217 = *__error();
          v104 = *__error();
          v105 = __error();
          v106 = strerror(*v105);
          v107 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to seek %s to offset %lld: %d (%s)"), a1, a2, v104, v106);
          theStringb = v107;
          if (v107)
          {
            v108 = (char *)CFStringGetCStringPtr(v107, 0x8000100u);
            if (v108)
            {
              v109 = 0;
            }
            else
            {
              v108 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC6A5190EuLL);
              CFStringGetCString(theStringb, v108, 1024, 0x8000100u);
              v109 = v108;
            }
            if (qword_1000EBD40)
              v113 = (FILE *)qword_1000EBD40;
            else
              v113 = __stderrp;
            fprintf(v113, "%s\n", v108);
            if (v109)
              free(v109);
            CFRelease(theStringb);
          }
          else
          {
            v110 = sub_100030318();
            if (os_log_type_enabled(v110, OS_LOG_TYPE_FAULT))
              sub_10008AA8C();
            if (qword_1000EBD40)
              v111 = (FILE *)qword_1000EBD40;
            else
              v111 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v111);
          }
          *__error() = v217;
        }
        if ((v16 & 1) == 0)
        {
          close(v222);
          return 0;
        }
      }
      empty = xpc_dictionary_create_empty();
      v115 = empty;
      if (a9 > 0.0)
        xpc_dictionary_set_uint64(empty, "time", (unint64_t)(kCFAbsoluteTimeIntervalSince1970 + a9));
      systemstats_copy_microstackshots_to_file(v115, v222);
      close(v222);
      xpc_release(v115);
      if ((v16 & 1) == 0)
        return 0;
    }
    else
    {
      v51 = a8;
      if ((a6 & 1) == 0)
      {
        if (byte_1000EBD38)
        {
          v52 = *__error();
          v53 = sub_100030318();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
            sub_10008ACFC(v53, v54, v55, v56, v57, v58, v59, v60);
          *__error() = v52;
        }
        if (byte_1000EBD39)
          v61 = dword_1000EB4E8 <= 3;
        else
          v61 = 0;
        if (v61)
        {
          v199 = *__error();
          v200 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Didn't already return without report option"), "report");
          v201 = v200;
          if (v200)
          {
            v213 = (char *)CFStringGetCStringPtr(v200, 0x8000100u);
            if (v213)
            {
              v214 = 0;
            }
            else
            {
              v213 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA3F8821CuLL);
              CFStringGetCString(v201, v213, 1024, 0x8000100u);
              v214 = v213;
            }
            if (qword_1000EBD40)
              v215 = (FILE *)qword_1000EBD40;
            else
              v215 = __stderrp;
            fprintf(v215, "%s\n", v213);
            if (v214)
              free(v214);
            CFRelease(v201);
          }
          else
          {
            v202 = sub_100030318();
            if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT))
              sub_10008AC8C(v202, v203, v204, v205, v206, v207, v208, v209);
            if (qword_1000EBD40)
              v210 = (FILE *)qword_1000EBD40;
            else
              v210 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v210);
          }
          *__error() = v199;
        }
        sub_1000301F0("_HandleMicrostackshots", "microstackshot.m", 555, "%s: Didn't already return without report option", a5, a6, a7, a8, (char)"report");
        abort();
      }
    }
    v116 = objc_alloc((Class)SASampleStore);
    if (v17)
    {
      v30 = objc_msgSend(v116, "initForLiveSampling");
      objc_msgSend(v30, "setShouldGatherKextStat:", 0);
      if (!a11)
      {
LABEL_199:
        if (a12 && *(_DWORD *)a12 && *(_DWORD *)(a12 + 4))
          objc_msgSend(v30, "setMachTimebase:", *(_QWORD *)a12);
        if (a13)
          objc_msgSend(v30, "setHwPageSize:", a13);
        if (a14)
          objc_msgSend(v30, "setVmPageSize:", a14);
        if ((byte_1000EBD4C & 2) != 0 && sub_100025FB4())
        {
          if (byte_1000EBD38)
          {
            v117 = *__error();
            v118 = sub_100030318();
            if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "Avoiding inspecting live processes for microstackshot report due to audio running", buf, 2u);
            }
            *__error() = v117;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
          {
            v119 = *__error();
            v120 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Avoiding inspecting live processes for microstackshot report due to audio running"));
            v121 = v120;
            if (v120)
            {
              v122 = (char *)CFStringGetCStringPtr(v120, 0x8000100u);
              if (v122)
              {
                v123 = 0;
              }
              else
              {
                v122 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x998CF6E7uLL);
                CFStringGetCString(v121, v122, 1024, 0x8000100u);
                v123 = v122;
              }
              if (qword_1000EBD40)
                v126 = (FILE *)qword_1000EBD40;
              else
                v126 = __stderrp;
              fprintf(v126, "%s\n", v122);
              if (v123)
                free(v123);
              CFRelease(v121);
            }
            else
            {
              v124 = sub_100030318();
              if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT))
                sub_10008A8EC();
              if (qword_1000EBD40)
                v125 = (FILE *)qword_1000EBD40;
              else
                v125 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v125);
            }
            *__error() = v119;
          }
          objc_msgSend(v30, "setDataGatheringOptions:", (unint64_t)objc_msgSend(v30, "dataGatheringOptions") & 0xFFFFFFFFFFFFFFFDLL);
        }
        sub_10005993C(v30, (byte_1000EBD4C >> 3) & 1, (byte_1000EBD4C >> 2) & 1, (byte_1000EBD4C & 0x10) == 0);
        *(_QWORD *)buf = 0;
        v237 = buf;
        v238 = 0x2020000000;
        v239 = 0;
        v234[0] = 0;
        v234[1] = v234;
        v234[2] = 0x2020000000;
        v235 = 0;
        v127 = dispatch_semaphore_create(0);
        dispatch_retain(v127);
        v128 = xpc_dictionary_create_empty();
        v129 = v128;
        if (a9 > 0.0)
          xpc_dictionary_set_uint64(v128, "time", (unint64_t)(kCFAbsoluteTimeIntervalSince1970 + a9));
        if (value >= 1)
          xpc_dictionary_set_uint64(v129, "pid", value);
        v130 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
        v131 = dispatch_queue_create("com.apple.spindump.microstackshot_parsing", v130);
        dispatch_release(v130);
        dispatch_retain(v131);
        v230[0] = _NSConcreteStackBlock;
        v230[1] = 3221225472;
        v230[2] = sub_10002C7E0;
        v230[3] = &unk_1000DD270;
        v231 = qos_class_self();
        v232 = v51;
        v233 = value;
        *(double *)&v230[11] = a9;
        *(double *)&v230[12] = a10;
        v230[4] = v30;
        v230[5] = a15;
        v230[7] = v131;
        v230[8] = v234;
        v230[9] = buf;
        v230[10] = a4;
        v230[6] = v127;
        systemstats_get_microstackshots(v129, v230);
        xpc_release(v129);
        v226 = 0;
        v227 = &v226;
        v228 = 0x2020000000;
        v229 = 0;
        do
        {
          v132 = dispatch_time(0, 30000000000);
          if (!dispatch_semaphore_wait(v127, v132))
            break;
          value_4[0] = _NSConcreteStackBlock;
          value_4[1] = 3221225472;
          value_4[2] = sub_10004CAD8;
          value_4[3] = &unk_1000DD298;
          value_4[4] = v234;
          value_4[5] = &v226;
          dispatch_sync(v131, value_4);
        }
        while (!*((_BYTE *)v227 + 24));
        dispatch_release(v127);
        dispatch_release(v131);
        if (*((_QWORD *)v237 + 3))
        {
          if (byte_1000EBD38)
          {
            v133 = *__error();
            v134 = sub_100030318();
            if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
            {
              v135 = *((_DWORD *)v237 + 6);
              v136 = strerror(v135);
              sub_10008AA50((uint64_t)v136, (uint64_t)v241, v135);
            }
            *__error() = v133;
          }
          if (byte_1000EBD39)
            v137 = dword_1000EB4E8 <= 3;
          else
            v137 = 0;
          if (v137)
          {
            v138 = *__error();
            v139 = *((unsigned int *)v237 + 6);
            v140 = strerror(*((_DWORD *)v237 + 6));
            v141 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error grabbing microstackshots: %d (%s)"), v139, v140);
            v142 = v141;
            if (v141)
            {
              v143 = (char *)CFStringGetCStringPtr(v141, 0x8000100u);
              if (v143)
              {
                v144 = 0;
              }
              else
              {
                v143 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x186D4021uLL);
                CFStringGetCString(v142, v143, 1024, 0x8000100u);
                v144 = v143;
              }
              if (qword_1000EBD40)
                v149 = (FILE *)qword_1000EBD40;
              else
                v149 = __stderrp;
              fprintf(v149, "%s\n", v143);
              if (v144)
                free(v144);
              CFRelease(v142);
            }
            else
            {
              v145 = sub_100030318();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT))
              {
                v146 = *((_DWORD *)v237 + 6);
                v147 = strerror(v146);
                sub_10008AA14((uint64_t)v147, (uint64_t)v240, v146);
              }
              if (qword_1000EBD40)
                v148 = (FILE *)qword_1000EBD40;
              else
                v148 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v148);
            }
            *__error() = v138;
          }
        }
        objc_msgSend(v30, "postprocess");
        _Block_object_dispose(&v226, 8);
        _Block_object_dispose(v234, 8);
        _Block_object_dispose(buf, 8);
        return v30;
      }
    }
    else
    {
      v30 = objc_msgSend(v116, "initForFileParsing");
      if (!a11)
        goto LABEL_199;
    }
    objc_msgSend(v30, "setMachineArchitecture:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a11));
    goto LABEL_199;
  }
  v25 = open(a1, 0);
  if (v25 != -1)
  {
    v26 = v25;
    if (a2 && lseek(v25, a2, 0) == -1)
    {
      if (byte_1000EBD38)
      {
        v79 = *__error();
        v80 = sub_100030318();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          sub_10008A99C();
        *__error() = v79;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v81 = *__error();
        v82 = *__error();
        v83 = __error();
        v84 = strerror(*v83);
        v85 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to seek %s to offset %lld: %d (%s)"), a1, a2, v82, v84);
        v86 = v85;
        if (v85)
        {
          v87 = (char *)CFStringGetCStringPtr(v85, 0x8000100u);
          if (v87)
          {
            v88 = 0;
          }
          else
          {
            v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8B1AFD4uLL);
            CFStringGetCString(v86, v87, 1024, 0x8000100u);
            v88 = v87;
          }
          if (qword_1000EBD40)
            v99 = (FILE *)qword_1000EBD40;
          else
            v99 = __stderrp;
          fprintf(v99, "%s\n", v87);
          if (v88)
            free(v88);
          CFRelease(v86);
        }
        else
        {
          v94 = sub_100030318();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
            sub_10008A918();
          if (qword_1000EBD40)
            v95 = (FILE *)qword_1000EBD40;
          else
            v95 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
        }
        *__error() = v81;
      }
    }
    else
    {
      v27 = gzdopen(v26, "r");
      if (v27)
      {
        v28 = v27;
        v29 = objc_alloc((Class)SASampleStore);
        if (v17)
        {
          v30 = objc_msgSend(v29, "initForLiveSampling");
          objc_msgSend(v30, "setShouldGatherKextStat:", 0);
          if (!a11)
          {
LABEL_62:
            if (a12 && *(_DWORD *)a12 && *(_DWORD *)(a12 + 4))
              objc_msgSend(v30, "setMachTimebase:", *(_QWORD *)a12);
            if (a13)
              objc_msgSend(v30, "setHwPageSize:", a13);
            if (a14)
              objc_msgSend(v30, "setVmPageSize:", a14);
            if ((byte_1000EBD4C & 2) != 0 && sub_100025FB4())
            {
              if (byte_1000EBD38)
              {
                v72 = *__error();
                v73 = sub_100030318();
                if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "Avoiding inspecting live processes for microstackshot report due to audio running", buf, 2u);
                }
                *__error() = v72;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
              {
                v74 = *__error();
                v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Avoiding inspecting live processes for microstackshot report due to audio running"));
                v76 = v75;
                if (v75)
                {
                  v77 = (char *)CFStringGetCStringPtr(v75, 0x8000100u);
                  if (v77)
                  {
                    v78 = 0;
                  }
                  else
                  {
                    v77 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC4DFE513uLL);
                    CFStringGetCString(v76, v77, 1024, 0x8000100u);
                    v78 = v77;
                  }
                  if (qword_1000EBD40)
                    v112 = (FILE *)qword_1000EBD40;
                  else
                    v112 = __stderrp;
                  fprintf(v112, "%s\n", v77);
                  if (v78)
                    free(v78);
                  CFRelease(v76);
                }
                else
                {
                  v100 = sub_100030318();
                  if (os_log_type_enabled(v100, OS_LOG_TYPE_FAULT))
                    sub_10008A8EC();
                  if (qword_1000EBD40)
                    v101 = (FILE *)qword_1000EBD40;
                  else
                    v101 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v101);
                }
                *__error() = v74;
              }
              objc_msgSend(v30, "setDataGatheringOptions:", (unint64_t)objc_msgSend(v30, "dataGatheringOptions") & 0xFFFFFFFFFFFFFFFDLL);
            }
            sub_10005993C(v30, (byte_1000EBD4C >> 3) & 1, (byte_1000EBD4C >> 2) & 1, (byte_1000EBD4C & 0x10) == 0);
            sub_10002C8C0(v30, v28, 0, 0, v15, value, a4, a15, a9, a10);
            gzclose(v28);
            objc_msgSend(v30, "postprocess");
            return v30;
          }
        }
        else
        {
          v30 = objc_msgSend(v29, "initForFileParsing");
          if (!a11)
            goto LABEL_62;
        }
        objc_msgSend(v30, "setMachineArchitecture:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a11));
        goto LABEL_62;
      }
      if (byte_1000EBD38)
      {
        v62 = *__error();
        v63 = sub_100030318();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          sub_10008A878();
        *__error() = v62;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v64 = *__error();
        v65 = *__error();
        v66 = __error();
        v67 = strerror(*v66);
        v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to gzdopen datastore file %s: %d (%s)"), a1, v65, v67);
        v69 = v68;
        if (v68)
        {
          v70 = (char *)CFStringGetCStringPtr(v68, 0x8000100u);
          if (v70)
          {
            v71 = 0;
          }
          else
          {
            v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9BD42F74uLL);
            CFStringGetCString(v69, v70, 1024, 0x8000100u);
            v71 = v70;
          }
          if (qword_1000EBD40)
            v96 = (FILE *)qword_1000EBD40;
          else
            v96 = __stderrp;
          fprintf(v96, "%s\n", v70);
          if (v71)
            free(v71);
          CFRelease(v69);
        }
        else
        {
          v92 = sub_100030318();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
            sub_10008A7F4();
          if (qword_1000EBD40)
            v93 = (FILE *)qword_1000EBD40;
          else
            v93 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
        }
        *__error() = v64;
      }
    }
    close(v26);
    return 0;
  }
  if (byte_1000EBD38)
  {
    v40 = *__error();
    v41 = sub_100030318();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      sub_10008A780();
    *__error() = v40;
  }
  if (byte_1000EBD39)
    v42 = dword_1000EB4E8 <= 3;
  else
    v42 = 0;
  if (!v42)
    return 0;
  v43 = *__error();
  v44 = *__error();
  v45 = __error();
  v46 = strerror(*v45);
  v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to open %s: %d (%s)"), a1, v44, v46);
  v48 = v47;
  if (v47)
  {
    v49 = (char *)CFStringGetCStringPtr(v47, 0x8000100u);
    if (v49)
    {
      v50 = 0;
    }
    else
    {
      v49 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x49473BC4uLL);
      CFStringGetCString(v48, v49, 1024, 0x8000100u);
      v50 = v49;
    }
    if (qword_1000EBD40)
      v91 = (FILE *)qword_1000EBD40;
    else
      v91 = __stderrp;
    fprintf(v91, "%s\n", v49);
    if (v50)
      free(v50);
    CFRelease(v48);
  }
  else
  {
    v89 = sub_100030318();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
      sub_10008A6FC();
    if (qword_1000EBD40)
      v90 = (FILE *)qword_1000EBD40;
    else
      v90 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
  }
  v30 = 0;
  *__error() = v43;
  return v30;
}

void sub_10002C778(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 256), 8);
  _Block_object_dispose((const void *)(v26 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_10002C7E0(uint64_t a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  dispatch_qos_class_t v8;
  dispatch_block_t v9;
  _QWORD block[5];
  __int128 v11;
  uint64_t v12;
  __int128 v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t v20;

  if (a4 != 54)
  {
    v19 = v4;
    v20 = v5;
    v8 = *(_DWORD *)(a1 + 104);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004C864;
    block[3] = &unk_1000DD248;
    block[4] = a3;
    v16 = *(_QWORD *)(a1 + 108);
    v14 = *(_QWORD *)(a1 + 80);
    v15 = *(_OWORD *)(a1 + 88);
    v11 = *(_OWORD *)(a1 + 32);
    v18 = a2;
    v13 = *(_OWORD *)(a1 + 64);
    v17 = a4;
    v12 = *(_QWORD *)(a1 + 48);
    v9 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, v8, 0, block);
    dispatch_sync(*(dispatch_queue_t *)(a1 + 56), v9);
    _Block_release(v9);
    if (a2)
    {
      dispatch_release(*(dispatch_object_t *)(a1 + 56));
      dispatch_release(*(dispatch_object_t *)(a1 + 48));
    }
  }
}

void sub_10002C8C0(void *a1, gzFile_s *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10)
{
  void *v10;
  uint64_t v13;
  id v17;
  unint64_t v18;
  int v19;
  NSObject *v20;
  int v22;
  const __CFString *v23;
  const __CFString *v24;
  const char *CStringPtr;
  malloc_type_id_t v26;
  char *v28;
  unint64_t v29;
  char *v30;
  size_t v31;
  char v32;
  unint64_t v33;
  int v34;
  size_t v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  size_t v45;
  char *v46;
  unint64_t v47;
  int v48;
  NSObject *v49;
  unint64_t v50;
  int v51;
  const __CFString *v52;
  NSObject *v53;
  FILE *v54;
  const char *v55;
  uint64_t v56;
  int v57;
  NSObject *v58;
  BOOL v59;
  int v60;
  const __CFString *v61;
  const __CFString *v62;
  const char *v63;
  char *v64;
  char *v65;
  NSObject *v66;
  int v67;
  NSObject *v68;
  BOOL v69;
  uint64_t v70;
  char *v71;
  const __CFString *v72;
  const __CFString *v73;
  const char *v74;
  char *v75;
  char *v76;
  NSObject *v77;
  FILE *v78;
  const __CFString *v79;
  NSObject *v80;
  FILE *v81;
  FILE *v82;
  int v83;
  NSObject *v84;
  const __CFString *v86;
  char *v87;
  char *v88;
  NSObject *v89;
  FILE *v90;
  FILE *v91;
  int v92;
  NSObject *v93;
  int v94;
  const __CFString *v95;
  NSObject *v96;
  FILE *v97;
  const __CFString *v98;
  const char *v99;
  char *v100;
  char *v101;
  int v102;
  NSObject *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  BOOL v111;
  int v112;
  const __CFString *v113;
  NSObject *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  FILE *v122;
  FILE *v123;
  const __CFString *v124;
  const char *v125;
  char *v126;
  char *v127;
  FILE *v128;
  const __CFString *v129;
  const char *v130;
  char *v131;
  char *v132;
  FILE *v133;
  unsigned int v134;
  char v135;
  int errnum;

  v10 = (void *)a8;
  v13 = a7;
  if (a3)
  {
    v17 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytesNoCopy:length:freeWhenDone:", a3, a4, 0);
    v18 = (unint64_t)objc_msgSend(a1, "addMicrostackshotsFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:", v17, a5, a6, v13, v10, a9, a10);

    if ((v18 & 0x8000000000000000) == 0)
      return;
    if (byte_1000EBD38)
    {
      v19 = *__error();
      v20 = sub_100030318();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_10008C580();
      *__error() = v19;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      return;
    v22 = *__error();
    v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Data does not contain microstackshots"));
    if (v23)
    {
      v24 = v23;
      CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
      if (!CStringPtr)
      {
        v26 = 1380284601;
LABEL_112:
        v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v26);
        CFStringGetCString(v24, v87, 1024, 0x8000100u);
        v88 = v87;
        goto LABEL_113;
      }
      goto LABEL_104;
    }
    v66 = sub_100030318();
    if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
      sub_10008C554();
    goto LABEL_107;
  }
  if (!a2)
  {
    if (byte_1000EBD38)
    {
      v102 = *__error();
      v103 = sub_100030318();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        sub_10008C4E4(v103, v104, v105, v106, v107, v108, v109, v110);
      *__error() = v102;
    }
    if (byte_1000EBD39)
      v111 = dword_1000EB4E8 <= 3;
    else
      v111 = 0;
    if (v111)
    {
      v112 = *__error();
      v113 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No tracebuf nor gzfile"), "gzfile");
      if (v113)
      {
        v129 = v113;
        v130 = CFStringGetCStringPtr(v113, 0x8000100u);
        if (v130)
        {
          v131 = (char *)v130;
          v132 = 0;
        }
        else
        {
          v131 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD5BE80DuLL);
          CFStringGetCString(v129, v131, 1024, 0x8000100u);
          v132 = v131;
        }
        if (qword_1000EBD40)
          v133 = (FILE *)qword_1000EBD40;
        else
          v133 = __stderrp;
        fprintf(v133, "%s\n", v131);
        if (v132)
          free(v132);
        CFRelease(v129);
      }
      else
      {
        v114 = sub_100030318();
        if (os_log_type_enabled(v114, OS_LOG_TYPE_FAULT))
          sub_10008C474(v114, v115, v116, v117, v118, v119, v120, v121);
        if (qword_1000EBD40)
          v122 = (FILE *)qword_1000EBD40;
        else
          v122 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
      }
      *__error() = v112;
    }
    sub_1000301F0("_ParseMicrostackshot", "microstackshot.m", 699, "%s: No tracebuf nor gzfile", a5, a6, a7, a8, (char)"gzfile");
LABEL_183:
    abort();
  }
  v134 = a5;
  v28 = (char *)malloc_type_calloc(1uLL, 0x20000uLL, 0xDB5703AFuLL);
  v29 = 0x20000;
  v30 = v28;
  v31 = 0;
  v32 = 0;
  while (1)
  {
    v33 = v29;
    v34 = gzread(a2, &v30[v31], v29 - v31);
    v135 = v32;
    if (v34 <= 0)
      break;
    v35 = v31 + v34;
    v36 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytesNoCopy:length:freeWhenDone:", v30, v35, 0);
    v37 = v13;
    v38 = v13;
    v39 = v10;
    v40 = (unint64_t)objc_msgSend(a1, "addMicrostackshotsFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:", v36, v134, a6, v38, v10, a9, a10);

    if ((v40 & 0x8000000000000000) != 0)
      goto LABEL_92;
    v31 = v35 - v40;
    if (!v31)
      goto LABEL_22;
    if (v40)
    {
      memmove(v30, &v30[v40], v31);
LABEL_22:
      v29 = v33;
      goto LABEL_25;
    }
    v45 = 2 * v33;
    v46 = (char *)reallocf(v30, v45);
    if (!v46)
    {
      if (byte_1000EBD38)
      {
        v92 = *__error();
        v93 = sub_100030318();
        if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
          sub_10008C8EC();
        *__error() = v92;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v94 = *__error();
        v95 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: realloc to %lu failed"), "buf", v45);
        if (v95)
        {
          v124 = v95;
          v125 = CFStringGetCStringPtr(v95, 0x8000100u);
          if (v125)
          {
            v126 = (char *)v125;
            v127 = 0;
          }
          else
          {
            v126 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x25C99642uLL);
            CFStringGetCString(v124, v126, 1024, 0x8000100u);
            v127 = v126;
          }
          if (qword_1000EBD40)
            v128 = (FILE *)qword_1000EBD40;
          else
            v128 = __stderrp;
          fprintf(v128, "%s\n", v126);
          if (v127)
            free(v127);
          CFRelease(v124);
        }
        else
        {
          v96 = sub_100030318();
          if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT))
            sub_10008C87C();
          if (qword_1000EBD40)
            v97 = (FILE *)qword_1000EBD40;
          else
            v97 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v97);
        }
        *__error() = v94;
      }
      sub_1000301F0("_ParseMicrostackshot", "microstackshot.m", 750, "%s: realloc to %lu failed", v41, v42, v43, v44, (char)"buf");
      goto LABEL_183;
    }
    v30 = v46;
    v29 = v45;
LABEL_25:
    v32 = 1;
    v10 = v39;
    v13 = v37;
    if (v31 >= v29)
    {
      if (byte_1000EBD38)
      {
        v47 = v29;
        v48 = *__error();
        v49 = sub_100030318();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
          sub_10008C7FC();
        *__error() = v48;
        v29 = v47;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v50 = v29;
        v51 = *__error();
        v52 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: buf %lu, cap %lu"), "bufLength < bufCapacity", v31, v50);
        if (v52)
        {
          v98 = v52;
          v99 = CFStringGetCStringPtr(v52, 0x8000100u);
          if (v99)
          {
            v100 = (char *)v99;
            v101 = 0;
          }
          else
          {
            v100 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x49E8A663uLL);
            CFStringGetCString(v98, v100, 1024, 0x8000100u);
            v101 = v100;
          }
          if (qword_1000EBD40)
            v123 = (FILE *)qword_1000EBD40;
          else
            v123 = __stderrp;
          fprintf(v123, "%s\n", v100);
          if (v101)
            free(v101);
          CFRelease(v98);
        }
        else
        {
          v53 = sub_100030318();
          if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
            sub_10008C77C();
          if (qword_1000EBD40)
            v54 = (FILE *)qword_1000EBD40;
          else
            v54 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v54);
        }
        *__error() = v51;
      }
      sub_1000301F0("_ParseMicrostackshot", "microstackshot.m", 753, "%s: buf %lu, cap %lu", v41, v42, v43, v44, (char)"bufLength < bufCapacity");
      goto LABEL_183;
    }
  }
  if (v34 != -1)
  {
    objc_msgSend(v10, "setBytes_not_microstackshots:", (char *)objc_msgSend(v10, "bytes_not_microstackshots") + v31);
    goto LABEL_92;
  }
  errnum = 0;
  v55 = gzerror(a2, &errnum);
  if (errnum != -1)
  {
    v56 = (uint64_t)v55;
    if (byte_1000EBD38)
    {
      v57 = *__error();
      v58 = sub_100030318();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        sub_10008C700(&errnum, v56, v58);
      *__error() = v57;
    }
    if (byte_1000EBD39)
      v59 = dword_1000EB4E8 <= 3;
    else
      v59 = 0;
    if (!v59)
      goto LABEL_92;
    v60 = *__error();
    v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Read failed for microstackshots: %d (%s)"), errnum, v56);
    if (v61)
    {
      v62 = v61;
      v63 = CFStringGetCStringPtr(v61, 0x8000100u);
      if (v63)
      {
        v64 = (char *)v63;
        v65 = 0;
      }
      else
      {
        v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCD438DFBuLL);
        CFStringGetCString(v62, v64, 1024, 0x8000100u);
        v65 = v64;
      }
      if (qword_1000EBD40)
        v78 = (FILE *)qword_1000EBD40;
      else
        v78 = __stderrp;
      fprintf(v78, "%s\n", v64);
      if (v65)
        free(v65);
      v79 = v62;
      goto LABEL_90;
    }
    v77 = sub_100030318();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
      sub_10008C684(&errnum, v56, v77);
LABEL_79:
    if (qword_1000EBD40)
      v81 = (FILE *)qword_1000EBD40;
    else
      v81 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
    goto LABEL_91;
  }
  errnum = *__error();
  if (byte_1000EBD38)
  {
    v67 = *__error();
    v68 = sub_100030318();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      sub_10008C614(&errnum, v68);
    *__error() = v67;
  }
  if (byte_1000EBD39)
    v69 = dword_1000EB4E8 <= 3;
  else
    v69 = 0;
  if (v69)
  {
    v60 = *__error();
    v70 = errnum;
    v71 = strerror(errnum);
    v72 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Read failed for microstackshots: %d (%s)"), v70, v71);
    if (!v72)
    {
      v80 = sub_100030318();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
        sub_10008C5AC(&errnum);
      goto LABEL_79;
    }
    v73 = v72;
    v74 = CFStringGetCStringPtr(v72, 0x8000100u);
    if (v74)
    {
      v75 = (char *)v74;
      v76 = 0;
    }
    else
    {
      v75 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x547E2851uLL);
      CFStringGetCString(v73, v75, 1024, 0x8000100u);
      v76 = v75;
    }
    if (qword_1000EBD40)
      v82 = (FILE *)qword_1000EBD40;
    else
      v82 = __stderrp;
    fprintf(v82, "%s\n", v75);
    if (v76)
      free(v76);
    v79 = v73;
LABEL_90:
    CFRelease(v79);
LABEL_91:
    *__error() = v60;
  }
LABEL_92:
  if ((v135 & 1) == 0)
  {
    if (byte_1000EBD38)
    {
      v83 = *__error();
      v84 = sub_100030318();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
        sub_10008C580();
      *__error() = v83;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v22 = *__error();
      v86 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Data does not contain microstackshots"));
      if (v86)
      {
        v24 = v86;
        CStringPtr = CFStringGetCStringPtr(v86, 0x8000100u);
        if (!CStringPtr)
        {
          v26 = 2824655356;
          goto LABEL_112;
        }
LABEL_104:
        v87 = (char *)CStringPtr;
        v88 = 0;
LABEL_113:
        if (qword_1000EBD40)
          v91 = (FILE *)qword_1000EBD40;
        else
          v91 = __stderrp;
        fprintf(v91, "%s\n", v87);
        if (v88)
          free(v88);
        CFRelease(v24);
LABEL_119:
        *__error() = v22;
        return;
      }
      v89 = sub_100030318();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
        sub_10008C554();
LABEL_107:
      if (qword_1000EBD40)
        v90 = (FILE *)qword_1000EBD40;
      else
        v90 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
      goto LABEL_119;
    }
  }
}

uint64_t sub_10002D568(char *a1, int a2, long double a3, long double a4)
{
  uint64_t v8;
  int v9;
  char *v10;
  char *v11;

  v8 = a2;
  v9 = snprintf(a1, a2, "Start time:      ");
  v10 = &a1[v9];
  v11 = &a1[a2];
  if (v9 < a2)
    v10 += sub_1000266AC(&a1[v9], v8 - v9, 0, a3);
  if (v10 < v11)
    v10 += snprintf(v10, &a1[v8] - v10, "\nEnd time:        ");
  if (v10 < v11)
    v10 += sub_1000266AC(v10, &a1[v8] - v10, 0, a4);
  if (v10 < v11)
    LODWORD(v10) = (_DWORD)v10 + snprintf(v10, &a1[v8] - v10, "\n");
  return ((_DWORD)v10 - (_DWORD)a1);
}

BOOL sub_10002D658(const char *a1)
{
  stat v2;

  memset(&v2, 0, sizeof(v2));
  return lstat(a1, &v2) == 0;
}

BOOL sub_10002D698()
{
  char v0;
  _BOOL8 result;
  char v2;

  byte_1000EBD4C = byte_1000EBD4C & 0xFC | 1;
  if (sub_10002D658("/var/db/.spindump_enable_symbolication"))
    v0 = 8;
  else
    v0 = 16;
  byte_1000EBD4C = v0 | byte_1000EBD4C & 0xE3;
  result = sub_10002D658("/var/db/.spindump_disable_exclaves");
  if (result)
    v2 = 32;
  else
    v2 = 0;
  byte_1000EBD4C = byte_1000EBD4C & 0xDF | v2;
  return result;
}

uint64_t sub_10002D718(const char *a1, int a2, int a3, unsigned int a4)
{
  __int16 v6;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int v13;
  stat v15;
  stat v16;

  v6 = a2;
  memset(&v16, 0, sizeof(v16));
  memset(&v15.st_atimespec, 0, 112);
  if ((a2 & 0x200) != 0)
    v8 = -3585;
  else
    v8 = -1025;
  v9 = v8 & a2;
  memset(&v15, 0, 32);
  if (lstat(a1, &v15) < 0)
  {
    v12 = __error();
    v10 = 0xFFFFFFFFLL;
    if ((v6 & 0x200) != 0 && *v12 == 2)
    {
      v13 = open(a1, v9 | 0xA00, a4);
      if (v13 < 0)
        return 0xFFFFFFFFLL;
      else
        return v13;
    }
  }
  else
  {
    v10 = 0xFFFFFFFFLL;
    if ((v15.st_mode & 0xF000) == 0x8000 && v15.st_nlink == 1 && v15.st_uid == a3 && (v15.st_mode & 0xFFF) == a4)
    {
      v11 = open(a1, v9, 0);
      if ((v11 & 0x80000000) == 0)
      {
        v10 = v11;
        if (!fstat(v11, &v16)
          && v16.st_nlink == v15.st_nlink
          && v16.st_uid == v15.st_uid
          && v16.st_mode == v15.st_mode
          && v16.st_ino == v15.st_ino
          && v16.st_dev == v15.st_dev)
        {
          if ((v6 & 0x400) != 0)
            ftruncate(v10, 0);
        }
        else
        {
          close(v10);
          return 0xFFFFFFFFLL;
        }
      }
    }
  }
  return v10;
}

void sub_10002D8B4(const char *a1)
{
  uint64_t v2;
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  time_t v8;
  double v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  BOOL v13;
  int v14;
  const __CFString *v15;
  const __CFString *v16;
  const char *CStringPtr;
  char *v18;
  char *v19;
  time_t v20;
  int v21;
  NSObject *v22;
  BOOL v23;
  int v24;
  const __CFString *v25;
  const __CFString *v26;
  const char *v27;
  malloc_type_id_t v28;
  time_t v29;
  int v30;
  NSObject *v31;
  BOOL v32;
  const __CFString *v33;
  time_t v34;
  int v35;
  NSObject *v36;
  const __CFString *v37;
  time_t v38;
  int v39;
  NSObject *v40;
  const __CFString *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  double v48;
  char *v49;
  const __CFLocale *v50;
  const __CFString *v51;
  uint64_t v52;
  __CFDateFormatter *v53;
  uint64_t v54;
  __CFDateFormatter *v55;
  NSObject *v56;
  FILE *v57;
  int v58;
  NSObject *v59;
  int v60;
  double v61;
  const __CFString *v62;
  const __CFString *v63;
  const char *v64;
  malloc_type_id_t v65;
  int v66;
  NSObject *v67;
  const __CFString *v68;
  char *v69;
  char *v70;
  NSObject *v71;
  int v72;
  NSObject *v73;
  BOOL v74;
  int v75;
  NSObject *v76;
  int v77;
  const __CFString *v78;
  const __CFString *v79;
  const char *v80;
  char *v81;
  char *v82;
  FILE *v83;
  NSObject *v84;
  NSObject *v85;
  NSObject *v86;
  FILE *v87;
  NSObject *v88;
  FILE *v89;
  NSObject *v90;
  FILE *v91;
  int v92;
  const __CFString *v93;
  const __CFString *v94;
  const char *v95;
  char *v96;
  char *v97;
  FILE *v98;
  FILE *v99;
  FILE *v100;
  NSObject *v101;
  FILE *v102;
  NSObject *v103;
  uint64_t v104;
  FILE *v105;
  int v106;
  NSObject *v107;
  int v108;
  const __CFString *v109;
  NSObject *v110;
  FILE *v111;
  const __CFString *v112;
  const char *v113;
  char *v114;
  char *v115;
  FILE *v116;
  time_t v117;
  tm v118;
  CFAbsoluteTime atp;
  tm v120;
  char *__endptr;
  _OWORD v122[8];

  __endptr = 0;
  v2 = strtol(a1, &__endptr, 0);
  if (__endptr != a1 && !*__endptr)
  {
    v10 = v2;
    if (byte_1000EBD38)
    {
      v11 = *__error();
      v12 = sub_100030318();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        sub_10008FBDC();
      *__error() = v11;
    }
    if (byte_1000EBD39)
      v13 = dword_1000EB4E8 <= 0;
    else
      v13 = 0;
    if (v13)
    {
      v14 = *__error();
      v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found unix timestamp %ld"), v10);
      if (v15)
      {
        v16 = v15;
        CStringPtr = CFStringGetCStringPtr(v15, 0x8000100u);
        if (CStringPtr)
        {
          v18 = (char *)CStringPtr;
          v19 = 0;
        }
        else
        {
          v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA0A622E3uLL);
          CFStringGetCString(v16, v18, 1024, 0x8000100u);
          v19 = v18;
        }
        if (qword_1000EBD40)
          v83 = (FILE *)qword_1000EBD40;
        else
          v83 = __stderrp;
        fprintf(v83, "%s\n", v18);
        if (v19)
          free(v19);
        CFRelease(v16);
      }
      else
      {
        v56 = sub_100030318();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
          sub_10008FB78();
        if (qword_1000EBD40)
          v57 = (FILE *)qword_1000EBD40;
        else
          v57 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v57);
      }
      *__error() = v14;
    }
    return;
  }
  memset(&v120, 0, sizeof(v120));
  v120.tm_isdst = -1;
  v3 = strptime(a1, "%Y-%m-%d %T %z", &v120);
  __endptr = v3;
  if (v3 && !*v3)
  {
    v20 = mktime(&v120);
    if (byte_1000EBD38)
    {
      v21 = *__error();
      v22 = sub_100030318();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        sub_10008FB18();
      *__error() = v21;
    }
    if (byte_1000EBD39)
      v23 = dword_1000EB4E8 <= 0;
    else
      v23 = 0;
    if (!v23)
      return;
    v24 = *__error();
    v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found ISO timestamp with time zone number %ld"), v20);
    if (v25)
    {
      v26 = v25;
      v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (!v27)
      {
        v28 = 1503249402;
        goto LABEL_192;
      }
      goto LABEL_69;
    }
    v71 = sub_100030318();
    if (!os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
      goto LABEL_159;
LABEL_113:
    sub_10008FAB4();
    goto LABEL_159;
  }
  v4 = strptime(a1, "%Y-%m-%dT%T %z", &v120);
  if (v4 && !*v4)
  {
    v29 = mktime(&v120);
    if (byte_1000EBD38)
    {
      v30 = *__error();
      v31 = sub_100030318();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        sub_10008FB18();
      *__error() = v30;
    }
    if (byte_1000EBD39)
      v32 = dword_1000EB4E8 <= 0;
    else
      v32 = 0;
    if (!v32)
      return;
    v24 = *__error();
    v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found ISO timestamp with time zone number %ld"), v29);
    if (v33)
    {
      v26 = v33;
      v27 = CFStringGetCStringPtr(v33, 0x8000100u);
      if (!v27)
      {
        v28 = 40582745;
        goto LABEL_192;
      }
      goto LABEL_69;
    }
    v84 = sub_100030318();
    if (!os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
      goto LABEL_159;
    goto LABEL_113;
  }
  v5 = strptime(a1, "%Y-%m-%d %T %Z", &v120);
  __endptr = v5;
  if (v5 && !*v5)
  {
    v34 = mktime(&v120);
    if (byte_1000EBD38)
    {
      v35 = *__error();
      v36 = sub_100030318();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        sub_10008FA54();
      *__error() = v35;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
      return;
    v24 = *__error();
    v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found ISO timestamp with time zone name %ld"), v34);
    if (!v37)
    {
      v85 = sub_100030318();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
LABEL_158:
        sub_10008F9F0();
LABEL_159:
      if (qword_1000EBD40)
        v91 = (FILE *)qword_1000EBD40;
      else
        v91 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v91);
LABEL_199:
      *__error() = v24;
      return;
    }
    v26 = v37;
    v27 = CFStringGetCStringPtr(v37, 0x8000100u);
    if (!v27)
    {
      v28 = 1147833939;
      goto LABEL_192;
    }
LABEL_69:
    v42 = (char *)v27;
    v43 = 0;
LABEL_193:
    if (qword_1000EBD40)
      v100 = (FILE *)qword_1000EBD40;
    else
      v100 = __stderrp;
    fprintf(v100, "%s\n", v42);
    if (v43)
      free(v43);
    CFRelease(v26);
    goto LABEL_199;
  }
  v6 = strptime(a1, "%Y-%m-%dT%T %Z", &v120);
  if (v6 && !*v6)
  {
    v38 = mktime(&v120);
    if (byte_1000EBD38)
    {
      v39 = *__error();
      v40 = sub_100030318();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
        sub_10008FA54();
      *__error() = v39;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
      return;
    v24 = *__error();
    v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found ISO timestamp with time zone name %ld"), v38);
    if (v41)
    {
      v26 = v41;
      v27 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v27)
        goto LABEL_69;
      v28 = 134103016;
LABEL_192:
      v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v28);
      CFStringGetCString(v26, v42, 1024, 0x8000100u);
      v43 = v42;
      goto LABEL_193;
    }
    v90 = sub_100030318();
    if (os_log_type_enabled(v90, OS_LOG_TYPE_FAULT))
      goto LABEL_158;
    goto LABEL_159;
  }
  v7 = strptime(a1, "%Y-%m-%d %T", &v120);
  __endptr = v7;
  if (v7 || (v7 = strptime(a1, "%Y-%m-%dT%T", &v120), (__endptr = v7) != 0))
  {
    if (*v7 == 46)
    {
      *(_QWORD *)&v122[0] = 0;
      v48 = strtod(v7 - 2, (char **)v122);
      if (*(_QWORD *)&v122[0] <= (unint64_t)v7)
      {
        if (byte_1000EBD38)
        {
          v106 = *__error();
          v107 = sub_100030318();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
            sub_10008F96C();
          *__error() = v106;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v108 = *__error();
          v109 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: endOfSecs %p endPtr %p"), "endOfSecs && endOfSecs > endptr", *(_QWORD *)&v122[0], v7);
          if (v109)
          {
            v112 = v109;
            v113 = CFStringGetCStringPtr(v109, 0x8000100u);
            if (v113)
            {
              v114 = (char *)v113;
              v115 = 0;
            }
            else
            {
              v114 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE3D25C61uLL);
              CFStringGetCString(v112, v114, 1024, 0x8000100u);
              v115 = v114;
            }
            if (qword_1000EBD40)
              v116 = (FILE *)qword_1000EBD40;
            else
              v116 = __stderrp;
            fprintf(v116, "%s\n", v114);
            if (v115)
              free(v115);
            CFRelease(v112);
          }
          else
          {
            v110 = sub_100030318();
            if (os_log_type_enabled(v110, OS_LOG_TYPE_FAULT))
              sub_10008F8E8();
            if (qword_1000EBD40)
              v111 = (FILE *)qword_1000EBD40;
            else
              v111 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v111);
          }
          *__error() = v108;
        }
        sub_1000301F0("TimeFromString", "spindump.m", 4001, "%s: endOfSecs %p endPtr %p", v44, v45, v46, v47, (char)"endOfSecs && endOfSecs > endptr");
        abort();
      }
      v9 = v48;
      if (!**(_BYTE **)&v122[0]
        || ((v49 = strptime(*(const char **)&v122[0], " %z", &v120), (__endptr = v49) != 0)
         || (v49 = strptime(*(const char **)&v122[0], " %Z", &v120), (__endptr = v49) != 0))
        && !*v49)
      {
        v8 = mktime(&v120);
        if (v9 > 0.0)
        {
          if (byte_1000EBD38)
          {
            v58 = *__error();
            v59 = sub_100030318();
            if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
              sub_10008F790(v8, v59, v9);
            *__error() = v58;
          }
          if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
            goto LABEL_175;
          v60 = *__error();
          v61 = fmod(v9, 1.0);
          v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found ISO timestamp %ld with subseconds %f"), v8, *(_QWORD *)&v61);
          if (v62)
          {
            v63 = v62;
            v64 = CFStringGetCStringPtr(v62, 0x8000100u);
            if (v64)
            {
LABEL_111:
              v69 = (char *)v64;
              v70 = 0;
LABEL_168:
              if (qword_1000EBD40)
                v98 = (FILE *)qword_1000EBD40;
              else
                v98 = __stderrp;
              fprintf(v98, "%s\n", v69);
              if (v70)
                free(v70);
              CFRelease(v63);
LABEL_174:
              *__error() = v60;
LABEL_175:
              fmod(v9, 1.0);
              return;
            }
            v65 = 1035006030;
LABEL_167:
            v69 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v65);
            CFStringGetCString(v63, v69, 1024, 0x8000100u);
            v70 = v69;
            goto LABEL_168;
          }
          v103 = sub_100030318();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT))
            sub_10008F71C(v8, v103, v104, v61);
LABEL_147:
          if (qword_1000EBD40)
            v87 = (FILE *)qword_1000EBD40;
          else
            v87 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
          goto LABEL_174;
        }
LABEL_103:
        if (byte_1000EBD38)
        {
          v66 = *__error();
          v67 = sub_100030318();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
            sub_10008F888();
          *__error() = v66;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
          goto LABEL_175;
        v60 = *__error();
        v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found ISO timestamp %ld"), v8);
        if (v68)
        {
          v63 = v68;
          v64 = CFStringGetCStringPtr(v68, 0x8000100u);
          if (v64)
            goto LABEL_111;
          v65 = 2120532020;
          goto LABEL_167;
        }
        v86 = sub_100030318();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
          sub_10008F824();
        goto LABEL_147;
      }
    }
    else if (!*v7)
    {
      v8 = mktime(&v120);
      v9 = 0.0;
      goto LABEL_103;
    }
  }
  atp = 0.0;
  v50 = CFLocaleCopyCurrent();
  if (v50)
  {
    v51 = CFStringCreateWithCString(0, a1, 0x8000100u);
    if (v51)
    {
      v52 = 0;
      v53 = 0;
LABEL_78:
      v54 = 0;
      while (1)
      {
        if (v53)
          CFRelease(v53);
        v55 = CFDateFormatterCreate(0, v50, (CFDateFormatterStyle)qword_10009E670[v52], (CFDateFormatterStyle)qword_10009E670[v54]);
        if (!v55)
          break;
        v53 = v55;
        CFDateFormatterSetProperty(v55, kCFDateFormatterIsLenient, kCFBooleanTrue);
        if (CFDateFormatterGetAbsoluteTimeFromString(v53, v51, 0, &atp))
          goto LABEL_123;
        if (++v54 == 4)
        {
          if (++v52 != 4)
            goto LABEL_78;
          goto LABEL_123;
        }
      }
      if (byte_1000EBD38)
      {
        v72 = *__error();
        v73 = sub_100030318();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
          sub_10008F6F0();
        *__error() = v72;
      }
      if (byte_1000EBD39)
        v74 = dword_1000EB4E8 <= 3;
      else
        v74 = 0;
      if (v74)
      {
        v92 = *__error();
        v93 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to create date formatter"));
        if (v93)
        {
          v94 = v93;
          v95 = CFStringGetCStringPtr(v93, 0x8000100u);
          if (v95)
          {
            v96 = (char *)v95;
            v97 = 0;
          }
          else
          {
            v96 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA74AC0B4uLL);
            CFStringGetCString(v94, v96, 1024, 0x8000100u);
            v97 = v96;
          }
          if (qword_1000EBD40)
            v105 = (FILE *)qword_1000EBD40;
          else
            v105 = __stderrp;
          fprintf(v105, "%s\n", v96);
          if (v97)
            free(v97);
          CFRelease(v94);
        }
        else
        {
          v101 = sub_100030318();
          if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT))
            sub_10008F6C4();
          if (qword_1000EBD40)
            v102 = (FILE *)qword_1000EBD40;
          else
            v102 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v102);
        }
        v53 = 0;
        *__error() = v92;
        goto LABEL_123;
      }
    }
  }
  else
  {
    v51 = 0;
  }
  v53 = 0;
LABEL_123:
  if (atp == 0.0)
  {
    memset(v122, 0, sizeof(v122));
    memset(&v118, 0, sizeof(v118));
    v117 = (uint64_t)(CFAbsoluteTimeGetCurrent() + kCFAbsoluteTimeIntervalSince1970);
    localtime_r(&v117, &v118);
    strftime((char *)v122, 0x80uLL, "%Y-%m-%dT%T%z", &v118);
    if (byte_1000EBD38)
    {
      v75 = *__error();
      v76 = sub_100030318();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        sub_10008F654();
      *__error() = v75;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v77 = *__error();
      v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to parse time string %s, try using format '%%Y-%%m-%%dT%%T%%z', e.g. %s"), a1, v122);
      if (v78)
      {
        v79 = v78;
        v80 = CFStringGetCStringPtr(v78, 0x8000100u);
        if (v80)
        {
          v81 = (char *)v80;
          v82 = 0;
        }
        else
        {
          v81 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8F7724A9uLL);
          CFStringGetCString(v79, v81, 1024, 0x8000100u);
          v82 = v81;
        }
        if (qword_1000EBD40)
          v99 = (FILE *)qword_1000EBD40;
        else
          v99 = __stderrp;
        fprintf(v99, "%s\n", v81);
        if (v82)
          free(v82);
        CFRelease(v79);
      }
      else
      {
        v88 = sub_100030318();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT))
          sub_10008F5EC();
        if (qword_1000EBD40)
          v89 = (FILE *)qword_1000EBD40;
        else
          v89 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v89);
      }
      *__error() = v77;
    }
  }
  if (v51)
    CFRelease(v51);
  if (v50)
    CFRelease(v50);
  if (v53)
    CFRelease(v53);
}

uint64_t sub_10002E9F4()
{
  if (qword_1000EB550 != -1)
    dispatch_once(&qword_1000EB550, &stru_1000DCB48);
  return dword_1000EB548;
}

void sub_10002EA34(id a1)
{
  size_t v1;
  int v2[2];

  *(_QWORD *)v2 = 0x600000001;
  v1 = 4;
  if (sysctl(v2, 2u, &dword_1000EB548, &v1, 0, 0) == -1)
    sub_100082F70();
}

uint64_t sub_10002EABC(const char *a1, int a2, int a3, char a4, char **a5)
{
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  int v30;
  char *v31;
  uint64_t v32;
  const char *v33;
  unsigned int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const char *v41;
  int v42;
  NSObject *v43;
  BOOL v44;
  int v45;
  const __CFString *v46;
  const __CFString *v47;
  const char *v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  const char *v53;
  unsigned int *v54;
  char *v55;
  int v56;
  NSObject *v57;
  BOOL v58;
  char *v59;
  int v60;
  const __CFString *v61;
  const __CFString *v62;
  const char *v63;
  char *v64;
  char *v65;
  NSObject *v66;
  FILE *v67;
  FILE *v68;
  unsigned int v69;
  unsigned int v70;
  char *v71;
  int v72;
  NSObject *v73;
  int v74;
  const __CFString *v75;
  const __CFString *v76;
  const char *CStringPtr;
  malloc_type_id_t v78;
  uint64_t v79;
  unsigned int *v80;
  char *v81;
  char *v82;
  int v83;
  NSObject *v84;
  BOOL v85;
  int v86;
  const __CFString *v87;
  const __CFString *v88;
  const char *v89;
  char *v90;
  char *v91;
  NSObject *v92;
  FILE *v93;
  FILE *v94;
  unsigned int v95;
  unsigned int v96;
  size_t v97;
  size_t v98;
  uint64_t v99;
  char *v100;
  unsigned int *v101;
  int v102;
  NSObject *v103;
  BOOL v104;
  int v105;
  const __CFString *v106;
  const __CFString *v107;
  const char *v108;
  char *v109;
  char *v110;
  NSObject *v111;
  FILE *v112;
  FILE *v113;
  unsigned int v114;
  unsigned int v115;
  uint64_t v116;
  char *v117;
  unsigned int *v118;
  int v119;
  NSObject *v120;
  BOOL v121;
  int v122;
  const __CFString *v123;
  const __CFString *v124;
  const char *v125;
  char *v126;
  char *v127;
  NSObject *v128;
  FILE *v129;
  FILE *v130;
  unsigned int v131;
  unsigned int v132;
  uint64_t v133;
  char *v134;
  unsigned int *v135;
  int v136;
  NSObject *v137;
  BOOL v138;
  int v139;
  const __CFString *v140;
  const __CFString *v141;
  const char *v142;
  char *v143;
  char *v144;
  NSObject *v145;
  FILE *v146;
  FILE *v147;
  unsigned int v148;
  unsigned int v149;
  int v150;
  NSObject *v151;
  const __CFString *v152;
  char *v153;
  char *v154;
  const char *v155;
  unsigned int *v156;
  char *v157;
  int v158;
  NSObject *v159;
  BOOL v160;
  int v161;
  const __CFString *v162;
  const __CFString *v163;
  const char *v164;
  char *v165;
  char *v166;
  NSObject *v167;
  FILE *v168;
  FILE *v169;
  uint64_t v170;
  unsigned int v171;
  unsigned int v172;
  NSObject *v173;
  FILE *v174;
  NSObject *v175;
  FILE *v176;
  NSObject *v178;
  FILE *v179;
  FILE *v180;
  unsigned int v181;
  char **v182;
  CFAllocatorRef alloc;
  char *v184;
  unsigned int *v185;
  char *v186;
  unsigned int v187;
  int v188;
  pid_t v190;
  char *__endptr;
  uint8_t buf[4];
  int *p_buffer;
  int buffer;
  char *v195;
  __int16 v196;
  unsigned int v197;
  uint64_t v198;

  v190 = getpid();
  __endptr = 0;
  if (!a1 || !*a1)
    return 4294967294;
  v9 = strtol(a1, &__endptr, 0);
  if (__endptr != a1 && !*__endptr)
  {
    v32 = v9;
    if (!(_DWORD)v9 || !kill(v9, 0))
    {
      if (a5)
      {
        if (proc_pidpath(v32, &buffer, 0x400u) >= 1)
        {
          v71 = (char *)malloc_type_malloc(0x400uLL, 0xAB8C5037uLL);
          *a5 = v71;
          basename_r((const char *)&buffer, v71);
        }
        if (byte_1000EBD38)
        {
          v72 = *__error();
          v73 = sub_100030318();
          if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
            sub_100083164();
          *__error() = v72;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
          return v32;
        v74 = *__error();
        v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found pid %s [%d]"), *a5, v32);
        if (v75)
        {
          v76 = v75;
          CStringPtr = CFStringGetCStringPtr(v75, 0x8000100u);
          if (!CStringPtr)
          {
            v78 = 3504435981;
LABEL_314:
            v153 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v78);
            CFStringGetCString(v76, v153, 1024, 0x8000100u);
            v154 = v153;
            goto LABEL_315;
          }
          goto LABEL_246;
        }
        v175 = sub_100030318();
        if (os_log_type_enabled(v175, OS_LOG_TYPE_FAULT))
          sub_1000830F0();
      }
      else
      {
        if (byte_1000EBD38)
        {
          v150 = *__error();
          v151 = sub_100030318();
          if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
            sub_10008307C(v32, v151);
          *__error() = v150;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
          return v32;
        v74 = *__error();
        v152 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found pid [%d]"), v32);
        if (v152)
        {
          v76 = v152;
          CStringPtr = CFStringGetCStringPtr(v152, 0x8000100u);
          if (!CStringPtr)
          {
            v78 = 683168702;
            goto LABEL_314;
          }
LABEL_246:
          v153 = (char *)CStringPtr;
          v154 = 0;
LABEL_315:
          if (qword_1000EBD40)
            v180 = (FILE *)qword_1000EBD40;
          else
            v180 = __stderrp;
          fprintf(v180, "%s\n", v153);
          if (v154)
            free(v154);
          CFRelease(v76);
LABEL_321:
          *__error() = v74;
          return v32;
        }
        v178 = sub_100030318();
        if (os_log_type_enabled(v178, OS_LOG_TYPE_FAULT))
          sub_100083008(v32, v178);
      }
      if (qword_1000EBD40)
        v179 = (FILE *)qword_1000EBD40;
      else
        v179 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v179);
      goto LABEL_321;
    }
  }
  if (qword_1000EB550 != -1)
    dispatch_once(&qword_1000EB550, &stru_1000DCB48);
  v10 = dword_1000EB548;
  v185 = (unsigned int *)malloc_type_calloc(dword_1000EB548, 4uLL, 0x100004052888210uLL);
  v11 = proc_listallpids(v185, 4 * v10);
  if (v11 == -1)
  {
    perror("proc_listallpids");
    free(v185);
    return 4294967294;
  }
  v12 = v11;
  v13 = (char *)malloc_type_calloc(v11, 0x400uLL, 0x1000040D7EB2065uLL);
  v184 = v13;
  if (v12 < 1)
  {
    if (a3)
    {
      sub_100030270((char *)&buffer, 0x100uLL, "Multiple matches for \"%s\": ", v14, v15, v16, v17, v18, (char)a1);
      v51 = 0;
LABEL_133:
      v32 = 4294967294;
LABEL_134:
      if (a5)
        goto LABEL_301;
      goto LABEL_302;
    }
    v181 = v12;
    v182 = a5;
    v187 = -1;
LABEL_95:
    if ((int)v181 < 1 || (a2 & 1) != 0)
      goto LABEL_131;
    v79 = v181;
    alloc = (CFAllocatorRef)v181;
    v81 = v184;
    v80 = v185;
    v82 = v184;
    do
    {
      if (!strncasecmp(v81, a1, 0x400uLL))
      {
        if (byte_1000EBD38)
        {
          v83 = *__error();
          v84 = sub_100030318();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_DEBUG))
          {
            v95 = *v80;
            buffer = 136315394;
            v195 = v82;
            v196 = 1024;
            v197 = v95;
            _os_log_debug_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEBUG, "Found case insensitive match %s [%d]", (uint8_t *)&buffer, 0x12u);
          }
          *__error() = v83;
        }
        if (byte_1000EBD39)
          v85 = dword_1000EB4E8 <= 0;
        else
          v85 = 0;
        if (v85)
        {
          v86 = *__error();
          v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found case insensitive match %s [%d]"), v81, *v80);
          if (v87)
          {
            v88 = v87;
            v89 = CFStringGetCStringPtr(v87, 0x8000100u);
            if (v89)
            {
              v90 = (char *)v89;
              v91 = 0;
            }
            else
            {
              v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C3642E0uLL);
              CFStringGetCString(v88, v90, 1024, 0x8000100u);
              v91 = v90;
            }
            if (qword_1000EBD40)
              v94 = (FILE *)qword_1000EBD40;
            else
              v94 = __stderrp;
            fprintf(v94, "%s\n", v90);
            if (v91)
              free(v91);
            CFRelease(v88);
          }
          else
          {
            v92 = sub_100030318();
            if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
            {
              v96 = *v80;
              buffer = 136315394;
              v195 = v82;
              v196 = 1024;
              v197 = v96;
              _os_log_fault_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_FAULT, "Unable to format: Found case insensitive match %s [%d]", (uint8_t *)&buffer, 0x12u);
            }
            if (qword_1000EBD40)
              v93 = (FILE *)qword_1000EBD40;
            else
              v93 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
          }
          *__error() = v86;
        }
        v32 = *v80;
        if ((a4 & 1) != 0 || v190 != (_DWORD)v32)
        {
          if (v190 != (_DWORD)v32)
          {
LABEL_249:
            if (v182)
              *v182 = strdup(v81);
            goto LABEL_302;
          }
          v187 = *v80;
        }
      }
      ++v80;
      v81 += 1024;
      v82 += 1024;
      --v79;
    }
    while (v79);
    v97 = strlen(a1);
    if (v97 > 0x3FF)
    {
LABEL_131:
      v32 = v187;
      goto LABEL_302;
    }
    v98 = v97;
    v99 = v181;
    v53 = v184;
    v100 = v184;
    v101 = v185;
    while (1)
    {
      if (!strncmp(v53, a1, v98))
      {
        if (byte_1000EBD38)
        {
          v102 = *__error();
          v103 = sub_100030318();
          if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
          {
            v114 = *v101;
            buffer = 136315394;
            v195 = v100;
            v196 = 1024;
            v197 = v114;
            _os_log_debug_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEBUG, "Found prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
          }
          *__error() = v102;
        }
        if (byte_1000EBD39)
          v104 = dword_1000EB4E8 <= 0;
        else
          v104 = 0;
        if (v104)
        {
          v105 = *__error();
          v106 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found prefix match %s [%d]"), v53, *v101);
          if (v106)
          {
            v107 = v106;
            v108 = CFStringGetCStringPtr(v106, 0x8000100u);
            if (v108)
            {
              v109 = (char *)v108;
              v110 = 0;
            }
            else
            {
              v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x43C6907CuLL);
              CFStringGetCString(v107, v109, 1024, 0x8000100u);
              v110 = v109;
            }
            if (qword_1000EBD40)
              v113 = (FILE *)qword_1000EBD40;
            else
              v113 = __stderrp;
            fprintf(v113, "%s\n", v109);
            if (v110)
              free(v110);
            CFRelease(v107);
          }
          else
          {
            v111 = sub_100030318();
            if (os_log_type_enabled(v111, OS_LOG_TYPE_FAULT))
            {
              v115 = *v101;
              buffer = 136315394;
              v195 = v100;
              v196 = 1024;
              v197 = v115;
              _os_log_fault_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_FAULT, "Unable to format: Found prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
            }
            if (qword_1000EBD40)
              v112 = (FILE *)qword_1000EBD40;
            else
              v112 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v112);
          }
          *__error() = v105;
        }
        v32 = *v101;
        if ((a4 & 1) != 0 || v190 != (_DWORD)v32)
        {
          if (v190 != (_DWORD)v32)
            goto LABEL_203;
          v187 = *v101;
        }
      }
      ++v101;
      v53 += 1024;
      v100 += 1024;
      if (!--v99)
      {
        v116 = v181;
        v53 = v184;
        v117 = v184;
        v118 = v185;
        while (1)
        {
          if (!strncasecmp(v53, a1, v98))
          {
            if (byte_1000EBD38)
            {
              v119 = *__error();
              v120 = sub_100030318();
              if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
              {
                v131 = *v118;
                buffer = 136315394;
                v195 = v117;
                v196 = 1024;
                v197 = v131;
                _os_log_debug_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEBUG, "Found case insensitive prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
              }
              *__error() = v119;
            }
            if (byte_1000EBD39)
              v121 = dword_1000EB4E8 <= 0;
            else
              v121 = 0;
            if (v121)
            {
              v122 = *__error();
              v123 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found case insensitive prefix match %s [%d]"), v53, *v118);
              if (v123)
              {
                v124 = v123;
                v125 = CFStringGetCStringPtr(v123, 0x8000100u);
                if (v125)
                {
                  v126 = (char *)v125;
                  v127 = 0;
                }
                else
                {
                  v126 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x88FE65CEuLL);
                  CFStringGetCString(v124, v126, 1024, 0x8000100u);
                  v127 = v126;
                }
                if (qword_1000EBD40)
                  v130 = (FILE *)qword_1000EBD40;
                else
                  v130 = __stderrp;
                fprintf(v130, "%s\n", v126);
                if (v127)
                  free(v127);
                CFRelease(v124);
              }
              else
              {
                v128 = sub_100030318();
                if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT))
                {
                  v132 = *v118;
                  buffer = 136315394;
                  v195 = v117;
                  v196 = 1024;
                  v197 = v132;
                  _os_log_fault_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_FAULT, "Unable to format: Found case insensitive prefix match %s [%d]", (uint8_t *)&buffer, 0x12u);
                }
                if (qword_1000EBD40)
                  v129 = (FILE *)qword_1000EBD40;
                else
                  v129 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v129);
              }
              *__error() = v122;
            }
            v32 = *v118;
            if ((a4 & 1) != 0 || v190 != (_DWORD)v32)
            {
              if (v190 != (_DWORD)v32)
                goto LABEL_203;
              v187 = *v118;
            }
          }
          ++v118;
          v53 += 1024;
          v117 += 1024;
          if (!--v116)
          {
            v133 = v181;
            v81 = v184;
            v134 = v184;
            v135 = v185;
            while (1)
            {
              if (strstr(v81, a1))
              {
                if (byte_1000EBD38)
                {
                  v136 = *__error();
                  v137 = sub_100030318();
                  if (os_log_type_enabled(v137, OS_LOG_TYPE_DEBUG))
                  {
                    v148 = *v135;
                    buffer = 136315394;
                    v195 = v134;
                    v196 = 1024;
                    v197 = v148;
                    _os_log_debug_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_DEBUG, "Found partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                  }
                  *__error() = v136;
                }
                if (byte_1000EBD39)
                  v138 = dword_1000EB4E8 <= 0;
                else
                  v138 = 0;
                if (v138)
                {
                  v139 = *__error();
                  v140 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found partial match %s [%d]"), v81, *v135);
                  if (v140)
                  {
                    v141 = v140;
                    v142 = CFStringGetCStringPtr(v140, 0x8000100u);
                    if (v142)
                    {
                      v143 = (char *)v142;
                      v144 = 0;
                    }
                    else
                    {
                      v143 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D3F60F8uLL);
                      CFStringGetCString(v141, v143, 1024, 0x8000100u);
                      v144 = v143;
                    }
                    if (qword_1000EBD40)
                      v147 = (FILE *)qword_1000EBD40;
                    else
                      v147 = __stderrp;
                    fprintf(v147, "%s\n", v143);
                    if (v144)
                      free(v144);
                    CFRelease(v141);
                  }
                  else
                  {
                    v145 = sub_100030318();
                    if (os_log_type_enabled(v145, OS_LOG_TYPE_FAULT))
                    {
                      v149 = *v135;
                      buffer = 136315394;
                      v195 = v134;
                      v196 = 1024;
                      v197 = v149;
                      _os_log_fault_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_FAULT, "Unable to format: Found partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                    }
                    if (qword_1000EBD40)
                      v146 = (FILE *)qword_1000EBD40;
                    else
                      v146 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v146);
                  }
                  *__error() = v139;
                }
                v32 = *v135;
                if ((a4 & 1) != 0 || v190 != (_DWORD)v32)
                {
                  if (v190 != (_DWORD)v32)
                    goto LABEL_249;
                  v187 = *v135;
                }
              }
              ++v135;
              v81 += 1024;
              v134 += 1024;
              if (!--v133)
              {
                v155 = v184;
                v156 = v185;
                v157 = v184;
                v32 = v187;
                while (1)
                {
                  if (strcasestr(v155, a1))
                  {
                    if (byte_1000EBD38)
                    {
                      v158 = *__error();
                      v159 = sub_100030318();
                      if (os_log_type_enabled(v159, OS_LOG_TYPE_DEBUG))
                      {
                        v171 = *v156;
                        buffer = 136315394;
                        v195 = v157;
                        v196 = 1024;
                        v197 = v171;
                        _os_log_debug_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_DEBUG, "Found case insensitive partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                      }
                      *__error() = v158;
                    }
                    if (byte_1000EBD39)
                      v160 = dword_1000EB4E8 <= 0;
                    else
                      v160 = 0;
                    if (v160)
                    {
                      v161 = *__error();
                      v162 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found case insensitive partial match %s [%d]"), v155, *v156);
                      if (v162)
                      {
                        v163 = v162;
                        v164 = CFStringGetCStringPtr(v162, 0x8000100u);
                        if (v164)
                        {
                          v165 = (char *)v164;
                          v166 = 0;
                        }
                        else
                        {
                          v165 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC82CF512uLL);
                          CFStringGetCString(v163, v165, 1024, 0x8000100u);
                          v166 = v165;
                        }
                        if (qword_1000EBD40)
                          v169 = (FILE *)qword_1000EBD40;
                        else
                          v169 = __stderrp;
                        fprintf(v169, "%s\n", v165);
                        if (v166)
                          free(v166);
                        CFRelease(v163);
                      }
                      else
                      {
                        v167 = sub_100030318();
                        if (os_log_type_enabled(v167, OS_LOG_TYPE_FAULT))
                        {
                          v172 = *v156;
                          buffer = 136315394;
                          v195 = v157;
                          v196 = 1024;
                          v197 = v172;
                          _os_log_fault_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_FAULT, "Unable to format: Found case insensitive partial match %s [%d]", (uint8_t *)&buffer, 0x12u);
                        }
                        if (qword_1000EBD40)
                          v168 = (FILE *)qword_1000EBD40;
                        else
                          v168 = __stderrp;
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v168);
                      }
                      *__error() = v161;
                    }
                    v170 = *v156;
                    if ((a4 & 1) != 0 || v190 != (_DWORD)v170)
                    {
                      if (v190 != (_DWORD)v170)
                      {
                        if (v182)
                          *v182 = strdup(v155);
                        v32 = v170;
                        goto LABEL_302;
                      }
                      v32 = *v156;
                    }
                  }
                  ++v156;
                  v155 += 1024;
                  v157 += 1024;
                  alloc = (CFAllocatorRef)((char *)alloc - 1);
                  if (!alloc)
                    goto LABEL_302;
                }
              }
            }
          }
        }
      }
    }
  }
  v181 = v12;
  v19 = v12;
  v20 = v12;
  v21 = v13;
  v22 = (int *)v185;
  do
  {
    v23 = *v22++;
    if (proc_pidpath(v23, &buffer, 0x400u) >= 1)
      basename_r((const char *)&buffer, v21);
    v21 += 1024;
    --v20;
  }
  while (v20);
  v182 = a5;
  v188 = a2;
  if ((a3 & 1) == 0)
  {
    v187 = -1;
    v52 = &byte_1000EBD38;
    v53 = v184;
    v54 = v185;
    v55 = v184;
    do
    {
      if (!strncmp(v53, a1, 0x400uLL))
      {
        if (*v52)
        {
          v56 = *__error();
          v57 = sub_100030318();
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
          {
            v69 = *v54;
            buffer = 136315394;
            v195 = v55;
            v196 = 1024;
            v197 = v69;
            _os_log_debug_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEBUG, "Found exact match %s [%d]", (uint8_t *)&buffer, 0x12u);
          }
          *__error() = v56;
        }
        if (byte_1000EBD39)
          v58 = dword_1000EB4E8 <= 0;
        else
          v58 = 0;
        if (v58)
        {
          v59 = v52;
          v60 = *__error();
          v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Found exact match %s [%d]"), v53, *v54);
          if (v61)
          {
            v62 = v61;
            v63 = CFStringGetCStringPtr(v61, 0x8000100u);
            if (v63)
            {
              v64 = (char *)v63;
              v65 = 0;
            }
            else
            {
              v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1EFAEFDAuLL);
              CFStringGetCString(v62, v64, 1024, 0x8000100u);
              v65 = v64;
            }
            if (qword_1000EBD40)
              v68 = (FILE *)qword_1000EBD40;
            else
              v68 = __stderrp;
            fprintf(v68, "%s\n", v64);
            if (v65)
              free(v65);
            CFRelease(v62);
          }
          else
          {
            v66 = sub_100030318();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
            {
              v70 = *v54;
              buffer = 136315394;
              v195 = v55;
              v196 = 1024;
              v197 = v70;
              _os_log_fault_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_FAULT, "Unable to format: Found exact match %s [%d]", (uint8_t *)&buffer, 0x12u);
            }
            if (qword_1000EBD40)
              v67 = (FILE *)qword_1000EBD40;
            else
              v67 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v67);
          }
          LOBYTE(a2) = v188;
          *__error() = v60;
          v52 = v59;
        }
        v32 = *v54;
        if ((a4 & 1) != 0 || v190 != (_DWORD)v32)
        {
          if (v190 != (_DWORD)v32)
          {
LABEL_203:
            if (v182)
              *v182 = strdup(v53);
            goto LABEL_302;
          }
          v187 = *v54;
        }
      }
      ++v54;
      v53 += 1024;
      v55 += 1024;
      --v19;
    }
    while (v19);
    goto LABEL_95;
  }
  v186 = 0;
  v29 = 0;
  v30 = 0;
  v31 = (char *)&buffer
      + (int)sub_100030270((char *)&buffer, 0x100uLL, "Multiple matches for \"%s\": ", v24, v25, v26, v27, v28, (char)a1);
  v32 = 0xFFFFFFFFLL;
  v33 = v184;
  v34 = v185;
  do
  {
    if (a2)
    {
      if (strncmp(v33, a1, 0x400uLL))
        goto LABEL_30;
    }
    else if (!strcasestr(v33, a1))
    {
      goto LABEL_30;
    }
    v40 = *v34;
    if ((a4 & 1) != 0 || v190 != (_DWORD)v40)
    {
      if (v190 != (_DWORD)v40)
      {
        if (a5 && !v30)
          v186 = strdup(v33);
        v41 = ", ";
        if (!v29)
          v41 = "";
        v31 += (int)sub_100030270(v31, (char *)&v198 - v31, "%s%s [%d]", v35, v36, v37, v38, v39, (char)v41);
        ++v30;
        ++v29;
      }
      v32 = v40;
    }
    a2 = v188;
LABEL_30:
    ++v34;
    v33 += 1024;
    --v19;
  }
  while (v19);
  if (v30 < 2)
  {
    v51 = v186;
    if (v30)
      goto LABEL_134;
    goto LABEL_133;
  }
  if (byte_1000EBD38)
  {
    v42 = *__error();
    v43 = sub_100030318();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315138;
      p_buffer = &buffer;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
    }
    *__error() = v42;
  }
  if (byte_1000EBD39)
    v44 = dword_1000EB4E8 <= 2;
  else
    v44 = 0;
  if (v44)
  {
    v45 = *__error();
    v46 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s"), &buffer);
    if (v46)
    {
      v47 = v46;
      v48 = CFStringGetCStringPtr(v46, 0x8000100u);
      if (v48)
      {
        v49 = (char *)v48;
        v50 = 0;
      }
      else
      {
        v49 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAC4F944CuLL);
        CFStringGetCString(v47, v49, 1024, 0x8000100u);
        v50 = v49;
      }
      if (qword_1000EBD40)
        v176 = (FILE *)qword_1000EBD40;
      else
        v176 = __stderrp;
      fprintf(v176, "%s\n", v49);
      if (v50)
        free(v50);
      CFRelease(v47);
    }
    else
    {
      v173 = sub_100030318();
      if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT))
        sub_100082F98((uint64_t)&buffer, v173);
      if (qword_1000EBD40)
        v174 = (FILE *)qword_1000EBD40;
      else
        v174 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v174);
    }
    *__error() = v45;
  }
  free(v186);
  v51 = 0;
  v32 = 0xFFFFFFFFLL;
  if (a5)
LABEL_301:
    *a5 = v51;
LABEL_302:
  free(v185);
  free(v184);
  return v32;
}

uint64_t sub_100030160(char *__format, ...)
{
  char __str[512];
  va_list va;

  va_start(va, __format);
  vsnprintf(__str, 0x200uLL, __format, va);
  return os_transaction_create(__str);
}

uint64_t sub_1000301F0(const char *a1, const char *a2, int a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result;

  result = snprintf(byte_1000EB558, 0x400uLL, "Assertion Failed %s %s:%d ", a1, a2, a3);
  if ((result - 1) <= 0x3FE)
    result = vsnprintf(&byte_1000EB558[result], 1024 - result, a4, &a9);
  qword_1000EB510 = (uint64_t)byte_1000EB558;
  return result;
}

uint64_t sub_100030270(char *a1, size_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t result;

  LODWORD(result) = vsnprintf(a1, a2, a3, &a9);
  if ((int)result >= a2)
    return (a2 - 1);
  else
    return result;
}

_DWORD *sub_1000302B4(int a1)
{
  unsigned int v1;
  BOOL v2;
  int v3;
  int v4;
  _DWORD *v5;

  do
    v1 = __ldxr((unsigned int *)&unk_1000EBB58);
  while (__stxr(v1 + 1, (unsigned int *)&unk_1000EBB58));
  v2 = (-v1 & 0x80000000) != 0;
  v3 = -v1 & 3;
  v4 = v1 & 3;
  if (!v2)
    v4 = -v3;
  v5 = (_DWORD *)((char *)&unk_1000EB958 + 128 * (uint64_t)v4);
  *v5 = 0;
  proc_name(a1, v5, 0x80u);
  return v5;
}

uint64_t sub_100030318()
{
  if (qword_1000EBB68 != -1)
    dispatch_once(&qword_1000EBB68, &stru_1000DCB88);
  return qword_1000EBB60;
}

void sub_100030358(id a1)
{
  qword_1000EBB60 = (uint64_t)os_log_create("com.apple.spindump", "logging");
  if (!qword_1000EBB60)
    sub_1000831D8();
}

uint64_t sub_10003038C(int a1)
{
  _OWORD v2[2];
  uint64_t v3;

  v3 = 0;
  memset(v2, 0, sizeof(v2));
  if (proc_pidinfo(a1, 20, 1uLL, v2, 40) == 40)
    return *(_QWORD *)&v2[0];
  else
    return 0;
}

id sub_1000303D0(int a1)
{
  _BYTE buffer[1024];

  if (proc_pidpath(a1, buffer, 0x400u) < 1)
    return 0;
  else
    return objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", buffer);
}

void sub_10003044C(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[6];
  int v8;

  v7[1] = 3221225472;
  v7[2] = sub_100030688;
  v7[3] = &unk_1000DCC18;
  v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_1000304BC(a1, a2, a3, 0, a6, a7, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_1000304BC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, uint64_t a11)
{
  NSObject *v21;
  id v22;
  id v23;
  id v24;
  uint64_t v25;
  _QWORD block[16];
  int v27;
  _QWORD buffer[8];

  if (qword_1000EBBB8 != -1)
    dispatch_once(&qword_1000EBBB8, &stru_1000DCCE8);
  v21 = *off_1000DCD28[a4];
  if (os_signpost_enabled(v21) || sub_100030848(a4))
  {
    if (!a3)
    {
      memset(buffer, 0, 40);
      if (proc_pidinfo(a1, 20, 1uLL, buffer, 40) == 40)
        a3 = buffer[0];
      else
        a3 = 0;
    }
    if (a2)
      v22 = a2;
    else
      v22 = sub_1000303D0(a1);
    v23 = v22;
    v24 = +[SATimestamp timestamp](SATimestamp, "timestamp");
    v25 = sub_100030160("Event rate report for [%d] type %lu", a1, a4);
    if (qword_1000EBBC8 != -1)
      dispatch_once(&qword_1000EBBC8, &stru_1000DCD08);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100032328;
    block[3] = &unk_1000DCCC8;
    block[10] = a6;
    block[11] = a7;
    block[12] = a8;
    block[4] = v23;
    block[5] = v24;
    *(double *)&block[13] = a9;
    *(double *)&block[14] = a10;
    v27 = a1;
    block[8] = a11;
    block[9] = a5;
    block[15] = a3;
    block[6] = v21;
    block[7] = v25;
    dispatch_async((dispatch_queue_t)qword_1000EBBC0, block);
  }
}

void sub_100030688(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  int IsEventUsed;
  _QWORD v16[8];
  __int128 v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  int v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;

  if (os_signpost_enabled(log))
  {
    v12 = *(_DWORD *)(a1 + 48);
    v13 = *(_QWORD *)(a1 + 32);
    v14 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    v19 = a4;
    v20 = 2050;
    v21 = a5;
    v22 = 2050;
    v23 = a3;
    v24 = 1026;
    v25 = v12;
    v26 = 2050;
    v27 = v13;
    v28 = 2050;
    v29 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Hang", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    v19 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "Hang", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.forcequitwhileunresponsive"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 3221225472;
        v16[2] = sub_100030894;
        v16[3] = &unk_1000DCBF8;
        v16[4] = a4;
        v16[5] = a3;
        v16[6] = a6;
        v16[7] = a5;
        v17 = *(_OWORD *)(a1 + 32);
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.forcequitwhileunresponsive"), v16);
      }
    }
  }
}

uint64_t sub_100030848(uint64_t a1)
{
  const __CFString *v1;

  if (!&_AnalyticsIsEventUsed)
    return 0;
  if ((unint64_t)(a1 - 1) > 7)
    v1 = CFSTR("com.apple.spindump.forcequitwhileunresponsive");
  else
    v1 = off_1000DCD70[a1 - 1];
  return AnalyticsIsEventUsed(v1);
}

NSDictionary *sub_100030894(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[5];
  _QWORD v5[5];

  v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("Duration");
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = CFSTR("ConditionsPreventingSubmission");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = CFSTR("OtherConditions");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 5);
}

void sub_1000309A0(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[8];
  int v8;

  v7[1] = 3221225472;
  v7[2] = sub_100030A14;
  v7[3] = &unk_1000DCC38;
  v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  v7[6] = a7;
  v7[7] = a6;
  v7[0] = _NSConcreteStackBlock;
  sub_1000304BC(a1, a2, a3, 1, 0, 0, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_100030A14(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  int IsEventUsed;
  __int128 v16;
  _QWORD v17[6];
  __int128 v18;
  __int128 v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (os_signpost_enabled(log))
  {
    v12 = *(_DWORD *)(a1 + 64);
    v13 = *(_QWORD *)(a1 + 32);
    v14 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    v21 = a4;
    v22 = 2050;
    v23 = a5;
    v24 = 2050;
    v25 = a3;
    v26 = 1026;
    v27 = v12;
    v28 = 2050;
    v29 = v13;
    v30 = 2050;
    v31 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SlowHIDResponse", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    v21 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SlowHIDResponse", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.slowhidresponse"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472;
        v17[2] = sub_100030BD0;
        v17[3] = &unk_1000DCBF8;
        v17[4] = a4;
        v17[5] = a3;
        v16 = *(_OWORD *)(a1 + 32);
        v18 = *(_OWORD *)(a1 + 48);
        v19 = v16;
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.slowhidresponse"), v17);
      }
    }
  }
}

NSDictionary *sub_100030BD0(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[5];
  _QWORD v5[5];

  v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("Duration");
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = CFSTR("ConditionsPreventingSubmission");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = CFSTR("OtherConditions");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 5);
}

void sub_100030CDC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, double a7, double a8, double a9)
{
  _QWORD v9[9];
  int v10;
  char v11;

  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_100030D54;
  v9[3] = &unk_1000DCC80;
  v10 = a1;
  v11 = a6;
  *(double *)&v9[4] = a9;
  v9[5] = a4;
  v9[6] = a5;
  *(double *)&v9[7] = a8;
  *(double *)&v9[8] = a7;
  sub_1000304BC(a1, a2, a3, 2, 0, 0, 0, 0, a7, a8, (uint64_t)v9);
}

void sub_100030D54(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  int v13;
  double v14;
  uint64_t v15;
  uint64_t v16;
  int IsEventUsed;
  _QWORD v18[6];
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  int v31;
  __int16 v32;
  double v33;
  __int16 v34;
  uint64_t v35;
  __int16 v36;
  uint64_t v37;

  if (os_signpost_enabled(log))
  {
    v12 = *(_DWORD *)(a1 + 72);
    v13 = *(unsigned __int8 *)(a1 + 76);
    v14 = round(*(double *)(a1 + 32));
    v15 = *(_QWORD *)(a1 + 40);
    v16 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)buf = 138545154;
    v23 = a4;
    v24 = 2050;
    v25 = a5;
    v26 = 2050;
    v27 = a3;
    v28 = 1026;
    v29 = v12;
    v30 = 1026;
    v31 = v13;
    v32 = 2050;
    v33 = v14;
    v34 = 2050;
    v35 = v15;
    v36 = 2050;
    v37 = v16;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "CPUResource", "BundleIdOverride=%{public,signpost.description:attribute}@ %{public,signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u fatal=%{public,name=fatal}d cpuUsed=%{public,name=cpuUsed}.0f conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x4Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    v23 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "CPUResource", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.cpuusageresource"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472;
        v18[2] = sub_100030F48;
        v18[3] = &unk_1000DCC60;
        v18[4] = a4;
        v18[5] = a3;
        v19 = *(_OWORD *)(a1 + 56);
        v20 = *(_QWORD *)(a1 + 32);
        v21 = *(_OWORD *)(a1 + 40);
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.cpuusageresource"), v18);
      }
    }
  }
}

NSDictionary *sub_100030F48(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[6];
  _QWORD v5[6];

  v2 = *(_QWORD *)(a1 + 40);
  v5[0] = *(_QWORD *)(a1 + 32);
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("Duration");
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 48) - *(double *)(a1 + 56));
  v4[3] = CFSTR("CpuUsedS");
  v5[3] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 64));
  v4[4] = CFSTR("ConditionsPreventingSubmission");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 72));
  v4[5] = CFSTR("OtherConditions");
  v5[5] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 80));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 6);
}

void sub_100031060(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7, double a8)
{
  _QWORD v8[9];
  int v9;

  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1000310D4;
  v8[3] = &unk_1000DCCA0;
  v9 = a1;
  v8[4] = a6;
  v8[5] = a4;
  v8[6] = a5;
  *(double *)&v8[7] = a8;
  *(double *)&v8[8] = a7;
  sub_1000304BC(a1, a2, a3, 3, 0, 0, 0, 0, a7, a8, (uint64_t)v8);
}

void sub_1000310D4(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int IsEventUsed;
  __int128 v17;
  _QWORD v18[6];
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  uint8_t buf[4];
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unint64_t v31;
  __int16 v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;

  if (os_signpost_enabled(log))
  {
    v12 = *(_DWORD *)(a1 + 72);
    v13 = *(_QWORD *)(a1 + 40);
    v14 = *(_QWORD *)(a1 + 32) / 0xF4240uLL;
    v15 = *(_QWORD *)(a1 + 48);
    *(_DWORD *)buf = 138544898;
    v23 = a4;
    v24 = 2050;
    v25 = a5;
    v26 = 2050;
    v27 = a3;
    v28 = 1026;
    v29 = v12;
    v30 = 2050;
    v31 = v14;
    v32 = 2050;
    v33 = v13;
    v34 = 2050;
    v35 = v15;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "DiskWritesResource", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u ioMB=%{public,name=ioMB}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    v23 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DiskWritesResource", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.diskwritesresource"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v18[0] = _NSConcreteStackBlock;
        v18[1] = 3221225472;
        v18[2] = sub_1000312C8;
        v18[3] = &unk_1000DCC60;
        v18[4] = a4;
        v18[5] = a3;
        v17 = *(_OWORD *)(a1 + 32);
        v19 = *(_OWORD *)(a1 + 56);
        v20 = v17;
        v21 = *(_QWORD *)(a1 + 48);
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.diskwritesresource"), v18);
      }
    }
  }
}

NSDictionary *sub_1000312C8(uint64_t a1)
{
  uint64_t v2;
  _QWORD v4[6];
  _QWORD v5[6];

  v2 = *(_QWORD *)(a1 + 40);
  v5[0] = *(_QWORD *)(a1 + 32);
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("Duration");
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 48) - *(double *)(a1 + 56));
  v4[3] = CFSTR("Bytes");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 64));
  v4[4] = CFSTR("ConditionsPreventingSubmission");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 72));
  v4[5] = CFSTR("OtherConditions");
  v5[5] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 80));
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 6);
}

void sub_1000313E0(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[8];
  int v8;

  v7[1] = 3221225472;
  v7[2] = sub_100031454;
  v7[3] = &unk_1000DCC38;
  v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  v7[6] = a4;
  v7[7] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_1000304BC(a1, a2, a3, 4, 0, 0, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_100031454(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int IsEventUsed;
  __int128 v14;
  _QWORD v15[6];
  __int128 v16;
  __int128 v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (os_signpost_enabled(log))
  {
    v8 = *(_DWORD *)(a1 + 64);
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    v19 = a4;
    v20 = 2050;
    v21 = a3;
    v22 = 1026;
    v23 = v8;
    v24 = 2050;
    v25 = v9;
    v26 = 2050;
    v27 = v10;
    v28 = 2050;
    v29 = v11;
    v30 = 2050;
    v31 = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "FileDescriptorExhaustion", "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numFDs=%{public,name=numFDs}llu numFDsLimit=%{public,name=numFDsLimit}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.filedescriptorexhaustion"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        v15[2] = sub_1000315BC;
        v15[3] = &unk_1000DCBF8;
        v15[4] = a4;
        v15[5] = a3;
        v14 = *(_OWORD *)(a1 + 48);
        v16 = *(_OWORD *)(a1 + 32);
        v17 = v14;
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.filedescriptorexhaustion"), v15);
      }
    }
  }
}

NSDictionary *sub_1000315BC(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[6];
  _QWORD v5[6];

  v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("NumFileDescriptors");
  v5[2] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[6]);
  v4[3] = CFSTR("NumFileDescriptorsLimit");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[7]);
  v4[4] = CFSTR("ConditionsPreventingSubmission");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[5] = CFSTR("OtherConditions");
  v5[5] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 6);
}

void sub_1000316D0(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[8];
  int v8;

  v7[1] = 3221225472;
  v7[2] = sub_100031744;
  v7[3] = &unk_1000DCC38;
  v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  v7[6] = a4;
  v7[7] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_1000304BC(a1, a2, a3, 5, 0, 0, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_100031744(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int IsEventUsed;
  __int128 v14;
  _QWORD v15[6];
  __int128 v16;
  __int128 v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (os_signpost_enabled(log))
  {
    v8 = *(_DWORD *)(a1 + 64);
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    v19 = a4;
    v20 = 2050;
    v21 = a3;
    v22 = 1026;
    v23 = v8;
    v24 = 2050;
    v25 = v9;
    v26 = 2050;
    v27 = v10;
    v28 = 2050;
    v29 = v11;
    v30 = 2050;
    v31 = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "PortExhaustion", "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numPorts=%{public,name=numPorts}llu numPortsLimit=%{public,name=numPortsLimit}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.portexhaustion"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        v15[2] = sub_1000318AC;
        v15[3] = &unk_1000DCBF8;
        v15[4] = a4;
        v15[5] = a3;
        v14 = *(_OWORD *)(a1 + 48);
        v16 = *(_OWORD *)(a1 + 32);
        v17 = v14;
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.portexhaustion"), v15);
      }
    }
  }
}

NSDictionary *sub_1000318AC(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[6];
  _QWORD v5[6];

  v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("NumPorts");
  v5[2] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[6]);
  v4[3] = CFSTR("NumPortsLimit");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[7]);
  v4[4] = CFSTR("ConditionsPreventingSubmission");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[5] = CFSTR("OtherConditions");
  v5[5] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 6);
}

void sub_1000319C0(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[8];
  int v8;

  v7[1] = 3221225472;
  v7[2] = sub_100031A34;
  v7[3] = &unk_1000DCC38;
  v8 = a1;
  v7[4] = a6;
  v7[5] = a7;
  v7[6] = a4;
  v7[7] = a5;
  v7[0] = _NSConcreteStackBlock;
  sub_1000304BC(a1, a2, a3, 6, 0, 0, 0, 0, 0.0, 0.0, (uint64_t)v7);
}

void sub_100031A34(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int IsEventUsed;
  __int128 v14;
  _QWORD v15[6];
  __int128 v16;
  __int128 v17;
  uint8_t buf[4];
  uint64_t v19;
  __int16 v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (os_signpost_enabled(log))
  {
    v8 = *(_DWORD *)(a1 + 64);
    v9 = *(_QWORD *)(a1 + 32);
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 48);
    v12 = *(_QWORD *)(a1 + 56);
    *(_DWORD *)buf = 138544898;
    v19 = a4;
    v20 = 2050;
    v21 = a3;
    v22 = 1026;
    v23 = v8;
    v24 = 2050;
    v25 = v9;
    v26 = 2050;
    v27 = v10;
    v28 = 2050;
    v29 = v11;
    v30 = 2050;
    v31 = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "KQWorkLoopExhaustion", "BundleIdOverride=%{public, signpost.description:attribute}@ cid=%{public,name=cid}llu pid=%{public,name=pid}u numKQWorkLoops=%{public,name=numKQWorkLoops}llu numKQWorkLoopsLimit=%{public,name=numKQWorkLoopsLimit}llu conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x44u);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.kqworkloopexhaustion"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 3221225472;
        v15[2] = sub_100031B9C;
        v15[3] = &unk_1000DCBF8;
        v15[4] = a4;
        v15[5] = a3;
        v14 = *(_OWORD *)(a1 + 48);
        v16 = *(_OWORD *)(a1 + 32);
        v17 = v14;
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.kqworkloopexhaustion"), v15);
      }
    }
  }
}

NSDictionary *sub_100031B9C(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[6];
  _QWORD v5[6];

  v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("NumKQWorkLoops");
  v5[2] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[6]);
  v4[3] = CFSTR("NumKQWorkLoopsLimit");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[7]);
  v4[4] = CFSTR("ConditionsPreventingSubmission");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[5] = CFSTR("OtherConditions");
  v5[5] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 6);
}

void sub_100031CB0(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[8];
  int v8;

  v7[1] = 3221225472;
  v7[2] = sub_100031D24;
  v7[3] = &unk_1000DCC38;
  v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  v7[6] = a7;
  v7[7] = a6;
  v7[0] = _NSConcreteStackBlock;
  sub_1000304BC(a1, a2, a3, 7, 0, 0, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_100031D24(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  int IsEventUsed;
  __int128 v16;
  _QWORD v17[6];
  __int128 v18;
  __int128 v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (os_signpost_enabled(log))
  {
    v12 = *(_DWORD *)(a1 + 64);
    v13 = *(_QWORD *)(a1 + 32);
    v14 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    v21 = a4;
    v22 = 2050;
    v23 = a5;
    v24 = 2050;
    v25 = a3;
    v26 = 1026;
    v27 = v12;
    v28 = 2050;
    v29 = v13;
    v30 = 2050;
    v31 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "StuckApp", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    v21 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "StuckApp", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.stuckapp"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472;
        v17[2] = sub_100031EE0;
        v17[3] = &unk_1000DCBF8;
        v17[4] = a4;
        v17[5] = a3;
        v16 = *(_OWORD *)(a1 + 32);
        v18 = *(_OWORD *)(a1 + 48);
        v19 = v16;
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.stuckapp"), v17);
      }
    }
  }
}

NSDictionary *sub_100031EE0(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[5];
  _QWORD v5[5];

  v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("Duration");
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = CFSTR("ConditionsPreventingSubmission");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = CFSTR("OtherConditions");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 5);
}

void sub_100031FEC(int a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  _QWORD v7[8];
  int v8;

  v7[1] = 3221225472;
  v7[2] = sub_100032060;
  v7[3] = &unk_1000DCC38;
  v8 = a1;
  v7[4] = a4;
  v7[5] = a5;
  v7[6] = a7;
  v7[7] = a6;
  v7[0] = _NSConcreteStackBlock;
  sub_1000304BC(a1, a2, a3, 8, 0, 0, a6, a7, 0.0, 0.0, (uint64_t)v7);
}

void sub_100032060(uint64_t a1, os_log_t log, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v12;
  uint64_t v13;
  uint64_t v14;
  int IsEventUsed;
  __int128 v16;
  _QWORD v17[6];
  __int128 v18;
  __int128 v19;
  uint8_t buf[4];
  uint64_t v21;
  __int16 v22;
  uint64_t v23;
  __int16 v24;
  uint64_t v25;
  __int16 v26;
  int v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  if (os_signpost_enabled(log))
  {
    v12 = *(_DWORD *)(a1 + 64);
    v13 = *(_QWORD *)(a1 + 32);
    v14 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)buf = 138544642;
    v21 = a4;
    v22 = 2050;
    v23 = a5;
    v24 = 2050;
    v25 = a3;
    v26 = 1026;
    v27 = v12;
    v28 = 2050;
    v29 = v13;
    v30 = 2050;
    v31 = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "ServiceWatchdog", "BundleIdOverride=%{public, signpost.description:attribute}@ %{public, signpost.description:begin_time}llu cid=%{public,name=cid}llu pid=%{public,name=pid}u conditionsPreventingSubmission=%{public,name=conditionsPreventingSubmission}#llx otherConditions=%{public,name=otherConditions}#llx enableTelemetry=YES ", buf, 0x3Au);
  }
  if (os_signpost_enabled(log))
  {
    *(_DWORD *)buf = 134349056;
    v21 = a6;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, log, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "ServiceWatchdog", "%{public, signpost.description:end_time}llu", buf, 0xCu);
  }
  if (&_AnalyticsIsEventUsed)
  {
    IsEventUsed = AnalyticsIsEventUsed(CFSTR("com.apple.spindump.servicewatchdog"));
    if (a4)
    {
      if (IsEventUsed)
      {
        v17[0] = _NSConcreteStackBlock;
        v17[1] = 3221225472;
        v17[2] = sub_10003221C;
        v17[3] = &unk_1000DCBF8;
        v17[4] = a4;
        v17[5] = a3;
        v16 = *(_OWORD *)(a1 + 32);
        v18 = *(_OWORD *)(a1 + 48);
        v19 = v16;
        AnalyticsSendEventLazy(CFSTR("com.apple.spindump.servicewatchdog"), v17);
      }
    }
  }
}

NSDictionary *sub_10003221C(_QWORD *a1)
{
  uint64_t v2;
  _QWORD v4[5];
  _QWORD v5[5];

  v2 = a1[5];
  v5[0] = a1[4];
  v5[1] = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), v2, CFSTR("BundleID"), CFSTR("CoalitionID"));
  v4[2] = CFSTR("Duration");
  SASecondsFromMachTimeUsingLiveTimebase(a1[6] - a1[7]);
  v5[2] = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
  v4[3] = CFSTR("ConditionsPreventingSubmission");
  v5[3] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[8]);
  v4[4] = CFSTR("OtherConditions");
  v5[4] = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a1[9]);
  return +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v5, v4, 5);
}

void sub_100032328(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  id v10;
  void *v11;
  __CFBundle *v12;
  __CFBundle *v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  double v19;
  id v20;
  double v21;
  id v22;
  double v23;
  BOOL v24;
  int v25;
  NSObject *v26;
  const char *v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  int v36;
  _DWORD *v37;
  const __CFString *v38;
  NSObject *v39;
  const char *v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  FILE *v48;
  int v49;
  NSObject *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  BOOL v57;
  int v58;
  const __CFString *v59;
  NSObject *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  FILE *v67;
  const __CFString *v68;
  const char *v69;
  char *v70;
  char *v71;
  const __CFString *v72;
  const char *CStringPtr;
  char *v74;
  char *v75;
  FILE *v76;
  char v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  FILE *v82;
  const __CFString *v83;
  __CFString *v84;
  uint8_t buf[4];
  const char *v86;
  __int16 v87;
  _BYTE v88[64];
  __int16 v89;
  uint64_t v90;

  v9 = *(_QWORD *)(a1 + 32);
  if (v9
    && (v10 = objc_msgSend(objc_alloc((Class)NSURL), "initFileURLWithPath:isDirectory:", v9, 0)) != 0)
  {
    v11 = v10;
    v12 = (__CFBundle *)_CFBundleCreateWithExecutableURLIfLooksLikeBundle(0, v10);
    if (v12)
    {
      v13 = v12;
      v83 = (id)CFBundleGetIdentifier(v12);
      CFRelease(v13);
    }
    else
    {
      v83 = 0;
    }

    v14 = v83;
  }
  else
  {
    v14 = 0;
  }
  v16 = *(_QWORD *)(a1 + 72);
  v15 = *(_QWORD *)(a1 + 80);
  if (v16)
    v17 = v15 == 0;
  else
    v17 = 1;
  v84 = (__CFString *)v14;
  if (v17)
  {
    v18 = *(_QWORD *)(a1 + 88);
    if (v18 && *(_QWORD *)(a1 + 96))
    {
      objc_msgSend(*(id *)(a1 + 40), "machContTime");
      objc_msgSend(*(id *)(a1 + 40), "machAbsTime");
    }
    else
    {
      v19 = *(double *)(a1 + 104);
      if (v19 == 0.0 || *(double *)(a1 + 112) == 0.0)
      {
        if (v16 | v18 | v15
          || (v19 == 0.0 ? (v24 = *(_QWORD *)(a1 + 96) == 0) : (v24 = 0), !v24 || *(double *)(a1 + 112) != 0.0))
        {
          if ((*(_DWORD *)(a1 + 128) & 0x80000000) != 0)
          {
            if (byte_1000EBD38)
            {
              v49 = *__error();
              v50 = sub_100030318();
              if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
              {
                v51 = *(_QWORD *)(a1 + 72);
                v52 = *(_QWORD *)(a1 + 80);
                v53 = *(_QWORD *)(a1 + 88);
                v54 = *(_QWORD *)(a1 + 96);
                v55 = *(_QWORD *)(a1 + 104);
                v56 = *(_QWORD *)(a1 + 112);
                *(_DWORD *)buf = 136316674;
                v86 = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && "
                      "startTimeCF == 0 && endTimeCF == 0";
                v87 = 2048;
                *(_QWORD *)v88 = v51;
                *(_WORD *)&v88[8] = 2048;
                *(_QWORD *)&v88[10] = v52;
                *(_WORD *)&v88[18] = 2048;
                *(_QWORD *)&v88[20] = v53;
                *(_WORD *)&v88[28] = 2048;
                *(_QWORD *)&v88[30] = v54;
                *(_WORD *)&v88[38] = 2048;
                *(_QWORD *)&v88[40] = v55;
                *(_WORD *)&v88[48] = 2048;
                *(_QWORD *)&v88[50] = v56;
                _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x48u);
              }
              *__error() = v49;
            }
            if (byte_1000EBD39)
              v57 = dword_1000EB4E8 <= 3;
            else
              v57 = 0;
            if (v57)
            {
              v58 = *__error();
              v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f"), "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0", *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112));
              if (v59)
              {
                v72 = v59;
                CStringPtr = CFStringGetCStringPtr(v59, 0x8000100u);
                if (CStringPtr)
                {
                  v74 = (char *)CStringPtr;
                  v75 = 0;
                }
                else
                {
                  v74 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6B85B7B6uLL);
                  CFStringGetCString(v72, v74, 1024, 0x8000100u);
                  v75 = v74;
                }
                if (qword_1000EBD40)
                  v82 = (FILE *)qword_1000EBD40;
                else
                  v82 = __stderrp;
                fprintf(v82, "%s\n", v74);
                if (v75)
                  free(v75);
                CFRelease(v72);
              }
              else
              {
                v60 = sub_100030318();
                if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
                {
                  v61 = *(_QWORD *)(a1 + 72);
                  v62 = *(_QWORD *)(a1 + 80);
                  v63 = *(_QWORD *)(a1 + 88);
                  v64 = *(_QWORD *)(a1 + 96);
                  v65 = *(_QWORD *)(a1 + 104);
                  v66 = *(_QWORD *)(a1 + 112);
                  *(_DWORD *)buf = 136316674;
                  v86 = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 &"
                        "& startTimeCF == 0 && endTimeCF == 0";
                  v87 = 2048;
                  *(_QWORD *)v88 = v61;
                  *(_WORD *)&v88[8] = 2048;
                  *(_QWORD *)&v88[10] = v62;
                  *(_WORD *)&v88[18] = 2048;
                  *(_QWORD *)&v88[20] = v63;
                  *(_WORD *)&v88[28] = 2048;
                  *(_QWORD *)&v88[30] = v64;
                  *(_WORD *)&v88[38] = 2048;
                  *(_QWORD *)&v88[40] = v65;
                  *(_WORD *)&v88[48] = 2048;
                  *(_QWORD *)&v88[50] = v66;
                  _os_log_fault_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_FAULT, "Unable to format: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x48u);
                }
                if (qword_1000EBD40)
                  v67 = (FILE *)qword_1000EBD40;
                else
                  v67 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v67);
              }
              *__error() = v58;
            }
            sub_1000301F0("_SPEventRateReportEvent_block_invoke", "SPEventRate.m", 339, "%s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", a5, v15, a7, a8, (char)"startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0");
          }
          else
          {
            if (byte_1000EBD38)
            {
              v25 = *__error();
              v26 = sub_100030318();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                v27 = (const char *)sub_1000302B4(*(_DWORD *)(a1 + 128));
                v28 = *(_DWORD *)(a1 + 128);
                v29 = *(_QWORD *)(a1 + 72);
                v30 = *(_QWORD *)(a1 + 80);
                v31 = *(_QWORD *)(a1 + 88);
                v32 = *(_QWORD *)(a1 + 96);
                v33 = *(_QWORD *)(a1 + 104);
                v34 = *(_QWORD *)(a1 + 112);
                *(_DWORD *)buf = 136317186;
                v86 = v27;
                v87 = 1024;
                *(_DWORD *)v88 = v28;
                *(_WORD *)&v88[4] = 2080;
                *(_QWORD *)&v88[6] = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeM"
                                     "achAbs == 0 && startTimeCF == 0 && endTimeCF == 0";
                *(_WORD *)&v88[14] = 2048;
                *(_QWORD *)&v88[16] = v29;
                *(_WORD *)&v88[24] = 2048;
                *(_QWORD *)&v88[26] = v30;
                *(_WORD *)&v88[34] = 2048;
                *(_QWORD *)&v88[36] = v31;
                *(_WORD *)&v88[44] = 2048;
                *(_QWORD *)&v88[46] = v32;
                *(_WORD *)&v88[54] = 2048;
                *(_QWORD *)&v88[56] = v33;
                v89 = 2048;
                v90 = v34;
                _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x58u);
              }
              *__error() = v25;
            }
            if (byte_1000EBD39)
              v35 = dword_1000EB4E8 <= 3;
            else
              v35 = 0;
            if (v35)
            {
              v36 = *__error();
              v37 = sub_1000302B4(*(_DWORD *)(a1 + 128));
              v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f"), v37, *(unsigned int *)(a1 + 128), "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTimeMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0", *(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112));
              if (v38)
              {
                v68 = v38;
                v69 = CFStringGetCStringPtr(v38, 0x8000100u);
                if (v69)
                {
                  v70 = (char *)v69;
                  v71 = 0;
                }
                else
                {
                  v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6B85B7B6uLL);
                  CFStringGetCString(v68, v70, 1024, 0x8000100u);
                  v71 = v70;
                }
                if (qword_1000EBD40)
                  v76 = (FILE *)qword_1000EBD40;
                else
                  v76 = __stderrp;
                fprintf(v76, "%s\n", v70);
                if (v71)
                  free(v71);
                CFRelease(v68);
              }
              else
              {
                v39 = sub_100030318();
                if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
                {
                  v40 = (const char *)sub_1000302B4(*(_DWORD *)(a1 + 128));
                  v41 = *(_DWORD *)(a1 + 128);
                  v42 = *(_QWORD *)(a1 + 72);
                  v43 = *(_QWORD *)(a1 + 80);
                  v44 = *(_QWORD *)(a1 + 88);
                  v45 = *(_QWORD *)(a1 + 96);
                  v46 = *(_QWORD *)(a1 + 104);
                  v47 = *(_QWORD *)(a1 + 112);
                  *(_DWORD *)buf = 136317186;
                  v86 = v40;
                  v87 = 1024;
                  *(_DWORD *)v88 = v41;
                  *(_WORD *)&v88[4] = 2080;
                  *(_QWORD *)&v88[6] = "startTimeMachCont == 0 && endTimeMachCont == 0 && startTimeMachAbs == 0 && endTim"
                                       "eMachAbs == 0 && startTimeCF == 0 && endTimeCF == 0";
                  *(_WORD *)&v88[14] = 2048;
                  *(_QWORD *)&v88[16] = v42;
                  *(_WORD *)&v88[24] = 2048;
                  *(_QWORD *)&v88[26] = v43;
                  *(_WORD *)&v88[34] = 2048;
                  *(_QWORD *)&v88[36] = v44;
                  *(_WORD *)&v88[44] = 2048;
                  *(_QWORD *)&v88[46] = v45;
                  *(_WORD *)&v88[54] = 2048;
                  *(_QWORD *)&v88[56] = v46;
                  v89 = 2048;
                  v90 = v47;
                  _os_log_fault_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", buf, 0x58u);
                }
                if (qword_1000EBD40)
                  v48 = (FILE *)qword_1000EBD40;
                else
                  v48 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v48);
              }
              *__error() = v36;
            }
            v77 = sub_1000302B4(*(_DWORD *)(a1 + 128));
            sub_1000301F0("_SPEventRateReportEvent_block_invoke", "SPEventRate.m", 339, "%s [%d]: %s: No matching timestamps provided: %llu-%llu, %llu-%llu, %.2f-%.2f", v78, v79, v80, v81, v77);
          }
          abort();
        }
      }
      else
      {
        objc_msgSend(*(id *)(a1 + 40), "machContTime");
        v20 = objc_msgSend(*(id *)(a1 + 40), "wallTime");
        SAMachTimeFromSecondsUsingLiveTimebase(v20, v21 - *(double *)(a1 + 104));
        objc_msgSend(*(id *)(a1 + 40), "machContTime");
        v22 = objc_msgSend(*(id *)(a1 + 40), "wallTime");
        SAMachTimeFromSecondsUsingLiveTimebase(v22, v23 - *(double *)(a1 + 112));
      }
    }
  }
  (*(void (**)(void))(*(_QWORD *)(a1 + 64) + 16))();

}

void sub_100032AF8(id a1)
{
  qword_1000EBB70 = (uint64_t)os_log_create("com.apple.spindump", "SpinTelemetry");
  qword_1000EBB78 = (uint64_t)os_log_create("com.apple.spindump", "HangTelemetry");
  qword_1000EBB80 = (uint64_t)os_log_create("com.apple.spindump", "CPUResourceTelemetry");
  qword_1000EBB88 = (uint64_t)os_log_create("com.apple.spindump", "DiskWritesResourceTelemetry");
  qword_1000EBB90 = (uint64_t)os_log_create("com.apple.spindump", "FileDescriptorExhaustion");
  qword_1000EBB98 = (uint64_t)os_log_create("com.apple.spindump", "PortExhaustion");
  qword_1000EBBA0 = (uint64_t)os_log_create("com.apple.spindump", "KQWorkLoopExhaustion");
  qword_1000EBBA8 = (uint64_t)os_log_create("com.apple.spindump", "StuckApp");
  qword_1000EBBB0 = (uint64_t)os_log_create("com.apple.spindump", "ServiceWatchdog");
}

void sub_100032BF0(id a1)
{
  NSObject *v1;
  NSObject *v2;

  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000EBBC0 = (uint64_t)dispatch_queue_create("com.apple.spindump.eventrate", v2);
  dispatch_release(v2);
  dispatch_release(v1);
}

void sub_10003306C(const char *a1)
{
  void *v2;
  char *v3;
  char *v4;
  uint64_t v5;
  _QWORD block[6];

  v2 = objc_autoreleasePoolPush();
  v3 = strdup(a1);
  v4 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA21A560AuLL);
  basename_r(v3, v4);
  v5 = sub_100030160("WR for %s", v4);
  free(v4);
  if (qword_1000EBBD8 != -1)
    dispatch_once(&qword_1000EBBD8, &stru_1000DCE50);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10003315C;
  block[3] = &unk_1000DCE30;
  block[4] = v5;
  block[5] = v3;
  dispatch_async((dispatch_queue_t)qword_1000EBBD0, block);
  objc_autoreleasePoolPop(v2);
}

void sub_10003315C(uint64_t a1)
{
  id v2;
  id v3;
  int v4;
  NSObject *v5;
  void *v6;
  int v7;
  const __CFString *v8;
  const __CFString *v9;
  char *v10;
  char *v11;
  int v12;
  NSObject *v13;
  BOOL v14;
  int v15;
  const __CFString *v16;
  const __CFString *v17;
  char *CStringPtr;
  char *v19;
  int v20;
  NSObject *v21;
  int v22;
  const __CFString *v23;
  const __CFString *v24;
  char *v25;
  char *v26;
  NSObject *v27;
  FILE *v28;
  NSObject *v29;
  FILE *v30;
  FILE *v31;
  id v32;
  id v33;
  _BYTE *v34;
  uint64_t v35;
  double v36;
  id v37;
  void *v38;
  id v39;
  int v40;
  NSObject *v41;
  int v42;
  const __CFString *v43;
  const __CFString *v44;
  char *v45;
  char *v46;
  int v47;
  NSObject *v48;
  int v49;
  const __CFString *v50;
  const __CFString *v51;
  char *v52;
  char *v53;
  int v54;
  NSObject *v55;
  int v56;
  const __CFString *v57;
  const __CFString *v58;
  char *v59;
  char *v60;
  int v61;
  NSObject *v62;
  int v63;
  const __CFString *v64;
  const __CFString *v65;
  char *v66;
  char *v67;
  FILE *v68;
  void *v69;
  NSObject *v70;
  FILE *v71;
  int v72;
  NSObject *v73;
  int v74;
  const __CFString *v75;
  const __CFString *v76;
  char *v77;
  char *v78;
  FILE *v79;
  NSObject *v80;
  FILE *v81;
  FILE *v82;
  NSObject *v83;
  FILE *v84;
  NSObject *v85;
  FILE *v86;
  FILE *v87;
  FILE *v88;
  NSObject *v89;
  FILE *v90;
  FILE *v91;
  NSObject *v92;
  FILE *v93;
  FILE *v94;
  void *v95;
  id v96;
  id v97;
  char v98;
  double v99;
  id v100;
  double v101;
  double v102;
  int v103;
  id v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  id v113;
  id v114;
  id v115;
  unint64_t v116;
  id v117;
  void *v118;
  id v119;
  id v120;
  id v121;
  int v122;
  NSObject *v123;
  BOOL v124;
  int v125;
  const __CFString *v126;
  const __CFString *v127;
  char *v128;
  char *v129;
  id v130;
  id v131;
  uint64_t v132;
  void *k;
  id v134;
  id v135;
  uint64_t v136;
  void *m;
  NSObject *v138;
  FILE *v139;
  FILE *v140;
  id v141;
  id v142;
  id v143;
  id v144;
  id v145;
  id v146;
  id v147;
  id v148;
  id v149;
  id v150;
  __int128 v151;
  id v152;
  id v153;
  char v154;
  double v155;
  int v156;
  double v157;
  double v158;
  double v159;
  double v160;
  double v161;
  int v162;
  int v163;
  NSObject *v164;
  int v165;
  const __CFString *v166;
  const __CFString *v167;
  char *v168;
  char *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  id v177;
  id v178;
  unint64_t v179;
  id v180;
  id v181;
  id v182;
  const __CFAllocator *v183;
  uint64_t v184;
  void *v185;
  id v186;
  id v187;
  int v188;
  NSObject *v189;
  BOOL v190;
  int v191;
  const __CFString *v192;
  const __CFString *v193;
  char *v194;
  char *v195;
  id v196;
  uint64_t v197;
  void *n;
  void *v199;
  id v200;
  id v201;
  uint64_t v202;
  void *ii;
  void *v204;
  id v205;
  NSObject *v206;
  FILE *v207;
  FILE *v208;
  id v209;
  id v210;
  id v211;
  id v212;
  id v213;
  id v214;
  id v215;
  id v216;
  NSObject *v217;
  FILE *v218;
  FILE *v219;
  id v220;
  id v221;
  id v222;
  id v223;
  id v224;
  id v225;
  id v226;
  id v227;
  uint64_t v228;
  uint64_t v229;
  id v230;
  NSString *v231;
  void *v232;
  id v233;
  double v234;
  int v235;
  NSObject *v236;
  int v237;
  const __CFString *v238;
  const __CFString *v239;
  char *v240;
  char *v241;
  int v242;
  NSObject *v243;
  const __CFString *v244;
  const __CFString *v245;
  char *v246;
  char *v247;
  int v248;
  NSObject *v249;
  const __CFString *v250;
  char *v251;
  char *v252;
  int v253;
  NSObject *v254;
  id v255;
  int v256;
  const __CFString *v257;
  const __CFString *v258;
  char *v259;
  char *v260;
  NSObject *v261;
  FILE *v262;
  NSObject *v263;
  FILE *v264;
  NSObject *v265;
  FILE *v266;
  FILE *v267;
  id v268;
  id v269;
  int v270;
  NSObject *v271;
  int v272;
  const __CFString *v273;
  const __CFString *v274;
  char *v275;
  char *v276;
  int v277;
  NSObject *v278;
  int v279;
  const __CFString *v280;
  const __CFString *v281;
  char *v282;
  char *v283;
  int v284;
  NSObject *v285;
  const __CFString *v286;
  char *v287;
  char *v288;
  NSObject *v289;
  FILE *v290;
  FILE *v291;
  int v292;
  NSObject *v293;
  const __CFString *v294;
  char *v295;
  char *v296;
  int v297;
  NSObject *v298;
  int v299;
  const __CFString *v300;
  const __CFString *v301;
  char *v302;
  char *v303;
  NSObject *v304;
  FILE *v305;
  NSObject *v306;
  FILE *v307;
  NSObject *v308;
  NSObject *v309;
  FILE *v310;
  FILE *v311;
  NSObject *v312;
  FILE *v313;
  id v314;
  void *v315;
  void *v316;
  id v317;
  id v318;
  id v319;
  id v320;
  int v321;
  NSObject *v322;
  id v323;
  id v324;
  id v325;
  unsigned int v326;
  int v327;
  const __CFString *v328;
  const __CFString *v329;
  char *v330;
  char *v331;
  int v332;
  NSObject *v333;
  id v334;
  unsigned int v335;
  int v336;
  const __CFString *v337;
  const __CFString *v338;
  char *v339;
  char *v340;
  int v341;
  NSObject *v342;
  id v343;
  id v344;
  unsigned int v345;
  int v346;
  const __CFString *v347;
  const __CFString *v348;
  char *v349;
  char *v350;
  NSObject *v351;
  FILE *v352;
  NSObject *v353;
  FILE *v354;
  FILE *v355;
  FILE *v356;
  double v357;
  double v358;
  NSObject *v359;
  FILE *v360;
  FILE *v361;
  double v362;
  double v363;
  double v364;
  NSString *v365;
  int v366;
  NSObject *v367;
  int v368;
  const __CFString *v369;
  const __CFString *v370;
  char *v371;
  char *v372;
  id v373;
  id v374;
  NSString *v375;
  NSObject *v376;
  FILE *v377;
  id v378;
  double v379;
  double v380;
  long double v381;
  FILE *v382;
  id v383;
  id v384;
  id v385;
  unsigned int v386;
  id v387;
  unsigned int v388;
  id v389;
  id v390;
  unsigned int v391;
  FILE *v392;
  FILE *v393;
  NSData *v394;
  NSObject *v395;
  id v396;
  NSUInteger v397;
  FILE *v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  int v403;
  _DWORD *v404;
  const __CFString *v405;
  const __CFString *v406;
  NSObject *v407;
  FILE *v408;
  int v409;
  _DWORD *v410;
  const __CFString *v411;
  const __CFString *v412;
  NSObject *v413;
  FILE *v414;
  int v415;
  NSObject *v416;
  int v417;
  const __CFString *v418;
  const __CFString *v419;
  char *v420;
  char *v421;
  const char *v422;
  int v423;
  int v424;
  const __CFString *v425;
  const __CFString *v426;
  NSObject *v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  FILE *v435;
  int v436;
  const __CFString *v437;
  const __CFString *v438;
  NSObject *v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  FILE *v447;
  int v448;
  NSObject *v449;
  int v450;
  NSObject *v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  int v459;
  NSObject *v460;
  int v461;
  NSObject *v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  NSObject *v470;
  FILE *v471;
  FILE *v472;
  char *v473;
  char *v474;
  char *v475;
  char *v476;
  FILE *v477;
  FILE *v478;
  char *v479;
  char *v480;
  char *v481;
  char *v482;
  FILE *v483;
  char v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  const char *v489;
  int v490;
  FILE *v491;
  id v492;
  id v493;
  id v494;
  id v495;
  uint64_t v496;
  id v497;
  id v498;
  uint64_t v499;
  unint64_t v500;
  uint64_t v501;
  id v502;
  uint64_t v503;
  void *v504;
  id obj;
  id obja;
  CFAllocatorRef v507;
  void *v508;
  void **v509;
  id v510;
  void *i;
  uint64_t v512;
  id alloc;
  uint64_t v514;
  id v515;
  const __CFAllocator *v516;
  id v517;
  id v518;
  CFAllocatorRef v519;
  CFAllocatorRef v520;
  id v521;
  void *v522;
  uint64_t v523;
  void *j;
  id v525;
  id v526;
  id v527;
  void *v528;
  id v529;
  void *v530;
  SPWRReportReason *v531;
  void *jj;
  SPWRReportReason *v533;
  void *v534;
  id v535;
  void *v536;
  void *v537;
  id v538;
  id v539;
  void *v540;
  __int128 v541;
  __int128 v542;
  __int128 v543;
  __int128 v544;
  _QWORD v545[7];
  __int128 v546;
  __int128 v547;
  __int128 v548;
  __int128 v549;
  unint64_t v550;
  unint64_t v551;
  uint64_t v552;
  _QWORD v553[2];
  uint64_t (*v554)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v555;
  uint64_t *v556;
  uint64_t *v557;
  _QWORD v558[2];
  uint64_t (*v559)(_QWORD *);
  void *v560;
  id v561;
  _QWORD *v562;
  uint64_t *v563;
  void *v564;
  uint64_t v565;
  uint64_t *v566;
  uint64_t v567;
  void (*v568)(uint64_t, uint64_t);
  void (*v569)(uint64_t);
  uint64_t v570;
  uint64_t v571;
  uint64_t *v572;
  uint64_t v573;
  void (*v574)(uint64_t, uint64_t);
  void (*v575)(uint64_t);
  uint64_t v576;
  _QWORD v577[3];
  char v578;
  uint64_t v579;
  __int128 v580;
  __int128 v581;
  __int128 v582;
  __int128 v583;
  uint8_t v584[16];
  __int128 v585;
  __int128 v586;
  __int128 v587;
  uint8_t v588[16];
  __int128 v589;
  __int128 v590;
  __int128 v591;
  __int128 v592;
  __int128 v593;
  __int128 v594;
  __int128 v595;
  _BYTE v596[128];
  __int128 v597;
  __int128 v598;
  __int128 v599;
  __int128 v600;
  __int128 v601;
  __int128 v602;
  _BYTE v603[128];
  _BYTE v604[128];
  uint8_t v605[128];
  uint8_t v606[4];
  id v607;
  __int16 v608;
  id v609;
  __int16 v610;
  id v611;
  __int16 v612;
  id v613;
  uint8_t v614[128];
  _BYTE v615[24];
  void *v616;
  id v617;
  id v618;
  uint8_t buf[4];
  id v620;
  __int16 v621;
  id v622;
  __int16 v623;
  NSUInteger v624;
  __int16 v625;
  id v626;
  __int16 v627;
  unsigned int v628;

  v2 = objc_alloc_init((Class)NSUUID);
  if (!objc_opt_class(WRWorkflow))
  {
    if (byte_1000EBD38)
    {
      v12 = *__error();
      v13 = sub_100030318();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        sub_100083330();
      *__error() = v12;
    }
    if (byte_1000EBD39)
      v14 = dword_1000EB4E8 <= 3;
    else
      v14 = 0;
    if (v14)
    {
      v15 = *__error();
      v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: WorkflowResponsivness unavailable, not generating spindump report(s) for %s"), *(_QWORD *)(a1 + 40));
      v17 = v16;
      if (v16)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v16, 0x8000100u);
        if (CStringPtr)
        {
          v19 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x248574ACuLL);
          CFStringGetCString(v17, CStringPtr, 1024, 0x8000100u);
          v19 = CStringPtr;
        }
        if (qword_1000EBD40)
          v68 = (FILE *)qword_1000EBD40;
        else
          v68 = __stderrp;
        fprintf(v68, "%s\n", CStringPtr);
        if (v19)
          free(v19);
        CFRelease(v17);
      }
      else
      {
        v29 = sub_100030318();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
          sub_1000832D0();
        if (qword_1000EBD40)
          v30 = (FILE *)qword_1000EBD40;
        else
          v30 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }
      *__error() = v15;
    }

    v69 = *(void **)(a1 + 40);
    goto LABEL_188;
  }
  v508 = v2;
  v579 = 0;
  v514 = a1;
  v509 = (void **)(a1 + 40);
  v3 = objc_msgSend(objc_alloc((Class)WRWorkflowEventTracker), "initWithTailspin:error:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *(_QWORD *)(a1 + 40)), &v579);
  v540 = v3;
  if (!v3)
  {
    if (byte_1000EBD38)
    {
      v20 = *__error();
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_1000833F4();
      *__error() = v20;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v22 = *__error();
      v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: Unable to decode workflow event tracker: %@"), v579);
      v24 = v23;
      if (v23)
      {
        v25 = (char *)CFStringGetCStringPtr(v23, 0x8000100u);
        if (v25)
        {
          v26 = 0;
        }
        else
        {
          v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3CD3BE78uLL);
          CFStringGetCString(v24, v25, 1024, 0x8000100u);
          v26 = v25;
        }
        if (qword_1000EBD40)
          v79 = (FILE *)qword_1000EBD40;
        else
          v79 = __stderrp;
        fprintf(v79, "%s\n", v25);
        if (v26)
          free(v26);
        CFRelease(v24);
      }
      else
      {
        v70 = sub_100030318();
        if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
          sub_100083394();
        if (qword_1000EBD40)
          v71 = (FILE *)qword_1000EBD40;
        else
          v71 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
      }
      *__error() = v22;
    }
    goto LABEL_187;
  }
  v510 = objc_msgSend(objc_msgSend(v3, "workflow"), "name");
  if (byte_1000EBD38)
  {
    v4 = *__error();
    v5 = sub_100030318();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      v6 = *v509;
      *(_DWORD *)buf = 138412546;
      v620 = v510;
      v621 = 2080;
      v622 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "WR: %@: Received tailspin path %s", buf, 0x16u);
    }
    *__error() = v4;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
  {
    v7 = *__error();
    v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: Received tailspin path %s"), v510, *v509);
    v9 = v8;
    if (v8)
    {
      v10 = (char *)CFStringGetCStringPtr(v8, 0x8000100u);
      if (v10)
      {
        v11 = 0;
      }
      else
      {
        v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50D503B8uLL);
        CFStringGetCString(v9, v10, 1024, 0x8000100u);
        v11 = v10;
      }
      if (qword_1000EBD40)
        v31 = (FILE *)qword_1000EBD40;
      else
        v31 = __stderrp;
      fprintf(v31, "%s\n", v10);
      if (v11)
        free(v11);
      CFRelease(v9);
    }
    else
    {
      v27 = sub_100030318();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
        sub_100083FC4();
      if (qword_1000EBD40)
        v28 = (FILE *)qword_1000EBD40;
      else
        v28 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
    }
    *__error() = v7;
  }
  v32 = objc_msgSend(v540, "eventStart");
  if (!v32)
  {
    if (byte_1000EBD38)
    {
      v47 = *__error();
      v48 = sub_100030318();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        sub_1000834B4();
      *__error() = v47;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v49 = *__error();
      v50 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: No workflow event start"), v510);
      v51 = v50;
      if (v50)
      {
        v52 = (char *)CFStringGetCStringPtr(v50, 0x8000100u);
        if (v52)
        {
          v53 = 0;
        }
        else
        {
          v52 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC01D22FAuLL);
          CFStringGetCString(v51, v52, 1024, 0x8000100u);
          v53 = v52;
        }
        if (qword_1000EBD40)
          v82 = (FILE *)qword_1000EBD40;
        else
          v82 = __stderrp;
        fprintf(v82, "%s\n", v52);
        if (v53)
          free(v53);
        CFRelease(v51);
      }
      else
      {
        v80 = sub_100030318();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
          sub_100083454();
        if (qword_1000EBD40)
          v81 = (FILE *)qword_1000EBD40;
        else
          v81 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
      }
      *__error() = v49;
    }
    goto LABEL_187;
  }
  v33 = objc_msgSend(v540, "eventEnd");
  if (!v33)
  {
    if (byte_1000EBD38)
    {
      v54 = *__error();
      v55 = sub_100030318();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
        sub_100083574();
      *__error() = v54;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v56 = *__error();
      v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: No workflow event end"), v510);
      v58 = v57;
      if (v57)
      {
        v59 = (char *)CFStringGetCStringPtr(v57, 0x8000100u);
        if (v59)
        {
          v60 = 0;
        }
        else
        {
          v59 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7704C0F4uLL);
          CFStringGetCString(v58, v59, 1024, 0x8000100u);
          v60 = v59;
        }
        if (qword_1000EBD40)
          v87 = (FILE *)qword_1000EBD40;
        else
          v87 = __stderrp;
        fprintf(v87, "%s\n", v59);
        if (v60)
          free(v60);
        CFRelease(v58);
      }
      else
      {
        v83 = sub_100030318();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_FAULT))
          sub_100083514();
        if (qword_1000EBD40)
          v84 = (FILE *)qword_1000EBD40;
        else
          v84 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
      }
      *__error() = v56;
    }
    goto LABEL_187;
  }
  v34 = objc_msgSend(v33, "machContTimeNs");
  v35 = v34 - (_BYTE *)objc_msgSend(v32, "machContTimeNs");
  v36 = (double)v35 / 1000000000.0;
  if (v36 <= 0.0)
  {
    if (byte_1000EBD38)
    {
      v61 = *__error();
      v62 = sub_100030318();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        sub_100083F60();
      *__error() = v61;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v63 = *__error();
      v64 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: Workflow event has invalid duration %.3f"), v510, *(_QWORD *)&v36);
      v65 = v64;
      if (v64)
      {
        v66 = (char *)CFStringGetCStringPtr(v64, 0x8000100u);
        if (v66)
        {
          v67 = 0;
        }
        else
        {
          v66 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6FBD131uLL);
          CFStringGetCString(v65, v66, 1024, 0x8000100u);
          v67 = v66;
        }
        if (qword_1000EBD40)
          v88 = (FILE *)qword_1000EBD40;
        else
          v88 = __stderrp;
        fprintf(v88, "%s\n", v66);
        if (v67)
          free(v67);
        CFRelease(v65);
      }
      else
      {
        v85 = sub_100030318();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
          sub_100083EFC();
        if (qword_1000EBD40)
          v86 = (FILE *)qword_1000EBD40;
        else
          v86 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v86);
      }
      *__error() = v63;
    }
LABEL_187:

    v69 = *(void **)(v514 + 40);
LABEL_188:
    free(v69);
    return;
  }
  v37 = objc_msgSend(v540, "error");
  v38 = v37;
  if (v37)
  {
    v39 = objc_msgSend(v37, "domain");
    if (objc_msgSend(v39, "isEqualToString:", WRErrorDomain) && objc_msgSend(v38, "code") == (id)4)
    {
      if (byte_1000EBD38)
      {
        v40 = *__error();
        v41 = sub_100030318();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412546;
          v620 = v510;
          v621 = 2112;
          v622 = v38;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "WR: %@: Workflow event has error %@, still considering for diagnostics", buf, 0x16u);
        }
        *__error() = v40;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v42 = *__error();
        v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: Workflow event has error %@, still considering for diagnostics"), v510, v38);
        v44 = v43;
        if (v43)
        {
          v45 = (char *)CFStringGetCStringPtr(v43, 0x8000100u);
          if (v45)
          {
            v46 = 0;
          }
          else
          {
            v45 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9807387BuLL);
            CFStringGetCString(v44, v45, 1024, 0x8000100u);
            v46 = v45;
          }
          if (qword_1000EBD40)
            v94 = (FILE *)qword_1000EBD40;
          else
            v94 = __stderrp;
          fprintf(v94, "%s\n", v45);
          if (v46)
            free(v46);
          CFRelease(v44);
        }
        else
        {
          v92 = sub_100030318();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
            sub_100083E2C();
          if (qword_1000EBD40)
            v93 = (FILE *)qword_1000EBD40;
          else
            v93 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v93);
        }
        *__error() = v42;
      }
      goto LABEL_203;
    }
    if (byte_1000EBD38)
    {
      v72 = *__error();
      v73 = sub_100030318();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412546;
        v620 = v510;
        v621 = 2112;
        v622 = v38;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_DEFAULT, "WR: %@: Workflow event has error %@, not considering for diagnostics", buf, 0x16u);
      }
      *__error() = v72;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
    {
      v74 = *__error();
      v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: Workflow event has error %@, not considering for diagnostics"), v510, v38);
      v76 = v75;
      if (v75)
      {
        v77 = (char *)CFStringGetCStringPtr(v75, 0x8000100u);
        if (v77)
        {
          v78 = 0;
        }
        else
        {
          v77 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1C15E2B5uLL);
          CFStringGetCString(v76, v77, 1024, 0x8000100u);
          v78 = v77;
        }
        if (qword_1000EBD40)
          v91 = (FILE *)qword_1000EBD40;
        else
          v91 = __stderrp;
        fprintf(v91, "%s\n", v77);
        if (v78)
          free(v78);
        CFRelease(v76);
      }
      else
      {
        v89 = sub_100030318();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
          sub_100083E94();
        if (qword_1000EBD40)
          v90 = (FILE *)qword_1000EBD40;
        else
          v90 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
      }
      *__error() = v74;
    }
    goto LABEL_187;
  }
LABEL_203:
  v577[0] = 0;
  v577[1] = v577;
  v577[2] = 0x2020000000;
  v578 = 0;
  v571 = 0;
  v572 = &v571;
  v573 = 0x3052000000;
  v574 = sub_100038864;
  v575 = sub_100038874;
  v576 = 0;
  v565 = 0;
  v566 = &v565;
  v567 = 0x3052000000;
  v568 = sub_100038864;
  v569 = sub_100038874;
  v570 = 0;
  v558[0] = _NSConcreteStackBlock;
  v558[1] = 3221225472;
  v559 = sub_100038880;
  v560 = &unk_1000DCDB8;
  v95 = *v509;
  v563 = &v571;
  v564 = v95;
  v562 = v577;
  v561 = v510;
  v553[0] = _NSConcreteStackBlock;
  v553[1] = 3221225472;
  v554 = sub_100038EBC;
  v555 = &unk_1000DCDE0;
  v556 = &v565;
  v557 = &v571;
  v579 = 0;
  v502 = objc_msgSend(v540, "encodedStringWithError:", &v579);
  if (!v502)
  {
    v415 = *__error();
    v416 = sub_100030318();
    if (os_log_type_enabled(v416, OS_LOG_TYPE_FAULT))
      sub_100083DCC();
    *__error() = v415;
    if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
    {
      v417 = *__error();
      v418 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to encode workflow event tracked into a string: %@"), v579);
      v419 = v418;
      if (v418)
      {
        v420 = (char *)CFStringGetCStringPtr(v418, 0x8000100u);
        if (v420)
        {
          v421 = 0;
        }
        else
        {
          v420 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC0A1F5DDuLL);
          CFStringGetCString(v419, v420, 1024, 0x8000100u);
          v421 = v420;
        }
        if (qword_1000EBD40)
          v472 = (FILE *)qword_1000EBD40;
        else
          v472 = __stderrp;
        fprintf(v472, "%s\n", v420);
        if (v421)
          free(v421);
        CFRelease(v419);
      }
      else
      {
        v470 = sub_100030318();
        if (os_log_type_enabled(v470, OS_LOG_TYPE_FAULT))
          sub_100083D6C();
        if (qword_1000EBD40)
          v471 = (FILE *)qword_1000EBD40;
        else
          v471 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v471);
      }
      *__error() = v417;
    }
  }
  v539 = objc_alloc_init((Class)NSMutableArray);
  v495 = objc_alloc_init((Class)NSMutableArray);
  v497 = objc_alloc_init((Class)NSMutableDictionary);
  v551 = 0;
  v550 = 0;
  v552 = 0;
  objc_msgSend(v540, "stats");
  v597 = 0u;
  v598 = 0u;
  v599 = 0u;
  v600 = 0u;
  v96 = objc_msgSend(objc_msgSend(v540, "workflow"), "workflowDiagnostics");
  v97 = objc_msgSend(v96, "countByEnumeratingWithState:objects:count:", &v597, buf, 16);
  if (!v97)
    goto LABEL_293;
  obj = v96;
  v499 = v35;
  v98 = 0;
  v507 = *(CFAllocatorRef *)v598;
  v503 = WRErrorDomain;
  while (2)
  {
    for (i = 0; i != v97; i = (char *)i + 1)
    {
      if (*(CFAllocatorRef *)v598 != v507)
        objc_enumerationMutation(obj);
      v536 = *(void **)(*((_QWORD *)&v597 + 1) + 8 * (_QWORD)i);
      v533 = -[SPWRReportReason initWithWorkflowTracker:signpostTracker:diagnostic:]([SPWRReportReason alloc], "initWithWorkflowTracker:signpostTracker:diagnostic:", v540, 0, v536);
      if (!objc_msgSend(v536, "hasTriggerThresholdDurationSingle"))
        goto LABEL_213;
      v99 = (double)0;
      if ((objc_msgSend(v536, "reportOmittingNetworkBoundIntervals") & 1) == 0)
      {
        v100 = objc_msgSend(objc_msgSend(v540, "eventEnd"), "machContTimeNs");
        v99 = (double)(unint64_t)v100
            - (double)(unint64_t)objc_msgSend(objc_msgSend(v540, "eventStart"), "machContTimeNs");
      }
      objc_msgSend(v536, "triggerThresholdDurationSingle");
      v101 = v99 / 1000000000.0;
      if (v102 <= v101)
      {
        if (objc_msgSend(v536, "reportOmittingNetworkBoundIntervals"))
          -[SPWRReportReason setWorkflowDurationOmittingNetworkBoundIntervals:](v533, "setWorkflowDurationOmittingNetworkBoundIntervals:", v101);
        else
          -[SPWRReportReason setWorkflowDuration:](v533, "setWorkflowDuration:", v101);
        v103 = 1;
      }
      else
      {
LABEL_213:
        v103 = 0;
      }
      if (objc_msgSend(v536, "triggerEventTimeout")
        && (v104 = objc_msgSend(v540, "error"),
            objc_msgSend(objc_msgSend(v104, "domain"), "isEqualToString:", v503))
        && objc_msgSend(v104, "code") == (id)4)
      {
        -[SPWRReportReason setWorkflowEventTimedOut:](v533, "setWorkflowEventTimedOut:", 1);
      }
      else if (!v103)
      {
        goto LABEL_287;
      }
      if (objc_msgSend(v536, "hasAnySpindumpReports"))
      {
        v530 = (void *)v559(v558);
        if (!v530)
        {

          v35 = v499;
LABEL_292:
          objc_msgSend(v495, "addObject:", CFSTR("overall"));
          goto LABEL_293;
        }
        v112 = (void *)v554((uint64_t)v553, v105, v106, v107, v108, v109, v110, v111);
        v113 = objc_msgSend(v536, "reportProcessesWithName");
        if (v113)
        {
          v527 = objc_alloc_init((Class)NSMutableArray);
          *(_QWORD *)&v580 = _NSConcreteStackBlock;
          *((_QWORD *)&v580 + 1) = 3221225472;
          *(_QWORD *)&v581 = sub_10003971C;
          *((_QWORD *)&v581 + 1) = &unk_1000DCE78;
          *(_QWORD *)&v582 = v113;
          *((_QWORD *)&v582 + 1) = v527;
          objc_msgSend(v530, "enumerateTasks:", &v580);
        }
        else
        {
          v527 = 0;
        }
        v114 = objc_msgSend(v536, "reportOtherSignpostWithName");
        if (v114)
        {
          v115 = objc_msgSend(objc_msgSend(v540, "allSignpostTrackers"), "mutableCopy");
          if (objc_msgSend(v115, "count"))
          {
            v116 = 0;
            do
            {
              if ((objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(v115, "objectAtIndexedSubscript:", v116), "signpost"), "name"), "isEqualToString:", v114) & 1) == 0)objc_msgSend(v115, "removeObjectAtIndex:", v116--);
              ++v116;
            }
            while (v116 < (unint64_t)objc_msgSend(v115, "count"));
          }
          v595 = 0u;
          v594 = 0u;
          v593 = 0u;
          v592 = 0u;
          v117 = objc_msgSend(v115, "countByEnumeratingWithState:objects:count:", &v592, v614, 16);
          if (v117)
          {
            v517 = v97;
            v519 = *(CFAllocatorRef *)v593;
            v515 = v115;
            do
            {
              v521 = v117;
              for (j = 0; j != v521; j = (char *)j + 1)
              {
                if (*(CFAllocatorRef *)v593 != v519)
                  objc_enumerationMutation(v115);
                v118 = *(void **)(*((_QWORD *)&v592 + 1) + 8 * (_QWORD)j);
                v119 = objc_msgSend(v118, "intervals");
                v120 = objc_msgSend(v118, "incompleteIntervalStarts");
                v121 = objc_msgSend(v119, "count");
                if ((char *)objc_msgSend(v120, "count") + (_QWORD)v121)
                {
                  v591 = 0u;
                  v590 = 0u;
                  v589 = 0u;
                  *(_OWORD *)v588 = 0u;
                  v130 = objc_msgSend(v118, "intervals");
                  v131 = objc_msgSend(v130, "countByEnumeratingWithState:objects:count:", v588, v605, 16);
                  if (v131)
                  {
                    v132 = *(_QWORD *)v589;
                    do
                    {
                      for (k = 0; k != v131; k = (char *)k + 1)
                      {
                        if (*(_QWORD *)v589 != v132)
                          objc_enumerationMutation(v130);
                        sub_100039764(v539, (uint64_t)v533, v530, v540, 0, v536, (uint64_t)v118, v527, v112, (uint64_t)objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)&v588[8] + 8 * (_QWORD)k), "start"), "threadID"), (uint64_t)objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)&v588[8] + 8 * (_QWORD)k), "end"), "threadID"), (unint64_t)objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)&v588[8] + 8 * (_QWORD)k), "start"), "machContTimeNs"), (unint64_t)objc_msgSend(
                                              objc_msgSend(*(id *)(*(_QWORD *)&v588[8] + 8 * (_QWORD)k), "end"),
                                              "machContTimeNs"));
                      }
                      v131 = objc_msgSend(v130, "countByEnumeratingWithState:objects:count:", v588, v605, 16);
                    }
                    while (v131);
                  }
                  v586 = 0u;
                  v587 = 0u;
                  *(_OWORD *)v584 = 0u;
                  v585 = 0u;
                  v97 = v517;
                  v115 = v515;
                  v134 = objc_msgSend(v118, "incompleteIntervalStarts");
                  v135 = objc_msgSend(v134, "countByEnumeratingWithState:objects:count:", v584, v604, 16);
                  if (v135)
                  {
                    v136 = *(_QWORD *)v585;
                    do
                    {
                      for (m = 0; m != v135; m = (char *)m + 1)
                      {
                        if (*(_QWORD *)v585 != v136)
                          objc_enumerationMutation(v134);
                        sub_100039764(v539, (uint64_t)v533, v530, v540, 0, v536, (uint64_t)v118, v527, v112, (uint64_t)objc_msgSend(*(id *)(*(_QWORD *)&v584[8] + 8 * (_QWORD)m), "threadID"), 0, (unint64_t)objc_msgSend(*(id *)(*(_QWORD *)&v584[8] + 8 * (_QWORD)m), "machContTimeNs"), (unint64_t)objc_msgSend(objc_msgSend(v540, "eventEnd"), "machContTimeNs"));
                      }
                      v135 = objc_msgSend(v134, "countByEnumeratingWithState:objects:count:", v584, v604, 16);
                    }
                    while (v135);
                  }
                }
                else
                {
                  if (byte_1000EBD38)
                  {
                    v122 = *__error();
                    v123 = sub_100030318();
                    if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
                    {
                      v141 = objc_msgSend(objc_msgSend(v540, "workflow"), "name");
                      v142 = objc_msgSend(objc_msgSend(v118, "signpost"), "name");
                      v143 = objc_msgSend(v536, "name");
                      *(_DWORD *)v615 = 138412802;
                      *(_QWORD *)&v615[4] = v141;
                      *(_WORD *)&v615[12] = 2112;
                      *(_QWORD *)&v615[14] = v142;
                      *(_WORD *)&v615[22] = 2112;
                      v616 = v143;
                      _os_log_error_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report", v615, 0x20u);
                    }
                    *__error() = v122;
                  }
                  if (byte_1000EBD39)
                    v124 = dword_1000EB4E8 <= 3;
                  else
                    v124 = 0;
                  if (v124)
                  {
                    v125 = *__error();
                    v126 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report"), objc_msgSend(objc_msgSend(v540, "workflow"), "name"), objc_msgSend(objc_msgSend(v118, "signpost"), "name"), objc_msgSend(v536, "name"));
                    v127 = v126;
                    if (v126)
                    {
                      v128 = (char *)CFStringGetCStringPtr(v126, 0x8000100u);
                      if (v128)
                      {
                        v129 = 0;
                      }
                      else
                      {
                        v128 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6CD67639uLL);
                        CFStringGetCString(v127, v128, 1024, 0x8000100u);
                        v129 = v128;
                      }
                      if (qword_1000EBD40)
                        v140 = (FILE *)qword_1000EBD40;
                      else
                        v140 = __stderrp;
                      fprintf(v140, "%s\n", v128);
                      if (v129)
                        free(v129);
                      CFRelease(v127);
                    }
                    else
                    {
                      v138 = sub_100030318();
                      if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT))
                      {
                        v144 = objc_msgSend(objc_msgSend(v540, "workflow"), "name");
                        v145 = objc_msgSend(objc_msgSend(v118, "signpost"), "name");
                        v146 = objc_msgSend(v536, "name");
                        *(_DWORD *)v615 = 138412802;
                        *(_QWORD *)&v615[4] = v144;
                        *(_WORD *)&v615[12] = 2112;
                        *(_QWORD *)&v615[14] = v145;
                        *(_WORD *)&v615[22] = 2112;
                        v616 = v146;
                        _os_log_fault_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to overall workflow, but no intervals to report", v615, 0x20u);
                      }
                      if (qword_1000EBD40)
                        v139 = (FILE *)qword_1000EBD40;
                      else
                        v139 = __stderrp;
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v139);
                    }
                    *__error() = v125;
                  }
                }
              }
              v117 = objc_msgSend(v115, "countByEnumeratingWithState:objects:count:", &v592, v614, 16);
            }
            while (v117);
          }

        }
        else
        {
          sub_100039764(v539, (uint64_t)v533, v530, v540, 0, v536, 0, v527, v112, (uint64_t)objc_msgSend(objc_msgSend(v540, "eventStart"), "threadID"), (uint64_t)objc_msgSend(objc_msgSend(v540, "eventEnd"), "threadID"), (unint64_t)objc_msgSend(objc_msgSend(v540, "eventStart"), "machContTimeNs"), (unint64_t)objc_msgSend(objc_msgSend(v540, "eventEnd"), "machContTimeNs"));
        }

      }
      v98 = 1;
LABEL_287:

    }
    v97 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v597, buf, 16);
    if (v97)
      continue;
    break;
  }
  v35 = v499;
  if ((v98 & 1) != 0)
    goto LABEL_292;
LABEL_293:
  v147 = objc_alloc_init((Class)NSMutableDictionary);
  if (v551 != v35)
    objc_msgSend(v147, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v551 / 1000000000.0), CFSTR("nonNetworkS"));
  if (v552)
    objc_msgSend(v147, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"), CFSTR("numIncomplete"));
  if (v550)
    objc_msgSend(v147, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)v550 / 1000000000.0), CFSTR("untrackedS"));
  if (objc_msgSend(v147, "count"))
    objc_msgSend(v497, "setObject:forKeyedSubscript:", v147, CFSTR("overall"));

  v548 = 0u;
  v549 = 0u;
  v546 = 0u;
  v547 = 0u;
  v148 = objc_msgSend(v540, "allSignpostTrackers");
  v149 = objc_msgSend(v148, "countByEnumeratingWithState:objects:count:", &v546, v603, 16);
  if (v149)
  {
    v496 = *(_QWORD *)v547;
    v492 = v148;
    do
    {
      v504 = 0;
      v493 = v149;
      do
      {
        if (*(_QWORD *)v547 != v496)
          objc_enumerationMutation(v148);
        v534 = *(void **)(*((_QWORD *)&v546 + 1) + 8 * (_QWORD)v504);
        v602 = 0u;
        v601 = 0u;
        v600 = 0u;
        v599 = 0u;
        v598 = 0u;
        v597 = 0u;
        v150 = objc_msgSend(objc_msgSend(v540, "eventEnd"), "machContTimeNs");
        if (!v534)
          goto LABEL_455;
        objc_msgSend(v534, "statsWithEventEndNs:", v150);
        v500 = v597;
        if (!(_QWORD)v597)
          goto LABEL_455;
        v151 = v598;
        v592 = 0u;
        v593 = 0u;
        v594 = 0u;
        v595 = 0u;
        v152 = objc_msgSend(objc_msgSend(v534, "signpost"), "diagnostics");
        v153 = objc_msgSend(v152, "countByEnumeratingWithState:objects:count:", &v592, buf, 16);
        if (!v153)
          goto LABEL_439;
        v498 = v153;
        v494 = v152;
        v154 = 0;
        v501 = *(_QWORD *)v593;
        v155 = (double)*((unint64_t *)&v151 + 1) / 1000000000.0;
        do
        {
          obja = 0;
          do
          {
            if (*(_QWORD *)v593 != v501)
              objc_enumerationMutation(v494);
            v537 = *(void **)(*((_QWORD *)&v592 + 1) + 8 * (_QWORD)obja);
            v531 = -[SPWRReportReason initWithWorkflowTracker:signpostTracker:diagnostic:]([SPWRReportReason alloc], "initWithWorkflowTracker:signpostTracker:diagnostic:", v540, v534, v537);
            if (objc_msgSend(v537, "hasTriggerThresholdCount")
              && v500 >= objc_msgSend(v537, "triggerThresholdCount"))
            {
              if (objc_msgSend(v537, "reportOtherSignpostWithName") || (_QWORD)v151)
              {
                -[SPWRReportReason setSignpostCount:](v531, "setSignpostCount:", v500);
                v156 = 1;
              }
              else
              {
                if (byte_1000EBD38)
                {
                  v163 = *__error();
                  v164 = sub_100030318();
                  if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
                  {
                    v220 = objc_msgSend(objc_msgSend(v540, "workflow"), "name");
                    v221 = objc_msgSend(objc_msgSend(v534, "signpost"), "name");
                    v222 = objc_msgSend(v537, "name");
                    *(_DWORD *)v606 = 138412802;
                    v607 = v220;
                    v608 = 2112;
                    v609 = v221;
                    v610 = 2112;
                    v611 = v222;
                    _os_log_error_impl((void *)&_mh_execute_header, v164, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report", v606, 0x20u);
                  }
                  *__error() = v163;
                }
                v156 = 0;
                if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                {
                  v165 = *__error();
                  v166 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report"), objc_msgSend(objc_msgSend(v540, "workflow"), "name"), objc_msgSend(objc_msgSend(v534, "signpost"), "name"), objc_msgSend(v537, "name"));
                  v167 = v166;
                  if (v166)
                  {
                    v168 = (char *)CFStringGetCStringPtr(v166, 0x8000100u);
                    if (v168)
                    {
                      v169 = 0;
                    }
                    else
                    {
                      v168 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DCEACBFuLL);
                      CFStringGetCString(v167, v168, 1024, 0x8000100u);
                      v169 = v168;
                    }
                    if (qword_1000EBD40)
                      v219 = (FILE *)qword_1000EBD40;
                    else
                      v219 = __stderrp;
                    fprintf(v219, "%s\n", v168);
                    if (v169)
                      free(v169);
                    CFRelease(v167);
                  }
                  else
                  {
                    v217 = sub_100030318();
                    if (os_log_type_enabled(v217, OS_LOG_TYPE_FAULT))
                    {
                      v223 = objc_msgSend(objc_msgSend(v540, "workflow"), "name");
                      v224 = objc_msgSend(objc_msgSend(v534, "signpost"), "name");
                      v225 = objc_msgSend(v537, "name");
                      *(_DWORD *)v606 = 138412802;
                      v607 = v223;
                      v608 = 2112;
                      v609 = v224;
                      v610 = 2112;
                      v611 = v225;
                      _os_log_fault_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to count threshold, but no intervals to report", v606, 0x20u);
                    }
                    if (qword_1000EBD40)
                      v218 = (FILE *)qword_1000EBD40;
                    else
                      v218 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v218);
                  }
                  v156 = 0;
                  *__error() = v165;
                }
              }
            }
            else
            {
              v156 = 0;
            }
            v157 = 0.0;
            if (objc_msgSend(v537, "hasTriggerThresholdDurationSingle"))
            {
              objc_msgSend(v537, "triggerThresholdDurationSingle");
              if (v158 <= v155)
              {
                -[SPWRReportReason setSignpostDurationSingle:](v531, "setSignpostDurationSingle:", v155);
                objc_msgSend(v537, "triggerThresholdDurationSingle");
                v157 = v159;
              }
            }
            if (objc_msgSend(v537, "hasTriggerThresholdDurationSum"))
            {
              objc_msgSend(v537, "triggerThresholdDurationSum");
              if (v160 <= v155)
              {
                -[SPWRReportReason setSignpostDurationSum:](v531, "setSignpostDurationSum:", v155);
                v156 = 1;
              }
            }
            if (objc_msgSend(v537, "hasTriggerThresholdDurationUnion")
              && (objc_msgSend(v537, "triggerThresholdDurationUnion"), v161 <= v155))
            {
              -[SPWRReportReason setSignpostDurationUnion:](v531, "setSignpostDurationUnion:", v155);
              LOBYTE(v156) = 1;
            }
            else
            {
              if (v157 > 0.0)
                v162 = 1;
              else
                v162 = v156;
              if (v162 != 1)
                goto LABEL_417;
            }
            if (objc_msgSend(v537, "hasAnySpindumpReports"))
            {
              v528 = (void *)v559(v558);
              if (!v528)
              {

                v148 = v492;
                goto LABEL_437;
              }
              v522 = (void *)v554((uint64_t)v553, v170, v171, v172, v173, v174, v175, v176);
              v177 = objc_msgSend(v537, "reportOtherSignpostWithName");
              if (v177)
              {
                v178 = objc_msgSend(objc_msgSend(v540, "allSignpostTrackers"), "mutableCopy");
                if (objc_msgSend(v178, "count"))
                {
                  v179 = 0;
                  do
                  {
                    v180 = objc_msgSend(v178, "objectAtIndexedSubscript:", v179);
                    v181 = objc_msgSend(v180, "signpost");
                    if (!objc_msgSend(objc_msgSend(v181, "name"), "isEqualToString:", v177)
                      || objc_msgSend(objc_msgSend(v534, "signpost"), "individuationFieldName")
                      && objc_msgSend(v181, "individuationFieldName")
                      && (!objc_msgSend(v534, "individuationIdentifier")
                       || !objc_msgSend(v180, "individuationIdentifier")
                       || (objc_msgSend(objc_msgSend(v534, "individuationIdentifier"), "isEqualToString:", objc_msgSend(v180, "individuationIdentifier")) & 1) == 0))
                    {
                      objc_msgSend(v178, "removeObjectAtIndex:", v179--);
                    }
                    ++v179;
                  }
                  while (v179 < (unint64_t)objc_msgSend(v178, "count"));
                }
                alloc = objc_msgSend(v178, "copy");

                LOBYTE(v156) = 1;
              }
              else
              {
                alloc = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", v534, 0);
              }
              v182 = objc_msgSend(v537, "reportProcessesWithName");
              if (v182)
              {
                v525 = objc_alloc_init((Class)NSMutableArray);
                *(_QWORD *)v615 = _NSConcreteStackBlock;
                *(_QWORD *)&v615[8] = 3221225472;
                *(_QWORD *)&v615[16] = sub_10003D6FC;
                v616 = &unk_1000DCE78;
                v617 = v182;
                v618 = v525;
                objc_msgSend(v528, "enumerateTasks:", v615);
              }
              else
              {
                v525 = 0;
              }
              v591 = 0u;
              v590 = 0u;
              v589 = 0u;
              *(_OWORD *)v588 = 0u;
              v183 = (const __CFAllocator *)objc_msgSend(alloc, "countByEnumeratingWithState:objects:count:", v588, v614, 16);
              if (v183)
              {
                v184 = *(_QWORD *)v589;
                v512 = *(_QWORD *)v589;
                do
                {
                  v520 = 0;
                  v516 = v183;
                  do
                  {
                    if (*(_QWORD *)v589 != v184)
                      objc_enumerationMutation(alloc);
                    v185 = *(void **)(*(_QWORD *)&v588[8] + 8 * (_QWORD)v520);
                    v186 = objc_msgSend(v185, "intervals");
                    v518 = objc_msgSend(v185, "incompleteIntervalStarts");
                    v187 = objc_msgSend(v186, "count");
                    if ((char *)objc_msgSend(v518, "count") + (_QWORD)v187)
                    {
                      v586 = 0u;
                      v587 = 0u;
                      *(_OWORD *)v584 = 0u;
                      v585 = 0u;
                      v196 = objc_msgSend(v186, "countByEnumeratingWithState:objects:count:", v584, v605, 16);
                      if (v196)
                      {
                        v197 = *(_QWORD *)v585;
                        do
                        {
                          for (n = 0; n != v196; n = (char *)n + 1)
                          {
                            if (*(_QWORD *)v585 != v197)
                              objc_enumerationMutation(v186);
                            v199 = *(void **)(*(_QWORD *)&v584[8] + 8 * (_QWORD)n);
                            if ((v156 & 1) == 0)
                            {
                              v200 = objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)&v584[8] + 8 * (_QWORD)n), "start"), "machContTimeNs");
                              if (v157 + (double)(unint64_t)v200 > (double)(unint64_t)objc_msgSend(objc_msgSend(v199, "end"), "machContTimeNs"))
                                continue;
                            }
                            sub_100039764(v539, (uint64_t)v531, v528, v540, v534, v537, (uint64_t)v185, v525, v522, (uint64_t)objc_msgSend(objc_msgSend(v199, "start"), "threadID"), (uint64_t)objc_msgSend(objc_msgSend(v199, "end"), "threadID"), (unint64_t)objc_msgSend(objc_msgSend(v199, "start"), "machContTimeNs"), (unint64_t)objc_msgSend(objc_msgSend(v199, "end"), "machContTimeNs"));
                          }
                          v196 = objc_msgSend(v186, "countByEnumeratingWithState:objects:count:", v584, v605, 16);
                        }
                        while (v196);
                      }
                      v582 = 0u;
                      v583 = 0u;
                      v580 = 0u;
                      v581 = 0u;
                      v184 = v512;
                      v201 = objc_msgSend(v518, "countByEnumeratingWithState:objects:count:", &v580, v604, 16);
                      if (v201)
                      {
                        v202 = *(_QWORD *)v581;
                        do
                        {
                          for (ii = 0; ii != v201; ii = (char *)ii + 1)
                          {
                            if (*(_QWORD *)v581 != v202)
                              objc_enumerationMutation(v518);
                            v204 = *(void **)(*((_QWORD *)&v580 + 1) + 8 * (_QWORD)ii);
                            if ((v156 & 1) == 0)
                            {
                              v205 = objc_msgSend(*(id *)(*((_QWORD *)&v580 + 1) + 8 * (_QWORD)ii), "machContTimeNs");
                              if (v157 + (double)(unint64_t)v205 > (double)(unint64_t)objc_msgSend(objc_msgSend(v540, "eventEnd"), "machContTimeNs"))
                                continue;
                            }
                            sub_100039764(v539, (uint64_t)v531, v528, v540, v534, v537, (uint64_t)v185, v525, v522, (uint64_t)objc_msgSend(v204, "threadID"), 0, (unint64_t)objc_msgSend(v204, "machContTimeNs"), (unint64_t)objc_msgSend(objc_msgSend(v540, "eventEnd"), "machContTimeNs"));
                          }
                          v201 = objc_msgSend(v518, "countByEnumeratingWithState:objects:count:", &v580, v604, 16);
                        }
                        while (v201);
                      }
                    }
                    else
                    {
                      if (byte_1000EBD38)
                      {
                        v188 = *__error();
                        v189 = sub_100030318();
                        if (os_log_type_enabled(v189, OS_LOG_TYPE_ERROR))
                        {
                          v209 = objc_msgSend(objc_msgSend(v540, "workflow"), "name");
                          v210 = objc_msgSend(objc_msgSend(v185, "signpost"), "name");
                          v211 = objc_msgSend(v537, "name");
                          v212 = objc_msgSend(objc_msgSend(v185, "signpost"), "name");
                          *(_DWORD *)v606 = 138413058;
                          v607 = v209;
                          v608 = 2112;
                          v609 = v210;
                          v610 = 2112;
                          v611 = v211;
                          v612 = 2112;
                          v613 = v212;
                          _os_log_error_impl((void *)&_mh_execute_header, v189, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report", v606, 0x2Au);
                        }
                        *__error() = v188;
                      }
                      if (byte_1000EBD39)
                        v190 = dword_1000EB4E8 <= 3;
                      else
                        v190 = 0;
                      if (v190)
                      {
                        v191 = *__error();
                        v192 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report"), objc_msgSend(objc_msgSend(v540, "workflow"), "name"), objc_msgSend(objc_msgSend(v185, "signpost"), "name"), objc_msgSend(v537, "name"), objc_msgSend(objc_msgSend(v185, "signpost"), "name"));
                        v193 = v192;
                        if (v192)
                        {
                          v194 = (char *)CFStringGetCStringPtr(v192, 0x8000100u);
                          if (v194)
                          {
                            v195 = 0;
                          }
                          else
                          {
                            v194 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2BF4310CuLL);
                            CFStringGetCString(v193, v194, 1024, 0x8000100u);
                            v195 = v194;
                          }
                          if (qword_1000EBD40)
                            v208 = (FILE *)qword_1000EBD40;
                          else
                            v208 = __stderrp;
                          fprintf(v208, "%s\n", v194);
                          if (v195)
                            free(v195);
                          CFRelease(v193);
                        }
                        else
                        {
                          v206 = sub_100030318();
                          if (os_log_type_enabled(v206, OS_LOG_TYPE_FAULT))
                          {
                            v213 = objc_msgSend(objc_msgSend(v540, "workflow"), "name");
                            v214 = objc_msgSend(objc_msgSend(v185, "signpost"), "name");
                            v215 = objc_msgSend(v537, "name");
                            v216 = objc_msgSend(objc_msgSend(v185, "signpost"), "name");
                            *(_DWORD *)v606 = 138413058;
                            v607 = v213;
                            v608 = 2112;
                            v609 = v214;
                            v610 = 2112;
                            v611 = v215;
                            v612 = 2112;
                            v613 = v216;
                            _os_log_fault_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Reporting spindump for this signpost due to %@, but no intervals to report", v606, 0x2Au);
                          }
                          if (qword_1000EBD40)
                            v207 = (FILE *)qword_1000EBD40;
                          else
                            v207 = __stderrp;
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v207);
                        }
                        *__error() = v191;
                      }
                    }
                    v520 = (CFAllocatorRef)((char *)v520 + 1);
                  }
                  while (v520 != v516);
                  v183 = (const __CFAllocator *)objc_msgSend(alloc, "countByEnumeratingWithState:objects:count:", v588, v614, 16);
                }
                while (v183);
              }

            }
            v154 = 1;
LABEL_417:

            obja = (char *)obja + 1;
          }
          while (obja != v498);
          v226 = objc_msgSend(v494, "countByEnumeratingWithState:objects:count:", &v592, buf, 16);
          v498 = v226;
        }
        while (v226);
        v148 = v492;
        if ((v154 & 1) == 0)
          goto LABEL_439;
LABEL_437:
        if ((objc_msgSend(v495, "containsObject:", objc_msgSend(objc_msgSend(v534, "signpost"), "name")) & 1) == 0)
          objc_msgSend(v495, "addObject:", objc_msgSend(objc_msgSend(v534, "signpost"), "name"));
LABEL_439:
        v149 = v493;
        v227 = objc_alloc_init((Class)NSMutableDictionary);
        v228 = v597;
        if ((unint64_t)v597 >= 2)
        {
          objc_msgSend(v227, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"), CFSTR("num"));
          v228 = v597;
        }
        if (v228 != (_QWORD)v600)
          objc_msgSend(v227, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"), CFSTR("numIncomplete"));
        v229 = *((_QWORD *)&v600 + 1);
        if (*((_QWORD *)&v600 + 1))
        {
          objc_msgSend(v227, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)*((unint64_t *)&v600 + 1) / 1000000000.0), CFSTR("unionS"));
          v229 = *((_QWORD *)&v600 + 1);
        }
        if (v229 != (_QWORD)v601)
        {
          objc_msgSend(v227, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)(unint64_t)v601 / 1000000000.0), CFSTR("sumS"));
          v229 = *((_QWORD *)&v600 + 1);
        }
        if (v229 != *((_QWORD *)&v601 + 1))
          objc_msgSend(v227, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", (double)*((unint64_t *)&v601 + 1) / 1000000000.0), CFSTR("maxS"));
        v230 = objc_msgSend(v534, "environment");
        v545[0] = _NSConcreteStackBlock;
        v545[1] = 3221225472;
        v545[2] = sub_1000390E0;
        v545[3] = &unk_1000DCE08;
        v545[4] = v227;
        v545[5] = v510;
        v545[6] = v534;
        objc_msgSend(v230, "enumerateKeysAndObjectsUsingBlock:", v545);
        if (objc_msgSend(v227, "count"))
        {
          if (objc_msgSend(v534, "individuationIdentifier"))
            v231 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%@"), objc_msgSend(objc_msgSend(v534, "signpost"), "name"), objc_msgSend(v534, "individuationIdentifier"));
          else
            v231 = (NSString *)objc_msgSend(objc_msgSend(v534, "signpost"), "name");
          objc_msgSend(v497, "setObject:forKeyedSubscript:", v227, WRSanitizeForCA(v231));
        }

LABEL_455:
        v504 = (char *)v504 + 1;
      }
      while (v504 != v149);
      v149 = objc_msgSend(v148, "countByEnumeratingWithState:objects:count:", &v546, v603, 16);
    }
    while (v149);
  }
  if (!objc_msgSend(v539, "count"))
  {
    if (byte_1000EBD38)
    {
      v242 = *__error();
      v243 = sub_100030318();
      if (os_log_type_enabled(v243, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 138412290;
        v620 = v510;
        _os_log_impl((void *)&_mh_execute_header, v243, OS_LOG_TYPE_INFO, "WR: %@: no spindump reports to generate", buf, 0xCu);
      }
      *__error() = v242;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 1)
      goto LABEL_534;
    v237 = *__error();
    v244 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: no spindump reports to generate"), v510);
    v245 = v244;
    if (!v244)
    {
      v261 = sub_100030318();
      if (os_log_type_enabled(v261, OS_LOG_TYPE_FAULT))
        sub_100083894();
      if (qword_1000EBD40)
        v262 = (FILE *)qword_1000EBD40;
      else
        v262 = __stderrp;
      goto LABEL_518;
    }
    v246 = (char *)CFStringGetCStringPtr(v244, 0x8000100u);
    if (v246)
    {
      v247 = 0;
    }
    else
    {
      v246 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D19C526uLL);
      CFStringGetCString(v245, v246, 1024, 0x8000100u);
      v247 = v246;
    }
    if (qword_1000EBD40)
      v264 = (FILE *)qword_1000EBD40;
    else
      v264 = __stderrp;
    fprintf(v264, "%s\n", v246);
    if (v247)
      free(v247);
    goto LABEL_532;
  }
  v232 = (void *)v572[5];
  if (!v232)
  {
    v248 = *__error();
    v249 = sub_100030318();
    if (os_log_type_enabled(v249, OS_LOG_TYPE_FAULT))
      sub_100083930((uint64_t)v614, (uint64_t)objc_msgSend(v539, "count"), v249);
    *__error() = v248;
    if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
      goto LABEL_534;
    v237 = *__error();
    v250 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: have %lu reports, but no sampleStore"), objc_msgSend(v539, "count"));
    v245 = v250;
    if (!v250)
    {
      v265 = sub_100030318();
      if (os_log_type_enabled(v265, OS_LOG_TYPE_FAULT))
        sub_1000838F4((uint64_t)v605, (uint64_t)objc_msgSend(v539, "count"), v265);
      if (qword_1000EBD40)
        v262 = (FILE *)qword_1000EBD40;
      else
        v262 = __stderrp;
      goto LABEL_518;
    }
    v251 = (char *)CFStringGetCStringPtr(v250, 0x8000100u);
    if (v251)
    {
      v252 = 0;
    }
    else
    {
      v251 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xADD1E47CuLL);
      CFStringGetCString(v245, v251, 1024, 0x8000100u);
      v252 = v251;
    }
    if (qword_1000EBD40)
      v267 = (FILE *)qword_1000EBD40;
    else
      v267 = __stderrp;
    fprintf(v267, "%s\n", v251);
    if (v252)
      free(v252);
LABEL_532:
    CFRelease(v245);
    goto LABEL_533;
  }
  v233 = objc_msgSend(v232, "startTime");
  if (v233 || (v233 = objc_msgSend((id)v572[5], "endTime")) != 0)
  {
    objc_msgSend(v233, "machContTimeSeconds");
    if (v234 != 0.0)
    {
      if (byte_1000EBD38)
      {
        v253 = *__error();
        v254 = sub_100030318();
        if (os_log_type_enabled(v254, OS_LOG_TYPE_DEFAULT))
        {
          v255 = objc_msgSend(v539, "count");
          *(_DWORD *)buf = 138412546;
          v620 = v510;
          v621 = 2048;
          v622 = v255;
          _os_log_impl((void *)&_mh_execute_header, v254, OS_LOG_TYPE_DEFAULT, "WR: %@: generating %lu spindump reports", buf, 0x16u);
        }
        *__error() = v253;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v256 = *__error();
        v257 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: generating %lu spindump reports"), v510, objc_msgSend(v539, "count"));
        v258 = v257;
        if (v257)
        {
          v259 = (char *)CFStringGetCStringPtr(v257, 0x8000100u);
          if (v259)
          {
            v260 = 0;
          }
          else
          {
            v259 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7CE89AEEuLL);
            CFStringGetCString(v258, v259, 1024, 0x8000100u);
            v260 = v259;
          }
          if (qword_1000EBD40)
            v313 = (FILE *)qword_1000EBD40;
          else
            v313 = __stderrp;
          fprintf(v313, "%s\n", v259);
          if (v260)
            free(v260);
          CFRelease(v258);
        }
        else
        {
          v306 = sub_100030318();
          if (os_log_type_enabled(v306, OS_LOG_TYPE_FAULT))
          {
            objc_msgSend(v539, "count");
            sub_100083D24();
          }
          if (qword_1000EBD40)
            v307 = (FILE *)qword_1000EBD40;
          else
            v307 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v307);
        }
        *__error() = v256;
      }
      objc_msgSend((id)v572[5], "setWrWorkflowName:", v510);
      v314 = objc_msgSend(v540, "error");
      objc_msgSend((id)v572[5], "setWrError:", v314);
      v543 = 0u;
      v544 = 0u;
      v541 = 0u;
      v542 = 0u;
      v526 = objc_msgSend(v539, "countByEnumeratingWithState:objects:count:", &v541, v596, 16);
      if (v526)
      {
        v523 = *(_QWORD *)v542;
        do
        {
          for (jj = 0; jj != v526; jj = (char *)jj + 1)
          {
            if (*(_QWORD *)v542 != v523)
              objc_enumerationMutation(v539);
            v315 = *(void **)(*((_QWORD *)&v541 + 1) + 8 * (_QWORD)jj);
            v316 = (void *)v572[5];
            v317 = objc_msgSend(v315, "reportReason");
            v318 = objc_msgSend(objc_msgSend(v317, "workflowTracker"), "workflow");
            v535 = objc_msgSend(v318, "name");
            v319 = objc_msgSend(v317, "signpostTracker");
            v320 = objc_msgSend(v315, "reportedSignpostTracker");
            v538 = objc_msgSend(v315, "timeRange");
            v529 = objc_msgSend(v315, "task");
            objc_msgSend(v316, "setWrWorkflowTimeoutDuration:", 0.0);
            objc_msgSend(v316, "setWrWorkflowDuration:", 0.0);
            objc_msgSend(v316, "setWrWorkflowDurationThreshold:", 0.0);
            objc_msgSend(v316, "setWrWorkflowDurationOmittingNetworkBoundIntervals:", 0.0);
            objc_msgSend(v316, "setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:", 0.0);
            objc_msgSend(v316, "setWrSignpostName:", 0);
            objc_msgSend(v316, "setWrSignpostSubsystem:", 0);
            objc_msgSend(v316, "setWrSignpostCategory:", 0);
            objc_msgSend(v316, "setWrTriggeringSignpostName:", 0);
            objc_msgSend(v316, "setWrTriggeringSignpostSubsystem:", 0);
            objc_msgSend(v316, "setWrTriggeringSignpostCategory:", 0);
            objc_msgSend(v316, "setWrSignpostDurationUnion:", 0.0);
            objc_msgSend(v316, "setWrSignpostDurationUnionThreshold:", 0.0);
            objc_msgSend(v316, "setWrSignpostDurationSum:", 0.0);
            objc_msgSend(v316, "setWrSignpostDurationSumThreshold:", 0.0);
            objc_msgSend(v316, "setWrSignpostDurationSingle:", 0.0);
            objc_msgSend(v316, "setWrSignpostDurationSingleThreshold:", 0.0);
            objc_msgSend(v316, "setWrSignpostCount:", 0);
            objc_msgSend(v316, "setWrSignpostCountThreshold:", 0);
            if (v320)
            {
              objc_msgSend(v316, "setWrSignpostName:", objc_msgSend(objc_msgSend(v320, "signpost"), "name"));
              objc_msgSend(v316, "setWrSignpostSubsystem:", objc_msgSend(objc_msgSend(v320, "signpost"), "subsystem"));
              objc_msgSend(v316, "setWrSignpostCategory:", objc_msgSend(objc_msgSend(v320, "signpost"), "category"));
              if (v319)
              {
                if (byte_1000EBD38)
                {
                  v321 = *__error();
                  v322 = sub_100030318();
                  if (os_log_type_enabled(v322, OS_LOG_TYPE_INFO))
                  {
                    v323 = objc_msgSend(objc_msgSend(v320, "signpost"), "name");
                    v324 = objc_msgSend(objc_msgSend(v319, "signpost"), "name");
                    v325 = objc_msgSend(v529, "name");
                    v326 = objc_msgSend(v529, "pid");
                    *(_DWORD *)buf = 138413314;
                    v620 = v535;
                    v621 = 2112;
                    v622 = v323;
                    v623 = 2112;
                    v624 = (NSUInteger)v324;
                    v625 = 2112;
                    v626 = v325;
                    v627 = 1024;
                    v628 = v326;
                    _os_log_impl((void *)&_mh_execute_header, v322, OS_LOG_TYPE_INFO, "WR: %@ generating report for %@ due to %@ for %@ [%d]", buf, 0x30u);
                  }
                  *__error() = v321;
                }
                if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
                {
                  v327 = *__error();
                  v328 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@ generating report for %@ due to %@ for %@ [%d]"), v535, objc_msgSend(objc_msgSend(v320, "signpost"), "name"), objc_msgSend(objc_msgSend(v319, "signpost"), "name"), objc_msgSend(v529, "name"), objc_msgSend(v529, "pid"));
                  v329 = v328;
                  if (v328)
                  {
                    v330 = (char *)CFStringGetCStringPtr(v328, 0x8000100u);
                    if (v330)
                    {
                      v331 = 0;
                    }
                    else
                    {
                      v330 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6A3A786uLL);
                      CFStringGetCString(v329, v330, 1024, 0x8000100u);
                      v331 = v330;
                    }
                    if (qword_1000EBD40)
                      v355 = (FILE *)qword_1000EBD40;
                    else
                      v355 = __stderrp;
                    fprintf(v355, "%s\n", v330);
                    if (v331)
                      free(v331);
                    CFRelease(v329);
                  }
                  else
                  {
                    v351 = sub_100030318();
                    if (os_log_type_enabled(v351, OS_LOG_TYPE_FAULT))
                    {
                      v383 = objc_msgSend(objc_msgSend(v320, "signpost"), "name");
                      v384 = objc_msgSend(objc_msgSend(v319, "signpost"), "name");
                      v385 = objc_msgSend(v529, "name");
                      v386 = objc_msgSend(v529, "pid");
                      *(_DWORD *)buf = 138413314;
                      v620 = v535;
                      v621 = 2112;
                      v622 = v383;
                      v623 = 2112;
                      v624 = (NSUInteger)v384;
                      v625 = 2112;
                      v626 = v385;
                      v627 = 1024;
                      v628 = v386;
                      _os_log_fault_impl((void *)&_mh_execute_header, v351, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@ generating report for %@ due to %@ for %@ [%d]", buf, 0x30u);
                    }
                    if (qword_1000EBD40)
                      v352 = (FILE *)qword_1000EBD40;
                    else
                      v352 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v352);
                  }
                  *__error() = v327;
                }
                objc_msgSend(v316, "setWrTriggeringSignpostName:", objc_msgSend(objc_msgSend(v319, "signpost"), "name"));
                objc_msgSend(v316, "setWrTriggeringSignpostSubsystem:", objc_msgSend(objc_msgSend(v319, "signpost"), "subsystem"));
                objc_msgSend(v316, "setWrTriggeringSignpostCategory:", objc_msgSend(objc_msgSend(v319, "signpost"), "category"));
              }
              else
              {
                if (byte_1000EBD38)
                {
                  v341 = *__error();
                  v342 = sub_100030318();
                  if (os_log_type_enabled(v342, OS_LOG_TYPE_INFO))
                  {
                    v343 = objc_msgSend(objc_msgSend(v320, "signpost"), "name");
                    v344 = objc_msgSend(v529, "name");
                    v345 = objc_msgSend(v529, "pid");
                    *(_DWORD *)buf = 138413058;
                    v620 = v535;
                    v621 = 2112;
                    v622 = v343;
                    v623 = 2112;
                    v624 = (NSUInteger)v344;
                    v625 = 1024;
                    LODWORD(v626) = v345;
                    _os_log_impl((void *)&_mh_execute_header, v342, OS_LOG_TYPE_INFO, "WR: %@ generating report for %@ due to overall workflow for %@ [%d]", buf, 0x26u);
                  }
                  *__error() = v341;
                }
                if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
                {
                  v346 = *__error();
                  v347 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@ generating report for %@ due to overall workflow for %@ [%d]"), v535, objc_msgSend(objc_msgSend(v320, "signpost"), "name"), objc_msgSend(v529, "name"), objc_msgSend(v529, "pid"));
                  v348 = v347;
                  if (v347)
                  {
                    v349 = (char *)CFStringGetCStringPtr(v347, 0x8000100u);
                    if (v349)
                    {
                      v350 = 0;
                    }
                    else
                    {
                      v349 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCFC5CE55uLL);
                      CFStringGetCString(v348, v349, 1024, 0x8000100u);
                      v350 = v349;
                    }
                    if (qword_1000EBD40)
                      v361 = (FILE *)qword_1000EBD40;
                    else
                      v361 = __stderrp;
                    fprintf(v361, "%s\n", v349);
                    if (v350)
                      free(v350);
                    CFRelease(v348);
                  }
                  else
                  {
                    v359 = sub_100030318();
                    if (os_log_type_enabled(v359, OS_LOG_TYPE_FAULT))
                    {
                      v389 = objc_msgSend(objc_msgSend(v320, "signpost"), "name");
                      v390 = objc_msgSend(v529, "name");
                      v391 = objc_msgSend(v529, "pid");
                      *(_DWORD *)buf = 138413058;
                      v620 = v535;
                      v621 = 2112;
                      v622 = v389;
                      v623 = 2112;
                      v624 = (NSUInteger)v390;
                      v625 = 1024;
                      LODWORD(v626) = v391;
                      _os_log_fault_impl((void *)&_mh_execute_header, v359, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@ generating report for %@ due to overall workflow for %@ [%d]", buf, 0x26u);
                    }
                    if (qword_1000EBD40)
                      v360 = (FILE *)qword_1000EBD40;
                    else
                      v360 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v360);
                  }
                  *__error() = v346;
                }
              }
              if (objc_msgSend(v317, "signpostCount"))
              {
                objc_msgSend(v316, "setWrSignpostCount:", objc_msgSend(v317, "signpostCount"));
                objc_msgSend(v316, "setWrSignpostCountThreshold:", objc_msgSend(objc_msgSend(v317, "diagnostic"), "triggerThresholdCount"));
              }
              objc_msgSend(v317, "signpostDurationUnion");
              if (v362 > 0.0)
              {
                objc_msgSend(v317, "signpostDurationUnion");
                objc_msgSend(v316, "setWrSignpostDurationUnion:");
                objc_msgSend(objc_msgSend(v317, "diagnostic"), "triggerThresholdDurationUnion");
                objc_msgSend(v316, "setWrSignpostDurationUnionThreshold:");
              }
              objc_msgSend(v317, "signpostDurationSum");
              if (v363 > 0.0)
              {
                objc_msgSend(v317, "signpostDurationSum");
                objc_msgSend(v316, "setWrSignpostDurationSum:");
                objc_msgSend(objc_msgSend(v317, "diagnostic"), "triggerThresholdDurationSum");
                objc_msgSend(v316, "setWrSignpostDurationSumThreshold:");
              }
              objc_msgSend(v317, "signpostDurationSingle");
              if (v364 > 0.0)
              {
                objc_msgSend(v317, "signpostDurationSingle");
                objc_msgSend(v316, "setWrSignpostDurationSingle:");
                objc_msgSend(objc_msgSend(v317, "diagnostic"), "triggerThresholdDurationSingle");
                objc_msgSend(v316, "setWrSignpostDurationSingleThreshold:");
              }
            }
            else
            {
              if (byte_1000EBD38)
              {
                v332 = *__error();
                v333 = sub_100030318();
                if (os_log_type_enabled(v333, OS_LOG_TYPE_INFO))
                {
                  v334 = objc_msgSend(v529, "name");
                  v335 = objc_msgSend(v529, "pid");
                  *(_DWORD *)buf = 138412802;
                  v620 = v535;
                  v621 = 2112;
                  v622 = v334;
                  v623 = 1024;
                  LODWORD(v624) = v335;
                  _os_log_impl((void *)&_mh_execute_header, v333, OS_LOG_TYPE_INFO, "WR: %@ generating overall workflow report for %@ [%d]", buf, 0x1Cu);
                }
                *__error() = v332;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
              {
                v336 = *__error();
                v337 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@ generating overall workflow report for %@ [%d]"), v535, objc_msgSend(v529, "name"), objc_msgSend(v529, "pid"));
                v338 = v337;
                if (v337)
                {
                  v339 = (char *)CFStringGetCStringPtr(v337, 0x8000100u);
                  if (v339)
                  {
                    v340 = 0;
                  }
                  else
                  {
                    v339 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x59970C77uLL);
                    CFStringGetCString(v338, v339, 1024, 0x8000100u);
                    v340 = v339;
                  }
                  if (qword_1000EBD40)
                    v356 = (FILE *)qword_1000EBD40;
                  else
                    v356 = __stderrp;
                  fprintf(v356, "%s\n", v339);
                  if (v340)
                    free(v340);
                  CFRelease(v338);
                }
                else
                {
                  v353 = sub_100030318();
                  if (os_log_type_enabled(v353, OS_LOG_TYPE_FAULT))
                  {
                    v387 = objc_msgSend(v529, "name");
                    v388 = objc_msgSend(v529, "pid");
                    *(_DWORD *)buf = 138412802;
                    v620 = v535;
                    v621 = 2112;
                    v622 = v387;
                    v623 = 1024;
                    LODWORD(v624) = v388;
                    _os_log_fault_impl((void *)&_mh_execute_header, v353, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@ generating overall workflow report for %@ [%d]", buf, 0x1Cu);
                  }
                  if (qword_1000EBD40)
                    v354 = (FILE *)qword_1000EBD40;
                  else
                    v354 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v354);
                }
                *__error() = v336;
              }
              objc_msgSend(v317, "workflowDuration");
              if (v357 > 0.0)
              {
                objc_msgSend(v317, "workflowDuration");
                objc_msgSend(v316, "setWrWorkflowDuration:");
                objc_msgSend(objc_msgSend(v317, "diagnostic"), "triggerThresholdDurationSingle");
                objc_msgSend(v316, "setWrWorkflowDurationThreshold:");
              }
              objc_msgSend(v317, "workflowDurationOmittingNetworkBoundIntervals");
              if (v358 > 0.0)
              {
                objc_msgSend(v317, "workflowDurationOmittingNetworkBoundIntervals");
                objc_msgSend(v316, "setWrWorkflowDurationOmittingNetworkBoundIntervals:");
                objc_msgSend(objc_msgSend(v317, "diagnostic"), "triggerThresholdDurationSingle");
                objc_msgSend(v316, "setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:");
              }
              if (objc_msgSend(v317, "workflowEventTimedOut"))
              {
                objc_msgSend(v318, "maximumEventDuration");
                objc_msgSend(v316, "setWrWorkflowTimeoutDuration:");
              }
            }
            if (v319)
              v365 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Workflow responsiveness delay with %@ (%@)"), v535, objc_msgSend(objc_msgSend(v319, "signpost"), "name"));
            else
              v365 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Workflow responsiveness delay with %@"), v535);
            objc_msgSend(v316, "setReason:", v365);
            if (objc_msgSend(v316, "indexOfFirstSampleOnOrAfterTimestamp:", objc_msgSend(v538, "startTime")) == (id)0x7FFFFFFFFFFFFFFFLL
              || objc_msgSend(v316, "indexOfLastSampleOnOrBeforeTimestamp:", objc_msgSend(v538, "endTime")) == (id)0x7FFFFFFFFFFFFFFFLL)
            {
              if (byte_1000EBD38)
              {
                v366 = *__error();
                v367 = sub_100030318();
                if (os_log_type_enabled(v367, OS_LOG_TYPE_ERROR))
                  sub_100083A28(v588, &v588[1], v367);
                *__error() = v366;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v368 = *__error();
                v369 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Sample store contains no samples for the signpost interval, not generating spindump report"));
                v370 = v369;
                if (v369)
                {
                  v371 = (char *)CFStringGetCStringPtr(v369, 0x8000100u);
                  if (v371)
                  {
                    v372 = 0;
                  }
                  else
                  {
                    v371 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x554CB48EuLL);
                    CFStringGetCString(v370, v371, 1024, 0x8000100u);
                    v372 = v371;
                  }
                  if (qword_1000EBD40)
                    v382 = (FILE *)qword_1000EBD40;
                  else
                    v382 = __stderrp;
                  fprintf(v382, "%s\n", v371);
                  if (v372)
                    free(v372);
                  CFRelease(v370);
                }
                else
                {
                  v376 = sub_100030318();
                  if (os_log_type_enabled(v376, OS_LOG_TYPE_FAULT))
                    sub_1000839EC(v584, &v584[1], v376);
                  if (qword_1000EBD40)
                    v377 = (FILE *)qword_1000EBD40;
                  else
                    v377 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v377);
                }
                *__error() = v368;
              }
            }
            else
            {
              objc_msgSend(v316, "setTargetProcess:", objc_msgSend(v315, "task"));
              if (objc_msgSend(v315, "thread"))
              {
                objc_msgSend(v316, "setTargetThreadId:", objc_msgSend(objc_msgSend(v315, "thread"), "threadId"));
                v373 = objc_msgSend(v316, "targetDispatchQueueId");
                if (v373 != objc_msgSend(objc_msgSend(v315, "dispatchQueue"), "identifier"))
                {
                  if ((objc_msgSend(v529, "pid") & 0x80000000) == 0)
                  {
                    if (byte_1000EBD38)
                    {
                      v448 = *__error();
                      v449 = sub_100030318();
                      if (os_log_type_enabled(v449, OS_LOG_TYPE_ERROR))
                      {
                        sub_1000302B4((int)objc_msgSend(v529, "pid"));
                        objc_msgSend(v529, "pid");
                        sub_100083C04();
                      }
                      *__error() = v448;
                    }
                    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                    {
                      v403 = *__error();
                      v404 = sub_1000302B4((int)objc_msgSend(v529, "pid"));
                      v405 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: Unable to set target thread"), v404, objc_msgSend(v529, "pid"), "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                      v406 = v405;
                      if (v405)
                      {
                        v479 = (char *)CFStringGetCStringPtr(v405, 0x8000100u);
                        if (v479)
                        {
                          v480 = 0;
                        }
                        else
                        {
                          v479 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8AC3D246uLL);
                          CFStringGetCString(v406, v479, 1024, 0x8000100u);
                          v480 = v479;
                        }
                        if (qword_1000EBD40)
                          v483 = (FILE *)qword_1000EBD40;
                        else
                          v483 = __stderrp;
                        fprintf(v483, "%s\n", v479);
                        if (v480)
                          free(v480);
                        CFRelease(v406);
                      }
                      else
                      {
                        v407 = sub_100030318();
                        if (os_log_type_enabled(v407, OS_LOG_TYPE_FAULT))
                        {
                          sub_1000302B4((int)objc_msgSend(v529, "pid"));
                          objc_msgSend(v529, "pid");
                          sub_100083BC4();
                        }
                        if (qword_1000EBD40)
                          v408 = (FILE *)qword_1000EBD40;
                        else
                          v408 = __stderrp;
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v408);
                      }
                      *__error() = v403;
                    }
                    v484 = sub_1000302B4((int)objc_msgSend(v529, "pid"));
                    objc_msgSend(v529, "pid");
                    v489 = "%s [%d]: %s: Unable to set target thread";
                    v490 = 236;
LABEL_920:
                    sub_1000301F0("GenerateWorkflowResponsivenessReport", "monitor-WorkflowResponsiveness.m", v490, v489, v485, v486, v487, v488, v484);
LABEL_897:
                    abort();
                  }
                  if (byte_1000EBD38)
                  {
                    v450 = *__error();
                    v451 = sub_100030318();
                    if (os_log_type_enabled(v451, OS_LOG_TYPE_ERROR))
                      sub_100083CB4(v451, v452, v453, v454, v455, v456, v457, v458);
                    *__error() = v450;
                  }
                  v422 = "%s: Unable to set target thread";
                  v423 = 236;
                  if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                  {
                    v424 = *__error();
                    v425 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Unable to set target thread"), "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                    v426 = v425;
                    if (v425)
                    {
                      v473 = (char *)CFStringGetCStringPtr(v425, 0x8000100u);
                      if (v473)
                      {
                        v474 = 0;
                      }
                      else
                      {
                        v473 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8AC3D246uLL);
                        CFStringGetCString(v426, v473, 1024, 0x8000100u);
                        v474 = v473;
                      }
                      if (qword_1000EBD40)
                        v477 = (FILE *)qword_1000EBD40;
                      else
                        v477 = __stderrp;
                      fprintf(v477, "%s\n", v473);
                      if (v474)
                        free(v474);
                      CFRelease(v426);
                    }
                    else
                    {
                      v427 = sub_100030318();
                      if (os_log_type_enabled(v427, OS_LOG_TYPE_FAULT))
                        sub_100083C44(v427, v428, v429, v430, v431, v432, v433, v434);
                      if (qword_1000EBD40)
                        v435 = (FILE *)qword_1000EBD40;
                      else
                        v435 = __stderrp;
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v435);
                    }
                    *__error() = v424;
                    v422 = "%s: Unable to set target thread";
                    v423 = 236;
                  }
LABEL_896:
                  sub_1000301F0("GenerateWorkflowResponsivenessReport", "monitor-WorkflowResponsiveness.m", v423, v422, v399, v400, v401, v402, (char)"sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                  goto LABEL_897;
                }
              }
              if (objc_msgSend(v315, "dispatchQueue"))
              {
                objc_msgSend(v316, "setTargetDispatchQueueId:", objc_msgSend(objc_msgSend(v315, "dispatchQueue"), "identifier"));
                v374 = objc_msgSend(v316, "targetDispatchQueueId");
                if (v374 != objc_msgSend(objc_msgSend(v315, "dispatchQueue"), "identifier"))
                {
                  if ((objc_msgSend(v529, "pid") & 0x80000000) == 0)
                  {
                    if (byte_1000EBD38)
                    {
                      v459 = *__error();
                      v460 = sub_100030318();
                      if (os_log_type_enabled(v460, OS_LOG_TYPE_ERROR))
                      {
                        sub_1000302B4((int)objc_msgSend(v529, "pid"));
                        objc_msgSend(v529, "pid");
                        sub_100083AA4();
                      }
                      *__error() = v459;
                    }
                    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                    {
                      v409 = *__error();
                      v410 = sub_1000302B4((int)objc_msgSend(v529, "pid"));
                      v411 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: Unable to set target dispatch queue"), v410, objc_msgSend(v529, "pid"), "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                      v412 = v411;
                      if (v411)
                      {
                        v481 = (char *)CFStringGetCStringPtr(v411, 0x8000100u);
                        if (v481)
                        {
                          v482 = 0;
                        }
                        else
                        {
                          v481 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x70AE332DuLL);
                          CFStringGetCString(v412, v481, 1024, 0x8000100u);
                          v482 = v481;
                        }
                        if (qword_1000EBD40)
                          v491 = (FILE *)qword_1000EBD40;
                        else
                          v491 = __stderrp;
                        fprintf(v491, "%s\n", v481);
                        if (v482)
                          free(v482);
                        CFRelease(v412);
                      }
                      else
                      {
                        v413 = sub_100030318();
                        if (os_log_type_enabled(v413, OS_LOG_TYPE_FAULT))
                        {
                          sub_1000302B4((int)objc_msgSend(v529, "pid"));
                          objc_msgSend(v529, "pid");
                          sub_100083A64();
                        }
                        if (qword_1000EBD40)
                          v414 = (FILE *)qword_1000EBD40;
                        else
                          v414 = __stderrp;
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v414);
                      }
                      *__error() = v409;
                    }
                    v484 = sub_1000302B4((int)objc_msgSend(v529, "pid"));
                    objc_msgSend(v529, "pid");
                    v489 = "%s [%d]: %s: Unable to set target dispatch queue";
                    v490 = 240;
                    goto LABEL_920;
                  }
                  if (byte_1000EBD38)
                  {
                    v461 = *__error();
                    v462 = sub_100030318();
                    if (os_log_type_enabled(v462, OS_LOG_TYPE_ERROR))
                      sub_100083B54(v462, v463, v464, v465, v466, v467, v468, v469);
                    *__error() = v461;
                  }
                  v422 = "%s: Unable to set target dispatch queue";
                  v423 = 240;
                  if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                  {
                    v436 = *__error();
                    v437 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Unable to set target dispatch queue"), "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier");
                    v438 = v437;
                    if (v437)
                    {
                      v475 = (char *)CFStringGetCStringPtr(v437, 0x8000100u);
                      if (v475)
                      {
                        v476 = 0;
                      }
                      else
                      {
                        v475 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x70AE332DuLL);
                        CFStringGetCString(v438, v475, 1024, 0x8000100u);
                        v476 = v475;
                      }
                      if (qword_1000EBD40)
                        v478 = (FILE *)qword_1000EBD40;
                      else
                        v478 = __stderrp;
                      fprintf(v478, "%s\n", v475);
                      if (v476)
                        free(v476);
                      CFRelease(v438);
                    }
                    else
                    {
                      v439 = sub_100030318();
                      if (os_log_type_enabled(v439, OS_LOG_TYPE_FAULT))
                        sub_100083AE4(v439, v440, v441, v442, v443, v444, v445, v446);
                      if (qword_1000EBD40)
                        v447 = (FILE *)qword_1000EBD40;
                      else
                        v447 = __stderrp;
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v447);
                    }
                    *__error() = v436;
                    v422 = "%s: Unable to set target dispatch queue";
                    v423 = 240;
                  }
                  goto LABEL_896;
                }
              }
              objc_msgSend(v316, "setEvent:", CFSTR("Workflow Responsiveness Delay"));
              if (v319)
                v375 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@, %@.%@.%@, %@"), v535, objc_msgSend(objc_msgSend(v319, "signpost"), "subsystem"), objc_msgSend(objc_msgSend(v319, "signpost"), "category"), objc_msgSend(objc_msgSend(v319, "signpost"), "name"), objc_msgSend(objc_msgSend(v317, "diagnostic"), "name"));
              else
                v375 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@, %@"), v535, objc_msgSend(objc_msgSend(v317, "diagnostic"), "name"));
              objc_msgSend(v316, "setEventNote:", v375);
              objc_msgSend(v316, "setEventTimeRange:", v538);
              objc_msgSend(v316, "setCustomOutput:", v502);
              v378 = objc_msgSend(objc_alloc((Class)SASamplePrinter), "initWithSampleStore:", v316);
              objc_msgSend(objc_msgSend(v378, "options"), "setPrintHeavyStacks:", 1);
              objc_msgSend(objc_msgSend(v378, "options"), "setPrintSpinSignatureStack:", 1);
              objc_msgSend(objc_msgSend(v378, "options"), "setForceOneBasedTimeIndexes:", 1);
              objc_msgSend(v378, "setIncidentUUID:", v508);
              objc_msgSend(v378, "filterToTimestampRangeStart:end:", objc_msgSend(v538, "startTime"), objc_msgSend(v538, "endTime"));
              objc_msgSend(objc_msgSend(v538, "startTime"), "deltaSecondsTo:timeDomainPriorityList:timeDomainUsed:", objc_msgSend(v538, "endTime"), &off_1000E6FF0, 0);
              v380 = v379;
              objc_msgSend(objc_msgSend(v538, "startTime"), "wallTime");
              sub_10004D06C(v378, 0, 0, 14, 0, 0, 1, 0, v381, v380, 0, 0);
            }
          }
          v526 = objc_msgSend(v539, "countByEnumeratingWithState:objects:count:", &v541, v596, 16);
        }
        while (v526);
      }
      goto LABEL_534;
    }
  }
  if (byte_1000EBD38)
  {
    v235 = *__error();
    v236 = sub_100030318();
    if (os_log_type_enabled(v236, OS_LOG_TYPE_ERROR))
    {
      objc_msgSend(v233, "debugDescription");
      sub_1000839A4();
    }
    *__error() = v235;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
    goto LABEL_534;
  v237 = *__error();
  v238 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: Unable to compare timesamps with tailspin data (%@)"), v510, objc_msgSend(v233, "debugDescription"));
  v239 = v238;
  if (!v238)
  {
    v263 = sub_100030318();
    if (os_log_type_enabled(v263, OS_LOG_TYPE_FAULT))
    {
      objc_msgSend(v233, "debugDescription");
      sub_10008396C();
    }
    if (qword_1000EBD40)
      v262 = (FILE *)qword_1000EBD40;
    else
      v262 = __stderrp;
LABEL_518:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v262);
    goto LABEL_533;
  }
  v240 = (char *)CFStringGetCStringPtr(v238, 0x8000100u);
  if (v240)
  {
    v241 = 0;
  }
  else
  {
    v240 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE753EFuLL);
    CFStringGetCString(v239, v240, 1024, 0x8000100u);
    v241 = v240;
  }
  if (qword_1000EBD40)
    v266 = (FILE *)qword_1000EBD40;
  else
    v266 = __stderrp;
  fprintf(v266, "%s\n", v240);
  if (v241)
    free(v241);
  CFRelease(v239);
LABEL_533:
  *__error() = v237;
LABEL_534:

  if (&_DRShouldGatherLog)
  {
    sub_100039408(v497);
    v268 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithObjectsAndKeys:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", v36 * 1000.0), CFSTR("durationms"), CFSTR("239"), CFSTR("bugtype"), v510, CFSTR("workflow"), v495, CFSTR("exceededThresholds"), objc_msgSend(v508, "UUIDString"), CFSTR("IncidentUUID"), v497, CFSTR("stats"), 0);
    if (objc_msgSend(v540, "error"))
    {
      v269 = objc_msgSend(objc_msgSend(v540, "error"), "domain");
      if (objc_msgSend(v269, "isEqualToString:", WRErrorDomain))
        objc_msgSend(v268, "setObject:forKeyedSubscript:", +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", objc_msgSend(objc_msgSend(v540, "error"), "code")), CFSTR("error"));
      else
        objc_msgSend(v268, "setObject:forKeyedSubscript:", &off_1000E6ED0, CFSTR("error"));
    }
    *(_QWORD *)&v592 = 0;
    if (!DRShouldGatherLog(CFSTR("com.apple.spindump"), CFSTR("WorkflowResponsiveness"), v268, CFSTR("tailspin"), &v592))
    {
      if ((_QWORD)v592)
      {
        if (byte_1000EBD38)
        {
          v277 = *__error();
          v278 = sub_100030318();
          if (os_log_type_enabled(v278, OS_LOG_TYPE_ERROR))
          {
            objc_msgSend((id)v592, "description");
            sub_10008385C();
          }
          *__error() = v277;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
          goto LABEL_799;
        v279 = *__error();
        v280 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: error in DRShouldGatherLog call: %@"), v510, objc_msgSend((id)v592, "description"));
        v281 = v280;
        if (!v280)
        {
          v304 = sub_100030318();
          if (os_log_type_enabled(v304, OS_LOG_TYPE_FAULT))
          {
            objc_msgSend((id)v592, "description");
            sub_100083824();
          }
          if (qword_1000EBD40)
            v305 = (FILE *)qword_1000EBD40;
          else
            v305 = __stderrp;
          goto LABEL_635;
        }
        v282 = (char *)CFStringGetCStringPtr(v280, 0x8000100u);
        if (v282)
        {
          v283 = 0;
        }
        else
        {
          v282 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x903F011DuLL);
          CFStringGetCString(v281, v282, 1024, 0x8000100u);
          v283 = v282;
        }
        if (qword_1000EBD40)
          v311 = (FILE *)qword_1000EBD40;
        else
          v311 = __stderrp;
        fprintf(v311, "%s\n", v282);
        if (v283)
          free(v283);
      }
      else
      {
        if (byte_1000EBD38)
        {
          v284 = *__error();
          v285 = sub_100030318();
          if (os_log_type_enabled(v285, OS_LOG_TYPE_DEBUG))
            sub_1000837C4();
          *__error() = v284;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
          goto LABEL_799;
        v279 = *__error();
        v286 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: DRShouldGatherLog return false, not submitting tailspin"), v510);
        v281 = v286;
        if (!v286)
        {
          v312 = sub_100030318();
          if (os_log_type_enabled(v312, OS_LOG_TYPE_FAULT))
            sub_100083764();
          if (qword_1000EBD40)
            v305 = (FILE *)qword_1000EBD40;
          else
            v305 = __stderrp;
          goto LABEL_635;
        }
        v287 = (char *)CFStringGetCStringPtr(v286, 0x8000100u);
        if (v287)
        {
          v288 = 0;
        }
        else
        {
          v287 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x12D257D7uLL);
          CFStringGetCString(v281, v287, 1024, 0x8000100u);
          v288 = v287;
        }
        if (qword_1000EBD40)
          v398 = (FILE *)qword_1000EBD40;
        else
          v398 = __stderrp;
        fprintf(v398, "%s\n", v287);
        if (v288)
          free(v288);
      }
LABEL_797:
      CFRelease(v281);
      goto LABEL_798;
    }
    if (byte_1000EBD38)
    {
      v270 = *__error();
      v271 = sub_100030318();
      if (os_log_type_enabled(v271, OS_LOG_TYPE_DEBUG))
        sub_100083704();
      *__error() = v270;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v272 = *__error();
      v273 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: submitting tailspin to Diagnostic Pipeline"), v510);
      v274 = v273;
      if (v273)
      {
        v275 = (char *)CFStringGetCStringPtr(v273, 0x8000100u);
        if (v275)
        {
          v276 = 0;
        }
        else
        {
          v275 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB07D7A88uLL);
          CFStringGetCString(v274, v275, 1024, 0x8000100u);
          v276 = v275;
        }
        if (qword_1000EBD40)
          v291 = (FILE *)qword_1000EBD40;
        else
          v291 = __stderrp;
        fprintf(v291, "%s\n", v275);
        if (v276)
          free(v276);
        CFRelease(v274);
      }
      else
      {
        v289 = sub_100030318();
        if (os_log_type_enabled(v289, OS_LOG_TYPE_FAULT))
          sub_1000836A4();
        if (qword_1000EBD40)
          v290 = (FILE *)qword_1000EBD40;
        else
          v290 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v290);
      }
      *__error() = v272;
    }
    if (DRSubmitLog(CFSTR("com.apple.spindump"), CFSTR("WorkflowResponsiveness"), v510, v268, CFSTR("tailspin"), +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", *v509), 0, &v592))
    {
      if (byte_1000EBD38)
      {
        v292 = *__error();
        v293 = sub_100030318();
        if (os_log_type_enabled(v293, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412290;
          v620 = v510;
          _os_log_impl((void *)&_mh_execute_header, v293, OS_LOG_TYPE_DEFAULT, "WR: %@: submitted tailspin to Diagnostic Pipeline", buf, 0xCu);
        }
        *__error() = v292;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v279 = *__error();
        v294 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: submitted tailspin to Diagnostic Pipeline"), v510);
        v281 = v294;
        if (v294)
        {
          v295 = (char *)CFStringGetCStringPtr(v294, 0x8000100u);
          if (v295)
          {
            v296 = 0;
          }
          else
          {
            v295 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x337AF97FuLL);
            CFStringGetCString(v281, v295, 1024, 0x8000100u);
            v296 = v295;
          }
          if (qword_1000EBD40)
            v392 = (FILE *)qword_1000EBD40;
          else
            v392 = __stderrp;
          fprintf(v392, "%s\n", v295);
          if (v296)
            free(v296);
          goto LABEL_797;
        }
        v308 = sub_100030318();
        if (os_log_type_enabled(v308, OS_LOG_TYPE_FAULT))
          sub_1000835D4();
        if (qword_1000EBD40)
          v305 = (FILE *)qword_1000EBD40;
        else
          v305 = __stderrp;
LABEL_635:
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v305);
LABEL_798:
        *__error() = v279;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v297 = *__error();
        v298 = sub_100030318();
        if (os_log_type_enabled(v298, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend((id)v592, "description");
          sub_10008366C();
        }
        *__error() = v297;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v299 = *__error();
        v300 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: error trying to provide tailspin to Diagnostic Pipeline: %@"), v510, objc_msgSend((id)v592, "description"));
        v301 = v300;
        if (v300)
        {
          v302 = (char *)CFStringGetCStringPtr(v300, 0x8000100u);
          if (v302)
          {
            v303 = 0;
          }
          else
          {
            v302 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x86C0BA83uLL);
            CFStringGetCString(v301, v302, 1024, 0x8000100u);
            v303 = v302;
          }
          if (qword_1000EBD40)
            v393 = (FILE *)qword_1000EBD40;
          else
            v393 = __stderrp;
          fprintf(v393, "%s\n", v302);
          if (v303)
            free(v303);
          CFRelease(v301);
        }
        else
        {
          v309 = sub_100030318();
          if (os_log_type_enabled(v309, OS_LOG_TYPE_FAULT))
          {
            objc_msgSend((id)v592, "description");
            sub_100083634();
          }
          if (qword_1000EBD40)
            v310 = (FILE *)qword_1000EBD40;
          else
            v310 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v310);
        }
        *__error() = v299;
      }
      v394 = +[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", v268, 200, 0, 0);
      v395 = sub_100030318();
      if (os_signpost_enabled(v395))
      {
        v396 = objc_msgSend((id)v592, "localizedDescription");
        v397 = -[NSData length](v394, "length");
        *(_DWORD *)buf = 138543874;
        v620 = v510;
        v621 = 2114;
        v622 = v396;
        v623 = 2050;
        v624 = v397;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v395, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "DPFailure", "Workflow:%{signpost.telemetry:string1,public}@ error:%{signpost.telemetry:string2,public}@ contextDictionarySize:%{signpost.telemetry:number1,public}lu enableTelemetry=YES ", buf, 0x20u);
      }
    }
LABEL_799:

  }
  free(*v509);
  _Block_object_dispose(&v565, 8);
  _Block_object_dispose(&v571, 8);
  _Block_object_dispose(v577, 8);
}

void sub_10003864C(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x2F8], 8);
  _Block_object_dispose(&STACK[0x328], 8);
  _Block_object_dispose(&STACK[0x358], 8);
  _Unwind_Resume(a1);
}

void sub_100038864(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_100038874(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

uint64_t sub_100038880(_QWORD *a1)
{
  _QWORD *v1;
  uint64_t v2;
  id v3;
  id v4;
  char *v5;
  char *v6;
  int *v7;
  id v8;
  uint64_t v9;
  void *i;
  const __CFString *v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  const __CFString *v18;
  const __CFString *v19;
  id v20;
  uint64_t v21;
  _QWORD *v22;
  char *v23;
  char *v24;
  int *v25;
  const char *CStringPtr;
  char *v27;
  char *v28;
  NSObject *v29;
  FILE *v30;
  FILE *v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  NSObject *v35;
  int v36;
  const __CFString *v37;
  const __CFString *v38;
  const __CFString *v39;
  const char *v40;
  char *v41;
  char *v42;
  NSObject *v43;
  FILE *v44;
  FILE *v45;
  uint64_t v47;
  uint64_t v48;
  const __CFString *v49;
  uint64_t v50;
  uint64_t v51;
  const __CFString *v52;
  unsigned __int8 v53;
  id obj;
  int v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  const __CFString *v60;
  uint8_t buf[4];
  uint64_t v62;
  __int16 v63;
  uint64_t v64;
  __int16 v65;
  const __CFString *v66;
  _BYTE v67[128];

  v1 = a1;
  v2 = *(_QWORD *)(a1[5] + 8);
  if (!*(_BYTE *)(v2 + 24))
  {
    *(_BYTE *)(v2 + 24) = 1;
    v3 = +[NSMutableArray array](NSMutableArray, "array");
    v60 = 0;
    *(_QWORD *)(*(_QWORD *)(v1[6] + 8) + 40) = objc_msgSend(objc_alloc((Class)SASampleStore), "initForLiveSampling");
    v53 = objc_msgSend(*(id *)(*(_QWORD *)(v1[6] + 8) + 40), "parseKTraceFile:warningsOut:errorOut:", v1[7], v3, &v60);
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    v59 = 0u;
    obj = v3;
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v56, v67, 16);
    v5 = &byte_1000EBD38;
    v6 = &byte_1000EBD39;
    v7 = &dword_1000EB4E8;
    if (v4)
    {
      v8 = v4;
      v9 = *(_QWORD *)v57;
      do
      {
        for (i = 0; i != v8; i = (char *)i + 1)
        {
          if (*(_QWORD *)v57 != v9)
            objc_enumerationMutation(obj);
          v11 = *(const __CFString **)(*((_QWORD *)&v56 + 1) + 8 * (_QWORD)i);
          if (*v5)
          {
            v12 = *__error();
            v13 = sub_100030318();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
            {
              v14 = v1[4];
              v15 = v1[7];
              *(_DWORD *)buf = 138412802;
              v62 = v14;
              v63 = 2080;
              v64 = v15;
              v65 = 2112;
              v66 = v11;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_INFO, "WR: %@: WARNING trying to create sample store from %s: %@\n", buf, 0x20u);
            }
            *__error() = v12;
          }
          if (*v6)
            v16 = *v7 <= 1;
          else
            v16 = 0;
          if (v16)
          {
            v17 = *__error();
            v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: WARNING trying to create sample store from %s: %@\n"), v1[4], v1[7], v11);
            if (v18)
            {
              v19 = v18;
              v55 = v17;
              v20 = v8;
              v21 = v9;
              v22 = v1;
              v23 = v5;
              v24 = v6;
              v25 = v7;
              CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
              if (CStringPtr)
              {
                v27 = (char *)CStringPtr;
                v28 = 0;
              }
              else
              {
                v27 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE2A57329uLL);
                CFStringGetCString(v19, v27, 1024, 0x8000100u);
                v28 = v27;
              }
              if (qword_1000EBD40)
                v31 = (FILE *)qword_1000EBD40;
              else
                v31 = __stderrp;
              fprintf(v31, "%s\n", v27);
              if (v28)
                free(v28);
              CFRelease(v19);
              v7 = v25;
              v6 = v24;
              v5 = v23;
              v1 = v22;
              v9 = v21;
              v8 = v20;
              v17 = v55;
            }
            else
            {
              v29 = sub_100030318();
              if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
              {
                v32 = v1[4];
                v33 = v1[7];
                *(_DWORD *)buf = 138412802;
                v62 = v32;
                v63 = 2080;
                v64 = v33;
                v65 = 2112;
                v66 = v11;
                _os_log_fault_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: WARNING trying to create sample store from %s: %@\n", buf, 0x20u);
              }
              if (qword_1000EBD40)
                v30 = (FILE *)qword_1000EBD40;
              else
                v30 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
            }
            *__error() = v17;
          }
        }
        v8 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v56, v67, 16);
      }
      while (v8);
    }
    if ((v53 & 1) == 0)
    {
      if (*v5)
      {
        v34 = *__error();
        v35 = sub_100030318();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          v47 = v1[4];
          v48 = v1[7];
          v49 = v60;
          if (!v60)
            v49 = CFSTR("Unknown error");
          *(_DWORD *)buf = 138412802;
          v62 = v47;
          v63 = 2080;
          v64 = v48;
          v65 = 2112;
          v66 = v49;
          _os_log_error_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n", buf, 0x20u);
        }
        *__error() = v34;
      }
      if (*v6 && *v7 <= 3)
      {
        v36 = *__error();
        v37 = v60;
        if (!v60)
          v37 = CFSTR("Unknown error");
        v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n"), v1[4], v1[7], v37);
        if (v38)
        {
          v39 = v38;
          v40 = CFStringGetCStringPtr(v38, 0x8000100u);
          if (v40)
          {
            v41 = (char *)v40;
            v42 = 0;
          }
          else
          {
            v41 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE9E19820uLL);
            CFStringGetCString(v39, v41, 1024, 0x8000100u);
            v42 = v41;
          }
          if (qword_1000EBD40)
            v45 = (FILE *)qword_1000EBD40;
          else
            v45 = __stderrp;
          fprintf(v45, "%s\n", v41);
          if (v42)
            free(v42);
          CFRelease(v39);
        }
        else
        {
          v43 = sub_100030318();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
          {
            v50 = v1[4];
            v51 = v1[7];
            v52 = v60;
            if (!v60)
              v52 = CFSTR("Unknown error");
            *(_DWORD *)buf = 138412802;
            v62 = v50;
            v63 = 2080;
            v64 = v51;
            v65 = 2112;
            v66 = v52;
            _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: Not generating any spindump reports, unable to create sample store for %s: %@\n", buf, 0x20u);
          }
          if (qword_1000EBD40)
            v44 = (FILE *)qword_1000EBD40;
          else
            v44 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
        }
        *__error() = v36;
      }

      *(_QWORD *)(*(_QWORD *)(v1[6] + 8) + 40) = 0;
    }
  }
  return *(_QWORD *)(*(_QWORD *)(v1[6] + 8) + 40);
}

uint64_t sub_100038EBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  void *v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  int v21;
  const __CFString *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  FILE *v31;
  const __CFString *v32;
  const char *CStringPtr;
  char *v34;
  char *v35;
  FILE *v36;

  result = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  if (!result)
  {
    v10 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    if (!v10)
    {
      if (byte_1000EBD38)
      {
        v11 = *__error();
        v12 = sub_100030318();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_1000840AC(v12, v13, v14, v15, v16, v17, v18, v19);
        *__error() = v11;
      }
      if (byte_1000EBD39)
        v20 = dword_1000EB4E8 <= 3;
      else
        v20 = 0;
      if (v20)
      {
        v21 = *__error();
        v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: TidToPidDictPromise called with no sample store"), "sampleStore");
        if (v22)
        {
          v32 = v22;
          CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
          if (CStringPtr)
          {
            v34 = (char *)CStringPtr;
            v35 = 0;
          }
          else
          {
            v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9FF2D1CCuLL);
            CFStringGetCString(v32, v34, 1024, 0x8000100u);
            v35 = v34;
          }
          if (qword_1000EBD40)
            v36 = (FILE *)qword_1000EBD40;
          else
            v36 = __stderrp;
          fprintf(v36, "%s\n", v34);
          if (v35)
            free(v35);
          CFRelease(v32);
        }
        else
        {
          v23 = sub_100030318();
          if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
            sub_10008403C(v23, v24, v25, v26, v27, v28, v29, v30);
          if (qword_1000EBD40)
            v31 = (FILE *)qword_1000EBD40;
          else
            v31 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
        }
        *__error() = v21;
      }
      sub_1000301F0("DoWorkflowResponsivenessDelay_block_invoke", "monitor-WorkflowResponsiveness.m", 935, "%s: TidToPidDictPromise called with no sample store", a5, a6, a7, a8, (char)"sampleStore");
      abort();
    }
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40) = objc_msgSend(v10, "tidToPidDict");
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  }
  return result;
}

void sub_1000390E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  id v7;
  int v8;
  NSObject *v9;
  BOOL v10;
  int v11;
  const __CFString *v12;
  const __CFString *v13;
  const char *CStringPtr;
  char *v15;
  char *v16;
  NSObject *v17;
  FILE *v18;
  FILE *v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  id v23;
  uint8_t buf[4];
  uint64_t v25;
  __int16 v26;
  id v27;
  __int16 v28;
  uint64_t v29;
  __int16 v30;
  uint64_t v31;

  v6 = objc_opt_class(NSNull);
  if ((objc_opt_isKindOfClass(a3, v6) & 1) == 0)
  {
    v7 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("env_%@"), WRSanitizeForCA(a2));
    if (objc_msgSend(*(id *)(a1 + 32), "objectForKeyedSubscript:", v7))
    {
      if (byte_1000EBD38)
      {
        v8 = *__error();
        v9 = sub_100030318();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          v20 = *(_QWORD *)(a1 + 40);
          v21 = objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "signpost"), "name");
          *(_DWORD *)buf = 138413058;
          v25 = v20;
          v26 = 2112;
          v27 = v21;
          v28 = 2112;
          v29 = a2;
          v30 = 2112;
          v31 = a3;
          _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "WR: %@: %@: %@ -> %@, conflicts with existing entry", buf, 0x2Au);
        }
        *__error() = v8;
      }
      if (byte_1000EBD39)
        v10 = dword_1000EB4E8 <= 3;
      else
        v10 = 0;
      if (v10)
      {
        v11 = *__error();
        v12 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: %@ -> %@, conflicts with existing entry"), *(_QWORD *)(a1 + 40), objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "signpost"), "name"), a2, a3);
        if (v12)
        {
          v13 = v12;
          CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
          if (CStringPtr)
          {
            v15 = (char *)CStringPtr;
            v16 = 0;
          }
          else
          {
            v15 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x45918A1CuLL);
            CFStringGetCString(v13, v15, 1024, 0x8000100u);
            v16 = v15;
          }
          if (qword_1000EBD40)
            v19 = (FILE *)qword_1000EBD40;
          else
            v19 = __stderrp;
          fprintf(v19, "%s\n", v15);
          if (v16)
            free(v16);
          CFRelease(v13);
        }
        else
        {
          v17 = sub_100030318();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
          {
            v22 = *(_QWORD *)(a1 + 40);
            v23 = objc_msgSend(objc_msgSend(*(id *)(a1 + 48), "signpost"), "name");
            *(_DWORD *)buf = 138413058;
            v25 = v22;
            v26 = 2112;
            v27 = v23;
            v28 = 2112;
            v29 = a2;
            v30 = 2112;
            v31 = a3;
            _os_log_fault_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: %@ -> %@, conflicts with existing entry", buf, 0x2Au);
          }
          if (qword_1000EBD40)
            v18 = (FILE *)qword_1000EBD40;
          else
            v18 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
        }
        *__error() = v11;
      }
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", a3, v7);
    }

  }
}

void sub_100039408(void *a1)
{
  uint64_t v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  uint64_t v8;
  id v9;
  uint64_t v10;
  unint64_t v11;
  id v12;
  uint64_t v13;
  id v14;
  id v15;
  id v16;
  uint64_t v17;
  void *j;
  void *v19;
  _QWORD v20[6];
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _QWORD v25[6];
  _QWORD v26[6];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  _BYTE v32[128];

  v2 = objc_opt_class(NSMutableDictionary);
  if ((objc_opt_isKindOfClass(a1, v2) & 1) != 0)
  {
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v3 = objc_msgSend(a1, "allKeys");
    v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v28;
      do
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(_QWORD *)v28 != v6)
            objc_enumerationMutation(v3);
          v8 = *(_QWORD *)(*((_QWORD *)&v27 + 1) + 8 * (_QWORD)i);
          v9 = objc_msgSend(a1, "objectForKeyedSubscript:", v8);
          v26[0] = _NSConcreteStackBlock;
          v26[1] = 3221225472;
          v26[2] = sub_10003D890;
          v26[3] = &unk_1000DCF18;
          v26[4] = a1;
          v26[5] = v8;
          sub_10003D744(v9, (uint64_t)v26);
        }
        v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v27, v32, 16);
      }
      while (v5);
    }
  }
  else
  {
    v10 = objc_opt_class(NSMutableArray);
    if ((objc_opt_isKindOfClass(a1, v10) & 1) != 0)
    {
      if (objc_msgSend(a1, "count"))
      {
        v11 = 0;
        do
        {
          v12 = objc_msgSend(a1, "objectAtIndexedSubscript:", v11);
          v25[0] = _NSConcreteStackBlock;
          v25[1] = 3221225472;
          v25[2] = sub_10003D8A0;
          v25[3] = &unk_1000DCF40;
          v25[4] = a1;
          v25[5] = v11;
          sub_10003D744(v12, (uint64_t)v25);
          ++v11;
        }
        while (v11 < (unint64_t)objc_msgSend(a1, "count"));
      }
    }
    else
    {
      v13 = objc_opt_class(NSMutableSet);
      if ((objc_opt_isKindOfClass(a1, v13) & 1) != 0)
      {
        v14 = objc_msgSend(a1, "copy");
        v21 = 0u;
        v22 = 0u;
        v23 = 0u;
        v24 = 0u;
        v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v21, v31, 16);
        if (v15)
        {
          v16 = v15;
          v17 = *(_QWORD *)v22;
          do
          {
            for (j = 0; j != v16; j = (char *)j + 1)
            {
              if (*(_QWORD *)v22 != v17)
                objc_enumerationMutation(v14);
              v19 = *(void **)(*((_QWORD *)&v21 + 1) + 8 * (_QWORD)j);
              v20[0] = _NSConcreteStackBlock;
              v20[1] = 3221225472;
              v20[2] = sub_10003D8B0;
              v20[3] = &unk_1000DCF18;
              v20[4] = a1;
              v20[5] = v19;
              sub_10003D744(v19, (uint64_t)v20);
            }
            v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v21, v31, 16);
          }
          while (v16);
        }

      }
    }
  }
}

void sub_1000396CC(id a1)
{
  NSObject *v1;
  NSObject *v2;

  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000EBBD0 = (uint64_t)dispatch_queue_create("WR processing", v2);
  dispatch_release(v2);
}

id sub_10003971C(uint64_t a1, void *a2)
{
  id result;

  result = objc_msgSend(objc_msgSend(a2, "name"), "isEqualToString:", *(_QWORD *)(a1 + 32));
  if ((_DWORD)result)
    return objc_msgSend(*(id *)(a1 + 40), "addObject:", a2);
  return result;
}

void sub_100039764(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6, uint64_t a7, void *a8, void *a9, uint64_t a10, uint64_t a11, unint64_t a12, unint64_t a13)
{
  void *v14;
  void *v15;
  unint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;
  id v22;
  void *v23;
  int v24;
  NSObject *v25;
  BOOL v26;
  int v27;
  id v28;
  const __CFString *v29;
  void *v30;
  void *v31;
  const __CFString *v32;
  const __CFString *v33;
  const __CFString *v34;
  const char *CStringPtr;
  char *v36;
  char *v37;
  id v38;
  id v39;
  id v40;
  uint64_t v41;
  void *i;
  int v44;
  NSObject *v45;
  BOOL v46;
  int v47;
  void *v48;
  id v49;
  const __CFString *v50;
  void *v51;
  const __CFString *v52;
  const __CFString *v53;
  const __CFString *v54;
  const char *v55;
  char *v56;
  char *v57;
  void *v58;
  int v59;
  NSObject *v60;
  BOOL v61;
  int v62;
  void *v63;
  id v64;
  const __CFString *v65;
  uint64_t v66;
  void *v67;
  const __CFString *v68;
  const __CFString *v69;
  const __CFString *v70;
  const char *v71;
  char *v72;
  char *v73;
  NSObject *v74;
  FILE *v75;
  FILE *v76;
  NSObject *v77;
  FILE *v78;
  FILE *v79;
  NSObject *v80;
  FILE *v81;
  FILE *v82;
  id v83;
  const __CFString *v84;
  void *v85;
  void *v86;
  const __CFString *v87;
  id v88;
  const __CFString *v89;
  void *v90;
  const __CFString *v91;
  id v92;
  const __CFString *v93;
  void *v94;
  const __CFString *v95;
  id v96;
  const __CFString *v97;
  const __CFString *v98;
  id v99;
  id v100;
  const __CFString *v101;
  const __CFString *v102;
  id v103;
  id v104;
  const __CFString *v105;
  const __CFString *v106;
  id v107;
  unint64_t v108;
  __int128 v111;
  __int128 v112;
  __int128 v113;
  __int128 v114;
  uint8_t v115[128];
  uint8_t buf[4];
  id v117;
  __int16 v118;
  const __CFString *v119;
  __int16 v120;
  id v121;
  __int16 v122;
  uint64_t v123;
  __int16 v124;
  unint64_t v125;

  v14 = a5;
  v15 = a4;
  v17 = a12;
  v18 = a10;
  if (a8)
  {
    v19 = a4;
    v20 = a5;
    v21 = a6;
    v22 = a8;
LABEL_22:
    v38 = +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, (double)v17 / 1000000000.0, 0.0), +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, (double)a13 / 1000000000.0, 0.0));
    v111 = 0u;
    v112 = 0u;
    v113 = 0u;
    v114 = 0u;
    v39 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v111, v115, 16);
    if (v39)
    {
      v40 = v39;
      v41 = *(_QWORD *)v112;
      do
      {
        for (i = 0; i != v40; i = (char *)i + 1)
        {
          if (*(_QWORD *)v112 != v41)
            objc_enumerationMutation(v22);
          sub_10003A418(a1, a2, v19, v20, v21, a7, a10, a11, v38, *(void **)(*((_QWORD *)&v111 + 1) + 8 * (_QWORD)i));
        }
        v40 = objc_msgSend(v22, "countByEnumeratingWithState:objects:count:", &v111, v115, 16);
      }
      while (v40);
    }

    return;
  }
  if (a11)
  {
    v108 = a12;
    v23 = sub_10003A268(a3, a9, a11, a13);
    if (!v23)
    {
      if (byte_1000EBD38)
      {
        v24 = *__error();
        v25 = sub_100030318();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          v83 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
          v84 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
          v85 = v15;
          v86 = v14;
          if (v84)
            v87 = v84;
          else
            v87 = CFSTR("<entire workflow>");
          *(_DWORD *)buf = 138413314;
          v117 = v83;
          v118 = 2112;
          v119 = v87;
          v14 = v86;
          v15 = v85;
          v120 = 2112;
          v121 = objc_msgSend(a6, "name");
          v122 = 2048;
          v123 = a11;
          v124 = 2048;
          v125 = a13;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
        }
        *__error() = v24;
      }
      if (byte_1000EBD39)
        v26 = dword_1000EB4E8 <= 3;
      else
        v26 = 0;
      if (v26)
      {
        v27 = *__error();
        v28 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
        v29 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
        v30 = v15;
        v31 = v14;
        if (v29)
          v32 = v29;
        else
          v32 = CFSTR("<entire workflow>");
        v33 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report"), v28, v32, objc_msgSend(a6, "name"), a11, a13);
        if (v33)
        {
          v34 = v33;
          CStringPtr = CFStringGetCStringPtr(v33, 0x8000100u);
          if (CStringPtr)
          {
            v36 = (char *)CStringPtr;
            v37 = 0;
          }
          else
          {
            v36 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2688D5C7uLL);
            CFStringGetCString(v34, v36, 1024, 0x8000100u);
            v37 = v36;
          }
          if (qword_1000EBD40)
            v76 = (FILE *)qword_1000EBD40;
          else
            v76 = __stderrp;
          fprintf(v76, "%s\n", v36);
          if (v37)
            free(v37);
          CFRelease(v34);
        }
        else
        {
          v74 = sub_100030318();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
          {
            v96 = objc_msgSend(objc_msgSend(v30, "workflow"), "name");
            v97 = (const __CFString *)objc_msgSend(objc_msgSend(v31, "signpost"), "name");
            if (v97)
              v98 = v97;
            else
              v98 = CFSTR("<entire workflow>");
            v99 = objc_msgSend(a6, "name");
            *(_DWORD *)buf = 138413314;
            v117 = v96;
            v118 = 2112;
            v119 = v98;
            v120 = 2112;
            v121 = v99;
            v122 = 2048;
            v123 = a11;
            v124 = 2048;
            v125 = a13;
            _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
          }
          if (qword_1000EBD40)
            v75 = (FILE *)qword_1000EBD40;
          else
            v75 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
        }
        *__error() = v27;
      }
      return;
    }
LABEL_21:
    v19 = v15;
    v20 = v14;
    v21 = a6;
    v22 = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", v23, 0);
    v17 = v108;
    goto LABEL_22;
  }
  if (a10)
  {
    v108 = a12;
    v23 = sub_10003A268(a3, a9, a10, a12);
    if (v23)
      goto LABEL_21;
    if (byte_1000EBD38)
    {
      v58 = v15;
      v59 = *__error();
      v60 = sub_100030318();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        v92 = objc_msgSend(objc_msgSend(v58, "workflow"), "name");
        v93 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
        v94 = v14;
        if (v93)
          v95 = v93;
        else
          v95 = CFSTR("<entire workflow>");
        *(_DWORD *)buf = 138413314;
        v117 = v92;
        v118 = 2112;
        v119 = v95;
        v14 = v94;
        v18 = a10;
        v120 = 2112;
        v121 = objc_msgSend(a6, "name");
        v122 = 2048;
        v123 = a10;
        v124 = 2048;
        v125 = a12;
        _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
      }
      *__error() = v59;
      v15 = v58;
    }
    if (byte_1000EBD39)
      v61 = dword_1000EB4E8 <= 3;
    else
      v61 = 0;
    if (v61)
    {
      v62 = *__error();
      v63 = v15;
      v64 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
      v65 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
      v66 = v18;
      v67 = v14;
      if (v65)
        v68 = v65;
      else
        v68 = CFSTR("<entire workflow>");
      v69 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report"), v64, v68, objc_msgSend(a6, "name"), v66, a12);
      if (v69)
      {
        v70 = v69;
        v71 = CFStringGetCStringPtr(v69, 0x8000100u);
        if (v71)
        {
          v72 = (char *)v71;
          v73 = 0;
        }
        else
        {
          v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7130A33DuLL);
          CFStringGetCString(v70, v72, 1024, 0x8000100u);
          v73 = v72;
        }
        if (qword_1000EBD40)
          v82 = (FILE *)qword_1000EBD40;
        else
          v82 = __stderrp;
        fprintf(v82, "%s\n", v72);
        if (v73)
          free(v73);
        CFRelease(v70);
      }
      else
      {
        v80 = sub_100030318();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
        {
          v104 = objc_msgSend(objc_msgSend(v63, "workflow"), "name");
          v105 = (const __CFString *)objc_msgSend(objc_msgSend(v67, "signpost"), "name");
          if (v105)
            v106 = v105;
          else
            v106 = CFSTR("<entire workflow>");
          v107 = objc_msgSend(a6, "name");
          *(_DWORD *)buf = 138413314;
          v117 = v104;
          v118 = 2112;
          v119 = v106;
          v120 = 2112;
          v121 = v107;
          v122 = 2048;
          v123 = v66;
          v124 = 2048;
          v125 = a12;
          _os_log_fault_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task with thread 0x%llx at %llu, cannot generate report", buf, 0x34u);
        }
        if (qword_1000EBD40)
          v81 = (FILE *)qword_1000EBD40;
        else
          v81 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v81);
      }
      *__error() = v62;
    }
  }
  else
  {
    if (byte_1000EBD38)
    {
      v44 = *__error();
      v45 = sub_100030318();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        v88 = objc_msgSend(objc_msgSend(a4, "workflow"), "name");
        v89 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
        v90 = v14;
        if (v89)
          v91 = v89;
        else
          v91 = CFSTR("<entire workflow>");
        *(_DWORD *)buf = 138412802;
        v117 = v88;
        v118 = 2112;
        v119 = v91;
        v14 = v90;
        v120 = 2112;
        v121 = objc_msgSend(a6, "name");
        _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report", buf, 0x20u);
      }
      *__error() = v44;
      v15 = a4;
    }
    if (byte_1000EBD39)
      v46 = dword_1000EB4E8 <= 3;
    else
      v46 = 0;
    if (v46)
    {
      v47 = *__error();
      v48 = v15;
      v49 = objc_msgSend(objc_msgSend(v15, "workflow"), "name");
      v50 = (const __CFString *)objc_msgSend(objc_msgSend(v14, "signpost"), "name");
      v51 = v14;
      if (v50)
        v52 = v50;
      else
        v52 = CFSTR("<entire workflow>");
      v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report"), v49, v52, objc_msgSend(a6, "name"));
      if (v53)
      {
        v54 = v53;
        v55 = CFStringGetCStringPtr(v53, 0x8000100u);
        if (v55)
        {
          v56 = (char *)v55;
          v57 = 0;
        }
        else
        {
          v56 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6AB5B559uLL);
          CFStringGetCString(v54, v56, 1024, 0x8000100u);
          v57 = v56;
        }
        if (qword_1000EBD40)
          v79 = (FILE *)qword_1000EBD40;
        else
          v79 = __stderrp;
        fprintf(v79, "%s\n", v56);
        if (v57)
          free(v57);
        CFRelease(v54);
      }
      else
      {
        v77 = sub_100030318();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
        {
          v100 = objc_msgSend(objc_msgSend(v48, "workflow"), "name");
          v101 = (const __CFString *)objc_msgSend(objc_msgSend(v51, "signpost"), "name");
          if (v101)
            v102 = v101;
          else
            v102 = CFSTR("<entire workflow>");
          v103 = objc_msgSend(a6, "name");
          *(_DWORD *)buf = 138412802;
          v117 = v100;
          v118 = 2112;
          v119 = v102;
          v120 = 2112;
          v121 = v103;
          _os_log_fault_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: Unable to find task given no threads, cannot generate report", buf, 0x20u);
        }
        if (qword_1000EBD40)
          v78 = (FILE *)qword_1000EBD40;
        else
          v78 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
      }
      *__error() = v47;
    }
  }
}

void *sub_10003A268(void *a1, void *a2, uint64_t a3, unint64_t a4)
{
  id v7;
  id v8;
  id v9;
  id v10;
  double v11;
  uint64_t v12;
  void *i;
  void *v14;
  id v15;
  double v16;
  id v18;
  double v19;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _BYTE v26[128];

  v7 = objc_msgSend(a2, "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"));
  if (!v7)
    return 0;
  v24 = 0u;
  v25 = 0u;
  v22 = 0u;
  v23 = 0u;
  v8 = objc_msgSend(objc_msgSend(a1, "tasksByPid", 0), "objectForKeyedSubscript:", v7);
  v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
  if (!v9)
    return 0;
  v10 = v9;
  v11 = (double)a4 / 1000000000.0;
  v12 = *(_QWORD *)v23;
  do
  {
    for (i = 0; i != v10; i = (char *)i + 1)
    {
      if (*(_QWORD *)v23 != v12)
        objc_enumerationMutation(v8);
      v14 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)i);
      if (objc_msgSend(objc_msgSend(v14, "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a3)))
      {
        v15 = objc_msgSend(v14, "startTimestamp");
        if (v15)
        {
          objc_msgSend(v15, "machContTimeSeconds");
          if (v16 != 0.0 && v11 < v16)
            return 0;
          v18 = objc_msgSend(v14, "endTimestamp");
          if (v18)
          {
            objc_msgSend(v18, "machContTimeSeconds");
            if (v19 != 0.0 && v11 < v19)
              return v14;
          }
        }
      }
    }
    v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v22, v26, 16);
    v14 = 0;
  }
  while (v10);
  return v14;
}

void sub_10003A418(void *a1, uint64_t a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  uint64_t v14;
  uint64_t v15;
  id v16;
  SPWRReport *v17;
  int v18;
  NSObject *v19;
  BOOL v20;
  int v21;
  id v22;
  const __CFString *v23;
  const __CFString *v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFString *v27;
  char *v28;
  char *v29;
  int v30;
  NSObject *v31;
  BOOL v32;
  id v33;
  const __CFString *v34;
  const __CFString *v35;
  const __CFString *v36;
  const __CFString *v37;
  char *CStringPtr;
  char *v39;
  NSObject *v40;
  FILE *v41;
  FILE *v42;
  NSObject *v43;
  FILE *v44;
  FILE *v45;
  id v46;
  void *v47;
  id v48;
  int v49;
  NSObject *v50;
  int v51;
  id v52;
  const __CFString *v53;
  const __CFString *v54;
  const __CFString *v55;
  id v56;
  const __CFString *v57;
  const __CFString *v58;
  char *v59;
  char *v60;
  id v61;
  int v62;
  NSObject *v63;
  const __CFString *v64;
  const __CFString *v65;
  const __CFString *v66;
  const __CFString *v67;
  char *v68;
  char *v69;
  NSObject *v70;
  FILE *v71;
  FILE *v72;
  id v73;
  SPWRReport *v74;
  int v75;
  NSObject *v76;
  id v77;
  const __CFString *v78;
  const __CFString *v79;
  const __CFString *v80;
  const __CFString *v81;
  char *v82;
  char *v83;
  NSObject *v84;
  FILE *v85;
  FILE *v86;
  id v87;
  id v88;
  uint64_t v89;
  unint64_t v90;
  unsigned int v91;
  int v92;
  NSObject *v93;
  id v94;
  const __CFString *v95;
  const __CFString *v96;
  const __CFString *v97;
  const __CFString *v98;
  char *v99;
  char *v100;
  unsigned int v101;
  int v102;
  NSObject *v103;
  id v104;
  const __CFString *v105;
  const __CFString *v106;
  const __CFString *v107;
  const __CFString *v108;
  char *v109;
  char *v110;
  NSObject *v111;
  const __CFString *v112;
  const __CFString *v113;
  id v114;
  id v115;
  id v116;
  id v117;
  const __CFString *v118;
  const __CFString *v119;
  const __CFString *v120;
  char *v121;
  char *v122;
  NSObject *v123;
  FILE *v124;
  int v125;
  NSObject *v126;
  id v127;
  const __CFString *v128;
  const __CFString *v129;
  const __CFString *v130;
  const __CFString *v131;
  char *v132;
  char *v133;
  FILE *v134;
  int *v135;
  int v136;
  int v137;
  NSObject *v138;
  id v139;
  const __CFString *v140;
  const __CFString *v141;
  const __CFString *v142;
  const __CFString *v143;
  char *v144;
  char *v145;
  NSObject *v146;
  FILE *v147;
  NSObject *v148;
  FILE *v149;
  const __CFString *v150;
  const __CFString *v151;
  id v152;
  id v153;
  id v154;
  NSObject *v155;
  FILE *v156;
  const __CFString *v157;
  const __CFString *v158;
  id v159;
  id v160;
  NSObject *v161;
  id v162;
  const __CFString *v163;
  const __CFString *v164;
  const __CFString *v165;
  const __CFString *v166;
  id v167;
  id v168;
  unsigned int v169;
  FILE *v170;
  FILE *v171;
  FILE *v172;
  FILE *v173;
  const __CFString *v174;
  const __CFString *v175;
  id v176;
  const __CFString *v177;
  const __CFString *v178;
  id v179;
  id v180;
  id v181;
  const __CFString *v182;
  const __CFString *v183;
  unsigned int v184;
  id v185;
  id v186;
  id v187;
  const __CFString *v188;
  const __CFString *v189;
  id v190;
  const __CFString *v191;
  const __CFString *v192;
  id v193;
  id v194;
  id v195;
  id v196;
  const __CFString *v197;
  id v198;
  id v199;
  const __CFString *v200;
  const __CFString *v201;
  id v202;
  id v203;
  unsigned int v204;
  NSObject *v205;
  FILE *v206;
  const __CFString *v207;
  const __CFString *v208;
  id v209;
  id v210;
  id v211;
  const __CFString *v212;
  const __CFString *v213;
  id v214;
  id v215;
  unsigned int v216;
  FILE *v217;
  id v218;
  void *v219;
  id v220;
  int v221;
  NSObject *v222;
  int v223;
  id v224;
  const __CFString *v225;
  const __CFString *v226;
  const __CFString *v227;
  id v228;
  const __CFString *v229;
  const __CFString *v230;
  char *v231;
  char *v232;
  id v233;
  void *v234;
  id v235;
  uint64_t v236;
  void *i;
  int v238;
  NSObject *v239;
  int v240;
  id v241;
  const __CFString *v242;
  const __CFString *v243;
  const __CFString *v244;
  const __CFString *v245;
  char *v246;
  char *v247;
  NSObject *v248;
  FILE *v249;
  FILE *v250;
  NSObject *v251;
  FILE *v252;
  id v253;
  const __CFString *v254;
  const __CFString *v255;
  id v256;
  id v257;
  unsigned int v258;
  FILE *v259;
  id v260;
  const __CFString *v261;
  const __CFString *v262;
  id v263;
  id v264;
  unsigned int v265;
  id v266;
  const __CFString *v267;
  const __CFString *v268;
  id v269;
  id v270;
  const __CFString *v271;
  id v272;
  const __CFString *v273;
  const __CFString *v274;
  id v275;
  id v276;
  id v277;
  id v278;
  const __CFString *v279;
  id v280;
  id v281;
  const __CFString *v282;
  const __CFString *v283;
  id v284;
  id v285;
  id v286;
  id v287;
  const __CFString *v288;
  const __CFString *v289;
  id v290;
  id v291;
  id v292;
  const __CFString *v293;
  const __CFString *v294;
  id v295;
  id v296;
  id v297;
  id v298;
  const __CFString *v299;
  const __CFString *v300;
  id v301;
  id v302;
  id v303;
  unsigned int v304;
  id v305;
  int v306;
  id v307;
  id v308;
  id v309;
  const __CFString *v310;
  const __CFString *v311;
  id v312;
  int v313;
  id v314;
  int v315;
  void *v316;
  int v317;
  id v318;
  id v319;
  id v320;
  id v321;
  id v322;
  id v326;
  const __CFString *v327;
  const __CFString *v328;
  id v329;
  const __CFString *v330;
  int v332;
  int v333;
  int v334;
  id v335;
  id v336;
  id v337;
  void **v339;
  uint64_t v340;
  uint64_t v341;
  void *v342;
  id v343;
  void *v344;
  uint64_t *v345;
  uint64_t v346;
  uint64_t *v347;
  uint64_t v348;
  void (*v349)(uint64_t, uint64_t);
  void (*v350)(uint64_t);
  uint64_t v351;
  _BYTE v352[68];
  __int16 v353;
  id v354;
  _BYTE buf[24];
  id v356;
  _BYTE v357[32];
  uint64_t v358;
  void *v359;
  void *v360;
  void ***v361;

  if (objc_msgSend(a5, "reportSpindumpForThisThread"))
  {
    if (a7 == a8 || a7 == 0)
      v14 = a8;
    else
      v14 = 0;
    if (a8)
      v15 = v14;
    else
      v15 = a7;
    if (v15)
    {
      v16 = objc_msgSend(objc_msgSend(a10, "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v15));
      if (v16)
      {
        v17 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]([SPWRReport alloc], "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:", a2, a6, a10, a9, v16, 0);
        objc_msgSend(a1, "addObject:", v17);

      }
      else
      {
        if (byte_1000EBD38)
        {
          v30 = *__error();
          v31 = sub_100030318();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            v321 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v174 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            v175 = CFSTR("<entire workflow>");
            if (v174)
              v175 = v174;
            *(_DWORD *)buf = 138413570;
            *(_QWORD *)&buf[4] = v321;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v175;
            *(_WORD *)&buf[22] = 2112;
            v356 = objc_msgSend(a5, "name");
            *(_WORD *)v357 = 2112;
            *(_QWORD *)&v357[2] = objc_msgSend(a10, "name");
            *(_WORD *)&v357[10] = 1024;
            *(_DWORD *)&v357[12] = objc_msgSend(a10, "pid");
            *(_WORD *)&v357[16] = 2048;
            *(_QWORD *)&v357[18] = v15;
            _os_log_error_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report", buf, 0x3Au);
          }
          *__error() = v30;
        }
        if (byte_1000EBD39)
          v32 = dword_1000EB4E8 <= 3;
        else
          v32 = 0;
        if (v32)
        {
          v313 = *__error();
          v33 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v34 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v34)
            v35 = v34;
          else
            v35 = CFSTR("<entire workflow>");
          v36 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report"), v33, v35, objc_msgSend(a5, "name"), objc_msgSend(a10, "name"), objc_msgSend(a10, "pid"), v15);
          v37 = v36;
          if (v36)
          {
            CStringPtr = (char *)CFStringGetCStringPtr(v36, 0x8000100u);
            if (CStringPtr)
            {
              v39 = 0;
            }
            else
            {
              CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x216E16A9uLL);
              CFStringGetCString(v37, CStringPtr, 1024, 0x8000100u);
              v39 = CStringPtr;
            }
            if (qword_1000EBD40)
              v45 = (FILE *)qword_1000EBD40;
            else
              v45 = __stderrp;
            fprintf(v45, "%s\n", CStringPtr);
            if (v39)
              free(v39);
            CFRelease(v37);
          }
          else
          {
            v43 = sub_100030318();
            if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
            {
              v312 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
              v212 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
              if (v212)
                v213 = v212;
              else
                v213 = CFSTR("<entire workflow>");
              v214 = objc_msgSend(a5, "name");
              v215 = objc_msgSend(a10, "name");
              v216 = objc_msgSend(a10, "pid");
              *(_DWORD *)buf = 138413570;
              *(_QWORD *)&buf[4] = v312;
              *(_WORD *)&buf[12] = 2112;
              *(_QWORD *)&buf[14] = v213;
              *(_WORD *)&buf[22] = 2112;
              v356 = v214;
              *(_WORD *)v357 = 2112;
              *(_QWORD *)&v357[2] = v215;
              *(_WORD *)&v357[10] = 1024;
              *(_DWORD *)&v357[12] = v216;
              *(_WORD *)&v357[16] = 2048;
              *(_QWORD *)&v357[18] = v15;
              _os_log_fault_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@: %@ [%d] has no thread 0x%llx, cannot generate report", buf, 0x3Au);
            }
            if (qword_1000EBD40)
              v44 = (FILE *)qword_1000EBD40;
            else
              v44 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
          }
          *__error() = v313;
        }
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v18 = *__error();
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          v162 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v163 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v163)
            v164 = v163;
          else
            v164 = CFSTR("<entire workflow>");
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = v162;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v164;
          *(_WORD *)&buf[22] = 2112;
          v356 = objc_msgSend(a5, "name");
          *(_WORD *)v357 = 2048;
          *(_QWORD *)&v357[2] = a7;
          *(_WORD *)&v357[10] = 2048;
          *(_QWORD *)&v357[12] = a8;
          _os_log_error_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx", buf, 0x34u);
        }
        *__error() = v18;
      }
      if (byte_1000EBD39)
        v20 = dword_1000EB4E8 <= 3;
      else
        v20 = 0;
      if (v20)
      {
        v21 = *__error();
        v22 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v23 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        v24 = CFSTR("<entire workflow>");
        if (v23)
          v25 = v23;
        else
          v25 = CFSTR("<entire workflow>");
        v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx"), v22, v25, objc_msgSend(a5, "name"), a7, a8);
        v27 = v26;
        if (v26)
        {
          v28 = (char *)CFStringGetCStringPtr(v26, 0x8000100u);
          if (v28)
          {
            v29 = 0;
          }
          else
          {
            v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC3558D9FuLL);
            CFStringGetCString(v27, v28, 1024, 0x8000100u);
            v29 = v28;
          }
          if (qword_1000EBD40)
            v42 = (FILE *)qword_1000EBD40;
          else
            v42 = __stderrp;
          fprintf(v42, "%s\n", v28);
          if (v29)
            free(v29);
          CFRelease(v27);
        }
        else
        {
          v40 = sub_100030318();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
          {
            v196 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v197 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v197)
              v24 = v197;
            v198 = objc_msgSend(a5, "name");
            *(_DWORD *)buf = 138413314;
            *(_QWORD *)&buf[4] = v196;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v24;
            *(_WORD *)&buf[22] = 2112;
            v356 = v198;
            *(_WORD *)v357 = 2048;
            *(_QWORD *)&v357[2] = a7;
            *(_WORD *)&v357[10] = 2048;
            *(_QWORD *)&v357[12] = a8;
            _os_log_fault_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this thread, but signpost starts on 0x%llx and ends on 0x%llx", buf, 0x34u);
          }
          if (qword_1000EBD40)
            v41 = (FILE *)qword_1000EBD40;
          else
            v41 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v41);
        }
        *__error() = v21;
      }
    }
  }
  v46 = objc_msgSend(a5, "reportSpindumpForThreadWithName");
  v47 = v46;
  if (v46)
  {
    if (objc_msgSend(v46, "hasPrefix:", CFSTR("^"))
      && objc_msgSend(v47, "hasSuffix:", CFSTR("$")))
    {
      *(_QWORD *)v352 = 0;
      v48 = objc_msgSend(objc_alloc((Class)NSRegularExpression), "initWithPattern:options:error:", v47, 0, v352);
      if (!v48)
      {
        if (byte_1000EBD38)
        {
          v49 = *__error();
          v50 = sub_100030318();
          if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
          {
            v187 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v188 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v188)
              v189 = v188;
            else
              v189 = CFSTR("<entire workflow>");
            v190 = objc_msgSend(a5, "name");
            *(_DWORD *)buf = 138413314;
            *(_QWORD *)&buf[4] = v187;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v189;
            *(_WORD *)&buf[22] = 2112;
            v356 = v190;
            *(_WORD *)v357 = 2112;
            *(_QWORD *)&v357[2] = v47;
            *(_WORD *)&v357[10] = 2112;
            *(_QWORD *)&v357[12] = *(_QWORD *)v352;
            _os_log_error_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@", buf, 0x34u);
          }
          *__error() = v49;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v51 = *__error();
          v52 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v53 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          v54 = CFSTR("<entire workflow>");
          if (v53)
            v55 = v53;
          else
            v55 = CFSTR("<entire workflow>");
          v56 = objc_msgSend(a5, "name");
          v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@"), v52, v55, v56, v47, *(_QWORD *)v352);
          v58 = v57;
          if (v57)
          {
            v59 = (char *)CFStringGetCStringPtr(v57, 0x8000100u);
            if (v59)
            {
              v60 = 0;
            }
            else
            {
              v59 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x65F27258uLL);
              CFStringGetCString(v58, v59, 1024, 0x8000100u);
              v60 = v59;
            }
            if (qword_1000EBD40)
              v170 = (FILE *)qword_1000EBD40;
            else
              v170 = __stderrp;
            fprintf(v170, "%s\n", v59);
            if (v60)
              free(v60);
            CFRelease(v58);
          }
          else
          {
            v146 = sub_100030318();
            if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT))
            {
              v270 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
              v271 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
              if (v271)
                v54 = v271;
              v272 = objc_msgSend(a5, "name");
              *(_DWORD *)buf = 138413314;
              *(_QWORD *)&buf[4] = v270;
              *(_WORD *)&buf[12] = 2112;
              *(_QWORD *)&buf[14] = v54;
              *(_WORD *)&buf[22] = 2112;
              v356 = v272;
              *(_WORD *)v357 = 2112;
              *(_QWORD *)&v357[2] = v47;
              *(_WORD *)&v357[10] = 2112;
              *(_QWORD *)&v357[12] = *(_QWORD *)v352;
              _os_log_fault_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports thread %@, but regex failed to compile: %@", buf, 0x34u);
            }
            if (qword_1000EBD40)
              v147 = (FILE *)qword_1000EBD40;
            else
              v147 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v147);
          }
          *__error() = v51;
        }
        goto LABEL_109;
      }
    }
    else
    {
      v48 = 0;
    }
    v339 = 0;
    v340 = (uint64_t)&v339;
    v341 = 0x2020000000;
    LOBYTE(v342) = 0;
    v61 = objc_msgSend(a10, "threads");
    *(_QWORD *)buf = _NSConcreteStackBlock;
    *(_QWORD *)&buf[8] = 3221225472;
    *(_QWORD *)&buf[16] = sub_10003D10C;
    v356 = &unk_1000DCEC8;
    *(_QWORD *)v357 = a9;
    *(_QWORD *)&v357[8] = v48;
    *(_QWORD *)&v357[16] = v47;
    *(_QWORD *)&v357[24] = a2;
    v358 = a6;
    v359 = a10;
    v360 = a1;
    v361 = &v339;
    objc_msgSend(v61, "enumerateKeysAndObjectsUsingBlock:", buf);
    if (!*(_BYTE *)(v340 + 24))
    {
      if (byte_1000EBD38)
      {
        v62 = *__error();
        v63 = sub_100030318();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          v319 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v157 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          v158 = CFSTR("<entire workflow>");
          if (v157)
            v158 = v157;
          v310 = v158;
          v308 = objc_msgSend(a5, "name");
          v307 = objc_msgSend(a10, "name");
          v304 = objc_msgSend(a10, "pid");
          v159 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
          v160 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
          *(_DWORD *)v352 = 138414082;
          *(_QWORD *)&v352[4] = v319;
          *(_WORD *)&v352[12] = 2112;
          *(_QWORD *)&v352[14] = v310;
          *(_WORD *)&v352[22] = 2112;
          *(_QWORD *)&v352[24] = v308;
          *(_WORD *)&v352[32] = 2112;
          *(_QWORD *)&v352[34] = v47;
          *(_WORD *)&v352[42] = 2112;
          *(_QWORD *)&v352[44] = v307;
          *(_WORD *)&v352[52] = 1024;
          *(_DWORD *)&v352[54] = v304;
          *(_WORD *)&v352[58] = 2112;
          *(_QWORD *)&v352[60] = v159;
          v353 = 2112;
          v354 = v160;
          _os_log_error_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@", v352, 0x4Eu);
        }
        *__error() = v62;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v306 = *__error();
        v314 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v64 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        v65 = CFSTR("<entire workflow>");
        if (v64)
          v65 = v64;
        v66 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@"), v314, v65, objc_msgSend(a5, "name"), v47, objc_msgSend(a10, "name"), objc_msgSend(a10, "pid"), objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription"), objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription"));
        v67 = v66;
        if (v66)
        {
          v68 = (char *)CFStringGetCStringPtr(v66, 0x8000100u);
          if (v68)
          {
            v69 = 0;
          }
          else
          {
            v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBB352E6BuLL);
            CFStringGetCString(v67, v68, 1024, 0x8000100u);
            v69 = v68;
          }
          if (qword_1000EBD40)
            v72 = (FILE *)qword_1000EBD40;
          else
            v72 = __stderrp;
          fprintf(v72, "%s\n", v68);
          if (v69)
            free(v69);
          CFRelease(v67);
        }
        else
        {
          v70 = sub_100030318();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
          {
            v322 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v182 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            v183 = CFSTR("<entire workflow>");
            if (v182)
              v183 = v182;
            v311 = v183;
            v309 = objc_msgSend(a5, "name");
            v305 = objc_msgSend(a10, "name");
            v184 = objc_msgSend(a10, "pid");
            v185 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
            v186 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
            *(_DWORD *)v352 = 138414082;
            *(_QWORD *)&v352[4] = v322;
            *(_WORD *)&v352[12] = 2112;
            *(_QWORD *)&v352[14] = v311;
            *(_WORD *)&v352[22] = 2112;
            *(_QWORD *)&v352[24] = v309;
            *(_WORD *)&v352[32] = 2112;
            *(_QWORD *)&v352[34] = v47;
            *(_WORD *)&v352[42] = 2112;
            *(_QWORD *)&v352[44] = v305;
            *(_WORD *)&v352[52] = 1024;
            *(_DWORD *)&v352[54] = v184;
            *(_WORD *)&v352[58] = 2112;
            *(_QWORD *)&v352[60] = v185;
            v353 = 2112;
            v354 = v186;
            _os_log_fault_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports thread %@, but %@ [%d] has no thread with that name during the interval %@ - %@", v352, 0x4Eu);
          }
          if (qword_1000EBD40)
            v71 = (FILE *)qword_1000EBD40;
          else
            v71 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
        }
        *__error() = v306;
      }
    }

    _Block_object_dispose(&v339, 8);
  }
LABEL_109:
  if (objc_msgSend(a5, "reportSpindumpForMainThread"))
  {
    v73 = objc_msgSend(a10, "mainThread");
    if (v73)
    {
      v74 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]([SPWRReport alloc], "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:", a2, a6, a10, a9, v73, 0);
      objc_msgSend(a1, "addObject:", v74);

    }
    else
    {
      if (byte_1000EBD38)
      {
        v75 = *__error();
        v76 = sub_100030318();
        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          v320 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v165 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v165)
            v166 = v165;
          else
            v166 = CFSTR("<entire workflow>");
          v167 = objc_msgSend(a5, "name");
          v168 = objc_msgSend(a10, "name");
          v169 = objc_msgSend(a10, "pid");
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = v320;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v166;
          *(_WORD *)&buf[22] = 2112;
          v356 = v167;
          *(_WORD *)v357 = 2112;
          *(_QWORD *)&v357[2] = v168;
          *(_WORD *)&v357[10] = 1024;
          *(_DWORD *)&v357[12] = v169;
          _os_log_error_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread", buf, 0x30u);
        }
        *__error() = v75;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v315 = *__error();
        v77 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v78 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v78)
          v79 = v78;
        else
          v79 = CFSTR("<entire workflow>");
        v80 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread"), v77, v79, objc_msgSend(a5, "name"), objc_msgSend(a10, "name"), objc_msgSend(a10, "pid"));
        v81 = v80;
        if (v80)
        {
          v82 = (char *)CFStringGetCStringPtr(v80, 0x8000100u);
          if (v82)
          {
            v83 = 0;
          }
          else
          {
            v82 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8B62C4B8uLL);
            CFStringGetCString(v81, v82, 1024, 0x8000100u);
            v83 = v82;
          }
          if (qword_1000EBD40)
            v86 = (FILE *)qword_1000EBD40;
          else
            v86 = __stderrp;
          fprintf(v86, "%s\n", v82);
          if (v83)
            free(v83);
          CFRelease(v81);
        }
        else
        {
          v84 = sub_100030318();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
          {
            v199 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v200 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v200)
              v201 = v200;
            else
              v201 = CFSTR("<entire workflow>");
            v202 = objc_msgSend(a5, "name");
            v203 = objc_msgSend(a10, "name");
            v204 = objc_msgSend(a10, "pid");
            *(_DWORD *)buf = 138413314;
            *(_QWORD *)&buf[4] = v199;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v201;
            *(_WORD *)&buf[22] = 2112;
            v356 = v202;
            *(_WORD *)v357 = 2112;
            *(_QWORD *)&v357[2] = v203;
            *(_WORD *)&v357[10] = 1024;
            *(_DWORD *)&v357[12] = v204;
            _os_log_fault_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports main thread, but %@ [%d] has no main thread", buf, 0x30u);
          }
          if (qword_1000EBD40)
            v85 = (FILE *)qword_1000EBD40;
          else
            v85 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v85);
        }
        *__error() = v315;
      }
    }
  }
  if (!objc_msgSend(a5, "reportSpindumpForThisDispatchQueue"))
    goto LABEL_332;
  v87 = objc_msgSend(objc_msgSend(objc_msgSend(a10, "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a7)), "firstThreadStateOnOrAfterTime:sampleIndex:", objc_msgSend(a9, "startTime"), 0x7FFFFFFFFFFFFFFFLL);
  v88 = objc_msgSend(objc_msgSend(objc_msgSend(a10, "threads"), "objectForKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", a8)), "lastThreadStateOnOrBeforeTime:sampleIndex:", objc_msgSend(a9, "endTime"), 0x7FFFFFFFFFFFFFFFLL);
  v89 = (uint64_t)objc_msgSend(v87, "dispatchQueue");
  v90 = (unint64_t)objc_msgSend(v88, "dispatchQueue");
  v316 = (void *)v90;
  if (!(v89 | v90))
  {
    if (byte_1000EBD38)
    {
      v92 = *__error();
      v93 = sub_100030318();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
      {
        v318 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v150 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v150)
          v151 = v150;
        else
          v151 = CFSTR("<entire workflow>");
        v152 = objc_msgSend(a5, "name");
        v153 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
        v154 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
        *(_DWORD *)buf = 138413826;
        *(_QWORD *)&buf[4] = v318;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v151;
        *(_WORD *)&buf[22] = 2112;
        v356 = v152;
        *(_WORD *)v357 = 2048;
        *(_QWORD *)&v357[2] = a7;
        *(_WORD *)&v357[10] = 2112;
        *(_QWORD *)&v357[12] = v153;
        *(_WORD *)&v357[20] = 2048;
        *(_QWORD *)&v357[22] = a8;
        *(_WORD *)&v357[30] = 2112;
        v358 = (uint64_t)v154;
        _os_log_error_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end %llu@%@ are on a dispatch queue", buf, 0x48u);
      }
      *__error() = v92;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v317 = *__error();
      v94 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      v95 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v95)
        v96 = v95;
      else
        v96 = CFSTR("<entire workflow>");
      v97 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end %llu@%@ are on a dispatch queue"), v94, v96, objc_msgSend(a5, "name"), a7, objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription"), a8, objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription"));
      v98 = v97;
      if (v97)
      {
        v99 = (char *)CFStringGetCStringPtr(v97, 0x8000100u);
        if (v99)
        {
          v100 = 0;
        }
        else
        {
          v99 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x16E96651uLL);
          CFStringGetCString(v98, v99, 1024, 0x8000100u);
          v100 = v99;
        }
        if (qword_1000EBD40)
          v134 = (FILE *)qword_1000EBD40;
        else
          v134 = __stderrp;
        fprintf(v134, "%s\n", v99);
        if (v100)
          free(v100);
        CFRelease(v98);
      }
      else
      {
        v123 = sub_100030318();
        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
        {
          v176 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v177 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v177)
            v178 = v177;
          else
            v178 = CFSTR("<entire workflow>");
          v179 = objc_msgSend(a5, "name");
          v180 = objc_msgSend(objc_msgSend(a9, "startTime"), "debugDescription");
          v181 = objc_msgSend(objc_msgSend(a9, "endTime"), "debugDescription");
          *(_DWORD *)buf = 138413826;
          *(_QWORD *)&buf[4] = v176;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v178;
          *(_WORD *)&buf[22] = 2112;
          v356 = v179;
          *(_WORD *)v357 = 2048;
          *(_QWORD *)&v357[2] = a7;
          *(_WORD *)&v357[10] = 2112;
          *(_QWORD *)&v357[12] = v180;
          *(_WORD *)&v357[20] = 2048;
          *(_QWORD *)&v357[22] = a8;
          *(_WORD *)&v357[30] = 2112;
          v358 = (uint64_t)v181;
          _os_log_fault_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but neither start %llu@%@ nor end %llu@%@ are on a dispatch queue", buf, 0x48u);
        }
        if (qword_1000EBD40)
          v124 = (FILE *)qword_1000EBD40;
        else
          v124 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v124);
      }
      v135 = __error();
      v136 = v317;
      goto LABEL_284;
    }
    goto LABEL_332;
  }
  if (v89 == v90)
  {
LABEL_330:
    if (v89)
      sub_10003D5A8(a1, a2, a6, (uint64_t)a9, (uint64_t)a10, v89);
    goto LABEL_332;
  }
  if (objc_msgSend(objc_msgSend(v87, "startTimestamp"), "le:", objc_msgSend(a9, "startTime")))
    v91 = objc_msgSend(objc_msgSend(v87, "endTimestamp"), "ge:", objc_msgSend(a9, "startTime"));
  else
    v91 = 0;
  if (objc_msgSend(objc_msgSend(v88, "startTimestamp"), "le:", objc_msgSend(a9, "endTime")))
  {
    v101 = objc_msgSend(objc_msgSend(v88, "endTimestamp"), "ge:", objc_msgSend(a9, "endTime"));
    if ((v91 & v101) == 1)
    {
      if (byte_1000EBD38)
      {
        v102 = *__error();
        v103 = sub_100030318();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          v336 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v207 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          v208 = CFSTR("<entire workflow>");
          if (v207)
            v208 = v207;
          v328 = v208;
          v209 = objc_msgSend(a5, "name");
          v210 = objc_msgSend((id)v89, "debugDescription");
          v211 = objc_msgSend(v316, "debugDescription");
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = v336;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v328;
          *(_WORD *)&buf[22] = 2112;
          v356 = v209;
          *(_WORD *)v357 = 2112;
          *(_QWORD *)&v357[2] = v210;
          *(_WORD *)&v357[10] = 2112;
          *(_QWORD *)&v357[12] = v211;
          _os_log_error_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting", buf, 0x34u);
        }
        *__error() = v102;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v332 = *__error();
        v104 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v105 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v105)
          v106 = v105;
        else
          v106 = CFSTR("<entire workflow>");
        v107 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting"), v104, v106, objc_msgSend(a5, "name"), objc_msgSend((id)v89, "debugDescription"), objc_msgSend(v316, "debugDescription"));
        v108 = v107;
        if (v107)
        {
          v109 = (char *)CFStringGetCStringPtr(v107, 0x8000100u);
          if (v109)
          {
            v110 = 0;
          }
          else
          {
            v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCE1E73F9uLL);
            CFStringGetCString(v108, v109, 1024, 0x8000100u);
            v110 = v109;
          }
          if (qword_1000EBD40)
            v173 = (FILE *)qword_1000EBD40;
          else
            v173 = __stderrp;
          fprintf(v173, "%s\n", v109);
          if (v110)
            free(v110);
LABEL_282:
          CFRelease(v108);
          goto LABEL_283;
        }
        v161 = sub_100030318();
        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT))
        {
          v287 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v288 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v288)
            v289 = v288;
          else
            v289 = CFSTR("<entire workflow>");
          v290 = objc_msgSend(a5, "name");
          v291 = objc_msgSend((id)v89, "debugDescription");
          v292 = objc_msgSend(v316, "debugDescription");
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = v287;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v289;
          *(_WORD *)&buf[22] = 2112;
          v356 = v290;
          *(_WORD *)v357 = 2112;
          *(_QWORD *)&v357[2] = v291;
          *(_WORD *)&v357[10] = 2112;
          *(_QWORD *)&v357[12] = v292;
          _os_log_fault_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, so not reporting", buf, 0x34u);
        }
        if (qword_1000EBD40)
          v156 = (FILE *)qword_1000EBD40;
        else
          v156 = __stderrp;
        goto LABEL_244;
      }
      goto LABEL_332;
    }
    if ((v91 & 1) != 0)
      goto LABEL_188;
    if (v101)
    {
      if (byte_1000EBD38)
      {
        v137 = *__error();
        v138 = sub_100030318();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
        {
          v337 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v293 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          v294 = CFSTR("<entire workflow>");
          if (v293)
            v294 = v293;
          v330 = v294;
          v295 = objc_msgSend(a5, "name");
          v296 = objc_msgSend((id)v89, "debugDescription");
          v297 = objc_msgSend(v316, "debugDescription");
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = v337;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v330;
          *(_WORD *)&buf[22] = 2112;
          v356 = v295;
          *(_WORD *)v357 = 2112;
          *(_QWORD *)&v357[2] = v296;
          *(_WORD *)&v357[10] = 2112;
          *(_QWORD *)&v357[12] = v297;
          _os_log_debug_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEBUG, "WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at the exact time, so using that", buf, 0x34u);
        }
        *__error() = v137;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
      {
        v89 = (uint64_t)v316;
        goto LABEL_330;
      }
      v334 = *__error();
      v139 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      v140 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v140)
        v141 = v140;
      else
        v141 = CFSTR("<entire workflow>");
      v142 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at the exact time, so using that"), v139, v141, objc_msgSend(a5, "name"), objc_msgSend((id)v89, "debugDescription"), objc_msgSend(v316, "debugDescription"));
      v143 = v142;
      if (v142)
      {
        v144 = (char *)CFStringGetCStringPtr(v142, 0x8000100u);
        if (v144)
        {
          v145 = 0;
        }
        else
        {
          v144 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF98E1683uLL);
          CFStringGetCString(v143, v144, 1024, 0x8000100u);
          v145 = v144;
        }
        if (qword_1000EBD40)
          v217 = (FILE *)qword_1000EBD40;
        else
          v217 = __stderrp;
        fprintf(v217, "%s\n", v144);
        if (v145)
          free(v145);
        CFRelease(v143);
      }
      else
      {
        v205 = sub_100030318();
        if (os_log_type_enabled(v205, OS_LOG_TYPE_FAULT))
        {
          v298 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v299 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v299)
            v300 = v299;
          else
            v300 = CFSTR("<entire workflow>");
          v301 = objc_msgSend(a5, "name");
          v302 = objc_msgSend((id)v89, "debugDescription");
          v303 = objc_msgSend(v316, "debugDescription");
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = v298;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v300;
          *(_WORD *)&buf[22] = 2112;
          v356 = v301;
          *(_WORD *)v357 = 2112;
          *(_QWORD *)&v357[2] = v302;
          *(_WORD *)&v357[10] = 2112;
          *(_QWORD *)&v357[12] = v303;
          _os_log_fault_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and end is at the exact time, so using that", buf, 0x34u);
        }
        if (qword_1000EBD40)
          v206 = (FILE *)qword_1000EBD40;
        else
          v206 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v206);
      }
      v89 = (uint64_t)v316;
      goto LABEL_329;
    }
  }
  else if (v91)
  {
LABEL_188:
    if (byte_1000EBD38)
    {
      v125 = *__error();
      v126 = sub_100030318();
      if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
      {
        v335 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v191 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        v192 = CFSTR("<entire workflow>");
        if (v191)
          v192 = v191;
        v327 = v192;
        v193 = objc_msgSend(a5, "name");
        v194 = objc_msgSend((id)v89, "debugDescription");
        v195 = objc_msgSend(v316, "debugDescription");
        *(_DWORD *)buf = 138413314;
        *(_QWORD *)&buf[4] = v335;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v327;
        *(_WORD *)&buf[22] = 2112;
        v356 = v193;
        *(_WORD *)v357 = 2112;
        *(_QWORD *)&v357[2] = v194;
        *(_WORD *)&v357[10] = 2112;
        *(_QWORD *)&v357[12] = v195;
        _os_log_debug_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEBUG, "WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that", buf, 0x34u);
      }
      *__error() = v125;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
      goto LABEL_330;
    v334 = *__error();
    v127 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
    v128 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
    if (v128)
      v129 = v128;
    else
      v129 = CFSTR("<entire workflow>");
    v130 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that"), v127, v129, objc_msgSend(a5, "name"), objc_msgSend((id)v89, "debugDescription"), objc_msgSend(v316, "debugDescription"));
    v131 = v130;
    if (v130)
    {
      v132 = (char *)CFStringGetCStringPtr(v130, 0x8000100u);
      if (v132)
      {
        v133 = 0;
      }
      else
      {
        v132 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x350E1AF7uLL);
        CFStringGetCString(v131, v132, 1024, 0x8000100u);
        v133 = v132;
      }
      if (qword_1000EBD40)
        v171 = (FILE *)qword_1000EBD40;
      else
        v171 = __stderrp;
      fprintf(v171, "%s\n", v132);
      if (v133)
        free(v133);
      CFRelease(v131);
    }
    else
    {
      v148 = sub_100030318();
      if (os_log_type_enabled(v148, OS_LOG_TYPE_FAULT))
      {
        v329 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v273 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v273)
          v274 = v273;
        else
          v274 = CFSTR("<entire workflow>");
        v275 = objc_msgSend(a5, "name");
        v276 = objc_msgSend((id)v89, "debugDescription");
        v277 = objc_msgSend(v316, "debugDescription");
        *(_DWORD *)buf = 138413314;
        *(_QWORD *)&buf[4] = v329;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v274;
        *(_WORD *)&buf[22] = 2112;
        v356 = v275;
        *(_WORD *)v357 = 2112;
        *(_QWORD *)&v357[2] = v276;
        *(_WORD *)&v357[10] = 2112;
        *(_QWORD *)&v357[12] = v277;
        _os_log_fault_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, signpost starts on %@ and ends on %@, and start is at the exact time, so using that", buf, 0x34u);
      }
      if (qword_1000EBD40)
        v149 = (FILE *)qword_1000EBD40;
      else
        v149 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v149);
    }
LABEL_329:
    *__error() = v334;
    goto LABEL_330;
  }
  if (byte_1000EBD38)
  {
    v333 = *__error();
    v111 = sub_100030318();
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      v326 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      v112 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v112)
        v113 = v112;
      else
        v113 = CFSTR("<entire workflow>");
      v114 = objc_msgSend(a5, "name");
      v115 = objc_msgSend((id)v89, "debugDescription");
      v116 = objc_msgSend(v316, "debugDescription");
      *(_DWORD *)buf = 138413314;
      *(_QWORD *)&buf[4] = v326;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v113;
      *(_WORD *)&buf[22] = 2112;
      v356 = v114;
      *(_WORD *)v357 = 2112;
      *(_QWORD *)&v357[2] = v115;
      *(_WORD *)&v357[10] = 2112;
      *(_QWORD *)&v357[12] = v116;
      _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting", buf, 0x34u);
    }
    *__error() = v333;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
  {
    v332 = *__error();
    v117 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
    v118 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
    if (v118)
      v119 = v118;
    else
      v119 = CFSTR("<entire workflow>");
    v120 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting"), v117, v119, objc_msgSend(a5, "name"), objc_msgSend((id)v89, "debugDescription"), objc_msgSend(v316, "debugDescription"));
    v108 = v120;
    if (v120)
    {
      v121 = (char *)CFStringGetCStringPtr(v120, 0x8000100u);
      if (v121)
      {
        v122 = 0;
      }
      else
      {
        v121 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDC7792EAuLL);
        CFStringGetCString(v108, v121, 1024, 0x8000100u);
        v122 = v121;
      }
      if (qword_1000EBD40)
        v172 = (FILE *)qword_1000EBD40;
      else
        v172 = __stderrp;
      fprintf(v172, "%s\n", v121);
      if (v122)
        free(v122);
      goto LABEL_282;
    }
    v155 = sub_100030318();
    if (os_log_type_enabled(v155, OS_LOG_TYPE_FAULT))
    {
      v281 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      v282 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v282)
        v283 = v282;
      else
        v283 = CFSTR("<entire workflow>");
      v284 = objc_msgSend(a5, "name");
      v285 = objc_msgSend((id)v89, "debugDescription");
      v286 = objc_msgSend(v316, "debugDescription");
      *(_DWORD *)buf = 138413314;
      *(_QWORD *)&buf[4] = v281;
      *(_WORD *)&buf[12] = 2112;
      *(_QWORD *)&buf[14] = v283;
      *(_WORD *)&buf[22] = 2112;
      v356 = v284;
      *(_WORD *)v357 = 2112;
      *(_QWORD *)&v357[2] = v285;
      *(_WORD *)&v357[10] = 2112;
      *(_QWORD *)&v357[12] = v286;
      _os_log_fault_impl((void *)&_mh_execute_header, v155, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports this dispatch queue, but signpost starts on %@ and ends on %@, neither at the exact right time, so not reporting", buf, 0x34u);
    }
    if (qword_1000EBD40)
      v156 = (FILE *)qword_1000EBD40;
    else
      v156 = __stderrp;
LABEL_244:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v156);
LABEL_283:
    v135 = __error();
    v136 = v332;
LABEL_284:
    *v135 = v136;
  }
LABEL_332:
  v218 = objc_msgSend(a5, "reportSpindumpForDispatchQueueWithLabel");
  v219 = v218;
  if (!v218)
    return;
  if (objc_msgSend(v218, "hasPrefix:", CFSTR("^"))
    && objc_msgSend(v219, "hasSuffix:", CFSTR("$")))
  {
    *(_QWORD *)v352 = 0;
    v220 = objc_msgSend(objc_alloc((Class)NSRegularExpression), "initWithPattern:options:error:", v219, 0, v352);
    if (!v220)
    {
      if (byte_1000EBD38)
      {
        v221 = *__error();
        v222 = sub_100030318();
        if (os_log_type_enabled(v222, OS_LOG_TYPE_ERROR))
        {
          v266 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v267 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v267)
            v268 = v267;
          else
            v268 = CFSTR("<entire workflow>");
          v269 = objc_msgSend(a5, "name");
          *(_DWORD *)buf = 138413314;
          *(_QWORD *)&buf[4] = v266;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v268;
          *(_WORD *)&buf[22] = 2112;
          v356 = v269;
          *(_WORD *)v357 = 2112;
          *(_QWORD *)&v357[2] = v219;
          *(_WORD *)&v357[10] = 2112;
          *(_QWORD *)&v357[12] = *(_QWORD *)v352;
          _os_log_error_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@", buf, 0x34u);
        }
        *__error() = v221;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v223 = *__error();
        v224 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v225 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        v226 = CFSTR("<entire workflow>");
        if (v225)
          v227 = v225;
        else
          v227 = CFSTR("<entire workflow>");
        v228 = objc_msgSend(a5, "name");
        v229 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@"), v224, v227, v228, v219, *(_QWORD *)v352);
        v230 = v229;
        if (v229)
        {
          v231 = (char *)CFStringGetCStringPtr(v229, 0x8000100u);
          if (v231)
          {
            v232 = 0;
          }
          else
          {
            v231 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF2FD6954uLL);
            CFStringGetCString(v230, v231, 1024, 0x8000100u);
            v232 = v231;
          }
          if (qword_1000EBD40)
            v259 = (FILE *)qword_1000EBD40;
          else
            v259 = __stderrp;
          fprintf(v259, "%s\n", v231);
          if (v232)
            free(v232);
          CFRelease(v230);
        }
        else
        {
          v251 = sub_100030318();
          if (os_log_type_enabled(v251, OS_LOG_TYPE_FAULT))
          {
            v278 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
            v279 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
            if (v279)
              v226 = v279;
            v280 = objc_msgSend(a5, "name");
            *(_DWORD *)buf = 138413314;
            *(_QWORD *)&buf[4] = v278;
            *(_WORD *)&buf[12] = 2112;
            *(_QWORD *)&buf[14] = v226;
            *(_WORD *)&buf[22] = 2112;
            v356 = v280;
            *(_WORD *)v357 = 2112;
            *(_QWORD *)&v357[2] = v219;
            *(_WORD *)&v357[10] = 2112;
            *(_QWORD *)&v357[12] = *(_QWORD *)v352;
            _os_log_fault_impl((void *)&_mh_execute_header, v251, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports dispatch queue %@, but regex failed to compile: %@", buf, 0x34u);
          }
          if (qword_1000EBD40)
            v252 = (FILE *)qword_1000EBD40;
          else
            v252 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v252);
        }
        *__error() = v223;
      }
      return;
    }
  }
  else
  {
    v220 = 0;
  }
  v346 = 0;
  v347 = &v346;
  v348 = 0x3052000000;
  v349 = sub_100038864;
  v350 = sub_100038874;
  v351 = 0;
  v233 = objc_msgSend(a10, "dispatchQueues");
  v339 = _NSConcreteStackBlock;
  v340 = 3221225472;
  v341 = (uint64_t)sub_10003D62C;
  v342 = &unk_1000DCEF0;
  v343 = v220;
  v344 = v219;
  v345 = &v346;
  objc_msgSend(v233, "enumerateKeysAndObjectsUsingBlock:", &v339);
  v234 = (void *)v347[5];
  if (v234)
  {
    memset(v352, 0, 64);
    v235 = objc_msgSend(v234, "countByEnumeratingWithState:objects:count:", v352, buf, 16);
    if (v235)
    {
      v236 = **(_QWORD **)&v352[16];
      do
      {
        for (i = 0; i != v235; i = (char *)i + 1)
        {
          if (**(_QWORD **)&v352[16] != v236)
            objc_enumerationMutation(v234);
          sub_10003D5A8(a1, a2, a6, (uint64_t)a9, (uint64_t)a10, *(_QWORD *)(*(_QWORD *)&v352[8] + 8 * (_QWORD)i));
        }
        v235 = objc_msgSend(v234, "countByEnumeratingWithState:objects:count:", v352, buf, 16);
      }
      while (v235);
    }

  }
  else
  {
    if (byte_1000EBD38)
    {
      v238 = *__error();
      v239 = sub_100030318();
      if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
      {
        v253 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
        v254 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
        if (v254)
          v255 = v254;
        else
          v255 = CFSTR("<entire workflow>");
        v256 = objc_msgSend(a5, "name");
        v257 = objc_msgSend(a10, "name");
        v258 = objc_msgSend(a10, "pid");
        *(_DWORD *)buf = 138413570;
        *(_QWORD *)&buf[4] = v253;
        *(_WORD *)&buf[12] = 2112;
        *(_QWORD *)&buf[14] = v255;
        *(_WORD *)&buf[22] = 2112;
        v356 = v256;
        *(_WORD *)v357 = 2112;
        *(_QWORD *)&v357[2] = v219;
        *(_WORD *)&v357[10] = 2112;
        *(_QWORD *)&v357[12] = v257;
        *(_WORD *)&v357[20] = 1024;
        *(_DWORD *)&v357[22] = v258;
        _os_log_error_impl((void *)&_mh_execute_header, v239, OS_LOG_TYPE_ERROR, "WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue", buf, 0x3Au);
      }
      *__error() = v238;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v240 = *__error();
      v241 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
      v242 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
      if (v242)
        v243 = v242;
      else
        v243 = CFSTR("<entire workflow>");
      v244 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue"), v241, v243, objc_msgSend(a5, "name"), v219, objc_msgSend(a10, "name"), objc_msgSend(a10, "pid"));
      v245 = v244;
      if (v244)
      {
        v246 = (char *)CFStringGetCStringPtr(v244, 0x8000100u);
        if (v246)
        {
          v247 = 0;
        }
        else
        {
          v246 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD1CB472uLL);
          CFStringGetCString(v245, v246, 1024, 0x8000100u);
          v247 = v246;
        }
        if (qword_1000EBD40)
          v250 = (FILE *)qword_1000EBD40;
        else
          v250 = __stderrp;
        fprintf(v250, "%s\n", v246);
        if (v247)
          free(v247);
        CFRelease(v245);
      }
      else
      {
        v248 = sub_100030318();
        if (os_log_type_enabled(v248, OS_LOG_TYPE_FAULT))
        {
          v260 = objc_msgSend(objc_msgSend(a3, "workflow"), "name");
          v261 = (const __CFString *)objc_msgSend(objc_msgSend(a4, "signpost"), "name");
          if (v261)
            v262 = v261;
          else
            v262 = CFSTR("<entire workflow>");
          v263 = objc_msgSend(a5, "name");
          v264 = objc_msgSend(a10, "name");
          v265 = objc_msgSend(a10, "pid");
          *(_DWORD *)buf = 138413570;
          *(_QWORD *)&buf[4] = v260;
          *(_WORD *)&buf[12] = 2112;
          *(_QWORD *)&buf[14] = v262;
          *(_WORD *)&buf[22] = 2112;
          v356 = v263;
          *(_WORD *)v357 = 2112;
          *(_QWORD *)&v357[2] = v219;
          *(_WORD *)&v357[10] = 2112;
          *(_QWORD *)&v357[12] = v264;
          *(_WORD *)&v357[20] = 1024;
          *(_DWORD *)&v357[22] = v265;
          _os_log_fault_impl((void *)&_mh_execute_header, v248, OS_LOG_TYPE_FAULT, "Unable to format: WR: %@: %@: diagnostic %@ reports dispatch queue %@, but %@ [%d] has no such dispatch queue", buf, 0x3Au);
        }
        if (qword_1000EBD40)
          v249 = (FILE *)qword_1000EBD40;
        else
          v249 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v249);
      }
      *__error() = v240;
    }
  }

  _Block_object_dispose(&v346, 8);
}

void sub_10003D08C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
  _Block_object_dispose(&a35, 8);
  _Unwind_Resume(a1);
}

void sub_10003D10C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5;
  id v6;
  void *v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  SPWRReport *v13;
  _QWORD v14[4];
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  void *v19;
  __int128 v20;
  uint64_t *v21;
  uint64_t *v22;
  _QWORD *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  void (*v27)(uint64_t, uint64_t);
  void (*v28)(uint64_t);
  uint64_t v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  void (*v33)(uint64_t, uint64_t);
  void (*v34)(uint64_t);
  uint64_t v35;
  _QWORD v36[3];
  char v37;

  v36[0] = 0;
  v36[1] = v36;
  v36[2] = 0x2020000000;
  v37 = 0;
  v30 = 0;
  v31 = &v30;
  v32 = 0x3052000000;
  v33 = sub_100038864;
  v34 = sub_100038874;
  v35 = 0;
  v24 = 0;
  v25 = &v24;
  v26 = 0x3052000000;
  v27 = sub_100038864;
  v28 = sub_100038874;
  v29 = 0;
  v5 = objc_msgSend(*(id *)(a1 + 32), "startTime");
  v6 = objc_msgSend(*(id *)(a1 + 32), "endTime");
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10003D3AC;
  v14[3] = &unk_1000DCEA0;
  v15 = *(_OWORD *)(a1 + 40);
  v21 = &v30;
  v22 = &v24;
  v23 = v36;
  v16 = *(_QWORD *)(a1 + 32);
  v17 = *(_OWORD *)(a1 + 56);
  v18 = *(_QWORD *)(a1 + 72);
  v19 = a3;
  v20 = *(_OWORD *)(a1 + 80);
  objc_msgSend(a3, "enumerateThreadStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", v5, 0x7FFFFFFFFFFFFFFFLL, v6, 0x7FFFFFFFFFFFFFFFLL, 0, v14);
  v7 = (void *)v31[5];
  if (v7 && v25[5])
  {
    if (objc_msgSend(objc_msgSend(v7, "startTimestamp"), "gt:", objc_msgSend(*(id *)(a1 + 32), "startTime")))v8 = objc_msgSend((id)v31[5], "startTimestamp");
    else
      v8 = objc_msgSend(*(id *)(a1 + 32), "startTime");
    v9 = v8;
    if (objc_msgSend(objc_msgSend((id)v31[5], "endTimestamp"), "lt:", objc_msgSend(*(id *)(a1 + 32), "endTime")))v10 = objc_msgSend((id)v31[5], "endTimestamp");
    else
      v10 = objc_msgSend(*(id *)(a1 + 32), "endTime");
    v11 = v10;
    if (v9 == objc_msgSend(*(id *)(a1 + 32), "startTime") && v11 == objc_msgSend(*(id *)(a1 + 32), "endTime"))
      v12 = *(id *)(a1 + 32);
    else
      v12 = +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", v9, v11);
    v13 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]([SPWRReport alloc], "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), v12, a3, 0);
    objc_msgSend(*(id *)(a1 + 80), "addObject:", v13);

  }
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v30, 8);
  _Block_object_dispose(v36, 8);
}

void sub_10003D36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  uint64_t v17;
  va_list va;

  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v17 - 128), 8);
  _Block_object_dispose((const void *)(v17 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_10003D3AC(uint64_t a1, void *a2)
{
  id v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  SPWRReport *v14;

  v4 = objc_msgSend(a2, "name");
  if (v4)
  {
    v5 = v4;
    v6 = *(void **)(a1 + 32);
    if (!v6)
      goto LABEL_25;
    if (objc_msgSend(v6, "numberOfMatchesInString:options:range:", v4, 4, 0, objc_msgSend(v4, "length")))
    {
LABEL_6:
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 96) + 8) + 24) = 1;
      v7 = *(_QWORD *)(*(_QWORD *)(a1 + 104) + 8);
      if (!*(_QWORD *)(v7 + 40))
        *(_QWORD *)(v7 + 40) = a2;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 40) = a2;
      return;
    }
    if (!*(_QWORD *)(a1 + 32))
    {
LABEL_25:
      if (objc_msgSend(v5, "isEqualToString:", *(_QWORD *)(a1 + 40)))
        goto LABEL_6;
    }
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 8) + 24) = 1;
  v8 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 40);
  if (v8 && *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8) + 40))
  {
    if (objc_msgSend(objc_msgSend(v8, "startTimestamp"), "gt:", objc_msgSend(*(id *)(a1 + 48), "startTime")))v9 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 40), "startTimestamp");
    else
      v9 = objc_msgSend(*(id *)(a1 + 48), "startTime");
    v10 = v9;
    if (objc_msgSend(objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 40), "endTimestamp"), "lt:", objc_msgSend(*(id *)(a1 + 48), "endTime")))v11 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8) + 40), "endTimestamp");
    else
      v11 = objc_msgSend(*(id *)(a1 + 48), "endTime");
    v12 = v11;
    if (v10 == objc_msgSend(*(id *)(a1 + 48), "startTime") && v12 == objc_msgSend(*(id *)(a1 + 48), "endTime"))
      v13 = *(id *)(a1 + 48);
    else
      v13 = +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", v10, v12);
    v14 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]([SPWRReport alloc], "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:", *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 72), v13, *(_QWORD *)(a1 + 80), 0);
    objc_msgSend(*(id *)(a1 + 88), "addObject:", v14);

  }
}

void sub_10003D5A8(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  SPWRReport *v7;

  v7 = -[SPWRReport initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:]([SPWRReport alloc], "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:", a2, a3, a5, a4, 0, a6);
  objc_msgSend(a1, "addObject:", v7);

}

id sub_10003D62C(_QWORD *a1, uint64_t a2, void *a3)
{
  id result;
  void *v6;
  void *v7;
  void *v8;

  result = objc_msgSend(a3, "dispatchQueueLabel");
  if (result)
  {
    v6 = result;
    v7 = (void *)a1[4];
    if (v7)
    {
      result = objc_msgSend(v7, "numberOfMatchesInString:options:range:", result, 4, 0, objc_msgSend(result, "length"));
      if (result)
      {
LABEL_6:
        v8 = *(void **)(*(_QWORD *)(a1[6] + 8) + 40);
        if (v8)
          return objc_msgSend(v8, "addObject:", a3);
        result = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithObjects:", a3, 0);
        *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40) = result;
        return result;
      }
      if (a1[4])
        return result;
    }
    result = objc_msgSend(v6, "isEqualToString:", a1[5]);
    if (!(_DWORD)result)
      return result;
    goto LABEL_6;
  }
  return result;
}

id sub_10003D6FC(uint64_t a1, void *a2)
{
  id result;

  result = objc_msgSend(objc_msgSend(a2, "name"), "isEqualToString:", *(_QWORD *)(a1 + 32));
  if ((_DWORD)result)
    return objc_msgSend(*(id *)(a1 + 40), "addObject:", a2);
  return result;
}

uint64_t sub_10003D744(void *a1, uint64_t a2)
{
  uint64_t v4;
  double v5;
  BOOL v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double v11;
  double v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;

  v4 = objc_opt_class(NSNumber);
  if ((objc_opt_isKindOfClass(a1, v4) & 1) != 0)
  {
    objc_msgSend(a1, "doubleValue");
    v6 = v5 < 0.0;
    if (v5 == 0.0)
    {
      result = +[NSDecimalNumber zero](NSDecimalNumber, "zero");
    }
    else
    {
      v11 = v5;
      v12 = -v5;
      if (!v6)
        v12 = v11;
      v13 = vcvtpd_s64_f64(log10(v12));
      v14 = llround(v11 * __exp10((double)(int)(3 - v13)));
      if (v14 >= 0)
        v15 = v14;
      else
        v15 = -v14;
      result = +[NSDecimalNumber decimalNumberWithMantissa:exponent:isNegative:](NSDecimalNumber, "decimalNumberWithMantissa:exponent:isNegative:", v15, (__int16)(v13 - 3), (unint64_t)v14 >> 63);
    }
    if ((void *)result != a1)
      return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, result);
  }
  else
  {
    v8 = objc_opt_class(NSMutableDictionary);
    if ((objc_opt_isKindOfClass(a1, v8) & 1) != 0)
      return sub_100039408(a1);
    v9 = objc_opt_class(NSMutableArray);
    if ((objc_opt_isKindOfClass(a1, v9) & 1) != 0)
      return sub_100039408(a1);
    v10 = objc_opt_class(NSMutableSet);
    result = objc_opt_isKindOfClass(a1, v10);
    if ((result & 1) != 0)
      return sub_100039408(a1);
  }
  return result;
}

id sub_10003D890(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", a2, *(_QWORD *)(a1 + 40));
}

id sub_10003D8A0(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "setObject:atIndexedSubscript:", a2, *(_QWORD *)(a1 + 40));
}

id sub_10003D8B0(uint64_t a1, uint64_t a2)
{
  objc_msgSend(*(id *)(a1 + 32), "removeObject:", *(_QWORD *)(a1 + 40));
  return objc_msgSend(*(id *)(a1 + 32), "addObject:", a2);
}

void sub_10003D8E4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

void sub_10003D8F4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0xCu);
}

void sub_10003D900(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

uint64_t sub_10003D910(uint64_t result, uint64_t a2, int a3, float a4)
{
  *(float *)a2 = a4;
  *(_QWORD *)(a2 + 4) = result;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 18) = 2080;
  return result;
}

uint64_t sub_10003D930(uint64_t result, uint64_t a2, uint64_t a3, float a4)
{
  *(float *)a3 = a4;
  *(_QWORD *)(a3 + 4) = result;
  *(_WORD *)(a3 + 12) = 2112;
  *(_QWORD *)(a3 + 14) = a2;
  return result;
}

void sub_10003D948(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x16u);
}

void sub_10003D960(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

void sub_10003D990(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

void sub_10003D9B8(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void sub_10003D9C4(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_fault_impl(a1, a4, OS_LOG_TYPE_FAULT, a2, a3, 0x1Cu);
}

void sub_10003D9D4(void *a1@<X0>, const char *a2@<X3>, uint8_t *a3@<X4>, NSObject *a4@<X8>)
{
  _os_log_error_impl(a1, a4, OS_LOG_TYPE_ERROR, a2, a3, 0x1Cu);
}

void sub_10003D9FC(unint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, const char *a7, const char *a8, double a9, double a10, uint64_t a11)
{
  unint64_t v18;
  int v19;
  NSObject *v20;
  BOOL v21;
  int v22;
  _DWORD *v23;
  const __CFString *v24;
  NSObject *v25;
  _DWORD *v26;
  const char *v27;
  NSObject *v28;
  uint32_t v29;
  int v30;
  NSObject *v31;
  BOOL v32;
  const __CFString *v33;
  const char *CStringPtr;
  char *v35;
  char *v36;
  FILE *v37;
  NSObject *v38;
  FILE *v39;
  double v40;
  char *v41;
  char *v42;
  char *v43;
  char *v44;
  char *v45;
  char *v46;
  char *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char *v52;
  int v53;
  NSObject *v54;
  char *v55;
  _DWORD *v56;
  CFStringRef v57;
  const __CFString *v58;
  int v59;
  NSObject *v60;
  _BOOL4 v61;
  int v62;
  _DWORD *v63;
  const __CFString *v64;
  NSObject *v65;
  int v66;
  NSObject *v67;
  _BOOL4 v68;
  int v69;
  _DWORD *v70;
  const __CFString *v71;
  NSObject *v72;
  int v73;
  NSObject *v74;
  int v75;
  CFStringRef v76;
  const char *v77;
  char *v78;
  char *v79;
  const __CFString *v80;
  const char *v81;
  char *v82;
  char *v83;
  const __CFString *v84;
  char *v85;
  const char *v86;
  char *v87;
  char *v88;
  NSObject *v89;
  FILE *v90;
  FILE *v91;
  int v92;
  unsigned int v93;
  uint64_t v94;
  char *v95;
  double Current;
  unsigned __int8 v97;
  unint64_t v98;
  char *v99;
  char *v100;
  unsigned int v101;
  char **v102;
  char **v103;
  int v104;
  double v105;
  qos_class_t v106;
  char *v107;
  dispatch_queue_global_t global_queue;
  int v109;
  NSObject *v110;
  int v111;
  _DWORD *v112;
  uint64_t v113;
  int *v114;
  char *v115;
  const __CFString *v116;
  const __CFString *v117;
  const char *v118;
  char *v119;
  char *v120;
  uint64_t v121;
  char **v122;
  double v123;
  double v124;
  uint64_t v125;
  _QWORD *v126;
  const void **v127;
  unsigned int v128;
  uint64_t v129;
  void *v130;
  int v131;
  uint64_t v132;
  qos_class_t v133;
  NSObject *v134;
  NSObject *v135;
  uint64_t v136;
  FILE *v137;
  FILE *v138;
  NSObject *v139;
  FILE *v140;
  int v141;
  NSObject *v142;
  uint64_t v143;
  int *v144;
  char *v145;
  const __CFString *v146;
  const __CFString *v147;
  const char *v148;
  char *v149;
  char *v150;
  NSObject *v151;
  FILE *v152;
  char *v153;
  NSObject *v154;
  FILE *v155;
  _DWORD *v156;
  NSObject *v157;
  FILE *v158;
  FILE *v159;
  const __CFString *v160;
  NSObject *v161;
  FILE *v162;
  FILE *v163;
  int *v164;
  _DWORD *v165;
  int v166;
  NSObject *v167;
  _BOOL4 v168;
  int v169;
  _DWORD *v170;
  char *v171;
  const __CFString *v172;
  NSObject *v173;
  int v174;
  NSObject *v175;
  _BOOL4 v176;
  char *v177;
  int v178;
  _DWORD *v179;
  char *v180;
  const __CFString *v181;
  NSObject *v182;
  _DWORD *v183;
  int v184;
  NSObject *v185;
  int v186;
  _DWORD *v187;
  const __CFString *v188;
  NSObject *v189;
  FILE *v190;
  int v191;
  NSObject *v192;
  int v193;
  _DWORD *v194;
  const __CFString *v195;
  NSObject *v196;
  FILE *v197;
  int v198;
  NSObject *v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  int v207;
  const __CFString *v208;
  NSObject *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  FILE *v217;
  int v218;
  NSObject *v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  int v227;
  const __CFString *v228;
  NSObject *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  FILE *v237;
  int v238;
  NSObject *v239;
  _BOOL4 v240;
  char *v241;
  int v242;
  _DWORD *v243;
  const __CFString *v244;
  const __CFString *v245;
  const char *v246;
  char *v247;
  char *v248;
  int v249;
  NSObject *v250;
  _BOOL4 v251;
  char *v252;
  int v253;
  _DWORD *v254;
  const __CFString *v255;
  NSObject *v256;
  const __CFString *v257;
  const char *v258;
  char *v259;
  char *v260;
  const __CFString *v261;
  const char *v262;
  char *v263;
  char *v264;
  const __CFString *v265;
  const __CFString *v266;
  const char *v267;
  char *v268;
  char *v269;
  const __CFString *v270;
  const char *v271;
  char *v272;
  char *v273;
  FILE *v274;
  const __CFString *v275;
  const char *v276;
  char *v277;
  char *v278;
  const __CFString *v279;
  const char *v280;
  char *v281;
  char *v282;
  const __CFString *v283;
  const char *v284;
  char *v285;
  char *v286;
  const __CFString *v287;
  const char *v288;
  char *v289;
  char *v290;
  FILE *v291;
  NSObject *v292;
  FILE *v293;
  NSObject *v294;
  FILE *v295;
  FILE *v296;
  const char *v297;
  FILE *v298;
  int v299;
  FILE *v300;
  FILE *v301;
  NSObject *v302;
  FILE *v303;
  _DWORD *v304;
  FILE *v305;
  const __CFString *v306;
  NSObject *v307;
  FILE *v308;
  NSObject *v309;
  FILE *v310;
  char *v311;
  FILE *v312;
  const char *v313;
  int v314;
  char *v315;
  int v316;
  char *v317;
  _QWORD v321[9];
  int v322;
  unint64_t v323;
  int v324;
  _QWORD v325[2];
  uint64_t (*v326)(uint64_t, uint64_t, uint64_t);
  void *v327;
  uint64_t v328;
  char *v329;
  char *v330;
  char *v331;
  time_t v332;
  tm v333;
  int v334;
  uint64_t v335;
  char v336[16];
  __int128 v337;
  _BYTE buf[100];
  __int16 v339;
  const char *v340;
  __int16 v341;
  _BOOL4 v342;
  _OWORD buffer[8];

  v18 = HIDWORD(a1);
  memset(buffer, 0, sizeof(buffer));
  proc_name(a1, buffer, 0x80u);
  if ((a3 & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v19 = *__error();
      v20 = sub_100030318();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136449282;
        *(_QWORD *)&buf[4] = sub_1000302B4(a3);
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a3;
        *(_WORD *)&buf[18] = 2082;
        *(_QWORD *)&buf[20] = buffer;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a1;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v18;
        *(_WORD *)&buf[40] = 2048;
        *(_QWORD *)&buf[42] = a4;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = a9;
        *(_WORD *)&buf[60] = 2048;
        *(double *)&buf[62] = a10;
        *(_WORD *)&buf[70] = 2048;
        *(_QWORD *)&buf[72] = a5;
        *(_WORD *)&buf[80] = 2080;
        *(_QWORD *)&buf[82] = a6;
        *(_WORD *)&buf[90] = 2080;
        *(_QWORD *)&buf[92] = a7;
        v339 = 2080;
        v340 = a8;
        v341 = 1024;
        v342 = a11 != 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "%{public}s [%d]: generate spindump: requested by %{public}s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d", buf, 0x74u);
      }
      *__error() = v19;
    }
    if (byte_1000EBD39)
      v21 = dword_1000EB4E8 <= 1;
    else
      v21 = 0;
    if (!v21)
      goto LABEL_39;
    v22 = *__error();
    v23 = sub_1000302B4(a3);
    v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d"), v23, a3, buffer, a1, v18, a4, *(_QWORD *)&a9, *(_QWORD *)&a10, a5, a6, a7, a8, a11 != 0);
    if (!v24)
    {
      v25 = sub_100030318();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
      {
        v26 = sub_1000302B4(a3);
        *(_DWORD *)buf = 136318210;
        *(_QWORD *)&buf[4] = v26;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a3;
        *(_WORD *)&buf[18] = 2080;
        *(_QWORD *)&buf[20] = buffer;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = a1;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v18;
        *(_WORD *)&buf[40] = 2048;
        *(_QWORD *)&buf[42] = a4;
        *(_WORD *)&buf[50] = 2048;
        *(double *)&buf[52] = a9;
        *(_WORD *)&buf[60] = 2048;
        *(double *)&buf[62] = a10;
        *(_WORD *)&buf[70] = 2048;
        *(_QWORD *)&buf[72] = a5;
        *(_WORD *)&buf[80] = 2080;
        *(_QWORD *)&buf[82] = a6;
        *(_WORD *)&buf[90] = 2080;
        *(_QWORD *)&buf[92] = a7;
        v339 = 2080;
        v340 = a8;
        v341 = 1024;
        v342 = a11 != 0;
        v27 = "Unable to format: %s [%d]: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f inte"
              "rval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d";
        v28 = v25;
        v29 = 116;
LABEL_254:
        _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v27, buf, v29);
        goto LABEL_34;
      }
      goto LABEL_34;
    }
    goto LABEL_24;
  }
  if (byte_1000EBD38)
  {
    v30 = *__error();
    v31 = sub_100030318();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136448770;
      *(_QWORD *)&buf[4] = buffer;
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = a1;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v18;
      *(_WORD *)&buf[24] = 2048;
      *(_QWORD *)&buf[26] = a4;
      *(_WORD *)&buf[34] = 2048;
      *(double *)&buf[36] = a9;
      *(_WORD *)&buf[44] = 2048;
      *(double *)&buf[46] = a10;
      *(_WORD *)&buf[54] = 2048;
      *(_QWORD *)&buf[56] = a5;
      *(_WORD *)&buf[64] = 2080;
      *(_QWORD *)&buf[66] = a6;
      *(_WORD *)&buf[74] = 2080;
      *(_QWORD *)&buf[76] = a7;
      *(_WORD *)&buf[84] = 2080;
      *(_QWORD *)&buf[86] = a8;
      *(_WORD *)&buf[94] = 1024;
      *(_DWORD *)&buf[96] = a11 != 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_INFO, "generate spindump: requested by %{public}s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d", buf, 0x64u);
    }
    *__error() = v30;
  }
  if (byte_1000EBD39)
    v32 = dword_1000EB4E8 <= 1;
  else
    v32 = 0;
  if (v32)
  {
    v22 = *__error();
    v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f flags:%#llx reason:%s signature:%s filename:%s callback:%d"), buffer, a1, v18, a4, *(_QWORD *)&a9, *(_QWORD *)&a10, a5, a6, a7, a8, a11 != 0);
    if (!v24)
    {
      v38 = sub_100030318();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136317698;
        *(_QWORD *)&buf[4] = buffer;
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = a1;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v18;
        *(_WORD *)&buf[24] = 2048;
        *(_QWORD *)&buf[26] = a4;
        *(_WORD *)&buf[34] = 2048;
        *(double *)&buf[36] = a9;
        *(_WORD *)&buf[44] = 2048;
        *(double *)&buf[46] = a10;
        *(_WORD *)&buf[54] = 2048;
        *(_QWORD *)&buf[56] = a5;
        *(_WORD *)&buf[64] = 2080;
        *(_QWORD *)&buf[66] = a6;
        *(_WORD *)&buf[74] = 2080;
        *(_QWORD *)&buf[76] = a7;
        *(_WORD *)&buf[84] = 2080;
        *(_QWORD *)&buf[86] = a8;
        *(_WORD *)&buf[94] = 1024;
        *(_DWORD *)&buf[96] = a11 != 0;
        v27 = "Unable to format: generate spindump: requested by %s [%d] uid %d, thread:%#llx duration:%.3f interval:%.6f"
              " flags:%#llx reason:%s signature:%s filename:%s callback:%d";
        v28 = v38;
        v29 = 100;
        goto LABEL_254;
      }
LABEL_34:
      if (qword_1000EBD40)
        v39 = (FILE *)qword_1000EBD40;
      else
        v39 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v39);
LABEL_38:
      *__error() = v22;
      goto LABEL_39;
    }
LABEL_24:
    v33 = v24;
    CStringPtr = CFStringGetCStringPtr(v24, 0x8000100u);
    if (CStringPtr)
    {
      v35 = (char *)CStringPtr;
      v36 = 0;
    }
    else
    {
      v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8F314794uLL);
      CFStringGetCString(v33, v35, 1024, 0x8000100u);
      v36 = v35;
    }
    if (qword_1000EBD40)
      v37 = (FILE *)qword_1000EBD40;
    else
      v37 = __stderrp;
    fprintf(v37, "%s\n", v35);
    if (v36)
      free(v36);
    CFRelease(v33);
    goto LABEL_38;
  }
LABEL_39:
  if (a9 == 0.0)
    a9 = 10.0;
  if (a10 == 0.0)
    v40 = 0.01;
  else
    v40 = a10;
  *(_OWORD *)v336 = 0u;
  v337 = 0u;
  memset(&v333, 0, sizeof(v333));
  v332 = time(0);
  localtime_r(&v332, &v333);
  strftime(v336, 0x20uLL, "%Y-%m-%d-%T", &v333);
  v41 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x8F9D389uLL);
  v42 = v41;
  if (!a8 || !*a8)
    a8 = (const char *)buffer;
  if (snprintf(v41, 0x400uLL, "/var/mobile/Library/Logs/CrashReporter/%s.%s.spindump.txt", a8, v336) < 0x400)
  {
    v43 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0xC4FF5730uLL);
    if (dirname_r(v42, v43))
    {
      v44 = (char *)malloc_type_calloc(1uLL, 0x400uLL, 0x6BF6B720uLL);
      if (basename_r(v42, v44))
      {
        v45 = realpath_DARWIN_EXTSN(v43, 0);
        if (v45)
        {
          v46 = v45;
          v47 = realpath_DARWIN_EXTSN("/var/mobile/Library/Logs/CrashReporter", 0);
          if (v47)
          {
            v52 = v47;
            if (strcmp("/", v47))
            {
              v317 = v44;
              if ((a3 & 0x80000000) != 0)
              {
                if (byte_1000EBD38)
                {
                  v73 = *__error();
                  v74 = sub_100030318();
                  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136315906;
                    *(_QWORD *)&buf[4] = v43;
                    *(_WORD *)&buf[12] = 2080;
                    *(_QWORD *)&buf[14] = v317;
                    *(_WORD *)&buf[22] = 2080;
                    *(_QWORD *)&buf[24] = v46;
                    *(_WORD *)&buf[32] = 2080;
                    *(_QWORD *)&buf[34] = v52;
                    _os_log_debug_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEBUG, "dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x2Au);
                  }
                  *__error() = v73;
                }
                v55 = v317;
                if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
                {
                  v75 = *__error();
                  v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("dir %s, fullfilename %s, realDir %s, expectedRealDir %s"), v43, v317, v46, v52);
                  if (!v76)
                  {
                    v139 = sub_100030318();
                    if (os_log_type_enabled(v139, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 136315906;
                      *(_QWORD *)&buf[4] = v43;
                      *(_WORD *)&buf[12] = 2080;
                      *(_QWORD *)&buf[14] = v317;
                      *(_WORD *)&buf[22] = 2080;
                      *(_QWORD *)&buf[24] = v46;
                      *(_WORD *)&buf[32] = 2080;
                      *(_QWORD *)&buf[34] = v52;
                      _os_log_fault_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_FAULT, "Unable to format: dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x2Au);
                    }
                    if (qword_1000EBD40)
                      v140 = (FILE *)qword_1000EBD40;
                    else
                      v140 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v140);
                    goto LABEL_116;
                  }
                  v58 = v76;
                  v316 = v75;
                  goto LABEL_86;
                }
              }
              else
              {
                if (byte_1000EBD38)
                {
                  v53 = *__error();
                  v54 = sub_100030318();
                  if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
                  {
                    v156 = sub_1000302B4(a3);
                    *(_DWORD *)buf = 136447490;
                    *(_QWORD *)&buf[4] = v156;
                    *(_WORD *)&buf[12] = 1024;
                    *(_DWORD *)&buf[14] = a3;
                    *(_WORD *)&buf[18] = 2080;
                    *(_QWORD *)&buf[20] = v43;
                    *(_WORD *)&buf[28] = 2080;
                    *(_QWORD *)&buf[30] = v317;
                    *(_WORD *)&buf[38] = 2080;
                    *(_QWORD *)&buf[40] = v46;
                    *(_WORD *)&buf[48] = 2080;
                    *(_QWORD *)&buf[50] = v52;
                    _os_log_debug_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x3Au);
                  }
                  *__error() = v53;
                }
                v55 = v317;
                if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
                {
                  v316 = *__error();
                  v56 = sub_1000302B4(a3);
                  v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s"), v56, a3, v43, v317, v46, v52);
                  if (!v57)
                  {
                    v89 = sub_100030318();
                    if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
                    {
                      v165 = sub_1000302B4(a3);
                      *(_DWORD *)buf = 136316418;
                      *(_QWORD *)&buf[4] = v165;
                      *(_WORD *)&buf[12] = 1024;
                      *(_DWORD *)&buf[14] = a3;
                      *(_WORD *)&buf[18] = 2080;
                      *(_QWORD *)&buf[20] = v43;
                      *(_WORD *)&buf[28] = 2080;
                      *(_QWORD *)&buf[30] = v317;
                      *(_WORD *)&buf[38] = 2080;
                      *(_QWORD *)&buf[40] = v46;
                      *(_WORD *)&buf[48] = 2080;
                      *(_QWORD *)&buf[50] = v52;
                      _os_log_fault_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: dir %s, fullfilename %s, realDir %s, expectedRealDir %s", buf, 0x3Au);
                    }
                    if (qword_1000EBD40)
                      v90 = (FILE *)qword_1000EBD40;
                    else
                      v90 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v90);
                    goto LABEL_115;
                  }
                  v58 = v57;
LABEL_86:
                  v315 = v42;
                  v77 = CFStringGetCStringPtr(v58, 0x8000100u);
                  if (v77)
                  {
                    v78 = (char *)v77;
                    v79 = 0;
                  }
                  else
                  {
                    v78 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1D152337uLL);
                    CFStringGetCString(v58, v78, 1024, 0x8000100u);
                    v79 = v78;
                  }
                  if (qword_1000EBD40)
                    v91 = (FILE *)qword_1000EBD40;
                  else
                    v91 = __stderrp;
                  fprintf(v91, "%s\n", v78);
                  if (v79)
                    free(v79);
                  CFRelease(v58);
                  v42 = v315;
LABEL_115:
                  v75 = v316;
LABEL_116:
                  *__error() = v75;
                  v55 = v317;
                }
              }
              v92 = strcmp(v52, v46);
              free(v43);
              free(v52);
              if (!v92)
              {
                v93 = snprintf(v42, 0x400uLL, "%s/%s", v46, v55);
                free(v55);
                free(v46);
                if (v93 < 0x400)
                {
                  v331 = 0;
                  if (a6)
                    v94 = asprintf(&v331, "Requested by %s [%d] - %s");
                  else
                    v94 = asprintf(&v331, "Requested by %s [%d]");
                  if ((a5 & 0x80) == 0)
                  {
                    v95 = v42;
                    Current = SAMachAbsTimeSecondsGetCurrent(v94);
                    if ((a5 & 0x20) != 0)
                      v97 = 2;
                    else
                      v97 = 3;
                    if ((a5 & 0x40) != 0)
                      v98 = 384;
                    else
                      v98 = 385;
                    if (a7)
                      v99 = strdup(a7);
                    else
                      v99 = 0;
                    v105 = a9 + Current;
                    if (a11)
                      v106 = qos_class_self();
                    else
                      v106 = QOS_CLASS_BACKGROUND;
                    global_queue = dispatch_get_global_queue(v106, 0);
                    v321[0] = _NSConcreteStackBlock;
                    v321[1] = 3221225472;
                    v321[2] = sub_100040680;
                    v321[3] = &unk_1000DCF90;
                    v322 = a3;
                    v321[6] = v99;
                    v321[7] = a5;
                    v321[8] = v42;
                    v321[4] = a11;
                    v321[5] = v331;
                    v323 = a1;
                    v324 = a2;
                    if (sub_10006CB58(a3, (v40 * 1000000.0), 0, v97, 0, v98, (uint64_t)global_queue, (uint64_t)v321, v105))
                    {
                      return;
                    }
                    if ((a3 & 0x80000000) != 0)
                    {
                      if (byte_1000EBD38)
                      {
                        v141 = *__error();
                        v142 = sub_100030318();
                        if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
                          sub_100084A3C();
                        *__error() = v141;
                      }
                      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                        goto LABEL_264;
                      v111 = *__error();
                      v143 = *__error();
                      v144 = __error();
                      v145 = strerror(*v144);
                      v146 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: unable to sample process: %d (%s)"), v143, v145);
                      if (!v146)
                      {
                        v161 = sub_100030318();
                        if (os_log_type_enabled(v161, OS_LOG_TYPE_FAULT))
                          sub_1000849CC();
                        if (qword_1000EBD40)
                          v162 = (FILE *)qword_1000EBD40;
                        else
                          v162 = __stderrp;
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v162);
                        goto LABEL_263;
                      }
                      v147 = v146;
                      v148 = CFStringGetCStringPtr(v146, 0x8000100u);
                      if (v148)
                      {
                        v149 = (char *)v148;
                        v150 = 0;
                      }
                      else
                      {
                        v149 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAAD5D4CEuLL);
                        CFStringGetCString(v147, v149, 1024, 0x8000100u);
                        v150 = v149;
                      }
                      if (qword_1000EBD40)
                        v163 = (FILE *)qword_1000EBD40;
                      else
                        v163 = __stderrp;
                      fprintf(v163, "%s\n", v149);
                      if (v150)
                        free(v150);
                      v160 = v147;
                    }
                    else
                    {
                      if (byte_1000EBD38)
                      {
                        v109 = *__error();
                        v110 = sub_100030318();
                        if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
                          sub_10008493C();
                        *__error() = v109;
                      }
                      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                        goto LABEL_264;
                      v111 = *__error();
                      v112 = sub_1000302B4(a3);
                      v113 = *__error();
                      v114 = __error();
                      v115 = strerror(*v114);
                      v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: unable to sample process: %d (%s)"), v112, a3, v113, v115);
                      if (!v116)
                      {
                        v157 = sub_100030318();
                        if (os_log_type_enabled(v157, OS_LOG_TYPE_FAULT))
                          sub_1000848AC();
                        if (qword_1000EBD40)
                          v158 = (FILE *)qword_1000EBD40;
                        else
                          v158 = __stderrp;
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v158);
                        v42 = v95;
                        goto LABEL_263;
                      }
                      v117 = v116;
                      v118 = CFStringGetCStringPtr(v116, 0x8000100u);
                      if (v118)
                      {
                        v119 = (char *)v118;
                        v120 = 0;
                      }
                      else
                      {
                        v119 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAAD5D4CEuLL);
                        CFStringGetCString(v117, v119, 1024, 0x8000100u);
                        v120 = v119;
                      }
                      v42 = v95;
                      if (qword_1000EBD40)
                        v159 = (FILE *)qword_1000EBD40;
                      else
                        v159 = __stderrp;
                      fprintf(v159, "%s\n", v119);
                      if (v120)
                        free(v120);
                      v160 = v117;
                    }
                    CFRelease(v160);
LABEL_263:
                    *__error() = v111;
LABEL_264:
                    if (a11)
                    {
                      v164 = __error();
                      (*(void (**)(uint64_t, _QWORD, _QWORD))(a11 + 16))(a11, *v164, 0);
                    }
                    free(v42);
                    if (v331)
                      free(v331);
                    if (v99)
                      free(v99);
                    return;
                  }
                  v100 = v331;
                  v325[0] = _NSConcreteStackBlock;
                  v325[1] = 3221225472;
                  v326 = sub_100040620;
                  v327 = &unk_1000DCF68;
                  v329 = v42;
                  v330 = v331;
                  v328 = a11;
                  v101 = 2;
                  v102 = (char **)malloc_type_calloc(2uLL, 8uLL, 0x10040436913F5uLL);
                  v103 = v102;
                  v335 = 0;
                  *v102 = "/usr/sbin/spindump";
                  v102[1] = "-noIPC";
                  if ((a3 & 0x80000000) != 0)
                  {
                    v104 = 0;
                  }
                  else
                  {
                    v103 = (char **)malloc_type_realloc(v102, 0x18uLL, 0x10040436913F5uLL);
                    asprintf(v103 + 2, "%d", a3);
                    v101 = 3;
                    v104 = 4;
                  }
                  v107 = v42;
                  if (a4)
                  {
                    v103 = (char **)malloc_type_realloc(v103, 8 * v101 + 16, 0x10040436913F5uLL);
                    v103[v101] = "-targetThreadID";
                    asprintf(&v103[v101 + 1], "%d", a3);
                    v104 |= 2 << v101;
                    v101 += 2;
                  }
                  v121 = v101 + 2;
                  v122 = (char **)malloc_type_realloc(v103, 8 * v121, 0x10040436913F5uLL);
                  if (round(a9) <= 0.0)
                    v123 = 1.0;
                  else
                    v123 = a9;
                  asprintf(&v122[v101], "%.0f", v123);
                  v124 = v40 * 1000000.0;
                  if (round(v40 * 1000000.0) <= 0.0)
                    v124 = 1.0;
                  asprintf(&v122[v101 + 1], "%.0fu", v124);
                  LOBYTE(v335) = (3 << v101) | v104;
                  if ((a5 & 1) != 0)
                  {
                    if ((a5 & 2) != 0)
                    {
LABEL_158:
                      v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                      v122[v121] = "-noText";
                      LODWORD(v121) = v121 + 1;
                      if ((a5 & 4) != 0)
                        goto LABEL_159;
                      goto LABEL_166;
                    }
                  }
                  else
                  {
                    v122 = (char **)malloc_type_realloc(v122, 8 * (v101 + 3), 0x10040436913F5uLL);
                    v122[v121] = "-timeline";
                    LODWORD(v121) = v101 + 3;
                    if ((a5 & 2) != 0)
                      goto LABEL_158;
                  }
                  if ((a5 & 4) != 0)
                  {
LABEL_159:
                    v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-noBinary";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 8) != 0)
                      goto LABEL_160;
                    goto LABEL_167;
                  }
LABEL_166:
                  if ((a5 & 8) != 0)
                  {
LABEL_160:
                    v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-noSymbolicate";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 0x20) != 0)
                      goto LABEL_161;
                    goto LABEL_168;
                  }
LABEL_167:
                  if ((a5 & 0x20) != 0)
                  {
LABEL_161:
                    v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-onlyTarget";
                    LODWORD(v121) = v121 + 1;
                    if ((a5 & 0x40) != 0)
                      goto LABEL_162;
                    goto LABEL_169;
                  }
LABEL_168:
                  if ((a5 & 0x40) != 0)
                  {
LABEL_162:
                    v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v122[v121] = "-sampleWithoutTarget";
                    LODWORD(v121) = v121 + 1;
                    if (!v100)
                      goto LABEL_171;
                    goto LABEL_170;
                  }
LABEL_169:
                  if (!v100)
                  {
LABEL_171:
                    if (a7)
                    {
                      v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 2), 0x10040436913F5uLL);
                      v122[v121] = "-signature";
                      v122[(v121 + 1)] = (char *)a7;
                      LODWORD(v121) = v121 + 2;
                    }
                    if (v107)
                    {
                      v125 = (v121 + 2);
                      v122 = (char **)malloc_type_realloc(v122, 8 * v125, 0x10040436913F5uLL);
                      v122[v121] = "-o";
                      v122[(v121 + 1)] = v107;
                      LODWORD(v121) = v121 + 2;
                    }
                    else
                    {
                      v125 = v121;
                    }
                    v126 = malloc_type_realloc(v122, 8 * (v121 + 1), 0x10040436913F5uLL);
                    v126[v125] = 0;
                    v127 = (const void **)_NSGetEnviron();
                    v128 = 1;
                    do
                      v129 = v128++ - 1;
                    while (*((_QWORD *)*v127 + v129));
                    v130 = malloc_type_malloc(8 * v128, 0x10040436913F5uLL);
                    memmove(v130, *v127, 8 * v129);
                    *((_QWORD *)v130 + v129) = "XPC_NULL_BOOTSTRAP=1";
                    *((_QWORD *)v130 + v128 - 1) = 0;
                    v334 = 0;
                    LOBYTE(v314) = 0;
                    v131 = SASpawnPlatformBinaryWithSigningIdentifier("/usr/sbin/spindump", "com.apple.spindump", v126, v130, 0, 0, 0, 0, &v334, v314, 0);
                    free(v130);
                    if ((v121 & 0x80000000) == 0)
                    {
                      v132 = 0;
                      do
                      {
                        if (((v336[(v132 >> 3) - 8] >> (v132 & 7)) & 1) != 0)
                          free((void *)v126[v132]);
                        ++v132;
                      }
                      while ((_DWORD)v121 + 1 != v132);
                    }
                    free(v126);
                    if (v131 < 1)
                    {
                      v136 = *__error();
                      v326((uint64_t)v325, v136, 0);
                    }
                    else
                    {
                      v133 = qos_class_self();
                      v134 = dispatch_get_global_queue(v133, 0);
                      v135 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v131, 0x80000000uLL, v134);
                      *(_QWORD *)buf = _NSConcreteStackBlock;
                      *(_QWORD *)&buf[8] = 3221225472;
                      *(_QWORD *)&buf[16] = sub_10004763C;
                      *(_QWORD *)&buf[24] = &unk_1000DD030;
                      *(_DWORD *)&buf[48] = v131;
                      *(_DWORD *)&buf[52] = v334;
                      *(_QWORD *)&buf[32] = v135;
                      *(_QWORD *)&buf[40] = v325;
                      dispatch_source_set_event_handler(v135, buf);
                      dispatch_activate(v135);
                    }
                    return;
                  }
LABEL_170:
                  v122 = (char **)malloc_type_realloc(v122, 8 * (v121 + 2), 0x10040436913F5uLL);
                  v122[v121] = "-reason";
                  v122[(v121 + 1)] = v100;
                  LODWORD(v121) = v121 + 2;
                  goto LABEL_171;
                }
                v249 = *__error();
                v250 = sub_100030318();
                v251 = os_log_type_enabled(v250, OS_LOG_TYPE_FAULT);
                if ((a3 & 0x80000000) != 0)
                {
                  if (v251)
                    sub_100084BE4();
                  *__error() = v249;
                  v252 = v42;
                  if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
                    goto LABEL_489;
                  v253 = *__error();
                  v255 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: filepath %s too large"), v42);
                  if (!v255)
                  {
                    v309 = sub_100030318();
                    if (os_log_type_enabled(v309, OS_LOG_TYPE_FAULT))
                      sub_100084B84();
                    goto LABEL_484;
                  }
                }
                else
                {
                  if (v251)
                    sub_100084B18();
                  *__error() = v249;
                  v252 = v42;
                  if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
                    goto LABEL_489;
                  v253 = *__error();
                  v254 = sub_1000302B4(a3);
                  v255 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: filepath %s too large"), v254, a3, v42);
                  if (!v255)
                  {
                    v256 = sub_100030318();
                    if (os_log_type_enabled(v256, OS_LOG_TYPE_FAULT))
                      sub_100084AAC();
LABEL_484:
                    if (qword_1000EBD40)
                      v310 = (FILE *)qword_1000EBD40;
                    else
                      v310 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v310);
LABEL_488:
                    *__error() = v253;
                    v252 = v42;
LABEL_489:
                    v311 = v252;
                    goto LABEL_500;
                  }
                }
                v270 = v255;
                v271 = CFStringGetCStringPtr(v255, 0x8000100u);
                if (v271)
                {
                  v272 = (char *)v271;
                  v273 = 0;
                }
                else
                {
                  v272 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3DC01EE4uLL);
                  CFStringGetCString(v270, v272, 1024, 0x8000100u);
                  v273 = v272;
                }
                if (qword_1000EBD40)
                  v303 = (FILE *)qword_1000EBD40;
                else
                  v303 = __stderrp;
                fprintf(v303, "%s\n", v272);
                if (v273)
                  free(v273);
                CFRelease(v270);
                goto LABEL_488;
              }
              v238 = *__error();
              v239 = sub_100030318();
              v240 = os_log_type_enabled(v239, OS_LOG_TYPE_FAULT);
              if ((a3 & 0x80000000) != 0)
              {
                if (v240)
                  sub_100084D7C();
                *__error() = v238;
                v241 = v42;
                if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
                  goto LABEL_499;
                v242 = *__error();
                v265 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter"), v42);
                if (v265)
                {
                  v266 = v265;
                  v267 = CFStringGetCStringPtr(v265, 0x8000100u);
                  if (v267)
                  {
                    v268 = (char *)v267;
                    v269 = 0;
                  }
                  else
                  {
                    v268 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1F180941uLL);
                    CFStringGetCString(v266, v268, 1024, 0x8000100u);
                    v269 = v268;
                  }
                  if (qword_1000EBD40)
                    v312 = (FILE *)qword_1000EBD40;
                  else
                    v312 = __stderrp;
                  fprintf(v312, "%s\n", v268);
                  if (v269)
                    free(v269);
                  v306 = v266;
                  goto LABEL_497;
                }
                v307 = sub_100030318();
                if (os_log_type_enabled(v307, OS_LOG_TYPE_FAULT))
                  sub_100084D1C();
              }
              else
              {
                if (v240)
                  sub_100084CB0();
                *__error() = v238;
                v241 = v42;
                if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
                  goto LABEL_499;
                v242 = *__error();
                v243 = sub_1000302B4(a3);
                v244 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter"), v243, a3, v42);
                if (v244)
                {
                  v245 = v244;
                  v246 = CFStringGetCStringPtr(v244, 0x8000100u);
                  if (v246)
                  {
                    v247 = (char *)v246;
                    v248 = 0;
                  }
                  else
                  {
                    v247 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1F180941uLL);
                    CFStringGetCString(v245, v247, 1024, 0x8000100u);
                    v248 = v247;
                  }
                  if (qword_1000EBD40)
                    v305 = (FILE *)qword_1000EBD40;
                  else
                    v305 = __stderrp;
                  fprintf(v305, "%s\n", v247);
                  if (v248)
                    free(v248);
                  v306 = v245;
LABEL_497:
                  CFRelease(v306);
LABEL_498:
                  *__error() = v242;
                  v241 = v42;
LABEL_499:
                  free(v46);
                  free(v317);
                  v311 = v241;
LABEL_500:
                  free(v311);
                  if (a11)
                    (*(void (**)(uint64_t, uint64_t, _QWORD))(a11 + 16))(a11, 22, 0);
                  return;
                }
                v302 = sub_100030318();
                if (os_log_type_enabled(v302, OS_LOG_TYPE_FAULT))
                  sub_100084C44();
              }
              if (qword_1000EBD40)
                v308 = (FILE *)qword_1000EBD40;
              else
                v308 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v308);
              goto LABEL_498;
            }
            if ((a3 & 0x80000000) != 0)
            {
              if (byte_1000EBD38)
              {
                v218 = *__error();
                v219 = sub_100030318();
                if (os_log_type_enabled(v219, OS_LOG_TYPE_ERROR))
                  sub_10008483C(v219, v220, v221, v222, v223, v224, v225, v226);
                *__error() = v218;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v227 = *__error();
                v228 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)"), "0 != strcmp(\"/\", expectedRealDir)");
                if (v228)
                {
                  v287 = v228;
                  v288 = CFStringGetCStringPtr(v228, 0x8000100u);
                  if (v288)
                  {
                    v289 = (char *)v288;
                    v290 = 0;
                  }
                  else
                  {
                    v289 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x824AC0ADuLL);
                    CFStringGetCString(v287, v289, 1024, 0x8000100u);
                    v290 = v289;
                  }
                  if (qword_1000EBD40)
                    v301 = (FILE *)qword_1000EBD40;
                  else
                    v301 = __stderrp;
                  fprintf(v301, "%s\n", v289);
                  if (v290)
                    free(v290);
                  CFRelease(v287);
                }
                else
                {
                  v229 = sub_100030318();
                  if (os_log_type_enabled(v229, OS_LOG_TYPE_FAULT))
                    sub_1000847CC(v229, v230, v231, v232, v233, v234, v235, v236);
                  if (qword_1000EBD40)
                    v237 = (FILE *)qword_1000EBD40;
                  else
                    v237 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v237);
                }
                *__error() = v227;
              }
              v313 = "0 != strcmp(\"/\", expectedRealDir)";
              v297 = "%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)";
            }
            else
            {
              if (byte_1000EBD38)
              {
                v191 = *__error();
                v192 = sub_100030318();
                if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
                  sub_100084754();
                *__error() = v191;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v193 = *__error();
                v194 = sub_1000302B4(a3);
                v195 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)"), v194, a3, "0 != strcmp(\"/\", expectedRealDir)");
                if (v195)
                {
                  v283 = v195;
                  v284 = CFStringGetCStringPtr(v195, 0x8000100u);
                  if (v284)
                  {
                    v285 = (char *)v284;
                    v286 = 0;
                  }
                  else
                  {
                    v285 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x824AC0ADuLL);
                    CFStringGetCString(v283, v285, 1024, 0x8000100u);
                    v286 = v285;
                  }
                  if (qword_1000EBD40)
                    v300 = (FILE *)qword_1000EBD40;
                  else
                    v300 = __stderrp;
                  fprintf(v300, "%s\n", v285);
                  if (v286)
                    free(v286);
                  CFRelease(v283);
                }
                else
                {
                  v196 = sub_100030318();
                  if (os_log_type_enabled(v196, OS_LOG_TYPE_FAULT))
                    sub_1000846DC();
                  if (qword_1000EBD40)
                    v197 = (FILE *)qword_1000EBD40;
                  else
                    v197 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v197);
                }
                *__error() = v193;
              }
              LOBYTE(v313) = sub_1000302B4(a3);
              v297 = "%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)";
            }
            v299 = 1515;
          }
          else
          {
            if ((a3 & 0x80000000) != 0)
            {
              if (byte_1000EBD38)
              {
                v198 = *__error();
                v199 = sub_100030318();
                if (os_log_type_enabled(v199, OS_LOG_TYPE_ERROR))
                  sub_10008466C(v199, v200, v201, v202, v203, v204, v205, v206);
                *__error() = v198;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v207 = *__error();
                v208 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)"), "expectedRealDir");
                if (v208)
                {
                  v279 = v208;
                  v280 = CFStringGetCStringPtr(v208, 0x8000100u);
                  if (v280)
                  {
                    v281 = (char *)v280;
                    v282 = 0;
                  }
                  else
                  {
                    v281 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x24AFD768uLL);
                    CFStringGetCString(v279, v281, 1024, 0x8000100u);
                    v282 = v281;
                  }
                  if (qword_1000EBD40)
                    v298 = (FILE *)qword_1000EBD40;
                  else
                    v298 = __stderrp;
                  fprintf(v298, "%s\n", v281);
                  if (v282)
                    free(v282);
                  CFRelease(v279);
                }
                else
                {
                  v209 = sub_100030318();
                  if (os_log_type_enabled(v209, OS_LOG_TYPE_FAULT))
                    sub_1000845FC(v209, v210, v211, v212, v213, v214, v215, v216);
                  if (qword_1000EBD40)
                    v217 = (FILE *)qword_1000EBD40;
                  else
                    v217 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v217);
                }
                *__error() = v207;
              }
              v313 = "expectedRealDir";
              v297 = "%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)";
            }
            else
            {
              if (byte_1000EBD38)
              {
                v184 = *__error();
                v185 = sub_100030318();
                if (os_log_type_enabled(v185, OS_LOG_TYPE_ERROR))
                  sub_100084584();
                *__error() = v184;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v186 = *__error();
                v187 = sub_1000302B4(a3);
                v188 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)"), v187, a3, "expectedRealDir");
                if (v188)
                {
                  v275 = v188;
                  v276 = CFStringGetCStringPtr(v188, 0x8000100u);
                  if (v276)
                  {
                    v277 = (char *)v276;
                    v278 = 0;
                  }
                  else
                  {
                    v277 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x24AFD768uLL);
                    CFStringGetCString(v275, v277, 1024, 0x8000100u);
                    v278 = v277;
                  }
                  if (qword_1000EBD40)
                    v296 = (FILE *)qword_1000EBD40;
                  else
                    v296 = __stderrp;
                  fprintf(v296, "%s\n", v277);
                  if (v278)
                    free(v278);
                  CFRelease(v275);
                }
                else
                {
                  v189 = sub_100030318();
                  if (os_log_type_enabled(v189, OS_LOG_TYPE_FAULT))
                    sub_10008450C();
                  if (qword_1000EBD40)
                    v190 = (FILE *)qword_1000EBD40;
                  else
                    v190 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v190);
                }
                *__error() = v186;
              }
              LOBYTE(v313) = sub_1000302B4(a3);
              v297 = "%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)";
            }
            v299 = 1514;
          }
          sub_1000301F0("DoGenerateSpindump", "monitor.m", v299, v297, v48, v49, v50, v51, (char)v313);
          abort();
        }
        v174 = *__error();
        v175 = sub_100030318();
        v176 = os_log_type_enabled(v175, OS_LOG_TYPE_FAULT);
        if ((a3 & 0x80000000) != 0)
        {
          if (v176)
            sub_1000844AC();
          *__error() = v174;
          if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
            goto LABEL_230;
          v177 = v44;
          v178 = *__error();
          v180 = v42;
          v181 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("NULL realDir (dir %s from %s)"), v43, v42);
          if (!v181)
          {
            v294 = sub_100030318();
            if (os_log_type_enabled(v294, OS_LOG_TYPE_FAULT))
              sub_10008444C();
            goto LABEL_416;
          }
        }
        else
        {
          if (v176)
          {
            v304 = sub_1000302B4(a3);
            *(_DWORD *)buf = 136446978;
            *(_QWORD *)&buf[4] = v304;
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = a3;
            *(_WORD *)&buf[18] = 2080;
            *(_QWORD *)&buf[20] = v43;
            *(_WORD *)&buf[28] = 2080;
            *(_QWORD *)&buf[30] = v42;
            _os_log_fault_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_FAULT, "%{public}s [%d]: NULL realDir (dir %s from %s)", buf, 0x26u);
          }
          *__error() = v174;
          if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
            goto LABEL_230;
          v177 = v44;
          v178 = *__error();
          v179 = sub_1000302B4(a3);
          v180 = v42;
          v181 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: NULL realDir (dir %s from %s)"), v179, a3, v43, v42);
          if (!v181)
          {
            v182 = sub_100030318();
            if (os_log_type_enabled(v182, OS_LOG_TYPE_FAULT))
            {
              v183 = sub_1000302B4(a3);
              *(_DWORD *)buf = 136315906;
              *(_QWORD *)&buf[4] = v183;
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = a3;
              *(_WORD *)&buf[18] = 2080;
              *(_QWORD *)&buf[20] = v43;
              *(_WORD *)&buf[28] = 2080;
              *(_QWORD *)&buf[30] = v42;
              _os_log_fault_impl((void *)&_mh_execute_header, v182, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: NULL realDir (dir %s from %s)", buf, 0x26u);
            }
LABEL_416:
            if (qword_1000EBD40)
              v295 = (FILE *)qword_1000EBD40;
            else
              v295 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v295);
LABEL_420:
            *__error() = v178;
            v42 = v180;
            v44 = v177;
            goto LABEL_230;
          }
        }
        v261 = v181;
        v262 = CFStringGetCStringPtr(v181, 0x8000100u);
        if (v262)
        {
          v263 = (char *)v262;
          v264 = 0;
        }
        else
        {
          v263 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA84743B1uLL);
          CFStringGetCString(v261, v263, 1024, 0x8000100u);
          v264 = v263;
        }
        if (qword_1000EBD40)
          v291 = (FILE *)qword_1000EBD40;
        else
          v291 = __stderrp;
        fprintf(v291, "%s\n", v263);
        if (v264)
          free(v264);
        CFRelease(v261);
        goto LABEL_420;
      }
      v66 = *__error();
      v67 = sub_100030318();
      v68 = os_log_type_enabled(v67, OS_LOG_TYPE_FAULT);
      if ((a3 & 0x80000000) != 0)
      {
        if (v68)
          sub_1000843EC();
        *__error() = v66;
        if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
          goto LABEL_230;
        v69 = *__error();
        v71 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to get basename of %s"), v42);
        if (!v71)
        {
          v154 = sub_100030318();
          if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT))
            sub_10008438C();
          goto LABEL_225;
        }
      }
      else
      {
        if (v68)
          sub_100084320();
        *__error() = v66;
        if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
          goto LABEL_230;
        v69 = *__error();
        v70 = sub_1000302B4(a3);
        v71 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to get basename of %s"), v70, a3, v42);
        if (!v71)
        {
          v72 = sub_100030318();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
            sub_1000842B4();
LABEL_225:
          if (qword_1000EBD40)
            v155 = (FILE *)qword_1000EBD40;
          else
            v155 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v155);
LABEL_229:
          *__error() = v69;
LABEL_230:
          free(v42);
          free(v43);
          v153 = v44;
          goto LABEL_231;
        }
      }
      v84 = v71;
      v85 = v44;
      v86 = CFStringGetCStringPtr(v71, 0x8000100u);
      if (v86)
      {
        v87 = (char *)v86;
        v88 = 0;
      }
      else
      {
        v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4883C9F9uLL);
        CFStringGetCString(v84, v87, 1024, 0x8000100u);
        v88 = v87;
      }
      if (qword_1000EBD40)
        v138 = (FILE *)qword_1000EBD40;
      else
        v138 = __stderrp;
      fprintf(v138, "%s\n", v87);
      if (v88)
        free(v88);
      CFRelease(v84);
      v44 = v85;
      goto LABEL_229;
    }
    v59 = *__error();
    v60 = sub_100030318();
    v61 = os_log_type_enabled(v60, OS_LOG_TYPE_FAULT);
    if ((a3 & 0x80000000) != 0)
    {
      if (v61)
        sub_100084254();
      *__error() = v59;
      if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
        goto LABEL_222;
      v62 = *__error();
      v64 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to get dirname of %s"), v42);
      if (!v64)
      {
        v151 = sub_100030318();
        if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT))
          sub_1000841F4();
        goto LABEL_217;
      }
    }
    else
    {
      if (v61)
        sub_100084188();
      *__error() = v59;
      if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
        goto LABEL_222;
      v62 = *__error();
      v63 = sub_1000302B4(a3);
      v64 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to get dirname of %s"), v63, a3, v42);
      if (!v64)
      {
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
          sub_10008411C();
LABEL_217:
        if (qword_1000EBD40)
          v152 = (FILE *)qword_1000EBD40;
        else
          v152 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v152);
LABEL_221:
        *__error() = v62;
LABEL_222:
        free(v42);
        v153 = v43;
        goto LABEL_231;
      }
    }
    v80 = v64;
    v81 = CFStringGetCStringPtr(v64, 0x8000100u);
    if (v81)
    {
      v82 = (char *)v81;
      v83 = 0;
    }
    else
    {
      v82 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8CA1E547uLL);
      CFStringGetCString(v80, v82, 1024, 0x8000100u);
      v83 = v82;
    }
    if (qword_1000EBD40)
      v137 = (FILE *)qword_1000EBD40;
    else
      v137 = __stderrp;
    fprintf(v137, "%s\n", v82);
    if (v83)
      free(v83);
    CFRelease(v80);
    goto LABEL_221;
  }
  v166 = *__error();
  v167 = sub_100030318();
  v168 = os_log_type_enabled(v167, OS_LOG_TYPE_FAULT);
  if ((a3 & 0x80000000) != 0)
  {
    if (v168)
      sub_100084BE4();
    *__error() = v166;
    if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
      goto LABEL_413;
    v169 = *__error();
    v171 = v42;
    v172 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: filepath %s too large"), v42);
    if (!v172)
    {
      v292 = sub_100030318();
      if (os_log_type_enabled(v292, OS_LOG_TYPE_FAULT))
        sub_100084B84();
      goto LABEL_408;
    }
LABEL_361:
    v257 = v172;
    v258 = CFStringGetCStringPtr(v172, 0x8000100u);
    if (v258)
    {
      v259 = (char *)v258;
      v260 = 0;
    }
    else
    {
      v259 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDC0CD11BuLL);
      CFStringGetCString(v257, v259, 1024, 0x8000100u);
      v260 = v259;
    }
    if (qword_1000EBD40)
      v274 = (FILE *)qword_1000EBD40;
    else
      v274 = __stderrp;
    fprintf(v274, "%s\n", v259);
    if (v260)
      free(v260);
    CFRelease(v257);
    goto LABEL_412;
  }
  if (v168)
    sub_100084B18();
  *__error() = v166;
  if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
    goto LABEL_413;
  v169 = *__error();
  v170 = sub_1000302B4(a3);
  v171 = v42;
  v172 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: filepath %s too large"), v170, a3, v42);
  if (v172)
    goto LABEL_361;
  v173 = sub_100030318();
  if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT))
    sub_100084AAC();
LABEL_408:
  if (qword_1000EBD40)
    v293 = (FILE *)qword_1000EBD40;
  else
    v293 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v293);
LABEL_412:
  v42 = v171;
  *__error() = v169;
LABEL_413:
  v153 = v42;
LABEL_231:
  free(v153);
  if (a11)
    (*(void (**)(uint64_t, uint64_t, _QWORD))(a11 + 16))(a11, 22, 0);
}

uint64_t sub_100040620(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  free(*(void **)(a1 + 40));
  free(*(void **)(a1 + 48));
  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(result + 16))(result, a2, a3);
  return result;
}

void sub_100040680(uint64_t a1, void *a2, int a3)
{
  int *v6;
  int v7;
  NSObject *v8;
  BOOL v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  const char *v13;
  const __CFString *v14;
  const __CFString *v15;
  const char *CStringPtr;
  char *v17;
  char *v18;
  int v19;
  NSObject *v20;
  BOOL v21;
  const char *v22;
  const __CFString *v23;
  const char *v24;
  char *v25;
  char *v26;
  NSObject *v27;
  FILE *v28;
  FILE *v29;
  NSObject *v30;
  FILE *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t *v34;
  const char *v35;
  uid_t v36;
  int v37;
  FILE *v38;
  FILE *v39;
  int v40;
  NSObject *v41;
  _DWORD *v42;
  int v43;
  _DWORD *v44;
  int v45;
  uint64_t v46;
  int v47;
  _DWORD *v48;
  uint64_t v49;
  _DWORD *v50;
  const __CFString *v51;
  NSObject *v52;
  _DWORD *v53;
  int v54;
  _DWORD *v55;
  int v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  int v60;
  _DWORD *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int *v65;
  char *v66;
  const __CFString *v67;
  const __CFString *v68;
  const char *v69;
  malloc_type_id_t v70;
  int v71;
  NSObject *v72;
  _DWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  int *v77;
  char *v78;
  const __CFString *v79;
  char *v80;
  char *v81;
  int v82;
  NSObject *v83;
  _DWORD *v84;
  int v85;
  _DWORD *v86;
  _DWORD *v87;
  const __CFString *v88;
  const char *v89;
  char *v90;
  char *v91;
  int v92;
  NSObject *v93;
  uint64_t v94;
  uint64_t v95;
  int *v96;
  char *v97;
  const __CFString *v98;
  const __CFString *v99;
  const char *v100;
  malloc_type_id_t v101;
  int v102;
  NSObject *v103;
  uint64_t v104;
  uint64_t v105;
  int *v106;
  char *v107;
  const __CFString *v108;
  char *v109;
  char *v110;
  FILE *v111;
  NSObject *v112;
  NSObject *v113;
  NSObject *v114;
  FILE *v115;
  uint64_t v116;
  NSObject *v117;
  FILE *v118;
  const __CFString *v119;
  NSObject *v120;
  FILE *v121;
  FILE *v122;
  uint64_t v123;
  uint64_t v124;
  void *v125;
  void *v126;
  uint8_t buf[4];
  _DWORD *v128;
  __int16 v129;
  int v130;
  __int16 v131;
  _DWORD *v132;
  __int16 v133;
  int v134;
  __int16 v135;
  uint64_t v136;

  v6 = (int *)(a1 + 72);
  if ((*(_DWORD *)(a1 + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v7 = *__error();
      v8 = sub_100030318();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        sub_1000852B4(v6);
      *__error() = v7;
    }
    if (byte_1000EBD39)
      v9 = dword_1000EB4E8 <= 0;
    else
      v9 = 0;
    if (!v9)
      goto LABEL_52;
    v10 = *__error();
    v11 = sub_1000302B4(*v6);
    v12 = *v6;
    v13 = sub_10006E888(a3);
    v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: done monitoring due to %s"), v11, v12, v13);
    if (v14)
    {
      v15 = v14;
      CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
      if (CStringPtr)
      {
        v17 = (char *)CStringPtr;
        v18 = 0;
      }
      else
      {
        v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DDC9E48uLL);
        CFStringGetCString(v15, v17, 1024, 0x8000100u);
        v18 = v17;
      }
      if (qword_1000EBD40)
        v29 = (FILE *)qword_1000EBD40;
      else
        v29 = __stderrp;
      fprintf(v29, "%s\n", v17);
      if (v18)
        free(v18);
LABEL_50:
      CFRelease(v15);
      goto LABEL_51;
    }
    v27 = sub_100030318();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      sub_10008521C(v6);
    if (qword_1000EBD40)
      v28 = (FILE *)qword_1000EBD40;
    else
      v28 = __stderrp;
    goto LABEL_31;
  }
  if (byte_1000EBD38)
  {
    v19 = *__error();
    v20 = sub_100030318();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      sub_1000853B4(a3, v20);
    *__error() = v19;
  }
  if (byte_1000EBD39)
    v21 = dword_1000EB4E8 <= 0;
  else
    v21 = 0;
  if (v21)
  {
    v10 = *__error();
    v22 = sub_10006E888(a3);
    v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: done monitoring due to %s"), v22);
    if (v23)
    {
      v15 = v23;
      v24 = CFStringGetCStringPtr(v23, 0x8000100u);
      if (v24)
      {
        v25 = (char *)v24;
        v26 = 0;
      }
      else
      {
        v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DDC9E48uLL);
        CFStringGetCString(v15, v25, 1024, 0x8000100u);
        v26 = v25;
      }
      if (qword_1000EBD40)
        v31 = (FILE *)qword_1000EBD40;
      else
        v31 = __stderrp;
      fprintf(v31, "%s\n", v25);
      if (v26)
        free(v26);
      goto LABEL_50;
    }
    v30 = sub_100030318();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
      sub_10008533C(a3, v30);
    if (qword_1000EBD40)
      v28 = (FILE *)qword_1000EBD40;
    else
      v28 = __stderrp;
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v28);
LABEL_51:
    *__error() = v10;
  }
LABEL_52:
  if (*(_QWORD *)(a1 + 40))
    objc_msgSend(a2, "setReason:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
  if (*(_QWORD *)(a1 + 48))
    objc_msgSend(a2, "setSignature:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:"));
  v32 = *(_QWORD *)(a1 + 56);
  if ((v32 & 1) != 0)
  {
    objc_msgSend(objc_msgSend(a2, "printOptions"), "setPrintHeavyStacks:", 1);
    v32 = *(_QWORD *)(a1 + 56);
  }
  objc_msgSend(a2, "setIncludeTextualFormatInReport:", (v32 & 2) == 0);
  objc_msgSend(a2, "setIncludeBinaryFormatInReport:", (*(_QWORD *)(a1 + 56) & 4) == 0);
  v33 = *(_QWORD *)(a1 + 56);
  if ((v33 & 0x10) != 0)
  {
    objc_msgSend(a2, "setShouldSymbolicate:", 1);
    objc_msgSend(a2, "setShouldUseBulkSymbolication:", 0);
    v33 = *(_QWORD *)(a1 + 56);
  }
  if ((v33 & 8) != 0)
  {
    objc_msgSend(a2, "setShouldSymbolicate:", 0);
    objc_msgSend(a2, "setShouldUseBulkSymbolication:", 0);
  }
  v34 = (uint64_t *)(a1 + 64);
  v35 = *(const char **)(a1 + 64);
  v36 = geteuid();
  v37 = sub_10002D718(v35, 536872449, v36, 0x1A4u);
  if ((v37 & 0x80000000) == 0)
  {
    v38 = fdopen(v37, "w");
    if (v38)
    {
      v39 = v38;
      objc_msgSend(a2, "saveReportToStream:", v38);
      fclose(v39);
      if (*v6 < 0)
      {
        if (byte_1000EBD38)
        {
          v82 = *__error();
          v83 = sub_100030318();
          if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
          {
            v84 = sub_1000302B4(*(_DWORD *)(a1 + 76));
            v85 = *(_DWORD *)(a1 + 76);
            v86 = *(_DWORD **)(a1 + 64);
            *(_DWORD *)buf = 136446722;
            v128 = v84;
            v129 = 1024;
            v130 = v85;
            v131 = 2080;
            v132 = v86;
            _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "generate spindump: saved report (requested by %{public}s [%d]) to %s", buf, 0x1Cu);
          }
          *__error() = v82;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
          goto LABEL_139;
        v47 = *__error();
        v87 = sub_1000302B4(*(_DWORD *)(a1 + 76));
        v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: saved report (requested by %s [%d]) to %s"), v87, *(unsigned int *)(a1 + 76), *(_QWORD *)(a1 + 64));
        if (!v51)
        {
          v114 = sub_100030318();
          if (os_log_type_enabled(v114, OS_LOG_TYPE_FAULT))
            sub_10008518C();
          goto LABEL_134;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v40 = *__error();
          v41 = sub_100030318();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            v42 = sub_1000302B4(*(_DWORD *)(a1 + 72));
            v43 = *(_DWORD *)(a1 + 72);
            v44 = sub_1000302B4(*(_DWORD *)(a1 + 76));
            v45 = *(_DWORD *)(a1 + 76);
            v46 = *(_QWORD *)(a1 + 64);
            *(_DWORD *)buf = 136447234;
            v128 = v42;
            v129 = 1024;
            v130 = v43;
            v131 = 2082;
            v132 = v44;
            v133 = 1024;
            v134 = v45;
            v135 = 2080;
            v136 = v46;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: generate spindump: saved report (requested by %{public}s [%d]) to %s", buf, 0x2Cu);
          }
          *__error() = v40;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
          goto LABEL_139;
        v47 = *__error();
        v48 = sub_1000302B4(*(_DWORD *)(a1 + 72));
        v49 = *(unsigned int *)(a1 + 72);
        v50 = sub_1000302B4(*(_DWORD *)(a1 + 76));
        v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: saved report (requested by %s [%d]) to %s"), v48, v49, v50, *(unsigned int *)(a1 + 76), *(_QWORD *)(a1 + 64));
        if (!v51)
        {
          v52 = sub_100030318();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT))
          {
            v53 = sub_1000302B4(*(_DWORD *)(a1 + 72));
            v54 = *(_DWORD *)(a1 + 72);
            v55 = sub_1000302B4(*(_DWORD *)(a1 + 76));
            v56 = *(_DWORD *)(a1 + 76);
            v57 = *(_QWORD *)(a1 + 64);
            *(_DWORD *)buf = 136316162;
            v128 = v53;
            v129 = 1024;
            v130 = v54;
            v131 = 2080;
            v132 = v55;
            v133 = 1024;
            v134 = v56;
            v135 = 2080;
            v136 = v57;
            _os_log_fault_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: generate spindump: saved report (requested by %s [%d]) to %s", buf, 0x2Cu);
          }
LABEL_134:
          if (qword_1000EBD40)
            v115 = (FILE *)qword_1000EBD40;
          else
            v115 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v115);
LABEL_138:
          *__error() = v47;
LABEL_139:
          v116 = *(_QWORD *)(a1 + 32);
          if (v116)
            (*(void (**)(uint64_t, _QWORD, uint64_t))(v116 + 16))(v116, 0, *v34);
          goto LABEL_169;
        }
      }
      v88 = v51;
      v89 = CFStringGetCStringPtr(v51, 0x8000100u);
      if (v89)
      {
        v90 = (char *)v89;
        v91 = 0;
      }
      else
      {
        v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x68CF5E99uLL);
        CFStringGetCString(v88, v90, 1024, 0x8000100u);
        v91 = v90;
      }
      if (qword_1000EBD40)
        v111 = (FILE *)qword_1000EBD40;
      else
        v111 = __stderrp;
      fprintf(v111, "%s\n", v90);
      if (v91)
        free(v91);
      CFRelease(v88);
      goto LABEL_138;
    }
    if ((*v6 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v71 = *__error();
        v72 = sub_100030318();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
          sub_10008502C(v6, a1 + 64, v72);
        *__error() = v71;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_167;
      v60 = *__error();
      v73 = sub_1000302B4(*v6);
      v74 = *v34;
      v75 = *v6;
      v76 = *__error();
      v77 = __error();
      v78 = strerror(*v77);
      v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: unable to fdopen %s for writing: %d (%s)"), v73, v75, v74, v76, v78);
      if (v79)
      {
        v68 = v79;
        v69 = CFStringGetCStringPtr(v79, 0x8000100u);
        if (v69)
          goto LABEL_93;
        v70 = 1826001926;
LABEL_144:
        v80 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v70);
        CFStringGetCString(v68, v80, 1024, 0x8000100u);
        v81 = v80;
        goto LABEL_145;
      }
      v113 = sub_100030318();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT))
        sub_100084FB4(v6, a1 + 64, v113);
LABEL_153:
      if (qword_1000EBD40)
        v121 = (FILE *)qword_1000EBD40;
      else
        v121 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v121);
      goto LABEL_166;
    }
    if (byte_1000EBD38)
    {
      v102 = *__error();
      v103 = sub_100030318();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        sub_100085118();
      *__error() = v102;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_167;
    v60 = *__error();
    v104 = *v34;
    v105 = *__error();
    v106 = __error();
    v107 = strerror(*v106);
    v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: unable to fdopen %s for writing: %d (%s)"), v104, v105, v107);
    if (!v108)
    {
      v120 = sub_100030318();
      if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT))
        sub_1000850A4();
      goto LABEL_153;
    }
    v99 = v108;
    v100 = CFStringGetCStringPtr(v108, 0x8000100u);
    if (v100)
      goto LABEL_120;
    v101 = 1826001926;
    goto LABEL_158;
  }
  if (*v6 < 0)
  {
    if (byte_1000EBD38)
    {
      v92 = *__error();
      v93 = sub_100030318();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
        sub_100084F40();
      *__error() = v92;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_167;
    v60 = *__error();
    v94 = *v34;
    v95 = *__error();
    v96 = __error();
    v97 = strerror(*v96);
    v98 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("generate spindump: unable to open %s for writing: %d (%s)"), v94, v95, v97);
    if (!v98)
    {
      v117 = sub_100030318();
      if (os_log_type_enabled(v117, OS_LOG_TYPE_FAULT))
        sub_100084ECC();
      goto LABEL_153;
    }
    v99 = v98;
    v100 = CFStringGetCStringPtr(v98, 0x8000100u);
    if (v100)
    {
LABEL_120:
      v109 = (char *)v100;
      v110 = 0;
LABEL_159:
      if (qword_1000EBD40)
        v122 = (FILE *)qword_1000EBD40;
      else
        v122 = __stderrp;
      fprintf(v122, "%s\n", v109);
      if (v110)
        free(v110);
      v119 = v99;
      goto LABEL_165;
    }
    v101 = 1799302704;
LABEL_158:
    v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v101);
    CFStringGetCString(v99, v109, 1024, 0x8000100u);
    v110 = v109;
    goto LABEL_159;
  }
  if (byte_1000EBD38)
  {
    v58 = *__error();
    v59 = sub_100030318();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
      sub_100084E54(v6, a1 + 64, v59);
    *__error() = v58;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
    goto LABEL_167;
  v60 = *__error();
  v61 = sub_1000302B4(*v6);
  v62 = *v34;
  v63 = *v6;
  v64 = *__error();
  v65 = __error();
  v66 = strerror(*v65);
  v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: generate spindump: unable to open %s for writing: %d (%s)"), v61, v63, v62, v64, v66);
  if (!v67)
  {
    v112 = sub_100030318();
    if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
      sub_100084DDC(v6, a1 + 64, v112);
    goto LABEL_153;
  }
  v68 = v67;
  v69 = CFStringGetCStringPtr(v67, 0x8000100u);
  if (!v69)
  {
    v70 = 1799302704;
    goto LABEL_144;
  }
LABEL_93:
  v80 = (char *)v69;
  v81 = 0;
LABEL_145:
  if (qword_1000EBD40)
    v118 = (FILE *)qword_1000EBD40;
  else
    v118 = __stderrp;
  fprintf(v118, "%s\n", v80);
  if (v81)
    free(v81);
  v119 = v68;
LABEL_165:
  CFRelease(v119);
LABEL_166:
  *__error() = v60;
LABEL_167:
  v123 = *(_QWORD *)(a1 + 32);
  if (v123)
  {
    v124 = *__error();
    (*(void (**)(uint64_t, uint64_t, _QWORD))(v123 + 16))(v123, v124, 0);
  }
LABEL_169:
  free(*(void **)(a1 + 64));
  v125 = *(void **)(a1 + 40);
  if (v125)
    free(v125);
  v126 = *(void **)(a1 + 48);
  if (v126)
    free(v126);
}

uint64_t sub_10004142C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, void *a5, double a6, double a7, double a8, double a9, double a10)
{
  id v20;
  _BYTE *v21;
  id v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  NSObject *v27;
  int v28;
  _DWORD *v29;
  const __CFString *v30;
  const __CFString *v31;
  const char *CStringPtr;
  malloc_type_id_t v33;
  int v34;
  NSObject *v35;
  _DWORD *v36;
  const __CFString *v37;
  int v38;
  NSObject *v39;
  _DWORD *v40;
  const __CFString *v41;
  char *v42;
  char *v43;
  int v44;
  NSObject *v45;
  int v46;
  const __CFString *v47;
  const __CFString *v48;
  const char *v49;
  malloc_type_id_t v50;
  int v51;
  NSObject *v52;
  const __CFString *v53;
  int v54;
  NSObject *v55;
  const __CFString *v56;
  char *v57;
  char *v58;
  NSObject *v59;
  NSObject *v60;
  NSObject *v61;
  NSObject *v62;
  FILE *v63;
  NSObject *v64;
  FILE *v65;
  int v66;
  NSObject *v67;
  int v68;
  _DWORD *v69;
  const __CFString *v70;
  const __CFString *v71;
  const char *v72;
  char *v73;
  char *v74;
  NSObject *v75;
  FILE *v76;
  const __CFString *v77;
  NSObject *v78;
  FILE *v79;
  FILE *v80;
  int v81;
  NSObject *v82;
  const __CFString *v83;
  const __CFString *v84;
  const char *v85;
  char *v86;
  char *v87;
  NSObject *v88;
  FILE *v89;
  FILE *v90;
  uint8_t buf[4];
  _DWORD *v93;
  __int16 v94;
  _BYTE v95[24];
  __int16 v96;
  id v97;

  v20 = objc_alloc_init((Class)SAMicrostackshotStatistics);
  v21 = objc_msgSend(a2, "UTF8String");
  v22 = objc_msgSend(a5, "UTF8String");
  v23 = sub_100027B80(0, 0, a1, v21, a3, 1, (uint64_t)v22, 0, a8 - a7, a8, 0.0, a6, a7, a9, a10, 5u, (word_1000EBD78 & 0x80) != 0, 0, 0,
          a4,
          SHIDWORD(a4),
          0x11u,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          (uint64_t)v20);
  v24 = objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order") != 0;
  if (objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"))
    v25 = ((unint64_t)(v24 & 1) << 41) | 0x10000000000;
  else
    v25 = v24 << 41;
  if (objc_msgSend(v20, "bytes_not_microstackshots"))
    v25 |= 0x40000000000uLL;
  if ((v23 & 0x800000) != 0)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v34 = *__error();
        v35 = sub_100030318();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
          sub_100085980(a1, v20, v35);
        *__error() = v34;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v28 = *__error();
        v36 = sub_1000302B4(a1);
        v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), v36, a1, objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), objc_msgSend(v20, "bytes_not_microstackshots"));
        if (v37)
        {
          v31 = v37;
          CStringPtr = CFStringGetCStringPtr(v37, 0x8000100u);
          if (!CStringPtr)
          {
            v33 = 3552302414;
            goto LABEL_80;
          }
LABEL_37:
          v42 = (char *)CStringPtr;
          v43 = 0;
LABEL_81:
          if (qword_1000EBD40)
            v65 = (FILE *)qword_1000EBD40;
          else
            v65 = __stderrp;
          fprintf(v65, "%s\n", v42);
          if (v43)
            free(v43);
          CFRelease(v31);
          goto LABEL_87;
        }
        v59 = sub_100030318();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
          sub_1000858F4(a1, v20, v59);
LABEL_73:
        if (qword_1000EBD40)
          v63 = (FILE *)qword_1000EBD40;
        else
          v63 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v63);
LABEL_87:
        *__error() = v28;
      }
LABEL_88:
      if (byte_1000EBD38)
      {
        v66 = *__error();
        v67 = sub_100030318();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEBUG))
          sub_100085498();
        *__error() = v66;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
      {
        v68 = *__error();
        v69 = sub_1000302B4(a1);
        v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: done reporting (%#llx)"), v69, a1, v23);
        if (v70)
        {
          v71 = v70;
          v72 = CFStringGetCStringPtr(v70, 0x8000100u);
          if (v72)
          {
            v73 = (char *)v72;
            v74 = 0;
          }
          else
          {
            v73 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB4E194A9uLL);
            CFStringGetCString(v71, v73, 1024, 0x8000100u);
            v74 = v73;
          }
          if (qword_1000EBD40)
            v76 = (FILE *)qword_1000EBD40;
          else
            v76 = __stderrp;
          fprintf(v76, "%s\n", v73);
          if (v74)
            free(v74);
          v77 = v71;
LABEL_143:
          CFRelease(v77);
LABEL_144:
          *__error() = v68;
          goto LABEL_145;
        }
        v75 = sub_100030318();
        if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT))
          sub_10008542C();
        goto LABEL_132;
      }
      goto LABEL_145;
    }
    if (byte_1000EBD38)
    {
      v44 = *__error();
      v45 = sub_100030318();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        sub_100085A90();
      *__error() = v44;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v46 = *__error();
      v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), objc_msgSend(v20, "bytes_not_microstackshots"));
      if (v47)
      {
        v48 = v47;
        v49 = CFStringGetCStringPtr(v47, 0x8000100u);
        if (!v49)
        {
          v50 = 3552302414;
LABEL_113:
          v57 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v50);
          CFStringGetCString(v48, v57, 1024, 0x8000100u);
          v58 = v57;
          goto LABEL_114;
        }
LABEL_64:
        v57 = (char *)v49;
        v58 = 0;
LABEL_114:
        if (qword_1000EBD40)
          v80 = (FILE *)qword_1000EBD40;
        else
          v80 = __stderrp;
        fprintf(v80, "%s\n", v57);
        if (v58)
          free(v58);
        CFRelease(v48);
        goto LABEL_120;
      }
      v61 = sub_100030318();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_FAULT))
        sub_100085A0C();
LABEL_108:
      if (qword_1000EBD40)
        v79 = (FILE *)qword_1000EBD40;
      else
        v79 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
LABEL_120:
      *__error() = v46;
    }
  }
  else if (v25)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v26 = *__error();
        v27 = sub_100030318();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v93 = sub_1000302B4(a1);
          v94 = 1024;
          *(_DWORD *)v95 = a1;
          *(_WORD *)&v95[4] = 2048;
          *(_QWORD *)&v95[6] = objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order");
          *(_WORD *)&v95[14] = 2048;
          *(_QWORD *)&v95[16] = objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info");
          v96 = 2048;
          v97 = objc_msgSend(v20, "bytes_not_microstackshots");
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x30u);
        }
        *__error() = v26;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v28 = *__error();
        v29 = sub_1000302B4(a1);
        v30 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), v29, a1, objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), objc_msgSend(v20, "bytes_not_microstackshots"));
        if (v30)
        {
          v31 = v30;
          CStringPtr = CFStringGetCStringPtr(v30, 0x8000100u);
          if (!CStringPtr)
          {
            v33 = 3447110704;
LABEL_80:
            v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v33);
            CFStringGetCString(v31, v42, 1024, 0x8000100u);
            v43 = v42;
            goto LABEL_81;
          }
          goto LABEL_37;
        }
        v60 = sub_100030318();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
          sub_1000857E4(a1, v20, v60);
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBD38)
    {
      v51 = *__error();
      v52 = sub_100030318();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        v93 = objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order");
        v94 = 2048;
        *(_QWORD *)v95 = objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info");
        *(_WORD *)&v95[8] = 2048;
        *(_QWORD *)&v95[10] = objc_msgSend(v20, "bytes_not_microstackshots");
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x20u);
      }
      *__error() = v51;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
    {
      v46 = *__error();
      v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), objc_msgSend(v20, "bytes_not_microstackshots"));
      if (v53)
      {
        v48 = v53;
        v49 = CFStringGetCStringPtr(v53, 0x8000100u);
        if (!v49)
        {
          v50 = 3447110704;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      v64 = sub_100030318();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_FAULT))
        sub_100085870();
      goto LABEL_108;
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v38 = *__error();
        v39 = sub_100030318();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
          sub_100085590(a1, v20, v39);
        *__error() = v38;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
      {
        v28 = *__error();
        v40 = sub_1000302B4(a1);
        v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), v40, a1, objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), objc_msgSend(v20, "bytes_not_microstackshots"));
        if (v41)
        {
          v31 = v41;
          CStringPtr = CFStringGetCStringPtr(v41, 0x8000100u);
          if (!CStringPtr)
          {
            v33 = 707843938;
            goto LABEL_80;
          }
          goto LABEL_37;
        }
        v62 = sub_100030318();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
          sub_100085504(a1, v20, v62);
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBD38)
    {
      v54 = *__error();
      v55 = sub_100030318();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
        sub_100085760();
      *__error() = v54;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v46 = *__error();
      v56 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), objc_msgSend(objc_msgSend(v20, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v20, "total"), "num_missing_load_info"), objc_msgSend(v20, "bytes_not_microstackshots"));
      if (v56)
      {
        v48 = v56;
        v49 = CFStringGetCStringPtr(v56, 0x8000100u);
        if (!v49)
        {
          v50 = 707843938;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      v78 = sub_100030318();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
        sub_1000856DC();
      goto LABEL_108;
    }
  }
  if (byte_1000EBD38)
  {
    v81 = *__error();
    v82 = sub_100030318();
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
      sub_10008567C();
    *__error() = v81;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
  {
    v68 = *__error();
    v83 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("cpu resource: done reporting (%#llx)"), v23);
    if (v83)
    {
      v84 = v83;
      v85 = CFStringGetCStringPtr(v83, 0x8000100u);
      if (v85)
      {
        v86 = (char *)v85;
        v87 = 0;
      }
      else
      {
        v86 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB4E194A9uLL);
        CFStringGetCString(v84, v86, 1024, 0x8000100u);
        v87 = v86;
      }
      if (qword_1000EBD40)
        v90 = (FILE *)qword_1000EBD40;
      else
        v90 = __stderrp;
      fprintf(v90, "%s\n", v86);
      if (v87)
        free(v87);
      v77 = v84;
      goto LABEL_143;
    }
    v88 = sub_100030318();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_FAULT))
      sub_10008561C();
LABEL_132:
    if (qword_1000EBD40)
      v89 = (FILE *)qword_1000EBD40;
    else
      v89 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v89);
    goto LABEL_144;
  }
LABEL_145:

  return v23;
}

uint64_t sub_100042198(uint64_t a1, uint64_t a2, char a3, _QWORD *a4)
{
  int v8;
  NSObject *v9;
  BOOL v10;
  int v11;
  _DWORD *v12;
  const __CFString *v13;
  NSObject *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  NSObject *v18;
  BOOL v19;
  const __CFString *v20;
  const char *CStringPtr;
  char *v22;
  char *v23;
  FILE *v24;
  NSObject *v25;
  FILE *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  NSObject *v31;
  int v32;
  _DWORD *v33;
  const __CFString *v34;
  const __CFString *v35;
  const char *v36;
  malloc_type_id_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  NSObject *v41;
  _DWORD *v42;
  const __CFString *v43;
  char *v44;
  char *v45;
  int v46;
  NSObject *v47;
  const __CFString *v48;
  const __CFString *v49;
  const char *v50;
  malloc_type_id_t v51;
  int v52;
  NSObject *v53;
  const __CFString *v54;
  char *v55;
  char *v56;
  NSObject *v57;
  NSObject *v58;
  NSObject *v59;
  FILE *v60;
  const __CFString *v61;
  NSObject *v62;
  FILE *v63;
  FILE *v64;
  uint64_t v65;
  _BOOL4 v66;
  uint64_t v67;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[4];
  __int128 v71;
  uint64_t v72;
  task_name_t v73;

  if (!sub_10005E5AC(a1))
  {
    v15 = 0;
    v16 = 0;
    goto LABEL_45;
  }
  if ((a3 & 0x10) != 0)
  {
    v16 = 0;
    v15 = 16;
    goto LABEL_45;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v17 = *__error();
      v18 = sub_100030318();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        sub_100086460();
      *__error() = v17;
    }
    if (byte_1000EBD39)
      v19 = dword_1000EB4E8 <= 0;
    else
      v19 = 0;
    if (!v19)
      goto LABEL_26;
    v11 = *__error();
    v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: being debugged"), a2);
    if (!v13)
    {
      v25 = sub_100030318();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
        sub_100086400();
      goto LABEL_39;
    }
LABEL_28:
    v20 = v13;
    CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
    if (CStringPtr)
    {
      v22 = (char *)CStringPtr;
      v23 = 0;
    }
    else
    {
      v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCAF36CB5uLL);
      CFStringGetCString(v20, v22, 1024, 0x8000100u);
      v23 = v22;
    }
    if (qword_1000EBD40)
      v24 = (FILE *)qword_1000EBD40;
    else
      v24 = __stderrp;
    fprintf(v24, "%s\n", v22);
    if (v23)
      free(v23);
    CFRelease(v20);
    goto LABEL_43;
  }
  if (byte_1000EBD38)
  {
    v8 = *__error();
    v9 = sub_100030318();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      sub_100086388();
    *__error() = v8;
  }
  if (byte_1000EBD39)
    v10 = dword_1000EB4E8 <= 0;
  else
    v10 = 0;
  if (v10)
  {
    v11 = *__error();
    v12 = sub_1000302B4(a1);
    v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: being debugged"), v12, a1, a2);
    if (!v13)
    {
      v14 = sub_100030318();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
        sub_10008631C();
LABEL_39:
      if (qword_1000EBD40)
        v26 = (FILE *)qword_1000EBD40;
      else
        v26 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
LABEL_43:
      v15 = 0;
      *__error() = v11;
      goto LABEL_44;
    }
    goto LABEL_28;
  }
LABEL_26:
  v15 = 0;
LABEL_44:
  v16 = 16;
LABEL_45:
  if (sub_10004819C())
    v15 |= 0x100uLL;
  if (sub_10005EED8())
    v27 = v15 | 0x80;
  else
    v27 = v15;
  if (qword_1000EBBF0 != -1)
    dispatch_once(&qword_1000EBBF0, &stru_1000DD070);
  if ((byte_1000EBBE8 & 1) != 0)
    goto LABEL_125;
  v73 = 0;
  v28 = task_inspect_for_pid(mach_task_self_, a1, &v73);
  if ((_DWORD)v28)
  {
    v29 = v28;
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v30 = *__error();
        v31 = sub_100030318();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_1000861F0();
        *__error() = v30;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v32 = *__error();
        v33 = sub_1000302B4(a1);
        v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to inspect task for suspended state (%d), assuming not suspended"), v33, a1, v29);
        if (v34)
        {
          v35 = v34;
          v36 = CFStringGetCStringPtr(v34, 0x8000100u);
          if (!v36)
          {
            v37 = 2492266603;
LABEL_102:
            v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v37);
            CFStringGetCString(v35, v44, 1024, 0x8000100u);
            v45 = v44;
            goto LABEL_103;
          }
          goto LABEL_74;
        }
        v57 = sub_100030318();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT))
          sub_100086184();
        goto LABEL_111;
      }
      goto LABEL_125;
    }
    if (byte_1000EBD38)
    {
      v46 = *__error();
      v47 = sub_100030318();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
        sub_1000862BC();
      *__error() = v46;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_125;
    v32 = *__error();
    v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to inspect task for suspended state (%d), assuming not suspended"), v29);
    if (!v48)
    {
      v58 = sub_100030318();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
        sub_10008625C();
      goto LABEL_111;
    }
    v49 = v48;
    v50 = CFStringGetCStringPtr(v48, 0x8000100u);
    if (!v50)
    {
      v51 = 2492266603;
LABEL_116:
      v55 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v51);
      CFStringGetCString(v49, v55, 1024, 0x8000100u);
      v56 = v55;
      goto LABEL_117;
    }
    goto LABEL_94;
  }
  v72 = 0;
  *(_OWORD *)task_info_out = 0u;
  v71 = 0u;
  task_info_outCnt = 10;
  v38 = task_info(v73, 0x12u, task_info_out, &task_info_outCnt);
  if (!(_DWORD)v38)
  {
    if (task_info_out[0])
      v27 |= 0x20uLL;
    goto LABEL_125;
  }
  v39 = v38;
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v52 = *__error();
      v53 = sub_100030318();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
        sub_100086124();
      *__error() = v52;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_125;
    v32 = *__error();
    v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to get suspended state (%d), assuming not suspended"), v39);
    if (!v54)
    {
      v62 = sub_100030318();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
        sub_1000860C4();
      goto LABEL_111;
    }
    v49 = v54;
    v50 = CFStringGetCStringPtr(v54, 0x8000100u);
    if (!v50)
    {
      v51 = 3856747882;
      goto LABEL_116;
    }
LABEL_94:
    v55 = (char *)v50;
    v56 = 0;
LABEL_117:
    if (qword_1000EBD40)
      v64 = (FILE *)qword_1000EBD40;
    else
      v64 = __stderrp;
    fprintf(v64, "%s\n", v55);
    if (v56)
      free(v56);
    v61 = v49;
    goto LABEL_123;
  }
  if (byte_1000EBD38)
  {
    v40 = *__error();
    v41 = sub_100030318();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      sub_100086058();
    *__error() = v40;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
  {
    v32 = *__error();
    v42 = sub_1000302B4(a1);
    v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to get suspended state (%d), assuming not suspended"), v42, a1, v39);
    if (v43)
    {
      v35 = v43;
      v36 = CFStringGetCStringPtr(v43, 0x8000100u);
      if (!v36)
      {
        v37 = 3856747882;
        goto LABEL_102;
      }
LABEL_74:
      v44 = (char *)v36;
      v45 = 0;
LABEL_103:
      if (qword_1000EBD40)
        v60 = (FILE *)qword_1000EBD40;
      else
        v60 = __stderrp;
      fprintf(v60, "%s\n", v44);
      if (v45)
        free(v45);
      v61 = v35;
LABEL_123:
      CFRelease(v61);
LABEL_124:
      *__error() = v32;
      goto LABEL_125;
    }
    v59 = sub_100030318();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
      sub_100085FEC();
LABEL_111:
    if (qword_1000EBD40)
      v63 = (FILE *)qword_1000EBD40;
    else
      v63 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v63);
    goto LABEL_124;
  }
LABEL_125:
  if (sub_100025FB4())
    v65 = v27 | 0x400000000;
  else
    v65 = v27;
  v66 = sub_10004872C();
  v67 = v65 | 0x80000000000;
  if (!v66)
    v67 = v65;
  *a4 |= v67;
  return v16;
}

uint64_t sub_100042A24(double a1)
{
  double v2;
  _BOOL8 v3;
  int v4;
  NSObject *v5;
  BOOL v6;
  int v7;
  NSObject *v8;
  BOOL v9;
  int v10;
  const __CFString *v11;
  const __CFString *v12;
  const char *CStringPtr;
  malloc_type_id_t v14;
  const __CFString *v15;
  char *v16;
  char *v17;
  NSObject *v18;
  NSObject *v19;
  FILE *v20;
  FILE *v21;

  if (a1 > 0.0)
  {
    if (a1 < 100.0)
    {
      if (qword_1000EBBE0 != -1)
        dispatch_once(&qword_1000EBBE0, &stru_1000DD050);
      v2 = (double)rand() * 100.0 / 2147483650.0;
      v3 = v2 > a1;
      if (v2 > a1)
      {
        if (byte_1000EBD38)
        {
          v4 = *__error();
          v5 = sub_100030318();
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
            sub_100086528();
          *__error() = v4;
        }
        if (byte_1000EBD39)
          v6 = dword_1000EB4E8 <= 0;
        else
          v6 = 0;
        if (!v6)
          return 1;
        v10 = *__error();
        v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Should restrict submission due to roll of %.4f (pref is %.4f)"), *(_QWORD *)&v2, *(_QWORD *)&a1);
        if (v11)
        {
          v12 = v11;
          CStringPtr = CFStringGetCStringPtr(v11, 0x8000100u);
          if (!CStringPtr)
          {
            v14 = 340758073;
LABEL_39:
            v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v14);
            CFStringGetCString(v12, v16, 1024, 0x8000100u);
            v17 = v16;
            goto LABEL_40;
          }
          goto LABEL_29;
        }
        v18 = sub_100030318();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
          sub_1000864C0();
        goto LABEL_34;
      }
      if (byte_1000EBD38)
      {
        v7 = *__error();
        v8 = sub_100030318();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          sub_1000865F4();
        *__error() = v7;
      }
      if (byte_1000EBD39)
        v9 = dword_1000EB4E8 <= 0;
      else
        v9 = 0;
      if (v9)
      {
        v10 = *__error();
        v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Should not restrict submission due to roll of %.4f (pref is %.4f)"), *(_QWORD *)&v2, *(_QWORD *)&a1);
        if (v15)
        {
          v12 = v15;
          CStringPtr = CFStringGetCStringPtr(v15, 0x8000100u);
          if (!CStringPtr)
          {
            v14 = 1617739763;
            goto LABEL_39;
          }
LABEL_29:
          v16 = (char *)CStringPtr;
          v17 = 0;
LABEL_40:
          if (qword_1000EBD40)
            v21 = (FILE *)qword_1000EBD40;
          else
            v21 = __stderrp;
          fprintf(v21, "%s\n", v16);
          if (v17)
            free(v17);
          CFRelease(v12);
LABEL_46:
          *__error() = v10;
          return v3;
        }
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          sub_10008658C();
LABEL_34:
        if (qword_1000EBD40)
          v20 = (FILE *)qword_1000EBD40;
        else
          v20 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
        goto LABEL_46;
      }
    }
    return 0;
  }
  return 1;
}

void sub_100042D54(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = sub_10004142C(*(unsigned int *)(a1 + 128), *(void **)(a1 + 32), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(void **)(a1 + 40), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 88), *(double *)(a1 + 96), *(double *)(a1 + 104));
  sub_100030CDC(*(_DWORD *)(a1 + 128), *(void **)(a1 + 32), *(_QWORD *)(a1 + 112), v2, *(_QWORD *)(a1 + 120) | v3, *(_DWORD *)(a1 + 64) & 1, *(double *)(a1 + 88) - *(double *)(a1 + 80), *(double *)(a1 + 88), *(double *)(a1 + 72));

}

uint64_t sub_100042DC0(uint64_t a1, void *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, double a7, double a8, double a9)
{
  id v18;
  _BYTE *v19;
  id v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  NSObject *v25;
  int v26;
  _DWORD *v27;
  const __CFString *v28;
  const __CFString *v29;
  const char *CStringPtr;
  malloc_type_id_t v31;
  int v32;
  NSObject *v33;
  _DWORD *v34;
  const __CFString *v35;
  int v36;
  NSObject *v37;
  _DWORD *v38;
  const __CFString *v39;
  char *v40;
  char *v41;
  int v42;
  NSObject *v43;
  int v44;
  const __CFString *v45;
  const __CFString *v46;
  const char *v47;
  malloc_type_id_t v48;
  int v49;
  NSObject *v50;
  const __CFString *v51;
  int v52;
  NSObject *v53;
  const __CFString *v54;
  char *v55;
  char *v56;
  NSObject *v57;
  NSObject *v58;
  NSObject *v59;
  NSObject *v60;
  FILE *v61;
  NSObject *v62;
  FILE *v63;
  int v64;
  NSObject *v65;
  int v66;
  _DWORD *v67;
  const __CFString *v68;
  const __CFString *v69;
  const char *v70;
  char *v71;
  char *v72;
  NSObject *v73;
  FILE *v74;
  const __CFString *v75;
  NSObject *v76;
  FILE *v77;
  FILE *v78;
  int v79;
  NSObject *v80;
  const __CFString *v81;
  const __CFString *v82;
  const char *v83;
  char *v84;
  char *v85;
  NSObject *v86;
  FILE *v87;
  FILE *v88;
  uint8_t buf[4];
  _DWORD *v91;
  __int16 v92;
  _BYTE v93[24];
  __int16 v94;
  id v95;

  v18 = objc_alloc_init((Class)SAMicrostackshotStatistics);
  v19 = objc_msgSend(a2, "UTF8String");
  v20 = objc_msgSend(a4, "UTF8String");
  v21 = sub_100027B80(0, 0, a1, v19, 0, 1, (uint64_t)v20, 0, a8 - a7, a8, 0.0, 0.0, a7, 0.0, a9, 6u, HIBYTE(word_1000EBD78) & 1, a5, a6,
          a3,
          SHIDWORD(a3),
          8u,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          (uint64_t)v18);
  v22 = objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order") != 0;
  if (objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"))
    v23 = ((unint64_t)(v22 & 1) << 41) | 0x10000000000;
  else
    v23 = v22 << 41;
  if (objc_msgSend(v18, "bytes_not_microstackshots"))
    v23 |= 0x40000000000uLL;
  if ((v21 & 0x800000) != 0)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v32 = *__error();
        v33 = sub_100030318();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          sub_100086BAC(a1, v18, v33);
        *__error() = v32;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v26 = *__error();
        v34 = sub_1000302B4(a1);
        v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), v34, a1, objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), objc_msgSend(v18, "bytes_not_microstackshots"));
        if (v35)
        {
          v29 = v35;
          CStringPtr = CFStringGetCStringPtr(v35, 0x8000100u);
          if (!CStringPtr)
          {
            v31 = 913548837;
            goto LABEL_80;
          }
LABEL_37:
          v40 = (char *)CStringPtr;
          v41 = 0;
LABEL_81:
          if (qword_1000EBD40)
            v63 = (FILE *)qword_1000EBD40;
          else
            v63 = __stderrp;
          fprintf(v63, "%s\n", v40);
          if (v41)
            free(v41);
          CFRelease(v29);
          goto LABEL_87;
        }
        v57 = sub_100030318();
        if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT))
          sub_100086B20(a1, v18, v57);
LABEL_73:
        if (qword_1000EBD40)
          v61 = (FILE *)qword_1000EBD40;
        else
          v61 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v61);
LABEL_87:
        *__error() = v26;
      }
LABEL_88:
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          sub_1000866C4();
        *__error() = v64;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
      {
        v66 = *__error();
        v67 = sub_1000302B4(a1);
        v68 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: done reporting (%#llx)"), v67, a1, v21);
        if (v68)
        {
          v69 = v68;
          v70 = CFStringGetCStringPtr(v68, 0x8000100u);
          if (v70)
          {
            v71 = (char *)v70;
            v72 = 0;
          }
          else
          {
            v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9125229EuLL);
            CFStringGetCString(v69, v71, 1024, 0x8000100u);
            v72 = v71;
          }
          if (qword_1000EBD40)
            v74 = (FILE *)qword_1000EBD40;
          else
            v74 = __stderrp;
          fprintf(v74, "%s\n", v71);
          if (v72)
            free(v72);
          v75 = v69;
LABEL_143:
          CFRelease(v75);
LABEL_144:
          *__error() = v66;
          goto LABEL_145;
        }
        v73 = sub_100030318();
        if (os_log_type_enabled(v73, OS_LOG_TYPE_FAULT))
          sub_100086658();
        goto LABEL_132;
      }
      goto LABEL_145;
    }
    if (byte_1000EBD38)
    {
      v42 = *__error();
      v43 = sub_100030318();
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
        sub_100086CBC();
      *__error() = v42;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v44 = *__error();
      v45 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), objc_msgSend(v18, "bytes_not_microstackshots"));
      if (v45)
      {
        v46 = v45;
        v47 = CFStringGetCStringPtr(v45, 0x8000100u);
        if (!v47)
        {
          v48 = 913548837;
LABEL_113:
          v55 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v48);
          CFStringGetCString(v46, v55, 1024, 0x8000100u);
          v56 = v55;
          goto LABEL_114;
        }
LABEL_64:
        v55 = (char *)v47;
        v56 = 0;
LABEL_114:
        if (qword_1000EBD40)
          v78 = (FILE *)qword_1000EBD40;
        else
          v78 = __stderrp;
        fprintf(v78, "%s\n", v55);
        if (v56)
          free(v56);
        CFRelease(v46);
        goto LABEL_120;
      }
      v59 = sub_100030318();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
        sub_100086C38();
LABEL_108:
      if (qword_1000EBD40)
        v77 = (FILE *)qword_1000EBD40;
      else
        v77 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v77);
LABEL_120:
      *__error() = v44;
    }
  }
  else if (v23)
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v24 = *__error();
        v25 = sub_100030318();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          v91 = sub_1000302B4(a1);
          v92 = 1024;
          *(_DWORD *)v93 = a1;
          *(_WORD *)&v93[4] = 2048;
          *(_QWORD *)&v93[6] = objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order");
          *(_WORD *)&v93[14] = 2048;
          *(_QWORD *)&v93[16] = objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info");
          v94 = 2048;
          v95 = objc_msgSend(v18, "bytes_not_microstackshots");
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x30u);
        }
        *__error() = v24;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v26 = *__error();
        v27 = sub_1000302B4(a1);
        v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), v27, a1, objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), objc_msgSend(v18, "bytes_not_microstackshots"));
        if (v28)
        {
          v29 = v28;
          CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
          if (!CStringPtr)
          {
            v31 = 1932714137;
LABEL_80:
            v40 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v31);
            CFStringGetCString(v29, v40, 1024, 0x8000100u);
            v41 = v40;
            goto LABEL_81;
          }
          goto LABEL_37;
        }
        v58 = sub_100030318();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
          sub_100086A10(a1, v18, v58);
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBD38)
    {
      v49 = *__error();
      v50 = sub_100030318();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218496;
        v91 = objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order");
        v92 = 2048;
        *(_QWORD *)v93 = objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info");
        *(_WORD *)&v93[8] = 2048;
        *(_QWORD *)&v93[10] = objc_msgSend(v18, "bytes_not_microstackshots");
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", buf, 0x20u);
      }
      *__error() = v49;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
    {
      v44 = *__error();
      v51 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), objc_msgSend(v18, "bytes_not_microstackshots"));
      if (v51)
      {
        v46 = v51;
        v47 = CFStringGetCStringPtr(v51, 0x8000100u);
        if (!v47)
        {
          v48 = 1932714137;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      v62 = sub_100030318();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
        sub_100086A9C();
      goto LABEL_108;
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v36 = *__error();
        v37 = sub_100030318();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
          sub_1000867BC(a1, v18, v37);
        *__error() = v36;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
      {
        v26 = *__error();
        v38 = sub_1000302B4(a1);
        v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), v38, a1, objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), objc_msgSend(v18, "bytes_not_microstackshots"));
        if (v39)
        {
          v29 = v39;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (!CStringPtr)
          {
            v31 = 275669395;
            goto LABEL_80;
          }
          goto LABEL_37;
        }
        v60 = sub_100030318();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
          sub_100086730(a1, v18, v60);
        goto LABEL_73;
      }
      goto LABEL_88;
    }
    if (byte_1000EBD38)
    {
      v52 = *__error();
      v53 = sub_100030318();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
        sub_10008698C();
      *__error() = v52;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v44 = *__error();
      v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid"), objc_msgSend(objc_msgSend(v18, "total"), "num_out_of_order"), objc_msgSend(objc_msgSend(v18, "total"), "num_missing_load_info"), objc_msgSend(v18, "bytes_not_microstackshots"));
      if (v54)
      {
        v46 = v54;
        v47 = CFStringGetCStringPtr(v54, 0x8000100u);
        if (!v47)
        {
          v48 = 275669395;
          goto LABEL_113;
        }
        goto LABEL_64;
      }
      v76 = sub_100030318();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
        sub_100086908();
      goto LABEL_108;
    }
  }
  if (byte_1000EBD38)
  {
    v79 = *__error();
    v80 = sub_100030318();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_DEBUG))
      sub_1000868A8();
    *__error() = v79;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
  {
    v66 = *__error();
    v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: done reporting (%#llx)"), v21);
    if (v81)
    {
      v82 = v81;
      v83 = CFStringGetCStringPtr(v81, 0x8000100u);
      if (v83)
      {
        v84 = (char *)v83;
        v85 = 0;
      }
      else
      {
        v84 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9125229EuLL);
        CFStringGetCString(v82, v84, 1024, 0x8000100u);
        v85 = v84;
      }
      if (qword_1000EBD40)
        v88 = (FILE *)qword_1000EBD40;
      else
        v88 = __stderrp;
      fprintf(v88, "%s\n", v84);
      if (v85)
        free(v85);
      v75 = v82;
      goto LABEL_143;
    }
    v86 = sub_100030318();
    if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
      sub_100086848();
LABEL_132:
    if (qword_1000EBD40)
      v87 = (FILE *)qword_1000EBD40;
    else
      v87 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
    goto LABEL_144;
  }
LABEL_145:

  return v21;
}

void sub_100043B20(uint64_t a1, id a2, uint64_t a3, uint64_t a4, _DWORD *a5, uint64_t a6, double a7, double a8, double a9)
{
  int v17;
  NSObject *v18;
  BOOL v19;
  int v20;
  _DWORD *v21;
  const __CFString *v22;
  const __CFString *v23;
  id v24;
  const char *CStringPtr;
  char *v26;
  char *v27;
  int v28;
  NSObject *v29;
  BOOL v30;
  const __CFString *v31;
  const __CFString *v32;
  id v33;
  const char *v34;
  char *v35;
  char *v36;
  NSObject *v37;
  FILE *v38;
  FILE *v39;
  NSObject *v40;
  FILE *v41;
  id v42;
  uint64_t v43;
  int v44;
  NSObject *v45;
  int v46;
  _DWORD *v47;
  const __CFString *v48;
  NSObject *v49;
  int v50;
  NSObject *v51;
  const __CFString *v52;
  uint64_t v53;
  _DWORD *v54;
  const char *v55;
  char *v56;
  char *v57;
  FILE *v58;
  NSObject *v59;
  FILE *v60;
  int v61;
  NSObject *v62;
  int v63;
  _DWORD *v64;
  const __CFString *v65;
  NSObject *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  NSObject *global_queue;
  int v72;
  NSObject *v73;
  const __CFString *v74;
  const char *v75;
  char *v76;
  char *v77;
  uint64_t v78;
  int v79;
  NSObject *v80;
  _DWORD *v81;
  int v82;
  _DWORD *v83;
  const __CFString *v84;
  NSObject *v85;
  FILE *v86;
  int v87;
  NSObject *v88;
  int v89;
  _DWORD *v90;
  const __CFString *v91;
  NSObject *v92;
  NSObject *v93;
  FILE *v94;
  int v95;
  NSObject *v96;
  _DWORD *v97;
  int v98;
  _DWORD *v99;
  const __CFString *v100;
  NSObject *v101;
  int v102;
  NSObject *v103;
  const __CFString *v104;
  const char *v105;
  char *v106;
  char *v107;
  FILE *v108;
  NSObject *v109;
  FILE *v110;
  uint64_t v111;
  double v112;
  int v113;
  void *v114;
  uint64_t v115;
  uint64_t v116;
  double v117;
  uint64_t v118;
  int v119;
  NSObject *v120;
  const __CFString *v121;
  uint64_t v122;
  uint64_t v123;
  const char *v124;
  char *v125;
  char *v126;
  int v127;
  NSObject *v128;
  const __CFString *v129;
  uint64_t v130;
  uint64_t v131;
  const char *v132;
  char *v133;
  char *v134;
  _DWORD *v135;
  FILE *v136;
  FILE *v137;
  NSObject *v138;
  FILE *v139;
  NSObject *v140;
  FILE *v141;
  uint64_t v142;
  id v143;
  uint64_t v145;
  _QWORD block[15];
  int v147;
  uint64_t v148;
  uint8_t buf[4];
  _DWORD *v150;
  __int16 v151;
  _BYTE v152[24];
  __int16 v153;
  uint64_t v154;

  if ((a1 & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v17 = *__error();
      v18 = sub_100030318();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136447234;
        v150 = sub_1000302B4(a1);
        v151 = 1024;
        *(_DWORD *)v152 = a1;
        *(_WORD *)&v152[4] = 2048;
        *(_QWORD *)&v152[6] = a5;
        *(_WORD *)&v152[14] = 2048;
        *(double *)&v152[16] = a7;
        v153 = 2048;
        v154 = a3;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "%{public}s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x30u);
      }
      *__error() = v17;
    }
    if (byte_1000EBD39)
      v19 = dword_1000EB4E8 <= 1;
    else
      v19 = 0;
    if (!v19)
      goto LABEL_52;
    v20 = *__error();
    v21 = sub_1000302B4(a1);
    v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx"), v21, a1, a5, *(_QWORD *)&a7, a3);
    if (v22)
    {
      v23 = v22;
      v24 = a2;
      CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
      if (CStringPtr)
      {
        v26 = (char *)CStringPtr;
        v27 = 0;
      }
      else
      {
        v26 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA227B0B6uLL);
        CFStringGetCString(v23, v26, 1024, 0x8000100u);
        v27 = v26;
      }
      if (qword_1000EBD40)
        v39 = (FILE *)qword_1000EBD40;
      else
        v39 = __stderrp;
      fprintf(v39, "%s\n", v26);
      if (v27)
        free(v27);
      CFRelease(v23);
      a2 = v24;
      goto LABEL_51;
    }
    v37 = sub_100030318();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
    {
      v135 = sub_1000302B4(a1);
      *(_DWORD *)buf = 136316162;
      v150 = v135;
      v151 = 1024;
      *(_DWORD *)v152 = a1;
      *(_WORD *)&v152[4] = 2048;
      *(_QWORD *)&v152[6] = a5;
      *(_WORD *)&v152[14] = 2048;
      *(double *)&v152[16] = a7;
      v153 = 2048;
      v154 = a3;
      _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x30u);
    }
    if (qword_1000EBD40)
      v38 = (FILE *)qword_1000EBD40;
    else
      v38 = __stderrp;
LABEL_31:
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
LABEL_51:
    *__error() = v20;
    goto LABEL_52;
  }
  if (byte_1000EBD38)
  {
    v28 = *__error();
    v29 = sub_100030318();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134218496;
      v150 = a5;
      v151 = 2048;
      *(double *)v152 = a7;
      *(_WORD *)&v152[8] = 2048;
      *(_QWORD *)&v152[10] = a3;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x20u);
    }
    *__error() = v28;
  }
  if (byte_1000EBD39)
    v30 = dword_1000EB4E8 <= 1;
  else
    v30 = 0;
  if (v30)
  {
    v20 = *__error();
    v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: %llu bytes over the last %.0f seconds with flags %#llx"), a5, *(_QWORD *)&a7, a3);
    if (v31)
    {
      v32 = v31;
      v33 = a2;
      v34 = CFStringGetCStringPtr(v31, 0x8000100u);
      if (v34)
      {
        v35 = (char *)v34;
        v36 = 0;
      }
      else
      {
        v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA227B0B6uLL);
        CFStringGetCString(v32, v35, 1024, 0x8000100u);
        v36 = v35;
      }
      if (qword_1000EBD40)
        v41 = (FILE *)qword_1000EBD40;
      else
        v41 = __stderrp;
      fprintf(v41, "%s\n", v35);
      if (v36)
        free(v36);
      CFRelease(v32);
      a2 = v33;
      goto LABEL_51;
    }
    v40 = sub_100030318();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 134218496;
      v150 = a5;
      v151 = 2048;
      *(double *)v152 = a7;
      *(_WORD *)&v152[8] = 2048;
      *(_QWORD *)&v152[10] = a3;
      _os_log_fault_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_FAULT, "Unable to format: disk writes: %llu bytes over the last %.0f seconds with flags %#llx", buf, 0x20u);
    }
    if (qword_1000EBD40)
      v38 = (FILE *)qword_1000EBD40;
    else
      v38 = __stderrp;
    goto LABEL_31;
  }
LABEL_52:
  v145 = sub_10003038C(a1);
  if (!a2)
    a2 = sub_1000303D0(a1);
  v42 = a2;
  v148 = 0;
  v43 = sub_100042198(a1, (uint64_t)"disk writes", 160, &v148);
  if ((word_1000EBD78 & 0x100) == 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v50 = *__error();
        v51 = sub_100030318();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
          sub_1000871EC();
        *__error() = v50;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_88;
      v142 = a6;
      v143 = v42;
      v46 = *__error();
      v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: not monitoring due to suppression cookie file"));
      if (!v48)
      {
        v59 = sub_100030318();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
          sub_1000871C0();
        goto LABEL_83;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v44 = *__error();
        v45 = sub_100030318();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
          sub_100087158();
        *__error() = v44;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_88;
      v142 = a6;
      v143 = v42;
      v46 = *__error();
      v47 = sub_1000302B4(a1);
      v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: not monitoring due to suppression cookie file"), v47, a1);
      if (!v48)
      {
        v49 = sub_100030318();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
          sub_1000870F0();
LABEL_83:
        if (qword_1000EBD40)
          v60 = (FILE *)qword_1000EBD40;
        else
          v60 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v60);
LABEL_87:
        *__error() = v46;
        a6 = v142;
        v42 = v143;
LABEL_88:
        v43 |= 0x8000uLL;
        goto LABEL_89;
      }
    }
    v52 = v48;
    v53 = a3;
    v54 = a5;
    v55 = CFStringGetCStringPtr(v48, 0x8000100u);
    if (v55)
    {
      v56 = (char *)v55;
      v57 = 0;
    }
    else
    {
      v56 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5C02547uLL);
      CFStringGetCString(v52, v56, 1024, 0x8000100u);
      v57 = v56;
    }
    if (qword_1000EBD40)
      v58 = (FILE *)qword_1000EBD40;
    else
      v58 = __stderrp;
    fprintf(v58, "%s\n", v56);
    if (v57)
      free(v57);
    CFRelease(v52);
    a5 = v54;
    a3 = v53;
    goto LABEL_87;
  }
LABEL_89:
  if (!sub_100042A24(*(double *)&qword_1000EBD68))
  {
    if (v43)
      goto LABEL_148;
    v67 = (uint64_t)a5;
    v68 = v148;
    v69 = (uint64_t)v42;
    if ((v148 & 0x80000000000) == 0)
    {
LABEL_102:
      v70 = sub_100030160("Disk writes resource for [%d]", a1);
      global_queue = dispatch_get_global_queue(9, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100044DF4;
      block[3] = &unk_1000DCFE0;
      v147 = a1;
      block[4] = v69;
      block[5] = a4;
      block[7] = a3;
      block[8] = v67;
      *(double *)&block[9] = a7;
      *(double *)&block[10] = a8;
      block[11] = a6;
      *(double *)&block[12] = a9;
      block[13] = v145;
      block[14] = v68;
      block[6] = v70;
      dispatch_async(global_queue, block);
      return;
    }
    v78 = a6;
    if (sub_10004EFD4())
    {
      if ((a1 & 0x80000000) != 0)
      {
        if (byte_1000EBD38)
        {
          v119 = *__error();
          v120 = sub_100030318();
          if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "disk writes: deferring report generation due to game mode", buf, 2u);
          }
          *__error() = v119;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
          goto LABEL_222;
        v82 = *__error();
        v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: deferring report generation due to game mode"));
        if (!v84)
        {
          v138 = sub_100030318();
          if (os_log_type_enabled(v138, OS_LOG_TYPE_FAULT))
            sub_100086F9C();
          goto LABEL_217;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v79 = *__error();
          v80 = sub_100030318();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_DEFAULT))
          {
            v81 = sub_1000302B4(a1);
            *(_DWORD *)buf = 136446466;
            v150 = v81;
            v151 = 1024;
            *(_DWORD *)v152 = a1;
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: disk writes: deferring report generation due to game mode", buf, 0x12u);
          }
          *__error() = v79;
          v69 = (uint64_t)v42;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
          goto LABEL_222;
        v82 = *__error();
        v83 = sub_1000302B4(a1);
        v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: deferring report generation due to game mode"), v83, a1);
        if (!v84)
        {
          v85 = sub_100030318();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
            sub_100086F34();
LABEL_217:
          if (qword_1000EBD40)
            v139 = (FILE *)qword_1000EBD40;
          else
            v139 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v139);
          v69 = (uint64_t)v42;
LABEL_221:
          *__error() = v82;
LABEL_222:
          sub_1000508EC(a1, v69, a3, a4, v67, v78, a7, a8, a9);
          v111 = v68 | 0x100000000000;
          v112 = a8 - a7;
          v113 = a1;
          v114 = (void *)v69;
          v115 = v145;
          v116 = 0;
          v117 = a8;
          v118 = v67;
          goto LABEL_182;
        }
      }
      v121 = v84;
      v122 = a3;
      v123 = (uint64_t)v42;
      v124 = CFStringGetCStringPtr(v84, 0x8000100u);
      if (v124)
      {
        v125 = (char *)v124;
        v126 = 0;
      }
      else
      {
        v125 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6E4FE841uLL);
        CFStringGetCString(v121, v125, 1024, 0x8000100u);
        v126 = v125;
      }
      if (qword_1000EBD40)
        v136 = (FILE *)qword_1000EBD40;
      else
        v136 = __stderrp;
      fprintf(v136, "%s\n", v125);
      if (v126)
        free(v126);
      CFRelease(v121);
      v69 = v123;
      a3 = v122;
      goto LABEL_221;
    }
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v127 = *__error();
        v128 = sub_100030318();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_DEBUG))
          sub_1000870C4();
        *__error() = v127;
      }
      a6 = v78;
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_102;
      v89 = *__error();
      v91 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: cannot defer report generation for game mode"));
      if (!v91)
      {
        v140 = sub_100030318();
        if (os_log_type_enabled(v140, OS_LOG_TYPE_FAULT))
          sub_100087098();
        goto LABEL_225;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v87 = *__error();
        v88 = sub_100030318();
        if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
          sub_100087030();
        *__error() = v87;
      }
      a6 = v78;
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_102;
      v89 = *__error();
      v90 = sub_1000302B4(a1);
      v91 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: cannot defer report generation for game mode"), v90, a1);
      if (!v91)
      {
        v92 = sub_100030318();
        if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
          sub_100086FC8();
LABEL_225:
        if (qword_1000EBD40)
          v141 = (FILE *)qword_1000EBD40;
        else
          v141 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v141);
        v69 = (uint64_t)v42;
LABEL_229:
        *__error() = v89;
        a6 = v78;
        goto LABEL_102;
      }
    }
    v129 = v91;
    v130 = a3;
    v131 = (uint64_t)v42;
    v132 = CFStringGetCStringPtr(v91, 0x8000100u);
    if (v132)
    {
      v133 = (char *)v132;
      v134 = 0;
    }
    else
    {
      v133 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC2760167uLL);
      CFStringGetCString(v129, v133, 1024, 0x8000100u);
      v134 = v133;
    }
    if (qword_1000EBD40)
      v137 = (FILE *)qword_1000EBD40;
    else
      v137 = __stderrp;
    fprintf(v137, "%s\n", v133);
    if (v134)
      free(v134);
    CFRelease(v129);
    v69 = v131;
    a3 = v130;
    goto LABEL_229;
  }
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v72 = *__error();
      v73 = sub_100030318();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
        sub_100086F08();
      *__error() = v72;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
      goto LABEL_147;
    v63 = *__error();
    v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: not monitoring due to tasking-specified sampling"));
    if (!v65)
    {
      v93 = sub_100030318();
      if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT))
        sub_100086EDC();
      goto LABEL_142;
    }
LABEL_110:
    v74 = v65;
    v75 = CFStringGetCStringPtr(v65, 0x8000100u);
    if (v75)
    {
      v76 = (char *)v75;
      v77 = 0;
    }
    else
    {
      v76 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB8574180uLL);
      CFStringGetCString(v74, v76, 1024, 0x8000100u);
      v77 = v76;
    }
    if (qword_1000EBD40)
      v86 = (FILE *)qword_1000EBD40;
    else
      v86 = __stderrp;
    fprintf(v86, "%s\n", v76);
    if (v77)
      free(v77);
    CFRelease(v74);
    goto LABEL_146;
  }
  if (byte_1000EBD38)
  {
    v61 = *__error();
    v62 = sub_100030318();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
      sub_100086E74();
    *__error() = v61;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
    goto LABEL_147;
  v63 = *__error();
  v64 = sub_1000302B4(a1);
  v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: not monitoring due to tasking-specified sampling"), v64, a1);
  if (v65)
    goto LABEL_110;
  v66 = sub_100030318();
  if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
    sub_100086E0C();
LABEL_142:
  if (qword_1000EBD40)
    v94 = (FILE *)qword_1000EBD40;
  else
    v94 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v94);
LABEL_146:
  *__error() = v63;
LABEL_147:
  v43 |= 0x200000uLL;
LABEL_148:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v102 = *__error();
      v103 = sub_100030318();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v150 = (_DWORD *)v43;
        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "disk writes: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v102;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
      goto LABEL_181;
    v98 = *__error();
    v100 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("disk writes: not monitoring due to conditions %#llx"), v43);
    if (!v100)
    {
      v109 = sub_100030318();
      if (os_log_type_enabled(v109, OS_LOG_TYPE_FAULT))
        sub_100086DAC();
      goto LABEL_176;
    }
LABEL_165:
    v104 = v100;
    v105 = CFStringGetCStringPtr(v100, 0x8000100u);
    if (v105)
    {
      v106 = (char *)v105;
      v107 = 0;
    }
    else
    {
      v106 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2C85B484uLL);
      CFStringGetCString(v104, v106, 1024, 0x8000100u);
      v107 = v106;
    }
    if (qword_1000EBD40)
      v108 = (FILE *)qword_1000EBD40;
    else
      v108 = __stderrp;
    fprintf(v108, "%s\n", v106);
    if (v107)
      free(v107);
    CFRelease(v104);
    goto LABEL_180;
  }
  if (byte_1000EBD38)
  {
    v95 = *__error();
    v96 = sub_100030318();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
    {
      v97 = sub_1000302B4(a1);
      *(_DWORD *)buf = 136446722;
      v150 = v97;
      v151 = 1024;
      *(_DWORD *)v152 = a1;
      *(_WORD *)&v152[4] = 2048;
      *(_QWORD *)&v152[6] = v43;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: disk writes: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v95;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
    goto LABEL_181;
  v98 = *__error();
  v99 = sub_1000302B4(a1);
  v100 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: disk writes: not monitoring due to conditions %#llx"), v99, a1, v43);
  if (v100)
    goto LABEL_165;
  v101 = sub_100030318();
  if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT))
    sub_100086D40();
LABEL_176:
  if (qword_1000EBD40)
    v110 = (FILE *)qword_1000EBD40;
  else
    v110 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v110);
LABEL_180:
  *__error() = v98;
LABEL_181:
  v111 = v148;
  v112 = a8 - a7;
  v113 = a1;
  v114 = v42;
  v115 = v145;
  v116 = v43;
  v117 = a8;
  v118 = (uint64_t)a5;
LABEL_182:
  sub_100031060(v113, v114, v115, v116, v111, v118, v112, v117);
}

void sub_100044DF4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = sub_100042DC0(*(unsigned int *)(a1 + 120), *(void **)(a1 + 32), *(_QWORD *)(a1 + 56), *(void **)(a1 + 40), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 88), *(double *)(a1 + 72), *(double *)(a1 + 80), *(double *)(a1 + 96));
  sub_100031060(*(_DWORD *)(a1 + 120), *(void **)(a1 + 32), *(_QWORD *)(a1 + 104), v2, *(_QWORD *)(a1 + 112) | v3, *(_QWORD *)(a1 + 64), *(double *)(a1 + 80) - *(double *)(a1 + 72), *(double *)(a1 + 80));

}

void sub_100044E58(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7;
  int v13;
  NSObject *v14;
  BOOL v15;
  int v16;
  _DWORD *v17;
  const __CFString *v18;
  NSObject *v19;
  _DWORD *v20;
  const char *v21;
  int v22;
  NSObject *v23;
  BOOL v24;
  _DWORD *v25;
  const __CFString *v26;
  const __CFString *v27;
  mach_port_name_t v28;
  const char *v29;
  malloc_type_id_t v30;
  int v31;
  NSObject *v32;
  BOOL v33;
  char *v34;
  char *v35;
  int v36;
  NSObject *v37;
  BOOL v38;
  const __CFString *v39;
  const __CFString *v40;
  id v41;
  uint64_t v42;
  uint64_t v43;
  mach_port_name_t v44;
  const char *CStringPtr;
  char *v46;
  char *v47;
  _DWORD *v48;
  FILE *v49;
  NSObject *v50;
  uint64_t v51;
  FILE *v52;
  FILE *v53;
  NSObject *v54;
  FILE *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  int v60;
  _DWORD *v61;
  const __CFString *v62;
  NSObject *v63;
  int v64;
  NSObject *v65;
  const __CFString *v66;
  uint64_t v67;
  uint64_t v68;
  mach_port_name_t v69;
  const char *v70;
  char *v71;
  char *v72;
  FILE *v73;
  NSObject *v74;
  FILE *v75;
  int v76;
  NSObject *v77;
  _DWORD *v78;
  int v79;
  _DWORD *v80;
  const __CFString *v81;
  NSObject *v82;
  int v83;
  NSObject *v84;
  const __CFString *v85;
  id v86;
  uint64_t v87;
  uint64_t v88;
  mach_port_name_t v89;
  const char *v90;
  char *v91;
  char *v92;
  FILE *v93;
  NSObject *v94;
  FILE *v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  _QWORD v100[9];
  int v101;
  uint64_t v102;
  uint8_t buf[4];
  _DWORD *v104;
  __int16 v105;
  _BYTE v106[14];
  __int16 v107;
  uint64_t v108;

  v7 = a7;
  v96 = a4;
  v98 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v36 = *__error();
        v37 = sub_100030318();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          v104 = (_DWORD *)a5;
          v105 = 2048;
          *(_QWORD *)v106 = a3;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "file descriptor exhaustion: %llu fds with flags %#llx", buf, 0x16u);
        }
        *__error() = v36;
      }
      if (byte_1000EBD39)
        v38 = dword_1000EB4E8 <= 1;
      else
        v38 = 0;
      if (v38)
      {
        v16 = *__error();
        v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("file descriptor exhaustion: %llu fds with flags %#llx"), a5, a3);
        if (v39)
        {
          v40 = v39;
          v41 = a2;
          v42 = a5;
          v43 = a6;
          v44 = v7;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (CStringPtr)
          {
            v46 = (char *)CStringPtr;
            v47 = 0;
          }
          else
          {
            v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x953BAB27uLL);
            CFStringGetCString(v40, v46, 1024, 0x8000100u);
            v47 = v46;
          }
          if (qword_1000EBD40)
            v55 = (FILE *)qword_1000EBD40;
          else
            v55 = __stderrp;
          fprintf(v55, "%s\n", v46);
          if (v47)
            free(v47);
          CFRelease(v40);
          v7 = v44;
          a6 = v43;
          a5 = v42;
          a2 = v41;
          goto LABEL_80;
        }
        v54 = sub_100030318();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
          sub_10008746C();
        v51 = qword_1000EBD40;
        v52 = __stderrp;
        goto LABEL_66;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v22 = *__error();
        v23 = sub_100030318();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          v104 = sub_1000302B4(a1);
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%{public}s [%d]: file descriptor exhaustion: %llu fds with flags %#llx", buf, 0x26u);
        }
        *__error() = v22;
      }
      if (byte_1000EBD39)
        v24 = dword_1000EB4E8 <= 1;
      else
        v24 = 0;
      if (v24)
      {
        v16 = *__error();
        v25 = sub_1000302B4(a1);
        v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: file descriptor exhaustion: %llu fds with flags %#llx"), v25, a1, a5, a3, v96);
        if (!v26)
        {
          v19 = sub_100030318();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            v48 = sub_1000302B4(a1);
            *(_DWORD *)buf = 136315906;
            v104 = v48;
            v105 = 1024;
            *(_DWORD *)v106 = a1;
            *(_WORD *)&v106[4] = 2048;
            *(_QWORD *)&v106[6] = a5;
            v107 = 2048;
            v108 = a3;
            v21 = "Unable to format: %s [%d]: file descriptor exhaustion: %llu fds with flags %#llx";
            goto LABEL_54;
          }
LABEL_65:
          v51 = qword_1000EBD40;
          v52 = __stderrp;
LABEL_66:
          if (v51)
            v53 = (FILE *)v51;
          else
            v53 = v52;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
LABEL_80:
          *__error() = v16;
          goto LABEL_81;
        }
        v27 = v26;
        v28 = v7;
        v29 = CFStringGetCStringPtr(v26, 0x8000100u);
        if (v29)
          goto LABEL_39;
        v30 = 2503715623;
        goto LABEL_56;
      }
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v13 = *__error();
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          v104 = sub_1000302B4(a1);
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "%{public}s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx", buf, 0x26u);
        }
        *__error() = v13;
      }
      if (byte_1000EBD39)
        v15 = dword_1000EB4E8 <= 1;
      else
        v15 = 0;
      if (!v15)
        goto LABEL_81;
      v16 = *__error();
      v17 = sub_1000302B4(a1);
      v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx"), v17, a1, a5, a3, v96);
      if (!v18)
      {
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          v20 = sub_1000302B4(a1);
          *(_DWORD *)buf = 136315906;
          v104 = v20;
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          v21 = "Unable to format: %s [%d]: file descriptor exhaustion: fatal, %llu fds with flags %#llx";
LABEL_54:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_65;
        }
        goto LABEL_65;
      }
      goto LABEL_38;
    }
    if (byte_1000EBD38)
    {
      v31 = *__error();
      v32 = sub_100030318();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        v104 = (_DWORD *)a5;
        v105 = 2048;
        *(_QWORD *)v106 = a3;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "file descriptor exhaustion: fatal, %llu fds with flags %#llx", buf, 0x16u);
      }
      *__error() = v31;
    }
    if (byte_1000EBD39)
      v33 = dword_1000EB4E8 <= 1;
    else
      v33 = 0;
    if (v33)
    {
      v16 = *__error();
      v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("file descriptor exhaustion: fatal, %llu fds with flags %#llx"), a5, a3);
      if (!v18)
      {
        v50 = sub_100030318();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
          sub_10008740C();
        goto LABEL_65;
      }
LABEL_38:
      v27 = v18;
      v28 = v7;
      v29 = CFStringGetCStringPtr(v18, 0x8000100u);
      if (v29)
      {
LABEL_39:
        v34 = (char *)v29;
        v35 = 0;
LABEL_57:
        if (qword_1000EBD40)
          v49 = (FILE *)qword_1000EBD40;
        else
          v49 = __stderrp;
        fprintf(v49, "%s\n", v34);
        if (v35)
          free(v35);
        CFRelease(v27);
        v7 = v28;
        goto LABEL_80;
      }
      v30 = 1282746773;
LABEL_56:
      v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
      CFStringGetCString(v27, v34, 1024, 0x8000100u);
      v35 = v34;
      goto LABEL_57;
    }
  }
LABEL_81:
  v99 = sub_10003038C(a1);
  if (!a2)
    a2 = sub_1000303D0(a1);
  v102 = 0;
  v56 = sub_100042198(a1, (uint64_t)"file descriptor exhaustion", 176, &v102);
  v57 = v56;
  if ((word_1000EBD78 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          sub_1000873E0();
        *__error() = v64;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_119;
      v60 = *__error();
      v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("file descriptor exhaustion: not monitoring due to suppression cookie file"));
      if (!v62)
      {
        v74 = sub_100030318();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
          sub_1000873B4();
        goto LABEL_114;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v58 = *__error();
        v59 = sub_100030318();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
          sub_10008734C();
        *__error() = v58;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_119;
      v60 = *__error();
      v61 = sub_1000302B4(a1);
      v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: file descriptor exhaustion: not monitoring due to suppression cookie file"), v61, a1);
      if (!v62)
      {
        v63 = sub_100030318();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT))
          sub_1000872E4();
LABEL_114:
        if (qword_1000EBD40)
          v75 = (FILE *)qword_1000EBD40;
        else
          v75 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
LABEL_118:
        *__error() = v60;
LABEL_119:
        v57 |= 0x8000uLL;
        goto LABEL_120;
      }
    }
    v66 = v62;
    v97 = v60;
    v67 = a5;
    v68 = a6;
    v69 = v7;
    v70 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v70)
    {
      v71 = (char *)v70;
      v72 = 0;
    }
    else
    {
      v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6A427206uLL);
      CFStringGetCString(v66, v71, 1024, 0x8000100u);
      v72 = v71;
    }
    if (qword_1000EBD40)
      v73 = (FILE *)qword_1000EBD40;
    else
      v73 = __stderrp;
    fprintf(v73, "%s\n", v71);
    if (v72)
      free(v72);
    CFRelease(v66);
    v7 = v69;
    a6 = v68;
    a5 = v67;
    v60 = v97;
    goto LABEL_118;
  }
  if (!v56)
  {
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 3221225472;
    v100[2] = sub_100045B88;
    v100[3] = &unk_1000DD008;
    v101 = a1;
    v100[4] = a2;
    v100[5] = v99;
    v100[6] = v102;
    v100[7] = a5;
    v100[8] = a6;
    sub_100053878(0, a1, (uint64_t)a2, a3, v96, a5, a6, v7, (uint64_t)v100);
    return;
  }
LABEL_120:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v83 = *__error();
      v84 = sub_100030318();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v104 = (_DWORD *)v57;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "file descriptor exhaustion: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v83;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
      goto LABEL_153;
    v79 = *__error();
    v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("file descriptor exhaustion: not monitoring due to conditions %#llx"), v57);
    if (!v81)
    {
      v94 = sub_100030318();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
        sub_100087284();
      goto LABEL_148;
    }
LABEL_137:
    v85 = v81;
    v86 = a2;
    v87 = a5;
    v88 = a6;
    v89 = v7;
    v90 = CFStringGetCStringPtr(v81, 0x8000100u);
    if (v90)
    {
      v91 = (char *)v90;
      v92 = 0;
    }
    else
    {
      v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4AB5E98uLL);
      CFStringGetCString(v85, v91, 1024, 0x8000100u);
      v92 = v91;
    }
    if (qword_1000EBD40)
      v93 = (FILE *)qword_1000EBD40;
    else
      v93 = __stderrp;
    fprintf(v93, "%s\n", v91);
    if (v92)
      free(v92);
    CFRelease(v85);
    v7 = v89;
    a6 = v88;
    a5 = v87;
    a2 = v86;
    goto LABEL_152;
  }
  if (byte_1000EBD38)
  {
    v76 = *__error();
    v77 = sub_100030318();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      v78 = sub_1000302B4(a1);
      *(_DWORD *)buf = 136446722;
      v104 = v78;
      v105 = 1024;
      *(_DWORD *)v106 = a1;
      *(_WORD *)&v106[4] = 2048;
      *(_QWORD *)&v106[6] = v57;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v76;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
    goto LABEL_153;
  v79 = *__error();
  v80 = sub_1000302B4(a1);
  v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx"), v80, a1, v57);
  if (v81)
    goto LABEL_137;
  v82 = sub_100030318();
  if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
    sub_100087218();
LABEL_148:
  if (qword_1000EBD40)
    v95 = (FILE *)qword_1000EBD40;
  else
    v95 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
LABEL_152:
  *__error() = v79;
LABEL_153:
  sub_1000313E0(a1, a2, v99, v57, v102, a5, a6);
  if (v98 <= 0xFFFFFFFD)
    sub_1000554DC(0, a1, v7);
}

void sub_100045B88(uint64_t a1, uint64_t a2)
{
  sub_1000313E0(*(_DWORD *)(a1 + 72), *(void **)(a1 + 32), *(_QWORD *)(a1 + 40), a2, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
}

void sub_100045BA4(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7;
  int v13;
  NSObject *v14;
  BOOL v15;
  int v16;
  _DWORD *v17;
  const __CFString *v18;
  NSObject *v19;
  _DWORD *v20;
  const char *v21;
  int v22;
  NSObject *v23;
  BOOL v24;
  _DWORD *v25;
  const __CFString *v26;
  const __CFString *v27;
  mach_port_name_t v28;
  const char *v29;
  malloc_type_id_t v30;
  int v31;
  NSObject *v32;
  BOOL v33;
  char *v34;
  char *v35;
  int v36;
  NSObject *v37;
  BOOL v38;
  const __CFString *v39;
  const __CFString *v40;
  id v41;
  uint64_t v42;
  uint64_t v43;
  mach_port_name_t v44;
  const char *CStringPtr;
  char *v46;
  char *v47;
  _DWORD *v48;
  FILE *v49;
  NSObject *v50;
  uint64_t v51;
  FILE *v52;
  FILE *v53;
  NSObject *v54;
  FILE *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  int v60;
  _DWORD *v61;
  const __CFString *v62;
  NSObject *v63;
  int v64;
  NSObject *v65;
  const __CFString *v66;
  uint64_t v67;
  uint64_t v68;
  mach_port_name_t v69;
  const char *v70;
  char *v71;
  char *v72;
  FILE *v73;
  NSObject *v74;
  FILE *v75;
  int v76;
  NSObject *v77;
  _DWORD *v78;
  int v79;
  _DWORD *v80;
  const __CFString *v81;
  NSObject *v82;
  int v83;
  NSObject *v84;
  const __CFString *v85;
  id v86;
  uint64_t v87;
  uint64_t v88;
  mach_port_name_t v89;
  const char *v90;
  char *v91;
  char *v92;
  FILE *v93;
  NSObject *v94;
  FILE *v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  _QWORD v100[9];
  int v101;
  uint64_t v102;
  uint8_t buf[4];
  _DWORD *v104;
  __int16 v105;
  _BYTE v106[14];
  __int16 v107;
  uint64_t v108;

  v7 = a7;
  v96 = a4;
  v98 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v36 = *__error();
        v37 = sub_100030318();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          v104 = (_DWORD *)a5;
          v105 = 2048;
          *(_QWORD *)v106 = a3;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "port exhaustion: %llu ports with flags %#llx", buf, 0x16u);
        }
        *__error() = v36;
      }
      if (byte_1000EBD39)
        v38 = dword_1000EB4E8 <= 1;
      else
        v38 = 0;
      if (v38)
      {
        v16 = *__error();
        v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("port exhaustion: %llu ports with flags %#llx"), a5, a3);
        if (v39)
        {
          v40 = v39;
          v41 = a2;
          v42 = a5;
          v43 = a6;
          v44 = v7;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (CStringPtr)
          {
            v46 = (char *)CStringPtr;
            v47 = 0;
          }
          else
          {
            v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x43989D7DuLL);
            CFStringGetCString(v40, v46, 1024, 0x8000100u);
            v47 = v46;
          }
          if (qword_1000EBD40)
            v55 = (FILE *)qword_1000EBD40;
          else
            v55 = __stderrp;
          fprintf(v55, "%s\n", v46);
          if (v47)
            free(v47);
          CFRelease(v40);
          v7 = v44;
          a6 = v43;
          a5 = v42;
          a2 = v41;
          goto LABEL_80;
        }
        v54 = sub_100030318();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
          sub_100087720();
        v51 = qword_1000EBD40;
        v52 = __stderrp;
        goto LABEL_66;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v22 = *__error();
        v23 = sub_100030318();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          v104 = sub_1000302B4(a1);
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%{public}s [%d]: port exhaustion: %llu ports with flags %#llx", buf, 0x26u);
        }
        *__error() = v22;
      }
      if (byte_1000EBD39)
        v24 = dword_1000EB4E8 <= 1;
      else
        v24 = 0;
      if (v24)
      {
        v16 = *__error();
        v25 = sub_1000302B4(a1);
        v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: port exhaustion: %llu ports with flags %#llx"), v25, a1, a5, a3, v96);
        if (!v26)
        {
          v19 = sub_100030318();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            v48 = sub_1000302B4(a1);
            *(_DWORD *)buf = 136315906;
            v104 = v48;
            v105 = 1024;
            *(_DWORD *)v106 = a1;
            *(_WORD *)&v106[4] = 2048;
            *(_QWORD *)&v106[6] = a5;
            v107 = 2048;
            v108 = a3;
            v21 = "Unable to format: %s [%d]: port exhaustion: %llu ports with flags %#llx";
            goto LABEL_54;
          }
LABEL_65:
          v51 = qword_1000EBD40;
          v52 = __stderrp;
LABEL_66:
          if (v51)
            v53 = (FILE *)v51;
          else
            v53 = v52;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
LABEL_80:
          *__error() = v16;
          goto LABEL_81;
        }
        v27 = v26;
        v28 = v7;
        v29 = CFStringGetCStringPtr(v26, 0x8000100u);
        if (v29)
          goto LABEL_39;
        v30 = 1134075261;
        goto LABEL_56;
      }
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v13 = *__error();
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          v104 = sub_1000302B4(a1);
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "%{public}s [%d]: port exhaustion: fatal, %llu ports with flags %#llx", buf, 0x26u);
        }
        *__error() = v13;
      }
      if (byte_1000EBD39)
        v15 = dword_1000EB4E8 <= 1;
      else
        v15 = 0;
      if (!v15)
        goto LABEL_81;
      v16 = *__error();
      v17 = sub_1000302B4(a1);
      v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: port exhaustion: fatal, %llu ports with flags %#llx"), v17, a1, a5, a3, v96);
      if (!v18)
      {
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          v20 = sub_1000302B4(a1);
          *(_DWORD *)buf = 136315906;
          v104 = v20;
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          v21 = "Unable to format: %s [%d]: port exhaustion: fatal, %llu ports with flags %#llx";
LABEL_54:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_65;
        }
        goto LABEL_65;
      }
      goto LABEL_38;
    }
    if (byte_1000EBD38)
    {
      v31 = *__error();
      v32 = sub_100030318();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        v104 = (_DWORD *)a5;
        v105 = 2048;
        *(_QWORD *)v106 = a3;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "port exhaustion: fatal, %llu ports with flags %#llx", buf, 0x16u);
      }
      *__error() = v31;
    }
    if (byte_1000EBD39)
      v33 = dword_1000EB4E8 <= 1;
    else
      v33 = 0;
    if (v33)
    {
      v16 = *__error();
      v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("port exhaustion: fatal, %llu ports with flags %#llx"), a5, a3);
      if (!v18)
      {
        v50 = sub_100030318();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
          sub_1000876C0();
        goto LABEL_65;
      }
LABEL_38:
      v27 = v18;
      v28 = v7;
      v29 = CFStringGetCStringPtr(v18, 0x8000100u);
      if (v29)
      {
LABEL_39:
        v34 = (char *)v29;
        v35 = 0;
LABEL_57:
        if (qword_1000EBD40)
          v49 = (FILE *)qword_1000EBD40;
        else
          v49 = __stderrp;
        fprintf(v49, "%s\n", v34);
        if (v35)
          free(v35);
        CFRelease(v27);
        v7 = v28;
        goto LABEL_80;
      }
      v30 = 3931054884;
LABEL_56:
      v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
      CFStringGetCString(v27, v34, 1024, 0x8000100u);
      v35 = v34;
      goto LABEL_57;
    }
  }
LABEL_81:
  v99 = sub_10003038C(a1);
  if (!a2)
    a2 = sub_1000303D0(a1);
  v102 = 0;
  v56 = sub_100042198(a1, (uint64_t)"port exhaustion", 176, &v102);
  v57 = v56;
  if ((word_1000EBD78 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          sub_100087694();
        *__error() = v64;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_119;
      v60 = *__error();
      v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("port exhaustion: not monitoring due to suppression cookie file"));
      if (!v62)
      {
        v74 = sub_100030318();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
          sub_100087668();
        goto LABEL_114;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v58 = *__error();
        v59 = sub_100030318();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
          sub_100087600();
        *__error() = v58;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_119;
      v60 = *__error();
      v61 = sub_1000302B4(a1);
      v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: port exhaustion: not monitoring due to suppression cookie file"), v61, a1);
      if (!v62)
      {
        v63 = sub_100030318();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT))
          sub_100087598();
LABEL_114:
        if (qword_1000EBD40)
          v75 = (FILE *)qword_1000EBD40;
        else
          v75 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
LABEL_118:
        *__error() = v60;
LABEL_119:
        v57 |= 0x8000uLL;
        goto LABEL_120;
      }
    }
    v66 = v62;
    v97 = v60;
    v67 = a5;
    v68 = a6;
    v69 = v7;
    v70 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v70)
    {
      v71 = (char *)v70;
      v72 = 0;
    }
    else
    {
      v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x59D043D0uLL);
      CFStringGetCString(v66, v71, 1024, 0x8000100u);
      v72 = v71;
    }
    if (qword_1000EBD40)
      v73 = (FILE *)qword_1000EBD40;
    else
      v73 = __stderrp;
    fprintf(v73, "%s\n", v71);
    if (v72)
      free(v72);
    CFRelease(v66);
    v7 = v69;
    a6 = v68;
    a5 = v67;
    v60 = v97;
    goto LABEL_118;
  }
  if (!v56)
  {
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 3221225472;
    v100[2] = sub_1000468D4;
    v100[3] = &unk_1000DD008;
    v101 = a1;
    v100[4] = a2;
    v100[5] = v99;
    v100[6] = v102;
    v100[7] = a5;
    v100[8] = a6;
    sub_100053878(1, a1, (uint64_t)a2, a3, v96, a5, a6, v7, (uint64_t)v100);
    return;
  }
LABEL_120:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v83 = *__error();
      v84 = sub_100030318();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v104 = (_DWORD *)v57;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "port exhaustion: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v83;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
      goto LABEL_153;
    v79 = *__error();
    v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("port exhaustion: not monitoring due to conditions %#llx"), v57);
    if (!v81)
    {
      v94 = sub_100030318();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
        sub_100087538();
      goto LABEL_148;
    }
LABEL_137:
    v85 = v81;
    v86 = a2;
    v87 = a5;
    v88 = a6;
    v89 = v7;
    v90 = CFStringGetCStringPtr(v81, 0x8000100u);
    if (v90)
    {
      v91 = (char *)v90;
      v92 = 0;
    }
    else
    {
      v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB0275F09uLL);
      CFStringGetCString(v85, v91, 1024, 0x8000100u);
      v92 = v91;
    }
    if (qword_1000EBD40)
      v93 = (FILE *)qword_1000EBD40;
    else
      v93 = __stderrp;
    fprintf(v93, "%s\n", v91);
    if (v92)
      free(v92);
    CFRelease(v85);
    v7 = v89;
    a6 = v88;
    a5 = v87;
    a2 = v86;
    goto LABEL_152;
  }
  if (byte_1000EBD38)
  {
    v76 = *__error();
    v77 = sub_100030318();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      v78 = sub_1000302B4(a1);
      *(_DWORD *)buf = 136446722;
      v104 = v78;
      v105 = 1024;
      *(_DWORD *)v106 = a1;
      *(_WORD *)&v106[4] = 2048;
      *(_QWORD *)&v106[6] = v57;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: port exhaustion: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v76;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
    goto LABEL_153;
  v79 = *__error();
  v80 = sub_1000302B4(a1);
  v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: port exhaustion: not monitoring due to conditions %#llx"), v80, a1, v57);
  if (v81)
    goto LABEL_137;
  v82 = sub_100030318();
  if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
    sub_1000874CC();
LABEL_148:
  if (qword_1000EBD40)
    v95 = (FILE *)qword_1000EBD40;
  else
    v95 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
LABEL_152:
  *__error() = v79;
LABEL_153:
  sub_1000316D0(a1, a2, v99, v57, v102, a5, a6);
  if (v98 <= 0xFFFFFFFD)
    sub_1000554DC(1, a1, v7);
}

void sub_1000468D4(uint64_t a1, uint64_t a2)
{
  sub_1000316D0(*(_DWORD *)(a1 + 72), *(void **)(a1 + 32), *(_QWORD *)(a1 + 40), a2, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
}

void sub_1000468F0(uint64_t a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, mach_port_name_t a7)
{
  mach_port_name_t v7;
  int v13;
  NSObject *v14;
  BOOL v15;
  int v16;
  _DWORD *v17;
  const __CFString *v18;
  NSObject *v19;
  _DWORD *v20;
  const char *v21;
  int v22;
  NSObject *v23;
  BOOL v24;
  _DWORD *v25;
  const __CFString *v26;
  const __CFString *v27;
  mach_port_name_t v28;
  const char *v29;
  malloc_type_id_t v30;
  int v31;
  NSObject *v32;
  BOOL v33;
  char *v34;
  char *v35;
  int v36;
  NSObject *v37;
  BOOL v38;
  const __CFString *v39;
  const __CFString *v40;
  id v41;
  uint64_t v42;
  uint64_t v43;
  mach_port_name_t v44;
  const char *CStringPtr;
  char *v46;
  char *v47;
  _DWORD *v48;
  FILE *v49;
  NSObject *v50;
  uint64_t v51;
  FILE *v52;
  FILE *v53;
  NSObject *v54;
  FILE *v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  NSObject *v59;
  int v60;
  _DWORD *v61;
  const __CFString *v62;
  NSObject *v63;
  int v64;
  NSObject *v65;
  const __CFString *v66;
  uint64_t v67;
  uint64_t v68;
  mach_port_name_t v69;
  const char *v70;
  char *v71;
  char *v72;
  FILE *v73;
  NSObject *v74;
  FILE *v75;
  int v76;
  NSObject *v77;
  _DWORD *v78;
  int v79;
  _DWORD *v80;
  const __CFString *v81;
  NSObject *v82;
  int v83;
  NSObject *v84;
  const __CFString *v85;
  id v86;
  uint64_t v87;
  uint64_t v88;
  mach_port_name_t v89;
  const char *v90;
  char *v91;
  char *v92;
  FILE *v93;
  NSObject *v94;
  FILE *v95;
  uint64_t v96;
  int v97;
  unsigned int v98;
  uint64_t v99;
  _QWORD v100[9];
  int v101;
  uint64_t v102;
  uint8_t buf[4];
  _DWORD *v104;
  __int16 v105;
  _BYTE v106[14];
  __int16 v107;
  uint64_t v108;

  v7 = a7;
  v96 = a4;
  v98 = a7 - 1;
  if (a7 - 1 > 0xFFFFFFFD)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v36 = *__error();
        v37 = sub_100030318();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 134218240;
          v104 = (_DWORD *)a5;
          v105 = 2048;
          *(_QWORD *)v106 = a3;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_INFO, "kqworkloop exhaustion: %llu kqworkloops with flags %#llx", buf, 0x16u);
        }
        *__error() = v36;
      }
      if (byte_1000EBD39)
        v38 = dword_1000EB4E8 <= 1;
      else
        v38 = 0;
      if (v38)
      {
        v16 = *__error();
        v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("kqworkloop exhaustion: %llu kqworkloops with flags %#llx"), a5, a3);
        if (v39)
        {
          v40 = v39;
          v41 = a2;
          v42 = a5;
          v43 = a6;
          v44 = v7;
          CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
          if (CStringPtr)
          {
            v46 = (char *)CStringPtr;
            v47 = 0;
          }
          else
          {
            v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC992F941uLL);
            CFStringGetCString(v40, v46, 1024, 0x8000100u);
            v47 = v46;
          }
          if (qword_1000EBD40)
            v55 = (FILE *)qword_1000EBD40;
          else
            v55 = __stderrp;
          fprintf(v55, "%s\n", v46);
          if (v47)
            free(v47);
          CFRelease(v40);
          v7 = v44;
          a6 = v43;
          a5 = v42;
          a2 = v41;
          goto LABEL_80;
        }
        v54 = sub_100030318();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
          sub_1000879D4();
        v51 = qword_1000EBD40;
        v52 = __stderrp;
        goto LABEL_66;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v22 = *__error();
        v23 = sub_100030318();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          v104 = sub_1000302B4(a1);
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_INFO, "%{public}s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx", buf, 0x26u);
        }
        *__error() = v22;
      }
      if (byte_1000EBD39)
        v24 = dword_1000EB4E8 <= 1;
      else
        v24 = 0;
      if (v24)
      {
        v16 = *__error();
        v25 = sub_1000302B4(a1);
        v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx"), v25, a1, a5, a3, v96);
        if (!v26)
        {
          v19 = sub_100030318();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          {
            v48 = sub_1000302B4(a1);
            *(_DWORD *)buf = 136315906;
            v104 = v48;
            v105 = 1024;
            *(_DWORD *)v106 = a1;
            *(_WORD *)&v106[4] = 2048;
            *(_QWORD *)&v106[6] = a5;
            v107 = 2048;
            v108 = a3;
            v21 = "Unable to format: %s [%d]: kqworkloop exhaustion: %llu kqworkloops with flags %#llx";
            goto LABEL_54;
          }
LABEL_65:
          v51 = qword_1000EBD40;
          v52 = __stderrp;
LABEL_66:
          if (v51)
            v53 = (FILE *)v51;
          else
            v53 = v52;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v53);
LABEL_80:
          *__error() = v16;
          goto LABEL_81;
        }
        v27 = v26;
        v28 = v7;
        v29 = CFStringGetCStringPtr(v26, 0x8000100u);
        if (v29)
          goto LABEL_39;
        v30 = 3381852481;
        goto LABEL_56;
      }
    }
  }
  else
  {
    if ((a1 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v13 = *__error();
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136446978;
          v104 = sub_1000302B4(a1);
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_INFO, "%{public}s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", buf, 0x26u);
        }
        *__error() = v13;
      }
      if (byte_1000EBD39)
        v15 = dword_1000EB4E8 <= 1;
      else
        v15 = 0;
      if (!v15)
        goto LABEL_81;
      v16 = *__error();
      v17 = sub_1000302B4(a1);
      v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx"), v17, a1, a5, a3, v96);
      if (!v18)
      {
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        {
          v20 = sub_1000302B4(a1);
          *(_DWORD *)buf = 136315906;
          v104 = v20;
          v105 = 1024;
          *(_DWORD *)v106 = a1;
          *(_WORD *)&v106[4] = 2048;
          *(_QWORD *)&v106[6] = a5;
          v107 = 2048;
          v108 = a3;
          v21 = "Unable to format: %s [%d]: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx";
LABEL_54:
          _os_log_fault_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v21, buf, 0x26u);
          goto LABEL_65;
        }
        goto LABEL_65;
      }
      goto LABEL_38;
    }
    if (byte_1000EBD38)
    {
      v31 = *__error();
      v32 = sub_100030318();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 134218240;
        v104 = (_DWORD *)a5;
        v105 = 2048;
        *(_QWORD *)v106 = a3;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", buf, 0x16u);
      }
      *__error() = v31;
    }
    if (byte_1000EBD39)
      v33 = dword_1000EB4E8 <= 1;
    else
      v33 = 0;
    if (v33)
    {
      v16 = *__error();
      v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx"), a5, a3);
      if (!v18)
      {
        v50 = sub_100030318();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
          sub_100087974();
        goto LABEL_65;
      }
LABEL_38:
      v27 = v18;
      v28 = v7;
      v29 = CFStringGetCStringPtr(v18, 0x8000100u);
      if (v29)
      {
LABEL_39:
        v34 = (char *)v29;
        v35 = 0;
LABEL_57:
        if (qword_1000EBD40)
          v49 = (FILE *)qword_1000EBD40;
        else
          v49 = __stderrp;
        fprintf(v49, "%s\n", v34);
        if (v35)
          free(v35);
        CFRelease(v27);
        v7 = v28;
        goto LABEL_80;
      }
      v30 = 3744613335;
LABEL_56:
      v34 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
      CFStringGetCString(v27, v34, 1024, 0x8000100u);
      v35 = v34;
      goto LABEL_57;
    }
  }
LABEL_81:
  v99 = sub_10003038C(a1);
  if (!a2)
    a2 = sub_1000303D0(a1);
  v102 = 0;
  v56 = sub_100042198(a1, (uint64_t)"kqworkloop exhaustion", 176, &v102);
  v57 = v56;
  if ((word_1000EBD78 & 4) != 0)
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          sub_100087948();
        *__error() = v64;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_119;
      v60 = *__error();
      v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("kqworkloop exhaustion: not monitoring due to suppression cookie file"));
      if (!v62)
      {
        v74 = sub_100030318();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
          sub_10008791C();
        goto LABEL_114;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v58 = *__error();
        v59 = sub_100030318();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
          sub_1000878B4();
        *__error() = v58;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_119;
      v60 = *__error();
      v61 = sub_1000302B4(a1);
      v62 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file"), v61, a1);
      if (!v62)
      {
        v63 = sub_100030318();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT))
          sub_10008784C();
LABEL_114:
        if (qword_1000EBD40)
          v75 = (FILE *)qword_1000EBD40;
        else
          v75 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
LABEL_118:
        *__error() = v60;
LABEL_119:
        v57 |= 0x8000uLL;
        goto LABEL_120;
      }
    }
    v66 = v62;
    v97 = v60;
    v67 = a5;
    v68 = a6;
    v69 = v7;
    v70 = CFStringGetCStringPtr(v62, 0x8000100u);
    if (v70)
    {
      v71 = (char *)v70;
      v72 = 0;
    }
    else
    {
      v71 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC069E135uLL);
      CFStringGetCString(v66, v71, 1024, 0x8000100u);
      v72 = v71;
    }
    if (qword_1000EBD40)
      v73 = (FILE *)qword_1000EBD40;
    else
      v73 = __stderrp;
    fprintf(v73, "%s\n", v71);
    if (v72)
      free(v72);
    CFRelease(v66);
    v7 = v69;
    a6 = v68;
    a5 = v67;
    v60 = v97;
    goto LABEL_118;
  }
  if (!v56)
  {
    v100[0] = _NSConcreteStackBlock;
    v100[1] = 3221225472;
    v100[2] = sub_100047620;
    v100[3] = &unk_1000DD008;
    v101 = a1;
    v100[4] = a2;
    v100[5] = v99;
    v100[6] = v102;
    v100[7] = a5;
    v100[8] = a6;
    sub_100053878(2, a1, (uint64_t)a2, a3, v96, a5, a6, v7, (uint64_t)v100);
    return;
  }
LABEL_120:
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v83 = *__error();
      v84 = sub_100030318();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134217984;
        v104 = (_DWORD *)v57;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "kqworkloop exhaustion: not monitoring due to conditions %#llx", buf, 0xCu);
      }
      *__error() = v83;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
      goto LABEL_153;
    v79 = *__error();
    v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("kqworkloop exhaustion: not monitoring due to conditions %#llx"), v57);
    if (!v81)
    {
      v94 = sub_100030318();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
        sub_1000877EC();
      goto LABEL_148;
    }
LABEL_137:
    v85 = v81;
    v86 = a2;
    v87 = a5;
    v88 = a6;
    v89 = v7;
    v90 = CFStringGetCStringPtr(v81, 0x8000100u);
    if (v90)
    {
      v91 = (char *)v90;
      v92 = 0;
    }
    else
    {
      v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1DC71713uLL);
      CFStringGetCString(v85, v91, 1024, 0x8000100u);
      v92 = v91;
    }
    if (qword_1000EBD40)
      v93 = (FILE *)qword_1000EBD40;
    else
      v93 = __stderrp;
    fprintf(v93, "%s\n", v91);
    if (v92)
      free(v92);
    CFRelease(v85);
    v7 = v89;
    a6 = v88;
    a5 = v87;
    a2 = v86;
    goto LABEL_152;
  }
  if (byte_1000EBD38)
  {
    v76 = *__error();
    v77 = sub_100030318();
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      v78 = sub_1000302B4(a1);
      *(_DWORD *)buf = 136446722;
      v104 = v78;
      v105 = 1024;
      *(_DWORD *)v106 = a1;
      *(_WORD *)&v106[4] = 2048;
      *(_QWORD *)&v106[6] = v57;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx", buf, 0x1Cu);
    }
    *__error() = v76;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
    goto LABEL_153;
  v79 = *__error();
  v80 = sub_1000302B4(a1);
  v81 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx"), v80, a1, v57);
  if (v81)
    goto LABEL_137;
  v82 = sub_100030318();
  if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
    sub_100087780();
LABEL_148:
  if (qword_1000EBD40)
    v95 = (FILE *)qword_1000EBD40;
  else
    v95 = __stderrp;
  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v95);
LABEL_152:
  *__error() = v79;
LABEL_153:
  sub_1000319C0(a1, a2, v99, v57, v102, a5, a6);
  if (v98 <= 0xFFFFFFFD)
    sub_1000554DC(2, a1, v7);
}

void sub_100047620(uint64_t a1, uint64_t a2)
{
  sub_1000319C0(*(_DWORD *)(a1 + 72), *(void **)(a1 + 32), *(_QWORD *)(a1 + 40), a2, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
}

void sub_10004763C(uint64_t a1)
{
  size_t v2;
  char *v3;
  unint64_t v4;
  size_t v5;
  ssize_t v6;
  int v7;
  NSObject *v8;
  BOOL v9;
  int v10;
  uint64_t v11;
  int *v12;
  char *v13;
  const __CFString *v14;
  const __CFString *v15;
  const char *CStringPtr;
  char *v17;
  char *v18;
  NSObject *v19;
  FILE *v20;
  FILE *v21;
  char *v22;
  const char *v23;
  char *v24;
  void (*v25)(void);
  int v26;
  NSObject *v27;
  int v28;
  const __CFString *v29;
  const __CFString *v30;
  const char *v31;
  malloc_type_id_t v32;
  int v33;
  NSObject *v34;
  const __CFString *v35;
  int v36;
  NSObject *v37;
  const __CFString *v38;
  char *v39;
  char *v40;
  NSObject *v41;
  NSObject *v42;
  NSObject *v43;
  FILE *v44;
  FILE *v45;

  while (waitpid(*(_DWORD *)(a1 + 48), 0, 0) == -1 && *__error() == 4)
    ;
  v2 = 0x4000;
  v3 = (char *)malloc_type_malloc(0x4000uLL, 0x9C4D967BuLL);
  v4 = 0;
  do
  {
    v5 = v4;
    if (v2 - 1 <= v4)
    {
      v2 *= 2;
      v3 = (char *)reallocf(v3, v2);
    }
    v6 = read(*(_DWORD *)(a1 + 52), &v3[v5], v2 + ~v5);
    v4 = v6 + v5;
  }
  while (v6 > 0);
  if (v6 < 0)
  {
    if (byte_1000EBD38)
    {
      v7 = *__error();
      v8 = sub_100030318();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100087CE4();
      *__error() = v7;
    }
    if (byte_1000EBD39)
      v9 = dword_1000EB4E8 <= 3;
    else
      v9 = 0;
    if (v9)
    {
      v10 = *__error();
      v11 = *__error();
      v12 = __error();
      v13 = strerror(*v12);
      v14 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("read from child returned error: %d (%s)"), v11, v13);
      if (v14)
      {
        v15 = v14;
        CStringPtr = CFStringGetCStringPtr(v14, 0x8000100u);
        if (CStringPtr)
        {
          v17 = (char *)CStringPtr;
          v18 = 0;
        }
        else
        {
          v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE9084DA6uLL);
          CFStringGetCString(v15, v17, 1024, 0x8000100u);
          v18 = v17;
        }
        if (qword_1000EBD40)
          v21 = (FILE *)qword_1000EBD40;
        else
          v21 = __stderrp;
        fprintf(v21, "%s\n", v17);
        if (v18)
          free(v18);
        CFRelease(v15);
      }
      else
      {
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          sub_100087C74();
        if (qword_1000EBD40)
          v20 = (FILE *)qword_1000EBD40;
        else
          v20 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
      }
      *__error() = v10;
    }
  }
  close(*(_DWORD *)(a1 + 52));
  v3[v5] = 0;
  v22 = strnstr(v3, "Spindump analysis written to file ", v5);
  if (!v22)
  {
    v26 = *__error();
    v27 = sub_100030318();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      sub_100087A94();
    *__error() = v26;
    if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
      goto LABEL_78;
    v28 = *__error();
    v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Spindump output doesn't contain output path: %s"), v3);
    if (!v29)
    {
      v41 = sub_100030318();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
        sub_100087A34();
      goto LABEL_65;
    }
    v30 = v29;
    v31 = CFStringGetCStringPtr(v29, 0x8000100u);
    if (!v31)
    {
      v32 = 950114446;
      goto LABEL_70;
    }
    goto LABEL_58;
  }
  v23 = v22 + 34;
  v24 = strnstr(v22 + 34, "\n", &v3[v5] - (v22 + 34));
  if (!v24)
  {
    v33 = *__error();
    v34 = sub_100030318();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_FAULT))
      sub_100087B54();
    *__error() = v33;
    if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
      goto LABEL_78;
    v28 = *__error();
    v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No newline in spindump output: %s"), v3);
    if (!v35)
    {
      v42 = sub_100030318();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
        sub_100087AF4();
      goto LABEL_65;
    }
    v30 = v35;
    v31 = CFStringGetCStringPtr(v35, 0x8000100u);
    if (!v31)
    {
      v32 = 3903177908;
      goto LABEL_70;
    }
LABEL_58:
    v39 = (char *)v31;
    v40 = 0;
LABEL_71:
    if (qword_1000EBD40)
      v45 = (FILE *)qword_1000EBD40;
    else
      v45 = __stderrp;
    fprintf(v45, "%s\n", v39);
    if (v40)
      free(v40);
    CFRelease(v30);
LABEL_77:
    *__error() = v28;
LABEL_78:
    v25 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
    goto LABEL_79;
  }
  *v24 = 0;
  if (!sub_10002D658(v23))
  {
    v36 = *__error();
    v37 = sub_100030318();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
      sub_100087C14();
    *__error() = v36;
    if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
      goto LABEL_78;
    v28 = *__error();
    v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Spindump output file doesn't exist: %s"), v23);
    if (v38)
    {
      v30 = v38;
      v31 = CFStringGetCStringPtr(v38, 0x8000100u);
      if (v31)
        goto LABEL_58;
      v32 = 4025747747;
LABEL_70:
      v39 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v32);
      CFStringGetCString(v30, v39, 1024, 0x8000100u);
      v40 = v39;
      goto LABEL_71;
    }
    v43 = sub_100030318();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
      sub_100087BB4();
LABEL_65:
    if (qword_1000EBD40)
      v44 = (FILE *)qword_1000EBD40;
    else
      v44 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
    goto LABEL_77;
  }
  v25 = *(void (**)(void))(*(_QWORD *)(a1 + 40) + 16);
LABEL_79:
  v25();
  free(v3);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

void sub_100047C5C(id a1)
{
  char *v1;

  v1 = getenv("SPINDUMP_IGNORE_SUSPENSION");
  if (v1)
  {
    if (strcmp(v1, "0"))
      byte_1000EBBE8 = 1;
  }
}

void sub_100047CDC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x1Cu);
}

void sub_100047DA0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x12u);
}

void sub_100047DB4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x12u);
}

void sub_100047DFC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 2u);
}

id sub_100047E0C()
{
  void *v0;

  return objc_msgSend(v0, "total");
}

void sub_100047E14(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x16u);
}

void sub_100047E34(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 2u);
}

_DWORD *sub_100047E44(int a1)
{
  return sub_1000302B4(a1);
}

_DWORD *sub_100047E54(int a1)
{
  return sub_1000302B4(a1);
}

void sub_100047E5C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x30u);
}

void sub_100047E70(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x20u);
}

id sub_100047EC0()
{
  void *v0;

  return objc_msgSend(v0, "bytes_not_microstackshots");
}

char *sub_100047F14(int *a1)
{
  return strerror(*a1);
}

void sub_100047F1C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x1Cu);
}

void sub_100047F30(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x1Cu);
}

int *sub_100047F88()
{
  return __error();
}

_DWORD *sub_100047F98(int a1)
{
  return sub_1000302B4(a1);
}

id sub_100047FB0(void *a1, const char *a2)
{
  return objc_msgSend(a1, "total");
}

_DWORD *sub_100047FEC(int *a1)
{
  return sub_1000302B4(*a1);
}

_DWORD *sub_100047FF8(int *a1)
{
  return sub_1000302B4(*a1);
}

int *sub_100048000()
{
  return __error();
}

void sub_10004800C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x30u);
}

void sub_100048020(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0x20u);
}

void sub_100048034(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x2Cu);
}

void sub_100048048(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x18u);
}

void sub_10004805C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x12u);
}

void sub_100048070(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x30u);
}

void sub_100048084(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x20u);
}

void sub_100048098(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x2Cu);
}

void sub_1000480AC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x18u);
}

int *sub_1000480C0()
{
  return __error();
}

int *sub_1000480C8()
{
  return __error();
}

const char *sub_1000480D0()
{
  unsigned __int8 v0;

  return sub_10006E888(v0);
}

int *sub_1000480E0()
{
  return __error();
}

int *sub_1000480E8()
{
  return __error();
}

_DWORD *sub_1000480F0@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_QWORD *)(v2 - 24) = a2;
  return sub_1000302B4(a1);
}

void sub_1000480F8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0x16u);
}

void sub_100048108(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 8u);
}

void sub_100048118(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

const char *sub_100048158(unsigned __int8 a1)
{
  return sub_10006E888(a1);
}

_DWORD *sub_100048170(_DWORD *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  if ((_DWORD)a2)
  {
    v8 = a2;
    result = sub_100024904((uint64_t)result, a2, a3, a4, a5, a6, a7, a8);
    if (result)
      result[1] = v8;
  }
  return result;
}

BOOL sub_10004819C()
{
  uint64_t state;
  uint64_t v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  _BOOL8 result;
  int v6;
  NSObject *v7;
  BOOL v8;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *v12;
  char *v13;
  char *v14;
  int v15;
  const __CFString *v16;
  const __CFString *v17;
  const char *CStringPtr;
  char *v19;
  char *v20;
  NSObject *v21;
  FILE *v22;
  FILE *v23;
  int *v24;
  NSObject *v25;
  FILE *v26;
  FILE *v27;
  uint64_t state64;

  if (qword_1000EBC08 != -1)
    dispatch_once(&qword_1000EBC08, &stru_1000DD090);
  if (dword_1000EB4EC == -1)
    return 0;
  state64 = 0;
  state = notify_get_state(dword_1000EB4EC, &state64);
  if ((_DWORD)state)
  {
    v1 = state;
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_100088B70();
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 3;
    else
      v4 = 0;
    if (!v4)
      return 0;
    v15 = *__error();
    v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to get thermal level: %d"), v1);
    if (v16)
    {
      v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        v19 = (char *)CStringPtr;
        v20 = 0;
      }
      else
      {
        v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x109ABBF4uLL);
        CFStringGetCString(v17, v19, 1024, 0x8000100u);
        v20 = v19;
      }
      if (qword_1000EBD40)
        v23 = (FILE *)qword_1000EBD40;
      else
        v23 = __stderrp;
      fprintf(v23, "%s\n", v19);
      if (v20)
        free(v20);
      CFRelease(v17);
    }
    else
    {
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
        sub_100088B10();
      if (qword_1000EBD40)
        v22 = (FILE *)qword_1000EBD40;
      else
        v22 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
    }
    v24 = __error();
    result = 0;
    *v24 = v15;
  }
  else
  {
    if (byte_1000EBD38)
    {
      v6 = *__error();
      v7 = sub_100030318();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        sub_100088AB0();
      *__error() = v6;
    }
    if (byte_1000EBD39)
      v8 = dword_1000EB4E8 <= 0;
    else
      v8 = 0;
    if (v8)
    {
      v9 = *__error();
      v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Got thermal level: %lld"), state64);
      if (v10)
      {
        v11 = v10;
        v12 = CFStringGetCStringPtr(v10, 0x8000100u);
        if (v12)
        {
          v13 = (char *)v12;
          v14 = 0;
        }
        else
        {
          v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4B3E5399uLL);
          CFStringGetCString(v11, v13, 1024, 0x8000100u);
          v14 = v13;
        }
        if (qword_1000EBD40)
          v27 = (FILE *)qword_1000EBD40;
        else
          v27 = __stderrp;
        fprintf(v27, "%s\n", v13);
        if (v14)
          free(v14);
        CFRelease(v11);
      }
      else
      {
        v25 = sub_100030318();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
          sub_100088A50();
        if (qword_1000EBD40)
          v26 = (FILE *)qword_1000EBD40;
        else
          v26 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v9;
    }
    return state64 > 0x1D;
  }
  return result;
}

void sub_100048548(id a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  NSObject *v4;
  BOOL v5;
  int v6;
  const __CFString *v7;
  const __CFString *v8;
  const char *CStringPtr;
  char *v10;
  char *v11;
  NSObject *v12;
  FILE *v13;
  FILE *v14;

  v1 = notify_register_check(kOSThermalNotificationPressureLevelName, &dword_1000EB4EC);
  if ((_DWORD)v1)
  {
    v2 = v1;
    if (byte_1000EBD38)
    {
      v3 = *__error();
      v4 = sub_100030318();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100088C30();
      *__error() = v3;
    }
    if (byte_1000EBD39)
      v5 = dword_1000EB4E8 <= 3;
    else
      v5 = 0;
    if (v5)
    {
      v6 = *__error();
      v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to register for thermal level: %d"), v2);
      if (v7)
      {
        v8 = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          v10 = (char *)CStringPtr;
          v11 = 0;
        }
        else
        {
          v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x236BBEA6uLL);
          CFStringGetCString(v8, v10, 1024, 0x8000100u);
          v11 = v10;
        }
        if (qword_1000EBD40)
          v14 = (FILE *)qword_1000EBD40;
        else
          v14 = __stderrp;
        fprintf(v14, "%s\n", v10);
        if (v11)
          free(v11);
        CFRelease(v8);
      }
      else
      {
        v12 = sub_100030318();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
          sub_100088BD0();
        if (qword_1000EBD40)
          v13 = (FILE *)qword_1000EBD40;
        else
          v13 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
      }
      *__error() = v6;
    }
    dword_1000EB4EC = -1;
  }
}

BOOL sub_10004872C()
{
  uint64_t state;
  uint64_t v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  _BOOL8 result;
  int v6;
  NSObject *v7;
  BOOL v8;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *v12;
  char *v13;
  char *v14;
  int v15;
  const __CFString *v16;
  const __CFString *v17;
  const char *CStringPtr;
  char *v19;
  char *v20;
  NSObject *v21;
  FILE *v22;
  FILE *v23;
  int *v24;
  NSObject *v25;
  FILE *v26;
  FILE *v27;
  uint64_t state64;

  if (qword_1000EBC10 != -1)
    dispatch_once(&qword_1000EBC10, &stru_1000DD0B0);
  if (dword_1000EB4F0 == -1)
    return 0;
  state64 = 0;
  state = notify_get_state(dword_1000EB4F0, &state64);
  if ((_DWORD)state)
  {
    v1 = state;
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_100088DB0();
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 3;
    else
      v4 = 0;
    if (!v4)
      return 0;
    v15 = *__error();
    v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("GM check: Failed to get game mode state: %d"), v1);
    if (v16)
    {
      v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        v19 = (char *)CStringPtr;
        v20 = 0;
      }
      else
      {
        v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCC4A1843uLL);
        CFStringGetCString(v17, v19, 1024, 0x8000100u);
        v20 = v19;
      }
      if (qword_1000EBD40)
        v23 = (FILE *)qword_1000EBD40;
      else
        v23 = __stderrp;
      fprintf(v23, "%s\n", v19);
      if (v20)
        free(v20);
      CFRelease(v17);
    }
    else
    {
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
        sub_100088D50();
      if (qword_1000EBD40)
        v22 = (FILE *)qword_1000EBD40;
      else
        v22 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
    }
    v24 = __error();
    result = 0;
    *v24 = v15;
  }
  else
  {
    if (byte_1000EBD38)
    {
      v6 = *__error();
      v7 = sub_100030318();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        sub_100088CF0();
      *__error() = v6;
    }
    if (byte_1000EBD39)
      v8 = dword_1000EB4E8 <= 0;
    else
      v8 = 0;
    if (v8)
    {
      v9 = *__error();
      v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("GM check: Got game mode: %lld"), state64);
      if (v10)
      {
        v11 = v10;
        v12 = CFStringGetCStringPtr(v10, 0x8000100u);
        if (v12)
        {
          v13 = (char *)v12;
          v14 = 0;
        }
        else
        {
          v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCC103072uLL);
          CFStringGetCString(v11, v13, 1024, 0x8000100u);
          v14 = v13;
        }
        if (qword_1000EBD40)
          v27 = (FILE *)qword_1000EBD40;
        else
          v27 = __stderrp;
        fprintf(v27, "%s\n", v13);
        if (v14)
          free(v14);
        CFRelease(v11);
      }
      else
      {
        v25 = sub_100030318();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
          sub_100088C90();
        if (qword_1000EBD40)
          v26 = (FILE *)qword_1000EBD40;
        else
          v26 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v9;
    }
    return state64 != 0;
  }
  return result;
}

void sub_100048AD8(id a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  NSObject *v4;
  BOOL v5;
  int v6;
  const __CFString *v7;
  const __CFString *v8;
  const char *CStringPtr;
  char *v10;
  char *v11;
  NSObject *v12;
  FILE *v13;
  FILE *v14;

  v1 = notify_register_check("com.apple.system.console_mode_changed", &dword_1000EB4F0);
  if ((_DWORD)v1)
  {
    v2 = v1;
    if (byte_1000EBD38)
    {
      v3 = *__error();
      v4 = sub_100030318();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        sub_100088E70();
      *__error() = v3;
    }
    if (byte_1000EBD39)
      v5 = dword_1000EB4E8 <= 3;
    else
      v5 = 0;
    if (v5)
    {
      v6 = *__error();
      v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to register for game mode state: %d"), v2);
      if (v7)
      {
        v8 = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          v10 = (char *)CStringPtr;
          v11 = 0;
        }
        else
        {
          v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x359574B8uLL);
          CFStringGetCString(v8, v10, 1024, 0x8000100u);
          v11 = v10;
        }
        if (qword_1000EBD40)
          v14 = (FILE *)qword_1000EBD40;
        else
          v14 = __stderrp;
        fprintf(v14, "%s\n", v10);
        if (v11)
          free(v11);
        CFRelease(v8);
      }
      else
      {
        v12 = sub_100030318();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
          sub_100088E10();
        if (qword_1000EBD40)
          v13 = (FILE *)qword_1000EBD40;
        else
          v13 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
      }
      *__error() = v6;
    }
    dword_1000EB4F0 = -1;
  }
}

uint64_t sub_100048CB8(uint64_t a1, uint64_t a2, double a3)
{
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  NSObject *v8;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *CStringPtr;
  char *v13;
  char *v14;
  NSObject *v15;
  FILE *v16;
  FILE *v17;
  _QWORD handler[5];
  int out_token;
  _QWORD v21[2];
  double (*v22)(uint64_t);
  void *v23;
  uint64_t v24;
  uint64_t v25;
  double v26;

  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v22 = sub_100049154;
  v23 = &unk_1000DD138;
  v24 = a1;
  v25 = a2;
  v26 = a3;
  v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v4 = dispatch_queue_create("Tasking notification", v3);
  dispatch_release(v3);
  out_token = 0;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10004971C;
  handler[3] = &unk_1000DD160;
  handler[4] = v21;
  v5 = notify_register_dispatch("com.apple.da.tasking_changed", &out_token, v4, handler);
  if ((_DWORD)v5)
  {
    v6 = v5;
    if (byte_1000EBD38)
    {
      v7 = *__error();
      v8 = sub_100030318();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        sub_100088F30();
      *__error() = v7;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v9 = *__error();
      v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to register for tasking update notifications: %d"), v6);
      if (v10)
      {
        v11 = v10;
        CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
        if (CStringPtr)
        {
          v13 = (char *)CStringPtr;
          v14 = 0;
        }
        else
        {
          v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBDEC8572uLL);
          CFStringGetCString(v11, v13, 1024, 0x8000100u);
          v14 = v13;
        }
        if (qword_1000EBD40)
          v17 = (FILE *)qword_1000EBD40;
        else
          v17 = __stderrp;
        fprintf(v17, "%s\n", v13);
        if (v14)
          free(v14);
        CFRelease(v11);
      }
      else
      {
        v15 = sub_100030318();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
          sub_100088ED0();
        if (qword_1000EBD40)
          v16 = (FILE *)qword_1000EBD40;
        else
          v16 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
      }
      *__error() = v9;
    }
  }
  return ((uint64_t (*)(_QWORD *))v22)(v21);
}

void sub_100048F2C(id a1)
{
  int has_internal_diagnostics;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  FILE *v19;
  FILE *v20;
  uint8_t buf[16];

  has_internal_diagnostics = os_variant_has_internal_diagnostics("com.apple.spindump");
  byte_1000EBC18 = has_internal_diagnostics;
  if (has_internal_diagnostics)
  {
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "apple internal", buf, 2u);
      }
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 1;
    else
      v4 = 0;
    if (v4)
    {
      v5 = *__error();
      v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("apple internal"));
      if (v6)
      {
        v7 = v6;
        CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          v9 = (char *)CStringPtr;
          v10 = 0;
        }
        else
        {
          v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C2873C8uLL);
          CFStringGetCString(v7, v9, 1024, 0x8000100u);
          v10 = v9;
        }
        if (qword_1000EBD40)
          v20 = (FILE *)qword_1000EBD40;
        else
          v20 = __stderrp;
        fprintf(v20, "%s\n", v9);
        if (v10)
          free(v10);
        CFRelease(v7);
      }
      else
      {
        v11 = sub_100030318();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
          sub_100088F90(v11, v12, v13, v14, v15, v16, v17, v18);
        if (qword_1000EBD40)
          v19 = (FILE *)qword_1000EBD40;
        else
          v19 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
      }
      *__error() = v5;
    }
  }
}

void sub_10004910C(id a1)
{
  byte_1000EBC28 = sub_10002D658("/var/db/.suppress_spin_reports");
}

void sub_100049130(id a1)
{
  byte_1000EBC38 = sub_10002D658("/var/db/.enable_spin_reports");
}

double sub_100049154(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  double result;
  uint64_t **v7;
  double *v8;
  int v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  int v14;
  const __CFString *v15;
  const __CFString *v16;
  const char *v17;
  char *v18;
  char *v19;
  int v20;
  NSObject *v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  int v25;
  const __CFString *v26;
  const __CFString *v27;
  const char *CStringPtr;
  char *v29;
  char *v30;
  int v31;
  NSObject *v32;
  BOOL v33;
  const __CFString *v34;
  const __CFString *v35;
  const char *v36;
  char *v37;
  char *v38;
  NSObject *v39;
  NSObject *v40;
  FILE *v41;
  NSObject *v42;
  FILE *v43;
  FILE *v44;
  const __CFString *v45;
  FILE *v46;
  FILE *v47;
  uint8_t buf[4];
  uint64_t v49;
  __int16 v50;
  uint64_t v51;

  v2 = (_QWORD *)(a1 + 32);
  v3 = OSAGetDATaskingValue(*(_QWORD *)(a1 + 32));
  if (!v3)
  {
    if (byte_1000EBD38)
    {
      v20 = *__error();
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
      {
        v22 = *(_QWORD *)(a1 + 32);
        v23 = *(_QWORD *)(a1 + 48);
        *(_DWORD *)buf = 138543618;
        v49 = v22;
        v50 = 2048;
        v51 = v23;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_INFO, "Tasking setting for %{public}@ not available, using default %.1f", buf, 0x16u);
      }
      *__error() = v20;
    }
    if (byte_1000EBD39)
      v24 = dword_1000EB4E8 <= 1;
    else
      v24 = 0;
    if (!v24)
      goto LABEL_77;
    v25 = *__error();
    v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Tasking setting for %@ not available, using default %.1f"), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 48));
    if (v26)
    {
      v27 = v26;
      CStringPtr = CFStringGetCStringPtr(v26, 0x8000100u);
      if (CStringPtr)
      {
        v29 = (char *)CStringPtr;
        v30 = 0;
      }
      else
      {
        v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5A7E4DA9uLL);
        CFStringGetCString(v27, v29, 1024, 0x8000100u);
        v30 = v29;
      }
      if (qword_1000EBD40)
        v44 = (FILE *)qword_1000EBD40;
      else
        v44 = __stderrp;
      fprintf(v44, "%s\n", v29);
      if (v30)
        free(v30);
      v45 = v27;
      goto LABEL_75;
    }
    v39 = sub_100030318();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
      sub_100088FC0();
LABEL_49:
    if (qword_1000EBD40)
      v43 = (FILE *)qword_1000EBD40;
    else
      v43 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
    goto LABEL_76;
  }
  v4 = (void *)v3;
  v5 = objc_opt_class(NSNumber);
  if ((objc_opt_isKindOfClass(v4, v5) & 1) == 0)
  {
    if (byte_1000EBD38)
    {
      v31 = *__error();
      v32 = sub_100030318();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        sub_100089100();
      *__error() = v31;
    }
    if (byte_1000EBD39)
      v33 = dword_1000EB4E8 <= 3;
    else
      v33 = 0;
    if (!v33)
      goto LABEL_77;
    v25 = *__error();
    v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Tasking setting for %@: %@ isn't a number"), *v2, v4);
    if (v34)
    {
      v35 = v34;
      v36 = CFStringGetCStringPtr(v34, 0x8000100u);
      if (v36)
      {
        v37 = (char *)v36;
        v38 = 0;
      }
      else
      {
        v37 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x26601C8DuLL);
        CFStringGetCString(v35, v37, 1024, 0x8000100u);
        v38 = v37;
      }
      if (qword_1000EBD40)
        v47 = (FILE *)qword_1000EBD40;
      else
        v47 = __stderrp;
      fprintf(v47, "%s\n", v37);
      if (v38)
        free(v38);
      v45 = v35;
LABEL_75:
      CFRelease(v45);
LABEL_76:
      *__error() = v25;
LABEL_77:
      result = *(double *)(a1 + 48);
      **(double **)(a1 + 40) = result;
      return result;
    }
    v42 = sub_100030318();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_FAULT))
      sub_100089094();
    goto LABEL_49;
  }
  objc_msgSend(v4, "doubleValue");
  v8 = *(double **)(a1 + 40);
  v7 = (uint64_t **)(a1 + 40);
  *v8 = result;
  if (byte_1000EBD38)
  {
    v9 = *__error();
    v10 = sub_100030318();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      v11 = *v2;
      v12 = **v7;
      *(_DWORD *)buf = 138543618;
      v49 = v11;
      v50 = 2048;
      v51 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Tasking setting for %{public}@: %.1f", buf, 0x16u);
    }
    *__error() = v9;
  }
  if (byte_1000EBD39)
    v13 = dword_1000EB4E8 <= 2;
  else
    v13 = 0;
  if (v13)
  {
    v14 = *__error();
    v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Tasking setting for %@: %.1f"), *v2, **v7);
    if (v15)
    {
      v16 = v15;
      v17 = CFStringGetCStringPtr(v15, 0x8000100u);
      if (v17)
      {
        v18 = (char *)v17;
        v19 = 0;
      }
      else
      {
        v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x547149F3uLL);
        CFStringGetCString(v16, v18, 1024, 0x8000100u);
        v19 = v18;
      }
      if (qword_1000EBD40)
        v46 = (FILE *)qword_1000EBD40;
      else
        v46 = __stderrp;
      fprintf(v46, "%s\n", v18);
      if (v19)
        free(v19);
      CFRelease(v16);
    }
    else
    {
      v40 = sub_100030318();
      if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
        sub_100089028();
      if (qword_1000EBD40)
        v41 = (FILE *)qword_1000EBD40;
      else
        v41 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v41);
    }
    *__error() = v14;
  }
  return result;
}

uint64_t sub_10004971C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_100049754(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x1Au);
}

void sub_100049790(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xEu);
}

void sub_1000497F0(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x14u);
}

void sub_1000497FC(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0x20u);
}

void sub_100049810(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void sub_10004982C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 8u);
}

double sub_100049868()
{
  return 2.0542726e-289;
}

void sub_10004989C(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

uint64_t sub_1000498B0(uint64_t a1)
{
  int v3;
  NSObject *v4;
  BOOL v5;
  int v6;
  _DWORD *v7;
  uint64_t v8;
  int *v9;
  char *v10;
  const __CFString *v11;
  const __CFString *v12;
  const char *v13;
  char *v14;
  char *v15;
  int v16;
  NSObject *v17;
  BOOL v18;
  uint64_t v19;
  int *v20;
  char *v21;
  const __CFString *v22;
  const __CFString *v23;
  const char *CStringPtr;
  char *v25;
  char *v26;
  NSObject *v27;
  FILE *v28;
  const __CFString *v29;
  NSObject *v30;
  FILE *v31;
  FILE *v32;
  _OWORD buffer[2];
  __int128 v34;
  __int128 v35;

  v34 = 0u;
  v35 = 0u;
  memset(buffer, 0, sizeof(buffer));
  if (proc_pidinfo(a1, 13, 1uLL, buffer, 64))
    return DWORD1(v34);
  if ((a1 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v16 = *__error();
      v17 = sub_100030318();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        sub_100089334(v17);
      *__error() = v16;
    }
    if (byte_1000EBD39)
      v18 = dword_1000EB4E8 <= 3;
    else
      v18 = 0;
    if (!v18)
      return 0xFFFFFFFFLL;
    v6 = *__error();
    v19 = *__error();
    v20 = __error();
    v21 = strerror(*v20);
    v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to get uid: %d (%s)"), v19, v21);
    if (v22)
    {
      v23 = v22;
      CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
      if (CStringPtr)
      {
        v25 = (char *)CStringPtr;
        v26 = 0;
      }
      else
      {
        v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DD57E13uLL);
        CFStringGetCString(v23, v25, 1024, 0x8000100u);
        v26 = v25;
      }
      if (qword_1000EBD40)
        v32 = (FILE *)qword_1000EBD40;
      else
        v32 = __stderrp;
      fprintf(v32, "%s\n", v25);
      if (v26)
        free(v26);
      v29 = v23;
      goto LABEL_50;
    }
    v30 = sub_100030318();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
      sub_1000892AC(v30);
LABEL_39:
    if (qword_1000EBD40)
      v31 = (FILE *)qword_1000EBD40;
    else
      v31 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    goto LABEL_51;
  }
  if (byte_1000EBD38)
  {
    v3 = *__error();
    v4 = sub_100030318();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      sub_100089214(a1, v4);
    *__error() = v3;
  }
  if (byte_1000EBD39)
    v5 = dword_1000EB4E8 <= 3;
  else
    v5 = 0;
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = *__error();
  v7 = sub_1000302B4(a1);
  v8 = *__error();
  v9 = __error();
  v10 = strerror(*v9);
  v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to get uid: %d (%s)"), v7, a1, v8, v10);
  if (!v11)
  {
    v27 = sub_100030318();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
      sub_10008917C(a1, v27);
    goto LABEL_39;
  }
  v12 = v11;
  v13 = CFStringGetCStringPtr(v11, 0x8000100u);
  if (v13)
  {
    v14 = (char *)v13;
    v15 = 0;
  }
  else
  {
    v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DD57E13uLL);
    CFStringGetCString(v12, v14, 1024, 0x8000100u);
    v15 = v14;
  }
  if (qword_1000EBD40)
    v28 = (FILE *)qword_1000EBD40;
  else
    v28 = __stderrp;
  fprintf(v28, "%s\n", v14);
  if (v15)
    free(v15);
  v29 = v12;
LABEL_50:
  CFRelease(v29);
LABEL_51:
  *__error() = v6;
  return 0xFFFFFFFFLL;
}

void sub_100049C50(uint64_t a1, xpc_object_t object)
{
  int v4;
  NSObject *v5;
  BOOL v6;
  int v7;
  const char *string;
  const __CFString *v9;
  const __CFString *v10;
  const char *CStringPtr;
  char *v12;
  char *v13;
  NSObject *v14;
  FILE *v15;
  FILE *v16;

  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_error)
  {
    if (byte_1000EBD38)
    {
      v4 = *__error();
      v5 = sub_100030318();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
        sub_1000895FC(object);
      *__error() = v4;
    }
    if (byte_1000EBD39)
      v6 = dword_1000EB4E8 <= 0;
    else
      v6 = 0;
    if (v6)
    {
      v7 = *__error();
      string = xpc_dictionary_get_string(object, _xpc_error_key_description);
      v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Got xpc error message in libspindump client connection: %s"), string);
      if (v9)
      {
        v10 = v9;
        CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
        if (CStringPtr)
        {
          v12 = (char *)CStringPtr;
          v13 = 0;
        }
        else
        {
          v12 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD22276FFuLL);
          CFStringGetCString(v10, v12, 1024, 0x8000100u);
          v13 = v12;
        }
        if (qword_1000EBD40)
          v16 = (FILE *)qword_1000EBD40;
        else
          v16 = __stderrp;
        fprintf(v16, "%s\n", v12);
        if (v13)
          free(v13);
        CFRelease(v10);
      }
      else
      {
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
          sub_100089588(object, _xpc_error_key_description, v14);
        if (qword_1000EBD40)
          v15 = (FILE *)qword_1000EBD40;
        else
          v15 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v15);
      }
      *__error() = v7;
    }
  }
  else if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_100049E80(*(_QWORD *)(a1 + 32), *(_DWORD *)(a1 + 40), object);
  }
}

void sub_100049E80(unint64_t a1, int a2, xpc_object_t xdict)
{
  int64_t int64;
  int64_t v7;
  uint64_t uint64;
  uint64_t v9;
  xpc_object_t value;
  void *v11;
  int v12;
  NSObject *v13;
  BOOL v14;
  int v15;
  const __CFString *v16;
  const __CFString *v17;
  const char *CStringPtr;
  malloc_type_id_t v19;
  int v20;
  NSObject *v21;
  _BOOL4 v22;
  BOOL v23;
  _DWORD *v24;
  const __CFString *v25;
  NSObject *v26;
  int64_t v27;
  uint64_t v28;
  int64_t v29;
  _DWORD *v30;
  xpc_object_t v31;
  void *v32;
  int v33;
  NSObject *v34;
  const __CFString *v35;
  _BOOL4 v36;
  xpc_connection_t remote_connection;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _xpc_connection_s *v42;
  xpc_object_t reply;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  _xpc_connection_s *v49;
  int64_t v50;
  int64_t v51;
  uint64_t v52;
  int64_t v53;
  uint64_t v54;
  int64_t v55;
  const char *v56;
  NSString *v57;
  int64_t v58;
  uint64_t v59;
  int64_t v60;
  uint64_t v61;
  int64_t v62;
  const char *v63;
  NSString *v64;
  const char *v65;
  int64_t v66;
  uint64_t v67;
  int64_t v68;
  uint64_t v69;
  int64_t v70;
  const char *v71;
  NSString *v72;
  int v73;
  NSObject *v74;
  BOOL v75;
  int v76;
  _DWORD *v77;
  const __CFString *v78;
  NSObject *v79;
  int v80;
  NSObject *v81;
  BOOL v82;
  const __CFString *v83;
  BOOL v84;
  int v85;
  NSObject *v86;
  BOOL v87;
  const __CFString *v88;
  int v89;
  NSObject *v90;
  BOOL v91;
  const __CFString *v92;
  int v93;
  NSObject *v94;
  BOOL v95;
  const __CFString *v96;
  int v97;
  NSObject *v98;
  BOOL v99;
  const __CFString *v100;
  int v101;
  NSObject *v102;
  BOOL v103;
  const __CFString *v104;
  int v105;
  NSObject *v106;
  BOOL v107;
  const __CFString *v108;
  int v109;
  NSObject *v110;
  BOOL v111;
  const __CFString *v112;
  int v113;
  NSObject *v114;
  BOOL v115;
  const __CFString *v116;
  int v117;
  NSObject *v118;
  BOOL v119;
  const __CFString *v120;
  int64_t v121;
  xpc_object_t v122;
  double v123;
  double v124;
  void *v125;
  xpc_object_t v126;
  void *v127;
  uint64_t v128;
  const char *v129;
  char *v130;
  const char *v131;
  _QWORD *v132;
  int v133;
  NSObject *v134;
  BOOL v135;
  const __CFString *v136;
  const char *v137;
  char *v138;
  char *v139;
  double v140;
  xpc_object_t v141;
  void *v142;
  int v143;
  NSObject *v144;
  const __CFString *v145;
  const char *v146;
  _BYTE *v147;
  NSString *v148;
  const char *v149;
  _BYTE *v150;
  NSString *v151;
  const char *v152;
  _BYTE *v153;
  NSString *v154;
  mach_port_name_t v155;
  mach_port_name_t v156;
  mach_port_name_t v157;
  double v158;
  xpc_object_t v159;
  void *v160;
  int v161;
  NSObject *v162;
  const __CFString *v163;
  NSObject *v164;
  int v165;
  NSObject *v166;
  const __CFString *v167;
  NSObject *v168;
  NSObject *v169;
  NSObject *v170;
  NSObject *v171;
  NSObject *v172;
  NSObject *v173;
  NSObject *v174;
  FILE *v175;
  NSObject *v176;
  int v177;
  NSObject *v178;
  const __CFString *v179;
  char *v180;
  char *v181;
  NSObject *v182;
  NSObject *v183;
  NSObject *v184;
  NSObject *v185;
  NSObject *v186;
  FILE *v187;
  double v188;
  xpc_object_t v189;
  void *v190;
  int v191;
  NSObject *v192;
  const __CFString *v193;
  NSObject *v194;
  double v195;
  int64_t v196;
  xpc_object_t v197;
  void *v198;
  int v199;
  NSObject *v200;
  const __CFString *v201;
  NSObject *v202;
  NSObject *v203;
  int v204;
  NSObject *v205;
  const __CFString *v206;
  NSObject *v207;
  FILE *v208;
  FILE *v209;
  double v210;
  int v211;
  NSObject *v212;
  const __CFString *v213;
  double v214;
  xpc_object_t v215;
  void *v216;
  int v217;
  NSObject *v218;
  const __CFString *v219;
  NSObject *v220;
  NSObject *v221;
  const char *v222;
  NSString *v223;
  NSObject *v224;
  double v225;
  int v226;
  NSObject *v227;
  const __CFString *v228;
  const char *v229;
  _BYTE *v230;
  NSString *v231;
  NSObject *v232;
  NSObject *v233;
  xpc_object_t v234;
  void *v235;
  int v236;
  NSObject *v237;
  const __CFString *v238;
  int v239;
  NSObject *v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  BOOL v248;
  int v249;
  const __CFString *v250;
  NSObject *v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  FILE *v259;
  int v260;
  NSObject *v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  BOOL v269;
  int v270;
  const __CFString *v271;
  NSObject *v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  FILE *v280;
  double v281;
  int v282;
  NSObject *v283;
  const __CFString *v284;
  NSObject *v285;
  NSObject *v286;
  const __CFString *v287;
  const char *v288;
  char *v289;
  char *v290;
  const __CFString *v291;
  const char *v292;
  char *v293;
  char *v294;
  const char *string;
  NSString *v296;
  FILE *v297;
  FILE *v298;
  const char *v299;
  _BYTE *v300;
  NSString *v301;
  NSObject *v302;
  void *v303;
  _QWORD v304[7];

  int64 = xpc_dictionary_get_int64(xdict, "message");
  switch(int64)
  {
    case 3:
      v7 = xpc_dictionary_get_int64(xdict, "pid");
      if ((_DWORD)v7)
      {
        uint64 = xpc_dictionary_get_uint64(xdict, "tid");
        v9 = xpc_dictionary_get_uint64(xdict, "flags");
        value = xpc_dictionary_get_value(xdict, "cpu");
        if (value && (v11 = value, xpc_get_type(value) == (xpc_type_t)&_xpc_type_double))
        {
          v140 = xpc_double_get_value(v11);
          if (v140 <= 0.0)
          {
            if (byte_1000EBD38)
            {
              v165 = *__error();
              v166 = sub_100030318();
              if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
                sub_10008A008();
              *__error() = v165;
            }
            if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
              return;
            v15 = *__error();
            v167 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: bad cpu_used (%f)"), *(_QWORD *)&v140);
            if (!v167)
            {
              v194 = sub_100030318();
              if (os_log_type_enabled(v194, OS_LOG_TYPE_FAULT))
                sub_100089FA4();
              goto LABEL_369;
            }
            v17 = v167;
            CStringPtr = CFStringGetCStringPtr(v167, 0x8000100u);
            if (CStringPtr)
              goto LABEL_311;
            v19 = 2357158955;
          }
          else
          {
            v141 = xpc_dictionary_get_value(xdict, "duration");
            if (v141 && (v142 = v141, xpc_get_type(v141) == (xpc_type_t)&_xpc_type_double))
            {
              v188 = xpc_double_get_value(v142);
              if (v188 <= 0.0)
              {
                if (byte_1000EBD38)
                {
                  v204 = *__error();
                  v205 = sub_100030318();
                  if (os_log_type_enabled(v205, OS_LOG_TYPE_ERROR))
                    sub_100089F40();
                  *__error() = v204;
                }
                if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                  return;
                v15 = *__error();
                v206 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: bad duration (%f)"), *(_QWORD *)&v188);
                if (!v206)
                {
                  v220 = sub_100030318();
                  if (os_log_type_enabled(v220, OS_LOG_TYPE_FAULT))
                    sub_100089EDC();
                  goto LABEL_369;
                }
                v17 = v206;
                CStringPtr = CFStringGetCStringPtr(v206, 0x8000100u);
                if (CStringPtr)
                  goto LABEL_311;
                v19 = 1383719025;
              }
              else
              {
                v189 = xpc_dictionary_get_value(xdict, "endtime");
                if (v189 && (v190 = v189, xpc_get_type(v189) == (xpc_type_t)&_xpc_type_double))
                {
                  v214 = xpc_double_get_value(v190);
                  v215 = xpc_dictionary_get_value(xdict, "cpu_limit");
                  if (v215 && (v216 = v215, xpc_get_type(v215) == (xpc_type_t)&_xpc_type_double))
                  {
                    v225 = xpc_double_get_value(v216);
                    if (v225 >= 0.0)
                    {
                      v234 = xpc_dictionary_get_value(xdict, "duration_limit");
                      if (v234 && (v235 = v234, xpc_get_type(v234) == (xpc_type_t)&_xpc_type_double))
                      {
                        v281 = xpc_double_get_value(v235);
                        if (v281 >= 0.0)
                        {
                          string = xpc_dictionary_get_string(xdict, "pname");
                          if (string)
                            v296 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", string);
                          else
                            v296 = 0;
                          v299 = xpc_dictionary_get_string(xdict, "action");
                          if (v299)
                          {
                            v300 = sub_100058234(v299);
                            v301 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v300);
                            free(v300);
                          }
                          else
                          {
                            v301 = 0;
                          }
                          sub_100026854(v7, v296, uint64, v9, (uint64_t)v301, v140, v188, v214, v225, v281);
                          return;
                        }
                        if (byte_1000EBD38)
                        {
                          v282 = *__error();
                          v283 = sub_100030318();
                          if (os_log_type_enabled(v283, OS_LOG_TYPE_ERROR))
                            sub_100089E78();
                          *__error() = v282;
                        }
                        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                          return;
                        v15 = *__error();
                        v284 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: bad duration_limit (%f)"), *(_QWORD *)&v281);
                        if (!v284)
                        {
                          v302 = sub_100030318();
                          if (os_log_type_enabled(v302, OS_LOG_TYPE_FAULT))
                            sub_100089E14();
                          goto LABEL_369;
                        }
                        v17 = v284;
                        CStringPtr = CFStringGetCStringPtr(v284, 0x8000100u);
                        if (CStringPtr)
                          goto LABEL_311;
                        v19 = 1515738748;
                      }
                      else
                      {
                        if (byte_1000EBD38)
                        {
                          v236 = *__error();
                          v237 = sub_100030318();
                          if (os_log_type_enabled(v237, OS_LOG_TYPE_ERROR))
                            sub_100089DE8();
                          *__error() = v236;
                        }
                        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                          return;
                        v15 = *__error();
                        v238 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: no duration_limit provided"));
                        if (!v238)
                        {
                          v286 = sub_100030318();
                          if (os_log_type_enabled(v286, OS_LOG_TYPE_FAULT))
                            sub_100089DBC();
                          goto LABEL_369;
                        }
                        v17 = v238;
                        CStringPtr = CFStringGetCStringPtr(v238, 0x8000100u);
                        if (CStringPtr)
                          goto LABEL_311;
                        v19 = 3046861743;
                      }
                    }
                    else
                    {
                      if (byte_1000EBD38)
                      {
                        v226 = *__error();
                        v227 = sub_100030318();
                        if (os_log_type_enabled(v227, OS_LOG_TYPE_ERROR))
                          sub_100089D58();
                        *__error() = v226;
                      }
                      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                        return;
                      v15 = *__error();
                      v228 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: bad cpu_used_limit (%f)"), *(_QWORD *)&v225);
                      if (!v228)
                      {
                        v285 = sub_100030318();
                        if (os_log_type_enabled(v285, OS_LOG_TYPE_FAULT))
                          sub_100089CF4();
                        goto LABEL_369;
                      }
                      v17 = v228;
                      CStringPtr = CFStringGetCStringPtr(v228, 0x8000100u);
                      if (CStringPtr)
                        goto LABEL_311;
                      v19 = 2882860621;
                    }
                  }
                  else
                  {
                    if (byte_1000EBD38)
                    {
                      v217 = *__error();
                      v218 = sub_100030318();
                      if (os_log_type_enabled(v218, OS_LOG_TYPE_ERROR))
                        sub_100089CC8();
                      *__error() = v217;
                    }
                    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                      return;
                    v15 = *__error();
                    v219 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: no cpu_used_limit provided"));
                    if (!v219)
                    {
                      v232 = sub_100030318();
                      if (os_log_type_enabled(v232, OS_LOG_TYPE_FAULT))
                        sub_100089C9C();
                      goto LABEL_369;
                    }
                    v17 = v219;
                    CStringPtr = CFStringGetCStringPtr(v219, 0x8000100u);
                    if (CStringPtr)
                      goto LABEL_311;
                    v19 = 3759030299;
                  }
                }
                else
                {
                  if (byte_1000EBD38)
                  {
                    v191 = *__error();
                    v192 = sub_100030318();
                    if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
                      sub_100089C70();
                    *__error() = v191;
                  }
                  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                    return;
                  v15 = *__error();
                  v193 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: no endtime provided"));
                  if (!v193)
                  {
                    v224 = sub_100030318();
                    if (os_log_type_enabled(v224, OS_LOG_TYPE_FAULT))
                      sub_100089C44();
                    goto LABEL_369;
                  }
                  v17 = v193;
                  CStringPtr = CFStringGetCStringPtr(v193, 0x8000100u);
                  if (CStringPtr)
                    goto LABEL_311;
                  v19 = 55076039;
                }
              }
            }
            else
            {
              if (byte_1000EBD38)
              {
                v143 = *__error();
                v144 = sub_100030318();
                if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
                  sub_100089C18();
                *__error() = v143;
              }
              if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                return;
              v15 = *__error();
              v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: no duration provided"));
              if (!v145)
              {
                v202 = sub_100030318();
                if (os_log_type_enabled(v202, OS_LOG_TYPE_FAULT))
                  sub_100089BEC();
                goto LABEL_369;
              }
              v17 = v145;
              CStringPtr = CFStringGetCStringPtr(v145, 0x8000100u);
              if (CStringPtr)
                goto LABEL_311;
              v19 = 3572982591;
            }
          }
        }
        else
        {
          if (byte_1000EBD38)
          {
            v12 = *__error();
            v13 = sub_100030318();
            if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
              sub_100089BC0();
            *__error() = v12;
          }
          if (byte_1000EBD39)
            v14 = dword_1000EB4E8 <= 3;
          else
            v14 = 0;
          if (!v14)
            return;
          v15 = *__error();
          v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: no cpu_used provided"));
          if (!v16)
          {
            v164 = sub_100030318();
            if (os_log_type_enabled(v164, OS_LOG_TYPE_FAULT))
              sub_100089B94();
            goto LABEL_369;
          }
          v17 = v16;
          CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
          if (CStringPtr)
            goto LABEL_311;
          v19 = 4240323128;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v80 = *__error();
          v81 = sub_100030318();
          if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            sub_100089B68();
          *__error() = v80;
        }
        if (byte_1000EBD39)
          v82 = dword_1000EB4E8 <= 3;
        else
          v82 = 0;
        if (!v82)
          return;
        v15 = *__error();
        v83 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting CPU resource: no pid provided"));
        if (!v83)
        {
          v168 = sub_100030318();
          if (os_log_type_enabled(v168, OS_LOG_TYPE_FAULT))
            sub_100089B3C();
          goto LABEL_369;
        }
        v17 = v83;
        CStringPtr = CFStringGetCStringPtr(v83, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 2818817574;
      }
      goto LABEL_374;
    case 5:
      v27 = xpc_dictionary_get_int64(xdict, "pid");
      if ((_DWORD)v27)
      {
        v28 = xpc_dictionary_get_uint64(xdict, "flags");
        v29 = xpc_dictionary_get_int64(xdict, "io");
        if (v29)
        {
          v30 = (_DWORD *)v29;
          v31 = xpc_dictionary_get_value(xdict, "duration");
          if (v31 && (v32 = v31, xpc_get_type(v31) == (xpc_type_t)&_xpc_type_double))
          {
            v158 = xpc_double_get_value(v32);
            if (v158 <= 0.0)
            {
              if (byte_1000EBD38)
              {
                v177 = *__error();
                v178 = sub_100030318();
                if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
                  sub_10008A350();
                *__error() = v177;
              }
              if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                return;
              v15 = *__error();
              v179 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting disk writes resource: bad duration (%f)"), *(_QWORD *)&v158);
              if (!v179)
              {
                v203 = sub_100030318();
                if (os_log_type_enabled(v203, OS_LOG_TYPE_FAULT))
                  sub_10008A2EC();
                goto LABEL_369;
              }
              v17 = v179;
              CStringPtr = CFStringGetCStringPtr(v179, 0x8000100u);
              if (CStringPtr)
                goto LABEL_311;
              v19 = 3150712307;
            }
            else
            {
              v159 = xpc_dictionary_get_value(xdict, "endtime");
              if (v159 && (v160 = v159, xpc_get_type(v159) == (xpc_type_t)&_xpc_type_double))
              {
                v195 = xpc_double_get_value(v160);
                v196 = xpc_dictionary_get_int64(xdict, "io_limit");
                v197 = xpc_dictionary_get_value(xdict, "duration_limit");
                if (v197 && (v198 = v197, xpc_get_type(v197) == (xpc_type_t)&_xpc_type_double))
                {
                  v210 = xpc_double_get_value(v198);
                  if (v210 >= 0.0)
                  {
                    v222 = xpc_dictionary_get_string(xdict, "pname");
                    if (v222)
                      v223 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v222);
                    else
                      v223 = 0;
                    v229 = xpc_dictionary_get_string(xdict, "action");
                    if (v229)
                    {
                      v230 = sub_100058234(v229);
                      v231 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v230);
                      free(v230);
                    }
                    else
                    {
                      v231 = 0;
                    }
                    sub_100043B20(v27, v223, v28, (uint64_t)v231, v30, v196, v158, v195, v210);
                    return;
                  }
                  if (byte_1000EBD38)
                  {
                    v211 = *__error();
                    v212 = sub_100030318();
                    if (os_log_type_enabled(v212, OS_LOG_TYPE_ERROR))
                      sub_10008A288();
                    *__error() = v211;
                  }
                  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                    return;
                  v15 = *__error();
                  v213 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting disk writes resource: bad duration_limit (%f)"), *(_QWORD *)&v210);
                  if (!v213)
                  {
                    v233 = sub_100030318();
                    if (os_log_type_enabled(v233, OS_LOG_TYPE_FAULT))
                      sub_10008A224();
                    goto LABEL_369;
                  }
                  v17 = v213;
                  CStringPtr = CFStringGetCStringPtr(v213, 0x8000100u);
                  if (CStringPtr)
                    goto LABEL_311;
                  v19 = 4107497684;
                }
                else
                {
                  if (byte_1000EBD38)
                  {
                    v199 = *__error();
                    v200 = sub_100030318();
                    if (os_log_type_enabled(v200, OS_LOG_TYPE_ERROR))
                      sub_10008A1F8();
                    *__error() = v199;
                  }
                  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                    return;
                  v15 = *__error();
                  v201 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting disk writes resource: no duration_limit provided"));
                  if (!v201)
                  {
                    v221 = sub_100030318();
                    if (os_log_type_enabled(v221, OS_LOG_TYPE_FAULT))
                      sub_10008A1CC();
                    goto LABEL_369;
                  }
                  v17 = v201;
                  CStringPtr = CFStringGetCStringPtr(v201, 0x8000100u);
                  if (CStringPtr)
                    goto LABEL_311;
                  v19 = 3165192007;
                }
              }
              else
              {
                if (byte_1000EBD38)
                {
                  v161 = *__error();
                  v162 = sub_100030318();
                  if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
                    sub_10008A1A0();
                  *__error() = v161;
                }
                if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                  return;
                v15 = *__error();
                v163 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting disk writes resource: no endtime provided"));
                if (!v163)
                {
                  v207 = sub_100030318();
                  if (os_log_type_enabled(v207, OS_LOG_TYPE_FAULT))
                    sub_10008A174();
                  goto LABEL_369;
                }
                v17 = v163;
                CStringPtr = CFStringGetCStringPtr(v163, 0x8000100u);
                if (CStringPtr)
                  goto LABEL_311;
                v19 = 2065113971;
              }
            }
          }
          else
          {
            if (byte_1000EBD38)
            {
              v33 = *__error();
              v34 = sub_100030318();
              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
                sub_10008A148();
              *__error() = v33;
            }
            if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
              return;
            v15 = *__error();
            v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting disk writes resource: no duration provided"));
            if (!v35)
            {
              v176 = sub_100030318();
              if (os_log_type_enabled(v176, OS_LOG_TYPE_FAULT))
                sub_10008A11C();
              goto LABEL_369;
            }
            v17 = v35;
            CStringPtr = CFStringGetCStringPtr(v35, 0x8000100u);
            if (CStringPtr)
              goto LABEL_311;
            v19 = 3858714645;
          }
        }
        else
        {
          if (byte_1000EBD38)
          {
            v105 = *__error();
            v106 = sub_100030318();
            if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
              sub_10008A0F0();
            *__error() = v105;
          }
          if (byte_1000EBD39)
            v107 = dword_1000EB4E8 <= 3;
          else
            v107 = 0;
          if (!v107)
            return;
          v15 = *__error();
          v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting disk writes resource: no num bytes provided"));
          if (!v108)
          {
            v182 = sub_100030318();
            if (os_log_type_enabled(v182, OS_LOG_TYPE_FAULT))
              sub_10008A0C4();
            goto LABEL_369;
          }
          v17 = v108;
          CStringPtr = CFStringGetCStringPtr(v108, 0x8000100u);
          if (CStringPtr)
            goto LABEL_311;
          v19 = 2654307608;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v85 = *__error();
          v86 = sub_100030318();
          if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
            sub_10008A098();
          *__error() = v85;
        }
        if (byte_1000EBD39)
          v87 = dword_1000EB4E8 <= 3;
        else
          v87 = 0;
        if (!v87)
          return;
        v15 = *__error();
        v88 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting disk writes resource: no pid provided"));
        if (!v88)
        {
          v170 = sub_100030318();
          if (os_log_type_enabled(v170, OS_LOG_TYPE_FAULT))
            sub_10008A06C();
          goto LABEL_369;
        }
        v17 = v88;
        CStringPtr = CFStringGetCStringPtr(v88, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 743219392;
      }
      goto LABEL_374;
    case 9:
      v36 = xpc_dictionary_get_BOOL(xdict, "callback");
      if (v36)
      {
        remote_connection = xpc_dictionary_get_remote_connection(xdict);
        if (remote_connection)
        {
          v42 = remote_connection;
          reply = xpc_dictionary_create_reply(xdict);
          if (reply)
          {
            v48 = reply;
            if ((a2 & 1) != 0)
            {
LABEL_45:
              v303 = v48;
              v49 = v42;
              if (xpc_dictionary_get_value(xdict, "pid"))
                v50 = xpc_dictionary_get_int64(xdict, "pid");
              else
                v50 = 0xFFFFFFFFLL;
              v121 = xpc_dictionary_get_int64(xdict, "tid");
              v122 = xpc_dictionary_get_value(xdict, "duration");
              v123 = 0.0;
              v124 = 0.0;
              if (v122)
              {
                v125 = v122;
                if (xpc_get_type(v122) == (xpc_type_t)&_xpc_type_double)
                  v124 = xpc_double_get_value(v125);
              }
              v126 = xpc_dictionary_get_value(xdict, "interval");
              if (v126)
              {
                v127 = v126;
                if (xpc_get_type(v126) == (xpc_type_t)&_xpc_type_double)
                  v123 = xpc_double_get_value(v127);
              }
              v128 = xpc_dictionary_get_uint64(xdict, "flags");
              v129 = xpc_dictionary_get_string(xdict, "reason");
              v130 = (char *)xpc_dictionary_get_string(xdict, "signature");
              v131 = xpc_dictionary_get_string(xdict, "filename");
              if (v36)
              {
                xpc_retain(v49);
                v304[0] = _NSConcreteStackBlock;
                v304[1] = 3221225472;
                v304[2] = sub_10004C4CC;
                v304[3] = &unk_1000DD1D0;
                v304[4] = v303;
                v304[5] = v49;
                v304[6] = sub_100030160("Pending reply for spindump request from [%d] for app [%d] thread %#llx", a1, v50, v121);
                v132 = v304;
              }
              else
              {
                v132 = 0;
              }
              if (v130)
                v130 = sub_100058234(v130);
              sub_10003D9FC(a1, a2, v50, v121, v128, (uint64_t)v129, v130, v131, v124, v123, (uint64_t)v132);
              free(v130);
              return;
            }
LABEL_62:
            if ((a1 & 0x80000000) != 0)
            {
              if (byte_1000EBD38)
              {
                v133 = *__error();
                v134 = sub_100030318();
                if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
                  sub_100089B10();
                *__error() = v133;
              }
              if (byte_1000EBD39)
                v135 = dword_1000EB4E8 <= 3;
              else
                v135 = 0;
              if (!v135)
                goto LABEL_327;
              v76 = *__error();
              v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Attemping to generate spindump, but not entitled"));
              if (!v78)
              {
                v186 = sub_100030318();
                if (os_log_type_enabled(v186, OS_LOG_TYPE_FAULT))
                  sub_100089AE4();
                goto LABEL_322;
              }
            }
            else
            {
              if (byte_1000EBD38)
              {
                v73 = *__error();
                v74 = sub_100030318();
                if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                  sub_100089A64(a1, v74);
                *__error() = v73;
              }
              if (byte_1000EBD39)
                v75 = dword_1000EB4E8 <= 3;
              else
                v75 = 0;
              if (!v75)
                goto LABEL_327;
              v76 = *__error();
              v77 = sub_1000302B4(a1);
              v78 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Attemping to generate spindump, but not entitled"), v77, a1);
              if (!v78)
              {
                v79 = sub_100030318();
                if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT))
                  sub_1000899E4(a1, v79);
LABEL_322:
                if (qword_1000EBD40)
                  v187 = (FILE *)qword_1000EBD40;
                else
                  v187 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v187);
LABEL_326:
                *__error() = v76;
LABEL_327:
                if (v36)
                {
                  xpc_dictionary_set_int64(v48, "errno", 1);
                  xpc_connection_send_message(v42, v48);
                  xpc_release(v48);
                }
                return;
              }
            }
            v136 = v78;
            v137 = CFStringGetCStringPtr(v78, 0x8000100u);
            if (v137)
            {
              v138 = (char *)v137;
              v139 = 0;
            }
            else
            {
              v138 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB551BC43uLL);
              CFStringGetCString(v136, v138, 1024, 0x8000100u);
              v139 = v138;
            }
            if (qword_1000EBD40)
              v175 = (FILE *)qword_1000EBD40;
            else
              v175 = __stderrp;
            fprintf(v175, "%s\n", v138);
            if (v139)
              free(v139);
            CFRelease(v136);
            goto LABEL_326;
          }
          if (byte_1000EBD38)
          {
            v260 = *__error();
            v261 = sub_100030318();
            if (os_log_type_enabled(v261, OS_LOG_TYPE_ERROR))
              sub_100089974(v261, v262, v263, v264, v265, v266, v267, v268);
            *__error() = v260;
          }
          if (byte_1000EBD39)
            v269 = dword_1000EB4E8 <= 3;
          else
            v269 = 0;
          if (v269)
          {
            v270 = *__error();
            v271 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: unable to create reply"), "reply");
            if (v271)
            {
              v291 = v271;
              v292 = CFStringGetCStringPtr(v271, 0x8000100u);
              if (v292)
              {
                v293 = (char *)v292;
                v294 = 0;
              }
              else
              {
                v293 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D8A2820uLL);
                CFStringGetCString(v291, v293, 1024, 0x8000100u);
                v294 = v293;
              }
              if (qword_1000EBD40)
                v298 = (FILE *)qword_1000EBD40;
              else
                v298 = __stderrp;
              fprintf(v298, "%s\n", v293);
              if (v294)
                free(v294);
              CFRelease(v291);
            }
            else
            {
              v272 = sub_100030318();
              if (os_log_type_enabled(v272, OS_LOG_TYPE_FAULT))
                sub_100089904(v272, v273, v274, v275, v276, v277, v278, v279);
              if (qword_1000EBD40)
                v280 = (FILE *)qword_1000EBD40;
              else
                v280 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v280);
            }
            *__error() = v270;
          }
          sub_1000301F0("SPHandleGenerateSpindump", "reading.m", 257, "%s: unable to create reply", v44, v45, v46, v47, (char)"reply");
        }
        else
        {
          if (byte_1000EBD38)
          {
            v239 = *__error();
            v240 = sub_100030318();
            if (os_log_type_enabled(v240, OS_LOG_TYPE_ERROR))
              sub_100089894(v240, v241, v242, v243, v244, v245, v246, v247);
            *__error() = v239;
          }
          if (byte_1000EBD39)
            v248 = dword_1000EB4E8 <= 3;
          else
            v248 = 0;
          if (v248)
          {
            v249 = *__error();
            v250 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: unable to get connection"), "connection");
            if (v250)
            {
              v287 = v250;
              v288 = CFStringGetCStringPtr(v250, 0x8000100u);
              if (v288)
              {
                v289 = (char *)v288;
                v290 = 0;
              }
              else
              {
                v289 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6BAC03FAuLL);
                CFStringGetCString(v287, v289, 1024, 0x8000100u);
                v290 = v289;
              }
              if (qword_1000EBD40)
                v297 = (FILE *)qword_1000EBD40;
              else
                v297 = __stderrp;
              fprintf(v297, "%s\n", v289);
              if (v290)
                free(v290);
              CFRelease(v287);
            }
            else
            {
              v251 = sub_100030318();
              if (os_log_type_enabled(v251, OS_LOG_TYPE_FAULT))
                sub_100089824(v251, v252, v253, v254, v255, v256, v257, v258);
              if (qword_1000EBD40)
                v259 = (FILE *)qword_1000EBD40;
              else
                v259 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v259);
            }
            *__error() = v249;
          }
          sub_1000301F0("SPHandleGenerateSpindump", "reading.m", 255, "%s: unable to get connection", v38, v39, v40, v41, (char)"connection");
        }
        abort();
      }
      v48 = 0;
      v42 = 0;
      if ((a2 & 1) != 0)
        goto LABEL_45;
      goto LABEL_62;
    case 11:
      v51 = xpc_dictionary_get_int64(xdict, "pid");
      if ((_DWORD)v51)
      {
        v52 = xpc_dictionary_get_uint64(xdict, "flags");
        v53 = xpc_dictionary_get_int64(xdict, "num_fds");
        if (v53)
        {
          v54 = v53;
          v55 = xpc_dictionary_get_int64(xdict, "num_fds_limit");
          v56 = xpc_dictionary_get_string(xdict, "pname");
          if (v56)
            v57 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v56);
          else
            v57 = 0;
          v146 = xpc_dictionary_get_string(xdict, "action");
          if (v146)
          {
            v147 = sub_100058234(v146);
            v148 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v147);
            free(v147);
          }
          else
          {
            v148 = 0;
          }
          v155 = xpc_dictionary_copy_mach_send(xdict, "fatal_port");
          sub_100044E58(v51, v57, v52, (uint64_t)v148, v54, v55, v155);
          return;
        }
        if (byte_1000EBD38)
        {
          v109 = *__error();
          v110 = sub_100030318();
          if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
            sub_10008A438();
          *__error() = v109;
        }
        if (byte_1000EBD39)
          v111 = dword_1000EB4E8 <= 3;
        else
          v111 = 0;
        if (!v111)
          return;
        v15 = *__error();
        v112 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting fd exhaustion: no num fds provided"));
        if (!v112)
        {
          v183 = sub_100030318();
          if (os_log_type_enabled(v183, OS_LOG_TYPE_FAULT))
            sub_10008A40C();
          goto LABEL_369;
        }
        v17 = v112;
        CStringPtr = CFStringGetCStringPtr(v112, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 1745781157;
      }
      else
      {
        if (byte_1000EBD38)
        {
          v89 = *__error();
          v90 = sub_100030318();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
            sub_10008A3E0();
          *__error() = v89;
        }
        if (byte_1000EBD39)
          v91 = dword_1000EB4E8 <= 3;
        else
          v91 = 0;
        if (!v91)
          return;
        v15 = *__error();
        v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting fd exhaustion: no pid provided"));
        if (!v92)
        {
          v171 = sub_100030318();
          if (os_log_type_enabled(v171, OS_LOG_TYPE_FAULT))
            sub_10008A3B4();
          goto LABEL_369;
        }
        v17 = v92;
        CStringPtr = CFStringGetCStringPtr(v92, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 3055471800;
      }
      goto LABEL_374;
    case 12:
      v58 = xpc_dictionary_get_int64(xdict, "pid");
      if ((_DWORD)v58)
      {
        v59 = xpc_dictionary_get_uint64(xdict, "flags");
        v60 = xpc_dictionary_get_int64(xdict, "num_ports");
        if (v60)
        {
          v61 = v60;
          v62 = xpc_dictionary_get_int64(xdict, "num_ports_limit");
          v63 = xpc_dictionary_get_string(xdict, "pname");
          if (v63)
            v64 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v63);
          else
            v64 = 0;
          v149 = xpc_dictionary_get_string(xdict, "action");
          if (v149)
          {
            v150 = sub_100058234(v149);
            v151 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v150);
            free(v150);
          }
          else
          {
            v151 = 0;
          }
          v156 = xpc_dictionary_copy_mach_send(xdict, "fatal_port");
          sub_100045BA4(v58, v64, v59, (uint64_t)v151, v61, v62, v156);
          return;
        }
        if (byte_1000EBD38)
        {
          v113 = *__error();
          v114 = sub_100030318();
          if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
            sub_10008A4E8();
          *__error() = v113;
        }
        if (byte_1000EBD39)
          v115 = dword_1000EB4E8 <= 3;
        else
          v115 = 0;
        if (!v115)
          return;
        v15 = *__error();
        v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting port exhaustion: no num ports provided"));
        if (!v116)
        {
          v184 = sub_100030318();
          if (os_log_type_enabled(v184, OS_LOG_TYPE_FAULT))
            sub_10008A4BC();
          goto LABEL_369;
        }
        v17 = v116;
        CStringPtr = CFStringGetCStringPtr(v116, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 193025320;
      }
      else
      {
        if (byte_1000EBD38)
        {
          v93 = *__error();
          v94 = sub_100030318();
          if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
            sub_10008A490();
          *__error() = v93;
        }
        if (byte_1000EBD39)
          v95 = dword_1000EB4E8 <= 3;
        else
          v95 = 0;
        if (!v95)
          return;
        v15 = *__error();
        v96 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting port exhaustion: no pid provided"));
        if (!v96)
        {
          v172 = sub_100030318();
          if (os_log_type_enabled(v172, OS_LOG_TYPE_FAULT))
            sub_10008A464();
          goto LABEL_369;
        }
        v17 = v96;
        CStringPtr = CFStringGetCStringPtr(v96, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 1819847248;
      }
      goto LABEL_374;
    case 13:
      v65 = xpc_dictionary_get_string(xdict, "filename");
      if (v65)
      {
        sub_10003306C(v65);
        return;
      }
      if (byte_1000EBD38)
      {
        v97 = *__error();
        v98 = sub_100030318();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
          sub_10008A5F0();
        *__error() = v97;
      }
      if (byte_1000EBD39)
        v99 = dword_1000EB4E8 <= 3;
      else
        v99 = 0;
      if (!v99)
        return;
      v15 = *__error();
      v100 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting workflow repsonsiveness delay: no tailspin file provided"));
      if (!v100)
      {
        v173 = sub_100030318();
        if (os_log_type_enabled(v173, OS_LOG_TYPE_FAULT))
          sub_10008A5C4();
        goto LABEL_369;
      }
      v17 = v100;
      CStringPtr = CFStringGetCStringPtr(v100, 0x8000100u);
      if (CStringPtr)
        goto LABEL_311;
      v19 = 2112575672;
      goto LABEL_374;
    case 14:
      v66 = xpc_dictionary_get_int64(xdict, "pid");
      if ((_DWORD)v66)
      {
        v67 = xpc_dictionary_get_uint64(xdict, "flags");
        v68 = xpc_dictionary_get_int64(xdict, "num_kqworkloops");
        if (v68)
        {
          v69 = v68;
          v70 = xpc_dictionary_get_int64(xdict, "num_kqworkloops_limit");
          v71 = xpc_dictionary_get_string(xdict, "pname");
          if (v71)
            v72 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v71);
          else
            v72 = 0;
          v152 = xpc_dictionary_get_string(xdict, "action");
          if (v152)
          {
            v153 = sub_100058234(v152);
            v154 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v153);
            free(v153);
          }
          else
          {
            v154 = 0;
          }
          v157 = xpc_dictionary_copy_mach_send(xdict, "fatal_port");
          sub_1000468F0(v66, v72, v67, (uint64_t)v154, v69, v70, v157);
          return;
        }
        if (byte_1000EBD38)
        {
          v117 = *__error();
          v118 = sub_100030318();
          if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
            sub_10008A598();
          *__error() = v117;
        }
        if (byte_1000EBD39)
          v119 = dword_1000EB4E8 <= 3;
        else
          v119 = 0;
        if (!v119)
          return;
        v15 = *__error();
        v120 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting kqworkloop exhaustion: no num kqworkloops provided"));
        if (!v120)
        {
          v185 = sub_100030318();
          if (os_log_type_enabled(v185, OS_LOG_TYPE_FAULT))
            sub_10008A56C();
          goto LABEL_369;
        }
        v17 = v120;
        CStringPtr = CFStringGetCStringPtr(v120, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 4099477833;
      }
      else
      {
        if (byte_1000EBD38)
        {
          v101 = *__error();
          v102 = sub_100030318();
          if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
            sub_10008A540();
          *__error() = v101;
        }
        if (byte_1000EBD39)
          v103 = dword_1000EB4E8 <= 3;
        else
          v103 = 0;
        if (!v103)
          return;
        v15 = *__error();
        v104 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Error reporting kqworkloop exhaustion: no pid provided"));
        if (!v104)
        {
          v174 = sub_100030318();
          if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT))
            sub_10008A514();
          goto LABEL_369;
        }
        v17 = v104;
        CStringPtr = CFStringGetCStringPtr(v104, 0x8000100u);
        if (CStringPtr)
          goto LABEL_311;
        v19 = 2322554561;
      }
      goto LABEL_374;
    default:
      v20 = *__error();
      v21 = sub_100030318();
      v22 = os_log_type_enabled(v21, OS_LOG_TYPE_FAULT);
      if ((a1 & 0x80000000) == 0)
      {
        if (v22)
          sub_1000896EC(a1);
        *__error() = v20;
        if (byte_1000EBD39)
          v23 = dword_1000EB4E8 <= 4;
        else
          v23 = 0;
        if (!v23)
          return;
        v15 = *__error();
        v24 = sub_1000302B4(a1);
        v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unknown message to libspindump (%lld)"), v24, a1, int64);
        if (!v25)
        {
          v26 = sub_100030318();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
            sub_100089674(a1);
LABEL_369:
          if (qword_1000EBD40)
            v208 = (FILE *)qword_1000EBD40;
          else
            v208 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v208);
LABEL_381:
          *__error() = v15;
          return;
        }
        goto LABEL_95;
      }
      if (v22)
        sub_1000897C4();
      *__error() = v20;
      if (byte_1000EBD39)
        v84 = dword_1000EB4E8 <= 4;
      else
        v84 = 0;
      if (v84)
      {
        v15 = *__error();
        v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unknown message to libspindump (%lld)"), int64);
        if (!v25)
        {
          v169 = sub_100030318();
          if (os_log_type_enabled(v169, OS_LOG_TYPE_FAULT))
            sub_100089764();
          goto LABEL_369;
        }
LABEL_95:
        v17 = v25;
        CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
        if (CStringPtr)
        {
LABEL_311:
          v180 = (char *)CStringPtr;
          v181 = 0;
        }
        else
        {
          v19 = 1447658915;
LABEL_374:
          v180 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v19);
          CFStringGetCString(v17, v180, 1024, 0x8000100u);
          v181 = v180;
        }
        if (qword_1000EBD40)
          v209 = (FILE *)qword_1000EBD40;
        else
          v209 = __stderrp;
        fprintf(v209, "%s\n", v180);
        if (v181)
          free(v181);
        CFRelease(v17);
        goto LABEL_381;
      }
      return;
  }
}

void sub_10004C4CC(uint64_t a1, int a2, const char *a3)
{
  xpc_dictionary_set_int64(*(xpc_object_t *)(a1 + 32), "errno", a2);
  if (a3)
    xpc_dictionary_set_string(*(xpc_object_t *)(a1 + 32), "path", a3);
  xpc_connection_send_message(*(xpc_connection_t *)(a1 + 40), *(xpc_object_t *)(a1 + 32));

  xpc_release(*(xpc_object_t *)(a1 + 32));
  xpc_release(*(xpc_object_t *)(a1 + 40));
}

void sub_10004C534(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_10004C550(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_debug_impl(a1, v9, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

id sub_10004C564(char *a1, off_t a2, int a3, uint64_t a4, double a5, double a6)
{
  id result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v20;
  int v21;
  const __CFString *v22;
  NSObject *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  FILE *v31;
  const char *CStringPtr;
  char *v33;
  char *v34;
  FILE *v35;
  const __CFString *theString;
  int v37;

  result = sub_10002AEAC(a1, a2, a3, 0, a4, 0, 1, 0xFFFFFFFFLL, a5, a6, 0, 0, 0, 0, 0);
  if (result)
  {
    if (byte_1000EBD38)
    {
      v11 = *__error();
      v12 = sub_100030318();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        sub_10008A68C(v12, v13, v14, v15, v16, v17, v18, v19);
      *__error() = v11;
    }
    if (byte_1000EBD39)
      v20 = dword_1000EB4E8 <= 3;
    else
      v20 = 0;
    if (v20)
    {
      v21 = *__error();
      v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: _HandleMicrostackshots returned a SASampleStore when saving to a file"), "!sampleStore");
      v37 = v21;
      if (v22)
      {
        theString = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr)
        {
          v33 = (char *)CStringPtr;
          v34 = 0;
        }
        else
        {
          v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x322EB21DuLL);
          CFStringGetCString(theString, v33, 1024, 0x8000100u);
          v34 = v33;
        }
        if (qword_1000EBD40)
          v35 = (FILE *)qword_1000EBD40;
        else
          v35 = __stderrp;
        fprintf(v35, "%s\n", v33);
        if (v34)
          free(v34);
        CFRelease(theString);
      }
      else
      {
        v23 = sub_100030318();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
          sub_10008A61C(v23, v24, v25, v26, v27, v28, v29, v30);
        if (qword_1000EBD40)
          v31 = (FILE *)qword_1000EBD40;
        else
          v31 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
      }
      *__error() = v37;
    }
    sub_1000301F0("SaveMicrostackshotsToFile", "microstackshot.m", 88, "%s: _HandleMicrostackshots returned a SASampleStore when saving to a file", v7, v8, v9, v10, (char)"!sampleStore");
    abort();
  }
  return result;
}

uint64_t sub_10004C768(const char *a1, int a2)
{
  uint64_t i;
  size_t v5;
  id v6;
  void *v7;
  __CFBundle *v8;
  __CFString *Identifier;
  _BOOL8 v10;

  if (!a1 || *a1 != 47)
    return 1;
  for (i = 0; i != 6; ++i)
  {
    v5 = strlen((&off_1000DD1F0)[i]);
    if (!strncmp(a1, (&off_1000DD1F0)[i], v5))
      return 0;
  }
  if (!a2)
    return 1;
  v6 = objc_msgSend(objc_alloc((Class)NSURL), "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:", a1, 0, 0);
  if (!v6)
    return 1;
  v7 = v6;
  v8 = (__CFBundle *)_CFBundleCreateWithExecutableURLIfLooksLikeBundle(0, v6);

  if (!v8)
    return 1;
  Identifier = (__CFString *)CFBundleGetIdentifier(v8);
  v10 = !Identifier || (-[__CFString hasPrefix:](Identifier, "hasPrefix:", CFSTR("com.apple.")) & 1) == 0;
  CFRelease(v8);
  return v10;
}

void sub_10004C864(uint64_t a1)
{
  uint64_t v1;
  void *v3;
  const void *bytes_ptr;
  size_t length;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 64) + 8);
  if (*(_DWORD *)(v1 + 24) == 2)
  {
    if (qword_1000EBC48 != -1)
      dispatch_once(&qword_1000EBC48, &stru_1000DD220);
  }
  else
  {
    *(_DWORD *)(v1 + 24) = 1;
    v3 = *(void **)(a1 + 32);
    if (v3)
    {
      bytes_ptr = xpc_data_get_bytes_ptr(v3);
      length = xpc_data_get_length(*(xpc_object_t *)(a1 + 32));
      sub_10002C8C0(*(void **)(a1 + 40), 0, (uint64_t)bytes_ptr, length, *(unsigned int *)(a1 + 104), *(unsigned int *)(a1 + 108), *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 48), *(double *)(a1 + 88), *(double *)(a1 + 96));
    }
    if (*(_BYTE *)(a1 + 116))
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = *(int *)(a1 + 112);
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 56));
    }
  }
}

void sub_10004C92C(id a1)
{
  int v1;
  NSObject *v2;
  BOOL v3;
  int v4;
  const __CFString *v5;
  const __CFString *v6;
  const char *CStringPtr;
  char *v8;
  char *v9;
  NSObject *v10;
  FILE *v11;
  FILE *v12;

  if (byte_1000EBD38)
  {
    v1 = *__error();
    v2 = sub_100030318();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      sub_10008C988();
    *__error() = v1;
  }
  if (byte_1000EBD39)
    v3 = dword_1000EB4E8 <= 0;
  else
    v3 = 0;
  if (v3)
  {
    v4 = *__error();
    v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Already timed out, not parsing system stats microstackshots"));
    if (v5)
    {
      v6 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        v8 = (char *)CStringPtr;
        v9 = 0;
      }
      else
      {
        v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1B58D7CEuLL);
        CFStringGetCString(v6, v8, 1024, 0x8000100u);
        v9 = v8;
      }
      if (qword_1000EBD40)
        v12 = (FILE *)qword_1000EBD40;
      else
        v12 = __stderrp;
      fprintf(v12, "%s\n", v8);
      if (v9)
        free(v9);
      CFRelease(v6);
    }
    else
    {
      v10 = sub_100030318();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        sub_10008C95C();
      if (qword_1000EBD40)
        v11 = (FILE *)qword_1000EBD40;
      else
        v11 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }
    *__error() = v4;
  }
}

int *sub_10004CAD8(int *result)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  malloc_type_id_t v9;
  int v10;
  NSObject *v11;
  BOOL v12;
  const __CFString *v13;
  char *v14;
  char *v15;
  NSObject *v16;
  NSObject *v17;
  FILE *v18;
  FILE *v19;
  uint8_t buf[4];
  int v21;

  v1 = *(_QWORD *)(*((_QWORD *)result + 4) + 8);
  if (*(_DWORD *)(v1 + 24))
  {
    *(_DWORD *)(v1 + 24) = 0;
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v21 = 30;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer", buf, 8u);
      }
      result = __error();
      *result = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 2;
    else
      v4 = 0;
    if (!v4)
      return result;
    v5 = *__error();
    v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer"), 30);
    if (v6)
    {
      v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (!CStringPtr)
      {
        v9 = 1668640244;
LABEL_35:
        v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v9);
        CFStringGetCString(v7, v14, 1024, 0x8000100u);
        v15 = v14;
        goto LABEL_36;
      }
      goto LABEL_25;
    }
    v16 = sub_100030318();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      sub_10008CA88();
    goto LABEL_30;
  }
  *(_DWORD *)(v1 + 24) = 2;
  *(_BYTE *)(*(_QWORD *)(*((_QWORD *)result + 5) + 8) + 24) = 1;
  if (byte_1000EBD38)
  {
    v10 = *__error();
    v11 = sub_100030318();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_10008CA18();
    result = __error();
    *result = v10;
  }
  if (byte_1000EBD39)
    v12 = dword_1000EB4E8 <= 3;
  else
    v12 = 0;
  if (v12)
  {
    v5 = *__error();
    v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Timed out waiting for system stats microstackshots after %d seconds"), 30);
    if (v13)
    {
      v7 = v13;
      CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
      if (!CStringPtr)
      {
        v9 = 3412819671;
        goto LABEL_35;
      }
LABEL_25:
      v14 = (char *)CStringPtr;
      v15 = 0;
LABEL_36:
      if (qword_1000EBD40)
        v19 = (FILE *)qword_1000EBD40;
      else
        v19 = __stderrp;
      fprintf(v19, "%s\n", v14);
      if (v15)
        free(v15);
      CFRelease(v7);
LABEL_42:
      result = __error();
      *result = v5;
      return result;
    }
    v17 = sub_100030318();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
      sub_10008C9B4();
LABEL_30:
    if (qword_1000EBD40)
      v18 = (FILE *)qword_1000EBD40;
    else
      v18 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
    goto LABEL_42;
  }
  return result;
}

void sub_10004CE54(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x12u);
}

void sub_10004CE80(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x12u);
}

int *sub_10004CE8C()
{
  return __error();
}

void sub_10004CEB8(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x22u);
}

void sub_10004CECC(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x26u);
}

void sub_10004CEE0(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x22u);
}

void sub_10004CEF4(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x26u);
}

int *sub_10004CF40()
{
  return __error();
}

char *sub_10004CF48(int *a1)
{
  return strerror(*a1);
}

uint64_t sub_10004CF58(uint64_t result, uint64_t a2, int a3, float a4)
{
  *(float *)a2 = a4;
  *(_DWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 8) = 2080;
  *(_QWORD *)(a2 + 10) = result;
  return result;
}

id sub_10004CF80(uint64_t a1, id *a2)
{
  return objc_msgSend(*a2, "localizedDescription");
}

id sub_10004CFA0(int a1, _BYTE *a2, int a3)
{
  _BYTE buffer[1024];

  if (a2 && *a2 == 47)
    return objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", a2);
  if (a3 && proc_pidpath(a1, buffer, 0x400u) > 0)
    return objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", buffer);
  return 0;
}

uint64_t sub_10004D06C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, long double a9, double a10, uint64_t a11, uint64_t a12)
{
  int v14;
  int v15;
  int v16;
  int v20;
  NSObject *v21;
  BOOL v22;
  int v23;
  const char *v24;
  const __CFString *v25;
  const __CFString *v26;
  const char *CStringPtr;
  char *v28;
  char *v29;
  NSObject *v30;
  FILE *v31;
  FILE *v32;
  __CFString *v33;
  const __CFString *v34;
  int v35;
  char *v36;
  BOOL v37;
  int v38;
  const char *v39;
  const char *v40;
  const __CFString *v41;
  char *v42;
  FILE *v43;
  id v44;
  id v45;
  id v46;
  id v47;
  FILE *v48;
  FILE *v49;
  uint64_t v50;
  id v51;
  id v52;
  id v53;
  id v54;
  int v55;
  NSObject *v56;
  uint64_t v57;
  BOOL v58;
  int v59;
  const __CFString *v60;
  const __CFString *v61;
  const char *v62;
  char *v63;
  char *v64;
  id v65;
  uint64_t v66;
  const __CFString *v67;
  const __CFString *v68;
  const __CFString *v69;
  const __CFString *v70;
  id v71;
  id v72;
  const __CFString *v73;
  const __CFString *v74;
  id v75;
  id v76;
  const __CFString *v78;
  const char *v79;
  char *v80;
  char *v81;
  NSObject *v82;
  uint64_t v83;
  FILE *v84;
  FILE *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  FILE *v90;
  int v91;
  NSObject *v92;
  BOOL v93;
  int v94;
  const __CFString *v95;
  NSObject *v96;
  uint64_t v97;
  uint64_t v98;
  FILE *v99;
  int v100;
  NSObject *v101;
  int v102;
  uint64_t v103;
  int *v104;
  char *v105;
  const __CFString *v106;
  const __CFString *v107;
  const char *v108;
  char *v109;
  char *v110;
  const __CFString *v111;
  const char *v112;
  char *v113;
  char *v114;
  int v115;
  char *v116;
  BOOL v117;
  int v118;
  const __CFString *v119;
  char *v120;
  FILE *v121;
  int v122;
  char *v123;
  BOOL v124;
  int v125;
  const __CFString *v126;
  char *v127;
  FILE *v128;
  FILE *v129;
  NSObject *v130;
  FILE *v131;
  const __CFString *v132;
  const char *v133;
  char *v134;
  char *v135;
  const __CFString *v136;
  const char *v137;
  char *v138;
  char *v139;
  FILE *v140;
  FILE *v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  FILE *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  _QWORD v152[7];
  int v153;
  char v154[50];
  _QWORD v155[4];
  _QWORD v156[4];

  v14 = a8;
  v15 = a6;
  v16 = a5;
  if (byte_1000EBD38)
  {
    v20 = *__error();
    v21 = sub_100030318();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
      sub_10008D038(a4, v16, v21);
    *__error() = v20;
  }
  if (byte_1000EBD39)
    v22 = dword_1000EB4E8 <= 0;
  else
    v22 = 0;
  if (v22)
  {
    v23 = *__error();
    v24 = sub_100026810(a4, v16);
    v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Saving %s report"), v24);
    if (v25)
    {
      v26 = v25;
      CStringPtr = CFStringGetCStringPtr(v25, 0x8000100u);
      if (CStringPtr)
      {
        v28 = (char *)CStringPtr;
        v29 = 0;
      }
      else
      {
        v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC56AE213uLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        v29 = v28;
      }
      if (qword_1000EBD40)
        v32 = (FILE *)qword_1000EBD40;
      else
        v32 = __stderrp;
      fprintf(v32, "%s\n", v28);
      if (v29)
        free(v29);
      CFRelease(v26);
    }
    else
    {
      v30 = sub_100030318();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
        sub_10008CFD4();
      if (qword_1000EBD40)
        v31 = (FILE *)qword_1000EBD40;
      else
        v31 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }
    *__error() = v23;
  }
  v33 = CFSTR("periodic-io-microstackshot-report");
  v34 = CFSTR("144");
  switch((int)a4)
  {
    case 3:
      if (byte_1000EBD38)
      {
        v35 = *__error();
        v36 = (char *)sub_100030318();
        if (os_log_type_enabled((os_log_t)v36, OS_LOG_TYPE_ERROR))
          sub_10008CF44(a1, v36);
        *__error() = v35;
      }
      if (byte_1000EBD39)
        v37 = dword_1000EB4E8 <= 3;
      else
        v37 = 0;
      if (v37)
      {
        v38 = *__error();
        v39 = (const char *)objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name"), "UTF8String");
        if (v39)
          v40 = v39;
        else
          v40 = "No app";
        v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: %s: DID_MANUAL status while reporting"), "status != DID_MANUAL", v40);
        if (v41)
        {
          v78 = v41;
          v79 = CFStringGetCStringPtr(v41, 0x8000100u);
          if (v79)
          {
            v80 = (char *)v79;
            v81 = 0;
          }
          else
          {
            v80 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C65238BuLL);
            CFStringGetCString(v78, v80, 1024, 0x8000100u);
            v81 = v80;
          }
          if (qword_1000EBD40)
            v85 = (FILE *)qword_1000EBD40;
          else
            v85 = __stderrp;
          fprintf(v85, "%s\n", v80);
          if (v81)
            free(v81);
          CFRelease(v78);
        }
        else
        {
          v42 = (char *)sub_100030318();
          if (os_log_type_enabled((os_log_t)v42, OS_LOG_TYPE_FAULT))
            sub_10008CEB4(a1, v42);
          if (qword_1000EBD40)
            v43 = (FILE *)qword_1000EBD40;
          else
            v43 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
        }
        *__error() = v38;
      }
      objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name"), "UTF8String");
      sub_1000301F0("SaveReport", "reporting.m", 453, "%s: %s: DID_MANUAL status while reporting", v86, v87, v88, v89, (char)"status != DID_MANUAL");
      goto LABEL_132;
    case 4:
      v44 = objc_alloc_init((Class)NSDate);
      v45 = objc_alloc_init((Class)NSDateFormatter);
      objc_msgSend(v45, "setDateFormat:", CFSTR("yyyy-MM-dd-HHmmss"));
      v46 = objc_msgSend(v45, "stringFromDate:", v44);

      v47 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("/var/mobile/Library/Logs/CrashReporter/ShutdownStall-%@.txt"), v46);
      v48 = fopen((const char *)objc_msgSend(v47, "UTF8String"), "wx");
      if (v48)
      {
        v49 = v48;
        v50 = 1;
        fwrite("Use spindump -i to generate textual report\n\n", 0x2CuLL, 1uLL, v48);
        objc_msgSend(objc_msgSend(a1, "sampleStore"), "saveBinaryFormatToStream:", v49);
        fclose(v49);

      }
      else
      {
        v100 = *__error();
        v101 = sub_100030318();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT))
          sub_10008CC40();
        *__error() = v100;
        if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
        {
          v102 = *__error();
          v103 = *__error();
          v104 = __error();
          v105 = strerror(*v104);
          v106 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to create stream from %@: %d (%s)"), v47, v103, v105);
          if (v106)
          {
            v107 = v106;
            v108 = CFStringGetCStringPtr(v106, 0x8000100u);
            if (v108)
            {
              v109 = (char *)v108;
              v110 = 0;
            }
            else
            {
              v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA6CB246EuLL);
              CFStringGetCString(v107, v109, 1024, 0x8000100u);
              v110 = v109;
            }
            if (qword_1000EBD40)
              v140 = (FILE *)qword_1000EBD40;
            else
              v140 = __stderrp;
            fprintf(v140, "%s\n", v109);
            if (v110)
              free(v110);
            CFRelease(v107);
          }
          else
          {
            v130 = sub_100030318();
            if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT))
              sub_10008CBBC();
            if (qword_1000EBD40)
              v131 = (FILE *)qword_1000EBD40;
            else
              v131 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v131);
          }
          *__error() = v102;
        }

        return 0;
      }
      return v50;
    case 5:
      v51 = objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name");
      if (v51)
      {
        v52 = v51;
        v53 = objc_alloc((Class)NSString);
        if (v15)
        {
          v33 = (__CFString *)objc_msgSend(v53, "initWithFormat:", CFSTR("%@.cpu_resource_fatal"), v52);
          v34 = CFSTR("206");
        }
        else
        {
          v33 = (__CFString *)objc_msgSend(v53, "initWithFormat:", CFSTR("%@.cpu_resource"), v52);
          v34 = (const __CFString *)kOSAProblemTypeExcResource;
        }
        goto LABEL_71;
      }
      if (byte_1000EBD38)
      {
        v115 = *__error();
        v116 = (char *)sub_100030318();
        if (os_log_type_enabled((os_log_t)v116, OS_LOG_TYPE_ERROR))
          sub_10008CD44(a1, v116);
        *__error() = v115;
      }
      if (byte_1000EBD39)
        v117 = dword_1000EB4E8 <= 3;
      else
        v117 = 0;
      if (v117)
      {
        v118 = *__error();
        v119 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No app name for cpu resource report %s"), "appName", objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String"));
        if (v119)
        {
          v132 = v119;
          v133 = CFStringGetCStringPtr(v119, 0x8000100u);
          if (v133)
          {
            v134 = (char *)v133;
            v135 = 0;
          }
          else
          {
            v134 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD1AC7067uLL);
            CFStringGetCString(v132, v134, 1024, 0x8000100u);
            v135 = v134;
          }
          if (qword_1000EBD40)
            v141 = (FILE *)qword_1000EBD40;
          else
            v141 = __stderrp;
          fprintf(v141, "%s\n", v134);
          if (v135)
            free(v135);
          CFRelease(v132);
        }
        else
        {
          v120 = (char *)sub_100030318();
          if (os_log_type_enabled((os_log_t)v120, OS_LOG_TYPE_FAULT))
            sub_10008CCC4(a1, v120);
          if (qword_1000EBD40)
            v121 = (FILE *)qword_1000EBD40;
          else
            v121 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v121);
        }
        *__error() = v118;
      }
      objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String");
      sub_1000301F0("SaveReport", "reporting.m", 383, "%s: No app name for cpu resource report %s", v142, v143, v144, v145, (char)"appName");
      goto LABEL_132;
    case 6:
      v54 = objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "name");
      if (!v54)
      {
        if (byte_1000EBD38)
        {
          v122 = *__error();
          v123 = (char *)sub_100030318();
          if (os_log_type_enabled((os_log_t)v123, OS_LOG_TYPE_ERROR))
            sub_10008CD44(a1, v123);
          *__error() = v122;
        }
        if (byte_1000EBD39)
          v124 = dword_1000EB4E8 <= 3;
        else
          v124 = 0;
        if (v124)
        {
          v125 = *__error();
          v126 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No app name for cpu resource report %s"), "appName", objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String"));
          if (v126)
          {
            v136 = v126;
            v137 = CFStringGetCStringPtr(v126, 0x8000100u);
            if (v137)
            {
              v138 = (char *)v137;
              v139 = 0;
            }
            else
            {
              v138 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4B8C3696uLL);
              CFStringGetCString(v136, v138, 1024, 0x8000100u);
              v139 = v138;
            }
            if (qword_1000EBD40)
              v146 = (FILE *)qword_1000EBD40;
            else
              v146 = __stderrp;
            fprintf(v146, "%s\n", v138);
            if (v139)
              free(v139);
            CFRelease(v136);
          }
          else
          {
            v127 = (char *)sub_100030318();
            if (os_log_type_enabled((os_log_t)v127, OS_LOG_TYPE_FAULT))
              sub_10008CCC4(a1, v127);
            if (qword_1000EBD40)
              v128 = (FILE *)qword_1000EBD40;
            else
              v128 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v128);
          }
          *__error() = v125;
        }
        objc_msgSend(objc_msgSend(objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess"), "debugDescription"), "UTF8String");
        sub_1000301F0("SaveReport", "reporting.m", 409, "%s: No app name for cpu resource report %s", v147, v148, v149, v150, (char)"appName");
LABEL_132:
        abort();
      }
      v33 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%@.diskwrites_resource"), v54);
      if (v15 && qword_1000EBC50 != -1)
        dispatch_once(&qword_1000EBC50, &stru_1000DD2B8);
      v34 = CFSTR("145");
LABEL_71:
      if (a12)
      {
        if (byte_1000EBD38)
        {
          v91 = *__error();
          v92 = sub_100030318();
          if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
            sub_10008CE38(v92);
          *__error() = v91;
        }
        if (byte_1000EBD39)
          v93 = dword_1000EB4E8 <= 3;
        else
          v93 = 0;
        if (v93)
        {
          v94 = *__error();
          v95 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: asking for URL when generating report via OSA"), "!url_out");
          if (v95)
          {
            v111 = v95;
            v112 = CFStringGetCStringPtr(v95, 0x8000100u);
            if (v112)
            {
              v113 = (char *)v112;
              v114 = 0;
            }
            else
            {
              v113 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBE5AC277uLL);
              CFStringGetCString(v111, v113, 1024, 0x8000100u);
              v114 = v113;
            }
            if (qword_1000EBD40)
              v129 = (FILE *)qword_1000EBD40;
            else
              v129 = __stderrp;
            fprintf(v129, "%s\n", v113);
            if (v114)
              free(v114);
            CFRelease(v111);
          }
          else
          {
            v96 = sub_100030318();
            if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT))
              sub_10008CDC4(v96, v97, v98);
            if (qword_1000EBD40)
              v99 = (FILE *)qword_1000EBD40;
            else
              v99 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v99);
          }
          *__error() = v94;
        }
        sub_1000301F0("SaveReport", "reporting.m", 554, "%s: asking for URL when generating report via OSA", a5, a6, a7, a8, (char)"!url_out");
        goto LABEL_132;
      }
      v65 = objc_msgSend(objc_msgSend(a1, "sampleStore"), "targetProcess");
      if (objc_msgSend(v65, "developerType") == 1)
      {
        v66 = 1;
      }
      else if (objc_msgSend(v65, "developerType") == -1 && objc_msgSend(v65, "bundleIdentifier"))
      {
        v66 = (uint64_t)objc_msgSend(objc_msgSend(v65, "bundleIdentifier"), "hasPrefix:", CFSTR("com.apple."));
      }
      else
      {
        v66 = 0;
      }
      v155[0] = kOSALogMetadataAppName;
      if ((_DWORD)a4 == 4)
      {
        v67 = CFSTR("shutdown_stall");
      }
      else
      {
        v68 = (const __CFString *)objc_msgSend(v65, "name");
        if (v68)
          v67 = v68;
        else
          v67 = CFSTR("Unknown");
      }
      v156[0] = v67;
      v155[1] = CFSTR("app_name");
      v69 = (const __CFString *)objc_msgSend(v65, "name");
      if (v69)
        v70 = v69;
      else
        v70 = CFSTR("Unknown");
      v156[1] = v70;
      v155[2] = CFSTR("is_first_party");
      v156[2] = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", v66);
      v155[3] = CFSTR("share_with_app_devs");
      v156[3] = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", -[OSASystemConfiguration optIn3rdParty](+[OSASystemConfiguration sharedInstance](OSASystemConfiguration, "sharedInstance"), "optIn3rdParty"));
      v71 = -[NSDictionary mutableCopy](+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v156, v155, 4), "mutableCopy");
      if (objc_msgSend(a1, "incidentUUID"))
      {
        v72 = objc_msgSend(objc_msgSend(a1, "incidentUUID"), "UUIDString");
        objc_msgSend(v71, "setObject:forKeyedSubscript:", v72, kOSALogMetadataIncidentID);
      }
      if (objc_msgSend(v65, "mainBinary"))
      {
        v73 = (const __CFString *)objc_msgSend(objc_msgSend(objc_msgSend(v65, "mainBinary"), "uuid"), "UUIDString");
        if (v73)
          v74 = v73;
        else
          v74 = &stru_1000E0D48;
        objc_msgSend(v71, "setObject:forKeyedSubscript:", v74, CFSTR("slice_uuid"));
      }
      if (objc_msgSend(v65, "bundleIdentifier"))
      {
        v75 = objc_msgSend(v65, "bundleIdentifier");
        objc_msgSend(v71, "setObject:forKeyedSubscript:", v75, kOSALogMetadataBundleID);
      }
      if (objc_msgSend(v65, "bundleVersion"))
        objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "bundleVersion"), CFSTR("build_version"));
      if (objc_msgSend(v65, "bundleShortVersion"))
        objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "bundleShortVersion"), CFSTR("app_version"));
      if (objc_msgSend(v65, "isBeta"))
      {
        objc_msgSend(v71, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("is_beta"));
        if (objc_msgSend(v65, "cohortID"))
          objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "cohortID"), CFSTR("app_cohort"));
      }
      if (objc_msgSend(v65, "adamID"))
        objc_msgSend(v71, "setObject:forKeyedSubscript:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu"), objc_msgSend(v65, "adamID")), CFSTR("adam_id"));
      if (objc_msgSend(v65, "distributorID"))
        objc_msgSend(v71, "setObject:forKeyedSubscript:", objc_msgSend(v65, "distributorID"), CFSTR("distributor_id"));
      if (v14 && objc_msgSend(objc_msgSend(v65, "mainBinaryPath"), "isAbsolutePath"))
      {
        v76 = objc_msgSend(v65, "mainBinaryPath");
        objc_msgSend(v71, "setObject:forKeyedSubscript:", v76, kOSALogOptionReopenPath);
      }
      if (a9 > 0.0)
      {
        sub_1000266AC(v154, 0x32uLL, 0, a9);
        objc_msgSend(v71, "setObject:forKeyedSubscript:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v154), CFSTR("timestamp"));
      }
      if (a10 > 0.0)
        objc_msgSend(v71, "setObject:forKeyedSubscript:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%.0f"), a10 * 1000.0), CFSTR("duration_ms"));
      v152[0] = _NSConcreteStackBlock;
      v152[1] = 3221225472;
      v152[2] = sub_10004E4B8;
      v152[3] = &unk_1000DD2E0;
      v153 = a4;
      v152[4] = a1;
      v152[5] = a2;
      v152[6] = a3;
      v50 = OSAWriteLogForSubmission(v34, v33, v71, 0, v152);

      return v50;
    case 7:
      v34 = (const __CFString *)kOSAProblemTypeNewMicroSS;
      v33 = CFSTR("periodic-microstackshot-report");
      goto LABEL_71;
    case 8:
      goto LABEL_71;
    case 9:
    case 10:
      v34 = 0;
      v33 = 0;
      goto LABEL_71;
    case 14:
      v33 = 0;
      v34 = CFSTR("239");
      goto LABEL_71;
    default:
      v55 = *__error();
      v56 = sub_100030318();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
        sub_10008CB54(a4, v56, v57);
      *__error() = v55;
      if (byte_1000EBD39)
        v58 = dword_1000EB4E8 <= 4;
      else
        v58 = 0;
      if (!v58)
        return 0;
      v59 = *__error();
      v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SaveReport: Unsupported status %d"), a4);
      if (v60)
      {
        v61 = v60;
        v62 = CFStringGetCStringPtr(v60, 0x8000100u);
        if (v62)
        {
          v63 = (char *)v62;
          v64 = 0;
        }
        else
        {
          v63 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xECEB58AFuLL);
          CFStringGetCString(v61, v63, 1024, 0x8000100u);
          v64 = v63;
        }
        if (qword_1000EBD40)
          v90 = (FILE *)qword_1000EBD40;
        else
          v90 = __stderrp;
        fprintf(v90, "%s\n", v63);
        if (v64)
          free(v64);
        CFRelease(v61);
      }
      else
      {
        v82 = sub_100030318();
        if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
          sub_10008CAEC(a4, v82, v83);
        if (qword_1000EBD40)
          v84 = (FILE *)qword_1000EBD40;
        else
          v84 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v84);
      }
      v50 = 0;
      *__error() = v59;
      return v50;
  }
}

void sub_10004E31C(id a1)
{
  int v1;
  NSObject *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  int v11;
  const __CFString *v12;
  const __CFString *v13;
  const char *CStringPtr;
  char *v15;
  char *v16;
  NSObject *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  FILE *v25;
  FILE *v26;

  v1 = *__error();
  v2 = sub_100030318();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
    sub_10008D0E8(v2, v3, v4, v5, v6, v7, v8, v9);
  *__error() = v1;
  if (byte_1000EBD39)
    v10 = dword_1000EB4E8 <= 4;
  else
    v10 = 0;
  if (v10)
  {
    v11 = *__error();
    v12 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No bug type for fatal disk writes reports, using non-fatal bug type"));
    if (v12)
    {
      v13 = v12;
      CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
      if (CStringPtr)
      {
        v15 = (char *)CStringPtr;
        v16 = 0;
      }
      else
      {
        v15 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE9C6C32uLL);
        CFStringGetCString(v13, v15, 1024, 0x8000100u);
        v16 = v15;
      }
      if (qword_1000EBD40)
        v26 = (FILE *)qword_1000EBD40;
      else
        v26 = __stderrp;
      fprintf(v26, "%s\n", v15);
      if (v16)
        free(v16);
      CFRelease(v13);
    }
    else
    {
      v17 = sub_100030318();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
        sub_10008D0B8(v17, v18, v19, v20, v21, v22, v23, v24);
      if (qword_1000EBD40)
        v25 = (FILE *)qword_1000EBD40;
      else
        v25 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
    }
    *__error() = v11;
  }
}

int *sub_10004E4B8(uint64_t a1, void *a2)
{
  int v4;
  FILE *v5;
  FILE *v6;
  void *v7;
  int v8;
  NSObject *v9;
  int v10;
  uint64_t v11;
  char *v12;
  const __CFString *v13;
  const __CFString *v14;
  const char *v15;
  char *v16;
  char *v17;
  NSObject *v18;
  FILE *v19;
  FILE *v20;
  int v21;
  NSObject *v22;
  int v23;
  uint64_t v24;
  char *v25;
  const __CFString *v26;
  const __CFString *v27;
  const char *v28;
  char *v29;
  char *v30;
  NSObject *v31;
  FILE *v32;
  FILE *v33;
  int *result;
  int v35;
  NSObject *v36;
  BOOL v37;
  int v38;
  const __CFString *v39;
  const __CFString *v40;
  const char *CStringPtr;
  char *v42;
  char *v43;
  int v44;
  NSObject *v45;
  int *v46;
  const __CFString *v47;
  const __CFString *v48;
  const char *v49;
  malloc_type_id_t v50;
  int v51;
  NSObject *v52;
  BOOL v53;
  int *v54;
  const __CFString *v55;
  char *v56;
  char *v57;
  NSObject *v58;
  NSObject *v59;
  FILE *v60;
  const __CFString *v61;
  NSObject *v62;
  FILE *v63;
  FILE *v64;

  if (objc_msgSend(a2, "fileDescriptor") == -1)
  {
    v35 = *__error();
    v36 = sub_100030318();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_FAULT))
      sub_10008D18C(a2, v36);
    result = __error();
    *result = v35;
    if (byte_1000EBD39)
      v37 = dword_1000EB4E8 <= 4;
    else
      v37 = 0;
    if (v37)
    {
      v38 = *__error();
      v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("OSAWriteLogForSubmission provided invalid fd: %@"), objc_msgSend(a2, "debugDescription"));
      if (v39)
      {
        v40 = v39;
        CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
        if (CStringPtr)
        {
          v42 = (char *)CStringPtr;
          v43 = 0;
        }
        else
        {
          v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCB4EB3E7uLL);
          CFStringGetCString(v40, v42, 1024, 0x8000100u);
          v43 = v42;
        }
        if (qword_1000EBD40)
          v60 = (FILE *)qword_1000EBD40;
        else
          v60 = __stderrp;
        fprintf(v60, "%s\n", v42);
        if (v43)
          free(v43);
        v61 = v40;
        goto LABEL_111;
      }
      v58 = sub_100030318();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_FAULT))
        sub_10008D118(a2, v58);
      goto LABEL_99;
    }
  }
  else
  {
    v4 = dup((int)objc_msgSend(a2, "fileDescriptor"));
    if (v4 == -1)
    {
      v51 = *__error();
      v52 = sub_100030318();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_FAULT))
        sub_10008D270();
      result = __error();
      *result = v51;
      if (byte_1000EBD39)
        v53 = dword_1000EB4E8 <= 4;
      else
        v53 = 0;
      if (v53)
      {
        v38 = *__error();
        v54 = __error();
        v55 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("dup of OSA file handle failed: %{errnod}d"), *v54);
        if (v55)
        {
          v48 = v55;
          v49 = CFStringGetCStringPtr(v55, 0x8000100u);
          if (!v49)
          {
            v50 = 1681766229;
            goto LABEL_104;
          }
LABEL_85:
          v56 = (char *)v49;
          v57 = 0;
LABEL_105:
          if (qword_1000EBD40)
            v64 = (FILE *)qword_1000EBD40;
          else
            v64 = __stderrp;
          fprintf(v64, "%s\n", v56);
          if (v57)
            free(v57);
          v61 = v48;
LABEL_111:
          CFRelease(v61);
LABEL_112:
          result = __error();
          *result = v38;
          return result;
        }
        v62 = sub_100030318();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
          sub_10008D200();
LABEL_99:
        if (qword_1000EBD40)
          v63 = (FILE *)qword_1000EBD40;
        else
          v63 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v63);
        goto LABEL_112;
      }
    }
    else
    {
      v5 = fdopen(v4, "a");
      if (v5)
      {
        v6 = v5;
        if (*(_DWORD *)(a1 + 56) == 4)
        {
          fwrite("Use spindump -i to generate textual report\n\n", 0x2CuLL, 1uLL, v5);
          objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "sampleStore"), "saveBinaryFormatToStream:", v6);
        }
        else
        {
          v7 = *(void **)(a1 + 40);
          if (v7)
          {
            if (fwrite(objc_msgSend(v7, "bytes"), (size_t)objc_msgSend(*(id *)(a1 + 40), "length"), 1uLL, v6) != 1)
            {
              if (byte_1000EBD38)
              {
                v8 = *__error();
                v9 = sub_100030318();
                if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
                  sub_10008D504(v6);
                *__error() = v8;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v10 = *__error();
                v11 = ferror(v6);
                v12 = strerror(v11);
                v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write pre-blob to output file: %d (%s)"), v11, v12);
                if (v13)
                {
                  v14 = v13;
                  v15 = CFStringGetCStringPtr(v13, 0x8000100u);
                  if (v15)
                  {
                    v16 = (char *)v15;
                    v17 = 0;
                  }
                  else
                  {
                    v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1BE1B1BEuLL);
                    CFStringGetCString(v14, v16, 1024, 0x8000100u);
                    v17 = v16;
                  }
                  if (qword_1000EBD40)
                    v20 = (FILE *)qword_1000EBD40;
                  else
                    v20 = __stderrp;
                  fprintf(v20, "%s\n", v16);
                  if (v17)
                    free(v17);
                  CFRelease(v14);
                }
                else
                {
                  v18 = sub_100030318();
                  if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
                    sub_10008D498(v6);
                  if (qword_1000EBD40)
                    v19 = (FILE *)qword_1000EBD40;
                  else
                    v19 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
                }
                *__error() = v10;
              }
            }
            fwrite("\n================================================================\n", 0x42uLL, 1uLL, v6);
          }
          objc_msgSend(*(id *)(a1 + 32), "printToStream:", v6);
          if (*(_QWORD *)(a1 + 48))
          {
            fwrite("\n================================================================\n", 0x42uLL, 1uLL, v6);
            if (fwrite(objc_msgSend(*(id *)(a1 + 48), "bytes"), (size_t)objc_msgSend(*(id *)(a1 + 48), "length"), 1uLL, v6) != 1)
            {
              if (byte_1000EBD38)
              {
                v21 = *__error();
                v22 = sub_100030318();
                if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                  sub_10008D42C(v6);
                *__error() = v21;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v23 = *__error();
                v24 = ferror(v6);
                v25 = strerror(v24);
                v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write post-blob to output file: %d (%s)"), v24, v25);
                if (v26)
                {
                  v27 = v26;
                  v28 = CFStringGetCStringPtr(v26, 0x8000100u);
                  if (v28)
                  {
                    v29 = (char *)v28;
                    v30 = 0;
                  }
                  else
                  {
                    v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5B11B88uLL);
                    CFStringGetCString(v27, v29, 1024, 0x8000100u);
                    v30 = v29;
                  }
                  if (qword_1000EBD40)
                    v33 = (FILE *)qword_1000EBD40;
                  else
                    v33 = __stderrp;
                  fprintf(v33, "%s\n", v29);
                  if (v30)
                    free(v30);
                  CFRelease(v27);
                }
                else
                {
                  v31 = sub_100030318();
                  if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
                    sub_10008D3C0(v6);
                  if (qword_1000EBD40)
                    v32 = (FILE *)qword_1000EBD40;
                  else
                    v32 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
                }
                *__error() = v23;
              }
            }
          }
        }
        return (int *)fclose(v6);
      }
      v44 = *__error();
      v45 = sub_100030318();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
        sub_10008D350();
      result = __error();
      *result = v44;
      if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
      {
        v38 = *__error();
        v46 = __error();
        v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("unable to fdopen OSA dup fd: %{errno}d"), *v46);
        if (v47)
        {
          v48 = v47;
          v49 = CFStringGetCStringPtr(v47, 0x8000100u);
          if (!v49)
          {
            v50 = 3094833571;
LABEL_104:
            v56 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v50);
            CFStringGetCString(v48, v56, 1024, 0x8000100u);
            v57 = v56;
            goto LABEL_105;
          }
          goto LABEL_85;
        }
        v59 = sub_100030318();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
          sub_10008D2E0();
        goto LABEL_99;
      }
    }
  }
  return result;
}

const __CFString *sub_10004ED04(int a1, int a2)
{
  const __CFString *v2;
  const __CFString *v3;

  v2 = CFSTR("--------------------------------------------------\nTimeline format: stacks are sorted chronologically\nUse -i and -heavy to re-report with count sorting\n--------------------------------------------------");
  if (a1)
    v2 = CFSTR("------------------------------------------------------------\nHeavy format: stacks are sorted by count\nUse -i and -timeline to re-report with chronological sorting\n------------------------------------------------------------");
  v3 = CFSTR("--------------------------------------------------\nTimeline format: stacks are sorted chronologically\n--------------------------------------------------");
  if (a1)
    v3 = CFSTR("----------------------------------------\nHeavy format: stacks are sorted by count\n----------------------------------------");
  if (a2)
    return v2;
  else
    return v3;
}

void sub_10004ED3C(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 8u);
}

void sub_10004ED50(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 8u);
}

void sub_10004ED70(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_fault_impl(a1, v9, OS_LOG_TYPE_FAULT, a4, &a9, 0x16u);
}

void sub_10004ED84(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0x16u);
}

id sub_10004ED98(void *a1, const char *a2)
{
  return objc_msgSend(a1, "sampleStore");
}

uint64_t sub_10004EDA0(FILE *a1)
{
  return ferror(a1);
}

char *sub_10004EDA8(int __errnum)
{
  return strerror(__errnum);
}

int *sub_10004EDB0()
{
  return __error();
}

uint64_t sub_10004EDCC(NSString *a1, void *a2, uint64_t a3, int a4, int a5, unsigned int a6, _QWORD *a7)
{
  NSString *v12;
  const __CFString *v13;
  uint64_t v14;
  NSString *v15;
  const __CFString *v16;
  const __CFString *v17;
  int v18;
  uint64_t v19;
  NSString *i;
  _QWORD *v22;
  stat v24;
  stat v25;

  memset(&v25, 0, sizeof(v25));
  if (a1)
  {
    v12 = a1;
    if (stat(-[NSString fileSystemRepresentation](a1, "fileSystemRepresentation"), &v25)
      || (v25.st_mode & 0xF000) != 0x4000)
    {
      v14 = sub_10002D718(-[NSString UTF8String](v12, "UTF8String"), a4, a5, a6);
      if (!a7)
        return v14;
      goto LABEL_21;
    }
    v13 = (const __CFString *)v12;
  }
  else
  {
    v13 = CFSTR("/tmp");
  }
  v22 = a7;
  if (a2)
  {
    if ((a3 & 0x80000000) != 0)
      v15 = (NSString *)objc_msgSend(a2, "stringByReplacingOccurrencesOfString:withString:", CFSTR(" "), CFSTR("_"));
    else
      v15 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@_%i"), objc_msgSend(a2, "stringByReplacingOccurrencesOfString:withString:", CFSTR(" "), CFSTR("_")), a3);
    v16 = (const __CFString *)v15;
    v17 = CFSTR(".spindump.txt");
  }
  else
  {
    v16 = CFSTR("spindump");
    v17 = CFSTR(".txt");
  }
  v12 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@%@"), v13, v16, v17);
  v18 = a4 | 0x800;
  LODWORD(v19) = 1;
  memset(&v24, 0, sizeof(v24));
  do
  {
    for (i = v12; !stat(-[NSString fileSystemRepresentation](i, "fileSystemRepresentation"), &v24); v12 = i)
    {
      v19 = (v19 + 1);
      i = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@/%@.%d%@"), v13, v16, v19, v17);
    }
    v14 = sub_10002D718(-[NSString UTF8String](v12, "UTF8String"), v18, a5, a6);
  }
  while ((_DWORD)v14 == -1 && *__error() == 17);
  a7 = v22;
  if (v22)
LABEL_21:
    *a7 = v12;
  return v14;
}

BOOL sub_10004EFD4()
{
  return objc_opt_class(BGSystemTaskScheduler) != 0;
}

void sub_10004EFF8()
{
  int v0;
  NSObject *v1;
  BOOL v2;
  int v3;
  const __CFString *v4;
  const __CFString *v5;
  const char *CStringPtr;
  char *v7;
  char *v8;
  NSObject *v9;
  FILE *v10;
  FILE *v11;
  uint8_t buf[16];

  if (objc_opt_class(BGSystemTaskScheduler))
  {
    if (qword_1000EBC60 != -1)
      dispatch_once(&qword_1000EBC60, &stru_1000DD4A0);
    dispatch_async((dispatch_queue_t)qword_1000EBC58, &stru_1000DD3F0);
  }
  else
  {
    if (byte_1000EBD38)
    {
      v0 = *__error();
      v1 = sub_100030318();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_INFO, "Deferred reports not supported, not checking for them", buf, 2u);
      }
      *__error() = v0;
    }
    if (byte_1000EBD39)
      v2 = dword_1000EB4E8 <= 1;
    else
      v2 = 0;
    if (v2)
    {
      v3 = *__error();
      v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Deferred reports not supported, not checking for them"));
      if (v4)
      {
        v5 = v4;
        CStringPtr = CFStringGetCStringPtr(v4, 0x8000100u);
        if (CStringPtr)
        {
          v7 = (char *)CStringPtr;
          v8 = 0;
        }
        else
        {
          v7 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF8EFF864uLL);
          CFStringGetCString(v5, v7, 1024, 0x8000100u);
          v8 = v7;
        }
        if (qword_1000EBD40)
          v11 = (FILE *)qword_1000EBD40;
        else
          v11 = __stderrp;
        fprintf(v11, "%s\n", v7);
        if (v8)
          free(v8);
        CFRelease(v5);
      }
      else
      {
        v9 = sub_100030318();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
          sub_10008D570();
        if (qword_1000EBD40)
          v10 = (FILE *)qword_1000EBD40;
        else
          v10 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v10);
      }
      *__error() = v3;
    }
  }
}

void sub_10004F21C(id a1)
{
  id v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  malloc_type_id_t v9;
  int v10;
  NSObject *v11;
  BOOL v12;
  const __CFString *v13;
  char *v14;
  char *v15;
  NSObject *v16;
  NSObject *v17;
  FILE *v18;
  FILE *v19;

  v1 = +[BGSystemTaskScheduler sharedScheduler](BGSystemTaskScheduler, "sharedScheduler");
  if (qword_1000EBC60 != -1)
    dispatch_once(&qword_1000EBC60, &stru_1000DD4A0);
  if (objc_msgSend(v1, "registerForTaskWithIdentifier:usingQueue:launchHandler:", CFSTR("com.apple.spindump.deferred_report_generation"), qword_1000EBC58, &stru_1000DD430))
  {
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        sub_10008D5D0();
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 0;
    else
      v4 = 0;
    if (!v4)
      return;
    v5 = *__error();
    v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Registered for deferred report generation"));
    if (v6)
    {
      v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (!CStringPtr)
      {
        v9 = 1255908753;
LABEL_35:
        v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v9);
        CFStringGetCString(v7, v14, 1024, 0x8000100u);
        v15 = v14;
        goto LABEL_36;
      }
      goto LABEL_25;
    }
    v16 = sub_100030318();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
      sub_10008D5A0();
    goto LABEL_30;
  }
  v10 = *__error();
  v11 = sub_100030318();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
    sub_10008D62C();
  *__error() = v10;
  if (byte_1000EBD39)
    v12 = dword_1000EB4E8 <= 4;
  else
    v12 = 0;
  if (v12)
  {
    v5 = *__error();
    v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to register for deferred report generation"));
    if (v13)
    {
      v7 = v13;
      CStringPtr = CFStringGetCStringPtr(v13, 0x8000100u);
      if (!CStringPtr)
      {
        v9 = 3015652427;
        goto LABEL_35;
      }
LABEL_25:
      v14 = (char *)CStringPtr;
      v15 = 0;
LABEL_36:
      if (qword_1000EBD40)
        v19 = (FILE *)qword_1000EBD40;
      else
        v19 = __stderrp;
      fprintf(v19, "%s\n", v14);
      if (v15)
        free(v15);
      CFRelease(v7);
LABEL_42:
      *__error() = v5;
      return;
    }
    v17 = sub_100030318();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
      sub_10008D5FC();
LABEL_30:
    if (qword_1000EBD40)
      v18 = (FILE *)qword_1000EBD40;
    else
      v18 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
    goto LABEL_42;
  }
}

void sub_10004F4E8(id a1, BGNonRepeatingSystemTask *a2)
{
  int v3;
  NSObject *v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  char *CStringPtr;
  char *v9;
  NSObject *v10;
  FILE *v11;
  FILE *v12;
  uint64_t v13;
  _QWORD v14[5];
  _QWORD v15[5];
  _QWORD v16[5];
  char v17;

  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x3020000000;
  v17 = 0;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_100050BB4;
  v15[3] = &unk_1000DD4C8;
  v15[4] = v16;
  -[BGNonRepeatingSystemTask setExpirationHandler:](a2, "setExpirationHandler:", v15);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_100050D7C;
  v14[3] = &unk_1000DD4F0;
  v14[4] = v16;
  if ((sub_100050D8C((uint64_t)v14) & 1) == 0)
  {
    v13 = 0;
    if ((-[BGNonRepeatingSystemTask setTaskExpiredWithRetryAfter:error:](a2, "setTaskExpiredWithRetryAfter:error:", &v13, 0.0) & 1) != 0)goto LABEL_4;
    v3 = *__error();
    v4 = sub_100030318();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_FAULT))
      sub_10008D6BC();
    *__error() = v3;
    if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
    {
      v5 = *__error();
      v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to set expiry: %@"), v13);
      v7 = v6;
      if (v6)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          v9 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC676F883uLL);
          CFStringGetCString(v7, CStringPtr, 1024, 0x8000100u);
          v9 = CStringPtr;
        }
        if (qword_1000EBD40)
          v12 = (FILE *)qword_1000EBD40;
        else
          v12 = __stderrp;
        fprintf(v12, "%s\n", CStringPtr);
        if (v9)
          free(v9);
        CFRelease(v7);
      }
      else
      {
        v10 = sub_100030318();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
          sub_10008D65C();
        if (qword_1000EBD40)
          v11 = (FILE *)qword_1000EBD40;
        else
          v11 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
      }
      *__error() = v5;
    }
  }
  -[BGNonRepeatingSystemTask setTaskCompleted](a2, "setTaskCompleted");
LABEL_4:
  _Block_object_dispose(v16, 8);
}

void sub_10004F764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004F7A0(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t v20;
  _QWORD block[14];
  int v22;

  v20 = sub_100030160("create deferred cpu usage report for [%d]", a1);
  if (qword_1000EBC60 != -1)
    dispatch_once(&qword_1000EBC60, &stru_1000DD4A0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10004F8A4;
  block[3] = &unk_1000DD458;
  v22 = a1;
  block[7] = a3;
  block[8] = a4;
  block[4] = a2;
  block[5] = a5;
  *(double *)&block[9] = a6;
  *(double *)&block[10] = a7;
  *(double *)&block[11] = a8;
  *(double *)&block[12] = a9;
  *(double *)&block[13] = a10;
  block[6] = v20;
  dispatch_async((dispatch_queue_t)qword_1000EBC58, block);
}

void sub_10004F8A4(uint64_t a1)
{
  id v2;

  v2 = objc_alloc_init((Class)NSMutableDictionary);
  objc_msgSend(v2, "setObject:forKeyedSubscript:", &off_1000E6F30, CFSTR("message"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 112)), CFSTR("pid"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", *(_QWORD *)(a1 + 32), CFSTR("pname"));
  if (*(_QWORD *)(a1 + 56))
    objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"), CFSTR("tid"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 64)), CFSTR("flags"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", *(_QWORD *)(a1 + 40), CFSTR("action"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 72)), CFSTR("cpu"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 80)), CFSTR("duration"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 88)), CFSTR("endtime"));
  if (*(double *)(a1 + 96) > 0.0 && *(double *)(a1 + 104) > 0.0)
  {
    objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:"), CFSTR("cpu_limit"));
    objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 104)), CFSTR("duration_limit"));
  }
  sub_10004FA44((uint64_t)v2);

}

void sub_10004FA44(uint64_t a1)
{
  NSURL *v2;
  _UNKNOWN **v3;
  id v4;
  int v5;
  NSObject *v6;
  int v7;
  const __CFString *v8;
  const __CFString *v9;
  const char *CStringPtr;
  char *v11;
  char *v12;
  int v13;
  NSObject *v14;
  BOOL v15;
  int v16;
  const __CFString *v17;
  const __CFString *v18;
  const char *v19;
  char *v20;
  char *v21;
  NSObject *v22;
  FILE *v23;
  FILE *v24;
  NSObject *v25;
  FILE *v26;
  FILE *v27;
  int v28;
  NSObject *v29;
  id v30;
  int v31;
  const __CFString *v32;
  const __CFString *v33;
  const char *v34;
  char *v35;
  char *v36;
  int v37;
  NSObject *v38;
  int v39;
  id v40;
  const __CFString *v41;
  const __CFString *v42;
  const char *v43;
  char *v44;
  char *v45;
  char *v46;
  FILE *v47;
  NSObject *v48;
  FILE *v49;
  FILE *v50;
  int v51;
  NSObject *v52;
  int v53;
  const __CFString *v54;
  const __CFString *v55;
  const char *v56;
  malloc_type_id_t v57;
  int v58;
  NSObject *v59;
  const __CFString *v60;
  char *v61;
  char *v62;
  id v63;
  int v64;
  NSObject *v65;
  int v66;
  const __CFString *v67;
  const __CFString *v68;
  const char *v69;
  malloc_type_id_t v70;
  int v71;
  NSObject *v72;
  const __CFString *v73;
  char *v74;
  char *v75;
  FILE *v76;
  int v77;
  NSObject *v78;
  const __CFString *v79;
  NSObject *v80;
  NSObject *v81;
  FILE *v82;
  FILE *v83;
  NSObject *v84;
  NSObject *v85;
  FILE *v86;
  FILE *v87;
  int v88;
  NSObject *v89;
  int v90;
  const __CFString *v91;
  const __CFString *v92;
  const char *v93;
  char *v94;
  char *v95;
  NSObject *v96;
  NSObject *v97;
  FILE *v98;
  FILE *v99;
  uint64_t v100;
  uint8_t buf[24];

  v2 = +[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", CFSTR("/private/var/db/spindump/DeferredReports.plist"), 0);
  v3 = &AnalyticsIsEventUsed_ptr;
  if (-[NSFileManager fileExistsAtPath:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:", CFSTR("/private/var/db/spindump/DeferredReports.plist")))
  {
    *(_QWORD *)buf = 0;
    v4 = -[NSArray mutableCopy](+[NSArray arrayWithContentsOfURL:error:](NSArray, "arrayWithContentsOfURL:error:", v2, buf), "mutableCopy");
    if (v4)
      goto LABEL_52;
    v5 = *__error();
    v6 = sub_100030318();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      sub_10008DB60();
    *__error() = v5;
    if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
    {
      v7 = *__error();
      v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to read deferred reports plist, overwriting it: %@"), *(_QWORD *)buf);
      if (v8)
      {
        v9 = v8;
        CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
        if (CStringPtr)
        {
          v11 = (char *)CStringPtr;
          v12 = 0;
        }
        else
        {
          v11 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x547D7233uLL);
          CFStringGetCString(v9, v11, 1024, 0x8000100u);
          v12 = v11;
        }
        if (qword_1000EBD40)
          v27 = (FILE *)qword_1000EBD40;
        else
          v27 = __stderrp;
        fprintf(v27, "%s\n", v11);
        if (v12)
          free(v12);
        CFRelease(v9);
      }
      else
      {
        v25 = sub_100030318();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
          sub_10008DB00();
        if (qword_1000EBD40)
          v26 = (FILE *)qword_1000EBD40;
        else
          v26 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v7;
    }
    v100 = 0;
    if (!-[NSFileManager removeItemAtURL:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtURL:error:", v2, &v100))
    {
      v88 = *__error();
      v89 = sub_100030318();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_FAULT))
        sub_10008D9C8();
      *__error() = v88;
      if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
      {
        v90 = *__error();
        v91 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to remove deferred reports plist: %@"), v100);
        if (v91)
        {
          v92 = v91;
          v93 = CFStringGetCStringPtr(v91, 0x8000100u);
          if (v93)
          {
            v94 = (char *)v93;
            v95 = 0;
          }
          else
          {
            v94 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC44A159DuLL);
            CFStringGetCString(v92, v94, 1024, 0x8000100u);
            v95 = v94;
          }
          if (qword_1000EBD40)
            v99 = (FILE *)qword_1000EBD40;
          else
            v99 = __stderrp;
          fprintf(v99, "%s\n", v94);
          if (v95)
            free(v95);
          CFRelease(v92);
        }
        else
        {
          v97 = sub_100030318();
          if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
            sub_10008D968();
          if (qword_1000EBD40)
            v98 = (FILE *)qword_1000EBD40;
          else
            v98 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
        }
        *__error() = v90;
      }
    }
  }
  else
  {
    if (byte_1000EBD38)
    {
      v13 = *__error();
      v14 = sub_100030318();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        sub_10008DBF0();
      *__error() = v13;
    }
    if (byte_1000EBD39)
      v15 = dword_1000EB4E8 <= 0;
    else
      v15 = 0;
    if (v15)
    {
      v16 = *__error();
      v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No existing deferred reports, creating new plist"));
      if (v17)
      {
        v18 = v17;
        v19 = CFStringGetCStringPtr(v17, 0x8000100u);
        if (v19)
        {
          v20 = (char *)v19;
          v21 = 0;
        }
        else
        {
          v20 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDBF725E7uLL);
          CFStringGetCString(v18, v20, 1024, 0x8000100u);
          v21 = v20;
        }
        if (qword_1000EBD40)
          v24 = (FILE *)qword_1000EBD40;
        else
          v24 = __stderrp;
        fprintf(v24, "%s\n", v20);
        if (v21)
          free(v21);
        CFRelease(v18);
      }
      else
      {
        v22 = sub_100030318();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
          sub_10008DBC0();
        if (qword_1000EBD40)
          v23 = (FILE *)qword_1000EBD40;
        else
          v23 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
      }
      *__error() = v16;
      v3 = &AnalyticsIsEventUsed_ptr;
    }
  }
  v4 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 1);
LABEL_52:
  objc_msgSend(v4, "addObject:", a1);
  v100 = 0;
  if ((objc_msgSend(v4, "writeToURL:error:", v2, &v100) & 1) != 0)
  {
    if (byte_1000EBD38)
    {
      v28 = *__error();
      v29 = sub_100030318();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_INFO))
      {
        v30 = objc_msgSend(v4, "count");
        *(_DWORD *)buf = 134217984;
        *(_QWORD *)&buf[4] = v30;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_INFO, "Added report to pending deferred reports (have %lu)", buf, 0xCu);
      }
      *__error() = v28;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
    {
      v31 = *__error();
      v32 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Added report to pending deferred reports (have %lu)"), objc_msgSend(v4, "count"));
      if (v32)
      {
        v33 = v32;
        v34 = CFStringGetCStringPtr(v32, 0x8000100u);
        if (v34)
        {
          v35 = (char *)v34;
          v36 = 0;
        }
        else
        {
          v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA2C9B765uLL);
          CFStringGetCString(v33, v35, 1024, 0x8000100u);
          v36 = v35;
        }
        if (qword_1000EBD40)
          v50 = (FILE *)qword_1000EBD40;
        else
          v50 = __stderrp;
        fprintf(v50, "%s\n", v35);
        if (v36)
          free(v36);
        CFRelease(v33);
      }
      else
      {
        v46 = (char *)sub_100030318();
        if (os_log_type_enabled((os_log_t)v46, OS_LOG_TYPE_FAULT))
          sub_10008D8F4(v4, v46);
        if (qword_1000EBD40)
          v47 = (FILE *)qword_1000EBD40;
        else
          v47 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
      }
      *__error() = v31;
    }

    if (!objc_opt_class(BGSystemTaskScheduler))
    {
      v58 = *__error();
      v59 = sub_100030318();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
        sub_10008D74C();
      *__error() = v58;
      if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
      {
        v53 = *__error();
        v60 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Attempting to defer reports when not supported. Caller should check before calling"));
        if (v60)
        {
          v55 = v60;
          v56 = CFStringGetCStringPtr(v60, 0x8000100u);
          if (!v56)
          {
            v57 = 39118979;
            goto LABEL_149;
          }
          goto LABEL_106;
        }
        v81 = sub_100030318();
        if (os_log_type_enabled(v81, OS_LOG_TYPE_FAULT))
          sub_10008D71C();
        goto LABEL_144;
      }
      return;
    }
    if (objc_msgSend(+[BGSystemTaskScheduler sharedScheduler](BGSystemTaskScheduler, "sharedScheduler"), "taskRequestForIdentifier:", CFSTR("com.apple.spindump.deferred_report_generation")))
    {
      if (byte_1000EBD38)
      {
        v51 = *__error();
        v52 = sub_100030318();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
          sub_10008D8C8();
        *__error() = v51;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
      {
        v53 = *__error();
        v54 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Deferred report task already exists"));
        if (v54)
        {
          v55 = v54;
          v56 = CFStringGetCStringPtr(v54, 0x8000100u);
          if (!v56)
          {
            v57 = 1778843600;
LABEL_149:
            v61 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v57);
            CFStringGetCString(v55, v61, 1024, 0x8000100u);
            v62 = v61;
            goto LABEL_150;
          }
          goto LABEL_106;
        }
        v80 = sub_100030318();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
          sub_10008D898();
        goto LABEL_144;
      }
      return;
    }
    v63 = objc_msgSend(objc_alloc((Class)BGNonRepeatingSystemTaskRequest), "initWithIdentifier:", CFSTR("com.apple.spindump.deferred_report_generation"));
    objc_msgSend(v63, "setPriority:", 1);
    objc_msgSend(v63, "setScheduleAfter:", 1.0);
    objc_msgSend(v63, "setRequiresNetworkConnectivity:", 0);
    objc_msgSend(v63, "setRequiresExternalPower:", 0);
    *(_QWORD *)buf = 0;
    if ((objc_msgSend(+[BGSystemTaskScheduler sharedScheduler](BGSystemTaskScheduler, "sharedScheduler"), "submitTaskRequest:error:", v63, buf) & 1) != 0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
          sub_10008D7AC();
        *__error() = v64;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_174;
      v66 = *__error();
      v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Submitted deferred report task successfully"));
      if (v67)
      {
        v68 = v67;
        v69 = CFStringGetCStringPtr(v67, 0x8000100u);
        if (!v69)
        {
          v70 = 3303021729;
LABEL_166:
          v74 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v70);
          CFStringGetCString(v68, v74, 1024, 0x8000100u);
          v75 = v74;
          goto LABEL_167;
        }
        goto LABEL_123;
      }
      v84 = sub_100030318();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
        sub_10008D77C();
    }
    else
    {
      v71 = *__error();
      v72 = sub_100030318();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
        sub_10008D838();
      *__error() = v71;
      if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
        goto LABEL_174;
      v66 = *__error();
      v73 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to submit task with error: %@"), *(_QWORD *)buf);
      if (v73)
      {
        v68 = v73;
        v69 = CFStringGetCStringPtr(v73, 0x8000100u);
        if (!v69)
        {
          v70 = 1018071091;
          goto LABEL_166;
        }
LABEL_123:
        v74 = (char *)v69;
        v75 = 0;
LABEL_167:
        if (qword_1000EBD40)
          v87 = (FILE *)qword_1000EBD40;
        else
          v87 = __stderrp;
        fprintf(v87, "%s\n", v74);
        if (v75)
          free(v75);
        CFRelease(v68);
        goto LABEL_173;
      }
      v85 = sub_100030318();
      if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
        sub_10008D7D8();
    }
    if (qword_1000EBD40)
      v86 = (FILE *)qword_1000EBD40;
    else
      v86 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v86);
LABEL_173:
    *__error() = v66;
LABEL_174:

    return;
  }
  v37 = *__error();
  v38 = sub_100030318();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
    sub_10008DA94();
  *__error() = v37;
  if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
  {
    v39 = *__error();
    v40 = objc_msgSend(v4, "count");
    v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write %lu deferred reports to plist: %@"), v40, v100);
    if (v41)
    {
      v42 = v41;
      v43 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v43)
      {
        v44 = (char *)v43;
        v45 = 0;
      }
      else
      {
        v44 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD19FDEA4uLL);
        CFStringGetCString(v42, v44, 1024, 0x8000100u);
        v45 = v44;
      }
      if (qword_1000EBD40)
        v76 = (FILE *)qword_1000EBD40;
      else
        v76 = __stderrp;
      fprintf(v76, "%s\n", v44);
      if (v45)
        free(v45);
      CFRelease(v42);
    }
    else
    {
      v48 = sub_100030318();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
        sub_10008DA28();
      if (qword_1000EBD40)
        v49 = (FILE *)qword_1000EBD40;
      else
        v49 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v49);
    }
    *__error() = v39;
  }

  *(_QWORD *)buf = 0;
  if ((objc_msgSend(objc_msgSend(v3[28], "defaultManager"), "removeItemAtURL:error:", v2, buf) & 1) == 0)
  {
    v77 = *__error();
    v78 = sub_100030318();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
      sub_10008D9C8();
    *__error() = v77;
    if (byte_1000EBD39)
    {
      if (dword_1000EB4E8 <= 4)
      {
        v53 = *__error();
        v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to remove deferred reports plist: %@"), *(_QWORD *)buf);
        if (v79)
        {
          v55 = v79;
          v56 = CFStringGetCStringPtr(v79, 0x8000100u);
          if (!v56)
          {
            v57 = 331909043;
            goto LABEL_149;
          }
LABEL_106:
          v61 = (char *)v56;
          v62 = 0;
LABEL_150:
          if (qword_1000EBD40)
            v83 = (FILE *)qword_1000EBD40;
          else
            v83 = __stderrp;
          fprintf(v83, "%s\n", v61);
          if (v62)
            free(v62);
          CFRelease(v55);
LABEL_156:
          *__error() = v53;
          return;
        }
        v96 = sub_100030318();
        if (os_log_type_enabled(v96, OS_LOG_TYPE_FAULT))
          sub_10008D968();
LABEL_144:
        if (qword_1000EBD40)
          v82 = (FILE *)qword_1000EBD40;
        else
          v82 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v82);
        goto LABEL_156;
      }
    }
  }
}

void sub_1000508EC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, double a7, double a8, double a9)
{
  uint64_t v18;
  _QWORD block[13];
  int v20;

  v18 = sub_100030160("create deferred disk writes report for [%d]", a1);
  if (qword_1000EBC60 != -1)
    dispatch_once(&qword_1000EBC60, &stru_1000DD4A0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000509EC;
  block[3] = &unk_1000DD480;
  v20 = a1;
  block[4] = a2;
  block[5] = a4;
  block[7] = a3;
  block[8] = a5;
  *(double *)&block[9] = a7;
  *(double *)&block[10] = a8;
  block[11] = a6;
  *(double *)&block[12] = a9;
  block[6] = v18;
  dispatch_async((dispatch_queue_t)qword_1000EBC58, block);
}

void sub_1000509EC(uint64_t a1)
{
  id v2;

  v2 = objc_alloc_init((Class)NSMutableDictionary);
  objc_msgSend(v2, "setObject:forKeyedSubscript:", &off_1000E6F48, CFSTR("message"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 104)), CFSTR("pid"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", *(_QWORD *)(a1 + 32), CFSTR("pname"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 56)), CFSTR("flags"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", *(_QWORD *)(a1 + 40), CFSTR("action"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", *(_QWORD *)(a1 + 64)), CFSTR("io"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 72)), CFSTR("duration"));
  objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 80)), CFSTR("endtime"));
  if (*(_QWORD *)(a1 + 88) && *(double *)(a1 + 96) > 0.0)
  {
    objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:"), CFSTR("io_limit"));
    objc_msgSend(v2, "setObject:forKeyedSubscript:", +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:", *(double *)(a1 + 96)), CFSTR("duration_limit"));
  }
  sub_10004FA44((uint64_t)v2);

}

void sub_100050B64(id a1)
{
  NSObject *v1;
  NSObject *v2;

  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = dispatch_queue_attr_make_with_qos_class(v1, QOS_CLASS_BACKGROUND, 0);
  qword_1000EBC58 = (uint64_t)dispatch_queue_create("com.apple.spindump.deferred_report_generation", v2);
  dispatch_release(v2);
}

int *sub_100050BB4(int *result)
{
  int *v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  FILE *v12;
  FILE *v13;

  v1 = result;
  if (byte_1000EBD38)
  {
    v2 = *__error();
    v3 = sub_100030318();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
      sub_10008DC4C();
    result = __error();
    *result = v2;
  }
  if (byte_1000EBD39)
    v4 = dword_1000EB4E8 <= 0;
  else
    v4 = 0;
  if (v4)
  {
    v5 = *__error();
    v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Deferred tasks expired"));
    if (v6)
    {
      v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        v9 = (char *)CStringPtr;
        v10 = 0;
      }
      else
      {
        v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCD89AA88uLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        v10 = v9;
      }
      if (qword_1000EBD40)
        v13 = (FILE *)qword_1000EBD40;
      else
        v13 = __stderrp;
      fprintf(v13, "%s\n", v9);
      if (v10)
        free(v10);
      CFRelease(v7);
    }
    else
    {
      v11 = sub_100030318();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        sub_10008DC1C();
      if (qword_1000EBD40)
        v12 = (FILE *)qword_1000EBD40;
      else
        v12 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    result = __error();
    *result = v5;
  }
  *(_BYTE *)(*(_QWORD *)(*((_QWORD *)v1 + 4) + 8) + 40) = 1;
  return result;
}

uint64_t sub_100050D7C(uint64_t a1)
{
  return *(unsigned __int8 *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
}

uint64_t sub_100050D8C(uint64_t a1)
{
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  FILE *v12;
  FILE *v13;
  NSURL *v14;
  NSArray *v15;
  NSArray *v16;
  uint64_t v17;
  id v18;
  id v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  id v23;
  id v24;
  void *v25;
  id v26;
  id v27;
  uint64_t v28;
  id v29;
  id v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  int v39;
  NSObject *v40;
  int v41;
  const __CFString *v42;
  const __CFString *v43;
  const char *v44;
  malloc_type_id_t v45;
  int v46;
  NSObject *v47;
  BOOL v48;
  const __CFString *v49;
  char *v50;
  char *v51;
  id v52;
  uint64_t v53;
  id v54;
  id v55;
  double v56;
  double v57;
  double v58;
  double v59;
  uint64_t v60;
  double v61;
  double v62;
  int v63;
  NSObject *v64;
  const __CFString *v65;
  int v66;
  NSObject *v67;
  BOOL v68;
  const __CFString *v69;
  const __CFString *v70;
  const char *v71;
  char *v72;
  char *v73;
  int v74;
  NSObject *v75;
  const __CFString *v76;
  int v77;
  NSObject *v78;
  const __CFString *v79;
  NSObject *v80;
  int v81;
  NSObject *v82;
  const __CFString *v83;
  int v84;
  NSObject *v85;
  const __CFString *v86;
  FILE *v87;
  const __CFString *v88;
  int v89;
  NSObject *v90;
  const __CFString *v91;
  NSObject *v92;
  int v93;
  NSObject *v94;
  const __CFString *v95;
  FILE *v96;
  int v97;
  NSObject *v98;
  const __CFString *v99;
  int v100;
  NSObject *v101;
  const __CFString *v102;
  NSObject *v103;
  NSObject *v104;
  NSObject *v105;
  NSObject *v106;
  const char *v107;
  NSObject *v108;
  double v109;
  double v110;
  int v111;
  NSObject *v112;
  const __CFString *v113;
  int v114;
  NSObject *v115;
  const __CFString *v116;
  NSObject *v117;
  id v118;
  _BYTE *v119;
  NSObject *v120;
  id v121;
  _BYTE *v122;
  NSObject *v123;
  NSObject *v124;
  NSObject *v125;
  _DWORD *v126;
  _DWORD *v127;
  const __CFString *v128;
  const __CFString *v129;
  const char *v130;
  char *v131;
  NSObject *v132;
  const __CFString *v133;
  const char *v134;
  char *v135;
  NSObject *v136;
  int v137;
  NSObject *v138;
  _DWORD *v139;
  _DWORD *v140;
  const __CFString *v141;
  NSObject *v142;
  _DWORD *v143;
  int v144;
  NSObject *v145;
  const __CFString *v146;
  const char *v147;
  char *v148;
  NSObject *v149;
  NSObject *v150;
  NSObject *v151;
  FILE *v152;
  NSObject *v153;
  _DWORD *v154;
  FILE *v155;
  FILE *v156;
  char *v157;
  NSObject *v158;
  FILE *v159;
  NSObject *v160;
  FILE *v161;
  FILE *v162;
  int v163;
  NSObject *v164;
  BOOL v165;
  int v166;
  const __CFString *v167;
  const __CFString *v168;
  const char *v169;
  char *v170;
  char *v171;
  int v172;
  NSObject *v173;
  BOOL v174;
  int v175;
  const __CFString *v176;
  const __CFString *v177;
  const char *v178;
  char *v179;
  char *v180;
  int v181;
  NSObject *v182;
  BOOL v183;
  int v184;
  const __CFString *v185;
  const __CFString *v186;
  const char *v187;
  char *v188;
  char *v189;
  NSObject *v190;
  FILE *v191;
  malloc_type_id_t v192;
  FILE *v193;
  int v194;
  NSObject *v195;
  char *v196;
  BOOL v197;
  int v198;
  const __CFString *v199;
  const __CFString *v200;
  const char *v201;
  char *v202;
  char *v203;
  int v204;
  NSObject *v205;
  NSUInteger v206;
  BOOL v207;
  int v208;
  const __CFString *v209;
  const __CFString *v210;
  const char *v211;
  char *v212;
  char *v213;
  NSObject *v214;
  FILE *v215;
  NSObject *v216;
  FILE *v217;
  FILE *v218;
  int v219;
  NSObject *v220;
  const __CFString *v221;
  FILE *v222;
  int v223;
  NSObject *v224;
  const __CFString *v225;
  NSObject *v226;
  FILE *v227;
  char *v228;
  FILE *v229;
  FILE *v230;
  NSArray *v231;
  int v233;
  NSObject *v234;
  int v235;
  id v236;
  const __CFString *v237;
  const __CFString *v238;
  const char *v239;
  char *v240;
  char *v241;
  FILE *v242;
  int v243;
  NSObject *v244;
  const __CFString *v245;
  NSObject *v246;
  FILE *v247;
  FILE *v248;
  NSObject *v249;
  NSObject *v250;
  int v251;
  NSObject *v252;
  const __CFString *v253;
  NSObject *v254;
  NSObject *v255;
  char *v256;
  uint64_t v257;
  char *v258;
  const __CFString *cf;
  char *cfa;
  int v261;
  int v262;
  int v263;
  int v264;
  id v265;
  NSString *v266;
  NSString *v267;
  id v268;
  uint64_t v269;
  char v270;
  char v271[15];
  char v272;
  char v273[7];
  uint64_t v274;
  char v275;
  char v276[15];
  char v277;
  char v278[15];
  char v279;
  char v280[15];
  char v281;
  char v282[15];
  char v283;
  char v284[15];
  char v285;
  char v286[15];
  char v287;
  char v288[15];
  char v289;
  char v290[15];
  char v291;
  char v292[15];
  char v293;
  char v294[15];
  char v295[16];
  _BYTE buf[12];
  __int16 v297;
  unint64_t v298;
  __int128 v299;
  __int128 v300;
  __int128 v301;
  __int128 v302;

  if (byte_1000EBD38)
  {
    v2 = *__error();
    v3 = sub_100030318();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Generating deferred reports", buf, 2u);
    }
    *__error() = v2;
  }
  if (byte_1000EBD39)
    v4 = dword_1000EB4E8 <= 2;
  else
    v4 = 0;
  if (v4)
  {
    v5 = *__error();
    v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Generating deferred reports"));
    if (v6)
    {
      v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        v9 = (char *)CStringPtr;
        v10 = 0;
      }
      else
      {
        v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC85E0EAAuLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        v10 = v9;
      }
      if (qword_1000EBD40)
        v13 = (FILE *)qword_1000EBD40;
      else
        v13 = __stderrp;
      fprintf(v13, "%s\n", v9);
      if (v10)
        free(v10);
      CFRelease(v7);
    }
    else
    {
      v11 = sub_100030318();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        sub_10008E23C();
      if (qword_1000EBD40)
        v12 = (FILE *)qword_1000EBD40;
      else
        v12 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    *__error() = v5;
  }
  if (!-[NSFileManager fileExistsAtPath:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "fileExistsAtPath:", CFSTR("/private/var/db/spindump/DeferredReports.plist")))
  {
    if (byte_1000EBD38)
    {
      v163 = *__error();
      v164 = sub_100030318();
      if (os_log_type_enabled(v164, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v164, OS_LOG_TYPE_DEFAULT, "No deferred reports", buf, 2u);
      }
      *__error() = v163;
    }
    if (byte_1000EBD39)
      v165 = dword_1000EB4E8 <= 2;
    else
      v165 = 0;
    if (!v165)
      return 1;
    v166 = *__error();
    v167 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No deferred reports"));
    if (v167)
    {
      v168 = v167;
      v169 = CFStringGetCStringPtr(v167, 0x8000100u);
      if (!v169)
      {
        v192 = 1034863384;
        goto LABEL_363;
      }
      goto LABEL_331;
    }
    v190 = sub_100030318();
    if (os_log_type_enabled(v190, OS_LOG_TYPE_FAULT))
      sub_10008E20C();
    goto LABEL_358;
  }
  v14 = +[NSURL fileURLWithPath:isDirectory:](NSURL, "fileURLWithPath:isDirectory:", CFSTR("/private/var/db/spindump/DeferredReports.plist"), 0);
  v274 = 0;
  v15 = +[NSArray arrayWithContentsOfURL:error:](NSArray, "arrayWithContentsOfURL:error:", v14, &v274);
  if (!v15)
  {
    if (byte_1000EBD38)
    {
      v181 = *__error();
      v182 = sub_100030318();
      if (os_log_type_enabled(v182, OS_LOG_TYPE_ERROR))
        sub_10008DCD8();
      *__error() = v181;
    }
    if (byte_1000EBD39)
      v183 = dword_1000EB4E8 <= 3;
    else
      v183 = 0;
    if (v183)
    {
      v184 = *__error();
      v185 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to read deferred reports plist: %@"), v274);
      if (v185)
      {
        v186 = v185;
        v187 = CFStringGetCStringPtr(v185, 0x8000100u);
        if (v187)
        {
          v188 = (char *)v187;
          v189 = 0;
        }
        else
        {
          v188 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA9096A30uLL);
          CFStringGetCString(v186, v188, 1024, 0x8000100u);
          v189 = v188;
        }
        if (qword_1000EBD40)
          v222 = (FILE *)qword_1000EBD40;
        else
          v222 = __stderrp;
        fprintf(v222, "%s\n", v188);
        if (v189)
          free(v189);
        CFRelease(v186);
      }
      else
      {
        v216 = sub_100030318();
        if (os_log_type_enabled(v216, OS_LOG_TYPE_FAULT))
          sub_10008DC78();
        if (qword_1000EBD40)
          v217 = (FILE *)qword_1000EBD40;
        else
          v217 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v217);
      }
      *__error() = v184;
    }
    *(_QWORD *)buf = 0;
    if (-[NSFileManager removeItemAtURL:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtURL:error:", v14, buf))
    {
      return 1;
    }
    v223 = *__error();
    v224 = sub_100030318();
    if (os_log_type_enabled(v224, OS_LOG_TYPE_FAULT))
      sub_10008D9C8();
    *__error() = v223;
    if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
      return 1;
    v166 = *__error();
    v225 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to remove deferred reports plist: %@"), *(_QWORD *)buf);
    if (v225)
    {
      v168 = v225;
      v169 = CFStringGetCStringPtr(v225, 0x8000100u);
      if (v169)
        goto LABEL_331;
      v192 = 2680440707;
      goto LABEL_363;
    }
    v250 = sub_100030318();
    if (!os_log_type_enabled(v250, OS_LOG_TYPE_FAULT))
      goto LABEL_358;
LABEL_503:
    sub_10008D968();
    goto LABEL_358;
  }
  v16 = v15;
  v17 = objc_opt_class(NSDictionary);
  v299 = 0u;
  v300 = 0u;
  v301 = 0u;
  v302 = 0u;
  v18 = -[NSArray countByEnumeratingWithState:objects:count:](v16, "countByEnumeratingWithState:objects:count:", &v299, buf, 16);
  if (!v18)
    goto LABEL_37;
  v19 = v18;
  v20 = *(_QWORD *)v300;
LABEL_31:
  v21 = 0;
  while (1)
  {
    if (*(_QWORD *)v300 != v20)
      objc_enumerationMutation(v16);
    if ((objc_opt_isKindOfClass(*(_QWORD *)(*((_QWORD *)&v299 + 1) + 8 * v21), v17) & 1) == 0)
      break;
    if (v19 == (id)++v21)
    {
      v19 = -[NSArray countByEnumeratingWithState:objects:count:](v16, "countByEnumeratingWithState:objects:count:", &v299, buf, 16);
      if (!v19)
      {
LABEL_37:
        v22 = 0;
        if (-[NSArray count](v16, "count"))
        {
          while (1)
          {
            if (((*(uint64_t (**)(uint64_t))(a1 + 16))(a1) & 1) != 0)
              goto LABEL_371;
            v23 = -[NSArray objectAtIndexedSubscript:](v16, "objectAtIndexedSubscript:", v22);
            v24 = sub_100053740(v23, (uint64_t)CFSTR("message"));
            if (!v24)
              break;
            v25 = v24;
            v26 = objc_msgSend(v24, "longLongValue");
            if (v26 == (id)5)
            {
              v52 = objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("pid")), "intValue");
              if ((_DWORD)v52)
              {
                v53 = (uint64_t)v52;
                v54 = objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("flags")), "unsignedLongLongValue");
                v55 = objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("io")), "longLongValue");
                if ((uint64_t)v55 <= 0)
                {
                  if (byte_1000EBD38)
                  {
                    v84 = *__error();
                    v85 = sub_100030318();
                    if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(_QWORD *)&buf[4] = v55;
                      _os_log_error_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad bytes (%lld)", buf, 0xCu);
                    }
                    *__error() = v84;
                  }
                  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                    goto LABEL_279;
                  v41 = *__error();
                  v86 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred disk writes resource: bad bytes (%lld)"), v55);
                  if (!v86)
                  {
                    v108 = sub_100030318();
                    if (os_log_type_enabled(v108, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(_QWORD *)&buf[4] = v55;
                      v106 = v108;
                      v107 = "Unable to format: deferred disk writes resource: bad bytes (%lld)";
                      goto LABEL_220;
                    }
                    goto LABEL_274;
                  }
                  v43 = v86;
                  v44 = CFStringGetCStringPtr(v86, 0x8000100u);
                  if (v44)
                    goto LABEL_67;
                  v45 = 3046411982;
                }
                else
                {
                  objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("duration")), "doubleValue");
                  v57 = v56;
                  if (v56 <= 0.0)
                  {
                    if (byte_1000EBD38)
                    {
                      v89 = *__error();
                      v90 = sub_100030318();
                      if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&buf[4] = v57;
                        _os_log_error_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad duration (%f)", buf, 0xCu);
                      }
                      *__error() = v89;
                    }
                    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                      goto LABEL_279;
                    v41 = *__error();
                    v91 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred disk writes resource: bad duration (%f)"), *(_QWORD *)&v57);
                    if (!v91)
                    {
                      v117 = sub_100030318();
                      if (os_log_type_enabled(v117, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&buf[4] = v57;
                        v106 = v117;
                        v107 = "Unable to format: deferred disk writes resource: bad duration (%f)";
                        goto LABEL_220;
                      }
                      goto LABEL_274;
                    }
                    v43 = v91;
                    v44 = CFStringGetCStringPtr(v91, 0x8000100u);
                    if (v44)
                      goto LABEL_67;
                    v45 = 4207070971;
                  }
                  else
                  {
                    objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("endtime")), "doubleValue");
                    if (v58 <= 0.0)
                    {
                      if (byte_1000EBD38)
                      {
                        v97 = *__error();
                        v98 = sub_100030318();
                        if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
                          sub_10008E17C(&v289, v290);
                        *__error() = v97;
                      }
                      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                        goto LABEL_279;
                      v41 = *__error();
                      v99 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred disk writes resource: no endtime provided"));
                      if (!v99)
                      {
                        v123 = sub_100030318();
                        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
                          sub_10008E150(&v287, v288);
                        goto LABEL_274;
                      }
                      v43 = v99;
                      v44 = CFStringGetCStringPtr(v99, 0x8000100u);
                      if (v44)
                        goto LABEL_67;
                      v45 = 4271087085;
                    }
                    else
                    {
                      v59 = v58;
                      v60 = (uint64_t)objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("io_limit")), "longLongValue");
                      if (v60 < 0)
                      {
                        if (byte_1000EBD38)
                        {
                          v114 = *__error();
                          v115 = sub_100030318();
                          if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(_QWORD *)&buf[4] = v60;
                            _os_log_error_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad io_limit_bytes (%lld)", buf, 0xCu);
                          }
                          *__error() = v114;
                        }
                        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                          goto LABEL_279;
                        v41 = *__error();
                        v116 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred disk writes resource: bad io_limit_bytes (%lld)"), v60);
                        if (!v116)
                        {
                          v149 = sub_100030318();
                          if (os_log_type_enabled(v149, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(_QWORD *)&buf[4] = v60;
                            v106 = v149;
                            v107 = "Unable to format: deferred disk writes resource: bad io_limit_bytes (%lld)";
                            goto LABEL_220;
                          }
                          goto LABEL_274;
                        }
                        v43 = v116;
                        v44 = CFStringGetCStringPtr(v116, 0x8000100u);
                        if (v44)
                          goto LABEL_67;
                        v45 = 406402714;
                      }
                      else
                      {
                        objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("duration_limit")), "doubleValue");
                        v62 = v61;
                        if (v61 >= 0.0)
                        {
                          v265 = sub_1000537A0(v23, (uint64_t)CFSTR("pname"));
                          v118 = sub_1000537A0(v23, (uint64_t)CFSTR("action"));
                          if (v118)
                          {
                            v119 = sub_100058234((const char *)objc_msgSend(v118, "UTF8String"));
                            v267 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v119);
                            free(v119);
                          }
                          else
                          {
                            v267 = 0;
                          }
                          if ((v53 & 0x80000000) != 0)
                          {
                            if (byte_1000EBD38)
                            {
                              v263 = *__error();
                              v132 = sub_100030318();
                              if (os_log_type_enabled(v132, OS_LOG_TYPE_INFO))
                              {
                                *(_WORD *)buf = 0;
                                _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_INFO, "deferred disk writes resource: generating deferred report", buf, 2u);
                              }
                              *__error() = v263;
                            }
                            if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
                            {
                              v262 = *__error();
                              v133 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred disk writes resource: generating deferred report"));
                              if (!v133)
                              {
                                v158 = sub_100030318();
                                if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT))
                                  sub_10008E124(&v285, v286);
                                goto LABEL_299;
                              }
                              cf = v133;
                              v134 = CFStringGetCStringPtr(v133, 0x8000100u);
                              if (v134)
                              {
                                v135 = (char *)v134;
                                v258 = 0;
                              }
                              else
                              {
                                v135 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x446032A7uLL);
                                CFStringGetCString(cf, v135, 1024, 0x8000100u);
                                v258 = v135;
                              }
                              if (qword_1000EBD40)
                                v162 = (FILE *)qword_1000EBD40;
                              else
                                v162 = __stderrp;
                              fprintf(v162, "%s\n", v135);
                              v157 = v258;
                              if (v258)
LABEL_295:
                                free(v157);
LABEL_296:
                              CFRelease(cf);
LABEL_303:
                              *__error() = v262;
                            }
                          }
                          else
                          {
                            if (byte_1000EBD38)
                            {
                              v261 = *__error();
                              v125 = sub_100030318();
                              if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
                              {
                                v126 = sub_1000302B4(v53);
                                *(_DWORD *)buf = 136446466;
                                *(_QWORD *)&buf[4] = v126;
                                v297 = 1024;
                                LODWORD(v298) = v53;
                                _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_INFO, "%{public}s [%d]: deferred disk writes resource: generating deferred report", buf, 0x12u);
                              }
                              *__error() = v261;
                            }
                            if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
                            {
                              v262 = *__error();
                              v127 = sub_1000302B4(v53);
                              v128 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: deferred disk writes resource: generating deferred report"), v127, v53);
                              if (v128)
                              {
                                v257 = v60;
                                v129 = v128;
                                v130 = CFStringGetCStringPtr(v128, 0x8000100u);
                                cf = v129;
                                if (v130)
                                {
                                  v131 = (char *)v130;
                                  v256 = 0;
                                }
                                else
                                {
                                  v131 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x446032A7uLL);
                                  CFStringGetCString(v129, v131, 1024, 0x8000100u);
                                  v256 = v131;
                                }
                                if (qword_1000EBD40)
                                  v156 = (FILE *)qword_1000EBD40;
                                else
                                  v156 = __stderrp;
                                fprintf(v156, "%s\n", v131);
                                v157 = v256;
                                v60 = v257;
                                if (v256)
                                  goto LABEL_295;
                                goto LABEL_296;
                              }
                              v153 = sub_100030318();
                              if (os_log_type_enabled(v153, OS_LOG_TYPE_FAULT))
                              {
                                v154 = sub_1000302B4(v53);
                                *(_DWORD *)buf = 136315394;
                                *(_QWORD *)&buf[4] = v154;
                                v297 = 1024;
                                LODWORD(v298) = v53;
                                _os_log_fault_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: deferred disk writes resource: generating deferred report", buf, 0x12u);
                              }
LABEL_299:
                              if (qword_1000EBD40)
                                v159 = (FILE *)qword_1000EBD40;
                              else
                                v159 = __stderrp;
                              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v159);
                              goto LABEL_303;
                            }
                          }
                          sub_100042DC0(v53, v265, (uint64_t)v54, v267, (uint64_t)v55, v60, v57, v59, v62);
                          goto LABEL_279;
                        }
                        if (byte_1000EBD38)
                        {
                          v63 = *__error();
                          v64 = sub_100030318();
                          if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&buf[4] = v62;
                            _os_log_error_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "deferred disk writes resource: bad duration_limit (%f)", buf, 0xCu);
                          }
                          *__error() = v63;
                        }
                        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                          goto LABEL_279;
                        v41 = *__error();
                        v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred disk writes resource: bad duration_limit (%f)"), *(_QWORD *)&v62);
                        if (!v65)
                        {
                          v150 = sub_100030318();
                          if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&buf[4] = v62;
                            v106 = v150;
                            v107 = "Unable to format: deferred disk writes resource: bad duration_limit (%f)";
                            goto LABEL_220;
                          }
LABEL_274:
                          if (qword_1000EBD40)
                            v152 = (FILE *)qword_1000EBD40;
                          else
                            v152 = __stderrp;
                          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v152);
                          goto LABEL_278;
                        }
                        v43 = v65;
                        v44 = CFStringGetCStringPtr(v65, 0x8000100u);
                        if (v44)
                          goto LABEL_67;
                        v45 = 984245784;
                      }
                    }
                  }
                }
              }
              else
              {
                if (byte_1000EBD38)
                {
                  v77 = *__error();
                  v78 = sub_100030318();
                  if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
                    sub_10008E0FC(&v293, v294);
                  *__error() = v77;
                }
                if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                  goto LABEL_279;
                v41 = *__error();
                v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred disk writes resource: no pid provided"));
                if (!v79)
                {
                  v104 = sub_100030318();
                  if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT))
                    sub_10008E0D0(&v291, v292);
                  goto LABEL_274;
                }
                v43 = v79;
                v44 = CFStringGetCStringPtr(v79, 0x8000100u);
                if (v44)
                  goto LABEL_67;
                v45 = 395052147;
              }
              goto LABEL_134;
            }
            if (v26 == (id)3)
            {
              v27 = objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("pid")), "intValue");
              if ((_DWORD)v27)
              {
                v28 = (uint64_t)v27;
                v29 = objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("tid")), "unsignedLongLongValue");
                v30 = objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("flags")), "unsignedLongLongValue");
                objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("cpu")), "doubleValue");
                v32 = v31;
                if (v31 <= 0.0)
                {
                  if (byte_1000EBD38)
                  {
                    v81 = *__error();
                    v82 = sub_100030318();
                    if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(double *)&buf[4] = v32;
                      _os_log_error_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad cpu_used (%f)", buf, 0xCu);
                    }
                    *__error() = v81;
                  }
                  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                    goto LABEL_279;
                  v41 = *__error();
                  v83 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred cpu resource: bad cpu_used (%f)"), *(_QWORD *)&v32);
                  if (!v83)
                  {
                    v105 = sub_100030318();
                    if (os_log_type_enabled(v105, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)buf = 134217984;
                      *(double *)&buf[4] = v32;
                      v106 = v105;
                      v107 = "Unable to format: deferred cpu resource: bad cpu_used (%f)";
                      goto LABEL_220;
                    }
                    goto LABEL_274;
                  }
                  v43 = v83;
                  v44 = CFStringGetCStringPtr(v83, 0x8000100u);
                  if (v44)
                    goto LABEL_67;
                  v45 = 4027693846;
                }
                else
                {
                  objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("duration")), "doubleValue");
                  v34 = v33;
                  if (v33 <= 0.0)
                  {
                    if (byte_1000EBD38)
                    {
                      v93 = *__error();
                      v94 = sub_100030318();
                      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&buf[4] = v34;
                        _os_log_error_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad duration (%f)", buf, 0xCu);
                      }
                      *__error() = v93;
                    }
                    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                      goto LABEL_279;
                    v41 = *__error();
                    v95 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred cpu resource: bad duration (%f)"), *(_QWORD *)&v34);
                    if (!v95)
                    {
                      v120 = sub_100030318();
                      if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)buf = 134217984;
                        *(double *)&buf[4] = v34;
                        v106 = v120;
                        v107 = "Unable to format: deferred cpu resource: bad duration (%f)";
                        goto LABEL_220;
                      }
                      goto LABEL_274;
                    }
                    v43 = v95;
                    v44 = CFStringGetCStringPtr(v95, 0x8000100u);
                    if (v44)
                      goto LABEL_67;
                    v45 = 2044966629;
                  }
                  else
                  {
                    objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("endtime")), "doubleValue");
                    if (v35 <= 0.0)
                    {
                      if (byte_1000EBD38)
                      {
                        v100 = *__error();
                        v101 = sub_100030318();
                        if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
                          sub_10008E0A8(&v279, v280);
                        *__error() = v100;
                      }
                      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                        goto LABEL_279;
                      v41 = *__error();
                      v102 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred cpu resource: no endtime provided"));
                      if (!v102)
                      {
                        v124 = sub_100030318();
                        if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT))
                          sub_10008E07C(&v277, v278);
                        goto LABEL_274;
                      }
                      v43 = v102;
                      v44 = CFStringGetCStringPtr(v102, 0x8000100u);
                      if (v44)
                        goto LABEL_67;
                      v45 = 1943661059;
                    }
                    else
                    {
                      v36 = v35;
                      objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("cpu_limit")), "doubleValue");
                      v38 = v37;
                      if (v37 < 0.0)
                      {
                        if (byte_1000EBD38)
                        {
                          v39 = *__error();
                          v40 = sub_100030318();
                          if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&buf[4] = v38;
                            _os_log_error_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad cpu_used_limit (%f)", buf, 0xCu);
                          }
                          *__error() = v39;
                        }
                        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                          goto LABEL_279;
                        v41 = *__error();
                        v42 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred cpu resource: bad cpu_used_limit (%f)"), *(_QWORD *)&v38);
                        if (!v42)
                        {
                          v136 = sub_100030318();
                          if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)buf = 134217984;
                            *(double *)&buf[4] = v38;
                            v106 = v136;
                            v107 = "Unable to format: deferred cpu resource: bad cpu_used_limit (%f)";
                            goto LABEL_220;
                          }
                          goto LABEL_274;
                        }
                        v43 = v42;
                        v44 = CFStringGetCStringPtr(v42, 0x8000100u);
                        if (!v44)
                        {
                          v45 = 2429807285;
                          goto LABEL_134;
                        }
LABEL_67:
                        v50 = (char *)v44;
                        v51 = 0;
LABEL_135:
                        if (qword_1000EBD40)
                          v87 = (FILE *)qword_1000EBD40;
                        else
                          v87 = __stderrp;
                        fprintf(v87, "%s\n", v50);
                        if (v51)
                          free(v51);
                        v88 = v43;
                        goto LABEL_168;
                      }
                      objc_msgSend(sub_100053740(v23, (uint64_t)CFSTR("duration_limit")), "doubleValue");
                      v110 = v109;
                      if (v109 >= 0.0)
                      {
                        v268 = sub_1000537A0(v23, (uint64_t)CFSTR("pname"));
                        v121 = sub_1000537A0(v23, (uint64_t)CFSTR("action"));
                        if (v121)
                        {
                          v122 = sub_100058234((const char *)objc_msgSend(v121, "UTF8String"));
                          v266 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", v122);
                          free(v122);
                        }
                        else
                        {
                          v266 = 0;
                        }
                        if ((v28 & 0x80000000) != 0)
                        {
                          if (byte_1000EBD38)
                          {
                            v144 = *__error();
                            v145 = sub_100030318();
                            if (os_log_type_enabled(v145, OS_LOG_TYPE_INFO))
                            {
                              *(_WORD *)buf = 0;
                              _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_INFO, "deferred cpu resource: generating deferred report", buf, 2u);
                            }
                            *__error() = v144;
                          }
                          if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
                          {
                            v264 = *__error();
                            v141 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred cpu resource: generating deferred report"));
                            if (v141)
                              goto LABEL_267;
                            v160 = sub_100030318();
                            if (os_log_type_enabled(v160, OS_LOG_TYPE_FAULT))
                              sub_10008E050(&v275, v276);
LABEL_307:
                            if (qword_1000EBD40)
                              v161 = (FILE *)qword_1000EBD40;
                            else
                              v161 = __stderrp;
                            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v161);
LABEL_311:
                            *__error() = v264;
                          }
                        }
                        else
                        {
                          if (byte_1000EBD38)
                          {
                            v137 = *__error();
                            v138 = sub_100030318();
                            if (os_log_type_enabled(v138, OS_LOG_TYPE_INFO))
                            {
                              v139 = sub_1000302B4(v28);
                              *(_DWORD *)buf = 136446466;
                              *(_QWORD *)&buf[4] = v139;
                              v297 = 1024;
                              LODWORD(v298) = v28;
                              _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_INFO, "%{public}s [%d]: deferred cpu resource: generating deferred report", buf, 0x12u);
                            }
                            *__error() = v137;
                          }
                          if (byte_1000EBD39 && dword_1000EB4E8 <= 1)
                          {
                            v264 = *__error();
                            v140 = sub_1000302B4(v28);
                            v141 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: deferred cpu resource: generating deferred report"), v140, v28);
                            if (!v141)
                            {
                              v142 = sub_100030318();
                              if (os_log_type_enabled(v142, OS_LOG_TYPE_FAULT))
                              {
                                v143 = sub_1000302B4(v28);
                                *(_DWORD *)buf = 136315394;
                                *(_QWORD *)&buf[4] = v143;
                                v297 = 1024;
                                LODWORD(v298) = v28;
                                _os_log_fault_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: deferred cpu resource: generating deferred report", buf, 0x12u);
                              }
                              goto LABEL_307;
                            }
LABEL_267:
                            v146 = v141;
                            v147 = CFStringGetCStringPtr(v141, 0x8000100u);
                            if (v147)
                            {
                              v148 = (char *)v147;
                              cfa = 0;
                            }
                            else
                            {
                              v148 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50C48E61uLL);
                              CFStringGetCString(v146, v148, 1024, 0x8000100u);
                              cfa = v148;
                            }
                            if (qword_1000EBD40)
                              v155 = (FILE *)qword_1000EBD40;
                            else
                              v155 = __stderrp;
                            fprintf(v155, "%s\n", v148);
                            if (cfa)
                              free(cfa);
                            CFRelease(v146);
                            goto LABEL_311;
                          }
                        }
                        sub_10004142C(v28, v268, (uint64_t)v29, (uint64_t)v30, v266, v32, v34, v36, v38, v110);
                        goto LABEL_279;
                      }
                      if (byte_1000EBD38)
                      {
                        v111 = *__error();
                        v112 = sub_100030318();
                        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)buf = 134217984;
                          *(double *)&buf[4] = v110;
                          _os_log_error_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_ERROR, "deferred cpu resource: bad duration_limit (%f)", buf, 0xCu);
                        }
                        *__error() = v111;
                      }
                      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                        goto LABEL_279;
                      v41 = *__error();
                      v113 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred cpu resource: bad duration_limit (%f)"), *(_QWORD *)&v110);
                      if (!v113)
                      {
                        v151 = sub_100030318();
                        if (os_log_type_enabled(v151, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)buf = 134217984;
                          *(double *)&buf[4] = v110;
                          v106 = v151;
                          v107 = "Unable to format: deferred cpu resource: bad duration_limit (%f)";
LABEL_220:
                          _os_log_fault_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_FAULT, v107, buf, 0xCu);
                        }
                        goto LABEL_274;
                      }
                      v43 = v113;
                      v44 = CFStringGetCStringPtr(v113, 0x8000100u);
                      if (v44)
                        goto LABEL_67;
                      v45 = 2641072546;
                    }
                  }
                }
              }
              else
              {
                if (byte_1000EBD38)
                {
                  v74 = *__error();
                  v75 = sub_100030318();
                  if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                    sub_10008E028(&v283, v284);
                  *__error() = v74;
                }
                if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
                  goto LABEL_279;
                v41 = *__error();
                v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("deferred cpu resource: no pid provided"));
                if (!v76)
                {
                  v103 = sub_100030318();
                  if (os_log_type_enabled(v103, OS_LOG_TYPE_FAULT))
                    sub_10008DFFC(&v281, v282);
                  goto LABEL_274;
                }
                v43 = v76;
                v44 = CFStringGetCStringPtr(v76, 0x8000100u);
                if (v44)
                  goto LABEL_67;
                v45 = 1292592631;
              }
LABEL_134:
              v50 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v45);
              CFStringGetCString(v43, v50, 1024, 0x8000100u);
              v51 = v50;
              goto LABEL_135;
            }
            if (byte_1000EBD38)
            {
              v66 = *__error();
              v67 = sub_100030318();
              if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                sub_10008DFAC((uint64_t)&v299, v25);
              *__error() = v66;
            }
            if (byte_1000EBD39)
              v68 = dword_1000EB4E8 <= 3;
            else
              v68 = 0;
            if (!v68)
              goto LABEL_279;
            v41 = *__error();
            v69 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unhandled deferred report type %llu"), objc_msgSend(v25, "longLongValue"));
            if (!v69)
            {
              v92 = sub_100030318();
              if (os_log_type_enabled(v92, OS_LOG_TYPE_FAULT))
                sub_10008DF5C((uint64_t)v295, v25);
              goto LABEL_274;
            }
            v70 = v69;
            v71 = CFStringGetCStringPtr(v69, 0x8000100u);
            if (v71)
            {
              v72 = (char *)v71;
              v73 = 0;
            }
            else
            {
              v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x713FB94BuLL);
              CFStringGetCString(v70, v72, 1024, 0x8000100u);
              v73 = v72;
            }
            if (qword_1000EBD40)
              v96 = (FILE *)qword_1000EBD40;
            else
              v96 = __stderrp;
            fprintf(v96, "%s\n", v72);
            if (v73)
              free(v73);
            v88 = v70;
LABEL_168:
            CFRelease(v88);
LABEL_278:
            *__error() = v41;
LABEL_279:
            if (++v22 >= -[NSArray count](v16, "count"))
              goto LABEL_371;
          }
          if (byte_1000EBD38)
          {
            v46 = *__error();
            v47 = sub_100030318();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
              sub_10008DF34(&v272, v273);
            *__error() = v46;
          }
          if (byte_1000EBD39)
            v48 = dword_1000EB4E8 <= 3;
          else
            v48 = 0;
          if (!v48)
            goto LABEL_279;
          v41 = *__error();
          v49 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Bad deferred report type value type"));
          if (!v49)
          {
            v80 = sub_100030318();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
              sub_10008DF08(&v270, v271);
            goto LABEL_274;
          }
          v43 = v49;
          v44 = CFStringGetCStringPtr(v49, 0x8000100u);
          if (v44)
            goto LABEL_67;
          v45 = 3044858836;
          goto LABEL_134;
        }
LABEL_371:
        if (v22 < -[NSArray count](v16, "count"))
        {
          if (byte_1000EBD38)
          {
            v194 = *__error();
            v195 = sub_100030318();
            if (os_log_type_enabled(v195, OS_LOG_TYPE_DEFAULT))
            {
              v196 = -[NSArray count](v16, "count");
              *(_DWORD *)buf = 134218240;
              *(_QWORD *)&buf[4] = &v196[-v22];
              v297 = 2048;
              v298 = v22;
              _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, "Task expired with %lu remaining deferred reports (generated %lu)", buf, 0x16u);
            }
            *__error() = v194;
          }
          if (byte_1000EBD39)
            v197 = dword_1000EB4E8 <= 2;
          else
            v197 = 0;
          if (v197)
          {
            v198 = *__error();
            v199 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Task expired with %lu remaining deferred reports (generated %lu)"), (char *)-[NSArray count](v16, "count") - v22, v22);
            if (v199)
            {
              v200 = v199;
              v201 = CFStringGetCStringPtr(v199, 0x8000100u);
              if (v201)
              {
                v202 = (char *)v201;
                v203 = 0;
              }
              else
              {
                v202 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7474524CuLL);
                CFStringGetCString(v200, v202, 1024, 0x8000100u);
                v203 = v202;
              }
              if (qword_1000EBD40)
                v230 = (FILE *)qword_1000EBD40;
              else
                v230 = __stderrp;
              fprintf(v230, "%s\n", v202);
              if (v203)
                free(v203);
              CFRelease(v200);
            }
            else
            {
              v226 = sub_100030318();
              if (os_log_type_enabled(v226, OS_LOG_TYPE_FAULT))
                sub_10008DE1C();
              if (qword_1000EBD40)
                v227 = (FILE *)qword_1000EBD40;
              else
                v227 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v227);
            }
            *__error() = v198;
          }
          if (!v22)
            return 0;
          v231 = -[NSArray subarrayWithRange:](v16, "subarrayWithRange:", v22, (char *)-[NSArray count](v16, "count") - v22);
          *(_QWORD *)buf = 0;
          if (-[NSArray writeToURL:error:](v231, "writeToURL:error:", v14, buf))
            return 0;
          v233 = *__error();
          v234 = sub_100030318();
          if (os_log_type_enabled(v234, OS_LOG_TYPE_FAULT))
            sub_10008DDB0();
          *__error() = v233;
          if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
          {
            v235 = *__error();
            v236 = -[NSArray count](v231, "count");
            v237 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write %lu remaining deferred reports to plist: %@"), v236, *(_QWORD *)buf);
            if (v237)
            {
              v238 = v237;
              v239 = CFStringGetCStringPtr(v237, 0x8000100u);
              if (v239)
              {
                v240 = (char *)v239;
                v241 = 0;
              }
              else
              {
                v240 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3B6DB5E1uLL);
                CFStringGetCString(v238, v240, 1024, 0x8000100u);
                v241 = v240;
              }
              if (qword_1000EBD40)
                v248 = (FILE *)qword_1000EBD40;
              else
                v248 = __stderrp;
              fprintf(v248, "%s\n", v240);
              if (v241)
                free(v241);
              CFRelease(v238);
            }
            else
            {
              v246 = sub_100030318();
              if (os_log_type_enabled(v246, OS_LOG_TYPE_FAULT))
                sub_10008DD44();
              if (qword_1000EBD40)
                v247 = (FILE *)qword_1000EBD40;
              else
                v247 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v247);
            }
            *__error() = v235;
          }
          v269 = 0;
          if (-[NSFileManager removeItemAtURL:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtURL:error:", v14, &v269))
          {
            return 1;
          }
          v251 = *__error();
          v252 = sub_100030318();
          if (os_log_type_enabled(v252, OS_LOG_TYPE_FAULT))
            sub_10008D9C8();
          *__error() = v251;
          if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
            return 1;
          v166 = *__error();
          v253 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to remove deferred reports plist: %@"), v269);
          if (v253)
          {
            v168 = v253;
            v169 = CFStringGetCStringPtr(v253, 0x8000100u);
            if (v169)
              goto LABEL_331;
            v192 = 2875848191;
            goto LABEL_363;
          }
          v255 = sub_100030318();
          if (os_log_type_enabled(v255, OS_LOG_TYPE_FAULT))
            sub_10008D968();
LABEL_358:
          if (qword_1000EBD40)
            v191 = (FILE *)qword_1000EBD40;
          else
            v191 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v191);
          goto LABEL_370;
        }
        if (byte_1000EBD38)
        {
          v204 = *__error();
          v205 = sub_100030318();
          if (os_log_type_enabled(v205, OS_LOG_TYPE_DEFAULT))
          {
            v206 = -[NSArray count](v16, "count");
            *(_DWORD *)buf = 134217984;
            *(_QWORD *)&buf[4] = v206;
            _os_log_impl((void *)&_mh_execute_header, v205, OS_LOG_TYPE_DEFAULT, "Generated %lu deferred reports", buf, 0xCu);
          }
          *__error() = v204;
        }
        if (byte_1000EBD39)
          v207 = dword_1000EB4E8 <= 2;
        else
          v207 = 0;
        if (v207)
        {
          v208 = *__error();
          v209 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Generated %lu deferred reports"), -[NSArray count](v16, "count"));
          if (v209)
          {
            v210 = v209;
            v211 = CFStringGetCStringPtr(v209, 0x8000100u);
            if (v211)
            {
              v212 = (char *)v211;
              v213 = 0;
            }
            else
            {
              v212 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x77E7693FuLL);
              CFStringGetCString(v210, v212, 1024, 0x8000100u);
              v213 = v212;
            }
            if (qword_1000EBD40)
              v242 = (FILE *)qword_1000EBD40;
            else
              v242 = __stderrp;
            fprintf(v242, "%s\n", v212);
            if (v213)
              free(v213);
            CFRelease(v210);
          }
          else
          {
            v228 = (char *)sub_100030318();
            if (os_log_type_enabled((os_log_t)v228, OS_LOG_TYPE_FAULT))
              sub_10008DE94(v16, v228);
            if (qword_1000EBD40)
              v229 = (FILE *)qword_1000EBD40;
            else
              v229 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v229);
          }
          *__error() = v208;
        }
        *(_QWORD *)buf = 0;
        if (-[NSFileManager removeItemAtURL:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtURL:error:", v14, buf))
        {
          return 1;
        }
        v243 = *__error();
        v244 = sub_100030318();
        if (os_log_type_enabled(v244, OS_LOG_TYPE_FAULT))
          sub_10008D9C8();
        *__error() = v243;
        if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
          return 1;
        v166 = *__error();
        v245 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to remove deferred reports plist: %@"), *(_QWORD *)buf);
        if (!v245)
        {
          v254 = sub_100030318();
          if (os_log_type_enabled(v254, OS_LOG_TYPE_FAULT))
            sub_10008D968();
          goto LABEL_358;
        }
        v168 = v245;
        v169 = CFStringGetCStringPtr(v245, 0x8000100u);
        if (v169)
          goto LABEL_331;
        v192 = 1690975433;
LABEL_363:
        v170 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v192);
        CFStringGetCString(v168, v170, 1024, 0x8000100u);
        v171 = v170;
        goto LABEL_364;
      }
      goto LABEL_31;
    }
  }
  if (byte_1000EBD38)
  {
    v172 = *__error();
    v173 = sub_100030318();
    if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
      sub_10008E1D4();
    *__error() = v172;
  }
  if (byte_1000EBD39)
    v174 = dword_1000EB4E8 <= 3;
  else
    v174 = 0;
  if (v174)
  {
    v175 = *__error();
    v176 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Invalid deferred reports plist"));
    if (v176)
    {
      v177 = v176;
      v178 = CFStringGetCStringPtr(v176, 0x8000100u);
      if (v178)
      {
        v179 = (char *)v178;
        v180 = 0;
      }
      else
      {
        v179 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6638AFB2uLL);
        CFStringGetCString(v177, v179, 1024, 0x8000100u);
        v180 = v179;
      }
      if (qword_1000EBD40)
        v218 = (FILE *)qword_1000EBD40;
      else
        v218 = __stderrp;
      fprintf(v218, "%s\n", v179);
      if (v180)
        free(v180);
      CFRelease(v177);
    }
    else
    {
      v214 = sub_100030318();
      if (os_log_type_enabled(v214, OS_LOG_TYPE_FAULT))
        sub_10008E1A4();
      if (qword_1000EBD40)
        v215 = (FILE *)qword_1000EBD40;
      else
        v215 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v215);
    }
    *__error() = v175;
  }
  *(_QWORD *)buf = 0;
  if (-[NSFileManager removeItemAtURL:error:](+[NSFileManager defaultManager](NSFileManager, "defaultManager"), "removeItemAtURL:error:", v14, buf))
  {
    return 1;
  }
  v219 = *__error();
  v220 = sub_100030318();
  if (os_log_type_enabled(v220, OS_LOG_TYPE_FAULT))
    sub_10008D9C8();
  *__error() = v219;
  if (!byte_1000EBD39 || dword_1000EB4E8 > 4)
    return 1;
  v166 = *__error();
  v221 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to remove deferred reports plist: %@"), *(_QWORD *)buf);
  if (!v221)
  {
    v249 = sub_100030318();
    if (!os_log_type_enabled(v249, OS_LOG_TYPE_FAULT))
      goto LABEL_358;
    goto LABEL_503;
  }
  v168 = v221;
  v169 = CFStringGetCStringPtr(v221, 0x8000100u);
  if (!v169)
  {
    v192 = 1724433624;
    goto LABEL_363;
  }
LABEL_331:
  v170 = (char *)v169;
  v171 = 0;
LABEL_364:
  if (qword_1000EBD40)
    v193 = (FILE *)qword_1000EBD40;
  else
    v193 = __stderrp;
  fprintf(v193, "%s\n", v170);
  if (v171)
    free(v171);
  CFRelease(v168);
LABEL_370:
  *__error() = v166;
  return 1;
}

id sub_100053740(void *a1, uint64_t a2)
{
  uint64_t v4;
  id v5;
  id v6;

  v4 = objc_opt_class(NSNumber);
  v5 = objc_msgSend(a1, "objectForKeyedSubscript:", a2);
  if (!v5)
    return 0;
  v6 = v5;
  if ((objc_opt_isKindOfClass(v5, v4) & 1) == 0)
    return 0;
  return v6;
}

id sub_1000537A0(void *a1, uint64_t a2)
{
  uint64_t v4;
  id v5;
  id v6;

  v4 = objc_opt_class(NSString);
  v5 = objc_msgSend(a1, "objectForKeyedSubscript:", a2);
  if (!v5)
    return 0;
  v6 = v5;
  if ((objc_opt_isKindOfClass(v5, v4) & 1) == 0)
    return 0;
  return v6;
}

void sub_100053800(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 2u);
}

_BYTE *sub_10005380C(_BYTE *result, _BYTE *a2)
{
  *result = 0;
  *a2 = 0;
  return result;
}

void sub_10005381C(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

id sub_100053844(void *a1, const char *a2)
{
  return objc_msgSend(a1, "count");
}

id sub_10005384C(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "longLongValue");
}

void sub_100053878(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9)
{
  uint64_t v17;
  NSObject *global_queue;
  _QWORD block[12];
  int v20;
  int v21;

  v17 = sub_100030160("Resource exhaustion for [%d]", a2);
  global_queue = dispatch_get_global_queue(25, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100053944;
  block[3] = &unk_1000DD540;
  v20 = a2;
  v21 = a8;
  block[8] = a1;
  block[9] = a4;
  block[4] = v17;
  block[5] = a3;
  block[6] = a5;
  block[7] = a9;
  block[10] = a6;
  block[11] = a7;
  dispatch_async(global_queue, block);
}

void sub_100053944(uint64_t a1)
{
  time_t v2;
  id v3;
  unsigned int *v4;
  uint64_t v5;
  pid_t v6;
  pid_t v7;
  void *v8;
  ssize_t v9;
  ssize_t v10;
  char v11;
  id v12;
  void *v13;
  int v14;
  NSObject *v15;
  BOOL v16;
  int v17;
  _DWORD *v18;
  const __CFString *v19;
  const __CFString *v20;
  id v21;
  const char *v22;
  char *v23;
  char *v24;
  int v25;
  NSObject *v26;
  BOOL v27;
  int v28;
  const __CFString *v29;
  const __CFString *v30;
  id v31;
  const char *CStringPtr;
  char *v33;
  char *v34;
  NSObject *v35;
  FILE *v36;
  FILE *v37;
  NSObject *v38;
  FILE *v39;
  FILE *v40;
  _DWORD *v41;
  int v42;
  _DWORD *v43;
  int v44;
  id v45;
  uint64_t v46;
  pid_t v47;
  pid_t v48;
  void *v49;
  ssize_t v50;
  ssize_t v51;
  char v52;
  id v53;
  void *v54;
  int v55;
  NSObject *v56;
  BOOL v57;
  id v58;
  int v59;
  _DWORD *v60;
  const __CFString *v61;
  const __CFString *v62;
  const char *v63;
  char *v64;
  char *v65;
  int v66;
  NSObject *v67;
  BOOL v68;
  int v69;
  const __CFString *v70;
  const __CFString *v71;
  const char *v72;
  char *v73;
  char *v74;
  NSObject *v75;
  FILE *v76;
  FILE *v77;
  NSObject *v78;
  FILE *v79;
  FILE *v80;
  _DWORD *v81;
  int v82;
  _DWORD *v83;
  int v84;
  int v85;
  NSObject *v86;
  int v87;
  _DWORD *v88;
  uint64_t v89;
  uint64_t v90;
  int *v91;
  char *v92;
  const __CFString *v93;
  NSObject *v94;
  const __CFString *v95;
  mach_port_name_t v96;
  NSObject *global_queue;
  __int128 v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  NSObject *v102;
  int v103;
  _DWORD *v104;
  uint64_t v105;
  uint64_t v106;
  int *v107;
  char *v108;
  const __CFString *v109;
  NSObject *v110;
  int v111;
  NSObject *v112;
  uint64_t v113;
  int *v114;
  char *v115;
  const __CFString *v116;
  const char *v117;
  char *v118;
  char *v119;
  int v120;
  NSObject *v121;
  uint64_t v122;
  int *v123;
  char *v124;
  const __CFString *v125;
  const char *v126;
  char *v127;
  char *v128;
  FILE *v129;
  NSObject *v130;
  FILE *v131;
  uint64_t v132;
  int *v133;
  _BOOL4 v134;
  int v135;
  int v136;
  NSObject *v137;
  int v138;
  _DWORD *v139;
  const __CFString *v140;
  const __CFString *v141;
  const char *v142;
  malloc_type_id_t v143;
  int v144;
  NSObject *v145;
  _DWORD *v146;
  const __CFString *v147;
  int v148;
  NSObject *v149;
  const __CFString *v150;
  const __CFString *v151;
  const char *v152;
  malloc_type_id_t v153;
  int v154;
  NSObject *v155;
  const __CFString *v156;
  NSObject *v157;
  NSObject *v158;
  NSObject *v159;
  NSObject *v160;
  FILE *v161;
  NSObject *v162;
  FILE *v163;
  uint64_t v164;
  int *v165;
  int v166;
  int v167;
  NSObject *v168;
  _DWORD *v169;
  const __CFString *v170;
  int v171;
  NSObject *v172;
  _DWORD *v173;
  const __CFString *v174;
  char *v175;
  char *v176;
  int v177;
  NSObject *v178;
  const __CFString *v179;
  int v180;
  NSObject *v181;
  const __CFString *v182;
  char *v183;
  char *v184;
  NSObject *v185;
  NSObject *v186;
  FILE *v187;
  const __CFString *v188;
  NSObject *v189;
  NSObject *v190;
  FILE *v191;
  FILE *v192;
  mach_port_name_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  char *v197;
  id v198;
  pid_t v199;
  pid_t v200;
  time_t v201;
  time_t v202;
  uint64_t v203;
  uint64_t v204;
  _QWORD block[4];
  int8x16_t v206;
  id v207;
  uint64_t v208;
  id v209;
  uint64_t v210;
  __int128 v211;
  time_t v212;
  __int128 v213;
  int v214;
  int v215;
  _BYTE v216[28];
  _BYTE buf[32];
  const char *v218;
  const char *v219;
  const char *v220;
  const char *v221;
  const char *v222;
  const char *v223;
  const char *v224;
  const char *v225;
  char *v226;
  uint64_t v227;
  char __str[8];

  sub_10005F498();
  v2 = time(0);
  v3 = +[NSMutableString string](NSMutableString, "string");
  v4 = (unsigned int *)(a1 + 96);
  v5 = snprintf(__str, 8uLL, "%d", *(_DWORD *)(a1 + 96));
  if ((unint64_t)(*(_QWORD *)(a1 + 64) - 1) <= 1)
  {
    objc_msgSend(v3, "appendFormat:", CFSTR("ddt %d\n"), *v4);
    *(_QWORD *)v216 = "/usr/local/bin/ddt";
    *(_QWORD *)&v216[8] = __str;
    *(_QWORD *)&v216[16] = 0;
    v215 = -1;
    v6 = SASpawnPlatformBinaryWithSigningIdentifier("/usr/local/bin/ddt", "com.apple.ddt", v216, 0, 0, 0, &v215, 0, 0, 0, 0);
    if ((v6 & 0x80000000) == 0)
    {
      v7 = v6;
      v8 = malloc_type_calloc(0x20uLL, 0x400uLL, 0x34CD9B87uLL);
      v9 = read(v215, v8, vm_page_size - 1);
      if (v9 >= 1)
      {
        v10 = v9;
        v199 = v7;
        v201 = v2;
        v203 = a1;
        v11 = 0;
        do
        {
          *((_BYTE *)v8 + v10) = 0;
          v12 = objc_msgSend(objc_alloc((Class)NSString), "initWithBytesNoCopy:length:encoding:freeWhenDone:", v8, v10, 4, 0);
          if (v12)
          {
            v13 = v12;
            objc_msgSend(v3, "appendString:", v12);

            v11 = 1;
          }
          else if ((*v4 & 0x80000000) != 0)
          {
            if (byte_1000EBD38)
            {
              v25 = *__error();
              v26 = sub_100030318();
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136315138;
                *(_QWORD *)&buf[4] = v8;
                _os_log_error_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "Unable to convert ddt output to NSString: %s", buf, 0xCu);
              }
              *__error() = v25;
            }
            if (byte_1000EBD39)
              v27 = dword_1000EB4E8 <= 3;
            else
              v27 = 0;
            if (v27)
            {
              v28 = *__error();
              v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to convert ddt output to NSString: %s"), v8);
              if (v29)
              {
                v30 = v29;
                v31 = v3;
                CStringPtr = CFStringGetCStringPtr(v29, 0x8000100u);
                if (CStringPtr)
                {
                  v33 = (char *)CStringPtr;
                  v34 = 0;
                }
                else
                {
                  v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x38C52AAuLL);
                  CFStringGetCString(v30, v33, 1024, 0x8000100u);
                  v34 = v33;
                }
                if (qword_1000EBD40)
                  v40 = (FILE *)qword_1000EBD40;
                else
                  v40 = __stderrp;
                fprintf(v40, "%s\n", v33);
                if (v34)
                  free(v34);
                CFRelease(v30);
                v3 = v31;
              }
              else
              {
                v38 = sub_100030318();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)buf = 136315138;
                  *(_QWORD *)&buf[4] = v8;
                  _os_log_fault_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, "Unable to format: Unable to convert ddt output to NSString: %s", buf, 0xCu);
                }
                if (qword_1000EBD40)
                  v39 = (FILE *)qword_1000EBD40;
                else
                  v39 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v39);
              }
              *__error() = v28;
            }
          }
          else
          {
            if (byte_1000EBD38)
            {
              v14 = *__error();
              v15 = sub_100030318();
              if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
              {
                v41 = sub_1000302B4(*v4);
                v42 = *v4;
                *(_DWORD *)buf = 136446722;
                *(_QWORD *)&buf[4] = v41;
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v42;
                *(_WORD *)&buf[18] = 2080;
                *(_QWORD *)&buf[20] = v8;
                _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to convert ddt output to NSString: %s", buf, 0x1Cu);
              }
              *__error() = v14;
            }
            if (byte_1000EBD39)
              v16 = dword_1000EB4E8 <= 3;
            else
              v16 = 0;
            if (v16)
            {
              v17 = *__error();
              v18 = sub_1000302B4(*v4);
              v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to convert ddt output to NSString: %s"), v18, *v4, v8);
              if (v19)
              {
                v20 = v19;
                v21 = v3;
                v22 = CFStringGetCStringPtr(v19, 0x8000100u);
                if (v22)
                {
                  v23 = (char *)v22;
                  v24 = 0;
                }
                else
                {
                  v23 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x38C52AAuLL);
                  CFStringGetCString(v20, v23, 1024, 0x8000100u);
                  v24 = v23;
                }
                if (qword_1000EBD40)
                  v37 = (FILE *)qword_1000EBD40;
                else
                  v37 = __stderrp;
                fprintf(v37, "%s\n", v23);
                if (v24)
                  free(v24);
                CFRelease(v20);
                v3 = v21;
              }
              else
              {
                v35 = sub_100030318();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
                {
                  v43 = sub_1000302B4(*v4);
                  v44 = *v4;
                  *(_DWORD *)buf = 136315650;
                  *(_QWORD *)&buf[4] = v43;
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v44;
                  *(_WORD *)&buf[18] = 2080;
                  *(_QWORD *)&buf[20] = v8;
                  _os_log_fault_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to convert ddt output to NSString: %s", buf, 0x1Cu);
                }
                if (qword_1000EBD40)
                  v36 = (FILE *)qword_1000EBD40;
                else
                  v36 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
              }
              *__error() = v17;
            }
          }
          v10 = read(v215, v8, vm_page_size - 1);
        }
        while (v10 > 0);
        waitpid(v199, 0, 0);
        free(v8);
        v5 = (uint64_t)objc_msgSend(v3, "appendFormat:", CFSTR("\n"));
        a1 = v203;
        if ((v11 & 1) != 0)
        {
          v2 = v201;
          goto LABEL_64;
        }
LABEL_190:
        v134 = sub_100025F88(*v4);
        v135 = *v4;
        if (v134)
        {
          if ((v135 & 0x80000000) == 0)
          {
            if (byte_1000EBD38)
            {
              v136 = *__error();
              v137 = sub_100030318();
              if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
                sub_10008E2DC();
              *__error() = v136;
            }
            if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
              goto LABEL_321;
            v138 = *__error();
            v139 = sub_1000302B4(*v4);
            v140 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to gather ddt for resource exhaustion report, though process is alive"), v139, *v4);
            if (!v140)
            {
              v157 = sub_100030318();
              if (os_log_type_enabled(v157, OS_LOG_TYPE_FAULT))
                sub_10008E26C();
              goto LABEL_307;
            }
            v141 = v140;
            v142 = CFStringGetCStringPtr(v140, 0x8000100u);
            if (v142)
              goto LABEL_272;
            v143 = 4172334830;
LABEL_296:
            v175 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v143);
            CFStringGetCString(v141, v175, 1024, 0x8000100u);
            v176 = v175;
            goto LABEL_297;
          }
          if (byte_1000EBD38)
          {
            v148 = *__error();
            v149 = sub_100030318();
            if (os_log_type_enabled(v149, OS_LOG_TYPE_ERROR))
              sub_10008E378();
            *__error() = v148;
          }
          if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
            goto LABEL_321;
          v138 = *__error();
          v150 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to gather ddt for resource exhaustion report, though process is alive"));
          if (!v150)
          {
            v159 = sub_100030318();
            if (os_log_type_enabled(v159, OS_LOG_TYPE_FAULT))
              sub_10008E34C();
            goto LABEL_307;
          }
          v151 = v150;
          v152 = CFStringGetCStringPtr(v150, 0x8000100u);
          if (v152)
            goto LABEL_290;
          v153 = 4172334830;
        }
        else
        {
          if ((v135 & 0x80000000) == 0)
          {
            if (byte_1000EBD38)
            {
              v144 = *__error();
              v145 = sub_100030318();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_ERROR))
                sub_10008E414();
              *__error() = v144;
            }
            if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
              goto LABEL_321;
            v138 = *__error();
            v146 = sub_1000302B4(*v4);
            v147 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to gather ddt for resource exhaustion report; process is no longer around"),
                     v146,
                     *v4);
            if (!v147)
            {
              v158 = sub_100030318();
              if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT))
                sub_10008E3A4();
              goto LABEL_307;
            }
            v141 = v147;
            v142 = CFStringGetCStringPtr(v147, 0x8000100u);
            if (v142)
              goto LABEL_272;
            v143 = 3600909264;
            goto LABEL_296;
          }
          if (byte_1000EBD38)
          {
            v154 = *__error();
            v155 = sub_100030318();
            if (os_log_type_enabled(v155, OS_LOG_TYPE_ERROR))
              sub_10008E4B0();
            *__error() = v154;
          }
          if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
            goto LABEL_321;
          v138 = *__error();
          v156 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to gather ddt for resource exhaustion report; process is no longer around"));
          if (!v156)
          {
            v160 = sub_100030318();
            if (os_log_type_enabled(v160, OS_LOG_TYPE_FAULT))
              sub_10008E484();
            goto LABEL_307;
          }
          v151 = v156;
          v152 = CFStringGetCStringPtr(v156, 0x8000100u);
          if (v152)
            goto LABEL_290;
          v153 = 3600909264;
        }
LABEL_312:
        v183 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v153);
        CFStringGetCString(v151, v183, 1024, 0x8000100u);
        v184 = v183;
        goto LABEL_313;
      }
      waitpid(v7, 0, 0);
      free(v8);
      v95 = CFSTR("\n");
LABEL_189:
      objc_msgSend(v3, "appendFormat:", v95, v196, v197);
      goto LABEL_190;
    }
    if ((*v4 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v111 = *__error();
        v112 = sub_100030318();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
          sub_10008E644();
        *__error() = v111;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_188;
      v87 = *__error();
      v113 = *__error();
      v114 = __error();
      v115 = strerror(*v114);
      v93 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to spawn ddt: %d (%s)"), v113, v115);
      if (!v93)
      {
        v130 = sub_100030318();
        if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT))
          sub_10008E5D4();
        goto LABEL_183;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v85 = *__error();
        v86 = sub_100030318();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
          sub_10008E558();
        *__error() = v85;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_188;
      v87 = *__error();
      v88 = sub_1000302B4(*v4);
      v89 = *v4;
      v90 = *__error();
      v91 = __error();
      v92 = strerror(*v91);
      v93 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to spawn ddt: %d (%s)"), v88, v89, v90, v92);
      if (!v93)
      {
        v94 = sub_100030318();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
          sub_10008E4DC();
LABEL_183:
        if (qword_1000EBD40)
          v131 = (FILE *)qword_1000EBD40;
        else
          v131 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v131);
LABEL_187:
        *__error() = v87;
LABEL_188:
        v132 = *__error();
        v133 = __error();
        v196 = v132;
        v197 = strerror(*v133);
        v95 = CFSTR("Unable to spawn ddt: %d (%s)\n\n");
        goto LABEL_189;
      }
    }
    v116 = v93;
    v117 = CFStringGetCStringPtr(v93, 0x8000100u);
    if (v117)
    {
      v118 = (char *)v117;
      v119 = 0;
    }
    else
    {
      v118 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD9FA48E4uLL);
      CFStringGetCString(v116, v118, 1024, 0x8000100u);
      v119 = v118;
    }
    if (qword_1000EBD40)
      v129 = (FILE *)qword_1000EBD40;
    else
      v129 = __stderrp;
    fprintf(v129, "%s\n", v118);
    if (v119)
      free(v119);
    CFRelease(v116);
    goto LABEL_187;
  }
LABEL_64:
  if ((byte_1000EBD4C & 2) != 0 && (v5 = sub_100025FB4(), (v5 & 1) != 0))
  {
    v45 = 0;
  }
  else
  {
    v46 = stackshot_config_create(v5);
    stackshot_config_set_flags(v46, 1302536203);
    v45 = sub_10006EB70(v46, +[NSMutableSet setWithObject:](NSMutableSet, "setWithObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *v4)));
    stackshot_config_dealloc(v46);
  }
  if ((unint64_t)(*(_QWORD *)(a1 + 64) - 3) > 0xFFFFFFFFFFFFFFFDLL)
    goto LABEL_142;
  objc_msgSend(v3, "appendFormat:", CFSTR("lsof -n -M -P -T -w +c 0 -s +fg +L -p %d\n"), *v4);
  *(_QWORD *)buf = "/usr/sbin/lsof";
  *(_QWORD *)&buf[8] = "-n";
  *(_QWORD *)&buf[16] = "-M";
  *(_QWORD *)&buf[24] = "-P";
  v218 = "-T";
  v219 = "-w";
  v220 = "+c";
  v221 = "0";
  v222 = "-s";
  v223 = "+fg";
  v224 = "+L";
  v225 = "-p";
  v226 = __str;
  v227 = 0;
  v215 = -1;
  LOBYTE(v197) = 0;
  v47 = SASpawnPlatformBinaryWithSigningIdentifier("/usr/sbin/lsof", "com.apple.lsof", buf, 0, 0, 0, &v215, 0, 0, (_DWORD)v197, 0);
  if (v47 < 0)
  {
    if ((*v4 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v120 = *__error();
        v121 = sub_100030318();
        if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
          sub_10008EA8C();
        *__error() = v120;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_251;
      v103 = *__error();
      v122 = *__error();
      v123 = __error();
      v124 = strerror(*v123);
      v109 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to spawn lsof: %d (%s)"), v122, v124);
      if (!v109)
      {
        v162 = sub_100030318();
        if (os_log_type_enabled(v162, OS_LOG_TYPE_FAULT))
          sub_10008EA1C();
        goto LABEL_246;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v101 = *__error();
        v102 = sub_100030318();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
          sub_10008E9A0();
        *__error() = v101;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_251;
      v103 = *__error();
      v104 = sub_1000302B4(*v4);
      v105 = *v4;
      v106 = *__error();
      v107 = __error();
      v108 = strerror(*v107);
      v109 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to spawn lsof: %d (%s)"), v104, v105, v106, v108);
      if (!v109)
      {
        v110 = sub_100030318();
        if (os_log_type_enabled(v110, OS_LOG_TYPE_FAULT))
          sub_10008E924();
LABEL_246:
        if (qword_1000EBD40)
          v163 = (FILE *)qword_1000EBD40;
        else
          v163 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v163);
LABEL_250:
        *__error() = v103;
LABEL_251:
        v164 = *__error();
        v165 = __error();
        objc_msgSend(v3, "appendFormat:", CFSTR("Unable to spawn lsof: %d (%s)\n\n"), v164, strerror(*v165));
        goto LABEL_252;
      }
    }
    v125 = v109;
    v126 = CFStringGetCStringPtr(v109, 0x8000100u);
    if (v126)
    {
      v127 = (char *)v126;
      v128 = 0;
    }
    else
    {
      v127 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBF99A0uLL);
      CFStringGetCString(v125, v127, 1024, 0x8000100u);
      v128 = v127;
    }
    if (qword_1000EBD40)
      v161 = (FILE *)qword_1000EBD40;
    else
      v161 = __stderrp;
    fprintf(v161, "%s\n", v127);
    if (v128)
      free(v128);
    CFRelease(v125);
    goto LABEL_250;
  }
  v48 = v47;
  v202 = v2;
  v204 = a1;
  v49 = malloc_type_calloc(0x20uLL, 0x400uLL, 0xFCAD8550uLL);
  v50 = read(v215, v49, vm_page_size - 1);
  if (v50 < 1)
  {
    waitpid(v48, 0, 0);
    free(v49);
    objc_msgSend(v3, "appendFormat:", CFSTR("\n"));
    a1 = v204;
  }
  else
  {
    v51 = v50;
    v200 = v48;
    v198 = v45;
    v52 = 0;
    do
    {
      *((_BYTE *)v49 + v51) = 0;
      v53 = objc_msgSend(objc_alloc((Class)NSString), "initWithBytesNoCopy:length:encoding:freeWhenDone:", v49, v51, 4, 0);
      if (v53)
      {
        v54 = v53;
        objc_msgSend(v3, "appendString:", v53);

        v52 = 1;
      }
      else if ((*v4 & 0x80000000) != 0)
      {
        if (byte_1000EBD38)
        {
          v66 = *__error();
          v67 = sub_100030318();
          if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)v216 = 136315138;
            *(_QWORD *)&v216[4] = v49;
            _os_log_error_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "Unable to convert lsof output to NSString: %s", v216, 0xCu);
          }
          *__error() = v66;
        }
        if (byte_1000EBD39)
          v68 = dword_1000EB4E8 <= 3;
        else
          v68 = 0;
        if (v68)
        {
          v69 = *__error();
          v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to convert lsof output to NSString: %s"), v49);
          if (v70)
          {
            v71 = v70;
            v72 = CFStringGetCStringPtr(v70, 0x8000100u);
            if (v72)
            {
              v73 = (char *)v72;
              v74 = 0;
            }
            else
            {
              v73 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50D1E49DuLL);
              CFStringGetCString(v71, v73, 1024, 0x8000100u);
              v74 = v73;
            }
            if (qword_1000EBD40)
              v80 = (FILE *)qword_1000EBD40;
            else
              v80 = __stderrp;
            fprintf(v80, "%s\n", v73);
            if (v74)
              free(v74);
            CFRelease(v71);
          }
          else
          {
            v78 = sub_100030318();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)v216 = 136315138;
              *(_QWORD *)&v216[4] = v49;
              _os_log_fault_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_FAULT, "Unable to format: Unable to convert lsof output to NSString: %s", v216, 0xCu);
            }
            if (qword_1000EBD40)
              v79 = (FILE *)qword_1000EBD40;
            else
              v79 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
          }
          *__error() = v69;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v55 = *__error();
          v56 = sub_100030318();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            v81 = sub_1000302B4(*v4);
            v82 = *v4;
            *(_DWORD *)v216 = 136446722;
            *(_QWORD *)&v216[4] = v81;
            *(_WORD *)&v216[12] = 1024;
            *(_DWORD *)&v216[14] = v82;
            *(_WORD *)&v216[18] = 2080;
            *(_QWORD *)&v216[20] = v49;
            _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to convert lsof output to NSString: %s", v216, 0x1Cu);
          }
          *__error() = v55;
        }
        if (byte_1000EBD39)
          v57 = dword_1000EB4E8 <= 3;
        else
          v57 = 0;
        if (v57)
        {
          v58 = v3;
          v59 = *__error();
          v60 = sub_1000302B4(*v4);
          v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to convert lsof output to NSString: %s"), v60, *v4, v49);
          if (v61)
          {
            v62 = v61;
            v63 = CFStringGetCStringPtr(v61, 0x8000100u);
            if (v63)
            {
              v64 = (char *)v63;
              v65 = 0;
            }
            else
            {
              v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x50D1E49DuLL);
              CFStringGetCString(v62, v64, 1024, 0x8000100u);
              v65 = v64;
            }
            if (qword_1000EBD40)
              v77 = (FILE *)qword_1000EBD40;
            else
              v77 = __stderrp;
            fprintf(v77, "%s\n", v64);
            if (v65)
              free(v65);
            CFRelease(v62);
          }
          else
          {
            v75 = sub_100030318();
            if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT))
            {
              v83 = sub_1000302B4(*v4);
              v84 = *v4;
              *(_DWORD *)v216 = 136315650;
              *(_QWORD *)&v216[4] = v83;
              *(_WORD *)&v216[12] = 1024;
              *(_DWORD *)&v216[14] = v84;
              *(_WORD *)&v216[18] = 2080;
              *(_QWORD *)&v216[20] = v49;
              _os_log_fault_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to convert lsof output to NSString: %s", v216, 0x1Cu);
            }
            if (qword_1000EBD40)
              v76 = (FILE *)qword_1000EBD40;
            else
              v76 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v76);
          }
          *__error() = v59;
          v3 = v58;
        }
      }
      v51 = read(v215, v49, vm_page_size - 1);
    }
    while (v51 > 0);
    waitpid(v200, 0, 0);
    free(v49);
    objc_msgSend(v3, "appendFormat:", CFSTR("\n"));
    a1 = v204;
    if ((v52 & 1) != 0)
    {
      v2 = v202;
      v45 = v198;
LABEL_142:
      v96 = *(_DWORD *)(a1 + 100);
      if (v96 + 1 >= 2)
        sub_1000554DC(*(_QWORD *)(a1 + 64), *(unsigned int *)(a1 + 96), v96);
      global_queue = dispatch_get_global_queue(9, 0);
      block[1] = 3221225472;
      v98 = *(_OWORD *)(a1 + 80);
      v211 = *(_OWORD *)(a1 + 64);
      v206 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
      block[0] = _NSConcreteStackBlock;
      block[2] = sub_100055CB4;
      block[3] = &unk_1000DD518;
      v212 = v2;
      v214 = *(_DWORD *)(a1 + 96);
      v100 = *(_QWORD *)(a1 + 48);
      v99 = *(_QWORD *)(a1 + 56);
      v207 = v45;
      v208 = v100;
      v213 = v98;
      v209 = v3;
      v210 = v99;
      dispatch_async(global_queue, block);
      return;
    }
  }
LABEL_252:
  v134 = sub_100025F88(*v4);
  v166 = *v4;
  if (!v134)
  {
    if ((v166 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v171 = *__error();
        v172 = sub_100030318();
        if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
          sub_10008E85C();
        *__error() = v171;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_321;
      v138 = *__error();
      v173 = sub_1000302B4(*v4);
      v174 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to gather lsof for resource exhaustion report; process is no longer around"),
               v173,
               *v4);
      if (v174)
      {
        v141 = v174;
        v142 = CFStringGetCStringPtr(v174, 0x8000100u);
        if (!v142)
        {
          v143 = 2726677414;
          goto LABEL_296;
        }
        goto LABEL_272;
      }
      v186 = sub_100030318();
      if (os_log_type_enabled(v186, OS_LOG_TYPE_FAULT))
        sub_10008E7EC();
LABEL_307:
      if (qword_1000EBD40)
        v191 = (FILE *)qword_1000EBD40;
      else
        v191 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v191);
      goto LABEL_320;
    }
    if (byte_1000EBD38)
    {
      v180 = *__error();
      v181 = sub_100030318();
      if (os_log_type_enabled(v181, OS_LOG_TYPE_ERROR))
        sub_10008E8F8();
      *__error() = v180;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_321;
    v138 = *__error();
    v182 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to gather lsof for resource exhaustion report; process is no longer around"));
    if (!v182)
    {
      v190 = sub_100030318();
      if (os_log_type_enabled(v190, OS_LOG_TYPE_FAULT))
        sub_10008E8CC();
      goto LABEL_307;
    }
    v151 = v182;
    v152 = CFStringGetCStringPtr(v182, 0x8000100u);
    if (!v152)
    {
      v153 = 2726677414;
      goto LABEL_312;
    }
    goto LABEL_290;
  }
  if (v166 < 0)
  {
    if (byte_1000EBD38)
    {
      v177 = *__error();
      v178 = sub_100030318();
      if (os_log_type_enabled(v178, OS_LOG_TYPE_ERROR))
        sub_10008E7C0();
      *__error() = v177;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_321;
    v138 = *__error();
    v179 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to gather lsof for resource exhaustion report, though process is alive"));
    if (!v179)
    {
      v189 = sub_100030318();
      if (os_log_type_enabled(v189, OS_LOG_TYPE_FAULT))
        sub_10008E794();
      goto LABEL_307;
    }
    v151 = v179;
    v152 = CFStringGetCStringPtr(v179, 0x8000100u);
    if (!v152)
    {
      v153 = 1843175792;
      goto LABEL_312;
    }
LABEL_290:
    v183 = (char *)v152;
    v184 = 0;
LABEL_313:
    if (qword_1000EBD40)
      v192 = (FILE *)qword_1000EBD40;
    else
      v192 = __stderrp;
    fprintf(v192, "%s\n", v183);
    if (v184)
      free(v184);
    v188 = v151;
    goto LABEL_319;
  }
  if (byte_1000EBD38)
  {
    v167 = *__error();
    v168 = sub_100030318();
    if (os_log_type_enabled(v168, OS_LOG_TYPE_ERROR))
      sub_10008E724();
    *__error() = v167;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
    goto LABEL_321;
  v138 = *__error();
  v169 = sub_1000302B4(*v4);
  v170 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to gather lsof for resource exhaustion report, though process is alive"), v169, *v4);
  if (!v170)
  {
    v185 = sub_100030318();
    if (os_log_type_enabled(v185, OS_LOG_TYPE_FAULT))
      sub_10008E6B4();
    goto LABEL_307;
  }
  v141 = v170;
  v142 = CFStringGetCStringPtr(v170, 0x8000100u);
  if (!v142)
  {
    v143 = 1843175792;
    goto LABEL_296;
  }
LABEL_272:
  v175 = (char *)v142;
  v176 = 0;
LABEL_297:
  if (qword_1000EBD40)
    v187 = (FILE *)qword_1000EBD40;
  else
    v187 = __stderrp;
  fprintf(v187, "%s\n", v175);
  if (v176)
    free(v176);
  v188 = v141;
LABEL_319:
  CFRelease(v188);
LABEL_320:
  *__error() = v138;
LABEL_321:
  v193 = *(_DWORD *)(a1 + 100);
  if (v193 + 1 >= 2)
    sub_1000554DC(*(_QWORD *)(a1 + 64), *(unsigned int *)(a1 + 96), v193);
  v194 = *(_QWORD *)(a1 + 56);
  if (v194)
  {
    if (v134)
      v195 = 0x2000000000;
    else
      v195 = 0x1000000000;
    (*(void (**)(uint64_t, uint64_t))(v194 + 16))(v194, v195);
  }

}

uint64_t sub_1000554DC(uint64_t a1, uint64_t a2, mach_port_name_t name)
{
  int v5;
  NSObject *v6;
  BOOL v7;
  int v8;
  _DWORD *v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *CStringPtr;
  malloc_type_id_t v13;
  int v14;
  NSObject *v15;
  BOOL v16;
  _DWORD *v17;
  const __CFString *v18;
  int v19;
  NSObject *v20;
  BOOL v21;
  _DWORD *v22;
  const __CFString *v23;
  char *v24;
  char *v25;
  int v26;
  NSObject *v27;
  BOOL v28;
  const __CFString *v29;
  const __CFString *v30;
  const char *v31;
  malloc_type_id_t v32;
  int v33;
  NSObject *v34;
  BOOL v35;
  const __CFString *v36;
  int v37;
  NSObject *v38;
  BOOL v39;
  const __CFString *v40;
  char *v41;
  char *v42;
  NSObject *v43;
  NSObject *v44;
  NSObject *v45;
  FILE *v46;
  const __CFString *v47;
  NSObject *v48;
  NSObject *v49;
  NSObject *v50;
  FILE *v51;
  FILE *v52;
  uint8_t buf[4];
  _DWORD *v55;
  __int16 v56;
  int v57;

  if (a1 != 2)
  {
    if (a1 != 1)
    {
      if (a1)
        return mach_port_deallocate(mach_task_self_, name);
      if ((a2 & 0x80000000) == 0)
      {
        if (byte_1000EBD38)
        {
          v5 = *__error();
          v6 = sub_100030318();
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            v55 = sub_1000302B4(a2);
            v56 = 1024;
            v57 = a2;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 0x12u);
          }
          *__error() = v5;
        }
        if (byte_1000EBD39)
          v7 = dword_1000EB4E8 <= 2;
        else
          v7 = 0;
        if (!v7)
          return mach_port_deallocate(mach_task_self_, name);
        v8 = *__error();
        v9 = sub_1000302B4(a2);
        v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion"), v9, a2);
        if (v10)
        {
          v11 = v10;
          CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
          if (!CStringPtr)
          {
            v13 = 446669766;
LABEL_86:
            v24 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v13);
            CFStringGetCString(v11, v24, 1024, 0x8000100u);
            v25 = v24;
            goto LABEL_87;
          }
          goto LABEL_42;
        }
        v45 = sub_100030318();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
          sub_10008EAFC(a2);
        goto LABEL_99;
      }
      if (byte_1000EBD38)
      {
        v37 = *__error();
        v38 = sub_100030318();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 2u);
        }
        *__error() = v37;
      }
      if (byte_1000EBD39)
        v39 = dword_1000EB4E8 <= 2;
      else
        v39 = 0;
      if (!v39)
        return mach_port_deallocate(mach_task_self_, name);
      v8 = *__error();
      v40 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion"));
      if (!v40)
      {
        v50 = sub_100030318();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_FAULT))
          sub_10008EB68();
        goto LABEL_99;
      }
      v30 = v40;
      v31 = CFStringGetCStringPtr(v40, 0x8000100u);
      if (v31)
        goto LABEL_78;
      v32 = 446669766;
LABEL_104:
      v41 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v32);
      CFStringGetCString(v30, v41, 1024, 0x8000100u);
      v42 = v41;
      goto LABEL_105;
    }
    if ((a2 & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v19 = *__error();
        v20 = sub_100030318();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446466;
          v55 = sub_1000302B4(a2);
          v56 = 1024;
          v57 = a2;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 0x12u);
        }
        *__error() = v19;
      }
      if (byte_1000EBD39)
        v21 = dword_1000EB4E8 <= 2;
      else
        v21 = 0;
      if (v21)
      {
        v8 = *__error();
        v22 = sub_1000302B4(a2);
        v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion"), v22, a2);
        if (v23)
        {
          v11 = v23;
          CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
          if (!CStringPtr)
          {
            v13 = 3880392626;
            goto LABEL_86;
          }
          goto LABEL_42;
        }
        v44 = sub_100030318();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
          sub_10008EB94(a2);
        goto LABEL_99;
      }
      return mach_port_deallocate(mach_task_self_, name);
    }
    if (byte_1000EBD38)
    {
      v33 = *__error();
      v34 = sub_100030318();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 2u);
      }
      *__error() = v33;
    }
    if (byte_1000EBD39)
      v35 = dword_1000EB4E8 <= 2;
    else
      v35 = 0;
    if (!v35)
      return mach_port_deallocate(mach_task_self_, name);
    v8 = *__error();
    v36 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion"));
    if (!v36)
    {
      v49 = sub_100030318();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
        sub_10008EC00();
      goto LABEL_99;
    }
    v30 = v36;
    v31 = CFStringGetCStringPtr(v36, 0x8000100u);
    if (!v31)
    {
      v32 = 3880392626;
      goto LABEL_104;
    }
    goto LABEL_78;
  }
  if ((a2 & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v26 = *__error();
      v27 = sub_100030318();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 2u);
      }
      *__error() = v26;
    }
    if (byte_1000EBD39)
      v28 = dword_1000EB4E8 <= 2;
    else
      v28 = 0;
    if (!v28)
      return mach_port_deallocate(mach_task_self_, name);
    v8 = *__error();
    v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion"));
    if (!v29)
    {
      v48 = sub_100030318();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
        sub_10008EC98();
      goto LABEL_99;
    }
    v30 = v29;
    v31 = CFStringGetCStringPtr(v29, 0x8000100u);
    if (!v31)
    {
      v32 = 1526647797;
      goto LABEL_104;
    }
LABEL_78:
    v41 = (char *)v31;
    v42 = 0;
LABEL_105:
    if (qword_1000EBD40)
      v52 = (FILE *)qword_1000EBD40;
    else
      v52 = __stderrp;
    fprintf(v52, "%s\n", v41);
    if (v42)
      free(v42);
    v47 = v30;
    goto LABEL_111;
  }
  if (byte_1000EBD38)
  {
    v14 = *__error();
    v15 = sub_100030318();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      v55 = sub_1000302B4(a2);
      v56 = 1024;
      v57 = a2;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", buf, 0x12u);
    }
    *__error() = v14;
  }
  if (byte_1000EBD39)
    v16 = dword_1000EB4E8 <= 2;
  else
    v16 = 0;
  if (v16)
  {
    v8 = *__error();
    v17 = sub_1000302B4(a2);
    v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion"), v17, a2);
    if (v18)
    {
      v11 = v18;
      CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
      if (!CStringPtr)
      {
        v13 = 1526647797;
        goto LABEL_86;
      }
LABEL_42:
      v24 = (char *)CStringPtr;
      v25 = 0;
LABEL_87:
      if (qword_1000EBD40)
        v46 = (FILE *)qword_1000EBD40;
      else
        v46 = __stderrp;
      fprintf(v46, "%s\n", v24);
      if (v25)
        free(v25);
      v47 = v11;
LABEL_111:
      CFRelease(v47);
LABEL_112:
      *__error() = v8;
      return mach_port_deallocate(mach_task_self_, name);
    }
    v43 = sub_100030318();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
      sub_10008EC2C(a2);
LABEL_99:
    if (qword_1000EBD40)
      v51 = (FILE *)qword_1000EBD40;
    else
      v51 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v51);
    goto LABEL_112;
  }
  return mach_port_deallocate(mach_task_self_, name);
}

void sub_100055CB4(uint64_t a1)
{
  uint64_t v2;
  char v3;
  const char *v4;
  const char *v5;
  const char *v6;
  NSString *v7;
  uid_t v8;
  int v9;
  int v10;
  int *v11;
  FILE *v12;
  FILE *v13;
  id v14;
  int *v15;
  const __CFString *v16;
  unint64_t v17;
  const __CFString *v18;
  const __CFString *v19;
  id v20;
  id v21;
  size_t v22;
  void *v23;
  size_t v24;
  void *v25;
  int v26;
  NSObject *v27;
  _DWORD *v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  const __CFString *v32;
  const __CFString *v33;
  const char *v34;
  malloc_type_id_t v35;
  int *v36;
  int v37;
  NSObject *v38;
  int v39;
  _DWORD *v40;
  uint64_t v41;
  uint64_t v42;
  int *v43;
  char *v44;
  const __CFString *v45;
  const __CFString *v46;
  const char *v47;
  malloc_type_id_t v48;
  int *v49;
  int v50;
  NSObject *v51;
  _DWORD *v52;
  uint64_t v53;
  uint64_t v54;
  int *v55;
  char *v56;
  const __CFString *v57;
  char *v58;
  char *v59;
  int v60;
  NSObject *v61;
  uint64_t v62;
  int *v63;
  char *v64;
  const __CFString *v65;
  const __CFString *v66;
  const char *v67;
  malloc_type_id_t v68;
  id v69;
  int v70;
  NSObject *v71;
  _DWORD *v72;
  uint64_t v73;
  uint64_t v74;
  char *v75;
  const __CFString *v76;
  const char *v77;
  char *v78;
  int v79;
  NSObject *v80;
  uint64_t v81;
  int *v82;
  char *v83;
  const __CFString *v84;
  char *v85;
  char *v86;
  int v87;
  NSObject *v88;
  _DWORD *v89;
  const __CFString *v90;
  char *v91;
  char *v92;
  NSObject *v93;
  NSObject *v94;
  NSObject *v95;
  int v96;
  NSObject *v97;
  int v98;
  uint64_t v99;
  char *v100;
  const __CFString *v101;
  const __CFString *v102;
  const char *v103;
  char *v104;
  char *v105;
  int v106;
  NSObject *v107;
  const __CFString *v108;
  const char *v109;
  FILE *v110;
  const __CFString *v111;
  NSObject *v112;
  FILE *v113;
  int v114;
  NSObject *v115;
  uint64_t v116;
  char *v117;
  const __CFString *v118;
  const char *v119;
  char *v120;
  FILE *v121;
  uint64_t v122;
  void (*v123)(void);
  NSObject *v124;
  NSObject *v125;
  NSObject *v126;
  FILE *v127;
  NSObject *v128;
  FILE *v129;
  FILE *v130;
  CFAllocatorRef v131;
  NSObject *v132;
  FILE *v133;
  FILE *v134;
  const __CFString *v135;
  NSObject *v136;
  FILE *v137;
  CFAllocatorRef v138;
  FILE *v139;
  int v140;
  NSObject *v141;
  id v142;
  int v143;
  int v144;
  const __CFString *v145;
  const __CFString *v146;
  const char *CStringPtr;
  char *v148;
  char *v149;
  NSObject *v150;
  FILE *v151;
  FILE *v152;
  uint64_t v153;
  id v154;
  int v155;
  CFAllocatorRef alloc;
  CFAllocatorRef alloca;
  int v158;
  void *v159;
  unsigned int v160;
  tm v161;
  uint8_t buf[4];
  id v163;
  __int16 v164;
  int v165;
  __int16 v166;
  const char *v167;
  __int16 v168;
  NSString *v169;
  char v170[64];

  v2 = *(_QWORD *)(a1 + 80);
  if (v2 == 2)
  {
    v3 = *(_BYTE *)(a1 + 88);
    v4 = "ExhaustionFatal_KQWorkLoops";
    v5 = "Exhaustion_KQWorkLoops";
  }
  else if (v2 == 1)
  {
    v3 = *(_BYTE *)(a1 + 88);
    v4 = "ExhaustionFatal_Ports";
    v5 = "Exhaustion_Ports";
  }
  else
  {
    if (v2)
    {
      v6 = 0;
      goto LABEL_11;
    }
    v3 = *(_BYTE *)(a1 + 88);
    v4 = "ExhaustionFatal_FileDescriptors";
    v5 = "Exhaustion_FileDescriptors";
  }
  if ((v3 & 1) != 0)
    v6 = v4;
  else
    v6 = v5;
LABEL_11:
  memset(&v161, 0, sizeof(v161));
  localtime_r((const time_t *)(a1 + 96), &v161);
  strftime(v170, 0x40uLL, "%F_%H-%M-%S", &v161);
  v7 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("/private/var/db/spindump/%s_%@_%s.txt"), v6, objc_msgSend(objc_msgSend(*(id *)(a1 + 32), "lastPathComponent"), "stringByReplacingOccurrencesOfString:withString:", CFSTR(" "), CFSTR("_")), v170);
  v8 = geteuid();
  v9 = sub_10004EDCC(v7, 0, 0, 1538, v8, 0x1A4u, 0);
  if ((v9 & 0x80000000) == 0)
  {
    v10 = v9;
    v11 = (int *)dup(v9);
    v12 = fdopen(v10, "w");
    if (v12)
    {
      v13 = v12;
      v14 = objc_msgSend(objc_alloc((Class)SASampleStore), "initForLiveSampling");
      sub_10005993C(v14, (byte_1000EBD4C >> 3) & 1, (byte_1000EBD4C >> 2) & 1, (byte_1000EBD4C >> 4) & 1);
      objc_msgSend(v14, "addKCDataStackshot:", *(_QWORD *)(a1 + 48));
      v15 = (int *)(a1 + 120);
      objc_msgSend(v14, "setTargetProcessId:", *(unsigned int *)(a1 + 120));
      objc_msgSend(v14, "postprocess");
      if (*(_QWORD *)(a1 + 56))
        v16 = *(const __CFString **)(a1 + 56);
      else
        v16 = CFSTR("none");
      objc_msgSend(v14, "setActionTaken:", v16);
      v17 = *(_QWORD *)(a1 + 80);
      if (v17 <= 2)
        objc_msgSend(v14, "setEvent:", off_1000DD560[v17]);
      if ((*(_QWORD *)(a1 + 88) & 1) != 0)
        v18 = CFSTR(" (fatal)");
      else
        v18 = &stru_1000E0D48;
      objc_msgSend(v14, "setEventNote:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%llu allocated, exceeding limit of %llu%@"), *(_QWORD *)(a1 + 104), *(_QWORD *)(a1 + 112), v18));
      if ((*(_QWORD *)(a1 + 88) & 1) != 0)
        v19 = CFSTR("Process killed");
      else
        v19 = CFSTR("none");
      objc_msgSend(v14, "setActionTaken:", v19);
      v20 = objc_msgSend(objc_alloc((Class)SASamplePrinter), "initWithSampleStore:", v14);
      objc_msgSend(objc_msgSend(v20, "options"), "setDisplayHeader:", 1);
      objc_msgSend(objc_msgSend(v20, "options"), "setDisplayBody:", 0);
      objc_msgSend(objc_msgSend(v20, "options"), "setDisplayFooter:", 0);
      objc_msgSend(v20, "setIncidentUUID:", +[NSUUID UUID](NSUUID, "UUID"));
      objc_msgSend(v20, "printToStream:", v13);
      fputc(10, v13);
      v21 = objc_msgSend(*(id *)(a1 + 64), "lengthOfBytesUsingEncoding:", 4);
      if (!v21)
      {
LABEL_216:
        objc_msgSend(objc_msgSend(v20, "options"), "setDisplayHeader:", 0);
        objc_msgSend(objc_msgSend(v20, "options"), "setDisplayBody:", 1);
        objc_msgSend(objc_msgSend(v20, "options"), "setDisplayFooter:", 1);
        objc_msgSend(v20, "printToStream:", v13);

        fwrite("\n\n", 2uLL, 1uLL, v13);
        objc_msgSend(v14, "setCustomOutput:", *(_QWORD *)(a1 + 64));
        objc_msgSend(v14, "saveBinaryFormatToStream:", v13);

        fclose(v13);
        if ((_DWORD)v11 != -1)
        {
          sub_100057CE4(v11);
          close((int)v11);
        }
        if (byte_1000EBD38)
        {
          v140 = *__error();
          v141 = sub_100030318();
          if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
          {
            v142 = objc_msgSend(*(id *)(a1 + 32), "lastPathComponent");
            v143 = *(_DWORD *)(a1 + 120);
            *(_DWORD *)buf = 138413058;
            v163 = v142;
            v164 = 1024;
            v165 = v143;
            v166 = 2082;
            v167 = v6;
            v168 = 2112;
            v169 = v7;
            _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "%@ [%d] Saved %{public}s report to %@", buf, 0x26u);
          }
          *__error() = v140;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
        {
          v144 = *__error();
          v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@ [%d] Saved %s report to %@"), objc_msgSend(*(id *)(a1 + 32), "lastPathComponent"), *(unsigned int *)(a1 + 120), v6, v7);
          if (v145)
          {
            v146 = v145;
            CStringPtr = CFStringGetCStringPtr(v145, 0x8000100u);
            if (CStringPtr)
            {
              v148 = (char *)CStringPtr;
              v149 = 0;
            }
            else
            {
              v148 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7912DBE8uLL);
              CFStringGetCString(v146, v148, 1024, 0x8000100u);
              v149 = v148;
            }
            if (qword_1000EBD40)
              v152 = (FILE *)qword_1000EBD40;
            else
              v152 = __stderrp;
            fprintf(v152, "%s\n", v148);
            if (v149)
              free(v149);
            CFRelease(v146);
          }
          else
          {
            v150 = sub_100030318();
            if (os_log_type_enabled(v150, OS_LOG_TYPE_FAULT))
            {
              v154 = objc_msgSend(*(id *)(a1 + 32), "lastPathComponent");
              v155 = *(_DWORD *)(a1 + 120);
              *(_DWORD *)buf = 138413058;
              v163 = v154;
              v164 = 1024;
              v165 = v155;
              v166 = 2080;
              v167 = v6;
              v168 = 2112;
              v169 = v7;
              _os_log_fault_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_FAULT, "Unable to format: %@ [%d] Saved %s report to %@", buf, 0x26u);
            }
            if (qword_1000EBD40)
              v151 = (FILE *)qword_1000EBD40;
            else
              v151 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v151);
          }
          *__error() = v144;
        }
        sub_100057258(v6, 3600);
        v153 = *(_QWORD *)(a1 + 72);
        if (v153)
        {
          v123 = *(void (**)(void))(v153 + 16);
          goto LABEL_243;
        }
        goto LABEL_244;
      }
      v22 = (size_t)v21;
      v160 = v11;
      v23 = malloc_type_malloc((size_t)v21, 0x23BFECBCuLL);
      if (objc_msgSend(*(id *)(a1 + 64), "getCString:maxLength:encoding:", v23, v22, 4))
      {
        v24 = fwrite(v23, v22, 1uLL, v13);
        v25 = v23;
        if (v24 != 1)
        {
          if ((*v15 & 0x80000000) == 0)
          {
            if (byte_1000EBD38)
            {
              v26 = *__error();
              v27 = sub_100030318();
              if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
                sub_10008F10C();
              *__error() = v26;
              v25 = v23;
            }
            if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
              goto LABEL_215;
            v159 = v25;
            v158 = *__error();
            v28 = sub_1000302B4(*v15);
            v29 = *v15;
            v30 = ferror(v13);
            v31 = strerror(v30);
            v32 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)"), v28, v29, v30, v31);
            if (v32)
            {
              v33 = v32;
              v34 = CFStringGetCStringPtr(v32, 0x8000100u);
              if (!v34)
              {
                v35 = 3700517583;
LABEL_173:
                v91 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v35);
                CFStringGetCString(v33, v91, 1024, 0x8000100u);
                v92 = v91;
                goto LABEL_174;
              }
              goto LABEL_96;
            }
            v124 = sub_100030318();
            if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT))
              goto LABEL_161;
            goto LABEL_162;
          }
          if (byte_1000EBD38)
          {
            v96 = *__error();
            v97 = sub_100030318();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
              sub_10008F1F0(v13);
            *__error() = v96;
            v25 = v23;
          }
          if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
            goto LABEL_215;
          v98 = *__error();
          v99 = ferror(v13);
          v100 = strerror(v99);
          v101 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write ddt/lsof output to buffer: %d (%s)"), v99, v100);
          if (!v101)
          {
            v128 = sub_100030318();
            if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT))
              sub_10008F184(v13);
            if (qword_1000EBD40)
              v129 = (FILE *)qword_1000EBD40;
            else
              v129 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v129);
            goto LABEL_214;
          }
          v102 = v101;
          v158 = v98;
          v159 = v25;
          v103 = CFStringGetCStringPtr(v101, 0x8000100u);
          if (v103)
          {
            v104 = (char *)v103;
            v105 = 0;
          }
          else
          {
            v104 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDC916ACFuLL);
            CFStringGetCString(v102, v104, 1024, 0x8000100u);
            v105 = v104;
          }
          goto LABEL_199;
        }
LABEL_215:
        free(v25);
        v11 = (int *)v160;
        goto LABEL_216;
      }
      v159 = v23;
      v69 = objc_msgSend(*(id *)(a1 + 64), "dataUsingEncoding:allowLossyConversion:", 4, 1);
      if (v69)
      {
        v25 = v23;
        if (fwrite(objc_msgSend(v69, "bytes"), (size_t)objc_msgSend(v69, "length"), 1uLL, v13) == 1)
          goto LABEL_215;
        if ((*v15 & 0x80000000) == 0)
        {
          if (byte_1000EBD38)
          {
            v70 = *__error();
            v71 = sub_100030318();
            if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
              sub_10008F10C();
            *__error() = v70;
            v25 = v23;
          }
          if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
            goto LABEL_215;
          v158 = *__error();
          v72 = sub_1000302B4(*v15);
          v73 = *v15;
          v74 = ferror(v13);
          v75 = strerror(v74);
          v76 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)"), v72, v73, v74, v75);
          if (v76)
          {
            v33 = v76;
            v77 = CFStringGetCStringPtr(v76, 0x8000100u);
            if (v77)
            {
              v78 = (char *)v77;
              alloc = 0;
            }
            else
            {
              v78 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xABF51116uLL);
              CFStringGetCString(v33, v78, 1024, 0x8000100u);
              alloc = (CFAllocatorRef)v78;
            }
            if (qword_1000EBD40)
              v134 = (FILE *)qword_1000EBD40;
            else
              v134 = __stderrp;
            fprintf(v134, "%s\n", v78);
            v131 = alloc;
            if (!alloc)
              goto LABEL_191;
            goto LABEL_190;
          }
          v126 = sub_100030318();
          if (os_log_type_enabled(v126, OS_LOG_TYPE_FAULT))
LABEL_161:
            sub_10008F094();
LABEL_162:
          if (qword_1000EBD40)
            v127 = (FILE *)qword_1000EBD40;
          else
            v127 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
          goto LABEL_212;
        }
        if (byte_1000EBD38)
        {
          v114 = *__error();
          v115 = sub_100030318();
          if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
            sub_10008F1F0(v13);
          *__error() = v114;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
          goto LABEL_215;
        v158 = *__error();
        v116 = ferror(v13);
        v117 = strerror(v116);
        v118 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write ddt/lsof output to buffer: %d (%s)"), v116, v117);
        if (v118)
        {
          v102 = v118;
          v119 = CFStringGetCStringPtr(v118, 0x8000100u);
          if (v119)
          {
            v120 = (char *)v119;
            alloca = 0;
          }
          else
          {
            v120 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xABF51116uLL);
            CFStringGetCString(v102, v120, 1024, 0x8000100u);
            alloca = (CFAllocatorRef)v120;
          }
          if (qword_1000EBD40)
            v139 = (FILE *)qword_1000EBD40;
          else
            v139 = __stderrp;
          fprintf(v139, "%s\n", v120);
          v138 = alloca;
          if (!alloca)
            goto LABEL_210;
          goto LABEL_209;
        }
        v136 = sub_100030318();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
          sub_10008F184(v13);
        if (qword_1000EBD40)
          v133 = (FILE *)qword_1000EBD40;
        else
          v133 = __stderrp;
      }
      else
      {
        if ((*v15 & 0x80000000) == 0)
        {
          if (byte_1000EBD38)
          {
            v87 = *__error();
            v88 = sub_100030318();
            if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
              sub_10008F2CC();
            *__error() = v87;
          }
          v25 = v23;
          if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
            goto LABEL_215;
          v158 = *__error();
          v89 = sub_1000302B4(*v15);
          v90 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to convert ddt/lsof output to buffer"), v89, *v15);
          if (v90)
          {
            v33 = v90;
            v34 = CFStringGetCStringPtr(v90, 0x8000100u);
            if (!v34)
            {
              v35 = 2270732346;
              goto LABEL_173;
            }
LABEL_96:
            v91 = (char *)v34;
            v92 = 0;
LABEL_174:
            if (qword_1000EBD40)
              v130 = (FILE *)qword_1000EBD40;
            else
              v130 = __stderrp;
            fprintf(v130, "%s\n", v91);
            if (!v92)
              goto LABEL_191;
            v131 = (CFAllocatorRef)v92;
LABEL_190:
            free(v131);
LABEL_191:
            v135 = v33;
LABEL_211:
            CFRelease(v135);
LABEL_212:
            v25 = v159;
            goto LABEL_213;
          }
          v125 = sub_100030318();
          if (os_log_type_enabled(v125, OS_LOG_TYPE_FAULT))
            sub_10008F25C();
          goto LABEL_162;
        }
        if (byte_1000EBD38)
        {
          v106 = *__error();
          v107 = sub_100030318();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
            sub_10008F368();
          *__error() = v106;
        }
        v25 = v23;
        if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
          goto LABEL_215;
        v158 = *__error();
        v108 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to convert ddt/lsof output to buffer"));
        if (v108)
        {
          v102 = v108;
          v109 = CFStringGetCStringPtr(v108, 0x8000100u);
          if (v109)
          {
            v104 = (char *)v109;
            v105 = 0;
          }
          else
          {
            v104 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8758A03AuLL);
            CFStringGetCString(v102, v104, 1024, 0x8000100u);
            v105 = v104;
          }
LABEL_199:
          if (qword_1000EBD40)
            v137 = (FILE *)qword_1000EBD40;
          else
            v137 = __stderrp;
          fprintf(v137, "%s\n", v104);
          if (!v105)
            goto LABEL_210;
          v138 = (CFAllocatorRef)v105;
LABEL_209:
          free(v138);
LABEL_210:
          v135 = v102;
          goto LABEL_211;
        }
        v132 = sub_100030318();
        if (os_log_type_enabled(v132, OS_LOG_TYPE_FAULT))
          sub_10008F33C();
        if (qword_1000EBD40)
          v133 = (FILE *)qword_1000EBD40;
        else
          v133 = __stderrp;
      }
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v133);
LABEL_213:
      v98 = v158;
LABEL_214:
      *__error() = v98;
      goto LABEL_215;
    }
    v49 = (int *)(a1 + 120);
    if ((*(_DWORD *)(a1 + 120) & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v50 = *__error();
        v51 = sub_100030318();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          sub_10008EF2C();
        *__error() = v50;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v39 = *__error();
        v52 = sub_1000302B4(*v49);
        v53 = *v49;
        v54 = *__error();
        v55 = __error();
        v56 = strerror(*v55);
        v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: could not fdopen log file %@: %d (%s)"), v52, v53, v7, v54, v56);
        if (v57)
        {
          v46 = v57;
          v47 = CFStringGetCStringPtr(v57, 0x8000100u);
          if (v47)
            goto LABEL_56;
          v48 = 2643340271;
          goto LABEL_122;
        }
        v94 = sub_100030318();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
          sub_10008EEAC();
        goto LABEL_131;
      }
      goto LABEL_154;
    }
    if (byte_1000EBD38)
    {
      v79 = *__error();
      v80 = sub_100030318();
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
        sub_10008F020();
      *__error() = v79;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_154;
    v39 = *__error();
    v81 = *__error();
    v82 = __error();
    v83 = strerror(*v82);
    v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("could not fdopen log file %@: %d (%s)"), v7, v81, v83);
    if (!v84)
    {
      v112 = sub_100030318();
      if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
        sub_10008EFAC();
      goto LABEL_131;
    }
    v66 = v84;
    v67 = CFStringGetCStringPtr(v84, 0x8000100u);
    if (v67)
      goto LABEL_86;
    v68 = 2643340271;
    goto LABEL_145;
  }
  v36 = (int *)(a1 + 120);
  if ((*(_DWORD *)(a1 + 120) & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v60 = *__error();
      v61 = sub_100030318();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        sub_10008EE38();
      *__error() = v60;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_154;
    v39 = *__error();
    v62 = *__error();
    v63 = __error();
    v64 = strerror(*v63);
    v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("could not open log file %@: %d (%s)"), v7, v62, v64);
    if (!v65)
    {
      v95 = sub_100030318();
      if (os_log_type_enabled(v95, OS_LOG_TYPE_FAULT))
        sub_10008EDC4();
      goto LABEL_131;
    }
    v66 = v65;
    v67 = CFStringGetCStringPtr(v65, 0x8000100u);
    if (v67)
    {
LABEL_86:
      v85 = (char *)v67;
      v86 = 0;
LABEL_146:
      if (qword_1000EBD40)
        v121 = (FILE *)qword_1000EBD40;
      else
        v121 = __stderrp;
      fprintf(v121, "%s\n", v85);
      if (v86)
        free(v86);
      v111 = v66;
      goto LABEL_152;
    }
    v68 = 4058203421;
LABEL_145:
    v85 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v68);
    CFStringGetCString(v66, v85, 1024, 0x8000100u);
    v86 = v85;
    goto LABEL_146;
  }
  if (byte_1000EBD38)
  {
    v37 = *__error();
    v38 = sub_100030318();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      sub_10008ED44();
    *__error() = v37;
  }
  if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
  {
    v39 = *__error();
    v40 = sub_1000302B4(*v36);
    v41 = *v36;
    v42 = *__error();
    v43 = __error();
    v44 = strerror(*v43);
    v45 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: could not open log file %@: %d (%s)"), v40, v41, v7, v42, v44);
    if (v45)
    {
      v46 = v45;
      v47 = CFStringGetCStringPtr(v45, 0x8000100u);
      if (v47)
      {
LABEL_56:
        v58 = (char *)v47;
        v59 = 0;
LABEL_123:
        if (qword_1000EBD40)
          v110 = (FILE *)qword_1000EBD40;
        else
          v110 = __stderrp;
        fprintf(v110, "%s\n", v58);
        if (v59)
          free(v59);
        v111 = v46;
LABEL_152:
        CFRelease(v111);
LABEL_153:
        *__error() = v39;
        goto LABEL_154;
      }
      v48 = 4058203421;
LABEL_122:
      v58 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v48);
      CFStringGetCString(v46, v58, 1024, 0x8000100u);
      v59 = v58;
      goto LABEL_123;
    }
    v93 = sub_100030318();
    if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT))
      sub_10008ECC4();
LABEL_131:
    if (qword_1000EBD40)
      v113 = (FILE *)qword_1000EBD40;
    else
      v113 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v113);
    goto LABEL_153;
  }
LABEL_154:
  v122 = *(_QWORD *)(a1 + 72);
  if (v122)
  {
    v123 = *(void (**)(void))(v122 + 16);
LABEL_243:
    v123();
  }
LABEL_244:

}

uint64_t sub_100057228()
{
  FILE *v0;

  return ferror(v0);
}

int *sub_100057238()
{
  return __error();
}

int *sub_100057244()
{
  return __error();
}

int *sub_100057250()
{
  return __error();
}

void sub_100057258(const char *a1, uint64_t a2)
{
  time_t v4;
  char *v5;
  uint64_t v6;
  NSObject *global_queue;
  _QWORD block[8];

  v4 = time(0);
  v5 = strdup(a1);
  v6 = sub_100030160("Cleanup spindump dir for %s", a1);
  global_queue = dispatch_get_global_queue(9, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000572FC;
  block[3] = &unk_1000DD580;
  block[6] = v4;
  block[7] = a2;
  block[4] = v6;
  block[5] = v5;
  dispatch_async(global_queue, block);
}

void sub_1000572FC(uint64_t a1)
{
  DIR *v2;
  DIR *v3;
  dirent *i;
  const char *d_name;
  size_t v6;
  int v7;
  NSObject *v8;
  BOOL v9;
  int v10;
  const __CFString *v11;
  const __CFString *v12;
  const char *v13;
  char *v14;
  char *v15;
  int v16;
  NSObject *v17;
  BOOL v18;
  int v19;
  uint64_t v20;
  int *v21;
  char *v22;
  const __CFString *v23;
  const __CFString *v24;
  const char *CStringPtr;
  malloc_type_id_t v26;
  int v27;
  NSObject *v28;
  const __CFString *v29;
  malloc_type_id_t v30;
  NSObject *v31;
  FILE *v32;
  FILE *v33;
  int v34;
  NSObject *v35;
  uint64_t v36;
  __darwin_time_t v37;
  const __CFString *v38;
  char *v39;
  char *v40;
  NSObject *v41;
  int v42;
  int *v43;
  char *v44;
  NSObject *v45;
  const char *v46;
  uint32_t v47;
  __darwin_ino64_t v48;
  NSObject *v49;
  uint64_t v50;
  __darwin_time_t v51;
  uint8_t *v52;
  NSObject *v53;
  const char *v54;
  uint32_t v55;
  NSObject *v56;
  uint64_t v57;
  __darwin_time_t v58;
  FILE *v59;
  int v60;
  int *v61;
  char *v62;
  FILE *v63;
  __darwin_ino64_t v64;
  uint64_t v65;
  __darwin_time_t v66;
  int v67;
  NSObject *v68;
  BOOL v69;
  int v70;
  uint64_t v71;
  int *v72;
  char *v73;
  const __CFString *v74;
  const __CFString *v75;
  const char *v76;
  char *v77;
  char *v78;
  NSObject *v79;
  FILE *v80;
  FILE *v81;
  uint8_t buf[4];
  char *v83;
  __int16 v84;
  _BYTE v85[18];
  stat v86;
  char __str[128];

  v2 = opendir("/private/var/db/spindump");
  if (v2)
  {
    v3 = v2;
    *__error() = 0;
    for (i = readdir(v3); i; i = readdir(v3))
    {
      d_name = i->d_name;
      v6 = strlen(*(const char **)(a1 + 40));
      if (!strncmp(d_name, *(const char **)(a1 + 40), v6))
      {
        snprintf(__str, 0x80uLL, "/private/var/db/spindump/%s", d_name);
        memset(&v86, 0, sizeof(v86));
        if (stat(__str, &v86))
        {
          if (byte_1000EBD38)
          {
            v16 = *__error();
            v17 = sub_100030318();
            if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
            {
              v60 = *__error();
              v61 = __error();
              v62 = strerror(*v61);
              *(_DWORD *)buf = 136315650;
              v83 = __str;
              v84 = 1024;
              *(_DWORD *)v85 = v60;
              *(_WORD *)&v85[4] = 2080;
              *(_QWORD *)&v85[6] = v62;
              _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Stat failed, attemping unlink of %s: %d (%s)", buf, 0x1Cu);
            }
            *__error() = v16;
          }
          if (byte_1000EBD39)
            v18 = dword_1000EB4E8 <= 3;
          else
            v18 = 0;
          if (!v18)
            goto LABEL_82;
          v19 = *__error();
          v20 = *__error();
          v21 = __error();
          v22 = strerror(*v21);
          v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Stat failed, attemping unlink of %s: %d (%s)"), __str, v20, v22);
          if (v23)
          {
            v24 = v23;
            CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
            if (CStringPtr)
              goto LABEL_61;
            v26 = 4028211986;
            goto LABEL_74;
          }
          v41 = sub_100030318();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
          {
            v42 = *__error();
            v43 = __error();
            v44 = strerror(*v43);
            *(_DWORD *)buf = 136315650;
            v83 = __str;
            v84 = 1024;
            *(_DWORD *)v85 = v42;
            *(_WORD *)&v85[4] = 2080;
            *(_QWORD *)&v85[6] = v44;
            v45 = v41;
            v46 = "Unable to format: Stat failed, attemping unlink of %s: %d (%s)";
            v47 = 28;
            goto LABEL_68;
          }
          goto LABEL_69;
        }
        if (v86.st_ctimespec.tv_sec <= *(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 56))
        {
          if (byte_1000EBD38)
          {
            v34 = *__error();
            v35 = sub_100030318();
            if (os_log_type_enabled(v35, OS_LOG_TYPE_INFO))
            {
              v36 = *(_QWORD *)(a1 + 56);
              v37 = *(_QWORD *)(a1 + 48) - v86.st_ctimespec.tv_sec;
              *(_DWORD *)buf = 136315650;
              v83 = __str;
              v84 = 2048;
              *(_QWORD *)v85 = v37;
              *(_WORD *)&v85[8] = 2048;
              *(_QWORD *)&v85[10] = v36;
              _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_INFO, "Unlinking %s which is %lds old (>=%lds)", buf, 0x20u);
            }
            *__error() = v34;
          }
          if (!byte_1000EBD39 || dword_1000EB4E8 > 1)
            goto LABEL_82;
          v19 = *__error();
          v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unlinking %s which is %lds old (>=%lds)"), __str, *(_QWORD *)(a1 + 48) - v86.st_ctimespec.tv_sec, *(_QWORD *)(a1 + 56));
          if (v38)
          {
            v24 = v38;
            CStringPtr = CFStringGetCStringPtr(v38, 0x8000100u);
            if (CStringPtr)
            {
LABEL_61:
              v39 = (char *)CStringPtr;
              v40 = 0;
              goto LABEL_75;
            }
            v26 = 2546796519;
LABEL_74:
            v39 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v26);
            CFStringGetCString(v24, v39, 1024, 0x8000100u);
            v40 = v39;
LABEL_75:
            if (qword_1000EBD40)
              v63 = (FILE *)qword_1000EBD40;
            else
              v63 = __stderrp;
            fprintf(v63, "%s\n", v39);
            if (v40)
              free(v40);
            CFRelease(v24);
LABEL_81:
            *__error() = v19;
LABEL_82:
            unlink(__str);
            continue;
          }
          v56 = sub_100030318();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
          {
            v57 = *(_QWORD *)(a1 + 56);
            v58 = *(_QWORD *)(a1 + 48) - v86.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            v83 = __str;
            v84 = 2048;
            *(_QWORD *)v85 = v58;
            *(_WORD *)&v85[8] = 2048;
            *(_QWORD *)&v85[10] = v57;
            v45 = v56;
            v46 = "Unable to format: Unlinking %s which is %lds old (>=%lds)";
            v47 = 32;
LABEL_68:
            _os_log_fault_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, v46, buf, v47);
          }
LABEL_69:
          if (qword_1000EBD40)
            v59 = (FILE *)qword_1000EBD40;
          else
            v59 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v59);
          goto LABEL_81;
        }
        if (byte_1000EBD38)
        {
          v27 = *__error();
          v28 = sub_100030318();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            v65 = *(_QWORD *)(a1 + 56);
            v66 = *(_QWORD *)(a1 + 48) - v86.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            v83 = __str;
            v84 = 2048;
            *(_QWORD *)v85 = v66;
            *(_WORD *)&v85[8] = 2048;
            *(_QWORD *)&v85[10] = v65;
            _os_log_debug_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEBUG, "Not unlinking %s which is %lds old (<%lds)", buf, 0x20u);
          }
          *__error() = v27;
        }
        if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
          continue;
        v10 = *__error();
        v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Not unlinking %s which is %lds old (<%lds)"), __str, *(_QWORD *)(a1 + 48) - v86.st_ctimespec.tv_sec, *(_QWORD *)(a1 + 56));
        if (!v29)
        {
          v49 = sub_100030318();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_FAULT))
          {
            v50 = *(_QWORD *)(a1 + 56);
            v51 = *(_QWORD *)(a1 + 48) - v86.st_ctimespec.tv_sec;
            *(_DWORD *)buf = 136315650;
            v83 = __str;
            v84 = 2048;
            *(_QWORD *)v85 = v51;
            *(_WORD *)&v85[8] = 2048;
            *(_QWORD *)&v85[10] = v50;
            v52 = buf;
            v53 = v49;
            v54 = "Unable to format: Not unlinking %s which is %lds old (<%lds)";
            v55 = 32;
            goto LABEL_86;
          }
LABEL_40:
          if (qword_1000EBD40)
            v32 = (FILE *)qword_1000EBD40;
          else
            v32 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
          goto LABEL_52;
        }
        v12 = v29;
        v13 = CFStringGetCStringPtr(v29, 0x8000100u);
        if (!v13)
        {
          v30 = 860181693;
LABEL_45:
          v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v30);
          CFStringGetCString(v12, v14, 1024, 0x8000100u);
          v15 = v14;
          goto LABEL_46;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v7 = *__error();
          v8 = sub_100030318();
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            v48 = *(_QWORD *)(a1 + 40);
            v86.st_dev = 136315394;
            *(_QWORD *)&v86.st_mode = d_name;
            WORD2(v86.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v86.st_ino + 6) = v48;
            _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "File %s doesn't match prefix %s", (uint8_t *)&v86, 0x16u);
          }
          *__error() = v7;
        }
        if (byte_1000EBD39)
          v9 = dword_1000EB4E8 <= 0;
        else
          v9 = 0;
        if (!v9)
          continue;
        v10 = *__error();
        v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("File %s doesn't match prefix %s"), d_name, *(_QWORD *)(a1 + 40));
        if (!v11)
        {
          v31 = sub_100030318();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
          {
            v64 = *(_QWORD *)(a1 + 40);
            v86.st_dev = 136315394;
            *(_QWORD *)&v86.st_mode = d_name;
            WORD2(v86.st_ino) = 2080;
            *(__darwin_ino64_t *)((char *)&v86.st_ino + 6) = v64;
            v52 = (uint8_t *)&v86;
            v53 = v31;
            v54 = "Unable to format: File %s doesn't match prefix %s";
            v55 = 22;
LABEL_86:
            _os_log_fault_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_FAULT, v54, v52, v55);
          }
          goto LABEL_40;
        }
        v12 = v11;
        v13 = CFStringGetCStringPtr(v11, 0x8000100u);
        if (!v13)
        {
          v30 = 1347677374;
          goto LABEL_45;
        }
      }
      v14 = (char *)v13;
      v15 = 0;
LABEL_46:
      if (qword_1000EBD40)
        v33 = (FILE *)qword_1000EBD40;
      else
        v33 = __stderrp;
      fprintf(v33, "%s\n", v14);
      if (v15)
        free(v15);
      CFRelease(v12);
LABEL_52:
      *__error() = v10;
    }

    closedir(v3);
    free(*(void **)(a1 + 40));
  }
  else
  {
    if (byte_1000EBD38)
    {
      v67 = *__error();
      v68 = sub_100030318();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
        sub_10008F410();
      *__error() = v67;
    }
    if (byte_1000EBD39)
      v69 = dword_1000EB4E8 <= 3;
    else
      v69 = 0;
    if (v69)
    {
      v70 = *__error();
      v71 = *__error();
      v72 = __error();
      v73 = strerror(*v72);
      v74 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to opendir /private/var/db/spindump: %d (%s)"), v71, v73);
      if (v74)
      {
        v75 = v74;
        v76 = CFStringGetCStringPtr(v74, 0x8000100u);
        if (v76)
        {
          v77 = (char *)v76;
          v78 = 0;
        }
        else
        {
          v77 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7297CD3AuLL);
          CFStringGetCString(v75, v77, 1024, 0x8000100u);
          v78 = v77;
        }
        if (qword_1000EBD40)
          v81 = (FILE *)qword_1000EBD40;
        else
          v81 = __stderrp;
        fprintf(v81, "%s\n", v77);
        if (v78)
          free(v78);
        CFRelease(v75);
      }
      else
      {
        v79 = sub_100030318();
        if (os_log_type_enabled(v79, OS_LOG_TYPE_FAULT))
          sub_10008F394();
        if (qword_1000EBD40)
          v80 = (FILE *)qword_1000EBD40;
        else
          v80 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v80);
      }
      *__error() = v70;
    }
  }
}

int *sub_100057CE4(int *result)
{
  int *v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  char *v6;
  const __CFString *v7;
  const __CFString *v8;
  const char *CStringPtr;
  char *v10;
  char *v11;
  int v12;
  NSObject *v13;
  BOOL v14;
  const __CFString *v15;
  const __CFString *v16;
  const char *v17;
  char *v18;
  char *v19;
  NSObject *v20;
  FILE *v21;
  const __CFString *v22;
  NSObject *v23;
  FILE *v24;
  FILE *v25;
  uint64_t v26;

  if ((result & 0x80000000) != 0)
    return result;
  v26 = 65605;
  result = (int *)ffsctl((int)result, 0xC0084A44uLL, &v26, 0);
  if ((_DWORD)result)
  {
    v1 = result;
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        sub_10008F57C((int)v1);
      result = __error();
      *result = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 3;
    else
      v4 = 0;
    if (!v4)
      return result;
    v5 = *__error();
    v6 = strerror((int)v1);
    v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to mark file purgeable: %d (%s)"), v1, v6);
    if (v7)
    {
      v8 = v7;
      CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
      if (CStringPtr)
      {
        v10 = (char *)CStringPtr;
        v11 = 0;
      }
      else
      {
        v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1C943F89uLL);
        CFStringGetCString(v8, v10, 1024, 0x8000100u);
        v11 = v10;
      }
      if (qword_1000EBD40)
        v21 = (FILE *)qword_1000EBD40;
      else
        v21 = __stderrp;
      fprintf(v21, "%s\n", v10);
      if (v11)
        free(v11);
      v22 = v8;
LABEL_49:
      CFRelease(v22);
LABEL_50:
      result = __error();
      *result = v5;
      return result;
    }
    v20 = sub_100030318();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
      sub_10008F50C((int)v1);
    goto LABEL_38;
  }
  if (byte_1000EBD38)
  {
    v12 = *__error();
    v13 = sub_100030318();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      sub_10008F4CC(v13);
    result = __error();
    *result = v12;
  }
  if (byte_1000EBD39)
    v14 = dword_1000EB4E8 <= 0;
  else
    v14 = 0;
  if (v14)
  {
    v5 = *__error();
    v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Marked file purgeable"));
    if (v15)
    {
      v16 = v15;
      v17 = CFStringGetCStringPtr(v15, 0x8000100u);
      if (v17)
      {
        v18 = (char *)v17;
        v19 = 0;
      }
      else
      {
        v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x82F5EFFuLL);
        CFStringGetCString(v16, v18, 1024, 0x8000100u);
        v19 = v18;
      }
      if (qword_1000EBD40)
        v25 = (FILE *)qword_1000EBD40;
      else
        v25 = __stderrp;
      fprintf(v25, "%s\n", v18);
      if (v19)
        free(v19);
      v22 = v16;
      goto LABEL_49;
    }
    v23 = sub_100030318();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
      sub_10008F48C(v23);
LABEL_38:
    if (qword_1000EBD40)
      v24 = (FILE *)qword_1000EBD40;
    else
      v24 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v24);
    goto LABEL_50;
  }
  return result;
}

void sub_10005800C(id a1, OS_dispatch_source *a2)
{
  int v3;
  NSObject *v4;
  BOOL v5;
  int v6;
  uintptr_t v7;
  const __CFString *v8;
  NSObject *v9;
  uintptr_t v10;
  FILE *v11;
  const __CFString *v12;
  const char *CStringPtr;
  char *v14;
  char *v15;
  FILE *v16;
  uint8_t buf[4];
  uintptr_t handle;

  if (byte_1000EBD38)
  {
    v3 = *__error();
    v4 = sub_100030318();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 134217984;
      handle = dispatch_source_get_handle((dispatch_source_t)a2);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_INFO, "Received signal %ld, exiting", buf, 0xCu);
    }
    *__error() = v3;
  }
  if (byte_1000EBD39)
    v5 = dword_1000EB4E8 <= 1;
  else
    v5 = 0;
  if (v5)
  {
    v6 = *__error();
    v7 = dispatch_source_get_handle((dispatch_source_t)a2);
    v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Received signal %ld, exiting"), v7);
    if (v8)
    {
      v12 = v8;
      CStringPtr = CFStringGetCStringPtr(v8, 0x8000100u);
      if (CStringPtr)
      {
        v14 = (char *)CStringPtr;
        v15 = 0;
      }
      else
      {
        v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF4B2BA26uLL);
        CFStringGetCString(v12, v14, 1024, 0x8000100u);
        v15 = v14;
      }
      if (qword_1000EBD40)
        v16 = (FILE *)qword_1000EBD40;
      else
        v16 = __stderrp;
      fprintf(v16, "%s\n", v14);
      if (v15)
        free(v15);
      CFRelease(v12);
    }
    else
    {
      v9 = sub_100030318();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
      {
        v10 = dispatch_source_get_handle((dispatch_source_t)a2);
        *(_DWORD *)buf = 134217984;
        handle = v10;
        _os_log_fault_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "Unable to format: Received signal %ld, exiting", buf, 0xCu);
      }
      if (qword_1000EBD40)
        v11 = (FILE *)qword_1000EBD40;
      else
        v11 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }
    *__error() = v6;
  }
  exit(0);
}

_BYTE *sub_100058234(const char *a1)
{
  int v2;
  _BYTE *v3;
  uint64_t i;

  if (!a1)
    return 0;
  v2 = strnlen(a1, 0x100uLL);
  if (v2 < 256)
  {
    v3 = strdup(a1);
    if (v2 < 1)
      return v3;
  }
  else
  {
    v3 = malloc_type_malloc(0x100uLL, 0xE1E07A57uLL);
    __strlcpy_chk(v3, a1, 256, 256);
    v2 = 255;
  }
  for (i = 0; i != v2; ++i)
  {
    if (v3[i] - 9 <= 1)
      v3[i] = 32;
  }
  return v3;
}

int *sub_1000582E8(void *a1)
{
  int *result;
  int v3;
  char *v4;
  BOOL v5;
  int v6;
  const __CFString *v7;
  const __CFString *v8;
  const char *CStringPtr;
  char *v10;
  char *v11;
  char *v12;
  FILE *v13;
  FILE *v14;
  int v15;
  char *v16;
  BOOL v17;
  int v18;
  const __CFString *v19;
  const __CFString *v20;
  const char *v21;
  char *v22;
  char *v23;
  char *v24;
  FILE *v25;
  FILE *v26;
  int v27;
  NSObject *v28;
  int v29;
  const __CFString *v30;
  const __CFString *v31;
  const char *v32;
  char *v33;
  char *v34;
  NSObject *v35;
  FILE *v36;
  FILE *v37;
  int v38;
  NSObject *v39;
  char *v40;
  char *v41;
  id v42;
  char *v43;
  id v44;
  id v45;
  id v46;
  id v47;
  id v48;
  id v49;
  id v50;
  id v51;
  id v52;
  BOOL v53;
  char *v54;
  char *v55;
  id v56;
  char *v57;
  const __CFString *v58;
  const __CFString *v59;
  const char *v60;
  char *v61;
  char *v62;
  NSObject *v63;
  FILE *v64;
  FILE *v65;
  id v66;
  id v67;
  id v68;
  id v69;
  id v70;
  id v71;
  id v72;
  id v73;
  id v74;
  id v75;
  id v76;
  id v77;
  id v78;
  id v79;
  id v80;
  id v81;
  id v82;
  id v83;
  id v84;
  id v85;
  id v86;
  id v87;
  id v88;
  id v89;
  id v90;
  id v91;
  id v92;
  id v93;
  id v94;
  id v95;
  id v96;
  id v97;
  id v98;
  id v99;
  id v100;
  id v101;
  id v102;
  id v103;
  id v104;
  id v105;
  id v106;
  id v107;
  id v108;
  id v109;
  id v110;
  id v111;
  id v112;
  id v113;
  id v114;
  id v115;
  id v116;
  id v117;
  id v118;
  id v119;
  id v120;
  id v121;
  id v122;
  id v123;
  id v124;
  id v125;
  id v126;
  id v127;
  id v128;
  id v129;
  id v130;
  id v131;
  id v132;
  id v133;
  id v134;
  id v135;
  id v136;
  id v137;
  id v138;
  id v139;
  id v140;
  id v141;
  id v142;
  id v143;
  id v144;
  id v145;
  id v146;
  id v147;
  id v148;
  id v149;
  id v150;
  id v151;
  id v152;
  id v153;
  id v154;
  id v155;
  id v156;
  id v157;
  id v158;
  id v159;
  id v160;
  id v161;
  id v162;
  id v163;
  id v164;
  id v165;
  id v166;
  id v167;
  id v168;
  id v169;
  id v170;
  id v171;
  id v172;
  id v173;
  id v174;
  id v175;
  id v176;
  id v177;
  id v178;
  id v179;
  id v180;
  id v181;
  id v182;
  id v183;
  id v184;
  id v185;
  id v186;
  id v187;
  char *v188;
  char *v189;
  NSObject *log;
  int v191;
  int v192;
  uint8_t buf[4];
  char *v194;
  __int16 v195;
  id v196;
  __int16 v197;
  id v198;
  __int16 v199;
  id v200;
  __int16 v201;
  id v202;
  __int16 v203;
  id v204;
  __int16 v205;
  id v206;
  __int16 v207;
  id v208;
  __int16 v209;
  id v210;
  __int16 v211;
  id v212;
  __int16 v213;
  id v214;
  __int16 v215;
  id v216;
  __int16 v217;
  id v218;
  __int16 v219;
  id v220;
  __int16 v221;
  id v222;
  __int16 v223;
  id v224;
  __int16 v225;
  id v226;
  __int16 v227;
  id v228;
  __int16 v229;
  id v230;
  __int16 v231;
  id v232;
  __int16 v233;
  id v234;
  __int16 v235;
  id v236;
  __int16 v237;
  id v238;
  __int16 v239;
  id v240;
  __int16 v241;
  id v242;
  __int16 v243;
  id v244;
  __int16 v245;
  id v246;
  __int16 v247;
  id v248;
  __int16 v249;
  id v250;
  __int16 v251;
  id v252;
  __int16 v253;
  id v254;
  __int16 v255;
  id v256;
  __int16 v257;
  id v258;
  __int16 v259;
  id v260;
  __int16 v261;
  id v262;
  __int16 v263;
  id v264;
  __int16 v265;
  id v266;
  __int16 v267;
  id v268;
  __int16 v269;
  id v270;
  __int16 v271;
  id v272;
  __int16 v273;
  id v274;
  __int16 v275;
  id v276;
  __int16 v277;
  id v278;
  __int16 v279;
  id v280;
  __int16 v281;
  id v282;
  __int16 v283;
  id v284;
  __int16 v285;
  id v286;
  __int16 v287;
  id v288;
  __int16 v289;
  id v290;
  __int16 v291;
  id v292;
  __int16 v293;
  id v294;
  __int16 v295;
  id v296;
  __int16 v297;
  id v298;
  __int16 v299;
  id v300;
  __int16 v301;
  id v302;
  __int16 v303;
  id v304;
  __int16 v305;
  id v306;
  __int16 v307;
  id v308;
  __int16 v309;
  id v310;
  __int16 v311;
  id v312;
  __int16 v313;
  id v314;
  __int16 v315;
  id v316;
  __int16 v317;
  id v318;
  __int16 v319;
  id v320;
  char v321;
  char v322;
  id v323;
  char v324;
  char v325;
  id v326;
  char v327;
  char v328;
  id v329;
  char v330;
  char v331;
  id v332;
  char v333;
  char v334;
  id v335;
  char v336;
  char v337;
  id v338;
  char v339;
  char v340;
  id v341;
  char v342;
  char v343;
  id v344;
  char v345;
  char v346;
  id v347;

  if (objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info")
    || objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order")
    || (result = (int *)objc_msgSend(a1, "bytes_not_microstackshots")) != 0)
  {
    if (objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info"))
    {
      if (byte_1000EBD38)
      {
        v3 = *__error();
        v4 = (char *)sub_100030318();
        if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_ERROR))
          sub_100090658(a1, v4);
        *__error() = v3;
      }
      if (byte_1000EBD39)
        v5 = dword_1000EB4E8 <= 3;
      else
        v5 = 0;
      if (v5)
      {
        v6 = *__error();
        v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%llu microstackshots dropped due to missing load infos"), objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info"));
        if (v7)
        {
          v8 = v7;
          CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
          if (CStringPtr)
          {
            v10 = (char *)CStringPtr;
            v11 = 0;
          }
          else
          {
            v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xEC2DED5BuLL);
            CFStringGetCString(v8, v10, 1024, 0x8000100u);
            v11 = v10;
          }
          if (qword_1000EBD40)
            v14 = (FILE *)qword_1000EBD40;
          else
            v14 = __stderrp;
          fprintf(v14, "%s\n", v10);
          if (v11)
            free(v11);
          CFRelease(v8);
        }
        else
        {
          v12 = (char *)sub_100030318();
          if (os_log_type_enabled((os_log_t)v12, OS_LOG_TYPE_FAULT))
            sub_1000905E4(a1, v12);
          if (qword_1000EBD40)
            v13 = (FILE *)qword_1000EBD40;
          else
            v13 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v13);
        }
        *__error() = v6;
      }
    }
    if (objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order"))
    {
      if (byte_1000EBD38)
      {
        v15 = *__error();
        v16 = (char *)sub_100030318();
        if (os_log_type_enabled((os_log_t)v16, OS_LOG_TYPE_ERROR))
          sub_100090570(a1, v16);
        *__error() = v15;
      }
      if (byte_1000EBD39)
        v17 = dword_1000EB4E8 <= 3;
      else
        v17 = 0;
      if (v17)
      {
        v18 = *__error();
        v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%llu microstackshots dropped due to being out of order"), objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order"));
        if (v19)
        {
          v20 = v19;
          v21 = CFStringGetCStringPtr(v19, 0x8000100u);
          if (v21)
          {
            v22 = (char *)v21;
            v23 = 0;
          }
          else
          {
            v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x620541CCuLL);
            CFStringGetCString(v20, v22, 1024, 0x8000100u);
            v23 = v22;
          }
          if (qword_1000EBD40)
            v26 = (FILE *)qword_1000EBD40;
          else
            v26 = __stderrp;
          fprintf(v26, "%s\n", v22);
          if (v23)
            free(v23);
          CFRelease(v20);
        }
        else
        {
          v24 = (char *)sub_100030318();
          if (os_log_type_enabled((os_log_t)v24, OS_LOG_TYPE_FAULT))
            sub_1000904FC(a1, v24);
          if (qword_1000EBD40)
            v25 = (FILE *)qword_1000EBD40;
          else
            v25 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
        }
        *__error() = v18;
      }
    }
    result = (int *)objc_msgSend(a1, "bytes_not_microstackshots");
    if (result)
    {
      if (byte_1000EBD38)
      {
        v27 = *__error();
        v28 = sub_100030318();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          sub_100090488(a1, v28);
        result = __error();
        *result = v27;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v29 = *__error();
        v30 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%llu bytes of microstackshot data was invalid (ignored)"), objc_msgSend(a1, "bytes_not_microstackshots"));
        if (v30)
        {
          v31 = v30;
          v32 = CFStringGetCStringPtr(v30, 0x8000100u);
          if (v32)
          {
            v33 = (char *)v32;
            v34 = 0;
          }
          else
          {
            v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x135F7D42uLL);
            CFStringGetCString(v31, v33, 1024, 0x8000100u);
            v34 = v33;
          }
          if (qword_1000EBD40)
            v37 = (FILE *)qword_1000EBD40;
          else
            v37 = __stderrp;
          fprintf(v37, "%s\n", v33);
          if (v34)
            free(v34);
          CFRelease(v31);
        }
        else
        {
          v35 = sub_100030318();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
            sub_100090414(a1, v35);
          if (qword_1000EBD40)
            v36 = (FILE *)qword_1000EBD40;
          else
            v36 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
        }
        result = __error();
        *result = v29;
      }
    }
  }
  if (byte_1000EBD38)
  {
    v38 = *__error();
    v39 = sub_100030318();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_INFO))
    {
      v191 = v38;
      v40 = (char *)objc_msgSend(objc_msgSend(a1, "total"), "bytes");
      log = v39;
      v41 = &v40[(_QWORD)objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate")];
      v42 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
      v43 = &v41[(unint64_t)objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info") + (_QWORD)v42];
      v188 = (char *)objc_msgSend(a1, "bytes_not_microstackshots") + (_QWORD)v43;
      v186 = objc_msgSend(a1, "bytes_not_microstackshots");
      v184 = objc_msgSend(a1, "num_microstackshots_filtered_out");
      v182 = objc_msgSend(objc_msgSend(a1, "total"), "count");
      v180 = objc_msgSend(objc_msgSend(a1, "total"), "bytes");
      v178 = objc_msgSend(objc_msgSend(a1, "total"), "num_load_infos");
      v176 = objc_msgSend(objc_msgSend(a1, "total"), "num_frames");
      v174 = objc_msgSend(objc_msgSend(a1, "total"), "num_duplicate");
      v172 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate");
      v170 = objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order");
      v168 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
      v166 = objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info");
      v164 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info");
      v162 = objc_msgSend(objc_msgSend(a1, "interrupt"), "count");
      v160 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes");
      v158 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_load_infos");
      v156 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_frames");
      v154 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_duplicate");
      v152 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_duplicate");
      v150 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_out_of_order");
      v148 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_out_of_order");
      v146 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_missing_load_info");
      v144 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_missing_load_info");
      v142 = objc_msgSend(objc_msgSend(a1, "timer"), "count");
      v140 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes");
      v138 = objc_msgSend(objc_msgSend(a1, "timer"), "num_load_infos");
      v136 = objc_msgSend(objc_msgSend(a1, "timer"), "num_frames");
      v134 = objc_msgSend(objc_msgSend(a1, "timer"), "num_duplicate");
      v132 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_duplicate");
      v130 = objc_msgSend(objc_msgSend(a1, "timer"), "num_out_of_order");
      v128 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_out_of_order");
      v126 = objc_msgSend(objc_msgSend(a1, "timer"), "num_missing_load_info");
      v124 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_missing_load_info");
      v122 = objc_msgSend(objc_msgSend(a1, "io"), "count");
      v118 = objc_msgSend(objc_msgSend(a1, "io"), "bytes");
      v114 = objc_msgSend(objc_msgSend(a1, "io"), "num_load_infos");
      v108 = objc_msgSend(objc_msgSend(a1, "io"), "num_frames");
      v104 = objc_msgSend(objc_msgSend(a1, "io"), "num_duplicate");
      v100 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_duplicate");
      v96 = objc_msgSend(objc_msgSend(a1, "io"), "num_out_of_order");
      v92 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_out_of_order");
      v88 = objc_msgSend(objc_msgSend(a1, "io"), "num_missing_load_info");
      v84 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_missing_load_info");
      v112 = objc_msgSend(objc_msgSend(a1, "pmi"), "count");
      v120 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes");
      v116 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_load_infos");
      v110 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_frames");
      v106 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_duplicate");
      v102 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_duplicate");
      v98 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_out_of_order");
      v94 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_out_of_order");
      v90 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_missing_load_info");
      v86 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_missing_load_info");
      v82 = objc_msgSend(objc_msgSend(a1, "macf"), "count");
      v80 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes");
      v78 = objc_msgSend(objc_msgSend(a1, "macf"), "num_load_infos");
      v76 = objc_msgSend(objc_msgSend(a1, "macf"), "num_frames");
      v74 = objc_msgSend(objc_msgSend(a1, "macf"), "num_duplicate");
      v72 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_duplicate");
      v70 = objc_msgSend(objc_msgSend(a1, "macf"), "num_out_of_order");
      v69 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_out_of_order");
      v68 = objc_msgSend(objc_msgSend(a1, "macf"), "num_missing_load_info");
      v67 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_missing_load_info");
      v66 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "count");
      v44 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes");
      v45 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_load_infos");
      v46 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_frames");
      v47 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_duplicate");
      v48 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_duplicate");
      v49 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_out_of_order");
      v50 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_out_of_order");
      v51 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_missing_load_info");
      v52 = objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_missing_load_info");
      v194 = v188;
      v196 = v186;
      v198 = v184;
      v200 = v182;
      v202 = v180;
      v204 = v178;
      v206 = v176;
      v208 = v174;
      v210 = v172;
      v212 = v170;
      v214 = v168;
      v216 = v166;
      v218 = v164;
      v220 = v162;
      v222 = v160;
      v224 = v158;
      v226 = v156;
      v228 = v154;
      v230 = v152;
      v232 = v150;
      v234 = v148;
      v236 = v146;
      v238 = v144;
      v240 = v142;
      v242 = v140;
      v244 = v138;
      v246 = v136;
      v248 = v134;
      v250 = v132;
      v252 = v130;
      v254 = v128;
      v256 = v126;
      v258 = v124;
      v260 = v122;
      v262 = v118;
      v264 = v114;
      v266 = v108;
      v268 = v104;
      v270 = v100;
      v272 = v96;
      v274 = v92;
      v276 = v88;
      v278 = v84;
      *(_DWORD *)buf = 134236416;
      v280 = v112;
      v195 = 2048;
      v197 = 2048;
      v199 = 2048;
      v201 = 2048;
      v203 = 2048;
      v205 = 2048;
      v207 = 2048;
      v209 = 2048;
      v211 = 2048;
      v213 = 2048;
      v215 = 2048;
      v217 = 2048;
      v219 = 2048;
      v221 = 2048;
      v223 = 2048;
      v225 = 2048;
      v227 = 2048;
      v229 = 2048;
      v231 = 2048;
      v233 = 2048;
      v235 = 2048;
      v237 = 2048;
      v239 = 2048;
      v241 = 2048;
      v243 = 2048;
      v245 = 2048;
      v247 = 2048;
      v249 = 2048;
      v251 = 2048;
      v253 = 2048;
      v255 = 2048;
      v257 = 2048;
      v259 = 2048;
      v261 = 2048;
      v263 = 2048;
      v265 = 2048;
      v267 = 2048;
      v269 = 2048;
      v271 = 2048;
      v273 = 2048;
      v275 = 2048;
      v277 = 2048;
      v279 = 2048;
      v281 = 2048;
      v282 = v120;
      v283 = 2048;
      v284 = v116;
      v285 = 2048;
      v286 = v110;
      v287 = 2048;
      v288 = v106;
      v289 = 2048;
      v290 = v102;
      v291 = 2048;
      v292 = v98;
      v293 = 2048;
      v294 = v94;
      v295 = 2048;
      v296 = v90;
      v297 = 2048;
      v298 = v86;
      v299 = 2048;
      v300 = v82;
      v301 = 2048;
      v302 = v80;
      v303 = 2048;
      v304 = v78;
      v305 = 2048;
      v306 = v76;
      v307 = 2048;
      v308 = v74;
      v309 = 2048;
      v310 = v72;
      v311 = 2048;
      v312 = v70;
      v313 = 2048;
      v314 = v69;
      v315 = 2048;
      v316 = v68;
      v317 = 2048;
      v318 = v67;
      v319 = 2048;
      v320 = v66;
      v321 = 0;
      v322 = 8;
      v323 = v44;
      v324 = 0;
      v325 = 8;
      v326 = v45;
      v327 = 0;
      v328 = 8;
      v329 = v46;
      v330 = 0;
      v331 = 8;
      v332 = v47;
      v333 = 0;
      v334 = 8;
      v335 = v48;
      v38 = v191;
      v336 = 0;
      v337 = 8;
      v338 = v49;
      v339 = 0;
      v340 = 8;
      v341 = v50;
      v342 = 0;
      v343 = 8;
      v344 = v51;
      v345 = 0;
      v346 = 8;
      v347 = v52;
      _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_INFO, "Microstackshot statistics:\n%llu bytes parsed (%llu bytes invalid)\n%llu filtered out\n\ntotal     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ninterrupt count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "timer     count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "io        count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "pmi       count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "macf      count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)\n"
        "\n"
        "unknown   count          %llu (%llu bytes)\n"
        "          num_load_infos %llu\n"
        "          num_frames     %llu\n"
        "          duplicate      %llu (%llu bytes)\n"
        "          out_of_order   %llu (%llu bytes)\n"
        "          no_load_info   %llu (%llu bytes)",
        buf,
        0x2DCu);
    }
    result = __error();
    *result = v38;
  }
  if (byte_1000EBD39)
    v53 = dword_1000EB4E8 <= 1;
  else
    v53 = 0;
  if (v53)
  {
    v192 = *__error();
    v54 = (char *)objc_msgSend(objc_msgSend(a1, "total"), "bytes");
    v55 = &v54[(_QWORD)objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate")];
    v56 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
    v57 = &v55[(unint64_t)objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info") + (_QWORD)v56];
    v189 = (char *)objc_msgSend(a1, "bytes_not_microstackshots") + (_QWORD)v57;
    v187 = objc_msgSend(a1, "bytes_not_microstackshots");
    v185 = objc_msgSend(a1, "num_microstackshots_filtered_out");
    v183 = objc_msgSend(objc_msgSend(a1, "total"), "count");
    v181 = objc_msgSend(objc_msgSend(a1, "total"), "bytes");
    v179 = objc_msgSend(objc_msgSend(a1, "total"), "num_load_infos");
    v177 = objc_msgSend(objc_msgSend(a1, "total"), "num_frames");
    v175 = objc_msgSend(objc_msgSend(a1, "total"), "num_duplicate");
    v173 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_duplicate");
    v171 = objc_msgSend(objc_msgSend(a1, "total"), "num_out_of_order");
    v169 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_out_of_order");
    v167 = objc_msgSend(objc_msgSend(a1, "total"), "num_missing_load_info");
    v165 = objc_msgSend(objc_msgSend(a1, "total"), "bytes_missing_load_info");
    v163 = objc_msgSend(objc_msgSend(a1, "interrupt"), "count");
    v161 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes");
    v159 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_load_infos");
    v157 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_frames");
    v155 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_duplicate");
    v153 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_duplicate");
    v151 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_out_of_order");
    v149 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_out_of_order");
    v147 = objc_msgSend(objc_msgSend(a1, "interrupt"), "num_missing_load_info");
    v145 = objc_msgSend(objc_msgSend(a1, "interrupt"), "bytes_missing_load_info");
    v143 = objc_msgSend(objc_msgSend(a1, "timer"), "count");
    v141 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes");
    v139 = objc_msgSend(objc_msgSend(a1, "timer"), "num_load_infos");
    v137 = objc_msgSend(objc_msgSend(a1, "timer"), "num_frames");
    v135 = objc_msgSend(objc_msgSend(a1, "timer"), "num_duplicate");
    v133 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_duplicate");
    v131 = objc_msgSend(objc_msgSend(a1, "timer"), "num_out_of_order");
    v129 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_out_of_order");
    v127 = objc_msgSend(objc_msgSend(a1, "timer"), "num_missing_load_info");
    v125 = objc_msgSend(objc_msgSend(a1, "timer"), "bytes_missing_load_info");
    v123 = objc_msgSend(objc_msgSend(a1, "io"), "count");
    v121 = objc_msgSend(objc_msgSend(a1, "io"), "bytes");
    v119 = objc_msgSend(objc_msgSend(a1, "io"), "num_load_infos");
    v117 = objc_msgSend(objc_msgSend(a1, "io"), "num_frames");
    v115 = objc_msgSend(objc_msgSend(a1, "io"), "num_duplicate");
    v113 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_duplicate");
    v111 = objc_msgSend(objc_msgSend(a1, "io"), "num_out_of_order");
    v109 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_out_of_order");
    v107 = objc_msgSend(objc_msgSend(a1, "io"), "num_missing_load_info");
    v105 = objc_msgSend(objc_msgSend(a1, "io"), "bytes_missing_load_info");
    v103 = objc_msgSend(objc_msgSend(a1, "pmi"), "count");
    v101 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes");
    v99 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_load_infos");
    v97 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_frames");
    v95 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_duplicate");
    v93 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_duplicate");
    v91 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_out_of_order");
    v89 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_out_of_order");
    v87 = objc_msgSend(objc_msgSend(a1, "pmi"), "num_missing_load_info");
    v85 = objc_msgSend(objc_msgSend(a1, "pmi"), "bytes_missing_load_info");
    v83 = objc_msgSend(objc_msgSend(a1, "macf"), "count");
    v81 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes");
    v79 = objc_msgSend(objc_msgSend(a1, "macf"), "num_load_infos");
    v77 = objc_msgSend(objc_msgSend(a1, "macf"), "num_frames");
    v75 = objc_msgSend(objc_msgSend(a1, "macf"), "num_duplicate");
    v73 = objc_msgSend(objc_msgSend(a1, "macf"), "bytes_duplicate");
    v71 = objc_msgSend(objc_msgSend(a1, "macf"), "num_out_of_order");
    objc_msgSend(objc_msgSend(a1, "macf"), "bytes_out_of_order");
    objc_msgSend(objc_msgSend(a1, "macf"), "num_missing_load_info");
    objc_msgSend(objc_msgSend(a1, "macf"), "bytes_missing_load_info");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "count");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_load_infos");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_frames");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_duplicate");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_duplicate");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_out_of_order");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_out_of_order");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "num_missing_load_info");
    objc_msgSend(objc_msgSend(a1, "unknown_type"), "bytes_missing_load_info");
    v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Microstackshot statistics:\n%llu bytes parsed (%llu bytes invalid)\n%llu filtered out\n\ntotal     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ninterrupt count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ntimer     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nio        count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\npmi       count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nmacf      count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\nunknown   count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)"), v189, v187, v185, v183, v181, v179, v177, v175, v173, v171, v169, v167, v165, v163, v161, v159,
            v157,
            v155,
            v153,
            v151,
            v149,
            v147,
            v145,
            v143,
            v141,
            v139,
            v137,
            v135,
            v133,
            v131,
            v129,
            v127,
            v125,
            v123,
            v121,
            v119,
            v117,
            v115,
            v113,
            v111,
            v109,
            v107,
            v105,
            v103,
            v101,
            v99,
            v97,
            v95,
            v93,
            v91,
            v89,
            v87,
            v85,
            v83,
            v81,
            v79,
            v77,
            v75,
            v73,
            v71);
    if (v58)
    {
      v59 = v58;
      v60 = CFStringGetCStringPtr(v58, 0x8000100u);
      if (v60)
      {
        v61 = (char *)v60;
        v62 = 0;
      }
      else
      {
        v61 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB326FB3uLL);
        CFStringGetCString(v59, v61, 1024, 0x8000100u);
        v62 = v61;
      }
      if (qword_1000EBD40)
        v65 = (FILE *)qword_1000EBD40;
      else
        v65 = __stderrp;
      fprintf(v65, "%s\n", v61);
      if (v62)
        free(v62);
      CFRelease(v59);
    }
    else
    {
      v63 = sub_100030318();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_FAULT))
        sub_10008FC3C(a1, v63);
      if (qword_1000EBD40)
        v64 = (FILE *)qword_1000EBD40;
      else
        v64 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v64);
    }
    result = __error();
    *result = v192;
  }
  return result;
}

void sub_100059904(uint64_t a1)
{
  dispatch_group_leave((dispatch_group_t)qword_1000EBD98);
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

id sub_10005993C(void *a1, int a2, int a3, int a4)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;

  v8 = (unint64_t)objc_msgSend(a1, "dataGatheringOptions");
  if (a2)
  {
    objc_msgSend(a1, "setDataGatheringOptions:", v8 | 0x60);
    v9 = (unint64_t)objc_msgSend(a1, "dataGatheringOptions");
    if (a3)
      v10 = v9 | 8;
    else
      v10 = v9 & 0xFFFFFFFFFFFFFFF7;
  }
  else
  {
    v10 = v8 & 0xFFFFFFFFFFFFFF97;
  }
  objc_msgSend(a1, "setDataGatheringOptions:", v10);
  v11 = (unint64_t)objc_msgSend(a1, "dataGatheringOptions") & 0xFFFFFFFFFFFFFFEFLL;
  v12 = 16;
  if (!a4)
    v12 = 0;
  return objc_msgSend(a1, "setDataGatheringOptions:", v11 | v12);
}

void sub_1000599CC(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint8_t *a9, void *a10, char a11)
{
  uint8_t *v17;
  char v18;
  NSString *v19;
  id v20;
  uid_t v21;
  int v22;
  FILE *v23;
  int v24;
  NSObject *v25;
  BOOL v26;
  int v27;
  uint8_t *v28;
  uint64_t v29;
  int *v30;
  char *v31;
  const __CFString *v32;
  const __CFString *v33;
  const char *CStringPtr;
  char *v35;
  char *v36;
  NSObject *v37;
  FILE *v38;
  FILE *v39;
  int v40;
  NSObject *v41;
  int v42;
  const __CFString *v43;
  const __CFString *v44;
  const char *v45;
  char *v46;
  char *v47;
  NSObject *v48;
  FILE *v49;
  FILE *v50;
  char *v51;
  uint64_t v52;
  uint8_t *v53;
  int v54;
  int *v55;
  char *v56;
  uint8_t *v57;
  int v58;
  int *v59;
  char *v60;
  FILE *v61;
  int v62;
  NSObject *v63;
  int v64;
  const __CFString *v65;
  NSObject *v66;
  FILE *v67;
  const __CFString *v68;
  const char *v69;
  char *v70;
  char *v71;
  FILE *v72;
  uint8_t buf[8];
  id v75;
  _BYTE v76[12];
  __int16 v77;
  int v78;
  __int16 v79;
  char *v80;
  uint8_t v81[4];
  id v82;

  if (a2)
    objc_msgSend(a1, "setSignature:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a2));
  v17 = a9;
  if (a3)
    objc_msgSend(a1, "setReason:", +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a3));
  objc_msgSend(a1, "setUseDsymForUUIDForEverything:", a6);
  objc_msgSend(a1, "setFindDsymsForIDs:", a4);
  objc_msgSend(a1, "setIncludeBinaryFormatInReport:", a8 ^ 1u);
  objc_msgSend(a1, "setIncludeTextualFormatInReport:", a7 ^ 1u);
  objc_msgSend(a1, "setHeaderOnly:", 0);
  objc_msgSend(a1, "setDsymPaths:", a5);
  v75 = 0;
  if (a9)
  {
    while (1)
    {
      v19 = (NSString *)objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v17);
      v20 = objc_msgSend(a1, "targetProcessId");
      v21 = geteuid();
      v22 = sub_10004EDCC(v19, a10, (uint64_t)v20, 1537, v21, 0x1A4u, &v75);
      if (v19)

      if (v22 != -1)
      {
        v23 = fdopen(v22, "w");
        if (v23)
          break;
      }
      if (byte_1000EBD38)
      {
        v24 = *__error();
        v25 = sub_100030318();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          v53 = v17;
          if (v75)
            v53 = (uint8_t *)objc_msgSend(v75, "UTF8String");
          v54 = *__error();
          v55 = __error();
          v56 = strerror(*v55);
          *(_DWORD *)v76 = 136315650;
          *(_QWORD *)&v76[4] = v53;
          v77 = 1024;
          v78 = v54;
          v79 = 2080;
          v80 = v56;
          _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Spindump failed to save report to %s: %d (%s)", v76, 0x1Cu);
        }
        *__error() = v24;
      }
      if (byte_1000EBD39)
        v26 = dword_1000EB4E8 <= 3;
      else
        v26 = 0;
      if (v26)
      {
        v27 = *__error();
        v28 = v17;
        if (v75)
          v28 = (uint8_t *)objc_msgSend(v75, "UTF8String");
        v29 = *__error();
        v30 = __error();
        v31 = strerror(*v30);
        v32 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Spindump failed to save report to %s: %d (%s)"), v28, v29, v31);
        if (v32)
        {
          v33 = v32;
          CStringPtr = CFStringGetCStringPtr(v32, 0x8000100u);
          if (CStringPtr)
          {
            v35 = (char *)CStringPtr;
            v36 = 0;
          }
          else
          {
            v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD0108B9BuLL);
            CFStringGetCString(v33, v35, 1024, 0x8000100u);
            v36 = v35;
          }
          if (qword_1000EBD40)
            v39 = (FILE *)qword_1000EBD40;
          else
            v39 = __stderrp;
          fprintf(v39, "%s\n", v35);
          if (v36)
            free(v36);
          CFRelease(v33);
        }
        else
        {
          v37 = sub_100030318();
          if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
          {
            v57 = v17;
            if (v75)
              v57 = (uint8_t *)objc_msgSend(v75, "UTF8String");
            v58 = *__error();
            v59 = __error();
            v60 = strerror(*v59);
            *(_DWORD *)v76 = 136315650;
            *(_QWORD *)&v76[4] = v57;
            v77 = 1024;
            v78 = v58;
            v79 = 2080;
            v80 = v60;
            _os_log_fault_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "Unable to format: Spindump failed to save report to %s: %d (%s)", v76, 0x1Cu);
          }
          if (qword_1000EBD40)
            v38 = (FILE *)qword_1000EBD40;
          else
            v38 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
        }
        *__error() = v27;
      }

      v75 = 0;
      if (v22 != -1)
        close(v22);
      *(_QWORD *)v76 = 0;
      if (byte_1000EBD38)
      {
        v40 = *__error();
        v41 = sub_100030318();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Please enter a new output location (or an empty line to output to stdout, including spindump binary format)", buf, 2u);
        }
        *__error() = v40;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v42 = *__error();
        v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Please enter a new output location (or an empty line to output to stdout, including spindump binary format)"));
        if (v43)
        {
          v44 = v43;
          v45 = CFStringGetCStringPtr(v43, 0x8000100u);
          if (v45)
          {
            v46 = (char *)v45;
            v47 = 0;
          }
          else
          {
            v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8C6F58D1uLL);
            CFStringGetCString(v44, v46, 1024, 0x8000100u);
            v47 = v46;
          }
          if (qword_1000EBD40)
            v50 = (FILE *)qword_1000EBD40;
          else
            v50 = __stderrp;
          fprintf(v50, "%s\n", v46);
          if (v47)
            free(v47);
          CFRelease(v44);
        }
        else
        {
          v48 = sub_100030318();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
          {
            *(_WORD *)buf = 0;
            _os_log_fault_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_FAULT, "Unable to format: Please enter a new output location (or an empty line to output to stdout, including spindump binary format)", buf, 2u);
          }
          if (qword_1000EBD40)
            v49 = (FILE *)qword_1000EBD40;
          else
            v49 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v49);
        }
        *__error() = v42;
      }
      v51 = fgetln(__stdinp, (size_t *)v76);
      v52 = *(_QWORD *)v76;
      if (!*(_QWORD *)v76)
        goto LABEL_8;
      if (v51[*(_QWORD *)v76 - 1] == 10)
      {
        v51[*(_QWORD *)v76 - 1] = 0;
        v52 = --*(_QWORD *)v76;
      }
      if ((unint64_t)(v52 - 1) >= 0x3FF)
        goto LABEL_8;
      v17 = v81;
      __memcpy_chk(v81, v51, v52, 1024);
      v81[v52] = 0;
    }
    v61 = v23;
    objc_msgSend(a1, "saveReportToStream:", v23);
    fclose(v61);
    if (byte_1000EBD38)
    {
      v62 = *__error();
      v63 = sub_100030318();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v81 = 138412290;
        v82 = v75;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Spindump analysis written to file %@", v81, 0xCu);
      }
      *__error() = v62;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
    {
      v64 = *__error();
      v65 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Spindump analysis written to file %@"), v75);
      if (v65)
      {
        v68 = v65;
        v69 = CFStringGetCStringPtr(v65, 0x8000100u);
        if (v69)
        {
          v70 = (char *)v69;
          v71 = 0;
        }
        else
        {
          v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD8E4F539uLL);
          CFStringGetCString(v68, v70, 1024, 0x8000100u);
          v71 = v70;
        }
        if (qword_1000EBD40)
          v72 = (FILE *)qword_1000EBD40;
        else
          v72 = __stderrp;
        fprintf(v72, "%s\n", v70);
        if (v71)
          free(v71);
        CFRelease(v68);
      }
      else
      {
        v66 = sub_100030318();
        if (os_log_type_enabled(v66, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)v81 = 138412290;
          v82 = v75;
          _os_log_fault_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_FAULT, "Unable to format: Spindump analysis written to file %@", v81, 0xCu);
        }
        if (qword_1000EBD40)
          v67 = (FILE *)qword_1000EBD40;
        else
          v67 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v67);
      }
      *__error() = v64;
      if ((a11 & 1) == 0)
        goto LABEL_106;
    }
    else if (!a11)
    {
      goto LABEL_106;
    }
    objc_msgSend(a1, "setIncludeBinaryFormatInReport:", 0);
    v18 = 0;
  }
  else
  {
    if ((a11 & 1) == 0)
      goto LABEL_107;
    v17 = 0;
LABEL_8:
    v18 = 1;
  }
  objc_msgSend(a1, "saveReportToStream:", __stdoutp);
  if (objc_msgSend(a1, "includeBinaryFormatInReport"))
    putchar(10);
  if ((v18 & 1) != 0)
  {

    if (v17)
      exit(69);
LABEL_107:
    exit(0);
  }
LABEL_106:

  goto LABEL_107;
}

void sub_10005A25C(id a1)
{
  int v1;
  NSObject *v2;
  BOOL v3;
  int v4;
  const __CFString *v5;
  NSObject *v6;
  FILE *v7;
  const __CFString *v8;
  const char *CStringPtr;
  char *v10;
  char *v11;
  FILE *v12;
  uint8_t v13[16];
  uint8_t buf[16];

  if (byte_1000EBD38)
  {
    v1 = *__error();
    v2 = sub_100030318();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Timed out, exiting", buf, 2u);
    }
    *__error() = v1;
  }
  if (byte_1000EBD39)
    v3 = dword_1000EB4E8 <= 2;
  else
    v3 = 0;
  if (v3)
  {
    v4 = *__error();
    v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Timed out, exiting"));
    if (v5)
    {
      v8 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        v10 = (char *)CStringPtr;
        v11 = 0;
      }
      else
      {
        v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA9DE7514uLL);
        CFStringGetCString(v8, v10, 1024, 0x8000100u);
        v11 = v10;
      }
      if (qword_1000EBD40)
        v12 = (FILE *)qword_1000EBD40;
      else
        v12 = __stderrp;
      fprintf(v12, "%s\n", v10);
      if (v11)
        free(v11);
      CFRelease(v8);
    }
    else
    {
      v6 = sub_100030318();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v13 = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "Unable to format: Timed out, exiting", v13, 2u);
      }
      if (qword_1000EBD40)
        v7 = (FILE *)qword_1000EBD40;
      else
        v7 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v7);
    }
    *__error() = v4;
  }
  exit(75);
}

id sub_10005A434(uint64_t a1, void *a2)
{
  NSString *v4;
  NSString *v5;
  NSString *v6;
  id v7;
  int v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  int v14;
  const __CFString *v15;
  const __CFString *v16;
  const char *v17;
  char *v18;
  char *v19;
  int v20;
  NSObject *v21;
  int v22;
  uint64_t v23;
  int *v24;
  char *v25;
  const __CFString *v26;
  const __CFString *v27;
  const char *CStringPtr;
  char *v29;
  char *v30;
  NSObject *v31;
  FILE *v32;
  FILE *v33;
  int v34;
  dispatch_time_t v35;
  id v36;
  uint64_t i;
  void *v38;
  int v39;
  int v40;
  double v41;
  NSString *v42;
  int v43;
  double v44;
  unsigned int v45;
  NSObject *v46;
  int v47;
  const __CFString *v48;
  const __CFString *v49;
  const char *v50;
  char *v51;
  NSString *v52;
  NSObject *v53;
  _DWORD *v54;
  uint64_t v55;
  int *v56;
  char *v57;
  const __CFString *v58;
  NSObject *v59;
  int *v60;
  char *v61;
  NSObject *v62;
  const char *v63;
  uint32_t v64;
  NSObject *v65;
  uint64_t v66;
  int *v67;
  char *v68;
  const char *v69;
  char *v70;
  NSObject *v71;
  FILE *v72;
  FILE *v73;
  NSObject *v74;
  id v75;
  FILE *v76;
  NSObject *v77;
  FILE *v78;
  uint64_t v79;
  int *v80;
  int v81;
  double v82;
  unsigned int v83;
  int v84;
  NSObject *v85;
  int v86;
  const __CFString *v87;
  const __CFString *v88;
  const char *v89;
  char *v90;
  char *v91;
  NSObject *v92;
  _DWORD *v93;
  uint64_t v94;
  int *v95;
  char *v96;
  const __CFString *v97;
  NSObject *v98;
  int *v99;
  char *v100;
  NSObject *v101;
  const char *v102;
  uint32_t v103;
  unsigned int v104;
  NSObject *v105;
  uint64_t v106;
  int *v107;
  char *v108;
  const char *v109;
  char *v110;
  NSObject *v111;
  FILE *v112;
  FILE *v113;
  id v114;
  int *v115;
  char *v116;
  unsigned int v117;
  FILE *v118;
  int *v119;
  char *v120;
  NSObject *v121;
  FILE *v122;
  uint64_t v123;
  int *v124;
  unsigned int v125;
  int *v126;
  char *v127;
  int *v128;
  char *v129;
  unsigned int v130;
  int *v131;
  char *v132;
  int *v133;
  char *v134;
  int v135;
  NSObject *v136;
  BOOL v137;
  int v138;
  const __CFString *v139;
  const __CFString *v140;
  const char *v141;
  char *v142;
  char *v143;
  int v144;
  NSObject *v145;
  BOOL v146;
  int v147;
  const __CFString *v148;
  const __CFString *v149;
  const char *v150;
  char *v151;
  char *v152;
  NSObject *v153;
  FILE *v154;
  NSObject *v155;
  FILE *v156;
  FILE *v157;
  NSObject *v158;
  FILE *v159;
  FILE *v160;
  uint64_t v161;
  int *v162;
  FILE *v163;
  uint64_t v165;
  uint64_t v166;
  char *v167;
  int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  void *v173;
  _DWORD *v174;
  char *v175;
  int v176;
  void *v177;
  _DWORD *v178;
  char *v179;
  _DWORD *v180;
  _DWORD *v181;
  int cf;
  const __CFString *cfa;
  CFTypeRef cff;
  unsigned int cfg;
  const __CFString *cfb;
  const __CFString *cfc;
  CFTypeRef cfj;
  unsigned int cfk;
  const __CFString *cfd;
  unsigned int cfe;
  int cfh;
  CFTypeRef cfm;
  int cfn;
  unsigned int cfi;
  int cfl;
  int cfo;
  unsigned int v198;
  int v199;
  int v200;
  int v201;
  uint64_t v202;
  unsigned int v203;
  int v204;
  int v205;
  int v206;
  id v207;
  void *v208;
  NSObject *object;
  dispatch_time_t timeout;
  NSObject *dsema;
  _QWORD v212[8];
  int v213;
  int v214;
  int v215;
  _QWORD v216[8];
  int v217;
  int v218;
  int v219;
  _QWORD v220[3];
  uint8_t v221[4];
  _BYTE v222[14];
  __int16 v223;
  int v224;
  __int16 v225;
  char *v226;
  _QWORD v227[5];
  char __str[8];
  uint8_t buf[4];
  int v230;

  objc_msgSend(a2, "setEvent:", CFSTR("shutdown stall"));
  objc_msgSend(a2, "setEventNote:", 0);
  v4 = *(NSString **)(a1 + 32);
  if (v4)
    v4 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  objc_msgSend(a2, "setSignature:", v4);
  v5 = *(NSString **)(a1 + 40);
  if (v5)
    v5 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
  objc_msgSend(a2, "setReason:", v5);
  if (*(_DWORD *)(a1 + 56))
    v6 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("sampling started after %d seconds"), *(unsigned int *)(a1 + 56));
  else
    v6 = 0;
  objc_msgSend(a2, "setDurationNote:", v6);
  objc_msgSend(a2, "setExtraDuration:", (double)*(int *)(a1 + 56));
  objc_msgSend(a2, "setStepsNote:", 0);
  objc_msgSend(a2, "setSanitizePaths:", 0);
  objc_msgSend(a2, "setOmitThirdPartyProcessStacks:", 0);
  objc_msgSend(a2, "setIncludeBinaryFormatInReport:", 1);
  objc_msgSend(a2, "setIncludeTextualFormatInReport:", 0);
  v7 = objc_alloc_init((Class)NSMutableString);
  v8 = sub_10002E9F4();
  v9 = (unsigned int *)malloc_type_calloc(v8, 4uLL, 0x100004052888210uLL);
  v10 = proc_listallpids(v9, 4 * v8);
  if ((_DWORD)v10 == -1)
  {
    if (byte_1000EBD38)
    {
      v20 = *__error();
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_10009073C();
      *__error() = v20;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v22 = *__error();
      v23 = *__error();
      v24 = __error();
      v25 = strerror(*v24);
      v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to get pid list: %d (%s)"), v23, v25);
      if (v26)
      {
        v27 = v26;
        CStringPtr = CFStringGetCStringPtr(v26, 0x8000100u);
        if (CStringPtr)
        {
          v29 = (char *)CStringPtr;
          v30 = 0;
        }
        else
        {
          v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3970AD45uLL);
          CFStringGetCString(v27, v29, 1024, 0x8000100u);
          v30 = v29;
        }
        if (qword_1000EBD40)
          v160 = (FILE *)qword_1000EBD40;
        else
          v160 = __stderrp;
        fprintf(v160, "%s\n", v29);
        if (v30)
          free(v30);
        CFRelease(v27);
      }
      else
      {
        v155 = sub_100030318();
        if (os_log_type_enabled(v155, OS_LOG_TYPE_FAULT))
          sub_1000906CC();
        if (qword_1000EBD40)
          v156 = (FILE *)qword_1000EBD40;
        else
          v156 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v156);
      }
      *__error() = v22;
    }
    v161 = *__error();
    v162 = __error();
    objc_msgSend(v7, "appendFormat:", CFSTR("Unable to get pid list for heap/ddt: %d %s\n"), v161, strerror(*v162));
  }
  else
  {
    v11 = v10;
    if (byte_1000EBD38)
    {
      v12 = *__error();
      v13 = sub_100030318();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 67109120;
        v230 = v11;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Running heap/ddt for all (%d) processes", buf, 8u);
      }
      *__error() = v12;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
    {
      v14 = *__error();
      v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Running heap/ddt for all (%d) processes"), v11);
      if (v15)
      {
        v16 = v15;
        v17 = CFStringGetCStringPtr(v15, 0x8000100u);
        if (v17)
        {
          v18 = (char *)v17;
          v19 = 0;
        }
        else
        {
          v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDD07B922uLL);
          CFStringGetCString(v16, v18, 1024, 0x8000100u);
          v19 = v18;
        }
        if (qword_1000EBD40)
          v33 = (FILE *)qword_1000EBD40;
        else
          v33 = __stderrp;
        fprintf(v33, "%s\n", v18);
        if (v19)
          free(v19);
        CFRelease(v16);
      }
      else
      {
        v31 = sub_100030318();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
          sub_1000908D8();
        if (qword_1000EBD40)
          v32 = (FILE *)qword_1000EBD40;
        else
          v32 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
      }
      *__error() = v14;
    }
    qsort_b(v9, (int)v11, 4uLL, &stru_1000DD668);
    dsema = dispatch_semaphore_create(8);
    object = dispatch_group_create();
    v34 = *(_DWORD *)(a1 + 60);
    if (v34)
    {
      v35 = *(_QWORD *)(a1 + 48);
      if (v34 >= 11)
        v35 = dispatch_time(v35, 1000000000 * (v34 - 10));
      timeout = v35;
    }
    else
    {
      timeout = -1;
    }
    v36 = objc_msgSend(objc_alloc((Class)NSMutableArray), "initWithCapacity:", 2 * (int)v11);
    if ((int)v11 >= 1)
    {
      for (i = 0; v11 != i; ++i)
      {
        v38 = objc_autoreleasePoolPush();
        v39 = v9[i];
        if (v39 < 2 || v39 == getpid())
          goto LABEL_61;
        v40 = *(_DWORD *)(a1 + 60);
        if (v40)
        {
          v41 = *(double *)&qword_1000EBD30 + (double)v40;
          if (v41 - CFAbsoluteTimeGetCurrent() < 10.0)
            goto LABEL_59;
        }
        if (sub_100025F88(v9[i]))
        {
          bzero(buf, 0x400uLL);
          if (proc_pidpath(v9[i], buf, 0x400u) < 1
            || !strnstr((const char *)buf, "dext", 0x400uLL)
            && !strnstr((const char *)buf, "/DriverExtensions/", 0x400uLL))
          {
            if (!dispatch_semaphore_wait(dsema, timeout))
            {
              v43 = *(_DWORD *)(a1 + 60);
              if (v43)
              {
                v44 = *(double *)&qword_1000EBD30 + (double)v43;
                if (v44 - CFAbsoluteTimeGetCurrent() < 10.0)
                {
                  v52 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("\nOut of time, skipping heap/ddt for %d\n"), v9[i], v165, v166);
                  goto LABEL_78;
                }
              }
              if (!sub_100025F88(v9[i]))
              {
                v52 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[%d] has exited, cannot take heap/ddt\n"), v9[i], v165, v166);
                goto LABEL_78;
              }
              snprintf(__str, 8uLL, "%d", v9[i]);
              v227[0] = "/usr/bin/heap";
              v227[1] = "--addresses=.*transaction.*";
              v227[2] = "--forkCorpseRetryTime=0";
              v227[3] = __str;
              v227[4] = 0;
              v219 = -1;
              v218 = -1;
              LOBYTE(v165) = 0;
              v45 = SASpawnPlatformBinaryWithSigningIdentifier("/usr/bin/heap", "com.apple.dt.SamplingTools.heap", v227, 0, 0, 0, &v219, 0, &v218, v165, 0);
              v207 = v7;
              v208 = v36;
              if ((v45 & 0x80000000) == 0)
              {
                v198 = v45;
                if (byte_1000EBD38)
                {
                  cf = *__error();
                  v46 = sub_100030318();
                  if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
                  {
                    v104 = v9[i];
                    *(_DWORD *)v221 = 136315394;
                    *(_QWORD *)v222 = buf;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = v104;
                    _os_log_debug_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEBUG, "Running heap for %s [%d]", v221, 0x12u);
                  }
                  *__error() = cf;
                }
                if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
                {
                  v47 = *__error();
                  v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Running heap for %s [%d]"), buf, v9[i]);
                  if (v48)
                  {
                    v172 = v47;
                    v49 = v48;
                    v50 = CFStringGetCStringPtr(v48, 0x8000100u);
                    cfa = v49;
                    if (v50)
                    {
                      v51 = (char *)v50;
                      v167 = 0;
                    }
                    else
                    {
                      v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF4632515uLL);
                      CFStringGetCString(v49, v51, 1024, 0x8000100u);
                      v167 = v51;
                    }
                    if (qword_1000EBD40)
                      v73 = (FILE *)qword_1000EBD40;
                    else
                      v73 = __stderrp;
                    fprintf(v73, "%s\n", v51);
                    v47 = v172;
                    if (v167)
                      free(v167);
                    CFRelease(cfa);
                  }
                  else
                  {
                    v71 = sub_100030318();
                    if (os_log_type_enabled(v71, OS_LOG_TYPE_FAULT))
                    {
                      v117 = v9[i];
                      *(_DWORD *)v221 = 136315394;
                      *(_QWORD *)v222 = buf;
                      *(_WORD *)&v222[8] = 1024;
                      *(_DWORD *)&v222[10] = v117;
                      _os_log_fault_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_FAULT, "Unable to format: Running heap for %s [%d]", v221, 0x12u);
                    }
                    if (qword_1000EBD40)
                      v72 = (FILE *)qword_1000EBD40;
                    else
                      v72 = __stderrp;
                    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v72);
                  }
                  *__error() = v47;
                }
                dispatch_retain(object);
                v74 = dsema;
                dispatch_retain(dsema);
                dispatch_group_enter(object);
                v75 = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithFormat:", CFSTR("\nheap --addresses=.*transaction.* --forkCorpseRetryTime=0 %d\n"), v9[i]);
                objc_msgSend(v208, "addObject:", v75);
                v216[0] = _NSConcreteStackBlock;
                v216[1] = 3221225472;
                v216[2] = sub_10005C21C;
                v216[3] = &unk_1000DD690;
                v217 = i;
                v216[4] = v75;
                v216[5] = dsema;
                v216[6] = object;
                v216[7] = v9;
                sub_10005BF9C(v198, v219, v218, (uint64_t)v75, (uint64_t)v216);
LABEL_127:
                if (dispatch_semaphore_wait(v74, timeout))
                {
                  v36 = v208;
                  objc_msgSend(v208, "addObject:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("\nOut of time, skipping ddt for %d\n"), v9[i]));
LABEL_129:
                  v7 = v207;
                  goto LABEL_61;
                }
                v81 = *(_DWORD *)(a1 + 60);
                v7 = v207;
                v36 = v208;
                if (v81 && (v82 = *(double *)&qword_1000EBD30 + (double)v81, v82 - CFAbsoluteTimeGetCurrent() < 10.0))
                {
                  v52 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("\nOut of time, skipping ddt for %d\n"), v9[i], v165, v166);
                }
                else if (sub_100025F88(v9[i]))
                {
                  v220[0] = "/usr/local/bin/ddt";
                  v220[1] = __str;
                  v220[2] = 0;
                  v215 = -1;
                  v214 = -1;
                  LOBYTE(v165) = 0;
                  v83 = SASpawnPlatformBinaryWithSigningIdentifier("/usr/local/bin/ddt", "com.apple.ddt", v220, 0, 0, 0, &v215, 0, &v214, v165, 0);
                  if ((v83 & 0x80000000) == 0)
                  {
                    v203 = v83;
                    if (byte_1000EBD38)
                    {
                      v84 = *__error();
                      v85 = sub_100030318();
                      if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
                      {
                        v125 = v9[i];
                        *(_DWORD *)v221 = 136315394;
                        *(_QWORD *)v222 = buf;
                        *(_WORD *)&v222[8] = 1024;
                        *(_DWORD *)&v222[10] = v125;
                        _os_log_debug_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEBUG, "Running ddt for %s [%d]", v221, 0x12u);
                      }
                      *__error() = v84;
                    }
                    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
                    {
                      v86 = *__error();
                      v87 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Running ddt for %s [%d]"), buf, v9[i]);
                      if (v87)
                      {
                        v176 = v86;
                        v88 = v87;
                        v89 = CFStringGetCStringPtr(v87, 0x8000100u);
                        cfc = v88;
                        if (v89)
                        {
                          v90 = (char *)v89;
                          v91 = 0;
                        }
                        else
                        {
                          v90 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE9AFAE9AuLL);
                          CFStringGetCString(v88, v90, 1024, 0x8000100u);
                          v91 = v90;
                        }
                        if (qword_1000EBD40)
                          v113 = (FILE *)qword_1000EBD40;
                        else
                          v113 = __stderrp;
                        fprintf(v113, "%s\n", v90);
                        v86 = v176;
                        if (v91)
                          free(v91);
                        CFRelease(cfc);
                      }
                      else
                      {
                        v111 = sub_100030318();
                        if (os_log_type_enabled(v111, OS_LOG_TYPE_FAULT))
                        {
                          v130 = v9[i];
                          *(_DWORD *)v221 = 136315394;
                          *(_QWORD *)v222 = buf;
                          *(_WORD *)&v222[8] = 1024;
                          *(_DWORD *)&v222[10] = v130;
                          _os_log_fault_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_FAULT, "Unable to format: Running ddt for %s [%d]", v221, 0x12u);
                        }
                        if (qword_1000EBD40)
                          v112 = (FILE *)qword_1000EBD40;
                        else
                          v112 = __stderrp;
                        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v112);
                      }
                      *__error() = v86;
                    }
                    dispatch_retain(object);
                    dispatch_retain(dsema);
                    dispatch_group_enter(object);
                    v114 = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithFormat:", CFSTR("\nddt %d\n"), v9[i]);
                    v36 = v208;
                    objc_msgSend(v208, "addObject:", v114);
                    v212[0] = _NSConcreteStackBlock;
                    v212[1] = 3221225472;
                    v212[2] = sub_10005C6C0;
                    v212[3] = &unk_1000DD690;
                    v213 = i;
                    v212[4] = v114;
                    v212[5] = dsema;
                    v212[6] = object;
                    v212[7] = v9;
                    sub_10005BF9C(v203, v215, v214, (uint64_t)v114, (uint64_t)v212);
                    goto LABEL_129;
                  }
                  if ((v9[i] & 0x80000000) != 0)
                  {
                    if (byte_1000EBD38)
                    {
                      v206 = *__error();
                      v105 = sub_100030318();
                      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                      {
                        cfl = *__error();
                        v131 = __error();
                        v132 = strerror(*v131);
                        *(_DWORD *)v221 = 67109378;
                        *(_DWORD *)v222 = cfl;
                        *(_WORD *)&v222[4] = 2080;
                        *(_QWORD *)&v222[6] = v132;
                        _os_log_error_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "Unable to spawn ddt: %d (%s)", v221, 0x12u);
                      }
                      *__error() = v206;
                    }
                    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                    {
                      v205 = *__error();
                      v106 = *__error();
                      v107 = __error();
                      v108 = strerror(*v107);
                      v97 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to spawn ddt: %d (%s)"), v106, v108);
                      if (v97)
                        goto LABEL_162;
                      v121 = sub_100030318();
                      if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
                      {
                        cfo = *__error();
                        v133 = __error();
                        v134 = strerror(*v133);
                        *(_DWORD *)v221 = 67109378;
                        *(_DWORD *)v222 = cfo;
                        *(_WORD *)&v222[4] = 2080;
                        *(_QWORD *)&v222[6] = v134;
                        v101 = v121;
                        v102 = "Unable to format: Unable to spawn ddt: %d (%s)";
                        v103 = 18;
LABEL_196:
                        _os_log_fault_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_FAULT, v102, v221, v103);
                      }
LABEL_187:
                      if (qword_1000EBD40)
                        v122 = (FILE *)qword_1000EBD40;
                      else
                        v122 = __stderrp;
                      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v122);
LABEL_191:
                      *__error() = v205;
                    }
                  }
                  else
                  {
                    if (byte_1000EBD38)
                    {
                      v204 = *__error();
                      v92 = sub_100030318();
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                      {
                        v181 = sub_1000302B4(v9[i]);
                        cfi = v9[i];
                        v171 = *__error();
                        v128 = __error();
                        v129 = strerror(*v128);
                        *(_DWORD *)v221 = 136446978;
                        *(_QWORD *)v222 = v181;
                        *(_WORD *)&v222[8] = 1024;
                        *(_DWORD *)&v222[10] = cfi;
                        v223 = 1024;
                        v224 = v171;
                        v225 = 2080;
                        v226 = v129;
                        _os_log_error_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to spawn ddt: %d (%s)", v221, 0x22u);
                      }
                      *__error() = v204;
                    }
                    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                    {
                      v205 = *__error();
                      v93 = sub_1000302B4(v9[i]);
                      v177 = (void *)v9[i];
                      cfj = v93;
                      v94 = *__error();
                      v95 = __error();
                      v96 = strerror(*v95);
                      v97 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to spawn ddt: %d (%s)"), cfj, v177, v94, v96);
                      if (!v97)
                      {
                        v98 = sub_100030318();
                        if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT))
                        {
                          v178 = sub_1000302B4(v9[i]);
                          cfk = v9[i];
                          v169 = *__error();
                          v99 = __error();
                          v100 = strerror(*v99);
                          *(_DWORD *)v221 = 136315906;
                          *(_QWORD *)v222 = v178;
                          *(_WORD *)&v222[8] = 1024;
                          *(_DWORD *)&v222[10] = cfk;
                          v223 = 1024;
                          v224 = v169;
                          v225 = 2080;
                          v226 = v100;
                          v101 = v98;
                          v102 = "Unable to format: %s [%d]: Unable to spawn ddt: %d (%s)";
                          v103 = 34;
                          goto LABEL_196;
                        }
                        goto LABEL_187;
                      }
LABEL_162:
                      cfd = v97;
                      v109 = CFStringGetCStringPtr(v97, 0x8000100u);
                      if (v109)
                      {
                        v110 = (char *)v109;
                        v179 = 0;
                      }
                      else
                      {
                        v110 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x763578B6uLL);
                        CFStringGetCString(cfd, v110, 1024, 0x8000100u);
                        v179 = v110;
                      }
                      if (qword_1000EBD40)
                        v118 = (FILE *)qword_1000EBD40;
                      else
                        v118 = __stderrp;
                      fprintf(v118, "%s\n", v110);
                      if (v179)
                        free(v179);
                      CFRelease(cfd);
                      goto LABEL_191;
                    }
                  }
                  cfm = (CFTypeRef)v9[i];
                  v123 = *__error();
                  v124 = __error();
                  v52 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Unable to spawn ddt for %d: %d %s\n"), cfm, v123, strerror(*v124));
                }
                else
                {
                  v52 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[%d] has exited, cannot take ddt\n"), v9[i], v165, v166);
                }
LABEL_78:
                objc_msgSend(v36, "addObject:", v52);
                dispatch_semaphore_signal(dsema);
                goto LABEL_61;
              }
              if ((v9[i] & 0x80000000) != 0)
              {
                if (byte_1000EBD38)
                {
                  v201 = *__error();
                  v65 = sub_100030318();
                  if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
                  {
                    cfh = *__error();
                    v119 = __error();
                    v120 = strerror(*v119);
                    *(_DWORD *)v221 = 67109378;
                    *(_DWORD *)v222 = cfh;
                    *(_WORD *)&v222[4] = 2080;
                    *(_QWORD *)&v222[6] = v120;
                    _os_log_error_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "Unable to spawn heap: %d (%s)", v221, 0x12u);
                  }
                  *__error() = v201;
                }
                if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                {
                  v200 = *__error();
                  v66 = *__error();
                  v67 = __error();
                  v68 = strerror(*v67);
                  v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to spawn heap: %d (%s)"), v66, v68);
                  if (v58)
                    goto LABEL_96;
                  v77 = sub_100030318();
                  if (os_log_type_enabled(v77, OS_LOG_TYPE_FAULT))
                  {
                    cfn = *__error();
                    v126 = __error();
                    v127 = strerror(*v126);
                    *(_DWORD *)v221 = 67109378;
                    *(_DWORD *)v222 = cfn;
                    *(_WORD *)&v222[4] = 2080;
                    *(_QWORD *)&v222[6] = v127;
                    v62 = v77;
                    v63 = "Unable to format: Unable to spawn heap: %d (%s)";
                    v64 = 18;
LABEL_194:
                    _os_log_fault_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_FAULT, v63, v221, v64);
                  }
LABEL_121:
                  if (qword_1000EBD40)
                    v78 = (FILE *)qword_1000EBD40;
                  else
                    v78 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v78);
LABEL_125:
                  *__error() = v200;
                }
              }
              else
              {
                if (byte_1000EBD38)
                {
                  v199 = *__error();
                  v53 = sub_100030318();
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                  {
                    v180 = sub_1000302B4(v9[i]);
                    cfe = v9[i];
                    v170 = *__error();
                    v115 = __error();
                    v116 = strerror(*v115);
                    *(_DWORD *)v221 = 136446978;
                    *(_QWORD *)v222 = v180;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = cfe;
                    v223 = 1024;
                    v224 = v170;
                    v225 = 2080;
                    v226 = v116;
                    _os_log_error_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to spawn heap: %d (%s)", v221, 0x22u);
                  }
                  *__error() = v199;
                }
                if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
                {
                  v200 = *__error();
                  v54 = sub_1000302B4(v9[i]);
                  v173 = (void *)v9[i];
                  cff = v54;
                  v55 = *__error();
                  v56 = __error();
                  v57 = strerror(*v56);
                  v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to spawn heap: %d (%s)"), cff, v173, v55, v57);
                  if (!v58)
                  {
                    v59 = sub_100030318();
                    if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
                    {
                      v174 = sub_1000302B4(v9[i]);
                      cfg = v9[i];
                      v168 = *__error();
                      v60 = __error();
                      v61 = strerror(*v60);
                      *(_DWORD *)v221 = 136315906;
                      *(_QWORD *)v222 = v174;
                      *(_WORD *)&v222[8] = 1024;
                      *(_DWORD *)&v222[10] = cfg;
                      v223 = 1024;
                      v224 = v168;
                      v225 = 2080;
                      v226 = v61;
                      v62 = v59;
                      v63 = "Unable to format: %s [%d]: Unable to spawn heap: %d (%s)";
                      v64 = 34;
                      goto LABEL_194;
                    }
                    goto LABEL_121;
                  }
LABEL_96:
                  cfb = v58;
                  v69 = CFStringGetCStringPtr(v58, 0x8000100u);
                  if (v69)
                  {
                    v70 = (char *)v69;
                    v175 = 0;
                  }
                  else
                  {
                    v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD2AA5B1CuLL);
                    CFStringGetCString(cfb, v70, 1024, 0x8000100u);
                    v175 = v70;
                  }
                  if (qword_1000EBD40)
                    v76 = (FILE *)qword_1000EBD40;
                  else
                    v76 = __stderrp;
                  fprintf(v76, "%s\n", v70);
                  if (v175)
                    free(v175);
                  CFRelease(cfb);
                  goto LABEL_125;
                }
              }
              v202 = v9[i];
              v79 = *__error();
              v80 = __error();
              objc_msgSend(v36, "addObject:", +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Unable to spawn heap for %d: %d %s\n"), v202, v79, strerror(*v80)));
              v74 = dsema;
              dispatch_semaphore_signal(dsema);
              goto LABEL_127;
            }
LABEL_59:
            v42 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("\nOut of time, skipping heap/ddt for %d\n"), v9[i]);
            goto LABEL_60;
          }
          v42 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[%d] is DriverKit, skipping heap/ddt\n"), v9[i]);
        }
        else
        {
          v42 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("[%d] has exited, cannot take heap/ddt\n"), v9[i]);
        }
LABEL_60:
        objc_msgSend(v36, "addObject:", v42);
LABEL_61:
        objc_autoreleasePoolPop(v38);
      }
    }
    if (dispatch_group_wait(object, timeout))
    {
      if (byte_1000EBD38)
      {
        v135 = *__error();
        v136 = sub_100030318();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
          sub_100090874();
        *__error() = v135;
      }
      if (byte_1000EBD39)
        v137 = dword_1000EB4E8 <= 3;
      else
        v137 = 0;
      if (v137)
      {
        v138 = *__error();
        v139 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Timed out running heap/ddt for all (%d) processes"), v11);
        if (v139)
        {
          v140 = v139;
          v141 = CFStringGetCStringPtr(v139, 0x8000100u);
          if (v141)
          {
            v142 = (char *)v141;
            v143 = 0;
          }
          else
          {
            v142 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x58E719CFuLL);
            CFStringGetCString(v140, v142, 1024, 0x8000100u);
            v143 = v142;
          }
          if (qword_1000EBD40)
            v157 = (FILE *)qword_1000EBD40;
          else
            v157 = __stderrp;
          fprintf(v157, "%s\n", v142);
          if (v143)
            free(v143);
          CFRelease(v140);
        }
        else
        {
          v153 = sub_100030318();
          if (os_log_type_enabled(v153, OS_LOG_TYPE_FAULT))
            sub_100090810();
          if (qword_1000EBD40)
            v154 = (FILE *)qword_1000EBD40;
          else
            v154 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v154);
        }
        *__error() = v138;
      }
      objc_msgSend(v7, "appendFormat:", CFSTR("Timed out waiting for heap/ddt, last %d heap/ddt invocations may be truncated\n"), 8);
    }
    else
    {
      if (byte_1000EBD38)
      {
        v144 = *__error();
        v145 = sub_100030318();
        if (os_log_type_enabled(v145, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 67109120;
          v230 = v11;
          _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_INFO, "Done running heap/ddt for all (%d) processes", buf, 8u);
        }
        *__error() = v144;
      }
      if (byte_1000EBD39)
        v146 = dword_1000EB4E8 <= 1;
      else
        v146 = 0;
      if (v146)
      {
        v147 = *__error();
        v148 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Done running heap/ddt for all (%d) processes"), v11);
        if (v148)
        {
          v149 = v148;
          v150 = CFStringGetCStringPtr(v148, 0x8000100u);
          if (v150)
          {
            v151 = (char *)v150;
            v152 = 0;
          }
          else
          {
            v151 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x22DCC959uLL);
            CFStringGetCString(v149, v151, 1024, 0x8000100u);
            v152 = v151;
          }
          if (qword_1000EBD40)
            v163 = (FILE *)qword_1000EBD40;
          else
            v163 = __stderrp;
          fprintf(v163, "%s\n", v151);
          if (v152)
            free(v152);
          CFRelease(v149);
        }
        else
        {
          v158 = sub_100030318();
          if (os_log_type_enabled(v158, OS_LOG_TYPE_FAULT))
            sub_1000907AC();
          if (qword_1000EBD40)
            v159 = (FILE *)qword_1000EBD40;
          else
            v159 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v159);
        }
        *__error() = v147;
      }
    }
    dispatch_release(object);
    dispatch_release(dsema);
    objc_msgSend(v7, "appendString:", objc_msgSend(v36, "componentsJoinedByString:", &stru_1000E0D48));

  }
  objc_msgSend(a2, "setCustomOutput:", v7);

  return objc_msgSend(a2, "performSamplePrinterWork:", &stru_1000DD6D0);
}

int sub_10005BF8C(id a1, const void *a2, const void *a3)
{
  return *(_DWORD *)a2 - *(_DWORD *)a3;
}

void sub_10005BF9C(unsigned int a1, int a2, int a3, uint64_t a4, uint64_t a5)
{
  NSObject *v9;
  NSObject *v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  _QWORD v15[5];
  _QWORD v16[10];
  unsigned int v17;
  int v18;
  int v19;
  _QWORD v20[5];
  int v21;
  _QWORD v22[6];
  int v23;
  _QWORD v24[5];
  int v25;
  _QWORD handler[6];
  int v27;
  _QWORD v28[3];
  void *v29;

  v9 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v10 = dispatch_queue_create("com.apple.spindump.readchildren", v9);
  fcntl(a2, 4, 4);
  fcntl(a3, 4, 4);
  v28[0] = 0;
  v28[1] = v28;
  v28[2] = 0x2020000000;
  v29 = 0;
  v29 = malloc_type_calloc(1uLL, 0x400uLL, 0xF79D37D3uLL);
  v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a2, 0, v10);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_10005FC88;
  handler[3] = &unk_1000DD808;
  v27 = a2;
  handler[4] = a4;
  handler[5] = v28;
  dispatch_source_set_event_handler(v11, handler);
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472;
  v24[2] = sub_10005FD20;
  v24[3] = &unk_1000DD830;
  v25 = a2;
  v24[4] = v11;
  dispatch_source_set_cancel_handler(v11, v24);
  dispatch_activate(v11);
  v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a3, 0, v10);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_10005FD48;
  v22[3] = &unk_1000DD808;
  v23 = a3;
  v22[4] = a4;
  v22[5] = v28;
  dispatch_source_set_event_handler(v12, v22);
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_10005FDE0;
  v20[3] = &unk_1000DD830;
  v21 = a3;
  v20[4] = v12;
  dispatch_source_set_cancel_handler(v12, v20);
  dispatch_activate(v12);
  v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, a1, 0x80000000uLL, v10);
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_10005FE08;
  v16[3] = &unk_1000DD858;
  v16[4] = v11;
  v16[5] = v12;
  v17 = a1;
  v18 = a2;
  v19 = a3;
  v16[6] = v13;
  v16[7] = a4;
  v16[9] = v28;
  v16[8] = a5;
  dispatch_source_set_event_handler(v13, v16);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10005FFA0;
  v15[3] = &unk_1000DD608;
  v15[4] = v13;
  dispatch_source_set_cancel_handler(v13, v15);
  dispatch_activate(v13);
  dispatch_release(v10);
  _Block_object_dispose(v28, 8);
}

void sub_10005C21C(uint64_t a1)
{
  _QWORD *v2;
  int *v3;
  int v4;
  NSObject *v5;
  BOOL v6;
  int v7;
  _DWORD *v8;
  const __CFString *v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  BOOL v13;
  const __CFString *v14;
  const char *CStringPtr;
  char *v16;
  char *v17;
  FILE *v18;
  NSObject *v19;
  FILE *v20;
  int v21;
  NSObject *v22;
  BOOL v23;
  int v24;
  const __CFString *v25;
  const __CFString *v26;
  const char *v27;
  char *v28;
  char *v29;
  NSObject *v30;
  FILE *v31;
  FILE *v32;

  if (!objc_msgSend(*(id *)(a1 + 32), "length"))
  {
    v2 = (_QWORD *)(a1 + 56);
    v3 = (int *)(a1 + 64);
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * *(int *)(a1 + 64)) & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v11 = *__error();
        v12 = sub_100030318();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_100090B4C();
        *__error() = v11;
      }
      if (byte_1000EBD39)
        v13 = dword_1000EB4E8 <= 3;
      else
        v13 = 0;
      if (!v13)
        goto LABEL_41;
      v7 = *__error();
      v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No output from heap for %d"), *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          sub_100090AE4();
        goto LABEL_36;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v4 = *__error();
        v5 = sub_100030318();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_100090A74();
        *__error() = v4;
      }
      if (byte_1000EBD39)
        v6 = dword_1000EB4E8 <= 3;
      else
        v6 = 0;
      if (!v6)
        goto LABEL_41;
      v7 = *__error();
      v8 = sub_1000302B4(*(_DWORD *)(*v2 + 4 * *v3));
      v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: No output from heap for %d"), v8, *(unsigned int *)(*v2 + 4 * *v3), *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        v10 = sub_100030318();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
          sub_100090A04();
LABEL_36:
        if (qword_1000EBD40)
          v20 = (FILE *)qword_1000EBD40;
        else
          v20 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_40:
        *__error() = v7;
LABEL_41:
        objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR("No output from heap for %d\n"), *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
        goto LABEL_42;
      }
    }
    v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      v16 = (char *)CStringPtr;
      v17 = 0;
    }
    else
    {
      v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1A296697uLL);
      CFStringGetCString(v14, v16, 1024, 0x8000100u);
      v17 = v16;
    }
    if (qword_1000EBD40)
      v18 = (FILE *)qword_1000EBD40;
    else
      v18 = __stderrp;
    fprintf(v18, "%s\n", v16);
    if (v17)
      free(v17);
    CFRelease(v14);
    goto LABEL_40;
  }
LABEL_42:

  if (byte_1000EBD38)
  {
    v21 = *__error();
    v22 = sub_100030318();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      sub_1000909A4();
    *__error() = v21;
  }
  if (byte_1000EBD39)
    v23 = dword_1000EB4E8 <= 0;
  else
    v23 = 0;
  if (v23)
  {
    v24 = *__error();
    v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("heap for [%d] completed"), *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
    if (v25)
    {
      v26 = v25;
      v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        v28 = (char *)v27;
        v29 = 0;
      }
      else
      {
        v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2807575AuLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        v29 = v28;
      }
      if (qword_1000EBD40)
        v32 = (FILE *)qword_1000EBD40;
      else
        v32 = __stderrp;
      fprintf(v32, "%s\n", v28);
      if (v29)
        free(v29);
      CFRelease(v26);
    }
    else
    {
      v30 = sub_100030318();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
        sub_10009093C();
      if (qword_1000EBD40)
        v31 = (FILE *)qword_1000EBD40;
      else
        v31 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }
    *__error() = v24;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void sub_10005C6C0(uint64_t a1)
{
  _QWORD *v2;
  int *v3;
  int v4;
  NSObject *v5;
  BOOL v6;
  int v7;
  _DWORD *v8;
  const __CFString *v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  BOOL v13;
  const __CFString *v14;
  const char *CStringPtr;
  char *v16;
  char *v17;
  FILE *v18;
  NSObject *v19;
  FILE *v20;
  int v21;
  NSObject *v22;
  BOOL v23;
  int v24;
  const __CFString *v25;
  const __CFString *v26;
  const char *v27;
  char *v28;
  char *v29;
  NSObject *v30;
  FILE *v31;
  FILE *v32;

  if (!objc_msgSend(*(id *)(a1 + 32), "length"))
  {
    v2 = (_QWORD *)(a1 + 56);
    v3 = (int *)(a1 + 64);
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 56) + 4 * *(int *)(a1 + 64)) & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v11 = *__error();
        v12 = sub_100030318();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          sub_100090DC4();
        *__error() = v11;
      }
      if (byte_1000EBD39)
        v13 = dword_1000EB4E8 <= 3;
      else
        v13 = 0;
      if (!v13)
        goto LABEL_41;
      v7 = *__error();
      v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No output from ddt for %d"), *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
          sub_100090D5C();
        goto LABEL_36;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v4 = *__error();
        v5 = sub_100030318();
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
          sub_100090CEC();
        *__error() = v4;
      }
      if (byte_1000EBD39)
        v6 = dword_1000EB4E8 <= 3;
      else
        v6 = 0;
      if (!v6)
        goto LABEL_41;
      v7 = *__error();
      v8 = sub_1000302B4(*(_DWORD *)(*v2 + 4 * *v3));
      v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: No output from ddt for %d"), v8, *(unsigned int *)(*v2 + 4 * *v3), *(unsigned int *)(*v2 + 4 * *v3));
      if (!v9)
      {
        v10 = sub_100030318();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
          sub_100090C7C();
LABEL_36:
        if (qword_1000EBD40)
          v20 = (FILE *)qword_1000EBD40;
        else
          v20 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_40:
        *__error() = v7;
LABEL_41:
        objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR("No output from ddt for %d\n"), *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
        goto LABEL_42;
      }
    }
    v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      v16 = (char *)CStringPtr;
      v17 = 0;
    }
    else
    {
      v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC9814882uLL);
      CFStringGetCString(v14, v16, 1024, 0x8000100u);
      v17 = v16;
    }
    if (qword_1000EBD40)
      v18 = (FILE *)qword_1000EBD40;
    else
      v18 = __stderrp;
    fprintf(v18, "%s\n", v16);
    if (v17)
      free(v17);
    CFRelease(v14);
    goto LABEL_40;
  }
LABEL_42:

  if (byte_1000EBD38)
  {
    v21 = *__error();
    v22 = sub_100030318();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      sub_100090C1C();
    *__error() = v21;
  }
  if (byte_1000EBD39)
    v23 = dword_1000EB4E8 <= 0;
  else
    v23 = 0;
  if (v23)
  {
    v24 = *__error();
    v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("ddt for [%d] completed"), *(unsigned int *)(*(_QWORD *)(a1 + 56) + 4 * *(int *)(a1 + 64)));
    if (v25)
    {
      v26 = v25;
      v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        v28 = (char *)v27;
        v29 = 0;
      }
      else
      {
        v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAD774FBFuLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        v29 = v28;
      }
      if (qword_1000EBD40)
        v32 = (FILE *)qword_1000EBD40;
      else
        v32 = __stderrp;
      fprintf(v32, "%s\n", v28);
      if (v29)
        free(v29);
      CFRelease(v26);
    }
    else
    {
      v30 = sub_100030318();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
        sub_100090BB4();
      if (qword_1000EBD40)
        v31 = (FILE *)qword_1000EBD40;
      else
        v31 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    }
    *__error() = v24;
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 40));
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void sub_10005CB64(id a1, SASamplePrinter *a2)
{
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  NSObject *v7;
  FILE *v8;
  int v9;
  NSObject *v10;
  BOOL v11;
  int v12;
  const __CFString *v13;
  NSObject *v14;
  FILE *v15;
  const __CFString *v16;
  const char *CStringPtr;
  char *v18;
  char *v19;
  const __CFString *v20;
  const char *v21;
  char *v22;
  char *v23;
  FILE *v24;
  FILE *v25;
  uint8_t v26[16];
  uint8_t buf[16];
  uint8_t v28[16];
  uint8_t v29[16];

  if ((sub_10004D06C(a2, 0, 0, 4, 0, 0, 0, 0, 0.0, 0.0, 0, 0) & 1) != 0)
  {
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Saved shutdown report", buf, 2u);
      }
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 2;
    else
      v4 = 0;
    if (v4)
    {
      v5 = *__error();
      v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Saved shutdown report"));
      if (v6)
      {
        v16 = v6;
        CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
        if (CStringPtr)
        {
          v18 = (char *)CStringPtr;
          v19 = 0;
        }
        else
        {
          v18 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD8ED855uLL);
          CFStringGetCString(v16, v18, 1024, 0x8000100u);
          v19 = v18;
        }
        if (qword_1000EBD40)
          v24 = (FILE *)qword_1000EBD40;
        else
          v24 = __stderrp;
        fprintf(v24, "%s\n", v18);
        if (v19)
          free(v19);
        CFRelease(v16);
      }
      else
      {
        v7 = sub_100030318();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v26 = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "Unable to format: Saved shutdown report", v26, 2u);
        }
        if (qword_1000EBD40)
          v8 = (FILE *)qword_1000EBD40;
        else
          v8 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v8);
      }
      *__error() = v5;
    }
    exit(0);
  }
  if (byte_1000EBD38)
  {
    v9 = *__error();
    v10 = sub_100030318();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)v29 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Failed to save shutdown report", v29, 2u);
    }
    *__error() = v9;
  }
  if (byte_1000EBD39)
    v11 = dword_1000EB4E8 <= 2;
  else
    v11 = 0;
  if (v11)
  {
    v12 = *__error();
    v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to save shutdown report"));
    if (v13)
    {
      v20 = v13;
      v21 = CFStringGetCStringPtr(v13, 0x8000100u);
      if (v21)
      {
        v22 = (char *)v21;
        v23 = 0;
      }
      else
      {
        v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7D62EB02uLL);
        CFStringGetCString(v20, v22, 1024, 0x8000100u);
        v23 = v22;
      }
      if (qword_1000EBD40)
        v25 = (FILE *)qword_1000EBD40;
      else
        v25 = __stderrp;
      fprintf(v25, "%s\n", v22);
      if (v23)
        free(v23);
      CFRelease(v20);
    }
    else
    {
      v14 = sub_100030318();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)v28 = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, "Unable to format: Failed to save shutdown report", v28, 2u);
      }
      if (qword_1000EBD40)
        v15 = (FILE *)qword_1000EBD40;
      else
        v15 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v15);
    }
    *__error() = v12;
  }
  exit(69);
}

id sub_10005CF28(uint64_t a1, NSObject *a2)
{
  double Current;
  id v5;
  double v6;
  int v7;
  NSObject *v8;
  BOOL v9;
  int v10;
  double v11;
  uintptr_t v12;
  const __CFString *v13;
  const __CFString *v14;
  const char *v15;
  char *v16;
  char *v17;
  NSObject *v18;
  FILE *v19;
  FILE *v20;
  unsigned int *v21;
  int v22;
  int v23;
  NSObject *v24;
  double v25;
  unsigned int v26;
  BOOL v27;
  int v28;
  uintptr_t v29;
  const __CFString *v30;
  const __CFString *v31;
  const char *v32;
  char *v33;
  char *v34;
  int v35;
  NSObject *v36;
  double v37;
  BOOL v38;
  int v39;
  uintptr_t v40;
  const __CFString *v41;
  const __CFString *v42;
  const char *v43;
  malloc_type_id_t v44;
  int v45;
  NSObject *v46;
  double v47;
  BOOL v48;
  uintptr_t v49;
  const __CFString *v50;
  char *v51;
  char *v52;
  NSObject *v53;
  FILE *v54;
  NSObject *v55;
  FILE *v56;
  NSObject *v57;
  FILE *v58;
  FILE *v59;
  id result;
  id v61;
  uint64_t v62;
  void *v63;
  int v64;
  NSObject *v65;
  BOOL v66;
  int v67;
  uintptr_t handle;
  const __CFString *v69;
  NSObject *v70;
  FILE *v71;
  const __CFString *v72;
  const char *CStringPtr;
  char *v74;
  char *v75;
  FILE *v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  uint8_t v81[128];
  uint8_t buf[4];
  double v83;
  __int16 v84;
  uintptr_t v85;

  Current = SAMachAbsTimeSecondsGetCurrent(a1);
  v5 = +[SPSampledProcess allSampledProcesses](SPSampledProcess, "allSampledProcesses");
  if ((byte_1000EBC70 & 1) != 0)
  {
    v6 = Current - *(double *)&qword_1000EBC68;
    if (Current - *(double *)&qword_1000EBC68 > 1.0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 134217984;
          v83 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Interrupted again by signal %ld, exiting", buf, 0xCu);
        }
        *__error() = v64;
      }
      if (byte_1000EBD39)
        v66 = dword_1000EB4E8 <= 2;
      else
        v66 = 0;
      if (v66)
      {
        v67 = *__error();
        handle = dispatch_source_get_handle(a2);
        v69 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Interrupted again by signal %ld, exiting"), handle);
        if (v69)
        {
          v72 = v69;
          CStringPtr = CFStringGetCStringPtr(v69, 0x8000100u);
          if (CStringPtr)
          {
            v74 = (char *)CStringPtr;
            v75 = 0;
          }
          else
          {
            v74 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9D326124uLL);
            CFStringGetCString(v72, v74, 1024, 0x8000100u);
            v75 = v74;
          }
          if (qword_1000EBD40)
            v76 = (FILE *)qword_1000EBD40;
          else
            v76 = __stderrp;
          fprintf(v76, "%s\n", v74);
          if (v75)
            free(v75);
          CFRelease(v72);
        }
        else
        {
          v70 = sub_100030318();
          if (os_log_type_enabled(v70, OS_LOG_TYPE_FAULT))
            sub_100090E2C(a2, v70);
          if (qword_1000EBD40)
            v71 = (FILE *)qword_1000EBD40;
          else
            v71 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v71);
        }
        *__error() = v67;
      }
      exit(75);
    }
    if (byte_1000EBD38)
    {
      v7 = *__error();
      v8 = sub_100030318();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 134218240;
        v83 = Current - *(double *)&qword_1000EBC68;
        v84 = 2048;
        v85 = dispatch_source_get_handle(a2);
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Interrupted again after %.2f seconds by signal %ld, not exiting", buf, 0x16u);
      }
      *__error() = v7;
    }
    if (byte_1000EBD39)
      v9 = dword_1000EB4E8 <= 2;
    else
      v9 = 0;
    if (v9)
    {
      v10 = *__error();
      v11 = Current - *(double *)&qword_1000EBC68;
      v12 = dispatch_source_get_handle(a2);
      v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Interrupted again after %.2f seconds by signal %ld, not exiting"), *(_QWORD *)&v11, v12);
      if (v13)
      {
        v14 = v13;
        v15 = CFStringGetCStringPtr(v13, 0x8000100u);
        if (v15)
        {
          v16 = (char *)v15;
          v17 = 0;
        }
        else
        {
          v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1A09CBB6uLL);
          CFStringGetCString(v14, v16, 1024, 0x8000100u);
          v17 = v16;
        }
        if (qword_1000EBD40)
          v20 = (FILE *)qword_1000EBD40;
        else
          v20 = __stderrp;
        fprintf(v20, "%s\n", v16);
        if (v17)
          free(v17);
        CFRelease(v14);
      }
      else
      {
        v18 = sub_100030318();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
          sub_100090FFC(a2, v18, Current);
        if (qword_1000EBD40)
          v19 = (FILE *)qword_1000EBD40;
        else
          v19 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
      }
      *__error() = v10;
    }
  }
  else
  {
    qword_1000EBC68 = *(_QWORD *)&Current;
    byte_1000EBC70 = 1;
  }
  if (!objc_msgSend(v5, "count", v6))
  {
    if (byte_1000EBD38)
    {
      v35 = *__error();
      v36 = sub_100030318();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        v37 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
        *(_DWORD *)buf = 134217984;
        v83 = v37;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Interrupted by signal %ld while saving report. Interrupt again after a second to exit early", buf, 0xCu);
      }
      *__error() = v35;
    }
    if (byte_1000EBD39)
      v38 = dword_1000EB4E8 <= 2;
    else
      v38 = 0;
    if (!v38)
      goto LABEL_100;
    v39 = *__error();
    v40 = dispatch_source_get_handle(a2);
    v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Interrupted by signal %ld while saving report. Interrupt again after a second to exit early"), v40);
    if (v41)
    {
      v42 = v41;
      v43 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v43)
      {
LABEL_67:
        v51 = (char *)v43;
        v52 = 0;
LABEL_93:
        if (qword_1000EBD40)
          v59 = (FILE *)qword_1000EBD40;
        else
          v59 = __stderrp;
        fprintf(v59, "%s\n", v51);
        if (v52)
          free(v52);
        CFRelease(v42);
        goto LABEL_99;
      }
      v44 = 1456550084;
LABEL_92:
      v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v44);
      CFStringGetCString(v42, v51, 1024, 0x8000100u);
      v52 = v51;
      goto LABEL_93;
    }
    v55 = sub_100030318();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
      sub_100090E9C(a2, v55);
LABEL_87:
    if (qword_1000EBD40)
      v58 = (FILE *)qword_1000EBD40;
    else
      v58 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v58);
LABEL_99:
    *__error() = v39;
    goto LABEL_100;
  }
  v22 = *(_DWORD *)(a1 + 32);
  v21 = (unsigned int *)(a1 + 32);
  if (v22)
  {
    if (byte_1000EBD38)
    {
      v23 = *__error();
      v24 = sub_100030318();
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        v25 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
        v26 = *v21;
        *(_DWORD *)buf = 134218240;
        v83 = v25;
        v84 = 1024;
        LODWORD(v85) = v26;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Interrupted by signal %ld, waiting %d seconds...", buf, 0x12u);
      }
      *__error() = v23;
    }
    if (byte_1000EBD39)
      v27 = dword_1000EB4E8 <= 2;
    else
      v27 = 0;
    if (v27)
    {
      v28 = *__error();
      v29 = dispatch_source_get_handle(a2);
      v30 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Interrupted by signal %ld, waiting %d seconds..."), v29, *v21);
      if (v30)
      {
        v31 = v30;
        v32 = CFStringGetCStringPtr(v30, 0x8000100u);
        if (v32)
        {
          v33 = (char *)v32;
          v34 = 0;
        }
        else
        {
          v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8FC039E6uLL);
          CFStringGetCString(v31, v33, 1024, 0x8000100u);
          v34 = v33;
        }
        if (qword_1000EBD40)
          v56 = (FILE *)qword_1000EBD40;
        else
          v56 = __stderrp;
        fprintf(v56, "%s\n", v33);
        if (v34)
          free(v34);
        CFRelease(v31);
      }
      else
      {
        v53 = sub_100030318();
        if (os_log_type_enabled(v53, OS_LOG_TYPE_FAULT))
          sub_100090F7C(a2);
        if (qword_1000EBD40)
          v54 = (FILE *)qword_1000EBD40;
        else
          v54 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v54);
      }
      *__error() = v28;
    }
    sleep(*v21);
    goto LABEL_100;
  }
  if (byte_1000EBD38)
  {
    v45 = *__error();
    v46 = sub_100030318();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      v47 = COERCE_DOUBLE(dispatch_source_get_handle(a2));
      *(_DWORD *)buf = 134217984;
      v83 = v47;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Interrupted by signal %ld", buf, 0xCu);
    }
    *__error() = v45;
  }
  if (byte_1000EBD39)
    v48 = dword_1000EB4E8 <= 2;
  else
    v48 = 0;
  if (v48)
  {
    v39 = *__error();
    v49 = dispatch_source_get_handle(a2);
    v50 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Interrupted by signal %ld"), v49);
    if (v50)
    {
      v42 = v50;
      v43 = CFStringGetCStringPtr(v50, 0x8000100u);
      if (v43)
        goto LABEL_67;
      v44 = 2954543306;
      goto LABEL_92;
    }
    v57 = sub_100030318();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_FAULT))
      sub_100090F0C(a2, v57);
    goto LABEL_87;
  }
LABEL_100:
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  result = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v77, v81, 16);
  if (result)
  {
    v61 = result;
    v62 = *(_QWORD *)v78;
    do
    {
      v63 = 0;
      do
      {
        if (*(_QWORD *)v78 != v62)
          objc_enumerationMutation(v5);
        objc_msgSend(*(id *)(*((_QWORD *)&v77 + 1) + 8 * (_QWORD)v63), "stopSamplingWithReason:", 5);
        v63 = (char *)v63 + 1;
      }
      while (v61 != v63);
      result = objc_msgSend(v5, "countByEnumeratingWithState:objects:count:", &v77, v81, 16);
      v61 = result;
    }
    while (result);
  }
  return result;
}

void sub_10005D8EC(id a1)
{
  uint64_t v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  malloc_type_id_t v9;
  char *v10;
  const char *v11;
  int v12;
  NSObject *v13;
  BOOL v14;
  int v15;
  const __CFString *v16;
  const __CFString *v17;
  const char *v18;
  char *v19;
  char *v20;
  NSObject *v21;
  NSObject *v22;
  FILE *v23;
  FILE *v24;
  int v25;
  NSObject *v26;
  const __CFString *v27;
  size_t v28;
  size_t v29;
  pid_t v30;
  FILE *v31;
  FILE *v32;
  uint64_t v33;
  id v34;
  void *v35;
  size_t v36;
  int v37;
  NSObject *v38;
  const __CFString *v39;
  int v40;
  NSObject *v41;
  int v42;
  const __CFString *v43;
  const __CFString *v44;
  const char *v45;
  char *v46;
  char *v47;
  int v48;
  NSObject *v49;
  uint64_t v50;
  int *v51;
  char *v52;
  const __CFString *v53;
  char *v54;
  char *v55;
  int v56;
  NSObject *v57;
  int v58;
  int v59;
  int v60;
  int v61;
  int v62;
  int v63;
  int v64;
  uint64_t v65;
  char *v66;
  const __CFString *v67;
  const __CFString *v68;
  const char *v69;
  char *v70;
  char *v71;
  NSObject *v72;
  FILE *v73;
  NSObject *v74;
  NSObject *v75;
  FILE *v76;
  FILE *v77;
  NSObject *v78;
  FILE *v79;
  NSObject *v80;
  int v81;
  int v82;
  int v83;
  int v84;
  int v85;
  int v86;
  FILE *v87;
  FILE *v88;
  int v89;
  NSObject *v90;
  int v91;
  const __CFString *v92;
  const __CFString *v93;
  const char *v94;
  char *v95;
  char *v96;
  NSObject *v97;
  FILE *v98;
  FILE *v99;
  time_t v100;
  tm v101;
  uint8_t v102[4];
  uint8_t *v103;
  uint8_t buf[1032];

  v1 = getpid();
  if (sub_10005E5AC(v1))
  {
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        sub_1000910C8();
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 0;
    else
      v4 = 0;
    if (!v4)
      return;
    v5 = *__error();
    v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("spindump-stuck: Running under debugger, ignoring"));
    if (v6)
    {
      v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (!CStringPtr)
      {
        v9 = 2269146905;
LABEL_118:
        v54 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v9);
        CFStringGetCString(v7, v54, 1024, 0x8000100u);
        v55 = v54;
        goto LABEL_119;
      }
      goto LABEL_88;
    }
    v21 = sub_100030318();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
      sub_10009109C();
    goto LABEL_127;
  }
  v10 = getenv("XPC_NULL_BOOTSTRAP");
  if (v10)
    v11 = v10;
  else
    v11 = "0";
  if (strcmp("1", v11))
  {
    if (byte_1000EBD38)
    {
      v12 = *__error();
      v13 = sub_100030318();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC", buf, 2u);
      }
      *__error() = v12;
    }
    if (byte_1000EBD39)
      v14 = dword_1000EB4E8 <= 2;
    else
      v14 = 0;
    if (v14)
    {
      v15 = *__error();
      v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC"));
      if (v16)
      {
        v17 = v16;
        v18 = CFStringGetCStringPtr(v16, 0x8000100u);
        if (v18)
        {
          v19 = (char *)v18;
          v20 = 0;
        }
        else
        {
          v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCC9C2C22uLL);
          CFStringGetCString(v17, v19, 1024, 0x8000100u);
          v20 = v19;
        }
        if (qword_1000EBD40)
          v24 = (FILE *)qword_1000EBD40;
        else
          v24 = __stderrp;
        fprintf(v24, "%s\n", v19);
        if (v20)
          free(v20);
        CFRelease(v17);
      }
      else
      {
        v22 = sub_100030318();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
          sub_1000914C8();
        if (qword_1000EBD40)
          v23 = (FILE *)qword_1000EBD40;
        else
          v23 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
      }
      *__error() = v15;
    }
  }
  if ((byte_1000EBD4C & 2) != 0 && sub_100025FB4())
  {
    if (byte_1000EBD38)
    {
      v25 = *__error();
      v26 = sub_100030318();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
        sub_10009149C();
      *__error() = v25;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v5 = *__error();
      v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("spindump-stuck: Audio running, avoiding stackshot"));
      if (v27)
      {
        v7 = v27;
        CStringPtr = CFStringGetCStringPtr(v27, 0x8000100u);
        if (!CStringPtr)
        {
          v9 = 3430403329;
          goto LABEL_118;
        }
LABEL_88:
        v54 = (char *)CStringPtr;
        v55 = 0;
LABEL_119:
        if (qword_1000EBD40)
          v77 = (FILE *)qword_1000EBD40;
        else
          v77 = __stderrp;
        fprintf(v77, "%s\n", v54);
        if (v55)
          free(v55);
        CFRelease(v7);
LABEL_131:
        *__error() = v5;
        return;
      }
      v75 = sub_100030318();
      if (os_log_type_enabled(v75, OS_LOG_TYPE_FAULT))
        sub_100091470();
LABEL_127:
      if (qword_1000EBD40)
        v79 = (FILE *)qword_1000EBD40;
      else
        v79 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
      goto LABEL_131;
    }
  }
  else
  {
    strcpy((char *)buf, "/var/tmp/spindump-stuck-stackshot.");
    memset(&v101, 0, sizeof(v101));
    v100 = time(0);
    localtime_r(&v100, &v101);
    v28 = strftime((char *)&buf[34], 0x3DEuLL, "%Y-%m-%d-%T", &v101);
    v29 = v28 + 34;
    if (v28 + 34 >= 0x400)
    {
      v89 = *__error();
      v90 = sub_100030318();
      if (os_log_type_enabled(v90, OS_LOG_TYPE_FAULT))
        sub_100091408();
      *__error() = v89;
      if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
      {
        v91 = *__error();
        v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("filePath %s cut off with date (needed %zu chars)"), buf, v29);
        if (v92)
        {
          v93 = v92;
          v94 = CFStringGetCStringPtr(v92, 0x8000100u);
          if (v94)
          {
            v95 = (char *)v94;
            v96 = 0;
          }
          else
          {
            v95 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x62ADF942uLL);
            CFStringGetCString(v93, v95, 1024, 0x8000100u);
            v96 = v95;
          }
          if (qword_1000EBD40)
            v99 = (FILE *)qword_1000EBD40;
          else
            v99 = __stderrp;
          fprintf(v99, "%s\n", v95);
          if (v96)
            free(v96);
          CFRelease(v93);
        }
        else
        {
          v97 = sub_100030318();
          if (os_log_type_enabled(v97, OS_LOG_TYPE_FAULT))
            sub_1000913A0();
          if (qword_1000EBD40)
            v98 = (FILE *)qword_1000EBD40;
          else
            v98 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v98);
        }
        *__error() = v91;
      }
    }
    v30 = getpid();
    snprintf((char *)&buf[v29], 990 - v28, ".%d.buf", v30);
    v31 = fopen((const char *)buf, "w");
    if (v31)
    {
      v32 = v31;
      v33 = stackshot_config_create(v31);
      stackshot_config_set_flags(v33, 1302536203);
      v34 = sub_10006EB70(v33, 0);
      v35 = v34;
      if (v34 && objc_msgSend(v34, "length"))
      {
        v36 = fwrite(objc_msgSend(v35, "bytes"), (size_t)objc_msgSend(v35, "length"), 1uLL, v32);

        stackshot_config_dealloc(v33);
        if (v36 == 1)
        {
          fclose(v32);
          if (byte_1000EBD38)
          {
            v37 = *__error();
            v38 = sub_100030318();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v102 = 136315138;
              v103 = buf;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "spindump-stuck: Wrote stackshot to %s", v102, 0xCu);
            }
            *__error() = v37;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
          {
            v5 = *__error();
            v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("spindump-stuck: Wrote stackshot to %s"), buf);
            if (v39)
            {
              v7 = v39;
              CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
              if (!CStringPtr)
              {
                v9 = 1186232392;
                goto LABEL_118;
              }
              goto LABEL_88;
            }
            v78 = sub_100030318();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
              sub_10009124C();
            goto LABEL_127;
          }
        }
        else
        {
          if (byte_1000EBD38)
          {
            v56 = *__error();
            v57 = sub_100030318();
            v58 = (int)v57;
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
              sub_100091328((int)buf, v32, v58, v59, v60, v61, v62, v63);
            *__error() = v56;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
          {
            v64 = *__error();
            v65 = ferror(v32);
            v66 = strerror(v65);
            v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write stackshot to %s: %d (%s)"), buf, v65, v66);
            if (v67)
            {
              v68 = v67;
              v69 = CFStringGetCStringPtr(v67, 0x8000100u);
              if (v69)
              {
                v70 = (char *)v69;
                v71 = 0;
              }
              else
              {
                v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5C58F1D1uLL);
                CFStringGetCString(v68, v70, 1024, 0x8000100u);
                v71 = v70;
              }
              if (qword_1000EBD40)
                v88 = (FILE *)qword_1000EBD40;
              else
                v88 = __stderrp;
              fprintf(v88, "%s\n", v70);
              if (v71)
                free(v71);
              CFRelease(v68);
            }
            else
            {
              v80 = sub_100030318();
              v81 = (int)v80;
              if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
                sub_1000912B0((int)buf, v32, v81, v82, v83, v84, v85, v86);
              if (qword_1000EBD40)
                v87 = (FILE *)qword_1000EBD40;
              else
                v87 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
            }
            *__error() = v64;
          }
          fclose(v32);
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v40 = *__error();
          v41 = sub_100030318();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
            sub_100091220();
          *__error() = v40;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v42 = *__error();
          v43 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("spindump-stuck: Unable to take stackshot"));
          if (v43)
          {
            v44 = v43;
            v45 = CFStringGetCStringPtr(v43, 0x8000100u);
            if (v45)
            {
              v46 = (char *)v45;
              v47 = 0;
            }
            else
            {
              v46 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7735B98AuLL);
              CFStringGetCString(v44, v46, 1024, 0x8000100u);
              v47 = v46;
            }
            if (qword_1000EBD40)
              v76 = (FILE *)qword_1000EBD40;
            else
              v76 = __stderrp;
            fprintf(v76, "%s\n", v46);
            if (v47)
              free(v47);
            CFRelease(v44);
          }
          else
          {
            v72 = sub_100030318();
            if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
              sub_1000911F4();
            if (qword_1000EBD40)
              v73 = (FILE *)qword_1000EBD40;
            else
              v73 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
          }
          *__error() = v42;
        }

        stackshot_config_dealloc(v33);
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v48 = *__error();
        v49 = sub_100030318();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
          sub_100091174();
        *__error() = v48;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v5 = *__error();
        v50 = *__error();
        v51 = __error();
        v52 = strerror(*v51);
        v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("spindump-stuck: Unable to open %s: %d (%s)"), buf, v50, v52);
        if (v53)
        {
          v7 = v53;
          CStringPtr = CFStringGetCStringPtr(v53, 0x8000100u);
          if (!CStringPtr)
          {
            v9 = 3207779541;
            goto LABEL_118;
          }
          goto LABEL_88;
        }
        v74 = sub_100030318();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
          sub_1000910F4();
        goto LABEL_127;
      }
    }
  }
}

BOOL sub_10005E5AC(uint64_t a1)
{
  int v3;
  NSObject *v4;
  BOOL v5;
  int v6;
  _DWORD *v7;
  uint64_t v8;
  int *v9;
  char *v10;
  const __CFString *v11;
  const __CFString *v12;
  const char *v13;
  char *v14;
  char *v15;
  int v16;
  NSObject *v17;
  BOOL v18;
  uint64_t v19;
  int *v20;
  char *v21;
  const __CFString *v22;
  const __CFString *v23;
  const char *CStringPtr;
  char *v25;
  char *v26;
  NSObject *v27;
  FILE *v28;
  const __CFString *v29;
  NSObject *v30;
  FILE *v31;
  FILE *v32;
  _OWORD buffer[2];
  __int128 v34;
  __int128 v35;

  v34 = 0u;
  v35 = 0u;
  memset(buffer, 0, sizeof(buffer));
  if (!proc_pidinfo(a1, 13, 1uLL, buffer, 64))
  {
    if ((a1 & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v16 = *__error();
        v17 = sub_100030318();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_10009167C();
        *__error() = v16;
      }
      if (byte_1000EBD39)
        v18 = dword_1000EB4E8 <= 3;
      else
        v18 = 0;
      if (!v18)
        return 0;
      v6 = *__error();
      v19 = *__error();
      v20 = __error();
      v21 = strerror(*v20);
      v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to get proc info, assuming not being debugged: %d (%s)"), v19, v21);
      if (v22)
      {
        v23 = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (CStringPtr)
        {
          v25 = (char *)CStringPtr;
          v26 = 0;
        }
        else
        {
          v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x878C781uLL);
          CFStringGetCString(v23, v25, 1024, 0x8000100u);
          v26 = v25;
        }
        if (qword_1000EBD40)
          v32 = (FILE *)qword_1000EBD40;
        else
          v32 = __stderrp;
        fprintf(v32, "%s\n", v25);
        if (v26)
          free(v26);
        v29 = v23;
        goto LABEL_51;
      }
      v30 = sub_100030318();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_FAULT))
        sub_10009160C();
    }
    else
    {
      if (byte_1000EBD38)
      {
        v3 = *__error();
        v4 = sub_100030318();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
          sub_100091580();
        *__error() = v3;
      }
      if (byte_1000EBD39)
        v5 = dword_1000EB4E8 <= 3;
      else
        v5 = 0;
      if (!v5)
        return 0;
      v6 = *__error();
      v7 = sub_1000302B4(a1);
      v8 = *__error();
      v9 = __error();
      v10 = strerror(*v9);
      v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)"), v7, a1, v8, v10);
      if (v11)
      {
        v12 = v11;
        v13 = CFStringGetCStringPtr(v11, 0x8000100u);
        if (v13)
        {
          v14 = (char *)v13;
          v15 = 0;
        }
        else
        {
          v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x878C781uLL);
          CFStringGetCString(v12, v14, 1024, 0x8000100u);
          v15 = v14;
        }
        if (qword_1000EBD40)
          v28 = (FILE *)qword_1000EBD40;
        else
          v28 = __stderrp;
        fprintf(v28, "%s\n", v14);
        if (v15)
          free(v15);
        v29 = v12;
LABEL_51:
        CFRelease(v29);
LABEL_52:
        *__error() = v6;
        return 0;
      }
      v27 = sub_100030318();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_FAULT))
        sub_1000914F4();
    }
    if (qword_1000EBD40)
      v31 = (FILE *)qword_1000EBD40;
    else
      v31 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v31);
    goto LABEL_52;
  }
  return (v34 & 2) != 0;
}

void sub_10005E954(uint64_t a1, void *a2)
{
  NSString *v4;
  int v5;
  NSObject *v6;
  BOOL v7;
  int v8;
  const __CFString *v9;
  NSObject *v10;
  const char *v11;
  uint8_t *v12;
  int v13;
  NSObject *v14;
  BOOL v15;
  const __CFString *v16;
  FILE *v17;
  const __CFString *v18;
  const char *CStringPtr;
  malloc_type_id_t v20;
  char *v21;
  char *v22;
  FILE *v23;
  int v24;
  NSObject *v25;
  int v26;
  const __CFString *v27;
  NSObject *v28;
  FILE *v29;
  const __CFString *v30;
  const char *v31;
  char *v32;
  char *v33;
  FILE *v34;
  uint8_t v35[16];
  uint8_t v36[16];
  __int16 v37;
  uint8_t buf[16];
  uint8_t v39[2];
  uint8_t v40[16];

  objc_msgSend(a2, "setIncidentUUID:", 0);
  v4 = (NSString *)objc_msgSend(a2, "targetProcessName");
  if (!v4)
  {
    if (*(_QWORD *)(a1 + 64))
      v4 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:");
    else
      v4 = 0;
  }
  if (*(_BYTE *)(a1 + 108))
  {
    dispatch_group_wait((dispatch_group_t)qword_1000EBD98, 0xFFFFFFFFFFFFFFFFLL);
    if ((byte_1000EBD4C & 0x18) == 0x10)
    {
      if (byte_1000EBD38)
      {
        v5 = *__error();
        v6 = sub_100030318();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SIGINFO received, generating report...", buf, 2u);
        }
        *__error() = v5;
      }
      if (byte_1000EBD39)
        v7 = dword_1000EB4E8 <= 2;
      else
        v7 = 0;
      if (!v7)
        goto LABEL_49;
      v8 = *__error();
      v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SIGINFO received, generating report..."));
      if (!v9)
      {
        v10 = sub_100030318();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        {
          v37 = 0;
          v11 = "Unable to format: SIGINFO received, generating report...";
          v12 = (uint8_t *)&v37;
LABEL_31:
          _os_log_fault_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, v11, v12, 2u);
          goto LABEL_32;
        }
        goto LABEL_32;
      }
      v18 = v9;
      CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
      if (!CStringPtr)
      {
        v20 = 1481238127;
LABEL_40:
        v21 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v20);
        CFStringGetCString(v18, v21, 1024, 0x8000100u);
        v22 = v21;
LABEL_42:
        if (qword_1000EBD40)
          v23 = (FILE *)qword_1000EBD40;
        else
          v23 = __stderrp;
        fprintf(v23, "%s\n", v21);
        if (v22)
          free(v22);
        CFRelease(v18);
        goto LABEL_48;
      }
      goto LABEL_41;
    }
    if (byte_1000EBD38)
    {
      v13 = *__error();
      v14 = sub_100030318();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)v40 = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SIGINFO received, processing symbols...", v40, 2u);
      }
      *__error() = v13;
    }
    if (byte_1000EBD39)
      v15 = dword_1000EB4E8 <= 2;
    else
      v15 = 0;
    if (v15)
    {
      v8 = *__error();
      v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("SIGINFO received, processing symbols..."));
      if (!v16)
      {
        v10 = sub_100030318();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v39 = 0;
          v11 = "Unable to format: SIGINFO received, processing symbols...";
          v12 = v39;
          goto LABEL_31;
        }
LABEL_32:
        if (qword_1000EBD40)
          v17 = (FILE *)qword_1000EBD40;
        else
          v17 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v17);
LABEL_48:
        *__error() = v8;
        goto LABEL_49;
      }
      v18 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (!CStringPtr)
      {
        v20 = 461140569;
        goto LABEL_40;
      }
LABEL_41:
      v21 = (char *)CStringPtr;
      v22 = 0;
      goto LABEL_42;
    }
  }
LABEL_49:
  if (*(_QWORD *)(a1 + 32))
    objc_msgSend(a2, "setPrintOptions:");
  objc_msgSend(a2, "setForceOneBasedTimeIndexes:", *(unsigned __int8 *)(a1 + 109));
  if (*(_QWORD *)(a1 + 72))
    objc_msgSend(a2, "setTargetThreadId:");
  if ((int)objc_msgSend(a2, "numSamplesAvoidedDueToAudio") >= 1 && !objc_msgSend(a2, "numSamples"))
  {
    if (byte_1000EBD38)
    {
      v24 = *__error();
      v25 = sub_100030318();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)v36 = 0;
        _os_log_error_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Unable to sample due to audio running", v36, 2u);
      }
      *__error() = v24;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v26 = *__error();
      v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to sample due to audio running"));
      if (v27)
      {
        v30 = v27;
        v31 = CFStringGetCStringPtr(v27, 0x8000100u);
        if (v31)
        {
          v32 = (char *)v31;
          v33 = 0;
        }
        else
        {
          v32 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8ED665AAuLL);
          CFStringGetCString(v30, v32, 1024, 0x8000100u);
          v33 = v32;
        }
        if (qword_1000EBD40)
          v34 = (FILE *)qword_1000EBD40;
        else
          v34 = __stderrp;
        fprintf(v34, "%s\n", v32);
        if (v33)
          free(v33);
        CFRelease(v30);
      }
      else
      {
        v28 = sub_100030318();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
        {
          *(_WORD *)v35 = 0;
          _os_log_fault_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, "Unable to format: Unable to sample due to audio running", v35, 2u);
        }
        if (qword_1000EBD40)
          v29 = (FILE *)qword_1000EBD40;
        else
          v29 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v29);
      }
      *__error() = v26;
    }
    exit(69);
  }
  sub_1000599CC(a2, *(_QWORD *)(a1 + 80), *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), *(unsigned __int8 *)(a1 + 110), *(unsigned __int8 *)(a1 + 111), *(unsigned __int8 *)(a1 + 112), *(uint8_t **)(a1 + 96), v4, *(_DWORD *)(a1 + 104) != 0);
}

uint64_t sub_10005EEC8(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32));
}

BOOL sub_10005EED8()
{
  int v0;
  NSObject *v1;
  BOOL v2;
  int v3;
  const __CFString *v4;
  const __CFString *v5;
  const char *v6;
  char *v7;
  char *v8;
  NSObject *v9;
  FILE *v10;
  FILE *v11;
  int v13;
  NSObject *v14;
  int v15;
  uint64_t v16;
  int *v17;
  char *v18;
  const __CFString *v19;
  const __CFString *v20;
  const char *CStringPtr;
  char *v22;
  char *v23;
  NSObject *v24;
  FILE *v25;
  FILE *v26;
  size_t v27;
  unsigned int v28;

  if (qword_1000EBCA0 != -1)
    dispatch_once(&qword_1000EBCA0, &stru_1000DD7C0);
  if (!qword_1000EB500)
    return 0;
  v28 = 0;
  v27 = 4;
  if (sysctl(dword_1000EBC90, qword_1000EB500, &v28, &v27, 0, 0))
  {
    v13 = *__error();
    v14 = sub_100030318();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
      sub_100091AD0();
    *__error() = v13;
    if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
    {
      v15 = *__error();
      v16 = *__error();
      v17 = __error();
      v18 = strerror(*v17);
      v19 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)"), v16, v18);
      if (v19)
      {
        v20 = v19;
        CStringPtr = CFStringGetCStringPtr(v19, 0x8000100u);
        if (CStringPtr)
        {
          v22 = (char *)CStringPtr;
          v23 = 0;
        }
        else
        {
          v22 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x73292CDDuLL);
          CFStringGetCString(v20, v22, 1024, 0x8000100u);
          v23 = v22;
        }
        if (qword_1000EBD40)
          v26 = (FILE *)qword_1000EBD40;
        else
          v26 = __stderrp;
        fprintf(v26, "%s\n", v22);
        if (v23)
          free(v23);
        CFRelease(v20);
      }
      else
      {
        v24 = sub_100030318();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
          sub_100091A60();
        if (qword_1000EBD40)
          v25 = (FILE *)qword_1000EBD40;
        else
          v25 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
      }
      *__error() = v15;
    }
    v28 = 0;
    qword_1000EB500 = 0;
  }
  if (byte_1000EBD38)
  {
    v0 = *__error();
    v1 = sub_100030318();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
      sub_1000919FC();
    *__error() = v0;
  }
  if (byte_1000EBD39)
    v2 = dword_1000EB4E8 <= 0;
  else
    v2 = 0;
  if (v2)
  {
    v3 = *__error();
    v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Memory pressure %d"), v28);
    if (v4)
    {
      v5 = v4;
      v6 = CFStringGetCStringPtr(v4, 0x8000100u);
      if (v6)
      {
        v7 = (char *)v6;
        v8 = 0;
      }
      else
      {
        v7 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD26F3BEuLL);
        CFStringGetCString(v5, v7, 1024, 0x8000100u);
        v8 = v7;
      }
      if (qword_1000EBD40)
        v11 = (FILE *)qword_1000EBD40;
      else
        v11 = __stderrp;
      fprintf(v11, "%s\n", v7);
      if (v8)
        free(v8);
      CFRelease(v5);
    }
    else
    {
      v9 = sub_100030318();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_FAULT))
        sub_100091994();
      if (qword_1000EBD40)
        v10 = (FILE *)qword_1000EBD40;
      else
        v10 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v10);
    }
    *__error() = v3;
  }
  return v28 > 3;
}

void sub_10005F2B4(id a1)
{
  int v1;
  NSObject *v2;
  BOOL v3;
  uint64_t v4;
  int *v5;
  char *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  FILE *v12;
  FILE *v13;
  const __CFString *theString;
  int v15;

  if (sysctlnametomib("kern.memorystatus_vm_pressure_level", dword_1000EBC90, (size_t *)&qword_1000EB500))
  {
    v1 = *__error();
    v2 = sub_100030318();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_FAULT))
      sub_100091BB0();
    *__error() = v1;
    if (byte_1000EBD39)
      v3 = dword_1000EB4E8 <= 4;
    else
      v3 = 0;
    if (v3)
    {
      v15 = *__error();
      v4 = *__error();
      v5 = __error();
      v6 = strerror(*v5);
      v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)"), v4, v6);
      if (v7)
      {
        theString = v7;
        CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
        if (CStringPtr)
        {
          v9 = (char *)CStringPtr;
          v10 = 0;
        }
        else
        {
          v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCAABF600uLL);
          CFStringGetCString(theString, v9, 1024, 0x8000100u);
          v10 = v9;
        }
        if (qword_1000EBD40)
          v13 = (FILE *)qword_1000EBD40;
        else
          v13 = __stderrp;
        fprintf(v13, "%s\n", v9);
        if (v10)
          free(v10);
        CFRelease(theString);
      }
      else
      {
        v11 = sub_100030318();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
          sub_100091B40();
        if (qword_1000EBD40)
          v12 = (FILE *)qword_1000EBD40;
        else
          v12 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
      }
      *__error() = v15;
    }
    qword_1000EB500 = 0;
  }
}

void sub_10005F498()
{
  int v0;
  NSObject *v1;
  BOOL v2;
  int v3;
  uint64_t v4;
  const __CFString *v5;
  NSObject *v6;
  FILE *v7;
  const __CFString *v8;
  const char *CStringPtr;
  char *v10;
  FILE *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  if (geteuid())
  {
    if (byte_1000EBD38)
    {
      v0 = *__error();
      v1 = sub_100030318();
      if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
        sub_100091C98();
      *__error() = v0;
    }
    if (byte_1000EBD39)
      v2 = dword_1000EB4E8 <= 3;
    else
      v2 = 0;
    if (v2)
    {
      v3 = *__error();
      v4 = geteuid();
      v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: spindump must run as root to create spindump directory (running as %d)"), "geteuid() == 0", v4);
      if (v5)
      {
        v8 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (CStringPtr)
        {
          v10 = 0;
        }
        else
        {
          v10 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1BA0901DuLL);
          CFStringGetCString(v8, v10, 1024, 0x8000100u);
          CStringPtr = v10;
        }
        v11 = (FILE *)qword_1000EBD40;
        if (!qword_1000EBD40)
          v11 = __stderrp;
        fprintf(v11, "%s\n", CStringPtr);
        if (v10)
          free(v10);
        CFRelease(v8);
      }
      else
      {
        v6 = sub_100030318();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
          sub_100091C20();
        if (qword_1000EBD40)
          v7 = (FILE *)qword_1000EBD40;
        else
          v7 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v7);
      }
      *__error() = v3;
    }
    geteuid();
    sub_1000301F0("MakeSpindumpDirectory", "spindump.m", 4222, "%s: spindump must run as root to create spindump directory (running as %d)", v12, v13, v14, v15, (char)"geteuid() == 0");
    abort();
  }
  if (qword_1000EBCA8 != -1)
    dispatch_once(&qword_1000EBCA8, &stru_1000DD7E0);
}

void sub_10005F6B8(id a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  NSObject *v7;
  BOOL v8;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *v12;
  char *v13;
  char *v14;
  int v15;
  NSObject *v16;
  uint64_t v17;
  uint64_t v18;
  BOOL v19;
  int v20;
  const __CFString *v21;
  NSObject *v22;
  uint64_t v23;
  uint64_t v24;
  FILE *v25;
  NSObject *v26;
  FILE *v27;
  FILE *v28;
  int v29;
  NSObject *v30;
  int v31;
  char *v32;
  uint64_t v33;
  int *v34;
  char *v35;
  const __CFString *v36;
  NSObject *v37;
  FILE *v38;
  const __CFString *v39;
  const char *v40;
  char *v41;
  char *v42;
  const __CFString *v43;
  const char *CStringPtr;
  char *v45;
  char *v46;
  FILE *v47;
  int *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  FILE *v53;
  stat v54;

  memset(&v54, 0, sizeof(v54));
  if (!stat("/private/var/db/spindump", &v54))
  {
    if ((v54.st_mode & 0xF000) == 0x4000)
      return;
    if (byte_1000EBD38)
    {
      v15 = *__error();
      v16 = sub_100030318();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        sub_100091D84(v16, v17, v18);
      *__error() = v15;
    }
    if (byte_1000EBD39)
      v19 = dword_1000EB4E8 <= 3;
    else
      v19 = 0;
    if (v19)
    {
      v20 = *__error();
      v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: /private/var/db/spindump already exists and isnt a directory!"), "(((st.st_mode) & 0170000) == 0040000)");
      if (v21)
      {
        v43 = v21;
        CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
        if (CStringPtr)
        {
          v45 = (char *)CStringPtr;
          v46 = 0;
        }
        else
        {
          v45 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5916B7BuLL);
          CFStringGetCString(v43, v45, 1024, 0x8000100u);
          v46 = v45;
        }
        if (qword_1000EBD40)
          v53 = (FILE *)qword_1000EBD40;
        else
          v53 = __stderrp;
        fprintf(v53, "%s\n", v45);
        if (v46)
          free(v46);
        CFRelease(v43);
      }
      else
      {
        v22 = sub_100030318();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
          sub_100091D10(v22, v23, v24);
        if (qword_1000EBD40)
          v25 = (FILE *)qword_1000EBD40;
        else
          v25 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v25);
      }
      *__error() = v20;
    }
    sub_1000301F0("MakeSpindumpDirectory_block_invoke", "spindump.m", 4237, "%s: /private/var/db/spindump already exists and isnt a directory!", v1, v2, v3, v4, (char)"(((st.st_mode) & 0170000) == 0040000)");
LABEL_82:
    abort();
  }
  v5 = *__error();
  if (byte_1000EBD38)
  {
    v6 = *__error();
    v7 = sub_100030318();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      sub_100091F84();
    *__error() = v6;
  }
  if (byte_1000EBD39)
    v8 = dword_1000EB4E8 <= 0;
  else
    v8 = 0;
  if (v8)
  {
    v9 = *__error();
    v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Creating spindump directory /private/var/db/spindump after stat said %d"), v5);
    if (v10)
    {
      v11 = v10;
      v12 = CFStringGetCStringPtr(v10, 0x8000100u);
      if (v12)
      {
        v13 = (char *)v12;
        v14 = 0;
      }
      else
      {
        v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5916B7BuLL);
        CFStringGetCString(v11, v13, 1024, 0x8000100u);
        v14 = v13;
      }
      if (qword_1000EBD40)
        v28 = (FILE *)qword_1000EBD40;
      else
        v28 = __stderrp;
      fprintf(v28, "%s\n", v13);
      if (v14)
        free(v14);
      CFRelease(v11);
    }
    else
    {
      v26 = sub_100030318();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
        sub_100091F20();
      if (qword_1000EBD40)
        v27 = (FILE *)qword_1000EBD40;
      else
        v27 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v27);
    }
    *__error() = v9;
  }
  if (mkdir("/private/var/db/spindump", 0x1EDu))
  {
    if (byte_1000EBD38)
    {
      v29 = *__error();
      v30 = sub_100030318();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        sub_100091E8C();
      *__error() = v29;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v31 = *__error();
      v32 = strerror(v5);
      v33 = *__error();
      v34 = __error();
      v35 = strerror(*v34);
      v36 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)"), "ret == 0", v5, v32, v33, v35);
      if (v36)
      {
        v39 = v36;
        v40 = CFStringGetCStringPtr(v36, 0x8000100u);
        if (v40)
        {
          v41 = (char *)v40;
          v42 = 0;
        }
        else
        {
          v41 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD5916B7BuLL);
          CFStringGetCString(v39, v41, 1024, 0x8000100u);
          v42 = v41;
        }
        if (qword_1000EBD40)
          v47 = (FILE *)qword_1000EBD40;
        else
          v47 = __stderrp;
        fprintf(v47, "%s\n", v41);
        if (v42)
          free(v42);
        CFRelease(v39);
      }
      else
      {
        v37 = sub_100030318();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
          sub_100091DF8();
        if (qword_1000EBD40)
          v38 = (FILE *)qword_1000EBD40;
        else
          v38 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v38);
      }
      *__error() = v31;
    }
    strerror(v5);
    __error();
    v48 = __error();
    strerror(*v48);
    sub_1000301F0("MakeSpindumpDirectory_block_invoke", "spindump.m", 4234, "%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)", v49, v50, v51, v52, (char)"ret == 0");
    goto LABEL_82;
  }
}

ssize_t sub_10005FC88(ssize_t result)
{
  void *v1;
  ssize_t v2;

  v1 = *(void **)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24);
  if (v1)
  {
    v2 = result;
    result = read(*(_DWORD *)(result + 48), v1, 0x3FFuLL);
    if (result >= 1)
    {
      do
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24) + result) = 0;
        objc_msgSend(*(id *)(v2 + 32), "appendFormat:", CFSTR("%s"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24));
        result = read(*(_DWORD *)(v2 + 48), *(void **)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24), 0x3FFuLL);
      }
      while (result > 0);
    }
  }
  return result;
}

void sub_10005FD20(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

ssize_t sub_10005FD48(ssize_t result)
{
  void *v1;
  ssize_t v2;

  v1 = *(void **)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24);
  if (v1)
  {
    v2 = result;
    result = read(*(_DWORD *)(result + 48), v1, 0x3FFuLL);
    if (result >= 1)
    {
      do
      {
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24) + result) = 0;
        objc_msgSend(*(id *)(v2 + 32), "appendFormat:", CFSTR("%s"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24));
        result = read(*(_DWORD *)(v2 + 48), *(void **)(*(_QWORD *)(*(_QWORD *)(v2 + 40) + 8) + 24), 0x3FFuLL);
      }
      while (result > 0);
    }
  }
  return result;
}

void sub_10005FDE0(uint64_t a1)
{
  close(*(_DWORD *)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

uint64_t sub_10005FE08(uint64_t a1)
{
  ssize_t v2;
  ssize_t v3;
  int v5;

  v5 = 0;
  while (waitpid(*(_DWORD *)(a1 + 80), &v5, 0) == -1 && *__error() == 4)
    ;
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 32));
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 40));
  dispatch_source_cancel(*(dispatch_source_t *)(a1 + 48));
  fcntl(*(_DWORD *)(a1 + 84), 4, 0);
  fcntl(*(_DWORD *)(a1 + 88), 4, 0);
  v2 = read(*(_DWORD *)(a1 + 84), *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24), 0x3FFuLL);
  if (v2 >= 1)
  {
    do
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) + v2) = 0;
      objc_msgSend(*(id *)(a1 + 56), "appendFormat:", CFSTR("%s"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24));
      v2 = read(*(_DWORD *)(a1 + 84), *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24), 0x3FFuLL);
    }
    while (v2 > 0);
  }
  v3 = read(*(_DWORD *)(a1 + 88), *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24), 0x3FFuLL);
  if (v3 >= 1)
  {
    do
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) + v3) = 0;
      objc_msgSend(*(id *)(a1 + 56), "appendFormat:", CFSTR("%s"), *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24));
      v3 = read(*(_DWORD *)(a1 + 88), *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24), 0x3FFuLL);
    }
    while (v3 > 0);
  }
  free(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24));
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 8) + 24) = 0;
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 64) + 16))();
}

void sub_10005FFA0(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)(a1 + 32));
}

_DWORD *sub_10005FFDC(_QWORD *a1, int *a2)
{
  return sub_1000302B4(*(_DWORD *)(*a1 + 4 * *a2));
}

id sub_100060024()
{
  void *v0;

  return objc_msgSend(v0, "macf");
}

id sub_10006002C()
{
  void *v0;

  return objc_msgSend(v0, "timer");
}

id sub_100060034()
{
  void *v0;

  return objc_msgSend(v0, "pmi");
}

id sub_10006003C()
{
  void *v0;

  return objc_msgSend(v0, "interrupt");
}

id sub_100060044()
{
  void *v0;

  return objc_msgSend(v0, "unknown_type");
}

id sub_10006004C()
{
  void *v0;

  return objc_msgSend(v0, "io");
}

void sub_100060054(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void sub_10006008C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 8u);
}

id sub_100060098(void *a1, const char *a2)
{
  return objc_msgSend(a1, "total");
}

uintptr_t sub_1000600A0(dispatch_source_t source)
{
  return dispatch_source_get_handle(source);
}

int *sub_1000600B8()
{
  return __error();
}

uint64_t sub_1000600C0(int a1, FILE *a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  return ferror(a2);
}

void sub_100060C24(id a1, void *a2, unint64_t a3)
{
  munmap(a2, a3);
}

void sub_100060C48(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

void sub_100060C54(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

double sub_1000612A4(void *a1, void *a2)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;

  objc_msgSend(a1, "machAbsTimeSeconds");
  if (v4 != 0.0)
  {
    objc_msgSend(a2, "machAbsTimeSeconds");
    if (v5 != 0.0)
    {
      objc_msgSend(a2, "machAbsTimeSeconds");
      v7 = v6;
      objc_msgSend(a1, "machAbsTimeSeconds");
      return v7 - v8;
    }
  }
  objc_msgSend(a1, "machContTimeSeconds");
  if (v9 != 0.0)
  {
    objc_msgSend(a2, "machContTimeSeconds");
    if (v10 != 0.0)
    {
      objc_msgSend(a2, "machContTimeSeconds");
      v7 = v11;
      objc_msgSend(a1, "machContTimeSeconds");
      return v7 - v8;
    }
  }
  objc_msgSend(a1, "wallTime");
  v12 = 0.0;
  if (v13 != 0.0)
  {
    objc_msgSend(a2, "wallTime");
    if (v14 != 0.0)
    {
      objc_msgSend(a2, "wallTime");
      v7 = v15;
      objc_msgSend(a1, "wallTime");
      return v7 - v8;
    }
  }
  return v12;
}

void sub_1000631B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000631C8(id a1)
{
  NSObject *v1;

  qword_1000EBCB8 = (uint64_t)objc_alloc_init((Class)NSMutableDictionary);
  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000EBCC0 = (uint64_t)dispatch_queue_create("com.apple.spindump.create_sampled_process", v1);
  dispatch_release(v1);
}

void sub_100063220(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_100063230(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

id sub_10006323C(uint64_t a1)
{
  id result;
  _BYTE *v3;
  uint64_t v4;
  _BYTE *v5;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = objc_msgSend((id)qword_1000EBCB8, "objectForKey:", *(_QWORD *)(a1 + 32));
  result = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
  if (result)
  {
    v3 = *(_BYTE **)(a1 + 48);
    if (v3)
    {
      *v3 = 1;
      result = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40);
    }
    result = objc_msgSend(result, "isWSBased");
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    if (*(unsigned __int8 *)(a1 + 61) == (_DWORD)result)
      return *(id *)(v4 + 40);
    else
      *(_QWORD *)(v4 + 40) = 0;
  }
  else
  {
    if (*(_BYTE *)(a1 + 60))
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = -[SPSampledProcess initWithPid:isWSBased:]([SPSampledProcess alloc], "initWithPid:isWSBased:", *(unsigned int *)(a1 + 56), *(unsigned __int8 *)(a1 + 61));
      result = objc_msgSend((id)qword_1000EBCB8, "setObject:forKey:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40), *(_QWORD *)(a1 + 32));
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) + 299) = 1;
    }
    v5 = *(_BYTE **)(a1 + 48);
    if (v5)
      *v5 = 0;
  }
  return result;
}

id sub_1000633AC(uint64_t a1)
{
  id v2;
  id v3;
  id result;

  v2 = objc_msgSend(objc_alloc((Class)NSNumber), "initWithInt:", *(unsigned int *)(a1 + 40));
  v3 = *(id *)(a1 + 32);
  if (v3 == objc_msgSend((id)qword_1000EBCB8, "objectForKey:", v2))
    objc_msgSend((id)qword_1000EBCB8, "removeObjectForKey:", v2);

  result = objc_msgSend((id)qword_1000EBCB8, "count");
  if (!result)
    return +[SPSampledProcess stopMemoryPressureTimer](SPSampledProcess, "stopMemoryPressureTimer");
  return result;
}

id sub_1000637D4(uint64_t a1)
{
  id *v1;
  int v2;
  NSObject *v3;
  _DWORD *v4;
  int v5;
  BOOL v6;
  int v7;
  _DWORD *v8;
  const __CFString *v9;
  NSObject *v10;
  int v11;
  NSObject *v12;
  BOOL v13;
  const __CFString *v14;
  const char *CStringPtr;
  char *v16;
  char *v17;
  FILE *v18;
  NSObject *v19;
  FILE *v20;
  _QWORD v22[5];
  uint8_t buf[4];
  _DWORD *v24;
  __int16 v25;
  int v26;

  v1 = (id *)(a1 + 32);
  if ((*(_DWORD *)(*(_QWORD *)(a1 + 32) + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
      {
        v4 = sub_1000302B4(*((_DWORD *)*v1 + 18));
        v5 = *((_DWORD *)*v1 + 18);
        *(_DWORD *)buf = 136446466;
        v24 = v4;
        v25 = 1024;
        v26 = v5;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "%{public}s [%d]: exited - HID", buf, 0x12u);
      }
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v6 = dword_1000EB4E8 <= 1;
    else
      v6 = 0;
    if (!v6)
      goto LABEL_40;
    v7 = *__error();
    v8 = sub_1000302B4(*((_DWORD *)*v1 + 18));
    v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: exited - HID"), v8, *((unsigned int *)*v1 + 18));
    if (!v9)
    {
      v10 = sub_100030318();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        sub_100092D64();
LABEL_35:
      if (qword_1000EBD40)
        v20 = (FILE *)qword_1000EBD40;
      else
        v20 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v20);
LABEL_39:
      *__error() = v7;
      goto LABEL_40;
    }
    goto LABEL_24;
  }
  if (byte_1000EBD38)
  {
    v11 = *__error();
    v12 = sub_100030318();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "exited - HID", buf, 2u);
    }
    *__error() = v11;
  }
  if (byte_1000EBD39)
    v13 = dword_1000EB4E8 <= 1;
  else
    v13 = 0;
  if (v13)
  {
    v7 = *__error();
    v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("exited - HID"));
    if (!v9)
    {
      v19 = sub_100030318();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
        sub_100092DD0();
      goto LABEL_35;
    }
LABEL_24:
    v14 = v9;
    CStringPtr = CFStringGetCStringPtr(v9, 0x8000100u);
    if (CStringPtr)
    {
      v16 = (char *)CStringPtr;
      v17 = 0;
    }
    else
    {
      v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB473D439uLL);
      CFStringGetCString(v14, v16, 1024, 0x8000100u);
      v17 = v16;
    }
    if (qword_1000EBD40)
      v18 = (FILE *)qword_1000EBD40;
    else
      v18 = __stderrp;
    fprintf(v18, "%s\n", v16);
    if (v17)
      free(v17);
    CFRelease(v14);
    goto LABEL_39;
  }
LABEL_40:
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_100063BB8;
  v22[3] = &unk_1000DD938;
  v22[4] = *v1;
  sub_100063B2C((uint64_t)v22);
  return objc_msgSend(*v1, "deleteHIDExitSource");
}

void sub_100063B2C(uint64_t a1)
{
  _QWORD block[5];

  if (qword_1000EBCD8 != -1)
    dispatch_once(&qword_1000EBCD8, &stru_1000DDAE8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10006E90C;
  block[3] = &unk_1000DDB10;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_1000EBCC8, block);
}

int *sub_100063BB8(uint64_t a1, void *a2)
{
  int **v3;
  int *result;
  int *v5;
  BOOL v6;
  int v7;
  NSObject *v8;
  BOOL v9;
  int v10;
  _DWORD *v11;
  const __CFString *v12;
  const __CFString *v13;
  const char *v14;
  char *v15;
  char *v16;
  int *v17;
  int v18;
  NSObject *v19;
  BOOL v20;
  int v21;
  _DWORD *v22;
  const __CFString *v23;
  NSObject *v24;
  int v25;
  NSObject *v26;
  BOOL v27;
  const __CFString *v28;
  const __CFString *v29;
  const char *v30;
  char *v31;
  char *v32;
  int v33;
  NSObject *v34;
  BOOL v35;
  const __CFString *v36;
  const char *CStringPtr;
  char *v38;
  char *v39;
  NSObject *v40;
  FILE *v41;
  FILE *v42;
  const __CFString *v43;
  NSObject *v44;
  FILE *v45;
  NSObject *v46;
  FILE *v47;
  FILE *v48;

  v3 = (int **)(a1 + 32);
  result = (int *)objc_msgSend(a2, "objectForKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(*(_QWORD *)(a1 + 32) + 72)));
  v5 = *v3;
  if (result)
    v6 = result == v5;
  else
    v6 = 0;
  if (v6)
  {
    v17 = result;
    if (result[18] < 0)
    {
      if (byte_1000EBD38)
      {
        v33 = *__error();
        v34 = sub_100030318();
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
          sub_100092F00();
        *__error() = v33;
      }
      if (byte_1000EBD39)
        v35 = dword_1000EB4E8 <= 0;
      else
        v35 = 0;
      if (!v35)
        goto LABEL_84;
      v21 = *__error();
      v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Process exited, no longer waiting for HID event"));
      if (!v23)
      {
        v46 = sub_100030318();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
          sub_100092ED4();
        goto LABEL_79;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v18 = *__error();
        v19 = sub_100030318();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          sub_100092E68();
        *__error() = v18;
      }
      if (byte_1000EBD39)
        v20 = dword_1000EB4E8 <= 0;
      else
        v20 = 0;
      if (!v20)
        goto LABEL_84;
      v21 = *__error();
      v22 = sub_1000302B4((*v3)[18]);
      v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Process exited, no longer waiting for HID event"), v22, (*v3)[18]);
      if (!v23)
      {
        v24 = sub_100030318();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_FAULT))
          sub_100092DFC();
LABEL_79:
        if (qword_1000EBD40)
          v47 = (FILE *)qword_1000EBD40;
        else
          v47 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v47);
LABEL_83:
        *__error() = v21;
LABEL_84:
        dispatch_semaphore_signal(*((dispatch_semaphore_t *)v17 + 53));
        return (int *)objc_msgSend(a2, "setObject:forKeyedSubscript:", 0, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", (*v3)[18]));
      }
    }
    v36 = v23;
    CStringPtr = CFStringGetCStringPtr(v23, 0x8000100u);
    if (CStringPtr)
    {
      v38 = (char *)CStringPtr;
      v39 = 0;
    }
    else
    {
      v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE906A8A2uLL);
      CFStringGetCString(v36, v38, 1024, 0x8000100u);
      v39 = v38;
    }
    if (qword_1000EBD40)
      v41 = (FILE *)qword_1000EBD40;
    else
      v41 = __stderrp;
    fprintf(v41, "%s\n", v38);
    if (v39)
      free(v39);
    CFRelease(v36);
    goto LABEL_83;
  }
  if ((v5[18] & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v7 = *__error();
      v8 = sub_100030318();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        sub_100092F98();
      result = __error();
      *result = v7;
    }
    if (byte_1000EBD39)
      v9 = dword_1000EB4E8 <= 0;
    else
      v9 = 0;
    if (!v9)
      return result;
    v10 = *__error();
    v11 = sub_1000302B4((*v3)[18]);
    v12 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Process exited, and not waiting for a HID event"), v11, (*v3)[18]);
    if (v12)
    {
      v13 = v12;
      v14 = CFStringGetCStringPtr(v12, 0x8000100u);
      if (v14)
      {
        v15 = (char *)v14;
        v16 = 0;
      }
      else
      {
        v15 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB89FEB8EuLL);
        CFStringGetCString(v13, v15, 1024, 0x8000100u);
        v16 = v15;
      }
      if (qword_1000EBD40)
        v42 = (FILE *)qword_1000EBD40;
      else
        v42 = __stderrp;
      fprintf(v42, "%s\n", v15);
      if (v16)
        free(v16);
      v43 = v13;
LABEL_92:
      CFRelease(v43);
LABEL_93:
      result = __error();
      *result = v10;
      return result;
    }
    v40 = sub_100030318();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
      sub_100092F2C();
    goto LABEL_73;
  }
  if (byte_1000EBD38)
  {
    v25 = *__error();
    v26 = sub_100030318();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
      sub_100093030();
    result = __error();
    *result = v25;
  }
  if (byte_1000EBD39)
    v27 = dword_1000EB4E8 <= 0;
  else
    v27 = 0;
  if (v27)
  {
    v10 = *__error();
    v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Process exited, and not waiting for a HID event"));
    if (v28)
    {
      v29 = v28;
      v30 = CFStringGetCStringPtr(v28, 0x8000100u);
      if (v30)
      {
        v31 = (char *)v30;
        v32 = 0;
      }
      else
      {
        v31 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB89FEB8EuLL);
        CFStringGetCString(v29, v31, 1024, 0x8000100u);
        v32 = v31;
      }
      if (qword_1000EBD40)
        v48 = (FILE *)qword_1000EBD40;
      else
        v48 = __stderrp;
      fprintf(v48, "%s\n", v31);
      if (v32)
        free(v32);
      v43 = v29;
      goto LABEL_92;
    }
    v44 = sub_100030318();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
      sub_100093004();
LABEL_73:
    if (qword_1000EBD40)
      v45 = (FILE *)qword_1000EBD40;
    else
      v45 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v45);
    goto LABEL_93;
  }
  return result;
}

void sub_10006421C(uint64_t a1)
{
  _QWORD v1[5];
  char v2;

  v1[0] = _NSConcreteStackBlock;
  v1[1] = 3221225472;
  v1[2] = sub_100064278;
  v1[3] = &unk_1000DD960;
  v1[4] = *(_QWORD *)(a1 + 32);
  v2 = *(_BYTE *)(a1 + 40);
  sub_100063B2C((uint64_t)v1);
}

int *sub_100064278(uint64_t a1, void *a2)
{
  int **v3;
  int *result;
  int *v5;
  int v6;
  NSObject *v7;
  _DWORD *v8;
  int v9;
  BOOL v10;
  int v11;
  _DWORD *v12;
  const __CFString *v13;
  NSObject *v14;
  int v15;
  NSObject *v16;
  BOOL v17;
  int v18;
  _DWORD *v19;
  const __CFString *v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  BOOL v24;
  int v25;
  _DWORD *v26;
  const __CFString *v27;
  NSObject *v28;
  int v29;
  NSObject *v30;
  BOOL v31;
  int v32;
  _DWORD *v33;
  const __CFString *v34;
  const __CFString *v35;
  const char *v36;
  char *v37;
  char *v38;
  int v39;
  NSObject *v40;
  BOOL v41;
  int v42;
  _DWORD *v43;
  const __CFString *v44;
  NSObject *v45;
  int v46;
  NSObject *v47;
  BOOL v48;
  const __CFString *v49;
  const char *v50;
  char *v51;
  char *v52;
  int v53;
  NSObject *v54;
  BOOL v55;
  int v56;
  _DWORD *v57;
  const __CFString *v58;
  NSObject *v59;
  int v60;
  NSObject *v61;
  BOOL v62;
  const __CFString *v63;
  const char *v64;
  char *v65;
  char *v66;
  int v67;
  NSObject *v68;
  BOOL v69;
  const __CFString *v70;
  const char *v71;
  char *v72;
  char *v73;
  int v74;
  NSObject *v75;
  BOOL v76;
  const __CFString *v77;
  const __CFString *v78;
  const char *v79;
  char *v80;
  char *v81;
  int v82;
  NSObject *v83;
  BOOL v84;
  const __CFString *v85;
  const char *v86;
  char *v87;
  char *v88;
  int v89;
  NSObject *v90;
  BOOL v91;
  const __CFString *v92;
  const char *v93;
  char *v94;
  char *v95;
  FILE *v96;
  FILE *v97;
  NSObject *v98;
  NSObject *v99;
  FILE *v100;
  FILE *v101;
  NSObject *v102;
  FILE *v103;
  FILE *v104;
  FILE *v105;
  const __CFString *v106;
  NSObject *v107;
  FILE *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  NSObject *v114;
  int v115;
  _DWORD *v116;
  const __CFString *v117;
  NSObject *v118;
  FILE *v119;
  NSObject *v120;
  FILE *v121;
  FILE *v122;
  NSObject *v123;
  FILE *v124;
  int v125;
  NSObject *v126;
  int v127;
  _DWORD *v128;
  const __CFString *v129;
  NSObject *v130;
  FILE *v131;
  FILE *v132;
  NSObject *v133;
  FILE *v134;
  int v135;
  NSObject *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  const __CFString *v145;
  NSObject *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  FILE *v154;
  int v155;
  NSObject *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  int v164;
  const __CFString *v165;
  NSObject *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  FILE *v174;
  const __CFString *v175;
  const char *v176;
  char *v177;
  char *v178;
  const __CFString *v179;
  const char *CStringPtr;
  char *v181;
  char *v182;
  const __CFString *v183;
  const char *v184;
  char *v185;
  char *v186;
  const __CFString *v187;
  const char *v188;
  char *v189;
  char *v190;
  FILE *v191;
  unsigned __int8 v192;
  const char *v193;
  FILE *v194;
  int v195;
  FILE *v196;
  unsigned __int8 v197;
  FILE *v198;
  const char *v199;
  uint8_t buf[4];
  _DWORD *v201;
  __int16 v202;
  int v203;

  v3 = (int **)(a1 + 32);
  result = (int *)objc_msgSend(a2, "objectForKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(*(id *)(a1 + 32), "targetProcessId")));
  v5 = *v3;
  if (!*((_BYTE *)v3 + 8))
  {
    if (result)
    {
      if (result != v5)
      {
        if (v5[18] < 0)
        {
          if (byte_1000EBD38)
          {
            v67 = *__error();
            v68 = sub_100030318();
            if (os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
              sub_100093780();
            *__error() = v67;
          }
          if (byte_1000EBD39)
            v69 = dword_1000EB4E8 <= 0;
          else
            v69 = 0;
          if (!v69)
            goto LABEL_216;
          v18 = *__error();
          v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Previous spin waiting for HID event"));
          if (!v20)
          {
            v107 = sub_100030318();
            if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT))
              sub_100093754();
            goto LABEL_211;
          }
        }
        else
        {
          if (byte_1000EBD38)
          {
            v15 = *__error();
            v16 = sub_100030318();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
              sub_1000936E8();
            *__error() = v15;
          }
          if (byte_1000EBD39)
            v17 = dword_1000EB4E8 <= 0;
          else
            v17 = 0;
          if (!v17)
            goto LABEL_216;
          v18 = *__error();
          v19 = sub_1000302B4((*v3)[18]);
          v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Previous spin waiting for HID event"), v19, (*v3)[18]);
          if (!v20)
          {
            v21 = sub_100030318();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
              sub_10009367C();
LABEL_211:
            if (qword_1000EBD40)
              v108 = (FILE *)qword_1000EBD40;
            else
              v108 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v108);
LABEL_215:
            *__error() = v18;
LABEL_216:
            result = *v3;
            if (!*((_QWORD *)*v3 + 53))
              return result;
            if ((objc_msgSend(result, "targetProcessId") & 0x80000000) != 0)
            {
              if (byte_1000EBD38)
              {
                v135 = *__error();
                v136 = sub_100030318();
                if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
                  sub_10009360C(v136, v137, v138, v139, v140, v141, v142, v143);
                *__error() = v135;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v144 = *__error();
                v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: _hidEventSem non-NULL when already tracking this process in previous spin"), "_hidEventSem == NULL");
                if (v145)
                {
                  v179 = v145;
                  CStringPtr = CFStringGetCStringPtr(v145, 0x8000100u);
                  if (CStringPtr)
                  {
                    v181 = (char *)CStringPtr;
                    v182 = 0;
                  }
                  else
                  {
                    v181 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x81381D63uLL);
                    CFStringGetCString(v179, v181, 1024, 0x8000100u);
                    v182 = v181;
                  }
                  if (qword_1000EBD40)
                    v194 = (FILE *)qword_1000EBD40;
                  else
                    v194 = __stderrp;
                  fprintf(v194, "%s\n", v181);
                  if (v182)
                    free(v182);
                  CFRelease(v179);
                }
                else
                {
                  v146 = sub_100030318();
                  if (os_log_type_enabled(v146, OS_LOG_TYPE_FAULT))
                    sub_10009359C(v146, v147, v148, v149, v150, v151, v152, v153);
                  if (qword_1000EBD40)
                    v154 = (FILE *)qword_1000EBD40;
                  else
                    v154 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v154);
                }
                *__error() = v144;
              }
              v199 = "_hidEventSem == NULL";
              v193 = "%s: _hidEventSem non-NULL when already tracking this process in previous spin";
            }
            else
            {
              if (byte_1000EBD38)
              {
                v113 = *__error();
                v114 = sub_100030318();
                if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
                  sub_10009351C();
                *__error() = v113;
              }
              if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
              {
                v115 = *__error();
                v116 = sub_1000302B4((int)objc_msgSend(*v3, "targetProcessId"));
                v117 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin"), v116, objc_msgSend(*v3, "targetProcessId"), "_hidEventSem == NULL");
                if (v117)
                {
                  v175 = v117;
                  v176 = CFStringGetCStringPtr(v117, 0x8000100u);
                  if (v176)
                  {
                    v177 = (char *)v176;
                    v178 = 0;
                  }
                  else
                  {
                    v177 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x81381D63uLL);
                    CFStringGetCString(v175, v177, 1024, 0x8000100u);
                    v178 = v177;
                  }
                  if (qword_1000EBD40)
                    v191 = (FILE *)qword_1000EBD40;
                  else
                    v191 = __stderrp;
                  fprintf(v191, "%s\n", v177);
                  if (v178)
                    free(v178);
                  CFRelease(v175);
                }
                else
                {
                  v118 = sub_100030318();
                  if (os_log_type_enabled(v118, OS_LOG_TYPE_FAULT))
                    sub_10009349C();
                  if (qword_1000EBD40)
                    v119 = (FILE *)qword_1000EBD40;
                  else
                    v119 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v119);
                }
                *__error() = v115;
              }
              v192 = sub_1000302B4((int)objc_msgSend(*v3, "targetProcessId"));
              objc_msgSend(*v3, "targetProcessId");
              LOBYTE(v199) = v192;
              v193 = "%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin";
            }
            v195 = 951;
            goto LABEL_356;
          }
        }
        v70 = v20;
        v71 = CFStringGetCStringPtr(v20, 0x8000100u);
        if (v71)
        {
          v72 = (char *)v71;
          v73 = 0;
        }
        else
        {
          v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6906A0A6uLL);
          CFStringGetCString(v70, v72, 1024, 0x8000100u);
          v73 = v72;
        }
        if (qword_1000EBD40)
          v101 = (FILE *)qword_1000EBD40;
        else
          v101 = __stderrp;
        fprintf(v101, "%s\n", v72);
        if (v73)
          free(v73);
        CFRelease(v70);
        goto LABEL_215;
      }
      if (result[18] < 0)
      {
        if (byte_1000EBD38)
        {
          v89 = *__error();
          v90 = sub_100030318();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEBUG))
            sub_100093470();
          *__error() = v89;
        }
        if (byte_1000EBD39)
          v91 = dword_1000EB4E8 <= 0;
        else
          v91 = 0;
        if (!v91)
          goto LABEL_282;
        v56 = *__error();
        v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No longer waiting for HID event"));
        if (!v58)
        {
          v133 = sub_100030318();
          if (os_log_type_enabled(v133, OS_LOG_TYPE_FAULT))
            sub_100093444();
          goto LABEL_277;
        }
      }
      else
      {
        if (byte_1000EBD38)
        {
          v53 = *__error();
          v54 = sub_100030318();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
            sub_1000933D8();
          *__error() = v53;
        }
        if (byte_1000EBD39)
          v55 = dword_1000EB4E8 <= 0;
        else
          v55 = 0;
        if (!v55)
          goto LABEL_282;
        v56 = *__error();
        v57 = sub_1000302B4((*v3)[18]);
        v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: No longer waiting for HID event"), v57, (*v3)[18]);
        if (!v58)
        {
          v59 = sub_100030318();
          if (os_log_type_enabled(v59, OS_LOG_TYPE_FAULT))
            sub_10009336C();
LABEL_277:
          if (qword_1000EBD40)
            v134 = (FILE *)qword_1000EBD40;
          else
            v134 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v134);
LABEL_281:
          *__error() = v56;
LABEL_282:
          dispatch_semaphore_signal(*((dispatch_semaphore_t *)*v3 + 53));
          dispatch_release(*((dispatch_object_t *)*v3 + 53));
          *((_QWORD *)*v3 + 53) = 0;
          objc_msgSend(a2, "setObject:forKeyedSubscript:", 0, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(*v3, "targetProcessId")));
          return (int *)objc_msgSend(*v3, "deleteHIDExitSource");
        }
      }
      v92 = v58;
      v93 = CFStringGetCStringPtr(v58, 0x8000100u);
      if (v93)
      {
        v94 = (char *)v93;
        v95 = 0;
      }
      else
      {
        v94 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFAF3B7D1uLL);
        CFStringGetCString(v92, v94, 1024, 0x8000100u);
        v95 = v94;
      }
      if (qword_1000EBD40)
        v122 = (FILE *)qword_1000EBD40;
      else
        v122 = __stderrp;
      fprintf(v122, "%s\n", v94);
      if (v95)
        free(v95);
      CFRelease(v92);
      goto LABEL_281;
    }
    if (v5[18] < 0)
    {
      if (byte_1000EBD38)
      {
        v82 = *__error();
        v83 = sub_100030318();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_DEBUG))
          sub_100093340();
        *__error() = v82;
      }
      if (byte_1000EBD39)
        v84 = dword_1000EB4E8 <= 0;
      else
        v84 = 0;
      if (!v84)
        goto LABEL_251;
      v42 = *__error();
      v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Doesn't require HID event and we weren't waiting before anyway"));
      if (!v44)
      {
        v123 = sub_100030318();
        if (os_log_type_enabled(v123, OS_LOG_TYPE_FAULT))
          sub_100093314();
        goto LABEL_246;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v39 = *__error();
        v40 = sub_100030318();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
          sub_1000932A8();
        *__error() = v39;
      }
      if (byte_1000EBD39)
        v41 = dword_1000EB4E8 <= 0;
      else
        v41 = 0;
      if (!v41)
        goto LABEL_251;
      v42 = *__error();
      v43 = sub_1000302B4((*v3)[18]);
      v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Doesn't require HID event and we weren't waiting before anyway"), v43, (*v3)[18]);
      if (!v44)
      {
        v45 = sub_100030318();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
          sub_10009323C();
LABEL_246:
        if (qword_1000EBD40)
          v124 = (FILE *)qword_1000EBD40;
        else
          v124 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v124);
LABEL_250:
        *__error() = v42;
LABEL_251:
        result = *v3;
        if (!*((_QWORD *)*v3 + 53))
          return result;
        if ((objc_msgSend(result, "targetProcessId") & 0x80000000) != 0)
        {
          if (byte_1000EBD38)
          {
            v155 = *__error();
            v156 = sub_100030318();
            if (os_log_type_enabled(v156, OS_LOG_TYPE_ERROR))
              sub_1000931CC(v156, v157, v158, v159, v160, v161, v162, v163);
            *__error() = v155;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
          {
            v164 = *__error();
            v165 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: _hidEventSem non-NULL when not requiring HID event"), "_hidEventSem == NULL");
            if (v165)
            {
              v187 = v165;
              v188 = CFStringGetCStringPtr(v165, 0x8000100u);
              if (v188)
              {
                v189 = (char *)v188;
                v190 = 0;
              }
              else
              {
                v189 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x161961A5uLL);
                CFStringGetCString(v187, v189, 1024, 0x8000100u);
                v190 = v189;
              }
              if (qword_1000EBD40)
                v198 = (FILE *)qword_1000EBD40;
              else
                v198 = __stderrp;
              fprintf(v198, "%s\n", v189);
              if (v190)
                free(v190);
              CFRelease(v187);
            }
            else
            {
              v166 = sub_100030318();
              if (os_log_type_enabled(v166, OS_LOG_TYPE_FAULT))
                sub_10009315C(v166, v167, v168, v169, v170, v171, v172, v173);
              if (qword_1000EBD40)
                v174 = (FILE *)qword_1000EBD40;
              else
                v174 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v174);
            }
            *__error() = v164;
          }
          v199 = "_hidEventSem == NULL";
          v193 = "%s: _hidEventSem non-NULL when not requiring HID event";
        }
        else
        {
          if (byte_1000EBD38)
          {
            v125 = *__error();
            v126 = sub_100030318();
            if (os_log_type_enabled(v126, OS_LOG_TYPE_ERROR))
              sub_1000930DC();
            *__error() = v125;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
          {
            v127 = *__error();
            v128 = sub_1000302B4((int)objc_msgSend(*v3, "targetProcessId"));
            v129 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event"), v128, objc_msgSend(*v3, "targetProcessId"), "_hidEventSem == NULL");
            if (v129)
            {
              v183 = v129;
              v184 = CFStringGetCStringPtr(v129, 0x8000100u);
              if (v184)
              {
                v185 = (char *)v184;
                v186 = 0;
              }
              else
              {
                v185 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x161961A5uLL);
                CFStringGetCString(v183, v185, 1024, 0x8000100u);
                v186 = v185;
              }
              if (qword_1000EBD40)
                v196 = (FILE *)qword_1000EBD40;
              else
                v196 = __stderrp;
              fprintf(v196, "%s\n", v185);
              if (v186)
                free(v186);
              CFRelease(v183);
            }
            else
            {
              v130 = sub_100030318();
              if (os_log_type_enabled(v130, OS_LOG_TYPE_FAULT))
                sub_10009305C();
              if (qword_1000EBD40)
                v131 = (FILE *)qword_1000EBD40;
              else
                v131 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v131);
            }
            *__error() = v127;
          }
          v197 = sub_1000302B4((int)objc_msgSend(*v3, "targetProcessId"));
          objc_msgSend(*v3, "targetProcessId");
          LOBYTE(v199) = v197;
          v193 = "%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event";
        }
        v195 = 963;
LABEL_356:
        sub_1000301F0("-[SPSampledProcess requireHIDEvent:]_block_invoke", "SPProcessEvent.m", v195, v193, v109, v110, v111, v112, (char)v199);
        abort();
      }
    }
    v85 = v44;
    v86 = CFStringGetCStringPtr(v44, 0x8000100u);
    if (v86)
    {
      v87 = (char *)v86;
      v88 = 0;
    }
    else
    {
      v87 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8DBCFFB8uLL);
      CFStringGetCString(v85, v87, 1024, 0x8000100u);
      v88 = v87;
    }
    if (qword_1000EBD40)
      v104 = (FILE *)qword_1000EBD40;
    else
      v104 = __stderrp;
    fprintf(v104, "%s\n", v87);
    if (v88)
      free(v88);
    CFRelease(v85);
    goto LABEL_250;
  }
  if (!result)
  {
    if (v5[18] < 0)
    {
      if (byte_1000EBD38)
      {
        v60 = *__error();
        v61 = sub_100030318();
        if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
          sub_1000938B0();
        *__error() = v60;
      }
      if (byte_1000EBD39)
        v62 = dword_1000EB4E8 <= 0;
      else
        v62 = 0;
      if (!v62)
        goto LABEL_194;
      v25 = *__error();
      v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Requires HID event"));
      if (!v27)
      {
        v102 = sub_100030318();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT))
          sub_100093884();
        goto LABEL_189;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v22 = *__error();
        v23 = sub_100030318();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
          sub_100093818();
        *__error() = v22;
      }
      if (byte_1000EBD39)
        v24 = dword_1000EB4E8 <= 0;
      else
        v24 = 0;
      if (!v24)
        goto LABEL_194;
      v25 = *__error();
      v26 = sub_1000302B4((*v3)[18]);
      v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Requires HID event"), v26, (*v3)[18]);
      if (!v27)
      {
        v28 = sub_100030318();
        if (os_log_type_enabled(v28, OS_LOG_TYPE_FAULT))
          sub_1000937AC();
LABEL_189:
        if (qword_1000EBD40)
          v103 = (FILE *)qword_1000EBD40;
        else
          v103 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v103);
LABEL_193:
        *__error() = v25;
LABEL_194:
        *((_QWORD *)*v3 + 53) = dispatch_semaphore_create(0);
        objc_msgSend(a2, "setObject:forKeyedSubscript:", *v3, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", objc_msgSend(*v3, "targetProcessId")));
        return (int *)objc_msgSend(*v3, "createHIDExitSource");
      }
    }
    v63 = v27;
    v64 = CFStringGetCStringPtr(v27, 0x8000100u);
    if (v64)
    {
      v65 = (char *)v64;
      v66 = 0;
    }
    else
    {
      v65 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x75711560uLL);
      CFStringGetCString(v63, v65, 1024, 0x8000100u);
      v66 = v65;
    }
    if (qword_1000EBD40)
      v97 = (FILE *)qword_1000EBD40;
    else
      v97 = __stderrp;
    fprintf(v97, "%s\n", v65);
    if (v66)
      free(v66);
    CFRelease(v63);
    goto LABEL_193;
  }
  if (result != v5)
  {
    if (v5[18] < 0)
    {
      if (byte_1000EBD38)
      {
        v46 = *__error();
        v47 = sub_100030318();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Already waiting for HID event from previous spin, canceling this spin", buf, 2u);
        }
        *__error() = v46;
      }
      if (byte_1000EBD39)
        v48 = dword_1000EB4E8 <= 2;
      else
        v48 = 0;
      if (!v48)
        return (int *)objc_msgSend(*v3, "stopSamplingWithReason:", 7);
      v11 = *__error();
      v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Already waiting for HID event from previous spin, canceling this spin"));
      if (!v13)
      {
        v99 = sub_100030318();
        if (os_log_type_enabled(v99, OS_LOG_TYPE_FAULT))
          sub_100093A78();
        goto LABEL_174;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v6 = *__error();
        v7 = sub_100030318();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          v8 = sub_1000302B4((*v3)[18]);
          v9 = (*v3)[18];
          *(_DWORD *)buf = 136446466;
          v201 = v8;
          v202 = 1024;
          v203 = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: Already waiting for HID event from previous spin, canceling this spin", buf, 0x12u);
        }
        *__error() = v6;
      }
      if (byte_1000EBD39)
        v10 = dword_1000EB4E8 <= 2;
      else
        v10 = 0;
      if (!v10)
        return (int *)objc_msgSend(*v3, "stopSamplingWithReason:", 7);
      v11 = *__error();
      v12 = sub_1000302B4((*v3)[18]);
      v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Already waiting for HID event from previous spin, canceling this spin"), v12, (*v3)[18]);
      if (!v13)
      {
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_FAULT))
          sub_100093A0C();
LABEL_174:
        if (qword_1000EBD40)
          v100 = (FILE *)qword_1000EBD40;
        else
          v100 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v100);
LABEL_178:
        *__error() = v11;
        return (int *)objc_msgSend(*v3, "stopSamplingWithReason:", 7);
      }
    }
    v49 = v13;
    v50 = CFStringGetCStringPtr(v13, 0x8000100u);
    if (v50)
    {
      v51 = (char *)v50;
      v52 = 0;
    }
    else
    {
      v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x53D45D73uLL);
      CFStringGetCString(v49, v51, 1024, 0x8000100u);
      v52 = v51;
    }
    if (qword_1000EBD40)
      v96 = (FILE *)qword_1000EBD40;
    else
      v96 = __stderrp;
    fprintf(v96, "%s\n", v51);
    if (v52)
      free(v52);
    CFRelease(v49);
    goto LABEL_178;
  }
  if ((result[18] & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v29 = *__error();
      v30 = sub_100030318();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        sub_100093948();
      result = __error();
      *result = v29;
    }
    if (byte_1000EBD39)
      v31 = dword_1000EB4E8 <= 0;
    else
      v31 = 0;
    if (!v31)
      return result;
    v32 = *__error();
    v33 = sub_1000302B4((*v3)[18]);
    v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Already waiting for HID event"), v33, (*v3)[18]);
    if (v34)
    {
      v35 = v34;
      v36 = CFStringGetCStringPtr(v34, 0x8000100u);
      if (v36)
      {
        v37 = (char *)v36;
        v38 = 0;
      }
      else
      {
        v37 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD0A292AuLL);
        CFStringGetCString(v35, v37, 1024, 0x8000100u);
        v38 = v37;
      }
      if (qword_1000EBD40)
        v105 = (FILE *)qword_1000EBD40;
      else
        v105 = __stderrp;
      fprintf(v105, "%s\n", v37);
      if (v38)
        free(v38);
      v106 = v35;
LABEL_273:
      CFRelease(v106);
LABEL_274:
      result = __error();
      *result = v32;
      return result;
    }
    v98 = sub_100030318();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_FAULT))
      sub_1000938DC();
    goto LABEL_233;
  }
  if (byte_1000EBD38)
  {
    v74 = *__error();
    v75 = sub_100030318();
    if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
      sub_1000939E0();
    result = __error();
    *result = v74;
  }
  if (byte_1000EBD39)
    v76 = dword_1000EB4E8 <= 0;
  else
    v76 = 0;
  if (v76)
  {
    v32 = *__error();
    v77 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Already waiting for HID event"));
    if (v77)
    {
      v78 = v77;
      v79 = CFStringGetCStringPtr(v77, 0x8000100u);
      if (v79)
      {
        v80 = (char *)v79;
        v81 = 0;
      }
      else
      {
        v80 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xBD0A292AuLL);
        CFStringGetCString(v78, v80, 1024, 0x8000100u);
        v81 = v80;
      }
      if (qword_1000EBD40)
        v132 = (FILE *)qword_1000EBD40;
      else
        v132 = __stderrp;
      fprintf(v132, "%s\n", v80);
      if (v81)
        free(v81);
      v106 = v78;
      goto LABEL_273;
    }
    v120 = sub_100030318();
    if (os_log_type_enabled(v120, OS_LOG_TYPE_FAULT))
      sub_1000939B4();
LABEL_233:
    if (qword_1000EBD40)
      v121 = (FILE *)qword_1000EBD40;
    else
      v121 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v121);
    goto LABEL_274;
  }
  return result;
}

int *sub_100065A90(uint64_t a1, void *a2)
{
  unsigned int *v4;
  int *result;
  uint64_t v6;
  id *v7;
  int v8;
  NSObject *v9;
  BOOL v10;
  int v11;
  _DWORD *v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  const __CFString *v17;
  const __CFString *v18;
  const char *CStringPtr;
  char *v20;
  char *v21;
  int v22;
  NSObject *v23;
  BOOL v24;
  int v25;
  _DWORD *v26;
  const __CFString *v27;
  const __CFString *v28;
  const char *v29;
  char *v30;
  char *v31;
  int v32;
  NSObject *v33;
  _DWORD *v34;
  int v35;
  BOOL v36;
  int v37;
  _DWORD *v38;
  const __CFString *v39;
  const __CFString *v40;
  const char *v41;
  char *v42;
  char *v43;
  int v44;
  NSObject *v45;
  BOOL v46;
  int v47;
  const __CFString *v48;
  const __CFString *v49;
  const char *v50;
  char *v51;
  char *v52;
  int v53;
  NSObject *v54;
  BOOL v55;
  double v56;
  double v57;
  double v58;
  const __CFString *v59;
  const __CFString *v60;
  const char *v61;
  char *v62;
  char *v63;
  int v64;
  NSObject *v65;
  BOOL v66;
  const __CFString *v67;
  const __CFString *v68;
  const char *v69;
  char *v70;
  char *v71;
  NSObject *v72;
  FILE *v73;
  NSObject *v74;
  FILE *v75;
  NSObject *v76;
  FILE *v77;
  NSObject *v78;
  FILE *v79;
  FILE *v80;
  const __CFString *v81;
  NSObject *v82;
  FILE *v83;
  NSObject *v84;
  FILE *v85;
  FILE *v86;
  const __CFString *v87;
  FILE *v88;
  FILE *v89;
  _DWORD *v90;
  int v91;
  double v92;
  double v93;
  double v94;
  _DWORD *v95;
  int v96;
  double v97;
  double v98;
  double v99;
  uint8_t buf[4];
  _DWORD *v101;
  __int16 v102;
  int v103;
  __int16 v104;
  double v105;

  v4 = (unsigned int *)(a1 + 64);
  result = (int *)objc_msgSend(a2, "objectForKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 64)));
  if (result)
  {
    v6 = (uint64_t)result;
    v7 = (id *)(a1 + 32);
    result = (int *)objc_msgSend(*((id *)result + 52), "gt:", *(_QWORD *)(a1 + 32));
    if ((_DWORD)result)
    {
      if ((*v4 & 0x80000000) == 0)
      {
        if (byte_1000EBD38)
        {
          v8 = *__error();
          v9 = sub_100030318();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
          {
            v90 = sub_1000302B4(*v4);
            v91 = *v4;
            objc_msgSend(*(id *)(v6 + 416), "machAbsTimeSeconds");
            v93 = v92;
            objc_msgSend(*v7, "machAbsTimeSeconds");
            *(_DWORD *)buf = 136446722;
            v101 = v90;
            v102 = 1024;
            v103 = v91;
            v104 = 2048;
            v105 = v93 - v94;
            _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", buf, 0x1Cu);
          }
          result = __error();
          *result = v8;
        }
        if (byte_1000EBD39)
          v10 = dword_1000EB4E8 <= 0;
        else
          v10 = 0;
        if (v10)
        {
          v11 = *__error();
          v12 = sub_1000302B4(*v4);
          v13 = *v4;
          objc_msgSend(*(id *)(v6 + 416), "machAbsTimeSeconds");
          v15 = v14;
          objc_msgSend(*v7, "machAbsTimeSeconds");
          v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait"), v12, v13, v15 - v16);
          if (v17)
          {
            v18 = v17;
            CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
            if (CStringPtr)
            {
              v20 = (char *)CStringPtr;
              v21 = 0;
            }
            else
            {
              v20 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDF1739DAuLL);
              CFStringGetCString(v18, v20, 1024, 0x8000100u);
              v21 = v20;
            }
            if (qword_1000EBD40)
              v79 = (FILE *)qword_1000EBD40;
            else
              v79 = __stderrp;
            fprintf(v79, "%s\n", v20);
            if (v21)
              free(v21);
            CFRelease(v18);
          }
          else
          {
            v74 = sub_100030318();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
            {
              v95 = sub_1000302B4(*v4);
              v96 = *v4;
              objc_msgSend(*(id *)(v6 + 416), "machAbsTimeSeconds");
              v98 = v97;
              objc_msgSend(*v7, "machAbsTimeSeconds");
              *(_DWORD *)buf = 136315650;
              v101 = v95;
              v102 = 1024;
              v103 = v96;
              v104 = 2048;
              v105 = v98 - v99;
              _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", buf, 0x1Cu);
            }
            if (qword_1000EBD40)
              v75 = (FILE *)qword_1000EBD40;
            else
              v75 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
          }
          result = __error();
          *result = v11;
        }
        return result;
      }
      if (byte_1000EBD38)
      {
        v53 = *__error();
        v54 = sub_100030318();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          sub_100093C70(v6, (uint64_t)v7, v54);
        result = __error();
        *result = v53;
      }
      if (byte_1000EBD39)
        v55 = dword_1000EB4E8 <= 0;
      else
        v55 = 0;
      if (!v55)
        return result;
      v47 = *__error();
      objc_msgSend(*(id *)(v6 + 416), "machAbsTimeSeconds");
      v57 = v56;
      objc_msgSend(*v7, "machAbsTimeSeconds");
      v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Got hid event from %.1fs earlier than the spin we monitored, continuing to wait"), v57 - v58);
      if (v59)
      {
        v60 = v59;
        v61 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v61)
        {
          v62 = (char *)v61;
          v63 = 0;
        }
        else
        {
          v62 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDF1739DAuLL);
          CFStringGetCString(v60, v62, 1024, 0x8000100u);
          v63 = v62;
        }
        if (qword_1000EBD40)
          v88 = (FILE *)qword_1000EBD40;
        else
          v88 = __stderrp;
        fprintf(v88, "%s\n", v62);
        if (v63)
          free(v63);
        v87 = v60;
LABEL_143:
        CFRelease(v87);
LABEL_144:
        result = __error();
        *result = v47;
        return result;
      }
      v82 = sub_100030318();
      if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
        sub_100093BD4(v6);
      goto LABEL_119;
    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
    if ((*(_DWORD *)(a1 + 64) & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_INFO, "Got hid event", buf, 2u);
        }
        *__error() = v64;
      }
      if (byte_1000EBD39)
        v66 = dword_1000EB4E8 <= 1;
      else
        v66 = 0;
      if (!v66)
        goto LABEL_154;
      v37 = *__error();
      v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Got hid event"));
      if (v67)
      {
        v68 = v67;
        v69 = CFStringGetCStringPtr(v67, 0x8000100u);
        if (v69)
        {
          v70 = (char *)v69;
          v71 = 0;
        }
        else
        {
          v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3E502C52uLL);
          CFStringGetCString(v68, v70, 1024, 0x8000100u);
          v71 = v70;
        }
        if (qword_1000EBD40)
          v89 = (FILE *)qword_1000EBD40;
        else
          v89 = __stderrp;
        fprintf(v89, "%s\n", v70);
        if (v71)
          free(v71);
        v81 = v68;
        goto LABEL_152;
      }
      v84 = sub_100030318();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_FAULT))
        sub_100093D78();
    }
    else
    {
      if (byte_1000EBD38)
      {
        v32 = *__error();
        v33 = sub_100030318();
        if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
        {
          v34 = sub_1000302B4(*v4);
          v35 = *v4;
          *(_DWORD *)buf = 136446466;
          v101 = v34;
          v102 = 1024;
          v103 = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_INFO, "%{public}s [%d]: Got hid event", buf, 0x12u);
        }
        *__error() = v32;
      }
      if (byte_1000EBD39)
        v36 = dword_1000EB4E8 <= 1;
      else
        v36 = 0;
      if (!v36)
        goto LABEL_154;
      v37 = *__error();
      v38 = sub_1000302B4(*v4);
      v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Got hid event"), v38, *v4);
      if (v39)
      {
        v40 = v39;
        v41 = CFStringGetCStringPtr(v39, 0x8000100u);
        if (v41)
        {
          v42 = (char *)v41;
          v43 = 0;
        }
        else
        {
          v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3E502C52uLL);
          CFStringGetCString(v40, v42, 1024, 0x8000100u);
          v43 = v42;
        }
        if (qword_1000EBD40)
          v80 = (FILE *)qword_1000EBD40;
        else
          v80 = __stderrp;
        fprintf(v80, "%s\n", v42);
        if (v43)
          free(v43);
        v81 = v40;
LABEL_152:
        CFRelease(v81);
LABEL_153:
        *__error() = v37;
LABEL_154:
        objc_msgSend((id)v6, "setEventTimeRange:", +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32)));
        objc_msgSend((id)v6, "setReportTimeStart:", *(_QWORD *)(a1 + 40));
        objc_msgSend((id)v6, "setReportTimeEnd:", *(_QWORD *)(a1 + 32));
        objc_msgSend((id)v6, "setTargetHIDEventMachAbs:", *(_QWORD *)(a1 + 56));
        objc_msgSend((id)v6, "setTargetHIDEventEndMachAbs:", objc_msgSend(*(id *)(a1 + 32), "machAbsTime"));
        dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v6 + 424));
        objc_msgSend(a2, "setObject:forKeyedSubscript:", 0, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 64)));
        return (int *)objc_msgSend((id)v6, "deleteHIDExitSource");
      }
      v76 = sub_100030318();
      if (os_log_type_enabled(v76, OS_LOG_TYPE_FAULT))
        sub_100093D0C();
    }
    if (qword_1000EBD40)
      v85 = (FILE *)qword_1000EBD40;
    else
      v85 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v85);
    goto LABEL_153;
  }
  if ((*v4 & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v22 = *__error();
      v23 = sub_100030318();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        sub_100093B10();
      result = __error();
      *result = v22;
    }
    if (byte_1000EBD39)
      v24 = dword_1000EB4E8 <= 0;
    else
      v24 = 0;
    if (v24)
    {
      v25 = *__error();
      v26 = sub_1000302B4(*v4);
      v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: No sampled process for hid event"), v26, *v4);
      if (v27)
      {
        v28 = v27;
        v29 = CFStringGetCStringPtr(v27, 0x8000100u);
        if (v29)
        {
          v30 = (char *)v29;
          v31 = 0;
        }
        else
        {
          v30 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x54607810uLL);
          CFStringGetCString(v28, v30, 1024, 0x8000100u);
          v31 = v30;
        }
        if (qword_1000EBD40)
          v77 = (FILE *)qword_1000EBD40;
        else
          v77 = __stderrp;
        fprintf(v77, "%s\n", v30);
        if (v31)
          free(v31);
        CFRelease(v28);
      }
      else
      {
        v72 = sub_100030318();
        if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
          sub_100093AA4();
        if (qword_1000EBD40)
          v73 = (FILE *)qword_1000EBD40;
        else
          v73 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
      }
      result = __error();
      *result = v25;
    }
    return result;
  }
  if (byte_1000EBD38)
  {
    v44 = *__error();
    v45 = sub_100030318();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      sub_100093BA8();
    result = __error();
    *result = v44;
  }
  if (byte_1000EBD39)
    v46 = dword_1000EB4E8 <= 0;
  else
    v46 = 0;
  if (v46)
  {
    v47 = *__error();
    v48 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No sampled process for hid event"));
    if (v48)
    {
      v49 = v48;
      v50 = CFStringGetCStringPtr(v48, 0x8000100u);
      if (v50)
      {
        v51 = (char *)v50;
        v52 = 0;
      }
      else
      {
        v51 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x54607810uLL);
        CFStringGetCString(v49, v51, 1024, 0x8000100u);
        v52 = v51;
      }
      if (qword_1000EBD40)
        v86 = (FILE *)qword_1000EBD40;
      else
        v86 = __stderrp;
      fprintf(v86, "%s\n", v51);
      if (v52)
        free(v52);
      v87 = v49;
      goto LABEL_143;
    }
    v78 = sub_100030318();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
      sub_100093B7C();
LABEL_119:
    if (qword_1000EBD40)
      v83 = (FILE *)qword_1000EBD40;
    else
      v83 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
    goto LABEL_144;
  }
  return result;
}

void sub_100067D00(uint64_t a1)
{
  uint64_t v2;
  uint64_t *v3;
  NSObject *v4;
  NSObject *global_queue;
  uint64_t v6;
  NSObject *v7;
  unsigned int v8;
  uint64_t v9;
  dispatch_time_t v10;
  int v11;
  NSObject *v12;
  BOOL v13;
  int v14;
  _DWORD *v15;
  const __CFString *v16;
  const __CFString *v17;
  const char *CStringPtr;
  char *v19;
  char *v20;
  int v21;
  NSObject *v22;
  BOOL v23;
  const __CFString *v24;
  const __CFString *v25;
  const char *v26;
  char *v27;
  char *v28;
  NSObject *v29;
  FILE *v30;
  const __CFString *v31;
  NSObject *v32;
  FILE *v33;
  FILE *v34;
  _QWORD handler[5];

  v3 = (uint64_t *)(a1 + 32);
  v2 = *(_QWORD *)(a1 + 32);
  if (!*(_BYTE *)(v2 + 298) || *(_BYTE *)(v2 + 297))
  {
    v4 = *(NSObject **)(v2 + 32);
    if (!v4)
    {
      global_queue = dispatch_get_global_queue(25, 2uLL);
      *(_QWORD *)(*v3 + 32) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, global_queue);
      v6 = *v3;
      v7 = *(NSObject **)(*v3 + 32);
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_100068110;
      handler[3] = &unk_1000DD608;
      handler[4] = v6;
      dispatch_source_set_event_handler(v7, handler);
      dispatch_resume(*(dispatch_object_t *)(*v3 + 32));
      v2 = *v3;
      v4 = *(NSObject **)(*v3 + 32);
    }
    v8 = *(_DWORD *)(v2 + 400);
    if (v8 >= 0x3E8)
      v9 = 1000000;
    else
      v9 = 1000 * v8;
    v10 = dispatch_time(0, (unint64_t)((*(double *)(a1 + 40) - *(double *)(a1 + 48)) * 1000000000.0));
    dispatch_source_set_timer(v4, v10, 0xFFFFFFFFFFFFFFFFLL, v9);
    return;
  }
  if ((*(_DWORD *)(v2 + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v11 = *__error();
      v12 = sub_100030318();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        sub_10009443C();
      *__error() = v11;
    }
    if (byte_1000EBD39)
      v13 = dword_1000EB4E8 <= 0;
    else
      v13 = 0;
    if (!v13)
      return;
    v14 = *__error();
    v15 = sub_1000302B4(*(_DWORD *)(*v3 + 72));
    v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Lost race: already done sampling"), v15, *(unsigned int *)(*v3 + 72));
    if (v16)
    {
      v17 = v16;
      CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
      if (CStringPtr)
      {
        v19 = (char *)CStringPtr;
        v20 = 0;
      }
      else
      {
        v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x665C327uLL);
        CFStringGetCString(v17, v19, 1024, 0x8000100u);
        v20 = v19;
      }
      if (qword_1000EBD40)
        v30 = (FILE *)qword_1000EBD40;
      else
        v30 = __stderrp;
      fprintf(v30, "%s\n", v19);
      if (v20)
        free(v20);
      v31 = v17;
LABEL_56:
      CFRelease(v31);
LABEL_57:
      *__error() = v14;
      return;
    }
    v29 = sub_100030318();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
      sub_1000943D0();
    goto LABEL_45;
  }
  if (byte_1000EBD38)
  {
    v21 = *__error();
    v22 = sub_100030318();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      sub_1000944D4();
    *__error() = v21;
  }
  if (byte_1000EBD39)
    v23 = dword_1000EB4E8 <= 0;
  else
    v23 = 0;
  if (v23)
  {
    v14 = *__error();
    v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Lost race: already done sampling"));
    if (v24)
    {
      v25 = v24;
      v26 = CFStringGetCStringPtr(v24, 0x8000100u);
      if (v26)
      {
        v27 = (char *)v26;
        v28 = 0;
      }
      else
      {
        v27 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x665C327uLL);
        CFStringGetCString(v25, v27, 1024, 0x8000100u);
        v28 = v27;
      }
      if (qword_1000EBD40)
        v34 = (FILE *)qword_1000EBD40;
      else
        v34 = __stderrp;
      fprintf(v34, "%s\n", v27);
      if (v28)
        free(v28);
      v31 = v25;
      goto LABEL_56;
    }
    v32 = sub_100030318();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
      sub_1000944A8();
LABEL_45:
    if (qword_1000EBD40)
      v33 = (FILE *)qword_1000EBD40;
    else
      v33 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
    goto LABEL_57;
  }
}

void sub_100068110(uint64_t a1)
{
  id *v1;
  double v2;
  double Current;
  int v4;
  int v5;
  NSObject *v6;
  BOOL v7;
  int v8;
  _DWORD *v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *v12;
  char *v13;
  char *v14;
  int v15;
  NSObject *v16;
  BOOL v17;
  int v18;
  _DWORD *v19;
  const __CFString *v20;
  NSObject *v21;
  int v22;
  NSObject *v23;
  BOOL v24;
  const __CFString *v25;
  const __CFString *v26;
  const char *v27;
  char *v28;
  char *v29;
  int v30;
  NSObject *v31;
  BOOL v32;
  const __CFString *v33;
  const char *CStringPtr;
  char *v35;
  char *v36;
  NSObject *v37;
  FILE *v38;
  FILE *v39;
  const __CFString *v40;
  NSObject *v41;
  FILE *v42;
  NSObject *v43;
  FILE *v44;
  FILE *v45;

  v1 = (id *)(a1 + 32);
  v2 = *(double *)(*(_QWORD *)(a1 + 32) + 48);
  Current = SAMachAbsTimeSecondsGetCurrent(a1);
  v4 = *((_DWORD *)*v1 + 18);
  if (v2 <= Current)
  {
    if (v4 < 0)
    {
      if (byte_1000EBD38)
      {
        v30 = *__error();
        v31 = sub_100030318();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
          sub_100094734();
        *__error() = v30;
      }
      if (byte_1000EBD39)
        v32 = dword_1000EB4E8 <= 0;
      else
        v32 = 0;
      if (!v32)
        goto LABEL_81;
      v18 = *__error();
      v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Monitoring timed out"));
      if (!v20)
      {
        v43 = sub_100030318();
        if (os_log_type_enabled(v43, OS_LOG_TYPE_FAULT))
          sub_100094708();
        goto LABEL_76;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v15 = *__error();
        v16 = sub_100030318();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
          sub_10009469C();
        *__error() = v15;
      }
      if (byte_1000EBD39)
        v17 = dword_1000EB4E8 <= 0;
      else
        v17 = 0;
      if (!v17)
        goto LABEL_81;
      v18 = *__error();
      v19 = sub_1000302B4(*((_DWORD *)*v1 + 18));
      v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Monitoring timed out"), v19, *((unsigned int *)*v1 + 18));
      if (!v20)
      {
        v21 = sub_100030318();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
          sub_100094630();
LABEL_76:
        if (qword_1000EBD40)
          v44 = (FILE *)qword_1000EBD40;
        else
          v44 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v44);
LABEL_80:
        *__error() = v18;
LABEL_81:
        objc_msgSend(*v1, "stopSamplingWithReason:", 3);
        return;
      }
    }
    v33 = v20;
    CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
    if (CStringPtr)
    {
      v35 = (char *)CStringPtr;
      v36 = 0;
    }
    else
    {
      v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD1519969uLL);
      CFStringGetCString(v33, v35, 1024, 0x8000100u);
      v36 = v35;
    }
    if (qword_1000EBD40)
      v38 = (FILE *)qword_1000EBD40;
    else
      v38 = __stderrp;
    fprintf(v38, "%s\n", v35);
    if (v36)
      free(v36);
    CFRelease(v33);
    goto LABEL_80;
  }
  if ((v4 & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v5 = *__error();
      v6 = sub_100030318();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
        sub_10009456C();
      *__error() = v5;
    }
    if (byte_1000EBD39)
      v7 = dword_1000EB4E8 <= 0;
    else
      v7 = 0;
    if (!v7)
      return;
    v8 = *__error();
    v9 = sub_1000302B4(*((_DWORD *)*v1 + 18));
    v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Monitoring timeout was extended, doing nothing"), v9, *((unsigned int *)*v1 + 18));
    if (v10)
    {
      v11 = v10;
      v12 = CFStringGetCStringPtr(v10, 0x8000100u);
      if (v12)
      {
        v13 = (char *)v12;
        v14 = 0;
      }
      else
      {
        v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD262D5CCuLL);
        CFStringGetCString(v11, v13, 1024, 0x8000100u);
        v14 = v13;
      }
      if (qword_1000EBD40)
        v39 = (FILE *)qword_1000EBD40;
      else
        v39 = __stderrp;
      fprintf(v39, "%s\n", v13);
      if (v14)
        free(v14);
      v40 = v11;
LABEL_89:
      CFRelease(v40);
LABEL_90:
      *__error() = v8;
      return;
    }
    v37 = sub_100030318();
    if (os_log_type_enabled(v37, OS_LOG_TYPE_FAULT))
      sub_100094500();
    goto LABEL_70;
  }
  if (byte_1000EBD38)
  {
    v22 = *__error();
    v23 = sub_100030318();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      sub_100094604();
    *__error() = v22;
  }
  if (byte_1000EBD39)
    v24 = dword_1000EB4E8 <= 0;
  else
    v24 = 0;
  if (v24)
  {
    v8 = *__error();
    v25 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Monitoring timeout was extended, doing nothing"));
    if (v25)
    {
      v26 = v25;
      v27 = CFStringGetCStringPtr(v25, 0x8000100u);
      if (v27)
      {
        v28 = (char *)v27;
        v29 = 0;
      }
      else
      {
        v28 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xD262D5CCuLL);
        CFStringGetCString(v26, v28, 1024, 0x8000100u);
        v29 = v28;
      }
      if (qword_1000EBD40)
        v45 = (FILE *)qword_1000EBD40;
      else
        v45 = __stderrp;
      fprintf(v45, "%s\n", v28);
      if (v29)
        free(v29);
      v40 = v26;
      goto LABEL_89;
    }
    v41 = sub_100030318();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_FAULT))
      sub_1000945D8();
LABEL_70:
    if (qword_1000EBD40)
      v42 = (FILE *)qword_1000EBD40;
    else
      v42 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v42);
    goto LABEL_90;
  }
}

void sub_100068ABC(_QWORD *a1)
{
  uint64_t v2;
  NSObject *v3;
  const void *v4;

  v2 = a1[4];
  v3 = *(NSObject **)(v2 + 56);
  if (v3)
  {
    dispatch_release(v3);
    v2 = a1[4];
  }
  v4 = *(const void **)(v2 + 64);
  if (v4)
  {
    _Block_release(v4);
    v2 = a1[4];
  }
  *(_QWORD *)(v2 + 56) = a1[5];
  *(_QWORD *)(a1[4] + 64) = a1[6];
}

void sub_100068B6C(uint64_t a1)
{
  uint64_t v1;
  uint64_t *v2;
  int v3;
  NSObject *v4;
  uintptr_t v5;
  NSObject *global_queue;
  uint64_t v7;
  NSObject *v8;
  int v9;
  NSObject *v10;
  BOOL v11;
  int v12;
  const __CFString *v13;
  const __CFString *v14;
  const char *v15;
  malloc_type_id_t v16;
  int v17;
  NSObject *v18;
  BOOL v19;
  _DWORD *v20;
  const __CFString *v21;
  const __CFString *v22;
  const char *CStringPtr;
  malloc_type_id_t v24;
  int v25;
  NSObject *v26;
  _DWORD *v27;
  const __CFString *v28;
  char *v29;
  char *v30;
  int v31;
  NSObject *v32;
  BOOL v33;
  const __CFString *v34;
  int v35;
  NSObject *v36;
  BOOL v37;
  const __CFString *v38;
  int v39;
  NSObject *v40;
  const __CFString *v41;
  char *v42;
  char *v43;
  NSObject *v44;
  NSObject *v45;
  NSObject *v46;
  NSObject *v47;
  NSObject *v48;
  FILE *v49;
  const __CFString *v50;
  NSObject *v51;
  FILE *v52;
  FILE *v53;
  uint8_t buf[8];
  _QWORD handler[5];

  v2 = (uint64_t *)(a1 + 32);
  v1 = *(_QWORD *)(a1 + 32);
  v3 = *(unsigned __int8 *)(a1 + 40);
  v4 = *(NSObject **)(v1 + 40);
  if (!v3)
  {
    if (v4)
    {
      dispatch_release(v4);
      *(_QWORD *)(*v2 + 40) = 0;
    }
    return;
  }
  if (v4)
    return;
  if (!*(_BYTE *)(v1 + 298) || *(_BYTE *)(v1 + 297))
  {
    v5 = *(unsigned int *)(v1 + 72);
    if ((int)v5 >= 1)
    {
      global_queue = dispatch_get_global_queue(25, 2uLL);
      *(_QWORD *)(*v2 + 40) = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_proc, v5, 0xA0000000uLL, global_queue);
      v7 = *v2;
      v8 = *(NSObject **)(*v2 + 40);
      if (v8)
      {
        handler[0] = _NSConcreteStackBlock;
        handler[1] = 3221225472;
        handler[2] = sub_1000692E4;
        handler[3] = &unk_1000DD608;
        handler[4] = v7;
        dispatch_source_set_event_handler(v8, handler);
        dispatch_resume(*(dispatch_object_t *)(*v2 + 40));
        return;
      }
      if ((*(_DWORD *)(v7 + 72) & 0x80000000) == 0)
      {
        if (byte_1000EBD38)
        {
          v25 = *__error();
          v26 = sub_100030318();
          if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
            sub_1000949A4();
          *__error() = v25;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v12 = *__error();
          v27 = sub_1000302B4(*(_DWORD *)(*v2 + 72));
          v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to allocate proc exit dispatch source"), v27, *(unsigned int *)(*v2 + 72));
          if (v28)
          {
            v22 = v28;
            CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
            if (CStringPtr)
              goto LABEL_45;
            v24 = 3829306288;
            goto LABEL_90;
          }
          v46 = sub_100030318();
          if (os_log_type_enabled(v46, OS_LOG_TYPE_FAULT))
            sub_100094938();
          goto LABEL_99;
        }
        return;
      }
      if (byte_1000EBD38)
      {
        v39 = *__error();
        v40 = sub_100030318();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
          sub_100094A3C();
        *__error() = v39;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        return;
      v12 = *__error();
      v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to allocate proc exit dispatch source"));
      if (!v41)
      {
        v51 = sub_100030318();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_FAULT))
          sub_100094A10();
        goto LABEL_99;
      }
      v14 = v41;
      v15 = CFStringGetCStringPtr(v41, 0x8000100u);
      if (v15)
        goto LABEL_78;
      v16 = 3829306288;
LABEL_104:
      v42 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v16);
      CFStringGetCString(v14, v42, 1024, 0x8000100u);
      v43 = v42;
      goto LABEL_105;
    }
    if ((_DWORD)v5)
    {
      if (byte_1000EBD38)
      {
        v9 = *__error();
        v10 = sub_100030318();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "No target process to monitor for exiting", buf, 2u);
        }
        *__error() = v9;
      }
      if (byte_1000EBD39)
        v11 = dword_1000EB4E8 <= 1;
      else
        v11 = 0;
      if (!v11)
        return;
      v12 = *__error();
      v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("No target process to monitor for exiting"));
      if (!v13)
      {
        v44 = sub_100030318();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_FAULT))
          sub_100094A94();
        goto LABEL_99;
      }
      v14 = v13;
      v15 = CFStringGetCStringPtr(v13, 0x8000100u);
      if (!v15)
      {
        v16 = 4191268265;
        goto LABEL_104;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v31 = *__error();
        v32 = sub_100030318();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_INFO, "Can't stop when kernel exits", buf, 2u);
        }
        *__error() = v31;
      }
      if (byte_1000EBD39)
        v33 = dword_1000EB4E8 <= 1;
      else
        v33 = 0;
      if (!v33)
        return;
      v12 = *__error();
      v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Can't stop when kernel exits"));
      if (!v34)
      {
        v47 = sub_100030318();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_FAULT))
          sub_100094A68();
        goto LABEL_99;
      }
      v14 = v34;
      v15 = CFStringGetCStringPtr(v34, 0x8000100u);
      if (!v15)
      {
        v16 = 3080682967;
        goto LABEL_104;
      }
    }
LABEL_78:
    v42 = (char *)v15;
    v43 = 0;
LABEL_105:
    if (qword_1000EBD40)
      v53 = (FILE *)qword_1000EBD40;
    else
      v53 = __stderrp;
    fprintf(v53, "%s\n", v42);
    if (v43)
      free(v43);
    v50 = v14;
    goto LABEL_111;
  }
  if ((*(_DWORD *)(v1 + 72) & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v35 = *__error();
      v36 = sub_100030318();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
        sub_1000944D4();
      *__error() = v35;
    }
    if (byte_1000EBD39)
      v37 = dword_1000EB4E8 <= 0;
    else
      v37 = 0;
    if (!v37)
      return;
    v12 = *__error();
    v38 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Lost race: already done sampling"));
    if (!v38)
    {
      v48 = sub_100030318();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
        sub_1000944A8();
      goto LABEL_99;
    }
    v14 = v38;
    v15 = CFStringGetCStringPtr(v38, 0x8000100u);
    if (!v15)
    {
      v16 = 668362104;
      goto LABEL_104;
    }
    goto LABEL_78;
  }
  if (byte_1000EBD38)
  {
    v17 = *__error();
    v18 = sub_100030318();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      sub_10009443C();
    *__error() = v17;
  }
  if (byte_1000EBD39)
    v19 = dword_1000EB4E8 <= 0;
  else
    v19 = 0;
  if (v19)
  {
    v12 = *__error();
    v20 = sub_1000302B4(*(_DWORD *)(*v2 + 72));
    v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Lost race: already done sampling"), v20, *(unsigned int *)(*v2 + 72));
    if (v21)
    {
      v22 = v21;
      CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
      if (CStringPtr)
      {
LABEL_45:
        v29 = (char *)CStringPtr;
        v30 = 0;
LABEL_91:
        if (qword_1000EBD40)
          v49 = (FILE *)qword_1000EBD40;
        else
          v49 = __stderrp;
        fprintf(v49, "%s\n", v29);
        if (v30)
          free(v30);
        v50 = v22;
LABEL_111:
        CFRelease(v50);
LABEL_112:
        *__error() = v12;
        return;
      }
      v24 = 668362104;
LABEL_90:
      v29 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v24);
      CFStringGetCString(v22, v29, 1024, 0x8000100u);
      v30 = v29;
      goto LABEL_91;
    }
    v45 = sub_100030318();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
      sub_1000943D0();
LABEL_99:
    if (qword_1000EBD40)
      v52 = (FILE *)qword_1000EBD40;
    else
      v52 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v52);
    goto LABEL_112;
  }
}

id sub_1000692E4(uint64_t a1)
{
  id *v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  _DWORD *v6;
  const __CFString *v7;
  NSObject *v8;
  int v9;
  NSObject *v10;
  BOOL v11;
  const __CFString *v12;
  const char *CStringPtr;
  char *v14;
  char *v15;
  FILE *v16;
  NSObject *v17;
  FILE *v18;

  v1 = (id *)(a1 + 32);
  if ((*(_DWORD *)(*(_QWORD *)(a1 + 32) + 72) & 0x80000000) == 0)
  {
    if (byte_1000EBD38)
    {
      v2 = *__error();
      v3 = sub_100030318();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
        sub_100094B2C();
      *__error() = v2;
    }
    if (byte_1000EBD39)
      v4 = dword_1000EB4E8 <= 0;
    else
      v4 = 0;
    if (!v4)
      return objc_msgSend(*v1, "stopSamplingWithReason:", 2);
    v5 = *__error();
    v6 = sub_1000302B4(*((_DWORD *)*v1 + 18));
    v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: exited"), v6, *((unsigned int *)*v1 + 18));
    if (!v7)
    {
      v8 = sub_100030318();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
        sub_100094AC0();
LABEL_35:
      if (qword_1000EBD40)
        v18 = (FILE *)qword_1000EBD40;
      else
        v18 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v18);
LABEL_39:
      *__error() = v5;
      return objc_msgSend(*v1, "stopSamplingWithReason:", 2);
    }
    goto LABEL_24;
  }
  if (byte_1000EBD38)
  {
    v9 = *__error();
    v10 = sub_100030318();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      sub_100094BC4();
    *__error() = v9;
  }
  if (byte_1000EBD39)
    v11 = dword_1000EB4E8 <= 0;
  else
    v11 = 0;
  if (v11)
  {
    v5 = *__error();
    v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("exited"));
    if (!v7)
    {
      v17 = sub_100030318();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_FAULT))
        sub_100094B98();
      goto LABEL_35;
    }
LABEL_24:
    v12 = v7;
    CStringPtr = CFStringGetCStringPtr(v7, 0x8000100u);
    if (CStringPtr)
    {
      v14 = (char *)CStringPtr;
      v15 = 0;
    }
    else
    {
      v14 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA6C15D34uLL);
      CFStringGetCString(v12, v14, 1024, 0x8000100u);
      v15 = v14;
    }
    if (qword_1000EBD40)
      v16 = (FILE *)qword_1000EBD40;
    else
      v16 = __stderrp;
    fprintf(v16, "%s\n", v14);
    if (v15)
      free(v15);
    CFRelease(v12);
    goto LABEL_39;
  }
  return objc_msgSend(*v1, "stopSamplingWithReason:", 2);
}

id sub_1000699D8(id result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  _BOOL8 v6;
  void *v7;
  uint64_t v8;
  _QWORD v9[5];
  char v10;

  v1 = *((_QWORD *)result + 4);
  if (*(_BYTE *)(v1 + 297))
  {
    v2 = result;
    *(_BYTE *)(v1 + 297) = 0;
    objc_msgSend(*((id *)result + 4), "removeSelfFromPidCache");
    v3 = v2[4];
    v4 = *(NSObject **)(v3 + 32);
    if (v4)
    {
      dispatch_release(v4);
      *(_QWORD *)(v2[4] + 32) = 0;
      v3 = v2[4];
    }
    v5 = *(NSObject **)(v3 + 40);
    if (v5)
    {
      dispatch_release(v5);
      *(_QWORD *)(v2[4] + 40) = 0;
      v3 = v2[4];
    }
    v6 = *(_BYTE *)(v3 + 301) == 0;
    v8 = *(_QWORD *)(v3 + 16);
    v7 = *(void **)(v3 + 24);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_100069A98;
    v9[3] = &unk_1000DDA00;
    v9[4] = v3;
    v10 = *((_BYTE *)v2 + 40);
    return objc_msgSend(v7, "stopAndWaitForAllSamplingToComplete:withCompletionCallbackOnQueue:withBlock:", v6, v8, v9);
  }
  return result;
}

id sub_100069A98(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "_samplingHasCompletedWithEndSnapshot:withReason:", a2, *(unsigned __int8 *)(a1 + 40));
}

BOOL sub_10006AC5C(int a1)
{
  return (a1 - 6) < 0xFFFFFFFC;
}

_DWORD *sub_10006AC6C(uint64_t a1, void *a2)
{
  id *v3;
  _DWORD *result;
  int v5;
  NSObject *v6;
  BOOL v7;
  int v8;
  _DWORD *v9;
  const __CFString *v10;
  NSObject *v11;
  int v12;
  NSObject *v13;
  BOOL v14;
  const __CFString *v15;
  const char *CStringPtr;
  char *v17;
  char *v18;
  FILE *v19;
  NSObject *v20;
  FILE *v21;

  v3 = (id *)(a1 + 32);
  result = objc_msgSend(a2, "objectForKeyedSubscript:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(*(_QWORD *)(a1 + 32) + 72)));
  if (result && result == *v3)
  {
    if ((result[18] & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v12 = *__error();
        v13 = sub_100030318();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          sub_1000953D4();
        *__error() = v12;
      }
      if (byte_1000EBD39)
        v14 = dword_1000EB4E8 <= 0;
      else
        v14 = 0;
      if (!v14)
        goto LABEL_42;
      v8 = *__error();
      v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Removing self from processes waiting on HID event list"));
      if (!v10)
      {
        v20 = sub_100030318();
        if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
          sub_1000953A8();
        goto LABEL_37;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v5 = *__error();
        v6 = sub_100030318();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
          sub_10009533C();
        *__error() = v5;
      }
      if (byte_1000EBD39)
        v7 = dword_1000EB4E8 <= 0;
      else
        v7 = 0;
      if (!v7)
        goto LABEL_42;
      v8 = *__error();
      v9 = sub_1000302B4(*((_DWORD *)*v3 + 18));
      v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Removing self from processes waiting on HID event list"), v9, *((unsigned int *)*v3 + 18));
      if (!v10)
      {
        v11 = sub_100030318();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
          sub_1000952D0();
LABEL_37:
        if (qword_1000EBD40)
          v21 = (FILE *)qword_1000EBD40;
        else
          v21 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v21);
LABEL_41:
        *__error() = v8;
LABEL_42:
        objc_msgSend(a2, "setObject:forKeyedSubscript:", 0, +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *((unsigned int *)*v3 + 18)));
        return objc_msgSend(*v3, "deleteHIDExitSource");
      }
    }
    v15 = v10;
    CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
    if (CStringPtr)
    {
      v17 = (char *)CStringPtr;
      v18 = 0;
    }
    else
    {
      v17 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x34677251uLL);
      CFStringGetCString(v15, v17, 1024, 0x8000100u);
      v18 = v17;
    }
    if (qword_1000EBD40)
      v19 = (FILE *)qword_1000EBD40;
    else
      v19 = __stderrp;
    fprintf(v19, "%s\n", v17);
    if (v18)
      free(v18);
    CFRelease(v15);
    goto LABEL_41;
  }
  return result;
}

void sub_10006AF54(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) + 16))();
  _Block_release(*(const void **)(*(_QWORD *)(a1 + 32) + 64));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) = 0;
}

void sub_10006AF98(uint64_t a1, void *a2)
{
  _DWORD *v4;
  id *v5;
  id v6;
  id v7;
  unsigned int v8;
  uint64_t v9;
  void *v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;
  double v17;
  void *v18;
  double v19;
  double v20;
  double v21;
  SATimestamp *v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  _QWORD *v28;
  NSObject *v29;
  int v30;
  NSObject *v31;
  int v32;
  _DWORD *v33;
  const __CFString *v34;
  NSObject *v35;
  FILE *v36;
  int v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  const __CFString *v47;
  NSObject *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  FILE *v56;
  const __CFString *v57;
  const char *v58;
  char *v59;
  char *v60;
  const __CFString *v61;
  const char *CStringPtr;
  char *v63;
  char *v64;
  FILE *v65;
  char v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  FILE *v71;
  _QWORD block[5];
  char v73;
  _QWORD v74[7];
  uint64_t v75;
  uint64_t *v76;
  uint64_t v77;
  uint64_t v78;

  objc_msgSend(a2, "setTargetThreadId:", 0);
  v5 = (id *)(a1 + 32);
  v4 = *(_DWORD **)(a1 + 32);
  if ((v4[18] & 0x80000000) == 0)
  {
    objc_msgSend(a2, "setTargetProcessId:");
    v4 = *v5;
  }
  if (*((_QWORD *)v4 + 19))
  {
    objc_msgSend(a2, "setTargetThreadId:");
    v4 = *v5;
  }
  if (*((_QWORD *)v4 + 15))
  {
    if ((objc_msgSend(objc_msgSend(objc_msgSend(a2, "targetProcess"), "mainBinaryPath"), "isAbsolutePath") & 1) == 0)
    {
      v6 = objc_msgSend(a2, "targetProcess");
      if (v6)
        objc_msgSend(v6, "setMainBinaryPath:", *((_QWORD *)*v5 + 15));
    }
  }
  objc_msgSend(a2, "setTargetHIDEventMachAbs:", *((_QWORD *)*v5 + 20));
  objc_msgSend(a2, "setTargetHIDEventEndMachAbs:", *((_QWORD *)*v5 + 21));

  *((_QWORD *)*v5 + 10) = objc_msgSend(objc_msgSend(a2, "targetProcess"), "name");
  if (objc_msgSend(objc_msgSend(objc_msgSend(a2, "targetProcess"), "mainBinaryPath"), "isAbsolutePath"))
    v7 = objc_msgSend(objc_msgSend(a2, "targetProcess"), "mainBinaryPath");
  else
    v7 = 0;
  *((_QWORD *)*v5 + 15) = v7;
  v8 = objc_msgSend(objc_msgSend(a2, "targetProcess"), "isUnresponsive");
  v9 = 0;
  if (v8)
    objc_msgSend(objc_msgSend(a2, "targetProcess", 0.0), "timeOfLastResponse");
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 144) = v9;
  v10 = *(void **)(a1 + 40);
  if (!v10)
  {
    v11 = 1;
    goto LABEL_40;
  }
  v11 = *(_BYTE *)(a1 + 48);
  if (objc_msgSend(v10, "stackshotProvider") != *((id *)*v5 + 3))
  {
    if ((*((_DWORD *)*v5 + 18) & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v37 = *__error();
        v38 = sub_100030318();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          sub_10009557C(v38, v39, v40, v41, v42, v43, v44, v45);
        *__error() = v37;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v46 = *__error();
        v47 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Mismatched sample providers"), "endSnapshot.stackshotProvider == _sampleProvider");
        if (v47)
        {
          v61 = v47;
          CStringPtr = CFStringGetCStringPtr(v47, 0x8000100u);
          if (CStringPtr)
          {
            v63 = (char *)CStringPtr;
            v64 = 0;
          }
          else
          {
            v63 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5B2C2171uLL);
            CFStringGetCString(v61, v63, 1024, 0x8000100u);
            v64 = v63;
          }
          if (qword_1000EBD40)
            v71 = (FILE *)qword_1000EBD40;
          else
            v71 = __stderrp;
          fprintf(v71, "%s\n", v63);
          if (v64)
            free(v64);
          CFRelease(v61);
        }
        else
        {
          v48 = sub_100030318();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_FAULT))
            sub_10009550C(v48, v49, v50, v51, v52, v53, v54, v55);
          if (qword_1000EBD40)
            v56 = (FILE *)qword_1000EBD40;
          else
            v56 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v56);
        }
        *__error() = v46;
      }
      sub_1000301F0("-[SPSampledProcess _samplingHasCompletedWithEndSnapshot:withReason:]_block_invoke", "SPProcessEvent.m", 1346, "%s: Mismatched sample providers", v12, v13, v14, v15, (char)"endSnapshot.stackshotProvider == _sampleProvider");
    }
    else
    {
      if (byte_1000EBD38)
      {
        v30 = *__error();
        v31 = sub_100030318();
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          sub_100095488();
        *__error() = v30;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v32 = *__error();
        v33 = sub_1000302B4(*((_DWORD *)*v5 + 18));
        v34 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: %s: Mismatched sample providers"), v33, *((unsigned int *)*v5 + 18), "endSnapshot.stackshotProvider == _sampleProvider");
        if (v34)
        {
          v57 = v34;
          v58 = CFStringGetCStringPtr(v34, 0x8000100u);
          if (v58)
          {
            v59 = (char *)v58;
            v60 = 0;
          }
          else
          {
            v59 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5B2C2171uLL);
            CFStringGetCString(v57, v59, 1024, 0x8000100u);
            v60 = v59;
          }
          if (qword_1000EBD40)
            v65 = (FILE *)qword_1000EBD40;
          else
            v65 = __stderrp;
          fprintf(v65, "%s\n", v59);
          if (v60)
            free(v60);
          CFRelease(v57);
        }
        else
        {
          v35 = sub_100030318();
          if (os_log_type_enabled(v35, OS_LOG_TYPE_FAULT))
            sub_100095400();
          if (qword_1000EBD40)
            v36 = (FILE *)qword_1000EBD40;
          else
            v36 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v36);
        }
        *__error() = v32;
      }
      v66 = sub_1000302B4(*((_DWORD *)*v5 + 18));
      sub_1000301F0("-[SPSampledProcess _samplingHasCompletedWithEndSnapshot:withReason:]_block_invoke", "SPProcessEvent.m", 1346, "%s [%d]: %s: Mismatched sample providers", v67, v68, v69, v70, v66);
    }
    abort();
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 284) = objc_msgSend(*(id *)(a1 + 40), "numSamplesAvoidedDueToAudio");
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 276) = objc_msgSend(*(id *)(a1 + 40), "numSamples");
  if (!objc_msgSend(*(id *)(a1 + 32), "eventTimeRange"))
  {
    v16 = *v5;
    v17 = *((double *)*v5 + 18);
    if (v17 > 0.0)
    {
      v18 = (void *)*((_QWORD *)v16 + 52);
      if (!v18)
        goto LABEL_21;
      objc_msgSend(v18, "wallTime");
      if (v17 < v19)
        goto LABEL_22;
      v16 = *v5;
      if (!*((_QWORD *)*v5 + 52))
      {
LABEL_21:
        v20 = *((double *)v16 + 18);
        objc_msgSend(objc_msgSend(*(id *)(a1 + 40), "timestamp"), "wallTime");
        if (v20 < v21)
        {
LABEL_22:
          v22 = +[SATimestamp timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:](SATimestamp, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:", 0, 0, 0.0, 0.0, *((double *)*v5 + 18));
          v23 = (id)*((_QWORD *)*v5 + 52);
          if (!v23)
            v23 = objc_msgSend(*(id *)(a1 + 40), "timestamp");
          -[SATimestamp guessMissingTimesBasedOnTimestamp:](v22, "guessMissingTimesBasedOnTimestamp:", v23);
          if (!v22)
            goto LABEL_30;
          goto LABEL_29;
        }
        v16 = *v5;
      }
    }
    v22 = (SATimestamp *)*((_QWORD *)v16 + 52);
    if (v22)
    {
LABEL_29:
      objc_msgSend(*(id *)(a1 + 32), "setEventTimeRange:", +[SATimeRange timeRangeStart:end:](SATimeRange, "timeRangeStart:end:", v22, objc_msgSend(*(id *)(a1 + 40), "timestamp")));
      objc_msgSend(*(id *)(a1 + 32), "setReportTimeStart:", v22);
      objc_msgSend(*(id *)(a1 + 32), "setReportTimeEnd:", objc_msgSend(*(id *)(a1 + 40), "timestamp"));
    }
  }
LABEL_30:
  if (*((int *)*v5 + 18) >= 1 && objc_msgSend(*v5, "eventTimeRange"))
  {
    v75 = 0;
    v76 = &v75;
    v77 = 0x2020000000;
    v78 = 0;
    v24 = objc_msgSend(*v5, "reportTimeStart");
    if (!v24)
      v24 = objc_msgSend(objc_msgSend(*v5, "eventTimeRange"), "startTime");
    v25 = objc_msgSend(a2, "indexOfFirstSampleOnOrAfterTimestamp:", v24);
    v26 = objc_msgSend(*v5, "reportTimeEnd");
    if (!v26)
      v26 = objc_msgSend(objc_msgSend(*v5, "eventTimeRange"), "endTime");
    v27 = objc_msgSend(a2, "indexOfLastSampleOnOrBeforeTimestamp:", v26);
    if (v25 != (id)0x7FFFFFFFFFFFFFFFLL && v27 != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      v74[0] = _NSConcreteStackBlock;
      v74[1] = 3221225472;
      v74[2] = sub_10006B784;
      v74[3] = &unk_1000DDA28;
      v74[4] = &v75;
      v74[5] = v25;
      v74[6] = v27;
      objc_msgSend(objc_msgSend(a2, "targetProcess"), "enumerateTaskStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:", v24, v25, v26, v27, 0, v74);
    }
    *((_DWORD *)*v5 + 72) = v76[3];
    _Block_object_dispose(&v75, 8);
  }
LABEL_40:
  v28 = *v5;
  v29 = *((_QWORD *)*v5 + 7);
  if (v29)
  {
    if (v28[8])
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10006B7DC;
      block[3] = &unk_1000DD988;
      block[4] = v28;
      v73 = v11;
      dispatch_async(v29, block);
      dispatch_release(*((dispatch_object_t *)*v5 + 7));
      *((_QWORD *)*v5 + 7) = 0;
    }
  }
}

void sub_10006B760(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

id sub_10006B784(_QWORD *a1, void *a2)
{
  id result;

  if (objc_msgSend(a2, "suspendCount") || (result = objc_msgSend(a2, "isPidSuspended"), (_DWORD)result))
  {
    result = objc_msgSend(a2, "sampleCountInSampleIndexRangeStart:end:", a1[5], a1[6]);
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) += result;
  }
  return result;
}

void sub_10006B7DC(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) + 16))();
  _Block_release(*(const void **)(*(_QWORD *)(a1 + 32) + 64));
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 64) = 0;
}

id sub_10006C14C(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 400);
  objc_msgSend(a2, "setAttemptedSamplingInterval:", (double)*(unint64_t *)&a3 / 1000000.0);
  objc_msgSend(*(id *)(a1 + 32), "reportTimeThreshold");
  objc_msgSend(a2, "setReportTimeThreshold:");
  return objc_msgSend(*(id *)(a1 + 32), "_saveReportToStream:withSampleStore:", *(_QWORD *)(a1 + 40), a2);
}

uint64_t sub_10006CAD8(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = *(_DWORD *)(*(_QWORD *)(a1 + 32) + 400);
  objc_msgSend(a2, "setAttemptedSamplingInterval:", (double)*(unint64_t *)&a3 / 1000000.0);
  objc_msgSend(*(id *)(a1 + 32), "reportTimeThreshold");
  objc_msgSend(a2, "setReportTimeThreshold:");
  objc_msgSend(*(id *)(a1 + 32), "_samplePrinterForSampleStore:", a2);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
}

id sub_10006CB58(uint64_t pid, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, uint64_t a8, double a9)
{
  NSString *v17;
  int *v18;
  id result;
  int v20;
  int v21;
  NSObject *v22;
  id v24;
  int v25;
  NSObject *v26;
  int v27;
  _DWORD *v28;
  const __CFString *v29;
  const __CFString *v30;
  const char *v31;
  malloc_type_id_t v32;
  id v33;
  void *v34;
  int v35;
  NSObject *v36;
  int v37;
  _DWORD *v38;
  const __CFString *v39;
  NSObject *v40;
  int v41;
  NSObject *v42;
  _DWORD *v43;
  const __CFString *v44;
  NSObject *v45;
  _DWORD *v46;
  uint64_t v47;
  int *v48;
  char *v49;
  const __CFString *v50;
  const __CFString *v51;
  const char *v52;
  char *v53;
  char *v54;
  int v55;
  NSObject *v56;
  int v57;
  _DWORD *v58;
  const __CFString *v59;
  const __CFString *v60;
  const char *v61;
  char *v62;
  char *v63;
  int v64;
  NSObject *v65;
  const __CFString *v66;
  const char *CStringPtr;
  char *v68;
  char *v69;
  int v70;
  NSObject *v71;
  const __CFString *v72;
  const __CFString *v73;
  const char *v74;
  malloc_type_id_t v75;
  int v76;
  NSObject *v77;
  _DWORD *v78;
  const __CFString *v79;
  NSObject *v80;
  NSObject *v81;
  _DWORD *v82;
  const char *v83;
  const __CFString *v84;
  NSObject *v85;
  NSObject *v86;
  FILE *v87;
  int v88;
  NSObject *v89;
  _DWORD *v90;
  _DWORD *v91;
  const __CFString *v92;
  int v93;
  NSObject *v94;
  const __CFString *v95;
  const __CFString *v96;
  const char *v97;
  char *v98;
  char *v99;
  FILE *v100;
  FILE *v101;
  int v102;
  NSObject *v103;
  int v104;
  const __CFString *v105;
  const char *v106;
  malloc_type_id_t v107;
  int v108;
  NSObject *v109;
  int v110;
  char *v111;
  char *v112;
  NSObject *v113;
  NSObject *v114;
  uint64_t v115;
  const char *v116;
  const char *v117;
  char *v118;
  NSObject *v119;
  FILE *v120;
  int v121;
  NSObject *v122;
  const __CFString *v123;
  NSObject *v124;
  NSObject *v125;
  FILE *v126;
  const __CFString *v127;
  FILE *v128;
  NSObject *v129;
  FILE *v130;
  FILE *v131;
  NSObject *v132;
  FILE *v133;
  NSObject *v134;
  NSObject *v135;
  FILE *v136;
  int v137;
  NSObject *v138;
  _DWORD *v139;
  const __CFString *v140;
  char *v141;
  char *v142;
  int v143;
  NSObject *v144;
  const __CFString *v145;
  char *v146;
  char *v147;
  uint64_t v148;
  NSObject *v149;
  FILE *v150;
  const __CFString *v151;
  NSObject *v152;
  NSObject *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  FILE *v160;
  int v161;
  NSObject *v162;
  int v163;
  _DWORD *v164;
  const __CFString *v165;
  NSObject *v166;
  int v167;
  NSObject *v168;
  const __CFString *v169;
  const char *v170;
  char *v171;
  char *v172;
  FILE *v173;
  NSObject *v174;
  FILE *v175;
  FILE *v176;
  NSObject *v177;
  FILE *v178;
  char *v179;
  CFAllocatorRef alloc;
  const __CFString *alloca;
  CFAllocatorRef allocb;
  int v183;
  int v184;
  int v185;
  int v186;
  NSString *v187;
  int v188;
  _QWORD v190[6];
  char v191;
  int buffer;
  _DWORD *v193;
  __int16 v194;
  int v195;

  if (!(_DWORD)a4 || !a7 || !a8)
  {
    v18 = __error();
    result = 0;
    v20 = 22;
LABEL_377:
    *v18 = v20;
    return result;
  }
  if ((pid & 0x80000000) != 0)
    goto LABEL_17;
  if (proc_pidpath(pid, &buffer, 0x400u) >= 1)
  {
    v17 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", &buffer);
    if ((a6 & 1) == 0)
      goto LABEL_19;
LABEL_18:
    if (sub_100025F88(pid))
      goto LABEL_19;
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v64 = *__error();
        v65 = sub_100030318();
        if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          sub_100096200();
        *__error() = v64;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_196;
      v37 = *__error();
      v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("process doesn't exist, not sampling"));
      if (!v39)
      {
        v119 = sub_100030318();
        if (os_log_type_enabled(v119, OS_LOG_TYPE_FAULT))
          sub_1000961D4();
        goto LABEL_191;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v35 = *__error();
        v36 = sub_100030318();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          sub_10009616C();
        *__error() = v35;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_196;
      v37 = *__error();
      v38 = sub_1000302B4(pid);
      v39 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: process doesn't exist, not sampling"), v38, pid);
      if (!v39)
      {
        v40 = sub_100030318();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_FAULT))
          sub_100096104();
LABEL_191:
        if (qword_1000EBD40)
          v120 = (FILE *)qword_1000EBD40;
        else
          v120 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v120);
LABEL_195:
        *__error() = v37;
LABEL_196:
        v18 = __error();
        result = 0;
        v20 = 2;
        goto LABEL_377;
      }
    }
    v66 = v39;
    CStringPtr = CFStringGetCStringPtr(v39, 0x8000100u);
    if (CStringPtr)
    {
      v68 = (char *)CStringPtr;
      v69 = 0;
    }
    else
    {
      v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x332A953AuLL);
      CFStringGetCString(v66, v68, 1024, 0x8000100u);
      v69 = v68;
    }
    if (qword_1000EBD40)
      v100 = (FILE *)qword_1000EBD40;
    else
      v100 = __stderrp;
    fprintf(v100, "%s\n", v68);
    if (v69)
      free(v69);
    CFRelease(v66);
    goto LABEL_195;
  }
  if (byte_1000EBD38)
  {
    v21 = *__error();
    v22 = sub_100030318();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      sub_1000962B8();
    *__error() = v21;
  }
  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
  {
LABEL_17:
    v17 = 0;
    if ((a6 & 1) == 0)
      goto LABEL_19;
    goto LABEL_18;
  }
  v188 = *__error();
  v46 = sub_1000302B4(pid);
  v47 = *__error();
  v48 = __error();
  v49 = strerror(*v48);
  v50 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to get path: %d (%s)"), v46, pid, v47, v49);
  if (v50)
  {
    v51 = v50;
    v52 = CFStringGetCStringPtr(v50, 0x8000100u);
    if (v52)
    {
      v53 = (char *)v52;
      v54 = 0;
    }
    else
    {
      v53 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9981D8F0uLL);
      CFStringGetCString(v51, v53, 1024, 0x8000100u);
      v54 = v53;
    }
    if (qword_1000EBD40)
      v101 = (FILE *)qword_1000EBD40;
    else
      v101 = __stderrp;
    fprintf(v101, "%s\n", v53);
    if (v54)
      free(v54);
    CFRelease(v51);
  }
  else
  {
    v86 = sub_100030318();
    if (os_log_type_enabled(v86, OS_LOG_TYPE_FAULT))
      sub_10009622C();
    if (qword_1000EBD40)
      v87 = (FILE *)qword_1000EBD40;
    else
      v87 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v87);
  }
  v17 = 0;
  *__error() = v188;
  if ((a6 & 1) != 0)
    goto LABEL_18;
LABEL_19:
  v187 = v17;
  v191 = 0;
  v24 = +[SPSampledProcess copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:](SPSampledProcess, "copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:", pid, (a6 >> 2) & 1, 1, &v191);
  if (v24)
    goto LABEL_20;
  if ((a6 & 2) == 0 || !v191)
  {
LABEL_326:
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v167 = *__error();
        v168 = sub_100030318();
        if (os_log_type_enabled(v168, OS_LOG_TYPE_ERROR))
          sub_100095860();
        *__error() = v167;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_376;
      v163 = *__error();
      v165 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to create SPSampledProcess"));
      if (!v165)
      {
        v174 = sub_100030318();
        if (os_log_type_enabled(v174, OS_LOG_TYPE_FAULT))
          sub_100095834();
        goto LABEL_354;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v161 = *__error();
        v162 = sub_100030318();
        if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
          sub_1000957CC();
        *__error() = v161;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_376;
      v163 = *__error();
      v164 = sub_1000302B4(pid);
      v165 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to create SPSampledProcess"), v164, pid);
      if (!v165)
      {
        v166 = sub_100030318();
        if (os_log_type_enabled(v166, OS_LOG_TYPE_FAULT))
          sub_100095764();
LABEL_354:
        if (qword_1000EBD40)
          v175 = (FILE *)qword_1000EBD40;
        else
          v175 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v175);
LABEL_358:
        *__error() = v163;
LABEL_376:
        v18 = __error();
        result = 0;
        v20 = 37;
        goto LABEL_377;
      }
    }
    v169 = v165;
    v170 = CFStringGetCStringPtr(v165, 0x8000100u);
    if (v170)
    {
      v171 = (char *)v170;
      v172 = 0;
    }
    else
    {
      v171 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xE0166F76uLL);
      CFStringGetCString(v169, v171, 1024, 0x8000100u);
      v172 = v171;
    }
    if (qword_1000EBD40)
      v173 = (FILE *)qword_1000EBD40;
    else
      v173 = __stderrp;
    fprintf(v173, "%s\n", v171);
    if (v172)
      free(v172);
    CFRelease(v169);
    goto LABEL_358;
  }
  v33 = +[SPSampledProcess copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:](SPSampledProcess, "copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:", pid, (a6 & 4) == 0, 0, 0);
  if (v33)
  {
    v34 = v33;
    objc_msgSend(v33, "stopSamplingWithReason:", 9);

    goto LABEL_325;
  }
  if ((pid & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v186 = *__error();
      v114 = sub_100030318();
      if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
        sub_100096084((a6 & 4) != 0, v114, v115);
      *__error() = v186;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v185 = *__error();
      if ((a6 & 4) != 0)
        v116 = "non-";
      else
        v116 = "";
      v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to find existing %sWindowServer-based sampled process"), v116);
      if (!v84)
      {
        allocb = (CFAllocatorRef)v116;
        v153 = sub_100030318();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_FAULT))
          sub_100096020((uint64_t)allocb, v153, v154, v155, v156, v157, v158, v159);
        goto LABEL_320;
      }
LABEL_187:
      alloca = v84;
      v117 = CFStringGetCStringPtr(v84, 0x8000100u);
      if (v117)
      {
        v118 = (char *)v117;
        v179 = 0;
      }
      else
      {
        v118 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7CACA105uLL);
        CFStringGetCString(alloca, v118, 1024, 0x8000100u);
        v179 = v118;
      }
      if (qword_1000EBD40)
        v131 = (FILE *)qword_1000EBD40;
      else
        v131 = __stderrp;
      fprintf(v131, "%s\n", v118);
      if (v179)
        free(v179);
      CFRelease(alloca);
      goto LABEL_324;
    }
  }
  else
  {
    if (byte_1000EBD38)
    {
      v184 = *__error();
      v81 = sub_100030318();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_DEBUG))
        sub_100095F78(pid);
      *__error() = v184;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v185 = *__error();
      v82 = sub_1000302B4(pid);
      if ((a6 & 4) != 0)
        v83 = "non-";
      else
        v83 = "";
      v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to find existing %sWindowServer-based sampled process"), v82, pid, v83);
      if (!v84)
      {
        v85 = sub_100030318();
        if (os_log_type_enabled(v85, OS_LOG_TYPE_FAULT))
          sub_100095EE8(pid);
LABEL_320:
        if (qword_1000EBD40)
          v160 = (FILE *)qword_1000EBD40;
        else
          v160 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v160);
LABEL_324:
        *__error() = v185;
        goto LABEL_325;
      }
      goto LABEL_187;
    }
  }
LABEL_325:
  v24 = +[SPSampledProcess copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:](SPSampledProcess, "copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:", pid, (a6 >> 2) & 1, 1, &v191);
  if (!v24)
    goto LABEL_326;
LABEL_20:
  if (!v191)
  {
    objc_msgSend(v24, "setSamplingIntervalUs:", a2);
    objc_msgSend(v24, "setOccasionalDataIntervalSec:", a3);
    objc_msgSend(v24, "setSamplingMode:withAdditionalSampledProcesses:", a4, a5);
    objc_msgSend(v24, "setOmitSensitiveStrings:", (a6 >> 4) & 1);
    objc_msgSend(v24, "setCancelOnMemoryPressure:", (a6 >> 5) & 1);
    if ((objc_msgSend(v24, "startSampling") & 1) != 0)
    {
      if ((a6 & 0x40) != 0)
        objc_msgSend(v24, "requireHIDEvent:", 1);
      goto LABEL_289;
    }
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v93 = *__error();
        v94 = sub_100030318();
        if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
          sub_100095988();
        *__error() = v93;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_249;
      v57 = *__error();
      v95 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Failed to start sampling"));
      if (v95)
      {
        v96 = v95;
        v97 = CFStringGetCStringPtr(v95, 0x8000100u);
        if (v97)
        {
          v98 = (char *)v97;
          v99 = 0;
        }
        else
        {
          v98 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x176201E8uLL);
          CFStringGetCString(v96, v98, 1024, 0x8000100u);
          v99 = v98;
        }
        if (qword_1000EBD40)
          v133 = (FILE *)qword_1000EBD40;
        else
          v133 = __stderrp;
        fprintf(v133, "%s\n", v98);
        if (v99)
          free(v99);
        v127 = v96;
        goto LABEL_247;
      }
      v129 = sub_100030318();
      if (os_log_type_enabled(v129, OS_LOG_TYPE_FAULT))
        sub_10009595C();
    }
    else
    {
      if (byte_1000EBD38)
      {
        v55 = *__error();
        v56 = sub_100030318();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          sub_1000958F4();
        *__error() = v55;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_249;
      v57 = *__error();
      v58 = sub_1000302B4(pid);
      v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Failed to start sampling"), v58, pid);
      if (v59)
      {
        v60 = v59;
        v61 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v61)
        {
          v62 = (char *)v61;
          v63 = 0;
        }
        else
        {
          v62 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x176201E8uLL);
          CFStringGetCString(v60, v62, 1024, 0x8000100u);
          v63 = v62;
        }
        if (qword_1000EBD40)
          v126 = (FILE *)qword_1000EBD40;
        else
          v126 = __stderrp;
        fprintf(v126, "%s\n", v62);
        if (v63)
          free(v63);
        v127 = v60;
LABEL_247:
        CFRelease(v127);
LABEL_248:
        *__error() = v57;
LABEL_249:
        objc_msgSend(v24, "removeSelfFromPidCache");
LABEL_375:

        goto LABEL_376;
      }
      v124 = sub_100030318();
      if (os_log_type_enabled(v124, OS_LOG_TYPE_FAULT))
        sub_10009588C();
    }
    if (qword_1000EBD40)
      v130 = (FILE *)qword_1000EBD40;
    else
      v130 = __stderrp;
    fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v130);
    goto LABEL_248;
  }
  if ((a6 & 0x102) == 0x100)
  {
    if ((pid & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v25 = *__error();
        v26 = sub_100030318();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
          sub_100095A1C();
        *__error() = v25;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_375;
      v27 = *__error();
      v28 = sub_1000302B4(pid);
      v29 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Not overriding existing sampling callback"), v28, pid);
      if (v29)
      {
        v30 = v29;
        v31 = CFStringGetCStringPtr(v29, 0x8000100u);
        if (!v31)
        {
          v32 = 356614855;
LABEL_309:
          v141 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v32);
          CFStringGetCString(v30, v141, 1024, 0x8000100u);
          v142 = v141;
          goto LABEL_310;
        }
        goto LABEL_276;
      }
      v113 = sub_100030318();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_FAULT))
        sub_1000959B4();
      goto LABEL_370;
    }
    if (byte_1000EBD38)
    {
      v70 = *__error();
      v71 = sub_100030318();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEBUG))
        sub_100095AB0();
      *__error() = v70;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
      goto LABEL_375;
    v27 = *__error();
    v72 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Not overriding existing sampling callback"));
    if (!v72)
    {
      v125 = sub_100030318();
      if (os_log_type_enabled(v125, OS_LOG_TYPE_FAULT))
        sub_100095A84();
      goto LABEL_370;
    }
    v73 = v72;
    v74 = CFStringGetCStringPtr(v72, 0x8000100u);
    if (!v74)
    {
      v75 = 356614855;
LABEL_360:
      v146 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v75);
      CFStringGetCString(v73, v146, 1024, 0x8000100u);
      v147 = v146;
      goto LABEL_361;
    }
    goto LABEL_285;
  }
  if ((a6 & 0x10) != 0 && (objc_msgSend(v24, "omitSensitiveStrings") & 1) == 0)
  {
    if ((pid & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v88 = *__error();
        v89 = sub_100030318();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
        {
          v90 = sub_1000302B4(pid);
          buffer = 136446466;
          v193 = v90;
          v194 = 1024;
          v195 = pid;
          _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%{public}s [%d]: Already sampling with sensitive strings", (uint8_t *)&buffer, 0x12u);
        }
        *__error() = v88;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
        goto LABEL_375;
      v27 = *__error();
      v91 = sub_1000302B4(pid);
      v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Already sampling with sensitive strings"), v91, pid);
      if (v92)
      {
        v30 = v92;
        v31 = CFStringGetCStringPtr(v92, 0x8000100u);
        if (!v31)
        {
          v32 = 3335414674;
          goto LABEL_309;
        }
LABEL_276:
        v141 = (char *)v31;
        v142 = 0;
LABEL_310:
        if (qword_1000EBD40)
          v150 = (FILE *)qword_1000EBD40;
        else
          v150 = __stderrp;
        fprintf(v150, "%s\n", v141);
        if (v142)
          free(v142);
        v151 = v30;
LABEL_367:
        CFRelease(v151);
LABEL_374:
        *__error() = v27;
        goto LABEL_375;
      }
      v132 = sub_100030318();
      if (os_log_type_enabled(v132, OS_LOG_TYPE_FAULT))
        sub_100095E54();
LABEL_370:
      if (qword_1000EBD40)
        v178 = (FILE *)qword_1000EBD40;
      else
        v178 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v178);
      goto LABEL_374;
    }
    if (byte_1000EBD38)
    {
      v121 = *__error();
      v122 = sub_100030318();
      if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buffer) = 0;
        _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "Already sampling with sensitive strings", (uint8_t *)&buffer, 2u);
      }
      *__error() = v121;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 2)
      goto LABEL_375;
    v27 = *__error();
    v123 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Already sampling with sensitive strings"));
    if (!v123)
    {
      v177 = sub_100030318();
      if (os_log_type_enabled(v177, OS_LOG_TYPE_FAULT))
        sub_100095EBC();
      goto LABEL_370;
    }
    v73 = v123;
    v74 = CFStringGetCStringPtr(v123, 0x8000100u);
    if (!v74)
    {
      v75 = 3335414674;
      goto LABEL_360;
    }
LABEL_285:
    v146 = (char *)v74;
    v147 = 0;
LABEL_361:
    if (qword_1000EBD40)
      v176 = (FILE *)qword_1000EBD40;
    else
      v176 = __stderrp;
    fprintf(v176, "%s\n", v146);
    if (v147)
      free(v147);
    v151 = v73;
    goto LABEL_367;
  }
  if ((a6 & 2) != 0)
  {
    if ((pid & 0x80000000) != 0)
    {
      if (byte_1000EBD38)
      {
        v108 = *__error();
        v109 = sub_100030318();
        if (os_log_type_enabled(v109, OS_LOG_TYPE_DEBUG))
          sub_100095E28();
        *__error() = v108;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_259;
      v110 = *__error();
      v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Already sampling, overriding existing callback"));
      v183 = v110;
      if (!v79)
      {
        v135 = sub_100030318();
        if (os_log_type_enabled(v135, OS_LOG_TYPE_FAULT))
          sub_100095DFC();
        goto LABEL_254;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v76 = *__error();
        v77 = sub_100030318();
        if (os_log_type_enabled(v77, OS_LOG_TYPE_DEBUG))
          sub_100095D94();
        *__error() = v76;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 0)
        goto LABEL_259;
      v183 = *__error();
      v78 = sub_1000302B4(pid);
      v79 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Already sampling, overriding existing callback"), v78, pid);
      if (!v79)
      {
        v80 = sub_100030318();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_FAULT))
          sub_100095D2C();
        goto LABEL_254;
      }
    }
    v105 = v79;
    v106 = CFStringGetCStringPtr(v79, 0x8000100u);
    alloc = (CFAllocatorRef)v105;
    if (!v106)
    {
      v107 = 3527695562;
      goto LABEL_218;
    }
LABEL_174:
    v111 = (char *)v106;
    v112 = 0;
LABEL_219:
    if (qword_1000EBD40)
      v128 = (FILE *)qword_1000EBD40;
    else
      v128 = __stderrp;
    fprintf(v128, "%s\n", v111);
    if (v112)
      free(v112);
    CFRelease(alloc);
    goto LABEL_258;
  }
  if ((pid & 0x80000000) != 0)
  {
    if (byte_1000EBD38)
    {
      v102 = *__error();
      v103 = sub_100030318();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        sub_100095D00();
      *__error() = v102;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v104 = *__error();
      v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Already sampling, not overriding existing callback"));
      v183 = v104;
      if (!v44)
      {
        v134 = sub_100030318();
        if (os_log_type_enabled(v134, OS_LOG_TYPE_FAULT))
          sub_100095CD4();
        goto LABEL_254;
      }
LABEL_164:
      v105 = v44;
      v106 = CFStringGetCStringPtr(v44, 0x8000100u);
      alloc = (CFAllocatorRef)v105;
      if (!v106)
      {
        v107 = 816801464;
LABEL_218:
        v111 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v107);
        CFStringGetCString(v105, v111, 1024, 0x8000100u);
        v112 = v111;
        goto LABEL_219;
      }
      goto LABEL_174;
    }
  }
  else
  {
    if (byte_1000EBD38)
    {
      v41 = *__error();
      v42 = sub_100030318();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        sub_100095C6C();
      *__error() = v41;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
    {
      v183 = *__error();
      v43 = sub_1000302B4(pid);
      v44 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Already sampling, not overriding existing callback"), v43, pid);
      if (!v44)
      {
        v45 = sub_100030318();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
          sub_100095C04();
LABEL_254:
        if (qword_1000EBD40)
          v136 = (FILE *)qword_1000EBD40;
        else
          v136 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v136);
LABEL_258:
        *__error() = v183;
        goto LABEL_259;
      }
      goto LABEL_164;
    }
  }
LABEL_259:
  if (objc_msgSend(v24, "samplingIntervalUs") != (_DWORD)a2
    || (_DWORD)a3
    && objc_msgSend(v24, "occasionalDataIntervalSec")
    && objc_msgSend(v24, "occasionalDataIntervalSec") != (_DWORD)a3)
  {
    if ((pid & 0x80000000) == 0)
    {
      if (byte_1000EBD38)
      {
        v137 = *__error();
        v138 = sub_100030318();
        if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
          sub_100095B44();
        *__error() = v137;
      }
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_375;
      v27 = *__error();
      v139 = sub_1000302B4(pid);
      v140 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Already sampling with incompatible parameters"), v139, pid);
      if (v140)
      {
        v30 = v140;
        v31 = CFStringGetCStringPtr(v140, 0x8000100u);
        if (!v31)
        {
          v32 = 32670908;
          goto LABEL_309;
        }
        goto LABEL_276;
      }
      v149 = sub_100030318();
      if (os_log_type_enabled(v149, OS_LOG_TYPE_FAULT))
        sub_100095ADC();
      goto LABEL_370;
    }
    if (byte_1000EBD38)
    {
      v143 = *__error();
      v144 = sub_100030318();
      if (os_log_type_enabled(v144, OS_LOG_TYPE_ERROR))
        sub_100095BD8();
      *__error() = v143;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
      goto LABEL_375;
    v27 = *__error();
    v145 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Already sampling with incompatible parameters"));
    if (!v145)
    {
      v152 = sub_100030318();
      if (os_log_type_enabled(v152, OS_LOG_TYPE_FAULT))
        sub_100095BAC();
      goto LABEL_370;
    }
    v73 = v145;
    v74 = CFStringGetCStringPtr(v145, 0x8000100u);
    if (!v74)
    {
      v75 = 32670908;
      goto LABEL_360;
    }
    goto LABEL_285;
  }
  if (objc_msgSend(v24, "samplingMode") >= a4)
  {
    if ((a6 & 2) != 0)
    {
      objc_msgSend(v24, "setSamplingMode:withAdditionalSampledProcesses:", a4, a5);
      objc_msgSend(v24, "setCancelOnMemoryPressure:", (a6 >> 5) & 1);
LABEL_293:
      objc_msgSend(v24, "requireHIDEvent:", (a6 >> 6) & 1);
      LODWORD(v148) = 1;
LABEL_294:
      if ((a6 & 8) != 0)
        objc_msgSend(v24, "setIsUrgent:", 1);
      v190[0] = _NSConcreteStackBlock;
      v190[1] = 3221225472;
      v190[2] = sub_10006E5D0;
      v190[3] = &unk_1000DDAC8;
      v190[4] = v24;
      v190[5] = a8;
      objc_msgSend(v24, "setSamplingCompletionHandlerQueue:andBlock:", a7, v190);
      goto LABEL_297;
    }
    if ((a6 & 0x20) == 0)
      objc_msgSend(v24, "setCancelOnMemoryPressure:", 0, a5);
  }
  else
  {
    objc_msgSend(v24, "setSamplingMode:withAdditionalSampledProcesses:", a4, a5);
    if ((a6 & 0x22) != 0x20)
    {
      objc_msgSend(v24, "setCancelOnMemoryPressure:", (a6 >> 5) & 1);
      if ((a6 & 2) != 0)
        goto LABEL_293;
    }
  }
LABEL_289:
  v148 = (a6 >> 1) & 1;
  if ((a6 & 2) != 0 || !v191)
    goto LABEL_294;
LABEL_297:
  if (a9 > 0.0)
    objc_msgSend(v24, "setSamplingTimeoutAtTime:", a9);
  if (((v191 != 0) & ~(_DWORD)v148) == 0)
    objc_msgSend(v24, "setStopWhenProcessExits:", a6 & 1);
  if ((a6 & 0x80) != 0)
    objc_msgSend(v24, "gatherLoadInfoForPid:", pid);
  if (v187)
    objc_msgSend(v24, "setTargetProcessAbsolutePath:", v187);
  return v24;
}

uint64_t sub_10006E5D0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 32), a2);
}

uint64_t sub_10006E5E4(int a1)
{
  uint64_t v1;

  v1 = 0x400000;
  if (a1 == 37)
    v1 = 0x4000;
  if (a1 == 2)
    return 0x8000000000;
  else
    return v1;
}

const char *sub_10006E888(int a1)
{
  if ((a1 - 1) > 9)
    return "unknown";
  else
    return off_1000DDB30[(char)(a1 - 1)];
}

void sub_10006E8B4(id a1)
{
  NSObject *v1;

  qword_1000EBCD0 = (uint64_t)objc_alloc_init((Class)NSMutableDictionary);
  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000EBCC8 = (uint64_t)dispatch_queue_create("com.apple.spindump.processes_waiting_for_hid_event", v1);
  dispatch_release(v1);
}

uint64_t sub_10006E90C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

_DWORD *sub_10006E920(uint64_t a1)
{
  return sub_1000302B4(*(_DWORD *)(*(_QWORD *)a1 + 72));
}

_DWORD *sub_10006E930(int *a1)
{
  return sub_1000302B4(*a1);
}

id sub_10006E9F4(id *a1)
{
  return objc_msgSend(*a1, "targetProcessId");
}

id sub_10006EA00()
{
  id *v0;

  return objc_msgSend(*v0, "targetProcessId");
}

void sub_10006EA0C(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, a5, 0xCu);
}

void sub_10006EA18(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, (uint8_t *)va, 0xEu);
}

void sub_10006EA2C(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x1Eu);
}

void sub_10006EA40(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0xEu);
}

id sub_10006EA64()
{
  id *v0;

  return objc_msgSend(*v0, "machAbsTimeSeconds");
}

void sub_10006EA70(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

id sub_10006EB70(uint64_t a1, void *a2)
{
  void *v3;
  id v4;
  id v5;
  id v6;
  uint64_t v7;
  void *v8;
  void *v9;
  int v10;
  int v11;
  NSObject *v12;
  BOOL v13;
  int v14;
  const __CFString *v15;
  const __CFString *v16;
  void *v17;
  id v18;
  const char *CStringPtr;
  char *v20;
  char *v21;
  uint64_t stackshot_buffer;
  id v23;
  uint64_t v24;
  NSObject *v25;
  FILE *v26;
  FILE *v27;
  id v28;
  int v29;
  id v30;
  uint64_t v31;
  int v33;
  _QWORD block[4];
  int v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  _QWORD v40[4];
  int v41;
  char v42[16];
  char v43[16];
  _BYTE v44[128];

  if (a2)
  {
    v3 = a2;
    v38 = 0u;
    v39 = 0u;
    v36 = 0u;
    v37 = 0u;
    v4 = objc_msgSend(a2, "countByEnumeratingWithState:objects:count:", &v36, v44, 16);
    if (v4)
    {
      v5 = v4;
      v6 = 0;
      v7 = *(_QWORD *)v37;
      do
      {
        v8 = 0;
        do
        {
          if (*(_QWORD *)v37 != v7)
            objc_enumerationMutation(v3);
          v9 = *(void **)(*((_QWORD *)&v36 + 1) + 8 * (_QWORD)v8);
          stackshot_config_set_pid(a1, objc_msgSend(v9, "intValue"));
          v10 = stackshot_capture_with_config(a1);
          if (v10)
          {
            if (v10 == 2)
            {
              if (byte_1000EBD38)
              {
                v11 = *__error();
                v12 = sub_100030318();
                if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
                  sub_10009639C((uint64_t)v43, v9);
                *__error() = v11;
              }
              if (byte_1000EBD39)
                v13 = dword_1000EB4E8 <= 0;
              else
                v13 = 0;
              if (v13)
              {
                v14 = *__error();
                v15 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("pid %d doesn't exist"), objc_msgSend(v9, "intValue"));
                if (v15)
                {
                  v16 = v15;
                  v33 = v14;
                  v17 = v3;
                  v18 = v6;
                  CStringPtr = CFStringGetCStringPtr(v15, 0x8000100u);
                  if (CStringPtr)
                  {
                    v20 = (char *)CStringPtr;
                    v21 = 0;
                  }
                  else
                  {
                    v20 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x3561A610uLL);
                    CFStringGetCString(v16, v20, 1024, 0x8000100u);
                    v21 = v20;
                  }
                  if (qword_1000EBD40)
                    v27 = (FILE *)qword_1000EBD40;
                  else
                    v27 = __stderrp;
                  fprintf(v27, "%s\n", v20);
                  if (v21)
                    free(v21);
                  CFRelease(v16);
                  v6 = v18;
                  v3 = v17;
                  v14 = v33;
                }
                else
                {
                  v25 = sub_100030318();
                  if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
                    sub_10009634C((uint64_t)v42, v9);
                  if (qword_1000EBD40)
                    v26 = (FILE *)qword_1000EBD40;
                  else
                    v26 = __stderrp;
                  fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
                }
                *__error() = v14;
              }
              objc_msgSend(v3, "removeObject:", v9);
            }
            else
            {
              block[0] = _NSConcreteStackBlock;
              block[1] = 3221225472;
              block[2] = sub_10006F204;
              block[3] = &unk_1000DDB80;
              v35 = v10;
              if (qword_1000EBCE8 != -1)
                dispatch_once(&qword_1000EBCE8, block);
            }
          }
          else
          {
            if (v6)
            {
              stackshot_buffer = stackshot_config_get_stackshot_buffer(a1);
              objc_msgSend(v6, "appendBytes:length:", stackshot_buffer, stackshot_config_get_stackshot_size(a1));
            }
            else
            {
              v23 = objc_alloc((Class)NSMutableData);
              v24 = stackshot_config_get_stackshot_buffer(a1);
              v6 = objc_msgSend(v23, "initWithBytes:length:", v24, stackshot_config_get_stackshot_size(a1));
            }
            stackshot_config_dealloc_buffer(a1);
          }
          v8 = (char *)v8 + 1;
        }
        while (v5 != v8);
        v28 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v36, v44, 16);
        v5 = v28;
      }
      while (v28);
      return v6;
    }
    return 0;
  }
  stackshot_config_set_pid(a1, 0xFFFFFFFFLL);
  v29 = stackshot_capture_with_config(a1);
  if (!v29)
  {
    v30 = objc_alloc((Class)NSData);
    v31 = stackshot_config_get_stackshot_buffer(a1);
    return objc_msgSend(v30, "initWithBytesNoCopy:length:freeWhenDone:", v31, stackshot_config_get_stackshot_size(a1), 0);
  }
  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472;
  v40[2] = sub_10006F044;
  v40[3] = &unk_1000DDB80;
  v41 = v29;
  if (qword_1000EBCE0 != -1)
  {
    dispatch_once(&qword_1000EBCE0, v40);
    return 0;
  }
  return 0;
}

int *sub_10006F044(int *result)
{
  int *v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  FILE *v12;
  FILE *v13;

  v1 = result;
  if (byte_1000EBD38)
  {
    v2 = *__error();
    v3 = sub_100030318();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_100096450();
    result = __error();
    *result = v2;
  }
  if (byte_1000EBD39)
    v4 = dword_1000EB4E8 <= 3;
  else
    v4 = 0;
  if (v4)
  {
    v5 = *__error();
    v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Stackshot failed: %d"), v1[8]);
    if (v6)
    {
      v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        v9 = (char *)CStringPtr;
        v10 = 0;
      }
      else
      {
        v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1EA7E9DEuLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        v10 = v9;
      }
      if (qword_1000EBD40)
        v13 = (FILE *)qword_1000EBD40;
      else
        v13 = __stderrp;
      fprintf(v13, "%s\n", v9);
      if (v10)
        free(v10);
      CFRelease(v7);
    }
    else
    {
      v11 = sub_100030318();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        sub_1000963EC();
      if (qword_1000EBD40)
        v12 = (FILE *)qword_1000EBD40;
      else
        v12 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    result = __error();
    *result = v5;
  }
  return result;
}

int *sub_10006F204(int *result)
{
  int *v1;
  int v2;
  NSObject *v3;
  BOOL v4;
  int v5;
  const __CFString *v6;
  const __CFString *v7;
  const char *CStringPtr;
  char *v9;
  char *v10;
  NSObject *v11;
  FILE *v12;
  FILE *v13;

  v1 = result;
  if (byte_1000EBD38)
  {
    v2 = *__error();
    v3 = sub_100030318();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
      sub_100096450();
    result = __error();
    *result = v2;
  }
  if (byte_1000EBD39)
    v4 = dword_1000EB4E8 <= 3;
  else
    v4 = 0;
  if (v4)
  {
    v5 = *__error();
    v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Stackshot failed: %d"), v1[8]);
    if (v6)
    {
      v7 = v6;
      CStringPtr = CFStringGetCStringPtr(v6, 0x8000100u);
      if (CStringPtr)
      {
        v9 = (char *)CStringPtr;
        v10 = 0;
      }
      else
      {
        v9 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1EAC331uLL);
        CFStringGetCString(v7, v9, 1024, 0x8000100u);
        v10 = v9;
      }
      if (qword_1000EBD40)
        v13 = (FILE *)qword_1000EBD40;
      else
        v13 = __stderrp;
      fprintf(v13, "%s\n", v9);
      if (v10)
        free(v10);
      CFRelease(v7);
    }
    else
    {
      v11 = sub_100030318();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_FAULT))
        sub_1000963EC();
      if (qword_1000EBD40)
        v12 = (FILE *)qword_1000EBD40;
      else
        v12 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v12);
    }
    result = __error();
    *result = v5;
  }
  return result;
}

void sub_100070058(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000700D0(uint64_t a1)
{
  _opaque_pthread_t *v2;
  thread_act_t v3;
  _opaque_pthread_t *v4;
  thread_act_t v5;
  dispatch_semaphore_t v6;
  int v7;
  dispatch_time_t v8;
  double Current;
  uint64_t v10;
  void *v11;
  _DWORD *v12;
  int v13;
  NSObject *v14;
  BOOL v15;
  _BOOL4 v16;
  int v17;
  const __CFString *v18;
  const __CFString *v19;
  char *v20;
  char *v21;
  NSObject *v22;
  FILE *v23;
  FILE *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  id v29;
  double v30;
  id v31;
  id v32;
  int v33;
  NSObject *v34;
  const __CFString *v35;
  const __CFString *v36;
  char *v37;
  char *v38;
  NSObject *v39;
  FILE *v40;
  FILE *v41;
  unint64_t *v42;
  unint64_t v43;
  int64_t v44;
  NSObject *global_queue;
  id v46;
  id v47;
  int v48;
  NSObject *v49;
  uint64_t v50;
  char *v51;
  const __CFString *v52;
  const __CFString *v53;
  char *v54;
  char *v55;
  NSObject *v56;
  FILE *v57;
  FILE *v58;
  NSObject *v59;
  intptr_t v60;
  double v61;
  unsigned int v62;
  int v63;
  char *v64;
  int v65;
  char *v66;
  int v67;
  NSObject *v68;
  int v69;
  const __CFString *v70;
  const __CFString *v71;
  char *v72;
  char *v73;
  NSObject *v74;
  FILE *v75;
  FILE *v76;
  uint64_t v77;
  int v79;
  const __CFString *v80;
  const __CFString *v81;
  NSObject *v82;
  FILE *v83;
  int v84;
  NSObject *v85;
  int v86;
  NSObject *v87;
  int v88;
  const __CFString *v89;
  const __CFString *v90;
  char *CStringPtr;
  char *v92;
  int v93;
  NSObject *v94;
  int v95;
  const __CFString *v96;
  const __CFString *v97;
  char *v98;
  char *v99;
  char *v100;
  char *v101;
  NSObject *v102;
  FILE *v103;
  NSObject *v104;
  FILE *v105;
  FILE *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  FILE *v111;
  FILE *v112;
  int v113;
  void *context;
  int v115;
  int v116;
  NSObject *group;
  id v118;
  unsigned __int8 v119;
  NSObject *dsema;
  _QWORD v121[10];
  int v122;
  _QWORD block[7];
  char v124;
  _BYTE v125[15];
  char v126;
  _BYTE v127[7];
  uint64_t v128;
  uint64_t *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t *v133;
  uint64_t v134;
  uint64_t v135;
  integer_t v136;
  integer_t policy_info;
  _DWORD v138[8];
  uint8_t buf[4];
  int v140;
  __int16 v141;
  _BYTE v142[10];

  context = objc_autoreleasePoolPush();
  policy_info = 0;
  v2 = pthread_self();
  v3 = pthread_mach_thread_np(v2);
  if (thread_policy_set(v3, 1u, &policy_info, 1u))
  {
    v86 = *__error();
    v87 = sub_100030318();
    if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT))
      sub_1000968C0();
    *__error() = v86;
    if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
    {
      v88 = *__error();
      v89 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("failed to set the sampling thread to a fixed-priority policy"));
      v90 = v89;
      if (v89)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v89, 0x8000100u);
        if (CStringPtr)
        {
          v92 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA0579F5AuLL);
          CFStringGetCString(v90, CStringPtr, 1024, 0x8000100u);
          v92 = CStringPtr;
        }
        if (qword_1000EBD40)
          v111 = (FILE *)qword_1000EBD40;
        else
          v111 = __stderrp;
        fprintf(v111, "%s\n", CStringPtr);
        if (v92)
          free(v92);
        CFRelease(v90);
      }
      else
      {
        v102 = sub_100030318();
        if (os_log_type_enabled(v102, OS_LOG_TYPE_FAULT))
          sub_100096894();
        if (qword_1000EBD40)
          v103 = (FILE *)qword_1000EBD40;
        else
          v103 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v103);
      }
      *__error() = v88;
    }
  }
  v136 = 63;
  v4 = pthread_self();
  v5 = pthread_mach_thread_np(v4);
  if (thread_policy_set(v5, 3u, &v136, 1u))
  {
    v93 = *__error();
    v94 = sub_100030318();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_FAULT))
      sub_100096868();
    *__error() = v93;
    if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
    {
      v95 = *__error();
      v96 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("failed to set sampling thread's priority"));
      v97 = v96;
      if (v96)
      {
        v98 = (char *)CFStringGetCStringPtr(v96, 0x8000100u);
        if (v98)
        {
          v99 = 0;
        }
        else
        {
          v98 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x729B46B9uLL);
          CFStringGetCString(v97, v98, 1024, 0x8000100u);
          v99 = v98;
        }
        if (qword_1000EBD40)
          v112 = (FILE *)qword_1000EBD40;
        else
          v112 = __stderrp;
        fprintf(v112, "%s\n", v98);
        if (v99)
          free(v99);
        CFRelease(v97);
      }
      else
      {
        v104 = sub_100030318();
        if (os_log_type_enabled(v104, OS_LOG_TYPE_FAULT))
          sub_10009683C();
        if (qword_1000EBD40)
          v105 = (FILE *)qword_1000EBD40;
        else
          v105 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v105);
      }
      *__error() = v95;
    }
  }
  v6 = 0;
  v132 = 0;
  v133 = &v132;
  v134 = 0x2020000000;
  v135 = 0;
  if (!(byte_1000EBD90 | byte_1000EBD91))
    v6 = dispatch_semaphore_create(0);
  dsema = v6;
  group = dispatch_group_create();
  v7 = byte_1000EBD91;
  if (byte_1000EBD91)
    dispatch_suspend(*(dispatch_object_t *)(a1 + 24));
  v128 = 0;
  v129 = &v128;
  v130 = 0x2020000000;
  v131 = 0;
  v8 = dispatch_time(0, 0);
  Current = SAMachAbsTimeSecondsGetCurrent(v8);
  v113 = v7;
  objc_msgSend(*(id *)(a1 + 8), "startingSamplingLiveSystem");
  v119 = 0;
  v118 = 0;
  v10 = 0;
  do
  {
    v11 = objc_autoreleasePoolPush();
    if ((byte_1000EBD4C & 2) != 0 && sub_100025FB4())
    {
      ++*(_DWORD *)(a1 + 88);
      goto LABEL_118;
    }
    ++*(_DWORD *)(a1 + 84);
    v12 = (_DWORD *)dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 112), 0);
    if (v12)
    {
      if (byte_1000EBD38)
      {
        v13 = *__error();
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_100096810(&v126, v127);
        v12 = __error();
        *v12 = v13;
      }
      if (byte_1000EBD39)
        v15 = dword_1000EB4E8 <= 3;
      else
        v15 = 0;
      if (v15)
      {
        v17 = *__error();
        v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to update sampling pid list"));
        v19 = v18;
        if (v18)
        {
          v20 = (char *)CFStringGetCStringPtr(v18, 0x8000100u);
          if (v20)
          {
            v21 = 0;
          }
          else
          {
            v20 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x8800F6EBuLL);
            CFStringGetCString(v19, v20, 1024, 0x8000100u);
            v21 = v20;
          }
          if (qword_1000EBD40)
            v24 = (FILE *)qword_1000EBD40;
          else
            v24 = __stderrp;
          fprintf(v24, "%s\n", v20);
          if (v21)
            free(v21);
          CFRelease(v19);
        }
        else
        {
          v22 = sub_100030318();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
            sub_1000967E4(&v124, v125);
          if (qword_1000EBD40)
            v23 = (FILE *)qword_1000EBD40;
          else
            v23 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
        }
        v12 = __error();
        v16 = 0;
        *v12 = v17;
      }
      else
      {
        v16 = 0;
      }
    }
    else
    {
      v16 = *(_BYTE *)(a1 + 104) != 0;
      if (*(_BYTE *)(a1 + 104))
      {
        *(_BYTE *)(a1 + 104) = 0;

        v118 = objc_msgSend(*(id *)(a1 + 96), "mutableCopy");
      }
      v12 = (_DWORD *)dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 112));
    }
    v25 = v129[3];
    if (v25)
      v129[3] = 0;
    else
      v25 = stackshot_config_create(v12);
    if ((byte_1000EBD4C & 0x20) != 0)
      v26 = 0x44DA1200BLL;
    else
      v26 = 1302405131;
    if (v10)
      v27 = v16;
    else
      v27 = 1;
    if (v27 == 1)
    {
      stackshot_config_set_flags(v25, v26);
      stackshot_config_set_delta_timestamp(v25, 0);
    }
    else
    {
      stackshot_config_set_flags(v25, v26 | 0x40000);
      stackshot_config_set_delta_timestamp(v25, v10);
      if (dword_1000EBD10)
      {
        v28 = (((double)dword_1000EBD10 * 1.2) + 0x3FFFF) & 0xFFFC0000;
        stackshot_config_set_size_hint(v25, v28);
        goto LABEL_55;
      }
    }
    v28 = 0;
LABEL_55:
    v10 = mach_absolute_time();
    v29 = sub_10006EB70(v25, v118);
    if (v29)
    {
      v30 = SASecondsFromMachTimeUsingLiveTimebase(v10);
      if ((unint64_t)objc_msgSend(v29, "length") >= 0xFFFFFFFF)
      {
        if (byte_1000EBD38)
        {
          v84 = *__error();
          v85 = sub_100030318();
          if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
            sub_100096798(buf, (uint64_t)objc_msgSend(v29, "length"));
          *__error() = v84;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v79 = *__error();
          v80 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: bad stackshot data length %lu"), "stackshotData.length < 4294967295U", objc_msgSend(v29, "length"));
          v81 = v80;
          if (v80)
          {
            v100 = (char *)CFStringGetCStringPtr(v80, 0x8000100u);
            if (v100)
            {
              v101 = 0;
            }
            else
            {
              v100 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xC6745CE3uLL);
              CFStringGetCString(v81, v100, 1024, 0x8000100u);
              v101 = v100;
            }
            if (qword_1000EBD40)
              v106 = (FILE *)qword_1000EBD40;
            else
              v106 = __stderrp;
            fprintf(v106, "%s\n", v100);
            if (v101)
              free(v101);
            CFRelease(v81);
          }
          else
          {
            v82 = sub_100030318();
            if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
              sub_100096758(v138, (uint64_t)objc_msgSend(v29, "length"));
            if (qword_1000EBD40)
              v83 = (FILE *)qword_1000EBD40;
            else
              v83 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v83);
          }
          *__error() = v79;
        }
        objc_msgSend(v29, "length");
        sub_1000301F0("_SamplingThread", "SPSampleProvider.m", 270, "%s: bad stackshot data length %lu", v107, v108, v109, v110, (char)"stackshotData.length < 4294967295U");
        abort();
      }
      v31 = objc_msgSend(v29, "length");
      v32 = v31;
      if ((v27 & 1) == 0)
      {
        if ((_DWORD)v28 && v28 < v31)
        {
          if (byte_1000EBD38)
          {
            v33 = *__error();
            v34 = sub_100030318();
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 67109632;
              v140 = dword_1000EBD10;
              v141 = 1024;
              *(_DWORD *)v142 = v28;
              *(_WORD *)&v142[4] = 1024;
              *(_DWORD *)&v142[6] = (_DWORD)v32;
              _os_log_debug_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEBUG, "Hint too small (previous %d, hint %d, actual %d)", buf, 0x14u);
            }
            *__error() = v33;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 0)
          {
            v115 = *__error();
            v35 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Hint too small (previous %d, hint %d, actual %d)"), dword_1000EBD10, v28, v32);
            v36 = v35;
            if (v35)
            {
              v37 = (char *)CFStringGetCStringPtr(v35, 0x8000100u);
              if (v37)
              {
                v38 = 0;
              }
              else
              {
                v37 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xF03250C4uLL);
                CFStringGetCString(v36, v37, 1024, 0x8000100u);
                v38 = v37;
              }
              if (qword_1000EBD40)
                v41 = (FILE *)qword_1000EBD40;
              else
                v41 = __stderrp;
              fprintf(v41, "%s\n", v37);
              if (v38)
                free(v38);
              CFRelease(v36);
            }
            else
            {
              v39 = sub_100030318();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)buf = 67109632;
                v140 = dword_1000EBD10;
                v141 = 1024;
                *(_DWORD *)v142 = v28;
                *(_WORD *)&v142[4] = 1024;
                *(_DWORD *)&v142[6] = (_DWORD)v32;
                _os_log_fault_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_FAULT, "Unable to format: Hint too small (previous %d, hint %d, actual %d)", buf, 0x14u);
              }
              if (qword_1000EBD40)
                v40 = (FILE *)qword_1000EBD40;
              else
                v40 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v40);
            }
            *__error() = v115;
          }
        }
        if (dword_1000EBD10 < v32)
          dword_1000EBD10 = (int)v32;
      }
      if (dsema)
      {
        v42 = (unint64_t *)(v133 + 3);
        do
        {
          v43 = __ldxr(v42);
          v44 = v43 + v32;
        }
        while (__stxr(v44, v42));
        v119 |= v44 > 20971519;
      }
      global_queue = dispatch_get_global_queue(25, 0);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000743EC;
      block[3] = &unk_1000DDC68;
      *(double *)&block[6] = v30;
      block[4] = a1;
      block[5] = group;
      dispatch_async(global_queue, block);
      if (qword_1000EBD20 != -1)
        dispatch_once(&qword_1000EBD20, &stru_1000DDC88);
      if (qword_1000EBD18)
      {
        v46 = objc_msgSend(v29, "bytes");
        v47 = objc_msgSend(v29, "length");
        if (fwrite(v46, (size_t)v47, 1uLL, (FILE *)qword_1000EBD18) != 1)
        {
          if (byte_1000EBD38)
          {
            v48 = *__error();
            v49 = sub_100030318();
            if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
            {
              v63 = ferror((FILE *)qword_1000EBD18);
              v64 = strerror(v63);
              *(_DWORD *)buf = 67109378;
              v140 = v63;
              v141 = 2080;
              *(_QWORD *)v142 = v64;
              _os_log_error_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Unable to write stackshot: %d (%s)", buf, 0x12u);
            }
            *__error() = v48;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
          {
            v116 = *__error();
            v50 = ferror((FILE *)qword_1000EBD18);
            v51 = strerror(v50);
            v52 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to write stackshot: %d (%s)"), v50, v51);
            v53 = v52;
            if (v52)
            {
              v54 = (char *)CFStringGetCStringPtr(v52, 0x8000100u);
              if (v54)
              {
                v55 = 0;
              }
              else
              {
                v54 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1704688FuLL);
                CFStringGetCString(v53, v54, 1024, 0x8000100u);
                v55 = v54;
              }
              if (qword_1000EBD40)
                v58 = (FILE *)qword_1000EBD40;
              else
                v58 = __stderrp;
              fprintf(v58, "%s\n", v54);
              if (v55)
                free(v55);
              CFRelease(v53);
            }
            else
            {
              v56 = sub_100030318();
              if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
              {
                v65 = ferror((FILE *)qword_1000EBD18);
                v66 = strerror(v65);
                *(_DWORD *)buf = 67109378;
                v140 = v65;
                v141 = 2080;
                *(_QWORD *)v142 = v66;
                _os_log_fault_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, "Unable to format: Unable to write stackshot: %d (%s)", buf, 0x12u);
              }
              if (qword_1000EBD40)
                v57 = (FILE *)qword_1000EBD40;
              else
                v57 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v57);
            }
            *__error() = v116;
          }
          fclose((FILE *)qword_1000EBD18);
          qword_1000EBD18 = 0;
        }
      }
      v59 = *(NSObject **)(a1 + 24);
      v121[0] = _NSConcreteStackBlock;
      v121[1] = 3221225472;
      v121[2] = sub_100074A00;
      v121[3] = &unk_1000DDCB0;
      v121[4] = a1;
      v121[5] = v29;
      v121[7] = &v128;
      v121[6] = dsema;
      v122 = (int)v32;
      v121[8] = &v132;
      v121[9] = v25;
      dispatch_group_async(group, v59, v121);
    }
LABEL_118:
    objc_autoreleasePoolPop(v11);
    if (((dsema != 0) & v119) == 1)
    {
      if (qword_1000EBD28 != -1)
        dispatch_once(&qword_1000EBD28, &stru_1000DDCD0);
      v60 = dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
      v119 = 0;
    }
    v61 = SAMachAbsTimeSecondsGetCurrent(v60);
    v62 = *(_DWORD *)(a1 + 64);
    Current = Current + (double)v62 / 1000000.0;
    if (Current <= v61)
    {
      v8 = dispatch_time(0, 0);
      Current = v61;
    }
    else
    {
      v8 = dispatch_time(v8, 1000 * v62);
    }
  }
  while (dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 48), v8));
  objc_msgSend(*(id *)(a1 + 8), "finishedSamplingLiveSystem");

  if (v113)
  {
    if (qword_1000EBD98 && dispatch_group_wait((dispatch_group_t)qword_1000EBD98, 0))
    {
      if (byte_1000EBD38)
      {
        v67 = *__error();
        v68 = sub_100030318();
        if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "Sampling completed, waiting for SIGINFO...", buf, 2u);
        }
        *__error() = v67;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v69 = *__error();
        v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Sampling completed, waiting for SIGINFO..."));
        v71 = v70;
        if (v70)
        {
          v72 = (char *)CFStringGetCStringPtr(v70, 0x8000100u);
          if (v72)
          {
            v73 = 0;
          }
          else
          {
            v72 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x5EB25A47uLL);
            CFStringGetCString(v71, v72, 1024, 0x8000100u);
            v73 = v72;
          }
          if (qword_1000EBD40)
            v76 = (FILE *)qword_1000EBD40;
          else
            v76 = __stderrp;
          fprintf(v76, "%s\n", v72);
          if (v73)
            free(v73);
          CFRelease(v71);
        }
        else
        {
          v74 = sub_100030318();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
            sub_10009672C();
          if (qword_1000EBD40)
            v75 = (FILE *)qword_1000EBD40;
          else
            v75 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
        }
        *__error() = v69;
      }
      dispatch_group_wait((dispatch_group_t)qword_1000EBD98, 0xFFFFFFFFFFFFFFFFLL);
    }
    dispatch_resume(*(dispatch_object_t *)(a1 + 24));
  }
  dispatch_group_wait(group, 0xFFFFFFFFFFFFFFFFLL);
  v77 = v129[3];
  if (v77)
    stackshot_config_dealloc(v77);
  if (dsema)
    dispatch_release(dsema);
  dispatch_release(group);
  _Block_object_dispose(&v128, 8);
  _Block_object_dispose(&v132, 8);
  objc_autoreleasePoolPop(context);
  return 0;
}

void sub_100071330(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,char a48)
{
  uint64_t v48;

  _Block_object_dispose(&a48, 8);
  _Block_object_dispose((const void *)(v48 - 248), 8);
  _Unwind_Resume(a1);
}

void sub_100071CB4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100071D94(id a1)
{
  NSObject *v1;

  v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_1000EBCF8 = (uint64_t)dispatch_queue_create("com.apple.spindump.sample_provider_singleton", v1);
  dispatch_release(v1);
}

void sub_100071EC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100071EDC(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_100071EEC(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

void sub_100071EF8(uint64_t a1)
{
  int v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  SPStackshotProviderSnapshot *v6;
  int v7;
  NSObject *v8;
  int v9;
  const __CFString *v10;
  const __CFString *v11;
  const char *CStringPtr;
  char *v13;
  char *v14;
  NSObject *v15;
  FILE *v16;
  FILE *v17;

  v2 = dword_1000EBD00;
  if (!dword_1000EBD00)
  {
    qword_1000EBD08 = objc_alloc_init(SPStackshotProvider);
    v2 = dword_1000EBD00;
  }
  dword_1000EBD00 = v2 + 1;
  v3 = +[SATimestamp timestamp](SATimestamp, "timestamp");
  v4 = *(unsigned int *)(qword_1000EBD08 + 84);
  v5 = *(unsigned int *)(qword_1000EBD08 + 88);
  if (objc_msgSend((id)qword_1000EBD08, "startWithSamplingIntervalUs:andOccasionalDataIntervalSec:andOnlySampleProcesses:andOnlySampleMainThreads:andOmitSensitiveStrings:", *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), *(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 56), *(unsigned __int8 *)(a1 + 57)))
  {
    v6 = [SPStackshotProviderSnapshot alloc];
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = -[SPStackshotProviderSnapshot initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:](v6, "initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:", qword_1000EBD08, v3, v4, v5);
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40) = 0;
    if (!--dword_1000EBD00)
    {
      v7 = *__error();
      v8 = sub_100030318();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_FAULT))
        sub_100096A20();
      *__error() = v7;
      if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
      {
        v9 = *__error();
        v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("shared instance has 0 references"));
        if (v10)
        {
          v11 = v10;
          CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
          if (CStringPtr)
          {
            v13 = (char *)CStringPtr;
            v14 = 0;
          }
          else
          {
            v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAA0D9545uLL);
            CFStringGetCString(v11, v13, 1024, 0x8000100u);
            v14 = v13;
          }
          if (qword_1000EBD40)
            v17 = (FILE *)qword_1000EBD40;
          else
            v17 = __stderrp;
          fprintf(v17, "%s\n", v13);
          if (v14)
            free(v14);
          CFRelease(v11);
        }
        else
        {
          v15 = sub_100030318();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
            sub_1000969F4();
          if (qword_1000EBD40)
            v16 = (FILE *)qword_1000EBD40;
          else
            v16 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v16);
        }
        *__error() = v9;
      }

      qword_1000EBD08 = 0;
    }
  }
}

void sub_100072984(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100073A7C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100073B8C(uint64_t a1, double a2, double a3, double a4, double a5)
{
  double v5;
  uint64_t v6;
  double v7;
  id v9;
  uint64_t v10;
  NSObject *v11;
  _QWORD v12[6];

  v5 = *(double *)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 32);
  v7 = *(double *)(v6 + 56);
  if (v5 + -1.0 > v7)
  {
    LODWORD(a5) = *(_DWORD *)(v6 + 68);
    if (v5 + 1.0 < v7 + (double)*(unint64_t *)&a5)
    {
      *(double *)(v6 + 56) = v5;
      v9 = +[SAAuxiliaryData auxiliaryDataForTimestamp:](SAAuxiliaryData, "auxiliaryDataForTimestamp:", 0);
      v10 = *(_QWORD *)(a1 + 32);
      v11 = *(NSObject **)(v10 + 24);
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      v12[2] = sub_100073C40;
      v12[3] = &unk_1000DDBF0;
      v12[4] = v10;
      v12[5] = v9;
      dispatch_async(v11, v12);
    }
  }
}

id sub_100073C40(uint64_t a1)
{
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "addAuxiliaryData:", *(_QWORD *)(a1 + 40));
}

void sub_100073DC0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100073DD8(uint64_t a1)
{
  int v1;
  NSObject *v2;
  BOOL v3;
  int v4;
  const __CFString *v5;
  const __CFString *v6;
  const char *CStringPtr;
  malloc_type_id_t v8;
  int v9;
  NSObject *v10;
  BOOL v11;
  const __CFString *v12;
  char *v13;
  char *v14;
  NSObject *v15;
  NSObject *v16;
  FILE *v17;
  FILE *v18;
  int v19;
  NSObject *v20;
  BOOL v21;
  const __CFString *v22;
  NSObject *v23;

  if (qword_1000EBD08 == *(_QWORD *)(a1 + 32))
  {
    if (--dword_1000EBD00)
    {
      if (byte_1000EBD38)
      {
        v1 = *__error();
        v2 = sub_100030318();
        if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
          sub_100096E98();
        *__error() = v1;
      }
      if (byte_1000EBD39)
        v3 = dword_1000EB4E8 <= 0;
      else
        v3 = 0;
      if (!v3)
        return;
      v4 = *__error();
      v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Stackshot provider shared instance not yet done"));
      if (v5)
      {
        v6 = v5;
        CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
        if (!CStringPtr)
        {
          v8 = 3084941988;
LABEL_36:
          v13 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v8);
          CFStringGetCString(v6, v13, 1024, 0x8000100u);
          v14 = v13;
          goto LABEL_37;
        }
        goto LABEL_26;
      }
      v15 = sub_100030318();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_FAULT))
        sub_100096E6C();
      goto LABEL_31;
    }

    qword_1000EBD08 = 0;
    if (byte_1000EBD38)
    {
      v9 = *__error();
      v10 = sub_100030318();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        sub_100096E40();
      *__error() = v9;
    }
    if (byte_1000EBD39)
      v11 = dword_1000EB4E8 <= 0;
    else
      v11 = 0;
    if (v11)
    {
      v4 = *__error();
      v12 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Stackshot provider shared instance done"));
      if (v12)
      {
        v6 = v12;
        CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
        if (!CStringPtr)
        {
          v8 = 3990020178;
          goto LABEL_36;
        }
LABEL_26:
        v13 = (char *)CStringPtr;
        v14 = 0;
LABEL_37:
        if (qword_1000EBD40)
          v18 = (FILE *)qword_1000EBD40;
        else
          v18 = __stderrp;
        fprintf(v18, "%s\n", v13);
        if (v14)
          free(v14);
        CFRelease(v6);
LABEL_43:
        *__error() = v4;
        return;
      }
      v16 = sub_100030318();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_FAULT))
        sub_100096E14();
LABEL_31:
      if (qword_1000EBD40)
        v17 = (FILE *)qword_1000EBD40;
      else
        v17 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v17);
      goto LABEL_43;
    }
  }
  else
  {
    v19 = *__error();
    v20 = sub_100030318();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_FAULT))
      sub_100096EF0();
    *__error() = v19;
    if (byte_1000EBD39)
      v21 = dword_1000EB4E8 <= 4;
    else
      v21 = 0;
    if (v21)
    {
      v4 = *__error();
      v22 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("shared instance isn't self"));
      if (v22)
      {
        v6 = v22;
        CStringPtr = CFStringGetCStringPtr(v22, 0x8000100u);
        if (!CStringPtr)
        {
          v8 = 1307034781;
          goto LABEL_36;
        }
        goto LABEL_26;
      }
      v23 = sub_100030318();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
        sub_100096EC4();
      goto LABEL_31;
    }
  }
}

uint64_t sub_10007414C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void sub_10007415C(uint64_t a1)
{
  double v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  NSObject *v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v11[8];
  _QWORD block[6];

  objc_msgSend(*(id *)(a1 + 32), "machAbsTimeSeconds");
  if (v2 + -1.0 > *(double *)(*(_QWORD *)(a1 + 40) + 56))
  {
    objc_msgSend(*(id *)(a1 + 32), "machAbsTimeSeconds");
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 56) = v3;
    v4 = +[SAAuxiliaryData auxiliaryDataForTimestamp:](SAAuxiliaryData, "auxiliaryDataForTimestamp:", 0);
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(NSObject **)(v5 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10007427C;
    block[3] = &unk_1000DDBF0;
    block[4] = v5;
    block[5] = v4;
    dispatch_async(v6, block);
  }
  v7 = *(NSObject **)(a1 + 48);
  if (v7)
  {
    v8 = *(_QWORD *)(a1 + 56);
    if (v8)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_100074288;
      v11[3] = &unk_1000DDC18;
      v10 = *(_QWORD *)(a1 + 32);
      v9 = *(_QWORD *)(a1 + 40);
      v11[4] = v9;
      v11[5] = v10;
      v11[7] = *(_QWORD *)(a1 + 64);
      v11[6] = v8;
      if (*(_BYTE *)(a1 + 72))
        dispatch_group_notify(*(dispatch_group_t *)(v9 + 32), v7, v11);
      else
        dispatch_async(v7, v11);
    }
  }
}

id sub_10007427C(uint64_t a1)
{
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "addAuxiliaryData:", *(_QWORD *)(a1 + 40));
}

uint64_t sub_100074288(uint64_t a1)
{
  SPStackshotProviderSnapshot *v2;

  v2 = -[SPStackshotProviderSnapshot initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:]([SPStackshotProviderSnapshot alloc], "initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:", *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60));
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 48) + 16))();
}

uint64_t sub_100074330(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(*(_QWORD *)(a1 + 40) + 16))(*(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8));
}

id sub_1000743A0(uint64_t a1)
{
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 120), "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", *(unsigned int *)(a1 + 40)));
}

void sub_1000743EC(double *a1)
{
  uint64_t v1;
  unsigned int v2;
  void *v4;
  id v5;
  NSObject *v6;
  uint64_t v7;
  NSObject *v8;
  _QWORD v9[6];

  v1 = *((_QWORD *)a1 + 4);
  v2 = *(_DWORD *)(v1 + 68);
  if (v2)
  {
    if (a1[6] > *(double *)(v1 + 56) + (double)v2)
    {
      v4 = objc_autoreleasePoolPush();
      *(double *)(*((_QWORD *)a1 + 4) + 56) = a1[6];
      v5 = +[SAAuxiliaryData auxiliaryDataForTimestamp:](SAAuxiliaryData, "auxiliaryDataForTimestamp:", 0);
      v7 = *((_QWORD *)a1 + 4);
      v6 = *((_QWORD *)a1 + 5);
      v8 = *(NSObject **)(v7 + 24);
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      v9[2] = sub_1000744A4;
      v9[3] = &unk_1000DDBF0;
      v9[4] = v7;
      v9[5] = v5;
      dispatch_group_async(v6, v8, v9);
      objc_autoreleasePoolPop(v4);
    }
  }
}

id sub_1000744A4(uint64_t a1)
{
  return objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "addAuxiliaryData:", *(_QWORD *)(a1 + 40));
}

void sub_1000744B0(id a1)
{
  char *v1;
  size_t v2;
  size_t v3;
  size_t v4;
  pid_t v5;
  int v6;
  NSObject *v7;
  int v8;
  const __CFString *v9;
  NSObject *v10;
  uint64_t v11;
  int v12;
  NSObject *v13;
  uint64_t v14;
  int *v15;
  char *v16;
  const __CFString *v17;
  const char *v18;
  char *v19;
  char *v20;
  FILE *v21;
  NSObject *v22;
  FILE *v23;
  int v24;
  NSObject *v25;
  int v26;
  const __CFString *v27;
  const __CFString *v28;
  const char *CStringPtr;
  char *v30;
  char *v31;
  NSObject *v32;
  FILE *v33;
  FILE *v34;
  size_t v35;
  time_t v36;
  tm v37;
  uint8_t buf[4];
  char *v39;
  char __filename[1032];

  v1 = getenv("SPINDUMP_SAVE_STACKSHOTS");
  if (v1 && strcmp(v1, "0"))
  {
    strcpy(__filename, "/var/mobile/stackshots.");
    memset(&v37, 0, sizeof(v37));
    v36 = time(0);
    localtime_r(&v36, &v37);
    v2 = strftime(&__filename[23], 0x3E9uLL, "%Y-%m-%d-%T", &v37);
    v3 = v2 + 23;
    if (v2 + 23 >= 0x400)
    {
      v35 = v2;
      v24 = *__error();
      v25 = sub_100030318();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
        sub_100097100();
      *__error() = v24;
      v2 = v35;
      if (byte_1000EBD39 && dword_1000EB4E8 <= 4)
      {
        v26 = *__error();
        v27 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("filePath %s cut off with date (needed %zu chars)"), __filename, v3);
        if (v27)
        {
          v28 = v27;
          CStringPtr = CFStringGetCStringPtr(v27, 0x8000100u);
          if (CStringPtr)
          {
            v30 = (char *)CStringPtr;
            v31 = 0;
          }
          else
          {
            v30 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2F5E82CEuLL);
            CFStringGetCString(v28, v30, 1024, 0x8000100u);
            v31 = v30;
          }
          if (qword_1000EBD40)
            v34 = (FILE *)qword_1000EBD40;
          else
            v34 = __stderrp;
          fprintf(v34, "%s\n", v30);
          if (v31)
            free(v31);
          CFRelease(v28);
        }
        else
        {
          v32 = sub_100030318();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
            sub_10009709C();
          if (qword_1000EBD40)
            v33 = (FILE *)qword_1000EBD40;
          else
            v33 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
        }
        *__error() = v26;
        v2 = v35;
      }
    }
    v4 = 1001 - v2;
    v5 = getpid();
    snprintf(&__filename[v3], v4, ".%d.buf", v5);
    qword_1000EBD18 = (uint64_t)fopen(__filename, "w");
    if (qword_1000EBD18)
    {
      if (byte_1000EBD38)
      {
        v6 = *__error();
        v7 = sub_100030318();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136315138;
          v39 = __filename;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Saving stackshots to %s", buf, 0xCu);
        }
        *__error() = v6;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 2)
      {
        v8 = *__error();
        v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Saving stackshots to %s"), __filename);
        if (!v9)
        {
          v10 = sub_100030318();
          if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
            sub_100097034((uint64_t)__filename, v10, v11);
LABEL_32:
          if (qword_1000EBD40)
            v23 = (FILE *)qword_1000EBD40;
          else
            v23 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v23);
LABEL_36:
          *__error() = v8;
          return;
        }
        goto LABEL_21;
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v12 = *__error();
        v13 = sub_100030318();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
          sub_100096FA8((uint64_t)__filename, v13);
        *__error() = v12;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v8 = *__error();
        v14 = *__error();
        v15 = __error();
        v16 = strerror(*v15);
        v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to open %s to save stackshots: %d (%s)"), __filename, v14, v16);
        if (!v9)
        {
          v22 = sub_100030318();
          if (os_log_type_enabled(v22, OS_LOG_TYPE_FAULT))
            sub_100096F1C((uint64_t)__filename, v22);
          goto LABEL_32;
        }
LABEL_21:
        v17 = v9;
        v18 = CFStringGetCStringPtr(v9, 0x8000100u);
        if (v18)
        {
          v19 = (char *)v18;
          v20 = 0;
        }
        else
        {
          v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2F5E82CEuLL);
          CFStringGetCString(v17, v19, 1024, 0x8000100u);
          v20 = v19;
        }
        if (qword_1000EBD40)
          v21 = (FILE *)qword_1000EBD40;
        else
          v21 = __stderrp;
        fprintf(v21, "%s\n", v19);
        if (v20)
          free(v20);
        CFRelease(v17);
        goto LABEL_36;
      }
    }
  }
}

intptr_t sub_100074A00(uint64_t a1)
{
  void *v2;
  id v3;
  id v4;
  uint64_t v5;
  void *i;
  void *v7;
  int v8;
  NSObject *v9;
  BOOL v10;
  int v11;
  _DWORD *v12;
  const __CFString *v13;
  const __CFString *v14;
  const char *v15;
  char *v16;
  char *v17;
  int v18;
  NSObject *v19;
  BOOL v20;
  const __CFString *v21;
  const __CFString *v22;
  const char *CStringPtr;
  char *v24;
  char *v25;
  NSObject *v26;
  _DWORD *v27;
  unsigned int v28;
  FILE *v29;
  const __CFString *v30;
  NSObject *v31;
  FILE *v32;
  FILE *v33;
  _DWORD *v34;
  unsigned int v35;
  uint64_t v36;
  intptr_t result;
  uint64_t v38;
  unint64_t *v39;
  unint64_t v40;
  uint64_t v41;
  void *context;
  char v43;
  _BYTE v44[15];
  char v45;
  _BYTE v46[15];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint8_t buf[4];
  _DWORD *v52;
  __int16 v53;
  unsigned int v54;
  _BYTE v55[128];

  context = objc_autoreleasePoolPush();
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "addKCDataStackshots:createSeparateSamplePerStackshot:", *(_QWORD *)(a1 + 40), 0);
  v47 = 0u;
  v48 = 0u;
  v49 = 0u;
  v50 = 0u;
  v2 = *(void **)(*(_QWORD *)(a1 + 32) + 120);
  v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v47, v55, 16);
  if (!v3)
    goto LABEL_58;
  v4 = v3;
  v5 = *(_QWORD *)v48;
  do
  {
    for (i = 0; i != v4; i = (char *)i + 1)
    {
      if (*(_QWORD *)v48 != v5)
        objc_enumerationMutation(v2);
      v7 = *(void **)(*((_QWORD *)&v47 + 1) + 8 * (_QWORD)i);
      if ((objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 8), "cacheLoadInfoForProcess:", objc_msgSend(v7, "intValue")) & 1) == 0)
      {
        if ((objc_msgSend(v7, "intValue") & 0x80000000) != 0)
        {
          if (byte_1000EBD38)
          {
            v18 = *__error();
            v19 = sub_100030318();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
              sub_100097190(&v45, v46);
            *__error() = v18;
          }
          if (byte_1000EBD39)
            v20 = dword_1000EB4E8 <= 3;
          else
            v20 = 0;
          if (v20)
          {
            v11 = *__error();
            v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to cache load info"));
            if (v21)
            {
              v22 = v21;
              CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
              if (CStringPtr)
              {
                v24 = (char *)CStringPtr;
                v25 = 0;
              }
              else
              {
                v24 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6C826B9uLL);
                CFStringGetCString(v22, v24, 1024, 0x8000100u);
                v25 = v24;
              }
              if (qword_1000EBD40)
                v33 = (FILE *)qword_1000EBD40;
              else
                v33 = __stderrp;
              fprintf(v33, "%s\n", v24);
              if (v25)
                free(v25);
              v30 = v22;
LABEL_54:
              CFRelease(v30);
LABEL_55:
              *__error() = v11;
              continue;
            }
            v31 = sub_100030318();
            if (os_log_type_enabled(v31, OS_LOG_TYPE_FAULT))
              sub_100097164(&v43, v44);
LABEL_43:
            if (qword_1000EBD40)
              v32 = (FILE *)qword_1000EBD40;
            else
              v32 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v32);
            goto LABEL_55;
          }
        }
        else
        {
          if (byte_1000EBD38)
          {
            v8 = *__error();
            v9 = sub_100030318();
            if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
            {
              v34 = sub_1000302B4((int)objc_msgSend(v7, "intValue"));
              v35 = objc_msgSend(v7, "intValue");
              *(_DWORD *)buf = 136446466;
              v52 = v34;
              v53 = 1024;
              v54 = v35;
              _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to cache load info", buf, 0x12u);
            }
            *__error() = v8;
          }
          if (byte_1000EBD39)
            v10 = dword_1000EB4E8 <= 3;
          else
            v10 = 0;
          if (v10)
          {
            v11 = *__error();
            v12 = sub_1000302B4((int)objc_msgSend(v7, "intValue"));
            v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s [%d]: Unable to cache load info"), v12, objc_msgSend(v7, "intValue"));
            if (v13)
            {
              v14 = v13;
              v15 = CFStringGetCStringPtr(v13, 0x8000100u);
              if (v15)
              {
                v16 = (char *)v15;
                v17 = 0;
              }
              else
              {
                v16 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6C826B9uLL);
                CFStringGetCString(v14, v16, 1024, 0x8000100u);
                v17 = v16;
              }
              if (qword_1000EBD40)
                v29 = (FILE *)qword_1000EBD40;
              else
                v29 = __stderrp;
              fprintf(v29, "%s\n", v16);
              if (v17)
                free(v17);
              v30 = v14;
              goto LABEL_54;
            }
            v26 = sub_100030318();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_FAULT))
            {
              v27 = sub_1000302B4((int)objc_msgSend(v7, "intValue"));
              v28 = objc_msgSend(v7, "intValue");
              *(_DWORD *)buf = 136315394;
              v52 = v27;
              v53 = 1024;
              v54 = v28;
              _os_log_fault_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to cache load info", buf, 0x12u);
            }
            goto LABEL_43;
          }
        }
      }
    }
    v4 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v47, v55, 16);
  }
  while (v4);
LABEL_58:
  objc_msgSend(*(id *)(*(_QWORD *)(a1 + 32) + 120), "removeAllObjects");
  objc_autoreleasePoolPop(context);

  v36 = *(_QWORD *)(a1 + 72);
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
  {
    result = stackshot_config_dealloc(v36);
  }
  else
  {
    result = stackshot_config_dealloc_buffer(v36);
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = *(_QWORD *)(a1 + 72);
  }
  if (*(_QWORD *)(a1 + 48))
  {
    v38 = *(unsigned int *)(a1 + 80);
    v39 = (unint64_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24);
    do
      v40 = __ldxr(v39);
    while (__stxr(v40 - v38, v39));
    v41 = v40 - v38;
    if (v41 <= 20971519 && v41 + *(unsigned int *)(a1 + 80) >= 20971520)
      return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
  }
  return result;
}

void sub_100074FA4(id a1)
{
  int v1;
  NSObject *v2;
  BOOL v3;
  int v4;
  const __CFString *v5;
  const __CFString *v6;
  const char *CStringPtr;
  char *v8;
  char *v9;
  NSObject *v10;
  FILE *v11;
  FILE *v12;

  if (byte_1000EBD38)
  {
    v1 = *__error();
    v2 = sub_100030318();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
      sub_1000971E8();
    *__error() = v1;
  }
  if (byte_1000EBD39)
    v3 = dword_1000EB4E8 <= 3;
  else
    v3 = 0;
  if (v3)
  {
    v4 = *__error();
    v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Unable to process samples fast enough, throttling sampling rate to avoid bloating memory. Use -noThrottle to avoid this."));
    if (v5)
    {
      v6 = v5;
      CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
      if (CStringPtr)
      {
        v8 = (char *)CStringPtr;
        v9 = 0;
      }
      else
      {
        v8 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA1741278uLL);
        CFStringGetCString(v6, v8, 1024, 0x8000100u);
        v9 = v8;
      }
      if (qword_1000EBD40)
        v12 = (FILE *)qword_1000EBD40;
      else
        v12 = __stderrp;
      fprintf(v12, "%s\n", v8);
      if (v9)
        free(v9);
      CFRelease(v6);
    }
    else
    {
      v10 = sub_100030318();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_FAULT))
        sub_1000971BC();
      if (qword_1000EBD40)
        v11 = (FILE *)qword_1000EBD40;
      else
        v11 = __stderrp;
      fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v11);
    }
    *__error() = v4;
  }
}

void sub_100075150(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 2u);
}

void sub_10007515C(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, log, OS_LOG_TYPE_FAULT, a4, a5, 0x16u);
}

uint64_t sub_10007516C(uint64_t result, uint64_t a2, int a3)
{
  uint64_t v3;

  *(_QWORD *)(a2 + 4) = v3;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 18) = 2080;
  *(_QWORD *)(a2 + 20) = result;
  return result;
}

id sub_10007518C(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "intValue");
}

void sub_1000751CC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x1Cu);
}

void sub_1000751D8(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

uint64_t sub_1000751E4@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_QWORD *)(result + 4) = a3;
  *(_WORD *)(result + 12) = 2048;
  *(_QWORD *)(result + 14) = a2;
  return result;
}

void sub_1000751F8(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0x1Cu);
}

id *sub_100075BF0(uint64_t a1, void *a2, char a3, void *a4, void *a5, void *a6, void *a7)
{
  objc_class *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id *v18;
  int v20;
  NSObject *v21;
  BOOL v22;
  int v23;
  const __CFString *v24;
  NSObject *v25;
  FILE *v26;
  int v27;
  NSObject *v28;
  BOOL v29;
  int v30;
  const __CFString *v31;
  NSObject *v32;
  FILE *v33;
  const char *CStringPtr;
  char *v35;
  char *v36;
  const __CFString *v37;
  const char *v38;
  char *v39;
  char *v40;
  FILE *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  FILE *v46;
  const __CFString *theString;

  v13 = (objc_class *)objc_opt_self();
  if (a4 && a7)
  {
    if (byte_1000EBD38)
    {
      v20 = *__error();
      v21 = sub_100030318();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        sub_100097624(a4);
      *__error() = v20;
    }
    if (byte_1000EBD39)
      v22 = dword_1000EB4E8 <= 3;
    else
      v22 = 0;
    if (v22)
    {
      v23 = *__error();
      v24 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: bodies (%s) and angle bracket contents (%s)"), "!(bodies && angleBracketContents)", objc_msgSend(objc_msgSend(a4, "debugDescription"), "UTF8String"), objc_msgSend(objc_msgSend(a7, "debugDescription"), "UTF8String"));
      if (v24)
      {
        theString = v24;
        CStringPtr = CFStringGetCStringPtr(v24, 0x8000100u);
        if (CStringPtr)
        {
          v35 = (char *)CStringPtr;
          v36 = 0;
        }
        else
        {
          v35 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB1C9ED6FuLL);
          CFStringGetCString(theString, v35, 1024, 0x8000100u);
          v36 = v35;
        }
        if (qword_1000EBD40)
          v41 = (FILE *)qword_1000EBD40;
        else
          v41 = __stderrp;
        fprintf(v41, "%s\n", v35);
        if (v36)
          free(v36);
        CFRelease(theString);
      }
      else
      {
        v25 = sub_100030318();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
          sub_100097590(a4, (uint64_t)a7, v25);
        if (qword_1000EBD40)
          v26 = (FILE *)qword_1000EBD40;
        else
          v26 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
      }
      *__error() = v23;
    }
    objc_msgSend(objc_msgSend(a4, "debugDescription"), "UTF8String");
    objc_msgSend(objc_msgSend(a7, "debugDescription"), "UTF8String");
    sub_1000301F0("+[SPTreeNode nodeWithParent:isKernel:bodies:address:stateInfo:angleBracketContents:]", "SPTextualReportParser.m", 69, "%s: bodies (%s) and angle bracket contents (%s)", v42, v43, v44, v45, (char)"!(bodies && angleBracketContents)");
LABEL_61:
    abort();
  }
  if (!a7 && !a6 && !a4)
  {
    if (byte_1000EBD38)
    {
      v27 = *__error();
      v28 = sub_100030318();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
        sub_10009772C(v28);
      *__error() = v27;
    }
    if (byte_1000EBD39)
      v29 = dword_1000EB4E8 <= 3;
    else
      v29 = 0;
    if (v29)
    {
      v30 = *__error();
      v31 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No frame bodies, state, nor angle bracket contents"), "bodies || angleBracketContents || stateInfo");
      if (v31)
      {
        v37 = v31;
        v38 = CFStringGetCStringPtr(v31, 0x8000100u);
        if (v38)
        {
          v39 = (char *)v38;
          v40 = 0;
        }
        else
        {
          v39 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xA4170E1uLL);
          CFStringGetCString(v37, v39, 1024, 0x8000100u);
          v40 = v39;
        }
        if (qword_1000EBD40)
          v46 = (FILE *)qword_1000EBD40;
        else
          v46 = __stderrp;
        fprintf(v46, "%s\n", v39);
        if (v40)
          free(v40);
        CFRelease(v37);
      }
      else
      {
        v32 = sub_100030318();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_FAULT))
          sub_1000976B0(v32);
        if (qword_1000EBD40)
          v33 = (FILE *)qword_1000EBD40;
        else
          v33 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v33);
      }
      *__error() = v30;
    }
    sub_1000301F0("+[SPTreeNode nodeWithParent:isKernel:bodies:address:stateInfo:angleBracketContents:]", "SPTextualReportParser.m", 70, "%s: No frame bodies, state, nor angle bracket contents", v14, v15, v16, v17, (char)"bodies || angleBracketContents || stateInfo");
    goto LABEL_61;
  }
  v18 = (id *)objc_alloc_init(v13);
  objc_storeWeak(v18 + 7, a2);
  *((_BYTE *)v18 + 8) = a3;
  v18[2] = objc_msgSend(a4, "copy");
  v18[4] = a5;
  v18[5] = objc_msgSend(a6, "copy");
  v18[3] = objc_msgSend(a7, "copy");
  return v18;
}

id *sub_1000760AC(uint64_t a1, int a2, void *a3, void *a4, void *a5, void *a6)
{
  id *v11;
  void *v12;
  id v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  id *v17;
  id *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];

  if (!a1)
    return 0;
  v11 = (id *)a1;
  v12 = *(void **)(a1 + 48);
  if (!v12)
  {
    *(_QWORD *)(a1 + 48) = objc_alloc_init((Class)NSMutableArray);
    goto LABEL_13;
  }
  v22 = 0u;
  v23 = 0u;
  v20 = 0u;
  v21 = 0u;
  v13 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
  if (!v13)
  {
LABEL_13:
    v17 = sub_100075BF0((uint64_t)SPTreeNode, v11, a2, a3, a4, a5, a6);
    objc_msgSend(v11[6], "addObject:", v17);
    return v17;
  }
  v14 = v13;
  v15 = *(_QWORD *)v21;
  v19 = v11;
LABEL_5:
  v16 = 0;
  while (1)
  {
    if (*(_QWORD *)v21 != v15)
      objc_enumerationMutation(v12);
    v17 = *(id **)(*((_QWORD *)&v20 + 1) + 8 * v16);
    if ((sub_100076234((uint64_t)v17, a2, a3, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6) & 1) != 0)
      return v17;
    if (v14 == (id)++v16)
    {
      v14 = objc_msgSend(v12, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
      v11 = v19;
      if (v14)
        goto LABEL_5;
      goto LABEL_13;
    }
  }
}

uint64_t sub_100076234(uint64_t result, int a2, void *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;

  if (result)
  {
    v6 = result;
    if (*(unsigned __int8 *)(result + 8) == a2 && *(_QWORD *)(result + 32) == a4)
    {
      v9 = *(_QWORD *)(result + 40);
      if (!(a5 | v9)
        || (result = 0, a5)
        && v9
        && (result = (uint64_t)objc_msgSend(*(id *)(v6 + 40), "isEqualToString:", a5), (_DWORD)result))
      {
        v10 = *(_QWORD *)(v6 + 24);
        if (!(a6 | v10)
          || (result = 0, a6)
          && v10
          && (result = (uint64_t)objc_msgSend(*(id *)(v6 + 24), "isEqualToString:", a6), (_DWORD)result))
        {
          if (*(_QWORD *)(v6 + 32) == -1)
            return 1;
          v11 = (unint64_t)objc_msgSend(*(id *)(v6 + 16), "firstObject");
          v12 = (unint64_t)objc_msgSend(a3, "firstObject");
          if (!(v11 | v12))
            return 1;
          v13 = v12;
          result = 0;
          if (v11)
          {
            if (v13)
            {
              result = (uint64_t)objc_msgSend((id)v11, "isEqualToString:");
              if ((_DWORD)result)
                return 1;
            }
          }
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100076410(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 12);
  return result;
}

uint64_t sub_10007641C(uint64_t result, int a2)
{
  if (result)
    *(_DWORD *)(result + 12) = a2;
  return result;
}

uint64_t sub_100076428(uint64_t result)
{
  if (result)
    return *(_BYTE *)(result + 8) & 1;
  return result;
}

uint64_t sub_100076438(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 16);
  return result;
}

uint64_t sub_100076444(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

uint64_t sub_100076450(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

uint64_t sub_10007645C(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

uint64_t sub_100076468(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

id *sub_100076474(id *result)
{
  if (result)
    return (id *)objc_loadWeak(result + 7);
  return result;
}

_QWORD *sub_10007648C(void *a1, void *a2, char a3, uint64_t a4, uint64_t a5, void *a6, void *a7, void *a8, void *a9)
{
  _QWORD *v16;
  objc_super v18;

  if (!a1)
    return 0;
  v18.receiver = a1;
  v18.super_class = (Class)SPLoadInfo;
  v16 = objc_msgSendSuper2(&v18, "init");
  if (v16)
  {
    v16[5] = a2;
    *((_BYTE *)v16 + 32) = a3;
    v16[7] = a4;
    v16[8] = a5;
    v16[1] = objc_msgSend(a6, "copy");
    v16[2] = objc_msgSend(a7, "copy");
    v16[3] = objc_msgSend(a8, "copy");
    v16[6] = objc_msgSend(a9, "copy");
  }
  return v16;
}

id *sub_100076620(id *result)
{
  id *v1;

  if (result)
  {
    v1 = result;
    result = (id *)objc_msgSend(result[5], "bundleIdentifier");
    if (!result)
      return (id *)v1[1];
  }
  return result;
}

id *sub_100076650(id *result)
{
  id *v1;

  if (result)
  {
    v1 = result;
    result = (id *)objc_msgSend(result[5], "name");
    if (!result)
      return (id *)v1[2];
  }
  return result;
}

void *sub_100076680(uint64_t a1)
{
  void *v2;
  unint64_t v3;
  id v4;
  id v5;
  unint64_t v6;
  id v7;
  unint64_t v8;

  if (!a1)
    return 0;
  v2 = *(void **)(a1 + 24);
  if (!v2)
  {
    v3 = (unint64_t)objc_msgSend(*(id *)(a1 + 40), "bundleVersion");
    v4 = objc_msgSend(*(id *)(a1 + 40), "bundleShortVersion");
    v5 = objc_msgSend(*(id *)(a1 + 40), "binaryVersion");
    v6 = (unint64_t)v5;
    if (!v4 && !v3 && !v5)
      return 0;
    v7 = +[NSMutableString string](NSMutableString, "string");
    v2 = v7;
    if (v4)
    {
      objc_msgSend(v7, "appendString:", v4);
      if (!(v3 | v6))
        return v2;
      objc_msgSend(v2, "appendString:", CFSTR(" "));
    }
    if (v3 | v6)
    {
      if (v3)
        v8 = v3;
      else
        v8 = v6;
      objc_msgSend(v2, "appendFormat:", CFSTR("(%@)"), v8);
    }
  }
  return v2;
}

uint64_t sub_100076758(uint64_t result)
{
  if (result)
    return *(_BYTE *)(result + 32) & 1;
  return result;
}

uint64_t sub_100076768(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 56);
  return result;
}

uint64_t sub_100076774(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 64);
  return result;
}

void sub_10007CA00(_Unwind_Exception *a1)
{
  _Block_object_dispose(&STACK[0x2C8], 8);
  _Block_object_dispose(&STACK[0x2E8], 8);
  _Unwind_Resume(a1);
}

void *sub_10007CE38(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  NSObject *v14;
  BOOL v15;
  int v16;
  const __CFString *v17;
  NSObject *v18;
  FILE *v19;
  void *result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  NSObject *v26;
  int v27;
  const __CFString *v28;
  NSObject *v29;
  FILE *v30;
  const __CFString *v31;
  const char *v32;
  char *v33;
  char *v34;
  FILE *v35;
  const __CFString *v36;
  const char *CStringPtr;
  char *v38;
  char *v39;
  FILE *v40;

  v9 = a1 + 32;
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v11 = *(_DWORD *)(v10 + 24);
  if (v11)
  {
    *(_DWORD *)(v10 + 24) = 2 * v11;
    v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24);
    if (v12 <= 0)
    {
      if (byte_1000EBD38)
      {
        v13 = *__error();
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_10009805C();
        *__error() = v13;
      }
      if (byte_1000EBD39)
        v15 = dword_1000EB4E8 <= 3;
      else
        v15 = 0;
      if (v15)
      {
        v16 = *__error();
        v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: bufSize overflow (%d)"), "bufSize > 0", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24));
        if (v17)
        {
          v36 = v17;
          CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
          if (CStringPtr)
          {
            v38 = (char *)CStringPtr;
            v39 = 0;
          }
          else
          {
            v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x9B1926D1uLL);
            CFStringGetCString(v36, v38, 1024, 0x8000100u);
            v39 = v38;
          }
          if (qword_1000EBD40)
            v40 = (FILE *)qword_1000EBD40;
          else
            v40 = __stderrp;
          fprintf(v40, "%s\n", v38);
          if (v39)
            free(v39);
          CFRelease(v36);
        }
        else
        {
          v18 = sub_100030318();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
            sub_100097FEC();
          if (qword_1000EBD40)
            v19 = (FILE *)qword_1000EBD40;
          else
            v19 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
        }
        *__error() = v16;
      }
      sub_1000301F0("-[SPTextualReportParser parseSpindumpFile:andReportToStream:]_block_invoke", "SPTextualReportParser.m", 287, "%s: bufSize overflow (%d)", a5, a6, a7, a8, (char)"bufSize > 0");
      goto LABEL_56;
    }
  }
  else
  {
    *(_DWORD *)(v10 + 24) = 0x4000;
    v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24);
  }
  result = reallocf(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), v12);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
  {
    if (byte_1000EBD38)
    {
      v25 = *__error();
      v26 = sub_100030318();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_100097F7C();
      *__error() = v25;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v27 = *__error();
      v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Unable to allocate %d buffer"), "buf", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24));
      if (v28)
      {
        v31 = v28;
        v32 = CFStringGetCStringPtr(v28, 0x8000100u);
        if (v32)
        {
          v33 = (char *)v32;
          v34 = 0;
        }
        else
        {
          v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xB6298B8AuLL);
          CFStringGetCString(v31, v33, 1024, 0x8000100u);
          v34 = v33;
        }
        if (qword_1000EBD40)
          v35 = (FILE *)qword_1000EBD40;
        else
          v35 = __stderrp;
        fprintf(v35, "%s\n", v33);
        if (v34)
          free(v34);
        CFRelease(v31);
      }
      else
      {
        v29 = sub_100030318();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
          sub_100097F0C();
        if (qword_1000EBD40)
          v30 = (FILE *)qword_1000EBD40;
        else
          v30 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }
      *__error() = v27;
    }
    sub_1000301F0("-[SPTextualReportParser parseSpindumpFile:andReportToStream:]_block_invoke", "SPTextualReportParser.m", 290, "%s: Unable to allocate %d buffer", v21, v22, v23, v24, (char)"buf");
LABEL_56:
    abort();
  }
  return result;
}

void sub_10007D28C(FILE *a1, uint64_t a2, uint64_t a3, char a4, char a5, uint64_t a6)
{
  id v12;
  id v13;
  id v14;
  id v15;
  void *context;
  _QWORD v17[6];
  _QWORD v18[13];
  char v19;
  char v20;
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  void (*v24)(uint64_t, uint64_t);
  void (*v25)(uint64_t);
  uint64_t v26;
  _QWORD v27[3];
  char v28;

  context = objc_autoreleasePoolPush();
  v12 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v13 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x2020000000;
  v28 = a5;
  v14 = +[NSMutableSet set](NSMutableSet, "set");
  v21 = 0;
  v22 = &v21;
  v23 = 0x3052000000;
  v24 = sub_1000818B4;
  v25 = sub_1000818C4;
  v26 = 0;
  v15 = sub_10007D464(a1, 0, a3, a4);
  v22[5] = (uint64_t)v15;
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_1000818D0;
  v18[3] = &unk_1000DDD80;
  v19 = a5;
  v20 = a4;
  v18[9] = v13;
  v18[10] = v27;
  v18[11] = &v21;
  v18[12] = a1;
  v18[4] = a6;
  v18[5] = a3;
  v18[6] = a2;
  v18[7] = v12;
  v18[8] = v14;
  sub_10007FC6C(a1, 0, (uint64_t)v18);

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_100081C18;
  v17[3] = &unk_1000DDDD0;
  v17[4] = v14;
  v17[5] = v13;
  objc_msgSend(v12, "enumerateKeysAndObjectsUsingBlock:", v17);
  _Block_object_dispose(&v21, 8);
  _Block_object_dispose(v27, 8);
  objc_autoreleasePoolPop(context);
}

void sub_10007D438(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

id sub_10007D464(FILE *a1, int a2, uint64_t a3, char a4)
{
  void *v8;
  id v9;
  _QWORD v11[7];
  char v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  char v16;

  v8 = objc_autoreleasePoolPush();
  v9 = objc_alloc_init((Class)NSMutableArray);
  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_100080360;
  v11[3] = &unk_1000DDD38;
  v11[5] = v9;
  v11[6] = &v13;
  v11[4] = a3;
  v12 = a4;
  sub_10007FC6C(a1, a2, (uint64_t)v11);
  if (!*((_BYTE *)v14 + 24))
  {

    v9 = 0;
  }
  _Block_object_dispose(&v13, 8);
  objc_autoreleasePoolPop(v8);
  return v9;
}

void sub_10007D548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

unint64_t sub_10007D560(void *a1, void *a2, int a3, int a4, int a5)
{
  id v6;
  uint64_t v7;
  unint64_t result;
  unsigned int v11;

  if (a3)
  {
    v6 = objc_msgSend(a2, "rangeWithName:", CFSTR("indentCount"));
    if (v6 == (id)0x7FFFFFFFFFFFFFFFLL)
      return 0xFFFFFFFFLL;
    else
      return sub_10007F0B0(objc_msgSend(a1, "substringWithRange:", v6, v7));
  }
  else
  {
    if (objc_msgSend(a2, "rangeWithName:", CFSTR("indentWhitespace")) == (id)0x7FFFFFFFFFFFFFFFLL)
      result = 0xFFFFFFFFLL;
    else
      result = v11;
    if ((result & 0x80000000) == 0)
      return (((int)result - a4) / a5);
  }
  return result;
}

id sub_10007D5F4(void *a1, uint64_t a2, void *a3, void *a4, int a5, unint64_t *a6)
{
  void *v12;
  void *v13;
  id v14;
  uint64_t v15;
  id v16;
  void *v17;
  id v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  id v26;
  uint64_t v27;
  id v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  id v35;
  uint64_t v36;
  id v37;
  id v38;
  id v39;
  id v40;
  _QWORD *v41;
  uint64_t v42;
  void *v43;
  void *v44;
  id v45;
  int v46;
  NSObject *v47;
  int v48;
  const __CFString *v49;
  const __CFString *v50;
  const char *v51;
  malloc_type_id_t v52;
  void *v53;
  int v54;
  NSObject *v55;
  const __CFString *v57;
  id v58;
  int v59;
  NSObject *v60;
  const __CFString *v61;
  id v62;
  id v63;
  id v64;
  _QWORD *v65;
  uint64_t v66;
  void *v67;
  void *v68;
  id v69;
  int v70;
  NSObject *v71;
  const __CFString *v72;
  int v73;
  NSObject *v74;
  const __CFString *v75;
  char *v76;
  char *v77;
  int v78;
  NSObject *v79;
  id v80;
  uint64_t v81;
  BOOL v82;
  int v83;
  const __CFString *v84;
  const __CFString *v85;
  const char *v86;
  malloc_type_id_t v87;
  int v88;
  NSObject *v89;
  id v90;
  uint64_t v91;
  BOOL v92;
  int v93;
  const __CFString *v94;
  const __CFString *v95;
  const char *v96;
  malloc_type_id_t v97;
  NSObject *v98;
  id v99;
  const char *v100;
  NSObject *v101;
  uint32_t v102;
  int v103;
  NSObject *v104;
  id v105;
  BOOL v106;
  NSObject *v107;
  int v108;
  NSObject *v109;
  id v110;
  BOOL v111;
  NSObject *v112;
  id v113;
  const __CFString *v114;
  char *v115;
  char *v116;
  const __CFString *v117;
  char *v118;
  char *v119;
  FILE *v120;
  NSObject *v121;
  id v122;
  uint64_t v123;
  const char *v124;
  NSObject *v125;
  uint32_t v126;
  FILE *v127;
  NSObject *v128;
  id v129;
  uint64_t v130;
  const char *v131;
  NSObject *v132;
  uint32_t v133;
  NSObject *v134;
  FILE *v135;
  NSObject *v136;
  FILE *v137;
  FILE *v138;
  id v139;
  int v140;
  NSObject *v141;
  int v142;
  const __CFString *v143;
  NSObject *v144;
  FILE *v145;
  FILE *v146;
  id v148;
  id v149;
  int v150;
  NSObject *v151;
  int v152;
  const __CFString *v153;
  NSObject *v154;
  FILE *v155;
  int v156;
  NSObject *v157;
  int v158;
  const __CFString *v159;
  NSObject *v160;
  FILE *v161;
  const __CFString *v162;
  const char *CStringPtr;
  char *v164;
  char *v165;
  FILE *v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  const __CFString *v171;
  const char *v172;
  char *v173;
  char *v174;
  const __CFString *v175;
  const char *v176;
  char *v177;
  char *v178;
  FILE *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  FILE *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  void *v189;
  uint64_t v190;
  __int128 v191;
  __int128 v192;
  __int128 v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  _QWORD v199[5];
  uint8_t v200[128];
  uint8_t buf[4];
  id v202;
  __int16 v203;
  _BYTE v204[24];
  __int16 v205;
  void *v206;
  _BYTE v207[128];

  v12 = objc_autoreleasePoolPush();
  v13 = v12;
  *a6 = -1;
  if (a5)
  {
    v14 = objc_msgSend(a3, "rangeWithName:", CFSTR("binaryIndex"));
    if (v14 == (id)0x7FFFFFFFFFFFFFFFLL)
      goto LABEL_3;
    v25 = sub_10007F0B0(objc_msgSend(a1, "substringWithRange:", v14, v15));
    if (v25 < (unint64_t)objc_msgSend(a4, "count"))
    {
      v16 = objc_msgSend(a4, "objectAtIndexedSubscript:", v25);
      v26 = objc_msgSend(a3, "rangeWithName:", CFSTR("offsetIntoBinary"));
      if (v26 == (id)0x7FFFFFFFFFFFFFFFLL)
      {
        if (byte_1000EBD38)
        {
          v150 = *__error();
          v151 = sub_100030318();
          if (os_log_type_enabled(v151, OS_LOG_TYPE_ERROR))
            sub_100098140();
          *__error() = v150;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v152 = *__error();
          v153 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: load info has binary but no offset into binary (%d: %s)"), "range.location != NSNotFound", a2, objc_msgSend(a1, "UTF8String"));
          if (v153)
          {
            v162 = v153;
            CStringPtr = CFStringGetCStringPtr(v153, 0x8000100u);
            if (CStringPtr)
            {
              v164 = (char *)CStringPtr;
              v165 = 0;
            }
            else
            {
              v164 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xAF47D90FuLL);
              CFStringGetCString(v162, v164, 1024, 0x8000100u);
              v165 = v164;
            }
            if (qword_1000EBD40)
              v166 = (FILE *)qword_1000EBD40;
            else
              v166 = __stderrp;
            fprintf(v166, "%s\n", v164);
            if (v165)
              free(v165);
            CFRelease(v162);
          }
          else
          {
            v154 = sub_100030318();
            if (os_log_type_enabled(v154, OS_LOG_TYPE_FAULT))
              sub_1000980CC();
            if (qword_1000EBD40)
              v155 = (FILE *)qword_1000EBD40;
            else
              v155 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v155);
          }
          *__error() = v152;
        }
        objc_msgSend(a1, "UTF8String");
        sub_1000301F0("LoadInfoForFrameLine", "SPTextualReportParser.m", 1117, "%s: load info has binary but no offset into binary (%d: %s)", v167, v168, v169, v170, (char)"range.location != NSNotFound");
        goto LABEL_299;
      }
      v28 = v26;
      v29 = a1;
      goto LABEL_233;
    }
    if (byte_1000EBD38)
    {
      v53 = v13;
      v54 = *__error();
      v55 = sub_100030318();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218754;
        v202 = (id)v25;
        v203 = 2048;
        *(_QWORD *)v204 = objc_msgSend(a4, "count");
        *(_WORD *)&v204[8] = 1024;
        *(_DWORD *)&v204[10] = a2;
        *(_WORD *)&v204[14] = 2112;
        *(_QWORD *)&v204[16] = a1;
        _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)", buf, 0x26u);
      }
      *__error() = v54;
      v13 = v53;
    }
    if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
    {
LABEL_3:
      v16 = 0;
      goto LABEL_235;
    }
    v48 = *__error();
    v57 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %lu (%lu binaries) (%d: %@)"), v25, objc_msgSend(a4, "count"), a2, a1);
    if (v57)
    {
      v50 = v57;
      v51 = CFStringGetCStringPtr(v57, 0x8000100u);
      if (!v51)
      {
        v52 = 1712542635;
        goto LABEL_169;
      }
      goto LABEL_108;
    }
    v98 = sub_100030318();
    if (!os_log_type_enabled(v98, OS_LOG_TYPE_FAULT))
      goto LABEL_182;
    v99 = objc_msgSend(a4, "count");
    *(_DWORD *)buf = 134218754;
    v202 = (id)v25;
    v203 = 2048;
    *(_QWORD *)v204 = v99;
    *(_WORD *)&v204[8] = 1024;
    *(_DWORD *)&v204[10] = a2;
    *(_WORD *)&v204[14] = 2112;
    *(_QWORD *)&v204[16] = a1;
    v100 = "Unable to format: Parsing spindump text: corrupt condensed file, frame line has out-of-bounds binary index %l"
           "u (%lu binaries) (%d: %@)";
    v101 = v98;
    v102 = 38;
LABEL_181:
    _os_log_fault_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_FAULT, v100, buf, v102);
    goto LABEL_182;
  }
  v17 = v12;
  v18 = objc_msgSend(a3, "rangeWithName:", CFSTR("address"));
  if (v18 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v30 = a1;
    v31 = sub_10007F0B0(objc_msgSend(a1, "substringWithRange:", v18, v19));
    v199[0] = _NSConcreteStackBlock;
    v199[1] = 3221225472;
    v199[2] = sub_100081890;
    v199[3] = &unk_1000DDD58;
    v199[4] = v31;
    v32 = SABinarySearchArray(a4, 1280, v199);
    if (v32 >= (unint64_t)objc_msgSend(a4, "count"))
    {
      v16 = 0;
      v13 = v17;
    }
    else
    {
      v33 = objc_msgSend(a4, "objectAtIndexedSubscript:", v32);
      if (v33)
        v34 = v33[7];
      else
        v34 = 0;
      v13 = v17;
      if (v34 <= v31)
        v16 = v33;
      else
        v16 = 0;
      if (v16)
        goto LABEL_64;
    }
    if (v32)
    {
      v58 = objc_msgSend(a4, "objectAtIndexedSubscript:", v32 - 1);
      if (v58)
      {
        v16 = v58;
        if (*((_QWORD *)v58 + 8) - 1 >= v31)
          goto LABEL_65;
      }
      goto LABEL_61;
    }
LABEL_64:
    if (v16)
    {
LABEL_65:
      v24 = v31 - *((_QWORD *)v16 + 7);
      goto LABEL_234;
    }
LABEL_61:
    if (objc_msgSend(a3, "rangeWithName:", CFSTR("binaryName")) != (id)0x7FFFFFFFFFFFFFFFLL
      || objc_msgSend(a3, "rangeWithName:", CFSTR("binaryUuid")) != (id)0x7FFFFFFFFFFFFFFFLL)
    {
      if (byte_1000EBD38)
      {
        v59 = *__error();
        v60 = sub_100030318();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          sub_100098304();
        *__error() = v59;
      }
      v16 = 0;
      v13 = v17;
      if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
        goto LABEL_235;
      v48 = *__error();
      v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: Unable to find load info for (%d: %@)"), a2, v30);
      if (v61)
      {
        v50 = v61;
        v51 = CFStringGetCStringPtr(v61, 0x8000100u);
        if (!v51)
        {
          v52 = 2963936884;
          goto LABEL_169;
        }
        goto LABEL_108;
      }
      v107 = sub_100030318();
      if (os_log_type_enabled(v107, OS_LOG_TYPE_FAULT))
        sub_10009829C();
      goto LABEL_182;
    }
    v16 = 0;
    goto LABEL_109;
  }
  v190 = a2;
  v20 = objc_msgSend(a3, "rangeWithName:", CFSTR("binaryUuid"));
  if (v20 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v35 = v20;
    v36 = v21;
    v189 = a1;
    v37 = sub_100081774(objc_msgSend(a1, "substringWithRange:", v20, v21));
    if (!v37)
    {
      if (byte_1000EBD38)
      {
        v73 = *__error();
        v74 = sub_100030318();
        if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138412802;
          v202 = objc_msgSend(a1, "substringWithRange:", v35, v36);
          v203 = 1024;
          *(_DWORD *)v204 = v190;
          *(_WORD *)&v204[4] = 2112;
          *(_QWORD *)&v204[6] = a1;
          _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: unable to parse UUID %@ in line (%d: %@)", buf, 0x1Cu);
        }
        *__error() = v73;
      }
      v16 = 0;
      if (byte_1000EBD39)
      {
        v13 = v17;
        if (dword_1000EB4E8 > 2)
          goto LABEL_235;
        v48 = *__error();
        v75 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: unable to parse UUID %@ in line (%d: %@)"), objc_msgSend(a1, "substringWithRange:", v35, v36), v190, a1);
        if (v75)
        {
          v50 = v75;
          v51 = CFStringGetCStringPtr(v75, 0x8000100u);
          if (v51)
            goto LABEL_108;
          v52 = 3349150436;
LABEL_169:
          v76 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v52);
          CFStringGetCString(v50, v76, 1024, 0x8000100u);
          v77 = v76;
          goto LABEL_170;
        }
        v112 = sub_100030318();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
        {
          v113 = objc_msgSend(a1, "substringWithRange:", v35, v36);
          *(_DWORD *)buf = 138412802;
          v202 = v113;
          v203 = 1024;
          *(_DWORD *)v204 = v190;
          *(_WORD *)&v204[4] = 2112;
          *(_QWORD *)&v204[6] = a1;
          v100 = "Unable to format: Parsing spindump text: unable to parse UUID %@ in line (%d: %@)";
          goto LABEL_180;
        }
        goto LABEL_182;
      }
LABEL_109:
      v13 = v17;
      goto LABEL_235;
    }
    v38 = v37;
    v197 = 0u;
    v198 = 0u;
    v195 = 0u;
    v196 = 0u;
    v39 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v195, v207, 16);
    if (!v39)
      goto LABEL_36;
    v40 = v39;
    v41 = 0;
    v42 = *(_QWORD *)v196;
    while (1)
    {
      v43 = 0;
      v16 = v41;
      do
      {
        if (*(_QWORD *)v196 != v42)
          objc_enumerationMutation(a4);
        v41 = *(_QWORD **)(*((_QWORD *)&v195 + 1) + 8 * (_QWORD)v43);
        if (v41)
          v44 = (void *)v41[5];
        else
          v44 = 0;
        if (objc_msgSend(objc_msgSend(v44, "uuid"), "isEqual:", v38))
        {
          if (v16)
          {
            if (*((_QWORD *)v16 + 6))
            {
              if (byte_1000EBD38)
              {
                v78 = *__error();
                v79 = sub_100030318();
                if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
                {
                  v80 = objc_msgSend(*((id *)v16 + 5), "uuid");
                  v81 = *((_QWORD *)v16 + 6);
                  *(_DWORD *)buf = 138413314;
                  v202 = v38;
                  v203 = 2112;
                  *(_QWORD *)v204 = v80;
                  *(_WORD *)&v204[8] = 2112;
                  *(_QWORD *)&v204[10] = v81;
                  *(_WORD *)&v204[18] = 1024;
                  *(_DWORD *)&v204[20] = v190;
                  v205 = 2112;
                  v206 = v189;
                  _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)", buf, 0x30u);
                }
                *__error() = v78;
              }
              if (byte_1000EBD39)
                v82 = dword_1000EB4E8 <= 2;
              else
                v82 = 0;
              if (!v82)
              {
LABEL_146:
                v13 = v17;
                goto LABEL_208;
              }
              v83 = *__error();
              v84 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)"), v38, objc_msgSend(*((id *)v16 + 5), "uuid"), *((_QWORD *)v16 + 6), v190, v189);
              v13 = v17;
              if (v84)
              {
                v85 = v84;
                v86 = CFStringGetCStringPtr(v84, 0x8000100u);
                if (!v86)
                {
                  v87 = 2876111463;
                  goto LABEL_200;
                }
LABEL_162:
                v115 = (char *)v86;
                v116 = 0;
                goto LABEL_201;
              }
              v121 = sub_100030318();
              if (os_log_type_enabled(v121, OS_LOG_TYPE_FAULT))
              {
                v122 = objc_msgSend(*((id *)v16 + 5), "uuid");
                v123 = *((_QWORD *)v16 + 6);
                *(_DWORD *)buf = 138413314;
                v202 = v38;
                v203 = 2112;
                *(_QWORD *)v204 = v122;
                *(_WORD *)&v204[8] = 2112;
                *(_QWORD *)&v204[10] = v123;
                *(_WORD *)&v204[18] = 1024;
                *(_DWORD *)&v204[20] = v190;
                v205 = 2112;
                v206 = v189;
                v124 = "Unable to format: Parsing spindump text: No address for frame line, and binary UUID %@ matches mu"
                       "ltiple load infos, assuming %@ segment %@ (%d: %@)";
                v125 = v121;
                v126 = 48;
                goto LABEL_237;
              }
              goto LABEL_190;
            }
            if (byte_1000EBD38)
            {
              v103 = *__error();
              v104 = sub_100030318();
              if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
              {
                v105 = objc_msgSend(*((id *)v16 + 5), "uuid");
                *(_DWORD *)buf = 138413058;
                v202 = v38;
                v203 = 2112;
                *(_QWORD *)v204 = v105;
                *(_WORD *)&v204[8] = 1024;
                *(_DWORD *)&v204[10] = v190;
                *(_WORD *)&v204[14] = 2112;
                *(_QWORD *)&v204[16] = v189;
                _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ (%d: %@)", buf, 0x26u);
              }
              *__error() = v103;
            }
            if (byte_1000EBD39)
              v106 = dword_1000EB4E8 <= 2;
            else
              v106 = 0;
            if (!v106)
              goto LABEL_146;
            v83 = *__error();
            v114 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: No address for frame line, and binary UUID %@ matches multiple load infos, assuming %@ (%d: %@)"), v38, objc_msgSend(*((id *)v16 + 5), "uuid"), v190, v189);
            v13 = v17;
            if (v114)
            {
              v85 = v114;
              v86 = CFStringGetCStringPtr(v114, 0x8000100u);
              if (v86)
                goto LABEL_162;
              v87 = 1508442993;
LABEL_200:
              v115 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v87);
              CFStringGetCString(v85, v115, 1024, 0x8000100u);
              v116 = v115;
LABEL_201:
              if (qword_1000EBD40)
                v138 = (FILE *)qword_1000EBD40;
              else
                v138 = __stderrp;
              fprintf(v138, "%s\n", v115);
              if (v116)
                free(v116);
              CFRelease(v85);
            }
            else
            {
              v134 = sub_100030318();
              if (os_log_type_enabled(v134, OS_LOG_TYPE_FAULT))
              {
                v148 = objc_msgSend(*((id *)v16 + 5), "uuid");
                *(_DWORD *)buf = 138413058;
                v202 = v38;
                v203 = 2112;
                *(_QWORD *)v204 = v148;
                *(_WORD *)&v204[8] = 1024;
                *(_DWORD *)&v204[10] = v190;
                *(_WORD *)&v204[14] = 2112;
                *(_QWORD *)&v204[16] = v189;
                v124 = "Unable to format: Parsing spindump text: No address for frame line, and binary UUID %@ matches mu"
                       "ltiple load infos, assuming %@ (%d: %@)";
                v125 = v134;
                v126 = 38;
LABEL_237:
                _os_log_fault_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_FAULT, v124, buf, v126);
              }
LABEL_190:
              if (qword_1000EBD40)
                v135 = (FILE *)qword_1000EBD40;
              else
                v135 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v135);
            }
            *__error() = v83;
            goto LABEL_208;
          }
        }
        else
        {
          v41 = v16;
        }
        v43 = (char *)v43 + 1;
        v16 = v41;
      }
      while (v40 != v43);
      v45 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v195, v207, 16);
      v40 = v45;
      if (!v45)
      {
        v16 = v41;
        v13 = v17;
        if (!v41)
        {
LABEL_36:
          if (byte_1000EBD38)
          {
            v46 = *__error();
            v47 = sub_100030318();
            if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138412802;
              v202 = v38;
              v203 = 1024;
              *(_DWORD *)v204 = v190;
              *(_WORD *)&v204[4] = 2112;
              *(_QWORD *)&v204[6] = v189;
              _os_log_error_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)", buf, 0x1Cu);
            }
            *__error() = v46;
          }
          v16 = 0;
          if (byte_1000EBD39)
          {
            v13 = v17;
            if (dword_1000EB4E8 > 3)
              goto LABEL_235;
            v48 = *__error();
            v49 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)"), v38, v190, v189);
            if (v49)
            {
              v50 = v49;
              v51 = CFStringGetCStringPtr(v49, 0x8000100u);
              if (!v51)
              {
                v52 = 4010476091;
                goto LABEL_169;
              }
              goto LABEL_108;
            }
            v112 = sub_100030318();
            if (os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 138412802;
              v202 = v38;
              v203 = 1024;
              *(_DWORD *)v204 = v190;
              *(_WORD *)&v204[4] = 2112;
              *(_QWORD *)&v204[6] = v189;
              v100 = "Unable to format: Parsing spindump text: No matching binary for frame line with binary UUID %@! (%d: %@)";
              goto LABEL_180;
            }
LABEL_182:
            if (qword_1000EBD40)
              v127 = (FILE *)qword_1000EBD40;
            else
              v127 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v127);
            goto LABEL_186;
          }
          goto LABEL_109;
        }
LABEL_208:
        v139 = objc_msgSend(a3, "rangeWithName:", CFSTR("offsetIntoBinary"));
        if (v139 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          if (byte_1000EBD38)
          {
            v140 = *__error();
            v141 = sub_100030318();
            if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
              sub_100098228();
            *__error() = v140;
          }
          if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
          {
            v142 = *__error();
            v143 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: frame regex returned binary but no offset into binary (%d: %s)"), "range.location != NSNotFound", v190, objc_msgSend(v189, "UTF8String"));
            if (v143)
            {
              v171 = v143;
              v172 = CFStringGetCStringPtr(v143, 0x8000100u);
              if (v172)
              {
                v173 = (char *)v172;
                v174 = 0;
              }
              else
              {
                v173 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6CD03AA1uLL);
                CFStringGetCString(v171, v173, 1024, 0x8000100u);
                v174 = v173;
              }
              if (qword_1000EBD40)
                v179 = (FILE *)qword_1000EBD40;
              else
                v179 = __stderrp;
              fprintf(v179, "%s\n", v173);
              if (v174)
                free(v174);
              CFRelease(v171);
            }
            else
            {
              v144 = sub_100030318();
              if (os_log_type_enabled(v144, OS_LOG_TYPE_FAULT))
                sub_1000981B4();
              if (qword_1000EBD40)
                v145 = (FILE *)qword_1000EBD40;
              else
                v145 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v145);
            }
            *__error() = v142;
          }
          objc_msgSend(v189, "UTF8String");
          sub_1000301F0("LoadInfoForFrameLine", "SPTextualReportParser.m", 1197, "%s: frame regex returned binary but no offset into binary (%d: %s)", v180, v181, v182, v183, (char)"range.location != NSNotFound");
LABEL_299:
          abort();
        }
LABEL_232:
        v28 = v139;
        v29 = v189;
LABEL_233:
        v24 = sub_10007F0B0(objc_msgSend(v29, "substringWithRange:", v28, v27));
LABEL_234:
        *a6 = v24;
        goto LABEL_235;
      }
    }
  }
  v22 = objc_msgSend(a3, "rangeWithName:", CFSTR("binaryName"));
  v13 = v17;
  if (v22 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v16 = 0;
    v24 = -1;
    goto LABEL_234;
  }
  v189 = a1;
  v62 = objc_msgSend(a1, "substringWithRange:", v22, v23);
  v191 = 0u;
  v192 = 0u;
  v193 = 0u;
  v194 = 0u;
  v63 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v191, v200, 16);
  if (!v63)
    goto LABEL_91;
  v64 = v63;
  v65 = 0;
  v66 = *(_QWORD *)v192;
  do
  {
    v67 = 0;
    v16 = v65;
    do
    {
      if (*(_QWORD *)v192 != v66)
        objc_enumerationMutation(a4);
      v65 = *(_QWORD **)(*((_QWORD *)&v191 + 1) + 8 * (_QWORD)v67);
      if (v65)
        v68 = (void *)v65[5];
      else
        v68 = 0;
      if (objc_msgSend(objc_msgSend(v68, "name"), "isEqualToString:", v62))
      {
        if (v16)
        {
          if (*((_QWORD *)v16 + 6))
          {
            if (byte_1000EBD38)
            {
              v88 = *__error();
              v89 = sub_100030318();
              if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
              {
                v90 = objc_msgSend(*((id *)v16 + 5), "uuid");
                v91 = *((_QWORD *)v16 + 6);
                *(_DWORD *)buf = 138413314;
                v202 = v62;
                v203 = 2112;
                *(_QWORD *)v204 = v90;
                *(_WORD *)&v204[8] = 2112;
                *(_QWORD *)&v204[10] = v91;
                *(_WORD *)&v204[18] = 1024;
                *(_DWORD *)&v204[20] = v190;
                v205 = 2112;
                v206 = v189;
                _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)", buf, 0x30u);
              }
              *__error() = v88;
            }
            if (byte_1000EBD39)
              v92 = dword_1000EB4E8 <= 2;
            else
              v92 = 0;
            if (!v92)
            {
LABEL_157:
              v13 = v17;
              goto LABEL_231;
            }
            v93 = *__error();
            v94 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ segment %@ (%d: %@)"), v62, objc_msgSend(*((id *)v16 + 5), "uuid"), *((_QWORD *)v16 + 6), v190, v189);
            v13 = v17;
            if (v94)
            {
              v95 = v94;
              v96 = CFStringGetCStringPtr(v94, 0x8000100u);
              if (!v96)
              {
                v97 = 2443886973;
LABEL_223:
                v118 = (char *)malloc_type_calloc(0x400uLL, 1uLL, v97);
                CFStringGetCString(v95, v118, 1024, 0x8000100u);
                v119 = v118;
                goto LABEL_224;
              }
              goto LABEL_165;
            }
            v128 = sub_100030318();
            if (os_log_type_enabled(v128, OS_LOG_TYPE_FAULT))
            {
              v129 = objc_msgSend(*((id *)v16 + 5), "uuid");
              v130 = *((_QWORD *)v16 + 6);
              *(_DWORD *)buf = 138413314;
              v202 = v62;
              v203 = 2112;
              *(_QWORD *)v204 = v129;
              *(_WORD *)&v204[8] = 2112;
              *(_QWORD *)&v204[10] = v130;
              *(_WORD *)&v204[18] = 1024;
              *(_DWORD *)&v204[20] = v190;
              v205 = 2112;
              v206 = v189;
              v131 = "Unable to format: Parsing spindump text: No address for frame line, and binary name %@ matches mult"
                     "iple load infos, assuming %@ segment %@ (%d: %@)";
              v132 = v128;
              v133 = 48;
LABEL_239:
              _os_log_fault_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_FAULT, v131, buf, v133);
            }
          }
          else
          {
            if (byte_1000EBD38)
            {
              v108 = *__error();
              v109 = sub_100030318();
              if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
              {
                v110 = objc_msgSend(*((id *)v16 + 5), "uuid");
                *(_DWORD *)buf = 138413058;
                v202 = v62;
                v203 = 2112;
                *(_QWORD *)v204 = v110;
                *(_WORD *)&v204[8] = 1024;
                *(_DWORD *)&v204[10] = v190;
                *(_WORD *)&v204[14] = 2112;
                *(_QWORD *)&v204[16] = v189;
                _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ (%d: %@)", buf, 0x26u);
              }
              *__error() = v108;
            }
            if (byte_1000EBD39)
              v111 = dword_1000EB4E8 <= 2;
            else
              v111 = 0;
            if (!v111)
              goto LABEL_157;
            v93 = *__error();
            v117 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: No address for frame line, and binary name %@ matches multiple load infos, assuming %@ (%d: %@)"), v62, objc_msgSend(*((id *)v16 + 5), "uuid"), v190, v189);
            v13 = v17;
            if (v117)
            {
              v95 = v117;
              v96 = CFStringGetCStringPtr(v117, 0x8000100u);
              if (!v96)
              {
                v97 = 2084680403;
                goto LABEL_223;
              }
LABEL_165:
              v118 = (char *)v96;
              v119 = 0;
LABEL_224:
              if (qword_1000EBD40)
                v146 = (FILE *)qword_1000EBD40;
              else
                v146 = __stderrp;
              fprintf(v146, "%s\n", v118);
              if (v119)
                free(v119);
              CFRelease(v95);
              goto LABEL_230;
            }
            v136 = sub_100030318();
            if (os_log_type_enabled(v136, OS_LOG_TYPE_FAULT))
            {
              v149 = objc_msgSend(*((id *)v16 + 5), "uuid");
              *(_DWORD *)buf = 138413058;
              v202 = v62;
              v203 = 2112;
              *(_QWORD *)v204 = v149;
              *(_WORD *)&v204[8] = 1024;
              *(_DWORD *)&v204[10] = v190;
              *(_WORD *)&v204[14] = 2112;
              *(_QWORD *)&v204[16] = v189;
              v131 = "Unable to format: Parsing spindump text: No address for frame line, and binary name %@ matches mult"
                     "iple load infos, assuming %@ (%d: %@)";
              v132 = v136;
              v133 = 38;
              goto LABEL_239;
            }
          }
          if (qword_1000EBD40)
            v137 = (FILE *)qword_1000EBD40;
          else
            v137 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v137);
LABEL_230:
          *__error() = v93;
LABEL_231:
          v139 = objc_msgSend(a3, "rangeWithName:", CFSTR("offsetIntoBinary"));
          if (v139 == (id)0x7FFFFFFFFFFFFFFFLL)
          {
            if (byte_1000EBD38)
            {
              v156 = *__error();
              v157 = sub_100030318();
              if (os_log_type_enabled(v157, OS_LOG_TYPE_ERROR))
                sub_100098228();
              *__error() = v156;
            }
            if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
            {
              v158 = *__error();
              v159 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: frame regex returned binary but no offset into binary (%d: %s)"), "range.location != NSNotFound", v190, objc_msgSend(v189, "UTF8String"));
              if (v159)
              {
                v175 = v159;
                v176 = CFStringGetCStringPtr(v159, 0x8000100u);
                if (v176)
                {
                  v177 = (char *)v176;
                  v178 = 0;
                }
                else
                {
                  v177 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x73195142uLL);
                  CFStringGetCString(v175, v177, 1024, 0x8000100u);
                  v178 = v177;
                }
                if (qword_1000EBD40)
                  v184 = (FILE *)qword_1000EBD40;
                else
                  v184 = __stderrp;
                fprintf(v184, "%s\n", v177);
                if (v178)
                  free(v178);
                CFRelease(v175);
              }
              else
              {
                v160 = sub_100030318();
                if (os_log_type_enabled(v160, OS_LOG_TYPE_FAULT))
                  sub_1000981B4();
                if (qword_1000EBD40)
                  v161 = (FILE *)qword_1000EBD40;
                else
                  v161 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v161);
              }
              *__error() = v158;
            }
            objc_msgSend(v189, "UTF8String");
            sub_1000301F0("LoadInfoForFrameLine", "SPTextualReportParser.m", 1225, "%s: frame regex returned binary but no offset into binary (%d: %s)", v185, v186, v187, v188, (char)"range.location != NSNotFound");
            goto LABEL_299;
          }
          goto LABEL_232;
        }
      }
      else
      {
        v65 = v16;
      }
      v67 = (char *)v67 + 1;
      v16 = v65;
    }
    while (v64 != v67);
    v69 = objc_msgSend(a4, "countByEnumeratingWithState:objects:count:", &v191, v200, 16);
    v64 = v69;
  }
  while (v69);
  v16 = v65;
  v13 = v17;
  if (v65)
    goto LABEL_231;
LABEL_91:
  if (byte_1000EBD38)
  {
    v70 = *__error();
    v71 = sub_100030318();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412802;
      v202 = v62;
      v203 = 1024;
      *(_DWORD *)v204 = v190;
      *(_WORD *)&v204[4] = 2112;
      *(_QWORD *)&v204[6] = v189;
      _os_log_error_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)", buf, 0x1Cu);
    }
    *__error() = v70;
    v13 = v17;
  }
  v16 = 0;
  if (!byte_1000EBD39 || dword_1000EB4E8 > 3)
    goto LABEL_235;
  v48 = *__error();
  v72 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)"), v62, v190, v189);
  if (!v72)
  {
    v112 = sub_100030318();
    if (!os_log_type_enabled(v112, OS_LOG_TYPE_FAULT))
      goto LABEL_182;
    *(_DWORD *)buf = 138412802;
    v202 = v62;
    v203 = 1024;
    *(_DWORD *)v204 = v190;
    *(_WORD *)&v204[4] = 2112;
    *(_QWORD *)&v204[6] = v189;
    v100 = "Unable to format: Parsing spindump text: No matching binary for frame line with binary name %@! (%d: %@)";
LABEL_180:
    v101 = v112;
    v102 = 28;
    goto LABEL_181;
  }
  v50 = v72;
  v51 = CFStringGetCStringPtr(v72, 0x8000100u);
  if (!v51)
  {
    v52 = 950882490;
    goto LABEL_169;
  }
LABEL_108:
  v76 = (char *)v51;
  v77 = 0;
LABEL_170:
  if (qword_1000EBD40)
    v120 = (FILE *)qword_1000EBD40;
  else
    v120 = __stderrp;
  fprintf(v120, "%s\n", v76);
  if (v77)
    free(v77);
  CFRelease(v50);
LABEL_186:
  v16 = 0;
  *__error() = v48;
LABEL_235:
  objc_autoreleasePoolPop(v13);
  return v16;
}

unint64_t sub_10007F0B0(void *a1)
{
  void *v2;
  const char *v3;
  id v4;
  unint64_t v5;

  v2 = objc_autoreleasePoolPush();
  v3 = (const char *)objc_msgSend(a1, "UTF8String");
  if (!v3)
  {
    v4 = objc_msgSend(a1, "dataUsingEncoding:allowLossyConversion:", 4, 1);
    if (!v4)
    {
      v5 = 0;
      goto LABEL_5;
    }
    v3 = (const char *)objc_msgSend(v4, "bytes");
  }
  v5 = strtoull(v3, 0, 0);
LABEL_5:
  objc_autoreleasePoolPop(v2);
  return v5;
}

uint64_t sub_10007F11C(FILE *a1, int a2, int a3, int a4, int a5, const char *a6, uint64_t a7, const char *a8, int a9, int a10)
{
  const char *v16;

  v16 = "";
  if (a3)
    v16 = "*";
  fprintf(a1, "%*s", a2, v16);
  fprintf(a1, "%-*d", a5, a4);
  fputs(a6, a1);
  if (a7 != -1)
    fprintf(a1, " [0x%llx]", a7);
  if (a8)
    fprintf(a1, " (%s)", a8);
  if (a9)
  {
    fprintf(a1, " %d", a9);
    if (a9 != a10)
      fprintf(a1, "-%d", a10);
  }
  return fputc(10, a1);
}

void sub_10007F228(void *a1, uint64_t a2, void *a3, int a4, int a5, int a6, _DWORD *a7, _DWORD *a8, BOOL *a9, _DWORD *a10, int *a11, _QWORD *a12, _QWORD *a13, int *a14, _DWORD *a15)
{
  _DWORD *v18;
  id v19;
  uint64_t v20;
  id v21;
  uint64_t v22;
  id v23;
  unint64_t v24;
  id v25;
  id v26;
  const __CFString *v27;
  const __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  const char *v35;
  uint64_t v36;
  const char *v37;
  id v38;
  uint64_t v39;
  int v40;
  int v41;
  id v42;
  uint64_t v43;
  int v44;
  id v45;
  uint64_t v46;
  int v47;
  id v48;
  uint64_t v49;
  int v50;
  NSObject *v51;
  int v52;
  const __CFString *v53;
  NSObject *v54;
  FILE *v55;
  int v56;
  NSObject *v57;
  int v58;
  const __CFString *v59;
  NSObject *v60;
  FILE *v61;
  const __CFString *v62;
  const char *CStringPtr;
  char *v64;
  char *v65;
  const __CFString *v66;
  const char *v67;
  char *v68;
  char *v69;
  FILE *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  FILE *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  void *context;

  v18 = a15;
  context = objc_autoreleasePoolPush();
  v19 = objc_msgSend(a3, "rangeWithName:", CFSTR("angleBracketContents"));
  if (v19 != (id)0x7FFFFFFFFFFFFFFFLL
    || (v19 = objc_msgSend(a3, "rangeWithName:", CFSTR("otherInfo")), v19 != (id)0x7FFFFFFFFFFFFFFFLL))
  {
    *a12 = objc_msgSend(a1, "substringWithRange:", v19, v20);
  }
  v21 = objc_msgSend(a3, "rangeWithName:", CFSTR("stateInfo"));
  if (v21 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v23 = objc_msgSend(a1, "substringWithRange:", v21, v22);
    if (a4)
    {
      v24 = sub_10007F0B0(v23);
      v25 = objc_alloc_init((Class)NSMutableString);
      v26 = v25;
      if ((v24 & 2) != 0)
        v27 = CFSTR("Frontmost App");
      else
        v27 = CFSTR("Non-Frontmost App");
      objc_msgSend(v25, "appendString:", v27);
      if ((v24 & 0x20) != 0)
        v28 = CFSTR(", Suppressed");
      else
        v28 = CFSTR(", Non-Suppressed");
      objc_msgSend(v26, "appendString:", v28);
      if ((v24 & 0x80) != 0)
        v29 = CFSTR(", Kernel mode");
      else
        v29 = CFSTR(", User mode");
      objc_msgSend(v26, "appendString:", v29);
      if ((v24 & 0x10) != 0)
      {
        if ((v24 & 4) != 0)
          v30 = CFSTR(", User Idle");
        else
          v30 = CFSTR(", User Active");
        objc_msgSend(v26, "appendString:", v30);
      }
      if ((v24 & 8) != 0)
        v31 = CFSTR(", On Battery");
      else
        v31 = CFSTR(", On AC");
      objc_msgSend(v26, "appendString:", v31);
      v32 = ((v24 >> 8) & 7) - 1;
      if (v32 > 6)
        v33 = "Thread QoS Unknown";
      else
        v33 = (&off_1000DDE90)[v32];
      objc_msgSend(v26, "appendFormat:", CFSTR(", Effective %s"), v33);
      v34 = ((v24 >> 11) & 7) - 1;
      if (v34 > 6)
        v35 = "Thread QoS Unknown";
      else
        v35 = (&off_1000DDE90)[v34];
      objc_msgSend(v26, "appendFormat:", CFSTR(", Requested %s"), v35);
      v36 = ((v24 >> 14) & 7) - 1;
      if (v36 > 6)
        v37 = "Thread QoS Unknown";
      else
        v37 = (&off_1000DDE90)[v36];
      objc_msgSend(v26, "appendFormat:", CFSTR(", Override %s"), v37);
    }
    else
    {
      v26 = v23;
    }
    *a13 = v26;
    v18 = a15;
  }
  v38 = objc_msgSend(a3, "rangeWithName:", CFSTR("count"));
  if (v38 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    *a10 = -1;
    *a11 = -1;
  }
  else
  {
    *a10 = sub_10007F0B0(objc_msgSend(a1, "substringWithRange:", v38, v39));
    if ((a4 & 1) != 0)
    {
      v40 = -1;
    }
    else if (objc_msgSend(a3, "rangeWithName:", CFSTR("countAndWhitespace")) == (id)0x7FFFFFFFFFFFFFFFLL)
    {
      if (byte_1000EBD38)
      {
        v50 = *__error();
        v51 = sub_100030318();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          sub_1000983E0();
        *__error() = v50;
      }
      if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
      {
        v52 = *__error();
        v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: frame match with no count and whitespace (%d: %s)"), "range.location != NSNotFound", a2, objc_msgSend(a1, "UTF8String"));
        if (v53)
        {
          v62 = v53;
          CStringPtr = CFStringGetCStringPtr(v53, 0x8000100u);
          if (CStringPtr)
          {
            v64 = (char *)CStringPtr;
            v65 = 0;
          }
          else
          {
            v64 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x446AA138uLL);
            CFStringGetCString(v62, v64, 1024, 0x8000100u);
            v65 = v64;
          }
          if (qword_1000EBD40)
            v70 = (FILE *)qword_1000EBD40;
          else
            v70 = __stderrp;
          fprintf(v70, "%s\n", v64);
          if (v65)
            free(v65);
          CFRelease(v62);
        }
        else
        {
          v54 = sub_100030318();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_FAULT))
            sub_10009836C();
          if (qword_1000EBD40)
            v55 = (FILE *)qword_1000EBD40;
          else
            v55 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v55);
        }
        *__error() = v52;
      }
      objc_msgSend(a1, "UTF8String");
      sub_1000301F0("ParseCallTreeNonFrameLine", "SPTextualReportParser.m", 2228, "%s: frame match with no count and whitespace (%d: %s)", v71, v72, v73, v74, (char)"range.location != NSNotFound");
LABEL_102:
      abort();
    }
    *a11 = v40;
    *a7 = sub_10007D560(a1, a3, a4, a5, a6);
  }
  if (objc_msgSend(a3, "rangeWithName:", CFSTR("indentWhitespace")) != (id)0x7FFFFFFFFFFFFFFFLL)
    *a8 = v41;
  *a9 = objc_msgSend(a3, "rangeWithName:", CFSTR("kernelDot")) != (id)0x7FFFFFFFFFFFFFFFLL;
  v42 = objc_msgSend(a3, "rangeWithName:", CFSTR("count"));
  if (v42 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v44 = -1;
    *a10 = -1;
    goto LABEL_48;
  }
  *a10 = sub_10007F0B0(objc_msgSend(a1, "substringWithRange:", v42, v43));
  if ((a4 & 1) != 0)
  {
    v44 = -1;
    goto LABEL_48;
  }
  if (objc_msgSend(a3, "rangeWithName:", CFSTR("countAndWhitespace")) == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    if (byte_1000EBD38)
    {
      v56 = *__error();
      v57 = sub_100030318();
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
        sub_1000983E0();
      *__error() = v56;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v58 = *__error();
      v59 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: frame match with no count and whitespace (%d: %s)"), "range.location != NSNotFound", a2, objc_msgSend(a1, "UTF8String"));
      if (v59)
      {
        v66 = v59;
        v67 = CFStringGetCStringPtr(v59, 0x8000100u);
        if (v67)
        {
          v68 = (char *)v67;
          v69 = 0;
        }
        else
        {
          v68 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x1863B9A1uLL);
          CFStringGetCString(v66, v68, 1024, 0x8000100u);
          v69 = v68;
        }
        if (qword_1000EBD40)
          v75 = (FILE *)qword_1000EBD40;
        else
          v75 = __stderrp;
        fprintf(v75, "%s\n", v68);
        if (v69)
          free(v69);
        CFRelease(v66);
      }
      else
      {
        v60 = sub_100030318();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_FAULT))
          sub_10009836C();
        if (qword_1000EBD40)
          v61 = (FILE *)qword_1000EBD40;
        else
          v61 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v61);
      }
      *__error() = v58;
    }
    objc_msgSend(a1, "UTF8String");
    sub_1000301F0("ParseCallTreeNonFrameLine", "SPTextualReportParser.m", 2261, "%s: frame match with no count and whitespace (%d: %s)", v76, v77, v78, v79, (char)"range.location != NSNotFound");
    goto LABEL_102;
  }
LABEL_48:
  *a11 = v44;
  v45 = objc_msgSend(a3, "rangeWithName:", CFSTR("startIndex"));
  if (v45 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v47 = 0;
    *a14 = 0;
  }
  else
  {
    *a14 = sub_10007F0B0(objc_msgSend(a1, "substringWithRange:", v45, v46));
    v48 = objc_msgSend(a3, "rangeWithName:", CFSTR("endIndex"));
    if (v48 == (id)0x7FFFFFFFFFFFFFFFLL)
      v47 = *a14;
    else
      v47 = sub_10007F0B0(objc_msgSend(a1, "substringWithRange:", v48, v49));
  }
  *v18 = v47;
  objc_autoreleasePoolPop(context);
}

uint64_t sub_10007FA1C(FILE *a1, int a2, int a3, int a4, int a5, const char *a6, uint64_t a7, int a8, int a9)
{
  const char *v15;

  v15 = "*";
  if (!a3)
    v15 = "";
  fprintf(a1, "%*s", a2, v15);
  if (a4 < 1)
  {
    if (a5 >= 1)
      fprintf(a1, "%*s");
  }
  else
  {
    fprintf(a1, "%-*d");
  }
  if (a6)
  {
    fprintf(a1, "<%s>", a6);
    if (a7)
      fprintf(a1, " (%s)");
  }
  else if (a7)
  {
    fprintf(a1, "<%s>");
  }
  if (a8)
  {
    fprintf(a1, " %d", a8);
    if (a8 != a9)
      fprintf(a1, "-%d", a9);
  }
  return fputc(10, a1);
}

int64_t sub_10007FB48(id a1, SPTreeNode *a2, SPTreeNode *a3)
{
  int count;
  int v4;
  int v6;
  int v7;

  if (a2)
  {
    count = a2->_count;
    if (a3)
    {
LABEL_3:
      v4 = a3->_count;
      goto LABEL_4;
    }
  }
  else
  {
    count = 0;
    if (a3)
      goto LABEL_3;
  }
  v4 = 0;
LABEL_4:
  if (count < v4)
    return 1;
  if (a2)
  {
    v6 = a2->_count;
    if (a3)
    {
LABEL_8:
      v7 = a3->_count;
      goto LABEL_9;
    }
  }
  else
  {
    v6 = 0;
    if (a3)
      goto LABEL_8;
  }
  v7 = 0;
LABEL_9:
  if (v6 <= v7)
    return 0;
  else
    return -1;
}

void sub_10007FC6C(FILE *a1, int a2, uint64_t a3)
{
  uint64_t v4;
  off_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  off_t v14;
  const char *v15;
  int v16;
  id v17;
  id v18;
  int v19;
  NSObject *v20;
  BOOL v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  NSObject *v28;
  int v29;
  int *v30;
  char *v31;
  BOOL v32;
  int v33;
  uint64_t v34;
  int *v35;
  char *v36;
  const __CFString *v37;
  const __CFString *v38;
  NSObject *v39;
  int v40;
  int *v41;
  char *v42;
  FILE *v43;
  int *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  int *v51;
  char *v52;
  const __CFString *v53;
  const __CFString *v54;
  NSObject *v55;
  FILE *v56;
  char *CStringPtr;
  char *v58;
  FILE *v59;
  char *v60;
  char *v61;
  FILE *v62;
  _QWORD v63[2];
  void *(*v64)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v65;
  uint64_t *v66;
  uint64_t *v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t v74;
  uint64_t v75;
  uint8_t buf[4];
  const char *v77;
  __int16 v78;
  off_t v79;
  __int16 v80;
  int v81;
  __int16 v82;
  char *v83;

  LODWORD(v4) = a2;
  v6 = ftello(a1);
  if (v6 == -1)
  {
    if (byte_1000EBD38)
    {
      v19 = *__error();
      v20 = sub_100030318();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        sub_1000984E0();
      *__error() = v19;
    }
    if (byte_1000EBD39)
      v21 = dword_1000EB4E8 <= 3;
    else
      v21 = 0;
    if (v21)
    {
      v49 = *__error();
      v50 = *__error();
      v51 = __error();
      v52 = strerror(*v51);
      v53 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: ftello failed: %d (%s)"), "pos != -1", v50, v52);
      v54 = v53;
      if (v53)
      {
        CStringPtr = (char *)CFStringGetCStringPtr(v53, 0x8000100u);
        if (CStringPtr)
        {
          v58 = 0;
        }
        else
        {
          CStringPtr = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x18926F60uLL);
          CFStringGetCString(v54, CStringPtr, 1024, 0x8000100u);
          v58 = CStringPtr;
        }
        if (qword_1000EBD40)
          v59 = (FILE *)qword_1000EBD40;
        else
          v59 = __stderrp;
        fprintf(v59, "%s\n", CStringPtr);
        if (v58)
          free(v58);
        CFRelease(v54);
      }
      else
      {
        v55 = sub_100030318();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_FAULT))
          sub_100098454();
        if (qword_1000EBD40)
          v56 = (FILE *)qword_1000EBD40;
        else
          v56 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v56);
      }
      *__error() = v49;
    }
    __error();
    v22 = __error();
    strerror(*v22);
    sub_1000301F0("LookaheadLines", "SPTextualReportParser.m", 965, "%s: ftello failed: %d (%s)", v23, v24, v25, v26, (char)"pos != -1");
    abort();
  }
  v14 = v6;
  v72 = 0;
  v73 = &v72;
  v74 = 0x2020000000;
  v75 = 0;
  v68 = 0;
  v69 = &v68;
  v70 = 0x2020000000;
  v71 = 0;
  v63[0] = _NSConcreteStackBlock;
  v63[1] = 3221225472;
  v64 = sub_100081320;
  v65 = &unk_1000DD298;
  v66 = &v68;
  v67 = &v72;
  sub_100081320((uint64_t)v63, v7, v8, v9, v10, v11, v12, v13);
  if (fgets((char *)v73[3], *((_DWORD *)v69 + 6), a1))
  {
    do
    {
      v15 = (const char *)v73[3];
      v16 = strnlen(v15, *((int *)v69 + 6));
      if (v15[v16 - 1] == 10)
      {
        v15[v16 - 1] = 0;
        v17 = objc_alloc((Class)NSString);
        v18 = objc_msgSend(v17, "initWithUTF8String:", v73[3]);
        v4 = (v4 + 1);
        buf[0] = 0;
        (*(void (**)(uint64_t, id, uint64_t, uint8_t *))(a3 + 16))(a3, v18, v4, buf);

        if (buf[0])
          break;
        v16 = 0;
      }
      else
      {
        ((void (*)(_QWORD *))v64)(v63);
      }
    }
    while (fgets((char *)(v73[3] + v16), *((_DWORD *)v69 + 6) - v16, a1));
  }
  free((void *)v73[3]);
  if (fseeko(a1, v14, 0))
  {
    if (byte_1000EBD38)
    {
      v27 = *__error();
      v28 = sub_100030318();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        v29 = *__error();
        v30 = __error();
        v31 = strerror(*v30);
        *(_DWORD *)buf = 136315906;
        v77 = "ret == 0";
        v78 = 2048;
        v79 = v14;
        v80 = 1024;
        v81 = v29;
        v82 = 2080;
        v83 = v31;
        _os_log_error_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%s: Unable to seek back to %lld after searching for load infos: %d (%s)", buf, 0x26u);
      }
      *__error() = v27;
    }
    if (byte_1000EBD39)
      v32 = dword_1000EB4E8 <= 3;
    else
      v32 = 0;
    if (v32)
    {
      v33 = *__error();
      v34 = *__error();
      v35 = __error();
      v36 = strerror(*v35);
      v37 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Unable to seek back to %lld after searching for load infos: %d (%s)"), "ret == 0", v14, v34, v36);
      v38 = v37;
      if (v37)
      {
        v60 = (char *)CFStringGetCStringPtr(v37, 0x8000100u);
        if (v60)
        {
          v61 = 0;
        }
        else
        {
          v60 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x140109E3uLL);
          CFStringGetCString(v38, v60, 1024, 0x8000100u);
          v61 = v60;
        }
        if (qword_1000EBD40)
          v62 = (FILE *)qword_1000EBD40;
        else
          v62 = __stderrp;
        fprintf(v62, "%s\n", v60);
        if (v61)
          free(v61);
        CFRelease(v38);
      }
      else
      {
        v39 = sub_100030318();
        if (os_log_type_enabled(v39, OS_LOG_TYPE_FAULT))
        {
          v40 = *__error();
          v41 = __error();
          v42 = strerror(*v41);
          *(_DWORD *)buf = 136315906;
          v77 = "ret == 0";
          v78 = 2048;
          v79 = v14;
          v80 = 1024;
          v81 = v40;
          v82 = 2080;
          v83 = v42;
          _os_log_fault_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_FAULT, "Unable to format: %s: Unable to seek back to %lld after searching for load infos: %d (%s)", buf, 0x26u);
        }
        if (qword_1000EBD40)
          v43 = (FILE *)qword_1000EBD40;
        else
          v43 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v43);
      }
      *__error() = v33;
    }
    __error();
    v44 = __error();
    strerror(*v44);
    sub_1000301F0("LookaheadLines", "SPTextualReportParser.m", 1008, "%s: Unable to seek back to %lld after searching for load infos: %d (%s)", v45, v46, v47, v48, (char)"ret == 0");
    abort();
  }
  _Block_object_dispose(&v68, 8);
  _Block_object_dispose(&v72, 8);
}

void sub_100080300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v12;
  va_list va;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v12 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

int *sub_100080360(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v8;
  void *v9;
  int v10;
  id v11;
  id v12;
  uint64_t v13;
  unint64_t v14;
  int *result;
  int v16;
  NSObject *v17;
  BOOL v18;
  int v19;
  const __CFString *v20;
  const __CFString *v21;
  const char *v22;
  char *v23;
  char *v24;
  id v25;
  uint64_t v26;
  id v27;
  uint64_t v28;
  id v29;
  uint64_t v30;
  id v31;
  id v32;
  uint64_t v33;
  id v34;
  id v35;
  uint64_t v36;
  id v37;
  id v38;
  uint64_t v39;
  id v40;
  id v41;
  uint64_t v42;
  id v43;
  id v44;
  uint64_t v45;
  id v46;
  id v47;
  id v48;
  id v49;
  id v50;
  id v51;
  id v52;
  id v53;
  SABinary *v54;
  int v55;
  NSObject *v56;
  int v57;
  const __CFString *v58;
  const __CFString *v59;
  const char *v60;
  char *v61;
  char *v62;
  int v63;
  NSObject *v64;
  BOOL v65;
  int v66;
  const __CFString *v67;
  const __CFString *v68;
  const char *v69;
  char *v70;
  char *v71;
  NSObject *v72;
  FILE *v73;
  NSObject *v74;
  FILE *v75;
  FILE *v76;
  FILE *v77;
  NSObject *v78;
  FILE *v79;
  id v80;
  FILE *v81;
  id v82;
  int v83;
  NSObject *v84;
  int v85;
  const __CFString *v86;
  NSObject *v87;
  FILE *v88;
  int v89;
  NSObject *v90;
  int v91;
  const __CFString *v92;
  NSObject *v93;
  FILE *v94;
  uint64_t v95;
  int v96;
  NSObject *v97;
  BOOL v98;
  int v99;
  const __CFString *v100;
  NSObject *v101;
  FILE *v102;
  const __CFString *v103;
  const char *v104;
  char *v105;
  char *v106;
  const __CFString *v107;
  const char *v108;
  char *v109;
  char *v110;
  const __CFString *v111;
  const char *CStringPtr;
  char *v113;
  char *v114;
  FILE *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  FILE *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  FILE *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _BYTE *v130;
  uint64_t v131;
  unint64_t v132;
  unint64_t v133;
  int *v134;
  uint8_t buf[4];
  _BYTE v136[18];
  __int16 v137;
  int v138;
  __int16 v139;
  void *v140;

  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24))
  {
    v8 = objc_msgSend(*(id *)(a1 + 32), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
    if (v8)
    {
      v9 = v8;
      v10 = *(unsigned __int8 *)(a1 + 56);
      v11 = objc_msgSend(v8, "rangeWithName:", CFSTR("kernelDot"));
      if (v10)
      {
        v12 = objc_msgSend(v9, "rangeWithName:", CFSTR("binaryIndex"));
        if (v12 == (id)0x7FFFFFFFFFFFFFFFLL)
        {
          v95 = a3;
          if (byte_1000EBD38)
          {
            v96 = *__error();
            v97 = sub_100030318();
            if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
              sub_1000988E0();
            *__error() = v96;
          }
          if (byte_1000EBD39)
            v98 = dword_1000EB4E8 <= 3;
          else
            v98 = 0;
          if (v98)
          {
            v99 = *__error();
            v100 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Parsing spindump text: No binary index (%d: %s)"), "range.location != NSNotFound", v95, objc_msgSend(a2, "UTF8String"));
            if (v100)
            {
              v111 = v100;
              CStringPtr = CFStringGetCStringPtr(v100, 0x8000100u);
              if (CStringPtr)
              {
                v113 = (char *)CStringPtr;
                v114 = 0;
              }
              else
              {
                v113 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x4D37C403uLL);
                CFStringGetCString(v111, v113, 1024, 0x8000100u);
                v114 = v113;
              }
              if (qword_1000EBD40)
                v125 = (FILE *)qword_1000EBD40;
              else
                v125 = __stderrp;
              fprintf(v125, "%s\n", v113);
              if (v114)
                free(v114);
              CFRelease(v111);
            }
            else
            {
              v101 = sub_100030318();
              if (os_log_type_enabled(v101, OS_LOG_TYPE_FAULT))
                sub_10009886C();
              if (qword_1000EBD40)
                v102 = (FILE *)qword_1000EBD40;
              else
                v102 = __stderrp;
              fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v102);
            }
            *__error() = v99;
          }
          objc_msgSend(a2, "UTF8String");
          sub_1000301F0("ParseLoadInfoLine", "SPTextualReportParser.m", 2343, "%s: Parsing spindump text: No binary index (%d: %s)", v126, v127, v128, v129, (char)"range.location != NSNotFound");
          goto LABEL_196;
        }
        v14 = sub_10007F0B0(objc_msgSend(a2, "substringWithRange:", v12, v13));
      }
      else
      {
        v14 = 0;
      }
      v25 = objc_msgSend(v9, "rangeWithName:", CFSTR("startAddress"));
      if (v25 == (id)0x7FFFFFFFFFFFFFFFLL)
        v133 = 0;
      else
        v133 = sub_10007F0B0(objc_msgSend(a2, "substringWithRange:", v25, v26));
      v130 = a4;
      v27 = objc_msgSend(v9, "rangeWithName:", CFSTR("endAddress"));
      if (v27 == (id)0x7FFFFFFFFFFFFFFFLL)
        v132 = 0;
      else
        v132 = sub_10007F0B0(objc_msgSend(a2, "substringWithRange:", v27, v28));
      v29 = objc_msgSend(v9, "rangeWithName:", CFSTR("bundleIdentifier"));
      if (v29 == (id)0x7FFFFFFFFFFFFFFFLL)
        v31 = 0;
      else
        v31 = objc_msgSend(a2, "substringWithRange:", v29, v30);
      v32 = objc_msgSend(v9, "rangeWithName:", CFSTR("name"));
      if (v32 == (id)0x7FFFFFFFFFFFFFFFLL)
        v34 = 0;
      else
        v34 = objc_msgSend(a2, "substringWithRange:", v32, v33);
      v134 = (int *)v14;
      v35 = objc_msgSend(v9, "rangeWithName:", CFSTR("version"));
      if (v35 == (id)0x7FFFFFFFFFFFFFFFLL)
        v37 = 0;
      else
        v37 = objc_msgSend(a2, "substringWithRange:", v35, v36);
      v38 = objc_msgSend(v9, "rangeWithName:", CFSTR("binaryUuid"));
      if (v38 == (id)0x7FFFFFFFFFFFFFFFLL)
      {
        if (byte_1000EBD38)
        {
          v83 = *__error();
          v84 = sub_100030318();
          if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
            sub_100098710();
          *__error() = v83;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v85 = *__error();
          v86 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No uuid in load info (%d: %s)"), "range.location != NSNotFound", a3, objc_msgSend(a2, "UTF8String"));
          if (v86)
          {
            v103 = v86;
            v104 = CFStringGetCStringPtr(v86, 0x8000100u);
            if (v104)
            {
              v105 = (char *)v104;
              v106 = 0;
            }
            else
            {
              v105 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x7086F3D7uLL);
              CFStringGetCString(v103, v105, 1024, 0x8000100u);
              v106 = v105;
            }
            if (qword_1000EBD40)
              v115 = (FILE *)qword_1000EBD40;
            else
              v115 = __stderrp;
            fprintf(v115, "%s\n", v105);
            if (v106)
              free(v106);
            CFRelease(v103);
          }
          else
          {
            v87 = sub_100030318();
            if (os_log_type_enabled(v87, OS_LOG_TYPE_FAULT))
              sub_10009869C();
            if (qword_1000EBD40)
              v88 = (FILE *)qword_1000EBD40;
            else
              v88 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v88);
          }
          *__error() = v85;
        }
        objc_msgSend(a2, "UTF8String");
        sub_1000301F0("ParseLoadInfoLine", "SPTextualReportParser.m", 2391, "%s: No uuid in load info (%d: %s)", v116, v117, v118, v119, (char)"range.location != NSNotFound");
      }
      else
      {
        v131 = a3;
        v40 = sub_100081774(objc_msgSend(a2, "substringWithRange:", v38, v39));
        v41 = objc_msgSend(v9, "rangeWithName:", CFSTR("segmentName"));
        if (v41 == (id)0x7FFFFFFFFFFFFFFFLL)
          v43 = 0;
        else
          v43 = objc_msgSend(a2, "substringWithRange:", v41, v42);
        v44 = objc_msgSend(v9, "rangeWithName:", CFSTR("binaryPath"));
        if (v44 == (id)0x7FFFFFFFFFFFFFFFLL)
          v46 = 0;
        else
          v46 = objc_msgSend(a2, "substringWithRange:", v44, v45);
        v47 = v31;
        v48 = v34;
        v49 = v37;
        v50 = v40;
        v51 = v43;
        v52 = v46;
        if (v40)
        {
          if (*(_BYTE *)(a1 + 56) && (result = (int *)objc_msgSend(*(id *)(a1 + 40), "count"), v134 != result))
          {
            if (byte_1000EBD38)
            {
              v55 = *__error();
              v56 = sub_100030318();
              if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
              {
                v80 = objc_msgSend(*(id *)(a1 + 40), "count");
                *(_DWORD *)buf = 134218754;
                *(_QWORD *)v136 = v80;
                *(_WORD *)&v136[8] = 2048;
                *(_QWORD *)&v136[10] = v134;
                v137 = 1024;
                v138 = v131;
                v139 = 2112;
                v140 = a2;
                _os_log_error_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)", buf, 0x26u);
              }
              result = __error();
              *result = v55;
            }
            if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
            {
              v57 = *__error();
              v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)"), objc_msgSend(*(id *)(a1 + 40), "count"), v134, v131, a2);
              if (v58)
              {
                v59 = v58;
                v60 = CFStringGetCStringPtr(v58, 0x8000100u);
                if (v60)
                {
                  v61 = (char *)v60;
                  v62 = 0;
                }
                else
                {
                  v61 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xDA92CAC3uLL);
                  CFStringGetCString(v59, v61, 1024, 0x8000100u);
                  v62 = v61;
                }
                if (qword_1000EBD40)
                  v77 = (FILE *)qword_1000EBD40;
                else
                  v77 = __stderrp;
                fprintf(v77, "%s\n", v61);
                if (v62)
                  free(v62);
                CFRelease(v59);
              }
              else
              {
                v74 = sub_100030318();
                if (os_log_type_enabled(v74, OS_LOG_TYPE_FAULT))
                {
                  v82 = objc_msgSend(*(id *)(a1 + 40), "count");
                  *(_DWORD *)buf = 134218754;
                  *(_QWORD *)v136 = v82;
                  *(_WORD *)&v136[8] = 2048;
                  *(_QWORD *)&v136[10] = v134;
                  v137 = 1024;
                  v138 = v131;
                  v139 = 2112;
                  v140 = a2;
                  _os_log_fault_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_FAULT, "Unable to format: Parsing spindump text: corrupt condensed file, binary at position %lu has index %lu (%d: %@)", buf, 0x26u);
                }
                if (qword_1000EBD40)
                  v75 = (FILE *)qword_1000EBD40;
                else
                  v75 = __stderrp;
                fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v75);
              }
              result = __error();
              *result = v57;
            }
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 0;
            *v130 = 1;
          }
          else
          {
            if (objc_msgSend(v46, "isAbsolutePath"))
              v53 = v46;
            else
              v53 = 0;
            v54 = +[SABinary binaryWithUUID:absolutePath:](SABinary, "binaryWithUUID:absolutePath:", v40, v53);
            if (!-[SABinary path](v54, "path"))
            {
              if (v46)
                -[SABinary addPath:](v54, "addPath:", v46);
            }
            return (int *)objc_msgSend(*(id *)(a1 + 40), "addObject:", sub_10007648C([SPLoadInfo alloc], v54, v11 != (id)0x7FFFFFFFFFFFFFFFLL, v133, v132, v31, v34, v37, v43));
          }
          return result;
        }
        if (byte_1000EBD38)
        {
          v89 = *__error();
          v90 = sub_100030318();
          if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
            sub_1000987F8();
          *__error() = v89;
        }
        if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
        {
          v91 = *__error();
          v92 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: No UUID in (%d: %s)"), "uuid", v131, objc_msgSend(a2, "UTF8String"));
          if (v92)
          {
            v107 = v92;
            v108 = CFStringGetCStringPtr(v92, 0x8000100u);
            if (v108)
            {
              v109 = (char *)v108;
              v110 = 0;
            }
            else
            {
              v109 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xEFE6DB91uLL);
              CFStringGetCString(v107, v109, 1024, 0x8000100u);
              v110 = v109;
            }
            if (qword_1000EBD40)
              v120 = (FILE *)qword_1000EBD40;
            else
              v120 = __stderrp;
            fprintf(v120, "%s\n", v109);
            if (v110)
              free(v110);
            CFRelease(v107);
          }
          else
          {
            v93 = sub_100030318();
            if (os_log_type_enabled(v93, OS_LOG_TYPE_FAULT))
              sub_100098784();
            if (qword_1000EBD40)
              v94 = (FILE *)qword_1000EBD40;
            else
              v94 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v94);
          }
          *__error() = v91;
        }
        objc_msgSend(a2, "UTF8String");
        sub_1000301F0("CopyNextLoadInfos_block_invoke", "SPTextualReportParser.m", 1066, "%s: No UUID in (%d: %s)", v121, v122, v123, v124, (char)"uuid");
      }
LABEL_196:
      abort();
    }
    result = (int *)objc_msgSend(a2, "length");
    if (result)
    {
      if (byte_1000EBD38)
      {
        v16 = *__error();
        v17 = sub_100030318();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_100098634();
        result = __error();
        *result = v16;
      }
      if (byte_1000EBD39)
        v18 = dword_1000EB4E8 <= 3;
      else
        v18 = 0;
      if (v18)
      {
        v19 = *__error();
        v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: Unexpected line in load infos, ignoring (%d: %@)"), a3, a2);
        if (v20)
        {
          v21 = v20;
          v22 = CFStringGetCStringPtr(v20, 0x8000100u);
          if (v22)
          {
            v23 = (char *)v22;
            v24 = 0;
          }
          else
          {
            v23 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x620F5784uLL);
            CFStringGetCString(v21, v23, 1024, 0x8000100u);
            v24 = v23;
          }
          if (qword_1000EBD40)
            v76 = (FILE *)qword_1000EBD40;
          else
            v76 = __stderrp;
          fprintf(v76, "%s\n", v23);
          if (v24)
            free(v24);
          CFRelease(v21);
        }
        else
        {
          v72 = sub_100030318();
          if (os_log_type_enabled(v72, OS_LOG_TYPE_FAULT))
            sub_1000985CC();
          if (qword_1000EBD40)
            v73 = (FILE *)qword_1000EBD40;
          else
            v73 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v73);
        }
        result = __error();
        *result = v19;
      }
    }
    else
    {
      result = (int *)objc_msgSend(*(id *)(a1 + 40), "count");
      if (!result)
      {
        if (byte_1000EBD38)
        {
          v63 = *__error();
          v64 = sub_100030318();
          if (os_log_type_enabled(v64, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 67109378;
            *(_DWORD *)v136 = a3;
            *(_WORD *)&v136[4] = 2112;
            *(_QWORD *)&v136[6] = a2;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_INFO, "Parsing spindump text: No load infos, ended at line (%d: %@)", buf, 0x12u);
          }
          result = __error();
          *result = v63;
        }
        if (byte_1000EBD39)
          v65 = dword_1000EB4E8 <= 1;
        else
          v65 = 0;
        if (v65)
        {
          v66 = *__error();
          v67 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: No load infos, ended at line (%d: %@)"), a3, a2);
          if (v67)
          {
            v68 = v67;
            v69 = CFStringGetCStringPtr(v67, 0x8000100u);
            if (v69)
            {
              v70 = (char *)v69;
              v71 = 0;
            }
            else
            {
              v70 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6C14095BuLL);
              CFStringGetCString(v68, v70, 1024, 0x8000100u);
              v71 = v70;
            }
            if (qword_1000EBD40)
              v81 = (FILE *)qword_1000EBD40;
            else
              v81 = __stderrp;
            fprintf(v81, "%s\n", v70);
            if (v71)
              free(v71);
            CFRelease(v68);
          }
          else
          {
            v78 = sub_100030318();
            if (os_log_type_enabled(v78, OS_LOG_TYPE_FAULT))
              sub_100098564();
            if (qword_1000EBD40)
              v79 = (FILE *)qword_1000EBD40;
            else
              v79 = __stderrp;
            fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v79);
          }
          result = __error();
          *result = v66;
        }
      }
      *a4 = 1;
    }
  }
  else
  {
    result = (int *)objc_msgSend(a2, "containsString:", CFSTR("Binary Images:"));
    if ((_DWORD)result)
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
  }
  return result;
}

void *sub_100081320(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  NSObject *v14;
  BOOL v15;
  int v16;
  const __CFString *v17;
  NSObject *v18;
  FILE *v19;
  void *result;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  NSObject *v26;
  int v27;
  const __CFString *v28;
  NSObject *v29;
  FILE *v30;
  const __CFString *v31;
  const char *v32;
  char *v33;
  char *v34;
  FILE *v35;
  const __CFString *v36;
  const char *CStringPtr;
  char *v38;
  char *v39;
  FILE *v40;

  v9 = a1 + 32;
  v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v11 = *(_DWORD *)(v10 + 24);
  if (v11)
  {
    *(_DWORD *)(v10 + 24) = 2 * v11;
    v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24);
    if (v12 <= 0)
    {
      if (byte_1000EBD38)
      {
        v13 = *__error();
        v14 = sub_100030318();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          sub_10009805C();
        *__error() = v13;
      }
      if (byte_1000EBD39)
        v15 = dword_1000EB4E8 <= 3;
      else
        v15 = 0;
      if (v15)
      {
        v16 = *__error();
        v17 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: bufSize overflow (%d)"), "bufSize > 0", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24));
        if (v17)
        {
          v36 = v17;
          CStringPtr = CFStringGetCStringPtr(v17, 0x8000100u);
          if (CStringPtr)
          {
            v38 = (char *)CStringPtr;
            v39 = 0;
          }
          else
          {
            v38 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x91C41402uLL);
            CFStringGetCString(v36, v38, 1024, 0x8000100u);
            v39 = v38;
          }
          if (qword_1000EBD40)
            v40 = (FILE *)qword_1000EBD40;
          else
            v40 = __stderrp;
          fprintf(v40, "%s\n", v38);
          if (v39)
            free(v39);
          CFRelease(v36);
        }
        else
        {
          v18 = sub_100030318();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_FAULT))
            sub_100097FEC();
          if (qword_1000EBD40)
            v19 = (FILE *)qword_1000EBD40;
          else
            v19 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v19);
        }
        *__error() = v16;
      }
      sub_1000301F0("LookaheadLines_block_invoke", "SPTextualReportParser.m", 976, "%s: bufSize overflow (%d)", a5, a6, a7, a8, (char)"bufSize > 0");
      goto LABEL_56;
    }
  }
  else
  {
    *(_DWORD *)(v10 + 24) = 0x4000;
    v12 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24);
  }
  result = reallocf(*(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24), v12);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
  {
    if (byte_1000EBD38)
    {
      v25 = *__error();
      v26 = sub_100030318();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        sub_100097F7C();
      *__error() = v25;
    }
    if (byte_1000EBD39 && dword_1000EB4E8 <= 3)
    {
      v27 = *__error();
      v28 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: Unable to allocate %d buffer"), "buf", *(unsigned int *)(*(_QWORD *)(*(_QWORD *)v9 + 8) + 24));
      if (v28)
      {
        v31 = v28;
        v32 = CFStringGetCStringPtr(v28, 0x8000100u);
        if (v32)
        {
          v33 = (char *)v32;
          v34 = 0;
        }
        else
        {
          v33 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xFCFB37F6uLL);
          CFStringGetCString(v31, v33, 1024, 0x8000100u);
          v34 = v33;
        }
        if (qword_1000EBD40)
          v35 = (FILE *)qword_1000EBD40;
        else
          v35 = __stderrp;
        fprintf(v35, "%s\n", v33);
        if (v34)
          free(v34);
        CFRelease(v31);
      }
      else
      {
        v29 = sub_100030318();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_FAULT))
          sub_100097F0C();
        if (qword_1000EBD40)
          v30 = (FILE *)qword_1000EBD40;
        else
          v30 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v30);
      }
      *__error() = v27;
    }
    sub_1000301F0("LookaheadLines_block_invoke", "SPTextualReportParser.m", 979, "%s: Unable to allocate %d buffer", v21, v22, v23, v24, (char)"buf");
LABEL_56:
    abort();
  }
  return result;
}

id sub_100081774(void *a1)
{
  id v2;
  id v3;

  v2 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDString:", a1);
  if (!v2)
  {
    if ((unint64_t)objc_msgSend(a1, "length") < 0x20)
    {
      v2 = 0;
    }
    else
    {
      v3 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%@-%@-%@-%@-%@"), objc_msgSend(a1, "substringWithRange:", 0, 8), objc_msgSend(a1, "substringWithRange:", 8, 4), objc_msgSend(a1, "substringWithRange:", 12, 4), objc_msgSend(a1, "substringWithRange:", 16, 4), objc_msgSend(a1, "substringWithRange:", 20, 12));
      v2 = objc_msgSend(objc_alloc((Class)NSUUID), "initWithUUIDString:", v3);

    }
  }
  return v2;
}

uint64_t sub_100081890(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  uint64_t v5;

  if (a2)
    v2 = *(_QWORD *)(a2 + 56);
  else
    v2 = 0;
  v3 = *(_QWORD *)(a1 + 32);
  v4 = v3 > v2;
  if (v3 >= v2)
    v5 = 0;
  else
    v5 = -1;
  if (v4)
    return 1;
  else
    return v5;
}

void sub_1000818B4(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void sub_1000818C4(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

id *sub_1000818D0(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  void *v8;
  id v9;
  id v10;
  uint64_t v11;
  void *i;
  id *result;
  id *v14;
  id v15;
  NSNull *v16;
  id v17;
  NSNull *v18;
  unint64_t v19;
  unint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];

  if (!*(_BYTE *)(a1 + 104)
    && ((objc_msgSend(a2, "hasPrefix:", CFSTR("Process:")) & 1) != 0
     || objc_msgSend(a2, "hasPrefix:", CFSTR("Powerstats for:"))))
  {
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v8 = *(void **)(a1 + 32);
    v9 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
    if (v9)
    {
      v10 = v9;
      v11 = *(_QWORD *)v22;
      do
      {
        for (i = 0; i != v10; i = (char *)i + 1)
        {
          if (*(_QWORD *)v22 != v11)
            objc_enumerationMutation(v8);
          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24) = objc_msgSend(a2, "containsString:", *(_QWORD *)(*((_QWORD *)&v21 + 1) + 8 * (_QWORD)i));
        }
        v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v21, v25, 16);
      }
      while (v10);
    }
  }
  result = (id *)objc_msgSend(a2, "containsString:", CFSTR("Binary Images:"));
  if ((_DWORD)result)
  {
    if (!*(_BYTE *)(a1 + 105))
    {

      result = (id *)sub_10007D464(*(FILE **)(a1 + 96), a3, *(_QWORD *)(a1 + 40), *(_BYTE *)(a1 + 105));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40) = result;
      if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40))
        *a4 = 1;
    }
  }
  else
  {
    result = (id *)objc_msgSend(*(id *)(a1 + 48), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
    if (result)
    {
      v20 = -1;
      result = (id *)sub_10007D5F4(a2, a3, result, *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 8) + 40), *(unsigned __int8 *)(a1 + 105), &v20);
      if (result)
      {
        v14 = result;
        if (!objc_msgSend(*(id *)(a1 + 56), "objectForKeyedSubscript:", objc_msgSend(result[5], "uuid")))
          objc_msgSend(*(id *)(a1 + 56), "setObject:forKeyedSubscript:", v14[5], objc_msgSend(v14[5], "uuid"));
        if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 80) + 8) + 24))
          objc_msgSend(*(id *)(a1 + 64), "addObject:", objc_msgSend(v14[5], "uuid"));
        v15 = objc_msgSend(*(id *)(a1 + 72), "objectForKeyedSubscript:", objc_msgSend(v14[5], "uuid"));
        if (!v15)
        {
          v15 = +[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary");
          objc_msgSend(*(id *)(a1 + 72), "setObject:forKeyedSubscript:", v15, objc_msgSend(v14[5], "uuid"));
        }
        v16 = (NSNull *)v14[6];
        if (!v16)
          v16 = +[NSNull null](NSNull, "null");
        v17 = objc_msgSend(v15, "objectForKeyedSubscript:", v16);
        if (!v17)
        {
          v17 = +[NSMutableSet set](NSMutableSet, "set");
          v18 = (NSNull *)v14[6];
          if (!v18)
            v18 = +[NSNull null](NSNull, "null");
          objc_msgSend(v15, "setObject:forKeyedSubscript:", v17, v18);
        }
        v19 = v20;
        objc_msgSend(v17, "addObject:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v20));
        return (id *)objc_msgSend(v17, "addObject:", +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", v19 - 1));
      }
    }
  }
  return result;
}

int *sub_100081C18(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5;
  int *result;
  id v7;
  int v8;
  NSObject *v9;
  id v10;
  id v11;
  BOOL v12;
  int v13;
  id v14;
  id v15;
  const __CFString *v16;
  const __CFString *v17;
  const char *CStringPtr;
  char *v19;
  char *v20;
  NSObject *v21;
  FILE *v22;
  FILE *v23;
  _QWORD v24[5];
  uint8_t buf[4];
  id v26;
  __int16 v27;
  id v28;

  if (objc_msgSend(*(id *)(a1 + 32), "containsObject:", objc_msgSend(a3, "uuid")))
    v5 = 636;
  else
    v5 = 628;
  result = (int *)objc_msgSend(a3, "cacheSymbolOwnerWithOptions:pid:", v5, 0xFFFFFFFFLL);
  if ((result & 1) != 0)
  {
    v7 = objc_msgSend(*(id *)(a1 + 40), "objectForKeyedSubscript:", objc_msgSend(a3, "uuid"));
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_100081F40;
    v24[3] = &unk_1000DDDA8;
    v24[4] = a3;
    objc_msgSend(v7, "enumerateKeysAndObjectsUsingBlock:", v24);
    objc_msgSend(a3, "symbolicateAllInstructionsWithOptions:pid:", 628, 0xFFFFFFFFLL);
    return (int *)objc_msgSend(a3, "clearCoreSymbolicationCache");
  }
  else
  {
    if (byte_1000EBD38)
    {
      v8 = *__error();
      v9 = sub_100030318();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
      {
        v10 = objc_msgSend(a3, "uuid");
        v11 = objc_msgSend(a3, "path");
        if (!v11)
          v11 = objc_msgSend(a3, "name");
        *(_DWORD *)buf = 138412546;
        v26 = v10;
        v27 = 2112;
        v28 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_INFO, "Parsing spindump text: Unable to find symbol owner for %@ %@", buf, 0x16u);
      }
      result = __error();
      *result = v8;
    }
    if (byte_1000EBD39)
      v12 = dword_1000EB4E8 <= 1;
    else
      v12 = 0;
    if (v12)
    {
      v13 = *__error();
      v14 = objc_msgSend(a3, "uuid");
      v15 = objc_msgSend(a3, "path");
      if (!v15)
        v15 = objc_msgSend(a3, "name");
      v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: Unable to find symbol owner for %@ %@"), v14, v15);
      if (v16)
      {
        v17 = v16;
        CStringPtr = CFStringGetCStringPtr(v16, 0x8000100u);
        if (CStringPtr)
        {
          v19 = (char *)CStringPtr;
          v20 = 0;
        }
        else
        {
          v19 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x2EC80C27uLL);
          CFStringGetCString(v17, v19, 1024, 0x8000100u);
          v20 = v19;
        }
        if (qword_1000EBD40)
          v23 = (FILE *)qword_1000EBD40;
        else
          v23 = __stderrp;
        fprintf(v23, "%s\n", v19);
        if (v20)
          free(v20);
        CFRelease(v17);
      }
      else
      {
        v21 = sub_100030318();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
          sub_100098954(a3, v21);
        if (qword_1000EBD40)
          v22 = (FILE *)qword_1000EBD40;
        else
          v22 = __stderrp;
        fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
      }
      result = __error();
      *result = v13;
    }
  }
  return result;
}

int *sub_100081F40(uint64_t a1, NSNull *a2, void *a3)
{
  id *v6;
  void *v7;
  int *result;
  int *v9;
  int *v10;
  uint64_t v11;
  int *v12;
  int *v13;
  uint64_t v14;
  int *v15;
  int v16;
  NSObject *v17;
  BOOL v18;
  int v19;
  const __CFString *v20;
  const __CFString *v21;
  const char *CStringPtr;
  char *v23;
  char *v24;
  NSObject *v25;
  FILE *v26;
  FILE *v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _BYTE v36[128];
  _BYTE v37[128];

  if (+[NSNull null](NSNull, "null") == a2)
  {
    v30 = 0u;
    v31 = 0u;
    v28 = 0u;
    v29 = 0u;
    result = (int *)objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v28, v36, 16);
    if (result)
    {
      v13 = result;
      v14 = *(_QWORD *)v29;
      do
      {
        v15 = 0;
        do
        {
          if (*(_QWORD *)v29 != v14)
            objc_enumerationMutation(a3);
          objc_msgSend(*(id *)(a1 + 32), "instructionAtOffsetIntoBinary:", objc_msgSend(*(id *)(*((_QWORD *)&v28 + 1) + 8 * (_QWORD)v15), "unsignedLongLongValue"));
          v15 = (int *)((char *)v15 + 1);
        }
        while (v13 != v15);
        result = (int *)objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v28, v36, 16);
        v13 = result;
      }
      while (result);
    }
  }
  else
  {
    v7 = *(void **)(a1 + 32);
    v6 = (id *)(a1 + 32);
    result = (int *)objc_msgSend(v7, "segmentWithName:", a2);
    if (result)
    {
      v9 = result;
      v34 = 0u;
      v35 = 0u;
      v32 = 0u;
      v33 = 0u;
      result = (int *)objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v32, v37, 16);
      if (result)
      {
        v10 = result;
        v11 = *(_QWORD *)v33;
        do
        {
          v12 = 0;
          do
          {
            if (*(_QWORD *)v33 != v11)
              objc_enumerationMutation(a3);
            objc_msgSend(v9, "instructionAtOffsetIntoSegment:", objc_msgSend(*(id *)(*((_QWORD *)&v32 + 1) + 8 * (_QWORD)v12), "unsignedLongLongValue"));
            v12 = (int *)((char *)v12 + 1);
          }
          while (v10 != v12);
          result = (int *)objc_msgSend(a3, "countByEnumeratingWithState:objects:count:", &v32, v37, 16);
          v10 = result;
        }
        while (result);
      }
    }
    else
    {
      if (byte_1000EBD38)
      {
        v16 = *__error();
        v17 = sub_100030318();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_100098A8C((uint64_t)a2, v6);
        result = __error();
        *result = v16;
      }
      if (byte_1000EBD39)
        v18 = dword_1000EB4E8 <= 3;
      else
        v18 = 0;
      if (v18)
      {
        v19 = *__error();
        v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Parsing spindump text: Unable to find segment %@ in %@ %@"), a2, objc_msgSend(*v6, "uuid"), objc_msgSend(*v6, "name"));
        if (v20)
        {
          v21 = v20;
          CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
          if (CStringPtr)
          {
            v23 = (char *)CStringPtr;
            v24 = 0;
          }
          else
          {
            v23 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0xCE4B975BuLL);
            CFStringGetCString(v21, v23, 1024, 0x8000100u);
            v24 = v23;
          }
          if (qword_1000EBD40)
            v27 = (FILE *)qword_1000EBD40;
          else
            v27 = __stderrp;
          fprintf(v27, "%s\n", v23);
          if (v24)
            free(v24);
          CFRelease(v21);
        }
        else
        {
          v25 = sub_100030318();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_FAULT))
            sub_100098A0C((uint64_t)a2, v6, v25);
          if (qword_1000EBD40)
            v26 = (FILE *)qword_1000EBD40;
          else
            v26 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v26);
        }
        result = __error();
        *result = v19;
      }
    }
  }
  return result;
}

id sub_1000822B0(void *a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  void *v12;
  id v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  id v17;
  id v18;
  id v19;
  id v20;
  uint64_t v21;
  id v22;
  id v23;
  uint64_t v24;
  id v25;
  uint64_t v26;
  NSString *v27;
  NSString *v28;
  id v29;
  id v30;
  void *v32;
  id v33;
  id v34;
  void *v35;
  NSString *v36;
  id v37;
  unsigned __int8 v38;
  uint64_t v39;
  _QWORD v40[8];
  char v41;
  _QWORD v42[10];

  v12 = objc_autoreleasePoolPush();
  v13 = objc_msgSend(a2, "rangeWithName:", CFSTR("fakeFrameInfo"));
  if (v13 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v18 = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", objc_msgSend(a1, "substringWithRange:", v13, v14), 0);
LABEL_21:
    v30 = v18;
    goto LABEL_22;
  }
  v15 = objc_msgSend(a2, "rangeWithName:", CFSTR("symbolName"));
  if (v15 == (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v17 = 0;
  }
  else
  {
    v19 = objc_msgSend(a1, "substringWithRange:", v15, v16);
    if (objc_msgSend(v19, "isEqualToString:", CFSTR("???")))
      v17 = 0;
    else
      v17 = v19;
  }
  v20 = objc_msgSend(a2, "rangeWithName:", CFSTR("sourceFilepath"));
  if (v20 == (id)0x7FFFFFFFFFFFFFFFLL)
    v22 = 0;
  else
    v22 = objc_msgSend(a1, "substringWithRange:", v20, v21);
  v23 = objc_msgSend(a2, "rangeWithName:", CFSTR("binaryName"));
  if (v23 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v28 = (NSString *)objc_msgSend(a1, "substringWithRange:", v23, v24);
LABEL_16:
    v27 = v28;
    goto LABEL_17;
  }
  v25 = objc_msgSend(a2, "rangeWithName:", CFSTR("binaryUuid"));
  if (v25 != (id)0x7FFFFFFFFFFFFFFFLL)
  {
    v28 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("<%@>"), objc_msgSend(a1, "substringWithRange:", v25, v26));
    goto LABEL_16;
  }
  v27 = 0;
LABEL_17:
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472;
  v42[2] = sub_10008267C;
  v42[3] = &unk_1000DDDF8;
  v42[4] = a2;
  v42[5] = a1;
  v42[6] = v17;
  v42[7] = v22;
  v42[8] = v27;
  if (a6 || a4 == 0x7FFFFFFFFFFFFFFFLL)
    goto LABEL_19;
  if (!a3 || (v32 = *(void **)(a3 + 40)) == 0)
  {
    v29 = objc_alloc((Class)NSArray);
    if (v27)
      goto LABEL_20;
LABEL_36:
    v37 = +[NSMutableString string](NSMutableString, "string");
    objc_msgSend(v37, "appendString:", CFSTR("???"));
    v18 = objc_msgSend(v29, "initWithObjects:", v37, 0);
    goto LABEL_21;
  }
  if (*(_QWORD *)(a3 + 48))
  {
    v33 = objc_msgSend(*(id *)(a3 + 40), "segmentWithName:");
    if (!v33)
    {
LABEL_19:
      v29 = objc_alloc((Class)NSArray);
LABEL_20:
      v18 = objc_msgSend(v29, "initWithObjects:", sub_10008267C((uint64_t)v42), 0);
      goto LABEL_21;
    }
    v34 = objc_msgSend(v33, "instructionAtOffsetIntoSegment:", a4 - a5);
  }
  else
  {
    v34 = objc_msgSend(*(id *)(a3 + 40), "instructionAtOffsetIntoBinary:", a4 - a5);
  }
  v35 = v34;
  if (!v34)
  {
    v29 = objc_alloc((Class)NSArray);
    goto LABEL_36;
  }
  if ((unint64_t)objc_msgSend(v34, "numSymbols") <= 1)
  {
    if (v22)
      goto LABEL_19;
    v38 = objc_msgSend(v35, "hasSourceInfo");
    if (v17)
    {
      if ((v38 & 1) == 0)
        goto LABEL_19;
    }
  }
  if (objc_msgSend(v32, "name"))
    v36 = (NSString *)objc_msgSend(v32, "name");
  else
    v36 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("<%@>"), objc_msgSend(objc_msgSend(v32, "uuid"), "UUIDString"));
  v39 = (uint64_t)v36;
  v30 = objc_alloc_init((Class)NSMutableArray);
  v40[0] = _NSConcreteStackBlock;
  v40[1] = 3221225472;
  v40[2] = sub_100082910;
  v40[3] = &unk_1000DDE20;
  v41 = a5;
  v40[4] = v35;
  v40[5] = v39;
  v40[6] = v30;
  v40[7] = a4;
  objc_msgSend(v35, "enumerateSymbols:", v40);
  if (!objc_msgSend(v30, "count"))
  {

    v18 = objc_msgSend(objc_alloc((Class)NSArray), "initWithObjects:", sub_1000827B8(0, -1, 0, 0, 0, v39, a4), 0);
    goto LABEL_21;
  }
LABEL_22:
  objc_autoreleasePoolPop(v12);
  return v30;
}

void *sub_10008267C(uint64_t a1)
{
  id v2;
  uint64_t v3;
  unint64_t v4;
  id v5;
  uint64_t v6;
  unint64_t v7;
  id v8;
  uint64_t v9;
  unint64_t v10;
  id v11;
  uint64_t v12;
  unint64_t v13;

  v2 = objc_msgSend(*(id *)(a1 + 32), "rangeWithName:", CFSTR("offsetIntoSymbol"));
  if (v2 == (id)0x7FFFFFFFFFFFFFFFLL
    && (v2 = objc_msgSend(*(id *)(a1 + 32), "rangeWithName:", CFSTR("offsetIntoUnknownSymbol")),
        v2 == (id)0x7FFFFFFFFFFFFFFFLL))
  {
    v4 = -1;
  }
  else
  {
    v4 = sub_10007F0B0(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v2, v3));
  }
  v5 = objc_msgSend(*(id *)(a1 + 32), "rangeWithName:", CFSTR("sourceLineNumber"));
  if (v5 == (id)0x7FFFFFFFFFFFFFFFLL)
    v7 = 0;
  else
    v7 = sub_10007F0B0(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v5, v6));
  v8 = objc_msgSend(*(id *)(a1 + 32), "rangeWithName:", CFSTR("sourceColumnNumber"));
  if (v8 == (id)0x7FFFFFFFFFFFFFFFLL)
    v10 = 0;
  else
    v10 = sub_10007F0B0(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v8, v9));
  v11 = objc_msgSend(*(id *)(a1 + 32), "rangeWithName:", CFSTR("offsetIntoBinary"));
  if (v11 == (id)0x7FFFFFFFFFFFFFFFLL)
    v13 = -1;
  else
    v13 = sub_10007F0B0(objc_msgSend(*(id *)(a1 + 40), "substringWithRange:", v11, v12));
  return sub_1000827B8(*(_QWORD *)(a1 + 48), v4, *(_QWORD *)(a1 + 56), v7, v10, *(_QWORD *)(a1 + 64), v13);
}

void *sub_1000827B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  id v14;
  void *v15;

  v14 = +[NSMutableString string](NSMutableString, "string");
  v15 = v14;
  if (!a1)
  {
    objc_msgSend(v14, "appendString:", CFSTR("???"));
    if (!a6)
      return v15;
    goto LABEL_7;
  }
  objc_msgSend(v14, "appendString:", a1);
  if (a2 != -1)
    objc_msgSend(v15, "appendFormat:", CFSTR(" + %llu"), a2);
  if (a6)
  {
LABEL_7:
    objc_msgSend(v15, "appendString:", CFSTR(" ("));
    if (a3)
    {
      objc_msgSend(v15, "appendString:", a3);
      if ((int)a4 >= 1)
      {
        objc_msgSend(v15, "appendFormat:", CFSTR(":%u"), a4);
        if ((int)a5 >= 1)
          objc_msgSend(v15, "appendFormat:", CFSTR(",%u"), a5);
      }
      objc_msgSend(v15, "appendString:", CFSTR(" in "));
    }
    objc_msgSend(v15, "appendFormat:", CFSTR("%@"), a6);
    if (a7 != -1)
      objc_msgSend(v15, "appendFormat:", CFSTR(" + %llu"), a7);
    objc_msgSend(v15, "appendString:", CFSTR(")"));
  }
  return v15;
}

id sub_100082910(uint64_t a1, void *a2, void *a3)
{
  return objc_msgSend(*(id *)(a1 + 48), "addObject:", sub_1000827B8((uint64_t)objc_msgSend(a2, "name"), (_BYTE *)objc_msgSend(*(id *)(a1 + 32), "offsetIntoSegment")- (_BYTE *)objc_msgSend(a2, "offsetIntoSegment")+ *(unsigned __int8 *)(a1 + 64), (uint64_t)objc_msgSend(a3, "fileName"), (uint64_t)objc_msgSend(a3, "lineNum"), (uint64_t)objc_msgSend(a3, "columnNum"), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 56)));
}

unint64_t sub_1000829B8(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id v8;
  void *v9;
  unint64_t result;
  BOOL v11;
  _BYTE *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;

  v8 = objc_msgSend(*(id *)(a1 + 32), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
  if (v8)
  {
    v9 = v8;
    *a4 = 1;
    result = sub_10007D560(a2, v8, *(unsigned __int8 *)(a1 + 116), *(_DWORD *)(a1 + 104), *(_DWORD *)(a1 + 108));
    v11 = 0;
    if ((int)result > *(_DWORD *)(a1 + 112))
    {
      if (*(_BYTE *)(a1 + 117)
        || (result = (unint64_t)objc_msgSend(v9, "rangeWithName:", CFSTR("kernelDot")),
            result == 0x7FFFFFFFFFFFFFFFLL))
      {
        v11 = 1;
      }
    }
    v12 = *(_BYTE **)(a1 + 80);
    **(_BYTE **)(a1 + 72) = v11;
    if (!*v12)
    {
      v13 = *(_QWORD *)(a1 + 48);
      if (v13)
      {
        if (*(_QWORD *)(v13 + 40))
        {
          if (*(_QWORD *)(a1 + 88) != -1)
          {
            v17 = -1;
            result = (unint64_t)sub_10007D5F4(a2, a3, v9, *(void **)(a1 + 56), *(unsigned __int8 *)(a1 + 116), &v17);
            if (*(_QWORD *)(a1 + 48) == result && v17 == *(_QWORD *)(a1 + 88))
            {
              result = (unint64_t)objc_msgSend(v9, "rangeWithName:", CFSTR("symbolName"));
              v15 = *(_QWORD *)(a1 + 64);
              if (result == 0x7FFFFFFFFFFFFFFFLL)
              {
                if (v15)
                {
LABEL_23:
                  **(_BYTE **)(a1 + 80) = 1;
                  return result;
                }
              }
              else
              {
                if (!v15)
                  goto LABEL_23;
                result = (unint64_t)objc_msgSend(*(id *)(a1 + 64), "isEqual:", objc_msgSend(a2, "substringWithRange:", result, v14));
                if ((result & 1) == 0)
                  goto LABEL_23;
              }
              result = (unint64_t)objc_msgSend(v9, "rangeWithName:", CFSTR("offsetIntoSymbol"));
              if (result != 0x7FFFFFFFFFFFFFFFLL)
              {
                result = sub_10007F0B0(objc_msgSend(a2, "substringWithRange:", result, v16));
                if (result != *(_QWORD *)(a1 + 96))
                  goto LABEL_23;
              }
            }
          }
        }
      }
    }
  }
  else
  {
    result = (unint64_t)objc_msgSend(*(id *)(a1 + 40), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
    if (!result)
      *a4 = 1;
  }
  return result;
}

id sub_100082BB4(uint64_t a1, void *a2, uint64_t a3, _BYTE *a4)
{
  id result;
  void *v9;
  int v10;
  int v11;
  int *v12;
  int v13;
  BOOL v14;
  int v15;
  int v16;
  NSObject *v17;
  BOOL v18;
  int v19;
  const __CFString *v20;
  NSObject *v21;
  FILE *v22;
  const __CFString *v23;
  const char *CStringPtr;
  char *v25;
  char *v26;
  FILE *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  result = objc_msgSend(*(id *)(a1 + 32), "firstMatchInString:options:range:", a2, 0, 0, objc_msgSend(a2, "length"));
  if (result)
  {
    v9 = result;
    **(_BYTE **)(a1 + 40) = objc_msgSend(result, "rangeWithName:", CFSTR("startIndex")) == (id)0x7FFFFFFFFFFFFFFFLL;
    result = objc_msgSend(v9, "rangeWithName:", CFSTR("indentWhitespace"));
    if (result == (id)0x7FFFFFFFFFFFFFFFLL)
      v11 = -1;
    else
      v11 = v10;
    if (v11 < 0)
    {
      if (byte_1000EBD38)
      {
        v16 = *__error();
        v17 = sub_100030318();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          sub_100098B78();
        *__error() = v16;
      }
      if (byte_1000EBD39)
        v18 = dword_1000EB4E8 <= 3;
      else
        v18 = 0;
      if (v18)
      {
        v19 = *__error();
        v20 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: frame match with no whitespace indent (%d: %s)"), "whitespaceLength >= 0", a3, objc_msgSend(a2, "UTF8String"));
        if (v20)
        {
          v23 = v20;
          CStringPtr = CFStringGetCStringPtr(v20, 0x8000100u);
          if (CStringPtr)
          {
            v25 = (char *)CStringPtr;
            v26 = 0;
          }
          else
          {
            v25 = (char *)malloc_type_calloc(0x400uLL, 1uLL, 0x6E2BE878uLL);
            CFStringGetCString(v23, v25, 1024, 0x8000100u);
            v26 = v25;
          }
          if (qword_1000EBD40)
            v27 = (FILE *)qword_1000EBD40;
          else
            v27 = __stderrp;
          fprintf(v27, "%s\n", v25);
          if (v26)
            free(v26);
          CFRelease(v23);
        }
        else
        {
          v21 = sub_100030318();
          if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
            sub_100098B04();
          if (qword_1000EBD40)
            v22 = (FILE *)qword_1000EBD40;
          else
            v22 = __stderrp;
          fwrite("UNABLE TO FORMAT STRING\n", 0x18uLL, 1uLL, v22);
        }
        *__error() = v19;
      }
      objc_msgSend(a2, "UTF8String");
      sub_1000301F0("LookaheadForIndentStyleAndHeavyMode_block_invoke", "SPTextualReportParser.m", 1738, "%s: frame match with no whitespace indent (%d: %s)", v28, v29, v30, v31, (char)"whitespaceLength >= 0");
      abort();
    }
    v12 = *(int **)(a1 + 48);
    v13 = *v12;
    if (*v12 == -1)
    {
      *v12 = v11;
    }
    else
    {
      v14 = __OFSUB__(v11, v13);
      v15 = v11 - v13;
      if (!((v15 < 0) ^ v14 | (v15 == 0)))
      {
        **(_DWORD **)(a1 + 56) = v15;
        *a4 = 1;
      }
    }
  }
  return result;
}

uint64_t sub_100082E90@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  *(_QWORD *)(a2 + 4) = a3;
  *(_WORD *)(a2 + 12) = 2080;
  *(_QWORD *)(a2 + 14) = result;
  return result;
}

void sub_100082EA4(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(v1 - 8) = a1;
}

id sub_100082EB8@<X0>(void *a1@<X0>, uint64_t x8_0@<X8>)
{
  uint64_t v3;

  *(_QWORD *)(v3 - 24) = x8_0;
  return objc_msgSend(a1, "UTF8String");
}

void sub_100082ED8(void *a1, int a2, os_log_t log, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, a5, 0x16u);
}

void sub_100082F08(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x20u);
}

uint64_t sub_100082F30(uint64_t result, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  *(_QWORD *)(a2 + 4) = v3;
  *(_WORD *)(a2 + 12) = 2080;
  *(_QWORD *)(a2 + 14) = a3;
  *(_WORD *)(a2 + 22) = 2080;
  *(_QWORD *)(a2 + 24) = result;
  return result;
}

id sub_100082F4C()
{
  void *v0;

  return objc_msgSend(v0, "debugDescription");
}

id sub_100082F58(uint64_t a1, id *a2)
{
  return objc_msgSend(*a2, "uuid");
}

id sub_100082F64()
{
  id *v0;

  return objc_msgSend(*v0, "name");
}

void sub_100082F70()
{
  perror("sysctl KERN_MAXPROC");
  dword_1000EB548 = 1064;
}

void sub_100082F98(uint64_t a1, NSObject *a2)
{
  int v2;
  uint64_t v3;

  v2 = 136315138;
  v3 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: %s", (uint8_t *)&v2, 0xCu);
  sub_1000301E8();
}

void sub_100083008(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Found pid [%d]", (uint8_t *)v2, 8u);
}

void sub_10008307C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Found pid [%d]", (uint8_t *)v2, 8u);
}

void sub_1000830F0()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000301D0();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Found pid %s [%d]", v1, 0x12u);
  sub_1000301E8();
}

void sub_100083164()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000301D0();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Found pid %s [%d]", v1, 0x12u);
  sub_1000301E8();
}

void sub_1000831D8()
{
  uint64_t v0;

  v0 = _os_assert_log(0);
  _os_crash(v0);
  __break(1u);
}

void sub_1000831F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: No thread nor dispatch queue", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100083260(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: No thread nor dispatch queue", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000832D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: WorkflowResponsivness unavailable, not generating spindump report(s) for %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083330()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D978();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "WR: WorkflowResponsivness unavailable, not generating spindump report(s) for %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083394()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: Unable to decode workflow event tracker: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000833F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "WR: Unable to decode workflow event tracker: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083454()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: No workflow event start", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000834B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "WR: %@: No workflow event start", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083514()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: No workflow event end", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083574()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "WR: %@: No workflow event end", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000835D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: submitted tailspin to Diagnostic Pipeline", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083634()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D96C();
  sub_10003D930(v0, v1, v2, 5.778e-34);
  sub_10003D948((void *)&_mh_execute_header, v5, v3, "Unable to format: WR: %@: error trying to provide tailspin to Diagnostic Pipeline: %@", v4);
}

void sub_10008366C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D96C();
  sub_10003D930(v0, v1, v2, 5.778e-34);
  sub_10003D960((void *)&_mh_execute_header, v5, v3, "WR: %@: error trying to provide tailspin to Diagnostic Pipeline: %@", v4);
}

void sub_1000836A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: submitting tailspin to Diagnostic Pipeline", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083704()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "WR: %@: submitting tailspin to Diagnostic Pipeline", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083764()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: DRShouldGatherLog return false, not submitting tailspin", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000837C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "WR: %@: DRShouldGatherLog return false, not submitting tailspin", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083824()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D96C();
  sub_10003D930(v0, v1, v2, 5.778e-34);
  sub_10003D948((void *)&_mh_execute_header, v5, v3, "Unable to format: WR: %@: error in DRShouldGatherLog call: %@", v4);
}

void sub_10008385C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D96C();
  sub_10003D930(v0, v1, v2, 5.778e-34);
  sub_10003D960((void *)&_mh_execute_header, v5, v3, "WR: %@: error in DRShouldGatherLog call: %@", v4);
}

void sub_100083894()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: no spindump reports to generate", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000838F4(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(_QWORD *)(a1 + 4) = a2;
  sub_10003D8F4((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unable to format: WR: have %lu reports, but no sampleStore", (uint8_t *)a1);
}

void sub_100083930(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a1 = 134217984;
  *(_QWORD *)(a1 + 4) = a2;
  sub_10003D8F4((void *)&_mh_execute_header, a3, (uint64_t)a3, "WR: have %lu reports, but no sampleStore", (uint8_t *)a1);
}

void sub_10008396C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D96C();
  sub_10003D930(v0, v1, v2, 5.778e-34);
  sub_10003D948((void *)&_mh_execute_header, v5, v3, "Unable to format: WR: %@: Unable to compare timesamps with tailspin data (%@)", v4);
}

void sub_1000839A4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint8_t *v3;
  NSObject *v4;

  sub_10003D96C();
  *(_DWORD *)v0 = 138412546;
  *(_QWORD *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2114;
  *(_QWORD *)(v0 + 14) = v2;
  sub_10003D960((void *)&_mh_execute_header, v4, v0, "WR: %@: Unable to compare timesamps with tailspin data (%{public}@)", v3);
}

void sub_1000839EC(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Sample store contains no samples for the signpost interval, not generating spindump report", buf, 2u);
}

void sub_100083A28(uint8_t *buf, _BYTE *a2, os_log_t log)
{
  *buf = 0;
  *a2 = 0;
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "Sample store contains no samples for the signpost interval, not generating spindump report", buf, 2u);
}

void sub_100083A64()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  sub_10003D910(v0, v1, v2, 4.8152e-34);
  *(_QWORD *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003D9C4((void *)&_mh_execute_header, "Unable to format: %s [%d]: %s: Unable to set target dispatch queue", v4, v5);
}

void sub_100083AA4()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  sub_10003D910(v0, v1, v2, 4.8152e-34);
  *(_QWORD *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003D9D4((void *)&_mh_execute_header, "%s [%d]: %s: Unable to set target dispatch queue", v4, v5);
}

void sub_100083AE4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: Unable to set target dispatch queue", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100083B54(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: Unable to set target dispatch queue", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100083BC4()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  sub_10003D910(v0, v1, v2, 4.8152e-34);
  *(_QWORD *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003D9C4((void *)&_mh_execute_header, "Unable to format: %s [%d]: %s: Unable to set target thread", v4, v5);
}

void sub_100083C04()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  sub_10003D910(v0, v1, v2, 4.8152e-34);
  *(_QWORD *)(v3 + 20) = "sampleStore.targetDispatchQueueId == report.dispatchQueue.identifier";
  sub_10003D9D4((void *)&_mh_execute_header, "%s [%d]: %s: Unable to set target thread", v4, v5);
}

void sub_100083C44(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: Unable to set target thread", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100083CB4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: Unable to set target thread", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100083D24()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint8_t *v3;
  NSObject *v4;

  sub_10003D984();
  *(_DWORD *)v0 = 138412546;
  *(_QWORD *)(v0 + 4) = v1;
  *(_WORD *)(v0 + 12) = 2048;
  *(_QWORD *)(v0 + 14) = v2;
  sub_10003D948((void *)&_mh_execute_header, v4, v2, "Unable to format: WR: %@: generating %lu spindump reports", v3);
}

void sub_100083D6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to encode workflow event tracked into a string: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083DCC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to encode workflow event tracked into a string: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100083E2C()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_10003D9A0();
  sub_10003D948((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: WR: %@: Workflow event has error %@, still considering for diagnostics", v1);
  sub_1000301E8();
}

void sub_100083E94()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_10003D9A0();
  sub_10003D948((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: WR: %@: Workflow event has error %@, not considering for diagnostics", v1);
  sub_1000301E8();
}

void sub_100083EFC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D9E4();
  sub_10003D948((void *)&_mh_execute_header, v0, v1, "Unable to format: WR: %@: Workflow event has invalid duration %.3f", v2);
  sub_1000301E8();
}

void sub_100083F60()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D9E4();
  sub_10003D960((void *)&_mh_execute_header, v0, v1, "WR: %@: Workflow event has invalid duration %.3f", v2);
  sub_1000301E8();
}

void sub_100083FC4()
{
  uint64_t v0;
  NSObject *v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_10003D954();
  v3 = 2080;
  v4 = v0;
  sub_10003D948((void *)&_mh_execute_header, v1, (uint64_t)v1, "Unable to format: WR: %@: Received tailspin path %s", v2);
  sub_1000301E8();
}

void sub_10008403C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: TidToPidDictPromise called with no sample store", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000840AC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: TidToPidDictPromise called with no sample store", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008411C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to get dirname of %s", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100084188()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to get dirname of %s", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000841F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to get dirname of %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100084254()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to get dirname of %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000842B4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to get basename of %s", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100084320()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to get basename of %s", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008438C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to get basename of %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000843EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to get basename of %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008444C()
{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  const char *v3;

  sub_100048140();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: NULL realDir (dir %s from %s)", v2, v3);
  sub_1000301E8();
}

void sub_1000844AC()
{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  const char *v3;

  sub_100048140();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "NULL realDir (dir %s from %s)", v2, v3);
  sub_1000301E8();
}

void sub_10008450C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_1000480F0(v0, __stack_chk_guard);
  sub_100047EF4();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
  sub_100047FE4();
}

void sub_100084584()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_1000480F0(v0, __stack_chk_guard);
  sub_100047EF4();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
  sub_100047FE4();
}

void sub_1000845FC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008466C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: NULL expectedRealDir (from /var/mobile/Library/Logs/CrashReporter)", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000846DC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_1000480F0(v0, __stack_chk_guard);
  sub_100047EF4();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
  sub_100047FE4();
}

void sub_100084754()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_1000480F0(v0, __stack_chk_guard);
  sub_100047EF4();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", v3, v4, v5, v6, v7);
  sub_100047FE4();
}

void sub_1000847CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008483C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: expectedRealDir of / (from /var/mobile/Library/Logs/CrashReporter)", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000848AC()
{
  NSObject *v0;
  int v1;
  int *v2;
  uint8_t v3[40];

  sub_100047E28();
  sub_100047E54(v1);
  __error();
  v2 = __error();
  sub_100047F14(v2);
  sub_100047FB8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: generate spindump: unable to sample process: %d (%s)", v3, 0x22u);
  sub_100047C98();
}

void sub_10008493C()
{
  NSObject *v0;
  int v1;
  int *v2;
  uint8_t v3[40];

  sub_100047E28();
  sub_100047E54(v1);
  __error();
  v2 = __error();
  sub_100047F14(v2);
  sub_100047FB8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s [%d]: generate spindump: unable to sample process: %d (%s)", v3, 0x22u);
  sub_100047C98();
}

void sub_1000849CC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: unable to sample process: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100084A3C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "generate spindump: unable to sample process: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100084AAC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: generate spindump: filepath %s too large", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100084B18()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: generate spindump: filepath %s too large", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100084B84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: generate spindump: filepath %s too large", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100084BE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "generate spindump: filepath %s too large", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100084C44()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100084CB0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100084D1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100084D7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "generate spindump: filepath %s not in /var/mobile/Library/Logs/CrashReporter", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

#error "100084E2C: call analysis failed (funcsize=28)"

#error "100084EA4: call analysis failed (funcsize=28)"

void sub_100084ECC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: unable to open %s for writing: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100084F40()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "generate spindump: unable to open %s for writing: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

#error "100085004: call analysis failed (funcsize=28)"

#error "10008507C: call analysis failed (funcsize=28)"

void sub_1000850A4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: unable to fdopen %s for writing: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100085118()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "generate spindump: unable to fdopen %s for writing: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008518C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047FF8(v0);
  sub_10003D954();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: generate spindump: saved report (requested by %s [%d]) to %s", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008521C(int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100047FF8(a1);
  sub_1000480D0();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: generate spindump: done monitoring due to %s", v3, v4, v5, v6, 2u);
  sub_100047C98();
}

void sub_1000852B4(int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100047FF8(a1);
  sub_1000480D0();
  sub_100048128();
  sub_100047F1C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: generate spindump: done monitoring due to %{public}s", v3, v4, v5, v6, 2u);
  sub_100047C98();
}

void sub_10008533C(unsigned __int8 a1, NSObject *a2)
{
  uint8_t v3[24];

  sub_100048158(a1);
  sub_10003D954();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: generate spindump: done monitoring due to %s", v3, 0xCu);
  sub_100047D94();
}

void sub_1000853B4(unsigned __int8 a1, NSObject *a2)
{
  uint8_t v3[24];

  sub_100048158(a1);
  sub_10003D954();
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "generate spindump: done monitoring due to %{public}s", v3, 0xCu);
  sub_100047D94();
}

void sub_10008542C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: done reporting (%#llx)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100085498()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047F1C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: done reporting (%#llx)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

#error "100085568: call analysis failed (funcsize=33)"

#error "1000855F4: call analysis failed (funcsize=33)"

void sub_10008561C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: done reporting (%#llx)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008567C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "cpu resource: done reporting (%#llx)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000856DC()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100047E70((void *)&_mh_execute_header, v2, v3, "Unable to format: cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_100085760()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100048020((void *)&_mh_execute_header, v2, v3, "cpu resource: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

#error "100085848: call analysis failed (funcsize=33)"

void sub_100085870()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100047E70((void *)&_mh_execute_header, v2, v3, "Unable to format: cpu resource: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

#error "100085958: call analysis failed (funcsize=33)"

#error "1000859E4: call analysis failed (funcsize=33)"

void sub_100085A0C()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100047E70((void *)&_mh_execute_header, v2, v3, "Unable to format: cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_100085A90()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100048084((void *)&_mh_execute_header, v2, v3, "cpu resource: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_100085B14()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: deferring report generation due to game mode", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100085B7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: deferring report generation due to game mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100085BA8()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100085C10()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100085C78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100085CA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "cpu resource: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100085CD0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100085D3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100085D9C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100085E04()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100085E6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100085E98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "cpu resource: not monitoring due to throttling the number of reports generated for 1st party processes", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100085EC4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: cpu resource: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100085F2C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: cpu resource: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100085F94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: cpu resource: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100085FC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "cpu resource: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100085FEC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E44(v0);
  sub_100047ED4();
  sub_1000480AC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to get suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
  sub_100047FA0();
}

void sub_100086058()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E44(v0);
  sub_100047ED4();
  sub_100048048((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to get suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
  sub_100047FA0();
}

void sub_1000860C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to get suspended state (%d), assuming not suspended", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100086124()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "Unable to get suspended state (%d), assuming not suspended", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100086184()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E44(v0);
  sub_100047ED4();
  sub_1000480AC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to inspect task for suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
  sub_100047FA0();
}

void sub_1000861F0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E44(v0);
  sub_100047ED4();
  sub_100048048((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to inspect task for suspended state (%d), assuming not suspended", v3, v4, v5, v6, v7);
  sub_100047FA0();
}

void sub_10008625C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to inspect task for suspended state (%d), assuming not suspended", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000862BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "Unable to inspect task for suspended state (%d), assuming not suspended", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008631C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D08();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: being debugged", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100086388()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100048128();
  sub_100047F1C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: %{public}s: being debugged", v3, v4, v5, v6, 2u);
  sub_100047C98();
}

void sub_100086400()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: being debugged", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100086460()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "%{public}s: being debugged", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000864C0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100047F44();
  sub_10003D948((void *)&_mh_execute_header, v0, v1, "Unable to format: Should restrict submission due to roll of %.4f (pref is %.4f)", v2);
  sub_1000301E8();
}

void sub_100086528()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047F44();
  sub_1000480F8((void *)&_mh_execute_header, v0, v1, "Should restrict submission due to roll of %.4f (pref is %.4f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008658C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_100047F44();
  sub_10003D948((void *)&_mh_execute_header, v0, v1, "Unable to format: Should not restrict submission due to roll of %.4f (pref is %.4f)", v2);
  sub_1000301E8();
}

void sub_1000865F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047F44();
  sub_1000480F8((void *)&_mh_execute_header, v0, v1, "Should not restrict submission due to roll of %.4f (pref is %.4f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100086658()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: done reporting (%#llx)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000866C4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047F1C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: done reporting (%#llx)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

#error "100086794: call analysis failed (funcsize=33)"

#error "100086820: call analysis failed (funcsize=33)"

void sub_100086848()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: done reporting (%#llx)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000868A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "disk writes: done reporting (%#llx)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100086908()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100047E70((void *)&_mh_execute_header, v2, v3, "Unable to format: disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10008698C()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100048020((void *)&_mh_execute_header, v2, v3, "disk writes: all microstackshots without errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

#error "100086A74: call analysis failed (funcsize=33)"

void sub_100086A9C()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100047E70((void *)&_mh_execute_header, v2, v3, "Unable to format: disk writes: some microstackshots with errors: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

#error "100086B84: call analysis failed (funcsize=33)"

#error "100086C10: call analysis failed (funcsize=33)"

void sub_100086C38()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100047E70((void *)&_mh_execute_header, v2, v3, "Unable to format: disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_100086CBC()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  objc_msgSend(sub_100047FB0(v0, v1), "num_out_of_order");
  objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  sub_100047EC0();
  sub_100047D60();
  sub_100048084((void *)&_mh_execute_header, v2, v3, "disk writes: no microstackshots: %llu out-of-order microstackshots, %llu microstackshots missing load infos, %llu bytes invalid", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_100086D40()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100086DAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100086E0C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: not monitoring due to tasking-specified sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100086E74()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: not monitoring due to tasking-specified sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100086EDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: not monitoring due to tasking-specified sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100086F08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "disk writes: not monitoring due to tasking-specified sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100086F34()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: deferring report generation due to game mode", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100086F9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: deferring report generation due to game mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100086FC8()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100087030()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: cannot defer report generation for game mode", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100087098()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000870C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "disk writes: cannot defer report generation for game mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000870F0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: disk writes: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100087158()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: disk writes: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000871C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: disk writes: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000871EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "disk writes: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100087218()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: file descriptor exhaustion: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100087284()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000872E4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: file descriptor exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008734C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: file descriptor exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000873B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000873E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "file descriptor exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008740C()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_100047EA8();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: fatal, %llu fds with flags %#llx", v2, v3);
  sub_1000301E8();
}

void sub_10008746C()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_100047EA8();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: %llu fds with flags %#llx", v2, v3);
  sub_1000301E8();
}

void sub_1000874CC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: port exhaustion: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100087538()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100087598()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: port exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100087600()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: port exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100087668()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100087694()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "port exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000876C0()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_100047EA8();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: fatal, %llu ports with flags %#llx", v2, v3);
  sub_1000301E8();
}

void sub_100087720()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_100047EA8();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: %llu ports with flags %#llx", v2, v3);
  sub_1000301E8();
}

void sub_100087780()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: kqworkloop exhaustion: not monitoring due to conditions %#llx", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000877EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: not monitoring due to conditions %#llx", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008784C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000878B4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: kqworkloop exhaustion: not monitoring due to suppression cookie file", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008791C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100087948()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "kqworkloop exhaustion: not monitoring due to suppression cookie file", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100087974()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_100047EA8();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: fatal, %llu kqworkloops with flags %#llx", v2, v3);
  sub_1000301E8();
}

void sub_1000879D4()
{
  uint64_t v0;
  os_log_t v1;
  uint64_t v2;
  uint64_t v3;

  sub_100047EA8();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: %llu kqworkloops with flags %#llx", v2, v3);
  sub_1000301E8();
}

void sub_100087A34()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Spindump output doesn't contain output path: %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100087A94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Spindump output doesn't contain output path: %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100087AF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: No newline in spindump output: %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100087B54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "No newline in spindump output: %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100087BB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Spindump output file doesn't exist: %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100087C14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Spindump output file doesn't exist: %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100087C74()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: read from child returned error: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100087CE4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "read from child returned error: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100087D54(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: unable to allocate prefs dict", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100087DC4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: unable to allocate prefs dict", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100087E34(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: unable to allocate prefs", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100087EA4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: unable to allocate prefs", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100087F14()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;
  int v4;
  int v5;

  sub_100049868();
  sub_1000497B4();
  sub_100049754((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Don't throttle short spin reports:%d due to pref isset:%d value:%d", v2, v3, v4, v5);
  sub_1000497A0();
}

void sub_100087F84()
{
  unsigned int v0;
  int v1;
  NSObject *v2;
  _DWORD v3[2];
  __int16 v4;
  int v5;
  __int16 v6;
  int v7;

  sub_100049810(__stack_chk_guard);
  v3[0] = 67109632;
  v3[1] = v1;
  v4 = 1024;
  v5 = (v0 >> 11) & 1;
  v6 = 1024;
  v7 = ((unsigned __int16)word_1000EBD78 >> 12) & 1;
  sub_1000497F0((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: UID %d: Gather samples for service watchdog:%d due to submit:%d", (uint8_t *)v3);
  sub_1000301E8();
}

void sub_100088014()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;
  int v4;
  int v5;

  sub_100049810(__stack_chk_guard);
  sub_100049728();
  sub_1000497FC((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Gather samples for stuck apps:%d due to internal:%d submit:%d user requested:%d", 67110144, v2, v3, v4, v5);
  sub_1000497A0();
}

void sub_100088090()
{
  unsigned int v0;
  unsigned int v1;
  __int16 v2;
  uint64_t v3;
  os_log_t v4;
  int v5;
  int v6;
  int v7;

  sub_100049810(__stack_chk_guard);
  sub_100049868();
  LOWORD(v6) = 1024;
  HIWORD(v6) = v2;
  LOWORD(v7) = ((v1 >> 6) & 1) >> 16;
  sub_100049754((void *)&_mh_execute_header, v3, v4, "Unable to format: UID %d: Gather samples for spins:%d due to submit:%d user requested:%d", v5, v6, (v0 >> 5) & 1, v7);
  sub_1000497A0();
}

void sub_10008811C()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;
  int v4;
  int v5;

  sub_100049810(__stack_chk_guard);
  sub_100049728();
  sub_1000497FC((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Gather samples for hangs:%d due to present:%d submit:%d user requested:%d", 67110144, v2, v3, v4, v5);
  sub_1000497A0();
}

void sub_100088198()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100049810(__stack_chk_guard);
  sub_100049768();
  sub_1000497F0((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: UID %d: User requested spins:%d hangs:%d unavilable on this platform", v1);
  sub_1000301E8();
}

void sub_100088200()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100049810(__stack_chk_guard);
  sub_100049768();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "UID %d: User requested spins:%d hangs:%d unavilable on this platform", v1, 0x14u);
  sub_1000301E8();
}

void sub_100088270()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;
  int v4;
  int v5;

  sub_100049868();
  sub_1000497B4();
  sub_100049754((void *)&_mh_execute_header, v0, v1, "Unable to format: UID %d: Present UI:%d due to server mode:%d admin:%d", v2, v3, v4, v5);
  sub_1000497A0();
}

void sub_1000882E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Initializing prefs for user %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088340()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_10004982C((void *)&_mh_execute_header, v0, v1, "Initializing prefs for user %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000883A0()
{
  os_log_t v0;
  int v1[6];

  v1[0] = 136315394;
  sub_100049888();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: Getting prefs for user %d as command-line", (uint8_t *)v1, 0x12u);
  sub_1000301E8();
}

void sub_100088418()
{
  os_log_t v0;
  int v1[6];

  v1[0] = 136315394;
  sub_100049888();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Getting prefs for user %d as command-line", (uint8_t *)v1, 0x12u);
  sub_1000301E8();
}

void sub_100088490()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004981C();
  sub_1000497A8();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: NoExclaves:%d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000884F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004981C();
  sub_1000497A8();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: UseDsymForUUID:%d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088560()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004981C();
  sub_1000497A8();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: NoBulkSymbolication:%d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000885C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000497A8();
  sub_100049790((void *)&_mh_execute_header, v0, v1, "Unable to format: Symbolicate:%d due to enable symbolication file existing:%d", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100088644()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000497A8();
  sub_100049790((void *)&_mh_execute_header, v0, v1, "Unable to format: Avoid affecting audio:%d due to internal:%d", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000886CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100049854();
  sub_1000497A8();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Submit service watchdog:%d unavilable on this platform", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088730()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100049854();
  sub_1000497A8();
  sub_10004982C((void *)&_mh_execute_header, v0, v1, "Submit service watchdog:%d unavilable on this platform", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088794()
{
  int v0;
  int v1;
  __int16 v2;
  int v3;
  os_log_t v4;
  uint8_t v5[4];
  int v6;
  int v7;
  __int16 v8;
  int v9;

  sub_100049868();
  v6 = v0;
  sub_100049874();
  v7 = v1;
  v8 = v2;
  v9 = v3;
  _os_log_fault_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "Unable to format: Submit systemstats:%d sleep/wake failure:%d watchdog:%d due to suppression:%d", v5, 0x1Au);
  sub_1000497A0();
}

void sub_100088828()
{
  int v0;
  NSObject *v1;
  uint64_t v2;
  _DWORD v3[6];

  v3[0] = 67109632;
  v3[1] = ((unsigned __int16)word_1000EBD78 >> 7) & 1;
  sub_100049874();
  v3[4] = v0;
  sub_1000497F0((void *)&_mh_execute_header, v1, v2, "Unable to format: Submit resource reports cpu:%d io:%d due to suppression:%d", (uint8_t *)v3);
  sub_1000301E8();
}

void sub_1000888B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004989C(__stack_chk_guard);
  sub_1000497D4();
  sub_100049790((void *)&_mh_execute_header, v0, v1, "Unable to format: Submit spins:%d hangs:%d unavilable on this platform", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100088914()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10004989C(__stack_chk_guard);
  sub_1000497D4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Submit spins:%d hangs:%d unavilable on this platform", v1, 0xEu);
  sub_1000301E8();
}

void sub_100088984()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Apple Internal: reporting full spins %.1f%% of the time", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000889F0(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100047DFC((void *)&_mh_execute_header, a1, a3, "Unable to format: Submissions forced enabled", a5, a6, a7, a8, 0);
  sub_100047E4C();
}

void sub_100088A20(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100047DFC((void *)&_mh_execute_header, a1, a3, "Unable to format: Submissions suppressed", a5, a6, a7, a8, 0);
  sub_100047E4C();
}

void sub_100088A50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Got thermal level: %lld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100088AB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "Got thermal level: %lld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100088B10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to get thermal level: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088B70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "Failed to get thermal level: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088BD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to register for thermal level: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088C30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "Failed to register for thermal level: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088C90()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: GM check: Got game mode: %lld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100088CF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "GM check: Got game mode: %lld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100088D50()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: GM check: Failed to get game mode state: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088DB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "GM check: Failed to get game mode state: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088E10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to register for game mode state: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088E70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "Failed to register for game mode state: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088ED0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to register for tasking update notifications: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088F30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "Unable to register for tasking update notifications: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100088F90(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100047DFC((void *)&_mh_execute_header, a1, a3, "Unable to format: apple internal", a5, a6, a7, a8, 0);
  sub_100047E4C();
}

void sub_100088FC0()
{
  uint64_t v0;
  os_log_t v1;

  sub_10004983C();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: Tasking setting for %@ not available, using default %.1f");
  sub_1000301E8();
}

void sub_100089028()
{
  uint64_t v0;
  os_log_t v1;

  sub_10004983C();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: Tasking setting for %@: %.1f");
  sub_1000301E8();
}

void sub_100089094()
{
  uint64_t v0;
  os_log_t v1;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: Tasking setting for %@: %@ isn't a number");
  sub_1000301E8();
}

void sub_100089100()
{
  uint64_t v0;
  os_log_t v1;
  uint8_t v2[12];
  __int16 v3;
  uint64_t v4;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  v3 = 2114;
  v4 = v0;
  _os_log_error_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "Tasking setting for %{public}@: %{public}@ isn't a number", v2, 0x16u);
  sub_1000301E8();
}

void sub_10008917C(int a1, NSObject *a2)
{
  int *v3;
  uint8_t v4[40];

  sub_1000302B4(a1);
  __error();
  v3 = __error();
  sub_100047F14(v3);
  sub_100047FB8();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to get uid: %d (%s)", v4, 0x22u);
  sub_100047C98();
}

void sub_100089214(int a1, NSObject *a2)
{
  int *v3;
  uint8_t v4[40];

  sub_1000302B4(a1);
  __error();
  v3 = __error();
  sub_100047F14(v3);
  sub_100047FB8();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to get uid: %d (%s)", v4, 0x22u);
  sub_100047C98();
}

void sub_1000892AC(NSObject *a1)
{
  int *v2;
  uint8_t v3[24];

  __error();
  v2 = __error();
  sub_100047F14(v2);
  sub_100047F5C();
  _os_log_fault_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_FAULT, "Unable to format: Unable to get uid: %d (%s)", v3, 0x12u);
  sub_100047D94();
}

void sub_100089334(NSObject *a1)
{
  int *v2;
  uint8_t v3[24];

  __error();
  v2 = __error();
  sub_100047F14(v2);
  sub_100047F5C();
  _os_log_error_impl((void *)&_mh_execute_header, a1, OS_LOG_TYPE_ERROR, "Unable to get uid: %d (%s)", v3, 0x12u);
  sub_100047D94();
}

void sub_1000893BC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: unable to allocate communication queue", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008942C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: unable to allocate communication queue", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008949C(void *a1, const char *a2, NSObject *a3)
{
  uint64_t v4;
  uint8_t v5[24];

  xpc_dictionary_get_string(a1, a2);
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a3, v4, "Unable to format: Got xpc error for peer: %s", v5);
  sub_100047D94();
}

void sub_100089510(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  xpc_dictionary_get_string(a1, _xpc_error_key_description);
  sub_10003D954();
  sub_10004C550((void *)&_mh_execute_header, v1, v2, "Got xpc error for peer: %{public}s", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100089588(void *a1, const char *a2, NSObject *a3)
{
  uint64_t v4;
  uint8_t v5[24];

  xpc_dictionary_get_string(a1, a2);
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a3, v4, "Unable to format: Got xpc error message in libspindump client connection: %s", v5);
  sub_100047D94();
}

void sub_1000895FC(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  xpc_dictionary_get_string(a1, _xpc_error_key_description);
  sub_10003D954();
  sub_10004C550((void *)&_mh_execute_header, v1, v2, "Got xpc error message in libspindump client connection: %{public}s", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100089674(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000302B4(a1);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unknown message to libspindump (%lld)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000896EC(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000302B4(a1);
  sub_100047D3C();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unknown message to libspindump (%lld)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100089764()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Unknown message to libspindump (%lld)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_1000897C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unknown message to libspindump (%lld)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100089824(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: unable to get connection", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100089894(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: unable to get connection", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100089904(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: unable to create reply", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100089974(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: unable to create reply", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000899E4(int a1, NSObject *a2)
{
  uint8_t v3[24];

  sub_1000302B4(a1);
  sub_100047CF0();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Attemping to generate spindump, but not entitled", v3, 0x12u);
  sub_100047D94();
}

void sub_100089A64(int a1, NSObject *a2)
{
  uint8_t v3[24];

  sub_1000302B4(a1);
  sub_100047CF0();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Attemping to generate spindump, but not entitled", v3, 0x12u);
  sub_100047D94();
}

void sub_100089AE4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Attemping to generate spindump, but not entitled", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089B10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Attemping to generate spindump, but not entitled", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089B3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089B68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089B94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no cpu_used provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089BC0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no cpu_used provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089BEC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no duration provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089C18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no duration provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089C44()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no endtime provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089C70()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no endtime provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089C9C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no cpu_used_limit provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089CC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no cpu_used_limit provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089CF4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad cpu_used_limit (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100089D58()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad cpu_used_limit (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100089DBC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: no duration_limit provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089DE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: no duration_limit provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100089E14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100089E78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100089EDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad duration (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100089F40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad duration (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100089FA4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting CPU resource: bad cpu_used (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008A008()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "Error reporting CPU resource: bad cpu_used (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008A06C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A098()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A0C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no num bytes provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A0F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no num bytes provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A11C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no duration provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A148()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no duration provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A174()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no endtime provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A1A0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no endtime provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A1CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: no duration_limit provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A1F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: no duration_limit provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A224()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008A288()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: bad duration_limit (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008A2EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting disk writes resource: bad duration (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008A350()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004C544();
  sub_10003D900((void *)&_mh_execute_header, v0, v1, "Error reporting disk writes resource: bad duration (%f)", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008A3B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting fd exhaustion: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A3E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting fd exhaustion: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A40C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting fd exhaustion: no num fds provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A438()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting fd exhaustion: no num fds provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A464()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting port exhaustion: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A490()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting port exhaustion: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A4BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting port exhaustion: no num ports provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A4E8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting port exhaustion: no num ports provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A514()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting kqworkloop exhaustion: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A540()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting kqworkloop exhaustion: no pid provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A56C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting kqworkloop exhaustion: no num kqworkloops provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A598()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting kqworkloop exhaustion: no num kqworkloops provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A5C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Error reporting workflow repsonsiveness delay: no tailspin file provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A5F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Error reporting workflow repsonsiveness delay: no tailspin file provided", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A61C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: _HandleMicrostackshots returned a SASampleStore when saving to a file", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008A68C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: _HandleMicrostackshots returned a SASampleStore when saving to a file", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008A6FC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  __error();
  v0 = __error();
  strerror(*v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008A780()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008A7F4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  __error();
  v0 = __error();
  strerror(*v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to gzdopen datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008A878()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "Unable to gzdopen datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008A8EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Avoiding inspecting live processes for microstackshot report due to audio running", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008A918()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  __error();
  v0 = __error();
  strerror(*v0);
  sub_10004CE24();
  sub_10004CECC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008A99C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_10004CF40();
  v0 = __error();
  sub_100047F14(v0);
  sub_10004CE24();
  sub_10004CEF4((void *)&_mh_execute_header, v1, v2, "Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008AA14(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10004CF58(a1, a2, a3, 1.5047e-36);
  sub_10004CE54((void *)&_mh_execute_header, v5, v3, "Unable to format: Error grabbing microstackshots: %d (%s)", v4);
}

void sub_10008AA50(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10004CF58(a1, a2, a3, 1.5047e-36);
  sub_10004CE80((void *)&_mh_execute_header, v5, v3, "Error grabbing microstackshots: %d (%s)", v4);
}

void sub_10008AA8C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  __error();
  v0 = __error();
  strerror(*v0);
  sub_10004CE24();
  sub_10004CECC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008AB10()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  __error();
  v0 = __error();
  strerror(*v0);
  sub_10004CE24();
  sub_10004CEF4((void *)&_mh_execute_header, v1, v2, "Unable to seek %s to offset %lld: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008AB94()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  __error();
  v0 = __error();
  strerror(*v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008AC18()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "Unable to open datastore file %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008AC8C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: Didn't already return without report option", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008ACFC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: Didn't already return without report option", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008AD6C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: No datastore path provided for saving", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008ADDC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: No datastore path provided for saving", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008AE4C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: Nothing to do", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008AEBC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: Nothing to do", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008AF2C(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  objc_msgSend(a1, "systemstatsFormat");
  sub_10004CF08();
  sub_1000480AC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: report_type %d, but systemstatsFormat %d", v3, v4, v5, v6, 2u);
  sub_100047D94();
}

void sub_10008AFA8(void *a1, uint64_t a2, NSObject *a3)
{
  int v4[6];

  objc_msgSend(a1, "systemstatsFormat");
  v4[0] = 136315650;
  sub_10004CF08();
  _os_log_error_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_ERROR, "%s: report_type %d, but systemstatsFormat %d", (uint8_t *)v4, 0x18u);
  sub_100047D94();
}

void sub_10008B034()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No microstackshots found", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008B09C()
{
  NSObject *v0;
  int v1;
  uint64_t v2;
  uint8_t v3[24];

  sub_100047E28();
  sub_100047E44(v1);
  sub_100047CF0();
  sub_10004CE80((void *)&_mh_execute_header, v0, v2, "%{public}s [%d]: No microstackshots found", v3);
  sub_100047D94();
}

void sub_10008B10C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: No microstackshots found", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008B138()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "No microstackshots found", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008B164(void *a1, NSObject *a2)
{
  uint8_t v3[24];

  objc_msgSend(a1, "numSamples");
  sub_10003D954();
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: -last provided, but unable to get data end time (%lu samples)", v3, 0xCu);
  sub_100047D94();
}

void sub_10008B1E0(void *a1, NSObject *a2)
{
  uint8_t v3[24];

  objc_msgSend(a1, "numSamples");
  sub_10003D954();
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "-last provided, but unable to get data end time (%lu samples)", v3, 0xCu);
  sub_100047D94();
}

#error "10008B2AC: call analysis failed (funcsize=28)"

#error "10008B324: call analysis failed (funcsize=28)"

void sub_10008B34C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008B3C0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008B434(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a2, a3, "Unable to format: Spindump analysis written to file %@", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

#error "10008B4EC: call analysis failed (funcsize=28)"

#error "10008B564: call analysis failed (funcsize=28)"

void sub_10008B58C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: could not write to file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008B600()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "could not write to file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

#error "10008B6C4: call analysis failed (funcsize=28)"

#error "10008B73C: call analysis failed (funcsize=28)"

void sub_10008B764()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008B7D8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100048000();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008B84C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_10004CE60();
  sub_10004CEA8();
  sub_10004CEB8((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Bad report type %d", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008B8C4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_10004CE60();
  sub_10004CEA8();
  sub_10004CEE0((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Bad report type %d", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008B93C()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  v2[0] = 136315394;
  sub_100049888();
  sub_10004CE54((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Bad report type %d", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_10008B9AC()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  v2[0] = 136315394;
  sub_100049888();
  sub_10004CE80((void *)&_mh_execute_header, v0, v1, "%s: Bad report type %d", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_10008BA1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: No file to append", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BA48()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "No file to append", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BA74(uint64_t a1, id *a2, NSObject *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;

  sub_10004CF80(a1, a2);
  v6 = 136315394;
  v7 = a1;
  sub_10004CE98();
  sub_10003D948((void *)&_mh_execute_header, a3, v5, "Unable to format: reading in data file %s failed: %@", (uint8_t *)&v6);
  sub_100047D94();
}

void sub_10008BAF0(uint64_t a1, id *a2, NSObject *a3)
{
  uint64_t v5;
  int v6;
  uint64_t v7;

  sub_10004CF80(a1, a2);
  v6 = 136315394;
  v7 = a1;
  sub_10004CE98();
  sub_10003D960((void *)&_mh_execute_header, a3, v5, "reading in data file %s failed: %@", (uint8_t *)&v6);
  sub_100047D94();
}

void sub_10008BB6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Appending data file %s", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008BBCC()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10003D954();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Appending data file %s", v1, 0xCu);
  sub_1000301E8();
}

void sub_10008BC38()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: MetricKit unavailable, not providing cpu usage report", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008BCA0()
{
  NSObject *v0;
  int v1;
  uint64_t v2;
  uint8_t v3[24];

  sub_100047E28();
  sub_100047E44(v1);
  sub_100047CF0();
  sub_10004CE80((void *)&_mh_execute_header, v0, v2, "%{public}s [%d]: MetricKit unavailable, not providing cpu usage report", v3);
  sub_100047D94();
}

void sub_10008BD10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: MetricKit unavailable, not providing cpu usage report", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BD3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "MetricKit unavailable, not providing cpu usage report", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BD68()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Providing cpu usage report to MetricKit", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008BDD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Providing cpu usage report to MetricKit", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BDFC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: MetricKit unavailable, not providing disk writes report", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008BE64()
{
  NSObject *v0;
  int v1;
  uint64_t v2;
  uint8_t v3[24];

  sub_100047E28();
  sub_100047E44(v1);
  sub_100047CF0();
  sub_10004CE80((void *)&_mh_execute_header, v0, v2, "%{public}s [%d]: MetricKit unavailable, not providing disk writes report", v3);
  sub_100047D94();
}

void sub_10008BED4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: MetricKit unavailable, not providing disk writes report", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BF00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "MetricKit unavailable, not providing disk writes report", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BF2C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Providing disk writes report to MetricKit", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008BF94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Providing disk writes report to MetricKit", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008BFC0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E44(v0);
  sub_100047ED4();
  sub_1000480AC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Not providing unsupported report type (%d) to MetricKit", v3, v4, v5, v6, v7);
  sub_100047FE4();
}

void sub_10008C034()
{
  NSObject *v0;
  int v1;
  uint8_t v2[24];

  sub_100047D2C();
  sub_100047E44(v1);
  sub_100047ED4();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: Not providing unsupported report type (%d) to MetricKit", v2, 0x18u);
  sub_100047FE4();
}

void sub_10008C0B8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100048118((void *)&_mh_execute_header, a2, a3, "Unable to format: Not providing unsupported report type (%d) to MetricKit", a5, a6, a7, a8, 0);
  sub_100047E4C();
}

void sub_10008C11C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Not providing unsupported report type (%d) to MetricKit", (uint8_t *)v2, 8u);
  sub_100047E4C();
}

void sub_10008C18C(void *a1, NSObject *a2, double a3)
{
  uint64_t v5;
  int v6;
  double v7;

  objc_msgSend(a1, "debugDescription");
  v6 = 134218242;
  v7 = a3;
  sub_10004CE98();
  sub_10003D948((void *)&_mh_execute_header, a2, v5, "Unable to format: -last provided, but unable to calculate %.0f seconds earlier than %@", (uint8_t *)&v6);
  sub_100047FE4();
}

void sub_10008C218(void *a1, NSObject *a2, double a3)
{
  uint64_t v5;
  int v6;
  double v7;

  objc_msgSend(a1, "debugDescription");
  v6 = 134218242;
  v7 = a3;
  sub_10004CE98();
  sub_10003D960((void *)&_mh_execute_header, a2, v5, "-last provided, but unable to calculate %.0f seconds earlier than %@", (uint8_t *)&v6);
  sub_100047FE4();
}

void sub_10008C2A4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_10004CE60();
  sub_10004CEA8();
  sub_10004CEB8((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Bad report type for microstackshots %d", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008C31C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047D2C();
  sub_100047E54(v0);
  sub_10004CE60();
  sub_10004CEA8();
  sub_10004CEE0((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Bad report type for microstackshots %d", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008C394()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  v2[0] = 136315394;
  sub_100049888();
  sub_10004CE54((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Bad report type for microstackshots %d", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_10008C404()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  v2[0] = 136315394;
  sub_100049888();
  sub_10004CE80((void *)&_mh_execute_header, v0, v1, "%s: Bad report type for microstackshots %d", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_10008C474(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: No tracebuf nor gzfile", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008C4E4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: No tracebuf nor gzfile", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10008C554()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Data does not contain microstackshots", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008C580()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Data does not contain microstackshots", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008C5AC(int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_10004CF48(a1);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Read failed for microstackshots: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008C614(int *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_10004CF48(a1);
  sub_100047F5C();
  sub_10004CE80((void *)&_mh_execute_header, a2, v3, "Read failed for microstackshots: %d (%s)", v4);
  sub_100047D94();
}

void sub_10008C684(int *a1, uint64_t a2, NSObject *a3)
{
  int v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;

  v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  v5 = 2080;
  v6 = a2;
  sub_10004CE54((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unable to format: Read failed for microstackshots: %d (%s)", (uint8_t *)v4);
  sub_1000301E8();
}

void sub_10008C700(int *a1, uint64_t a2, NSObject *a3)
{
  int v3;
  _DWORD v4[2];
  __int16 v5;
  uint64_t v6;

  v3 = *a1;
  v4[0] = 67109378;
  v4[1] = v3;
  v5 = 2082;
  v6 = a2;
  sub_10004CE80((void *)&_mh_execute_header, a3, (uint64_t)a3, "Read failed for microstackshots: %d (%{public}s)", (uint8_t *)v4);
  sub_1000301E8();
}

void sub_10008C77C()
{
  os_log_t v0;
  int v1[10];

  v1[0] = 136315650;
  sub_10004CF24();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: buf %lu, cap %lu", (uint8_t *)v1, 0x20u);
}

void sub_10008C7FC()
{
  os_log_t v0;
  int v1[10];

  v1[0] = 136315650;
  sub_10004CF24();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: buf %lu, cap %lu", (uint8_t *)v1, 0x20u);
}

void sub_10008C87C()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  v2[0] = 136315394;
  sub_10004CF8C();
  sub_10003D948((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: realloc to %lu failed", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_10008C8EC()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  v2[0] = 136315394;
  sub_10004CF8C();
  sub_10003D960((void *)&_mh_execute_header, v0, v1, "%s: realloc to %lu failed", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_10008C95C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already timed out, not parsing system stats microstackshots", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008C988()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Already timed out, not parsing system stats microstackshots", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008C9B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004CF70();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out waiting for system stats microstackshots after %d seconds", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008CA18()
{
  os_log_t v0;
  uint8_t v1[8];

  sub_10004CF70();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Timed out waiting for system stats microstackshots after %d seconds", v1, 8u);
  sub_100047E4C();
}

void sub_10008CA88()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004CF70();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out system stats microstackshots after %d seconds, but it's parsing, so waiting a bit longer", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008CAEC(int a1, NSObject *a2, uint64_t a3)
{
  _DWORD v3[2];

  v3[0] = 67109120;
  v3[1] = a1;
  sub_10004ED50((void *)&_mh_execute_header, a2, a3, "Unable to format: SaveReport: Unsupported status %d", (uint8_t *)v3);
  sub_100047E4C();
}

void sub_10008CB54(int a1, NSObject *a2, uint64_t a3)
{
  _DWORD v3[2];

  v3[0] = 67109120;
  v3[1] = a1;
  sub_10004ED50((void *)&_mh_execute_header, a2, a3, "SaveReport: Unsupported status %d", (uint8_t *)v3);
  sub_100047E4C();
}

void sub_10008CBBC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  strerror(*v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to create stream from %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008CC40()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  strerror(*v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to create stream from %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008CCC4(void *a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  objc_msgSend(objc_msgSend(objc_msgSend(sub_10004ED98(a1, a2), "targetProcess"), "debugDescription"), "UTF8String");
  sub_10004ED5C();
  sub_10004ED70((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: No app name for cpu resource report %s", v4, v5, v6, v7, 2u);
  sub_100047D94();
}

void sub_10008CD44(void *a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  objc_msgSend(objc_msgSend(objc_msgSend(sub_10004ED98(a1, a2), "targetProcess"), "debugDescription"), "UTF8String");
  sub_10004ED5C();
  sub_10004ED84((void *)&_mh_execute_header, v2, v3, "%s: No app name for cpu resource report %s", v4, v5, v6, v7, 2u);
  sub_100047D94();
}

void sub_10008CDC4(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "!url_out";
  sub_10003D8F4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: asking for URL when generating report via OSA", (uint8_t *)&v3);
  sub_1000301E8();
}

void sub_10008CE38(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136315138;
  v2 = "!url_out";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: asking for URL when generating report via OSA", (uint8_t *)&v1, 0xCu);
  sub_1000301E8();
}

void sub_10008CEB4(void *a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  objc_msgSend(objc_msgSend(objc_msgSend(sub_10004ED98(a1, a2), "targetProcess"), "name"), "UTF8String");
  sub_10004EDB8();
  sub_10004ED70((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: %s: DID_MANUAL status while reporting", v4, v5, v6, v7, 2u);
  sub_100047D94();
}

void sub_10008CF44(void *a1, const char *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  objc_msgSend(objc_msgSend(objc_msgSend(sub_10004ED98(a1, a2), "targetProcess"), "name"), "UTF8String");
  sub_10004EDB8();
  sub_10004ED84((void *)&_mh_execute_header, v2, v3, "%s: %s: DID_MANUAL status while reporting", v4, v5, v6, v7, 2u);
  sub_100047D94();
}

void sub_10008CFD4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, v0, v1, "Unable to format: Saving %s report", v2);
  sub_1000301E8();
}

void sub_10008D038(unsigned int a1, char a2, NSObject *a3)
{
  uint8_t v4[24];

  sub_100026810(a1, a2 & 1);
  sub_10003D954();
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "Saving %s report", v4, 0xCu);
  sub_100047D94();
}

void sub_10008D0B8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100047DFC((void *)&_mh_execute_header, a1, a3, "Unable to format: No bug type for fatal disk writes reports, using non-fatal bug type", a5, a6, a7, a8, 0);
  sub_100047E4C();
}

void sub_10008D0E8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_100047DFC((void *)&_mh_execute_header, a1, a3, "No bug type for fatal disk writes reports, using non-fatal bug type", a5, a6, a7, a8, 0);
  sub_100047E4C();
}

void sub_10008D118(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(a1, "debugDescription");
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: OSAWriteLogForSubmission provided invalid fd: %@", v4);
  sub_100047D94();
}

void sub_10008D18C(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(a1, "debugDescription");
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "OSAWriteLogForSubmission provided invalid fd: %@", v4);
  sub_100047D94();
}

void sub_10008D200()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004EDB0();
  sub_1000497A8();
  sub_10004ED3C((void *)&_mh_execute_header, v0, v1, "Unable to format: dup of OSA file handle failed: %{errnod}d", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D270()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004EDB0();
  sub_1000497A8();
  sub_10004ED3C((void *)&_mh_execute_header, v0, v1, "dup of OSA file handle failed: %{errnod}d", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D2E0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004EDB0();
  sub_1000497A8();
  sub_10004ED3C((void *)&_mh_execute_header, v0, v1, "Unable to format: unable to fdopen OSA dup fd: %{errno}d", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D350()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10004EDB0();
  sub_1000497A8();
  sub_10004ED3C((void *)&_mh_execute_header, v0, v1, "unable to fdopen OSA dup fd: %{errno}d", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D3C0(FILE *a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_10004EDA0(a1);
  sub_10004EDA8(v1);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write post-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008D42C(FILE *a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_10004EDA0(a1);
  sub_10004EDA8(v1);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v2, v3, "Unable to write post-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008D498(FILE *a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_10004EDA0(a1);
  sub_10004EDA8(v1);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write pre-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008D504(FILE *a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_10004EDA0(a1);
  sub_10004EDA8(v1);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v2, v3, "Unable to write pre-blob to output file: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008D570()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Deferred reports not supported, not checking for them", v2);
  sub_100047E4C();
}

void sub_10008D5A0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Registered for deferred report generation", v2);
  sub_100047E4C();
}

void sub_10008D5D0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Registered for deferred report generation", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008D5FC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to register for deferred report generation", v2);
  sub_100047E4C();
}

void sub_10008D62C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Failed to register for deferred report generation", v2);
  sub_100047E4C();
}

void sub_10008D65C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to set expiry: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D6BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Failed to set expiry: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D71C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempting to defer reports when not supported. Caller should check before calling", v2);
  sub_100047E4C();
}

void sub_10008D74C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Attempting to defer reports when not supported. Caller should check before calling", v2);
  sub_100047E4C();
}

void sub_10008D77C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Submitted deferred report task successfully", v2);
  sub_100047E4C();
}

void sub_10008D7AC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Submitted deferred report task successfully", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008D7D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to submit task with error: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D838()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Failed to submit task with error: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D898()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Deferred report task already exists", v2);
  sub_100047E4C();
}

void sub_10008D8C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Deferred report task already exists", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008D8F4(void *a1, char *a2)
{
  uint64_t v3;
  int v4;
  id v5;

  v4 = 134217984;
  v5 = sub_100053844(a1, a2);
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: Added report to pending deferred reports (have %lu)", (uint8_t *)&v4);
  sub_100047D94();
}

void sub_10008D968()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to remove deferred reports plist: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008D9C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to remove deferred reports plist: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008DA28()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100053860();
  sub_100053844(v0, v1);
  sub_10005382C();
  sub_10004ED70((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write %lu deferred reports to plist: %@", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008DA94()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100053860();
  sub_100053844(v0, v1);
  sub_10005382C();
  sub_10004ED70((void *)&_mh_execute_header, v2, v3, "Unable to write %lu deferred reports to plist: %@", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008DB00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to read deferred reports plist, overwriting it: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008DB60()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to read deferred reports plist, overwriting it: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008DBC0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: No existing deferred reports, creating new plist", v2);
  sub_100047E4C();
}

void sub_10008DBF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "No existing deferred reports, creating new plist", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008DC1C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Deferred tasks expired", v2);
  sub_100047E4C();
}

void sub_10008DC4C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Deferred tasks expired", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008DC78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to read deferred reports plist: %@", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008DCD8()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10003D9B8(__stack_chk_guard);
  sub_10003D978();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to read deferred reports plist: %@", v1, 0xCu);
  sub_1000301E8();
}

void sub_10008DD44()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100053860();
  sub_100053844(v0, v1);
  sub_10005382C();
  sub_10004ED70((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write %lu remaining deferred reports to plist: %@", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008DDB0()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100053860();
  sub_100053844(v0, v1);
  sub_10005382C();
  sub_10004ED70((void *)&_mh_execute_header, v2, v3, "Unable to write %lu remaining deferred reports to plist: %@", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008DE1C()
{
  void *v0;
  const char *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100053860();
  sub_100053844(v0, v1);
  sub_10003D978();
  sub_10004ED70((void *)&_mh_execute_header, v2, v3, "Unable to format: Task expired with %lu remaining deferred reports (generated %lu)", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008DE94(void *a1, char *a2)
{
  uint64_t v3;
  int v4;
  id v5;

  v4 = 134217984;
  v5 = sub_100053844(a1, a2);
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: Generated %lu deferred reports", (uint8_t *)&v4);
  sub_100047D94();
}

void sub_10008DF08(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: Bad deferred report type value type", v3);
}

void sub_10008DF34(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_10005380C(a1, a2);
  sub_10005381C((void *)&_mh_execute_header, v2, v3, "Bad deferred report type value type", v4);
}

void sub_10008DF5C(uint64_t a1, void *a2)
{
  NSObject *v2;
  _QWORD *v3;
  uint8_t *v4;
  id v5;

  v5 = sub_10005384C(a1, a2);
  *(_DWORD *)v4 = 134217984;
  *v3 = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Unable to format: Unhandled deferred report type %llu", v4, 0xCu);
  sub_10005386C();
}

void sub_10008DFAC(uint64_t a1, void *a2)
{
  NSObject *v2;
  _QWORD *v3;
  uint8_t *v4;
  id v5;

  v5 = sub_10005384C(a1, a2);
  *(_DWORD *)v4 = 134217984;
  *v3 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Unhandled deferred report type %llu", v4, 0xCu);
  sub_10005386C();
}

void sub_10008DFFC(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred cpu resource: no pid provided", v3);
}

void sub_10008E028(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_10005380C(a1, a2);
  sub_10005381C((void *)&_mh_execute_header, v2, v3, "deferred cpu resource: no pid provided", v4);
}

void sub_10008E050(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred cpu resource: generating deferred report", v3);
}

void sub_10008E07C(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred cpu resource: no endtime provided", v3);
}

void sub_10008E0A8(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_10005380C(a1, a2);
  sub_10005381C((void *)&_mh_execute_header, v2, v3, "deferred cpu resource: no endtime provided", v4);
}

void sub_10008E0D0(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred disk writes resource: no pid provided", v3);
}

void sub_10008E0FC(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_10005380C(a1, a2);
  sub_10005381C((void *)&_mh_execute_header, v2, v3, "deferred disk writes resource: no pid provided", v4);
}

void sub_10008E124(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred disk writes resource: generating deferred report", v3);
}

void sub_10008E150(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: deferred disk writes resource: no endtime provided", v3);
}

void sub_10008E17C(_BYTE *a1, _BYTE *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  sub_10005380C(a1, a2);
  sub_10005381C((void *)&_mh_execute_header, v2, v3, "deferred disk writes resource: no endtime provided", v4);
}

void sub_10008E1A4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Invalid deferred reports plist", v2);
  sub_100047E4C();
}

void sub_10008E1D4()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100047EC8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Invalid deferred reports plist", v1, 2u);
  sub_100047E4C();
}

void sub_10008E20C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: No deferred reports", v2);
  sub_100047E4C();
}

void sub_10008E23C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100053800((void *)&_mh_execute_header, v0, v1, "Unable to format: Generating deferred reports", v2);
  sub_100047E4C();
}

void sub_10008E26C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather ddt for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008E2DC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather ddt for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008E34C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather ddt for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008E378()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to gather ddt for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008E3A4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather ddt for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_100047D94();
}

void sub_10008E414()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather ddt for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_100047D94();
}

void sub_10008E484()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather ddt for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100047E4C();
}

void sub_10008E4B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to gather ddt for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100047E4C();
}

void sub_10008E4DC()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_100057244();
  v1 = sub_100057250();
  sub_100047F14(v1);
  sub_100047FB8();
  sub_10004CEB8((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: Unable to spawn ddt: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10008E558()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_100057244();
  v1 = sub_100057250();
  sub_100047F14(v1);
  sub_100047FB8();
  sub_10004CEE0((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: Unable to spawn ddt: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10008E5D4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to spawn ddt: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008E644()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "Unable to spawn ddt: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008E6B4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather lsof for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008E724()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather lsof for resource exhaustion report, though process is alive", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008E794()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather lsof for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008E7C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to gather lsof for resource exhaustion report, though process is alive", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008E7EC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to gather lsof for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_100047D94();
}

void sub_10008E85C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to gather lsof for resource exhaustion report; process is no longer around",
    v3,
    v4,
    v5,
    v6,
    v7);
  sub_100047D94();
}

void sub_10008E8CC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to gather lsof for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100047E4C();
}

void sub_10008E8F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to gather lsof for resource exhaustion report; process is no longer around",
    v2,
    v3,
    v4,
    v5,
    v6);
  sub_100047E4C();
}

void sub_10008E924()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_100057244();
  v1 = sub_100057250();
  sub_100047F14(v1);
  sub_100047FB8();
  sub_10004CEB8((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: Unable to spawn lsof: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10008E9A0()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_100057244();
  v1 = sub_100057250();
  sub_100047F14(v1);
  sub_100047FB8();
  sub_10004CEE0((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: Unable to spawn lsof: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10008EA1C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to spawn lsof: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008EA8C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "Unable to spawn lsof: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008EAFC(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E44(a1);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008EB68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: file descriptor exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008EB94(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E44(a1);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008EC00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: port exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008EC2C(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E44(a1);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008EC98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: kqworkloop exhaustion: deallocating fatal port, allowing process to exit due to fatal resource exhaustion", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008ECC4()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_100047FF8(v0);
  sub_100057238();
  v1 = sub_1000480C8();
  sub_100047F14(v1);
  sub_10004CDEC();
  sub_100048098((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: could not open log file %@: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D80();
}

void sub_10008ED44()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_100047FF8(v0);
  sub_100057238();
  v1 = sub_1000480C8();
  sub_100047F14(v1);
  sub_10004CDEC();
  sub_100048034((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: could not open log file %@: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D80();
}

void sub_10008EDC4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008EE38()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "could not open log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008EEAC()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_100047FF8(v0);
  sub_100057238();
  v1 = sub_1000480C8();
  sub_100047F14(v1);
  sub_10004CDEC();
  sub_100048098((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: could not fdopen log file %@: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D80();
}

void sub_10008EF2C()
{
  int *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_100047FF8(v0);
  sub_100057238();
  v1 = sub_1000480C8();
  sub_100047F14(v1);
  sub_10004CDEC();
  sub_100048034((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: could not fdopen log file %@: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D80();
}

void sub_10008EFAC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008F020()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "could not fdopen log file %@: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10008F094()
{
  int *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_100047FF8(v0);
  v1 = sub_100057228();
  sub_10004EDA8(v1);
  sub_1000571FC();
  sub_10004CEB8((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10008F10C()
{
  int *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_100047FF8(v0);
  v1 = sub_100057228();
  sub_10004EDA8(v1);
  sub_1000571FC();
  sub_10004CEE0((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10008F184(FILE *a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_10004EDA0(a1);
  sub_10004EDA8(v1);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v2, v3, "Unable to format: Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008F1F0(FILE *a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = sub_10004EDA0(a1);
  sub_10004EDA8(v1);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v2, v3, "Unable to write ddt/lsof output to buffer: %d (%s)", v4, v5, v6, v7, v8);
  sub_100047D94();
}

void sub_10008F25C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to convert ddt/lsof output to buffer", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008F2CC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to convert ddt/lsof output to buffer", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008F33C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to convert ddt/lsof output to buffer", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008F368()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to convert ddt/lsof output to buffer", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008F394()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  strerror(*v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to opendir /private/var/db/spindump: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008F410()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  strerror(*v0);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "Unable to opendir /private/var/db/spindump: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008F48C(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Marked file purgeable", v1, 2u);
}

void sub_10008F4CC(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_debug_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEBUG, "Marked file purgeable", v1, 2u);
}

void sub_10008F50C(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  strerror(a1);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Failed to mark file purgeable: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008F57C(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  strerror(a1);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "Failed to mark file purgeable: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10008F5EC()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100048140();
  sub_10003D948((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: Unable to parse time string %s, try using format '%%Y-%%m-%%dT%%T%%z', e.g. %s", v1);
  sub_1000301E8();
}

void sub_10008F654()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100048140();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "Unable to parse time string %s, try using format '%%Y-%%m-%%dT%%T%%z', e.g. %s", v1, 0x16u);
  sub_1000301E8();
}

void sub_10008F6C4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to create date formatter", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008F6F0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to create date formatter", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10008F71C(uint64_t a1, NSObject *a2, uint64_t a3, double a4)
{
  int v4;
  uint64_t v5;
  __int16 v6;
  double v7;

  v4 = 134218240;
  v5 = a1;
  v6 = 2048;
  v7 = a4;
  sub_10003D948((void *)&_mh_execute_header, a2, a3, "Unable to format: Found ISO timestamp %ld with subseconds %f", (uint8_t *)&v4);
  sub_1000301E8();
}

void sub_10008F790(uint64_t a1, NSObject *a2, long double a3)
{
  int v4;
  uint64_t v5;
  __int16 v6;
  long double v7;

  v4 = 134218240;
  v5 = a1;
  v6 = 2048;
  v7 = fmod(a3, 1.0);
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Found ISO timestamp %ld with subseconds %f", (uint8_t *)&v4, 0x16u);
  sub_100047D94();
}

void sub_10008F824()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, v0, v1, "Unable to format: Found ISO timestamp %ld", v2);
  sub_1000301E8();
}

void sub_10008F888()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "Found ISO timestamp %ld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008F8E8()
{
  os_log_t v0;
  int v1[10];

  v1[0] = 136315650;
  sub_100060070();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: endOfSecs %p endPtr %p", (uint8_t *)v1, 0x20u);
}

void sub_10008F96C()
{
  os_log_t v0;
  int v1[10];

  v1[0] = 136315650;
  sub_100060070();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: endOfSecs %p endPtr %p", (uint8_t *)v1, 0x20u);
}

void sub_10008F9F0()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, v0, v1, "Unable to format: Found ISO timestamp with time zone name %ld", v2);
  sub_1000301E8();
}

void sub_10008FA54()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "Found ISO timestamp with time zone name %ld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008FAB4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, v0, v1, "Unable to format: Found ISO timestamp with time zone number %ld", v2);
  sub_1000301E8();
}

void sub_10008FB18()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "Found ISO timestamp with time zone number %ld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008FB78()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, v0, v1, "Unable to format: Found unix timestamp %ld", v2);
  sub_1000301E8();
}

void sub_10008FBDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D990((void *)&_mh_execute_header, v0, v1, "Found unix timestamp %ld", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_10008FC3C(void *a1, NSObject *a2)
{
  char *v3;
  char *v4;
  id v5;
  char *v6;
  uint8_t buf[4];
  char *v9;
  __int16 v10;
  id v11;
  __int16 v12;
  id v13;
  __int16 v14;
  id v15;
  __int16 v16;
  id v17;
  __int16 v18;
  id v19;
  __int16 v20;
  id v21;
  __int16 v22;
  id v23;
  __int16 v24;
  id v25;
  __int16 v26;
  id v27;
  __int16 v28;
  id v29;
  __int16 v30;
  id v31;
  __int16 v32;
  id v33;
  __int16 v34;
  id v35;
  __int16 v36;
  id v37;
  __int16 v38;
  id v39;
  __int16 v40;
  id v41;
  __int16 v42;
  id v43;
  __int16 v44;
  id v45;
  __int16 v46;
  id v47;
  __int16 v48;
  id v49;
  __int16 v50;
  id v51;
  __int16 v52;
  id v53;
  __int16 v54;
  id v55;
  __int16 v56;
  id v57;
  __int16 v58;
  id v59;
  __int16 v60;
  id v61;
  __int16 v62;
  id v63;
  __int16 v64;
  id v65;
  __int16 v66;
  id v67;
  __int16 v68;
  id v69;
  __int16 v70;
  id v71;
  __int16 v72;
  id v73;
  __int16 v74;
  id v75;
  __int16 v76;
  id v77;
  __int16 v78;
  id v79;
  __int16 v80;
  id v81;
  __int16 v82;
  id v83;
  __int16 v84;
  id v85;
  __int16 v86;
  id v87;
  __int16 v88;
  id v89;
  __int16 v90;
  id v91;
  __int16 v92;
  id v93;
  __int16 v94;
  id v95;
  __int16 v96;
  id v97;
  __int16 v98;
  id v99;
  __int16 v100;
  id v101;
  __int16 v102;
  id v103;
  __int16 v104;
  id v105;
  __int16 v106;
  id v107;
  __int16 v108;
  id v109;
  __int16 v110;
  id v111;
  __int16 v112;
  id v113;
  __int16 v114;
  id v115;
  __int16 v116;
  id v117;
  __int16 v118;
  id v119;
  __int16 v120;
  id v121;
  __int16 v122;
  id v123;
  __int16 v124;
  id v125;
  __int16 v126;
  id v127;
  __int16 v128;
  id v129;
  __int16 v130;
  id v131;
  __int16 v132;
  id v133;
  __int16 v134;
  id v135;
  __int16 v136;
  id v137;
  __int16 v138;
  id v139;
  __int16 v140;
  id v141;
  __int16 v142;
  id v143;
  __int16 v144;
  id v145;
  __int16 v146;
  id v147;
  __int16 v148;
  id v149;
  __int16 v150;
  id v151;
  __int16 v152;
  id v153;

  v3 = (char *)objc_msgSend(objc_msgSend(a1, "total"), "bytes");
  v4 = &v3[(_QWORD)objc_msgSend(sub_100047E0C(), "bytes_duplicate")];
  v5 = objc_msgSend(sub_100047E0C(), "bytes_out_of_order");
  v6 = &v4[(unint64_t)objc_msgSend(sub_100047E0C(), "bytes_missing_load_info") + (_QWORD)v5];
  v9 = (char *)objc_msgSend(a1, "bytes_not_microstackshots") + (_QWORD)v6;
  v11 = objc_msgSend(a1, "bytes_not_microstackshots");
  v13 = objc_msgSend(a1, "num_microstackshots_filtered_out");
  v15 = objc_msgSend(sub_100047E0C(), "count");
  v17 = objc_msgSend(sub_100047E0C(), "bytes");
  v19 = objc_msgSend(sub_100047E0C(), "num_load_infos");
  v21 = objc_msgSend(sub_100047E0C(), "num_frames");
  v23 = objc_msgSend(sub_100047E0C(), "num_duplicate");
  v25 = objc_msgSend(sub_100047E0C(), "bytes_duplicate");
  v27 = objc_msgSend(sub_100047E0C(), "num_out_of_order");
  v29 = objc_msgSend(sub_100047E0C(), "bytes_out_of_order");
  v31 = objc_msgSend(sub_100047E0C(), "num_missing_load_info");
  v33 = objc_msgSend(sub_100047E0C(), "bytes_missing_load_info");
  v35 = objc_msgSend(sub_10006003C(), "count");
  v37 = objc_msgSend(sub_10006003C(), "bytes");
  v39 = objc_msgSend(sub_10006003C(), "num_load_infos");
  v41 = objc_msgSend(sub_10006003C(), "num_frames");
  v43 = objc_msgSend(sub_10006003C(), "num_duplicate");
  v45 = objc_msgSend(sub_10006003C(), "bytes_duplicate");
  v47 = objc_msgSend(sub_10006003C(), "num_out_of_order");
  v49 = objc_msgSend(sub_10006003C(), "bytes_out_of_order");
  v51 = objc_msgSend(sub_10006003C(), "num_missing_load_info");
  v53 = objc_msgSend(sub_10006003C(), "bytes_missing_load_info");
  v55 = objc_msgSend(sub_10006002C(), "count");
  v57 = objc_msgSend(sub_10006002C(), "bytes");
  v59 = objc_msgSend(sub_10006002C(), "num_load_infos");
  v61 = objc_msgSend(sub_10006002C(), "num_frames");
  v63 = objc_msgSend(sub_10006002C(), "num_duplicate");
  v65 = objc_msgSend(sub_10006002C(), "bytes_duplicate");
  v67 = objc_msgSend(sub_10006002C(), "num_out_of_order");
  v69 = objc_msgSend(sub_10006002C(), "bytes_out_of_order");
  v71 = objc_msgSend(sub_10006002C(), "num_missing_load_info");
  v73 = objc_msgSend(sub_10006002C(), "bytes_missing_load_info");
  v75 = objc_msgSend(sub_10006004C(), "count");
  v77 = objc_msgSend(sub_10006004C(), "bytes");
  v79 = objc_msgSend(sub_10006004C(), "num_load_infos");
  v81 = objc_msgSend(sub_10006004C(), "num_frames");
  v83 = objc_msgSend(sub_10006004C(), "num_duplicate");
  v85 = objc_msgSend(sub_10006004C(), "bytes_duplicate");
  v87 = objc_msgSend(sub_10006004C(), "num_out_of_order");
  v89 = objc_msgSend(sub_10006004C(), "bytes_out_of_order");
  v91 = objc_msgSend(sub_10006004C(), "num_missing_load_info");
  v93 = objc_msgSend(sub_10006004C(), "bytes_missing_load_info");
  v95 = objc_msgSend(sub_100060034(), "count");
  *(_DWORD *)buf = 134236416;
  v97 = objc_msgSend(sub_100060034(), "bytes");
  v10 = 2048;
  v12 = 2048;
  v14 = 2048;
  v16 = 2048;
  v18 = 2048;
  v20 = 2048;
  v22 = 2048;
  v24 = 2048;
  v26 = 2048;
  v28 = 2048;
  v30 = 2048;
  v32 = 2048;
  v34 = 2048;
  v36 = 2048;
  v38 = 2048;
  v40 = 2048;
  v42 = 2048;
  v44 = 2048;
  v46 = 2048;
  v48 = 2048;
  v50 = 2048;
  v52 = 2048;
  v54 = 2048;
  v56 = 2048;
  v58 = 2048;
  v60 = 2048;
  v62 = 2048;
  v64 = 2048;
  v66 = 2048;
  v68 = 2048;
  v70 = 2048;
  v72 = 2048;
  v74 = 2048;
  v76 = 2048;
  v78 = 2048;
  v80 = 2048;
  v82 = 2048;
  v84 = 2048;
  v86 = 2048;
  v88 = 2048;
  v90 = 2048;
  v92 = 2048;
  v94 = 2048;
  v96 = 2048;
  v98 = 2048;
  v99 = objc_msgSend(sub_100060034(), "num_load_infos");
  v100 = 2048;
  v101 = objc_msgSend(sub_100060034(), "num_frames");
  v102 = 2048;
  v103 = objc_msgSend(sub_100060034(), "num_duplicate");
  v104 = 2048;
  v105 = objc_msgSend(sub_100060034(), "bytes_duplicate");
  v106 = 2048;
  v107 = objc_msgSend(sub_100060034(), "num_out_of_order");
  v108 = 2048;
  v109 = objc_msgSend(sub_100060034(), "bytes_out_of_order");
  v110 = 2048;
  v111 = objc_msgSend(sub_100060034(), "num_missing_load_info");
  v112 = 2048;
  v113 = objc_msgSend(sub_100060034(), "bytes_missing_load_info");
  v114 = 2048;
  v115 = objc_msgSend(sub_100060024(), "count");
  v116 = 2048;
  v117 = objc_msgSend(sub_100060024(), "bytes");
  v118 = 2048;
  v119 = objc_msgSend(sub_100060024(), "num_load_infos");
  v120 = 2048;
  v121 = objc_msgSend(sub_100060024(), "num_frames");
  v122 = 2048;
  v123 = objc_msgSend(sub_100060024(), "num_duplicate");
  v124 = 2048;
  v125 = objc_msgSend(sub_100060024(), "bytes_duplicate");
  v126 = 2048;
  v127 = objc_msgSend(sub_100060024(), "num_out_of_order");
  v128 = 2048;
  v129 = objc_msgSend(sub_100060024(), "bytes_out_of_order");
  v130 = 2048;
  v131 = objc_msgSend(sub_100060024(), "num_missing_load_info");
  v132 = 2048;
  v133 = objc_msgSend(sub_100060024(), "bytes_missing_load_info");
  v134 = 2048;
  v135 = objc_msgSend(sub_100060044(), "count");
  v136 = 2048;
  v137 = objc_msgSend(sub_100060044(), "bytes");
  v138 = 2048;
  v139 = objc_msgSend(sub_100060044(), "num_load_infos");
  v140 = 2048;
  v141 = objc_msgSend(sub_100060044(), "num_frames");
  v142 = 2048;
  v143 = objc_msgSend(sub_100060044(), "num_duplicate");
  v144 = 2048;
  v145 = objc_msgSend(sub_100060044(), "bytes_duplicate");
  v146 = 2048;
  v147 = objc_msgSend(sub_100060044(), "num_out_of_order");
  v148 = 2048;
  v149 = objc_msgSend(sub_100060044(), "bytes_out_of_order");
  v150 = 2048;
  v151 = objc_msgSend(sub_100060044(), "num_missing_load_info");
  v152 = 2048;
  v153 = objc_msgSend(sub_100060044(), "bytes_missing_load_info");
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Microstackshot statistics:\n%llu bytes parsed (%llu bytes invalid)\n%llu filtered out\n\ntotal     count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n          no_load_info   %llu (%llu bytes)\n\ninterrupt count          %llu (%llu bytes)\n          num_load_infos %llu\n          num_frames     %llu\n          duplicate      %llu (%llu bytes)\n          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "timer     count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "io        count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "pmi       count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "macf      count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)\n"
    "\n"
    "unknown   count          %llu (%llu bytes)\n"
    "          num_load_infos %llu\n"
    "          num_frames     %llu\n"
    "          duplicate      %llu (%llu bytes)\n"
    "          out_of_order   %llu (%llu bytes)\n"
    "          no_load_info   %llu (%llu bytes)",
    buf,
    0x2DCu);
}

void sub_100090414(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(a1, "bytes_not_microstackshots");
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: %llu bytes of microstackshot data was invalid (ignored)", v4);
  sub_100047D94();
}

void sub_100090488(void *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(a1, "bytes_not_microstackshots");
  sub_10003D954();
  sub_100060054((void *)&_mh_execute_header, a2, v3, "%llu bytes of microstackshot data was invalid (ignored)", v4);
  sub_100047D94();
}

void sub_1000904FC(void *a1, char *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(sub_100060098(a1, a2), "num_out_of_order");
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: %llu microstackshots dropped due to being out of order", v4);
  sub_100047D94();
}

void sub_100090570(void *a1, char *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(sub_100060098(a1, a2), "num_out_of_order");
  sub_10003D954();
  sub_100060054((void *)&_mh_execute_header, a2, v3, "%llu microstackshots dropped due to being out of order", v4);
  sub_100047D94();
}

void sub_1000905E4(void *a1, char *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(sub_100060098(a1, a2), "num_missing_load_info");
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: %llu microstackshots dropped due to missing load infos", v4);
  sub_100047D94();
}

void sub_100090658(void *a1, char *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  objc_msgSend(sub_100060098(a1, a2), "num_missing_load_info");
  sub_10003D954();
  sub_100060054((void *)&_mh_execute_header, a2, v3, "%llu microstackshots dropped due to missing load infos", v4);
  sub_100047D94();
}

void sub_1000906CC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to get pid list: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009073C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "Unable to get pid list: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000907AC()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100048164();
  sub_10004ED50((void *)&_mh_execute_header, v0, v1, "Unable to format: Done running heap/ddt for all (%d) processes", v2);
  sub_100047E4C();
}

void sub_100090810()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100048164();
  sub_10004ED50((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out running heap/ddt for all (%d) processes", v2);
  sub_100047E4C();
}

void sub_100090874()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100048164();
  sub_10006008C((void *)&_mh_execute_header, v0, v1, "Timed out running heap/ddt for all (%d) processes", v2);
  sub_100047E4C();
}

void sub_1000908D8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100048164();
  sub_10004ED50((void *)&_mh_execute_header, v0, v1, "Unable to format: Running heap/ddt for all (%d) processes", v2);
  sub_100047E4C();
}

void sub_10009093C()
{
  NSObject *v0;
  uint8_t v1[8];

  sub_10005FFC8();
  sub_1000497A8();
  sub_10004ED50((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: heap for [%d] completed", v1);
  sub_100047E4C();
}

void sub_1000909A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000600CC();
  sub_1000497A8();
  sub_10004982C((void *)&_mh_execute_header, v0, v1, "heap for [%d] completed", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100090A04()
{
  _QWORD *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_10005FFDC(v0, v1);
  sub_100060060();
  sub_10005FFA8();
  sub_1000480AC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: No output from heap for %d", v4, v5, v6, v7, v8);
  sub_100047FA0();
}

void sub_100090A74()
{
  _QWORD *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_10005FFDC(v0, v1);
  sub_100060060();
  sub_10005FFA8();
  sub_100048048((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: No output from heap for %d", v4, v5, v6, v7, v8);
  sub_100047FA0();
}

void sub_100090AE4()
{
  NSObject *v0;
  uint8_t v1[8];

  sub_10005FFC8();
  sub_1000497A8();
  sub_10004ED50((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: No output from heap for %d", v1);
  sub_100047E4C();
}

void sub_100090B4C()
{
  NSObject *v0;
  uint8_t v1[8];

  sub_10005FFC8();
  sub_1000497A8();
  sub_10006008C((void *)&_mh_execute_header, v0, (uint64_t)v0, "No output from heap for %d", v1);
  sub_100047E4C();
}

void sub_100090BB4()
{
  NSObject *v0;
  uint8_t v1[8];

  sub_10005FFC8();
  sub_1000497A8();
  sub_10004ED50((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: ddt for [%d] completed", v1);
  sub_100047E4C();
}

void sub_100090C1C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000600CC();
  sub_1000497A8();
  sub_10004982C((void *)&_mh_execute_header, v0, v1, "ddt for [%d] completed", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100090C7C()
{
  _QWORD *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_10005FFDC(v0, v1);
  sub_100060060();
  sub_10005FFA8();
  sub_1000480AC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: No output from ddt for %d", v4, v5, v6, v7, v8);
  sub_100047FA0();
}

void sub_100090CEC()
{
  _QWORD *v0;
  int *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047D2C();
  sub_10005FFDC(v0, v1);
  sub_100060060();
  sub_10005FFA8();
  sub_100048048((void *)&_mh_execute_header, v2, v3, "%{public}s [%d]: No output from ddt for %d", v4, v5, v6, v7, v8);
  sub_100047FA0();
}

void sub_100090D5C()
{
  NSObject *v0;
  uint8_t v1[8];

  sub_10005FFC8();
  sub_1000497A8();
  sub_10004ED50((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: No output from ddt for %d", v1);
  sub_100047E4C();
}

void sub_100090DC4()
{
  NSObject *v0;
  uint8_t v1[8];

  sub_10005FFC8();
  sub_1000497A8();
  sub_10006008C((void *)&_mh_execute_header, v0, (uint64_t)v0, "No output from ddt for %d", v1);
  sub_100047E4C();
}

void sub_100090E2C(NSObject *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1000600A0(a1);
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: Interrupted again by signal %ld, exiting", v4);
  sub_100047D94();
}

void sub_100090E9C(NSObject *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1000600A0(a1);
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: Interrupted by signal %ld while saving report. Interrupt again after a second to exit early", v4);
  sub_100047D94();
}

void sub_100090F0C(NSObject *a1, NSObject *a2)
{
  uint64_t v3;
  uint8_t v4[24];

  sub_1000600A0(a1);
  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, a2, v3, "Unable to format: Interrupted by signal %ld", v4);
  sub_100047D94();
}

void sub_100090F7C(NSObject *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_1000600A0(a1);
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Interrupted by signal %ld, waiting %d seconds...", v3, v4, v5, v6, 0);
  sub_100047D94();
}

void sub_100090FFC(NSObject *a1, NSObject *a2, double a3)
{
  uint64_t v4;
  int v5;
  double v6;
  __int16 v7;
  uintptr_t handle;

  v5 = 134218240;
  v6 = a3 - *(double *)&qword_1000EBC68;
  v7 = 2048;
  handle = dispatch_source_get_handle(a1);
  sub_10003D948((void *)&_mh_execute_header, a2, v4, "Unable to format: Interrupted again after %.2f seconds by signal %ld, not exiting", (uint8_t *)&v5);
}

void sub_10009109C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Running under debugger, ignoring", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000910C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "spindump-stuck: Running under debugger, ignoring", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000910F4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: spindump-stuck: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100091174()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "spindump-stuck: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000911F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Unable to take stackshot", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100091220()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "spindump-stuck: Unable to take stackshot", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009124C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_10003D954();
  sub_10003D8F4((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Wrote stackshot to %s", v2);
  sub_1000301E8();
}

void sub_1000912B0(int a1, FILE *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint8_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v8 = sub_1000600C0(a1, a2, a3, a4, a5, a6, a7, a8, v15, v17, v18, v19, v20, v21);
  strerror(v8);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v9, v10, "Unable to format: Unable to write stackshot to %s: %d (%s)", v11, v12, v13, v14, v16);
  sub_100047C98();
}

void sub_100091328(int a1, FILE *a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint8_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v8 = sub_1000600C0(a1, a2, a3, a4, a5, a6, a7, a8, v15, v17, v18, v19, v20, v21);
  strerror(v8);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v9, v10, "Unable to write stackshot to %s: %d (%s)", v11, v12, v13, v14, v16);
  sub_100047C98();
}

void sub_1000913A0()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100047EA8();
  sub_10003D948((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: filePath %s cut off with date (needed %zu chars)", v1);
  sub_1000301E8();
}

void sub_100091408()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100047EA8();
  sub_10003D948((void *)&_mh_execute_header, v0, (uint64_t)v0, "filePath %s cut off with date (needed %zu chars)", v1);
  sub_1000301E8();
}

void sub_100091470()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Audio running, avoiding stackshot", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009149C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "spindump-stuck: Audio running, avoiding stackshot", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000914C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: spindump-stuck: Spindump has taken over a minute to process samples and may be stuck, try using -noIPC", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000914F4()
{
  NSObject *v0;
  int v1;
  int *v2;
  uint8_t v3[40];

  sub_100047E28();
  sub_1000302B4(v1);
  sub_1000600B8();
  v2 = sub_100057250();
  sub_100047F14(v2);
  sub_100047FB8();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)", v3, 0x22u);
  sub_100047C98();
}

void sub_100091580()
{
  NSObject *v0;
  int v1;
  int *v2;
  uint8_t v3[40];

  sub_100047E28();
  sub_1000302B4(v1);
  sub_1000600B8();
  v2 = sub_100057250();
  sub_100047F14(v2);
  sub_100047FB8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to get proc info, assuming not being debugged: %d (%s)", v3, 0x22u);
  sub_100047C98();
}

void sub_10009160C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to get proc info, assuming not being debugged: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009167C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "Unable to get proc info, assuming not being debugged: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000916EC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctl for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009175C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "sysctl for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000917CC(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "source";
  sub_10003D8F4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: unable to allocate source", (uint8_t *)&v3);
  sub_1000301E8();
}

void sub_100091840(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "source";
  sub_100060054((void *)&_mh_execute_header, a1, a3, "%s: unable to allocate source", (uint8_t *)&v3);
  sub_1000301E8();
}

void sub_1000918B4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100091924()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "sysctlnametomib for security.mac.sandbox.audio_active failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100091994()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_1000497A8();
  sub_10004ED50((void *)&_mh_execute_header, v0, v1, "Unable to format: Memory pressure %d", v2);
  sub_100047E4C();
}

void sub_1000919FC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000497A8();
  sub_10004982C((void *)&_mh_execute_header, v0, v1, "Memory pressure %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100091A60()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100091AD0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "sysctl for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100091B40()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100091BB0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_1000480E8();
  v0 = sub_1000480E0();
  sub_100047F14(v0);
  sub_100047F5C();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "sysctlnametomib for kern.memorystatus_vm_pressure_level failed: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100091C20()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  geteuid();
  sub_100049888();
  sub_100047DA0((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: spindump must run as root to create spindump directory (running as %d)", v2, v3, v4, v5, 2u);
  sub_100047D94();
}

void sub_100091C98()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  geteuid();
  sub_100049888();
  sub_10004805C((void *)&_mh_execute_header, v0, v1, "%s: spindump must run as root to create spindump directory (running as %d)", v2, v3, v4, v5, 2u);
  sub_100047D94();
}

void sub_100091D10(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "(((st.st_mode) & 0170000) == 0040000)";
  sub_10003D8F4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: /private/var/db/spindump already exists and isnt a directory!", (uint8_t *)&v3);
  sub_1000301E8();
}

void sub_100091D84(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "(((st.st_mode) & 0170000) == 0040000)";
  sub_100060054((void *)&_mh_execute_header, a1, a3, "%s: /private/var/db/spindump already exists and isnt a directory!", (uint8_t *)&v3);
  sub_1000301E8();
}

void sub_100091DF8()
{
  NSObject *v0;
  int v1;
  int *v2;
  uint8_t v3[56];

  sub_100047E28();
  strerror(v1);
  sub_1000600B8();
  v2 = sub_100057250();
  sub_100047F14(v2);
  sub_10005FFF0();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)", v3, 0x2Cu);
  sub_1000600A8();
}

void sub_100091E8C()
{
  NSObject *v0;
  int v1;
  int *v2;
  uint8_t v3[56];

  sub_100047E28();
  strerror(v1);
  sub_1000600B8();
  v2 = sub_100057250();
  sub_100047F14(v2);
  sub_10005FFF0();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: unable to create /private/var/db/spindump after state failed with %d (%s): %d (%s)", v3, 0x2Cu);
  sub_1000600A8();
}

void sub_100091F20()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[8];

  sub_100048164();
  sub_10004ED50((void *)&_mh_execute_header, v0, v1, "Unable to format: Creating spindump directory /private/var/db/spindump after stat said %d", v2);
  sub_100047E4C();
}

void sub_100091F84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100048164();
  sub_10004982C((void *)&_mh_execute_header, v0, v1, "Creating spindump directory /private/var/db/spindump after stat said %{errno}d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100091FE4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100092058()
{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  uint64_t v3;

  sub_100060C48(__stack_chk_guard);
  sub_100060C30();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: %s isn't big enough for a kcdata header (only %lld bytes)", v2, v3);
  sub_1000301E8();
}

void sub_1000920B8()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100060C48(__stack_chk_guard);
  sub_100060C30();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s isn't big enough for a kcdata header (only %lld bytes)", v1, 0x16u);
  sub_1000301E8();
}

void sub_100092128()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to map %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_10009219C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "Unable to map %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100092210()
{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  uint64_t v3;

  sub_100060C48(__stack_chk_guard);
  sub_100060C30();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: Not a kcdata file: kcdata in %s not valid (file length %lld)", v2, v3);
  sub_1000301E8();
}

void sub_100092270()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100060C48(__stack_chk_guard);
  sub_100060C30();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Not a kcdata file: kcdata in %s not valid (file length %lld)", v1, 0x16u);
  sub_1000301E8();
}

void sub_1000922E0(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Avoiding inspecting live processes for stackshot file due to audio running", v1, 2u);
}

void sub_100092320()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100060C54(__stack_chk_guard);
  sub_1000571E4();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: %s isn't a kcdata stackshot file (header type %#x)", v1, 0x12u);
  sub_1000301E8();
}

void sub_100092398()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100060C54(__stack_chk_guard);
  sub_1000571E4();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s isn't a kcdata stackshot file (header type %#x)", v1, 0x12u);
  sub_1000301E8();
}

void sub_100092410()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to stat %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100092484()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10004CF40();
  v0 = sub_1000480C0();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "Unable to stat %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000924F8(int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047FF8(a1);
  sub_10006E9AC();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: dealloc with %p transaction", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100092578(int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047FF8(a1);
  sub_10006E9AC();
  sub_100047F1C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: dealloc with %p transaction", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000925F8(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a2, a3, "Unable to format: dealloc with %p transaction", a5, a6, a7, a8, 0);
  sub_1000301E8();
}

void sub_100092660(uint64_t a1, NSObject *a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = 134217984;
  v5 = v3;
  sub_10006EA0C((void *)&_mh_execute_header, a2, a3, "dealloc with %p transaction", (uint8_t *)&v4);
  sub_1000301E8();
}

void sub_1000926CC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_10006E948();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: nil sampleStore", v3, v4, v5, v6, v7);
  sub_10006E9A0();
}

void sub_100092748()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_10006E948();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: nil sampleStore", v3, v4, v5, v6, v7);
  sub_10006E9A0();
}

void sub_1000927C4(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: nil sampleStore", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100092834(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: nil sampleStore", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000928A4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Generating report", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092910()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Generating report", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009293C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to create sample printer", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000929A8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to create sample printer", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092A14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to create sample printer", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092A40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to create sample printer", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092A6C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Done generating report", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092AD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Done generating report", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092B04()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to save spindump binary format", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092B70()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to save spindump binary format", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092BDC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to save spindump binary format", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092C08()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to save spindump binary format", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092C34()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to allocate proc exit HID dispatch source", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092CA0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to allocate proc exit HID dispatch source", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092D0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to allocate proc exit HID dispatch source", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092D38()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to allocate proc exit HID dispatch source", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092D64()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: exited - HID", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092DD0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: exited - HID", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092DFC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Process exited, no longer waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092E68()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Process exited, no longer waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092ED4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Process exited, no longer waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092F00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Process exited, no longer waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100092F2C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Process exited, and not waiting for a HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100092F98()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Process exited, and not waiting for a HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093004()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Process exited, and not waiting for a HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093030()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Process exited, and not waiting for a HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009305C()
{
  id *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  v1 = sub_10006E9F4(v0);
  sub_1000302B4(v1);
  sub_10006EA00();
  sub_10006E968();
  sub_100047CDC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: %s: _hidEventSem non-NULL when not requiring HID event", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_1000930DC()
{
  id *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  v1 = sub_10006E9F4(v0);
  sub_1000302B4(v1);
  sub_10006EA00();
  sub_10006E968();
  sub_100047F30((void *)&_mh_execute_header, v2, v3, "%s [%d]: %s: _hidEventSem non-NULL when not requiring HID event", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10009315C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: _hidEventSem non-NULL when not requiring HID event", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000931CC(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: _hidEventSem non-NULL when not requiring HID event", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10009323C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Doesn't require HID event and we weren't waiting before anyway", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000932A8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Doesn't require HID event and we weren't waiting before anyway", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093314()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Doesn't require HID event and we weren't waiting before anyway", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093340()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Doesn't require HID event and we weren't waiting before anyway", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009336C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No longer waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000933D8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: No longer waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093444()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: No longer waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093470()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "No longer waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009349C()
{
  id *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  v1 = sub_10006E9F4(v0);
  sub_1000302B4(v1);
  sub_10006EA00();
  sub_10006E968();
  sub_100047CDC((void *)&_mh_execute_header, v2, v3, "Unable to format: %s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10009351C()
{
  id *v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100047E28();
  v1 = sub_10006E9F4(v0);
  sub_1000302B4(v1);
  sub_10006EA00();
  sub_10006E968();
  sub_100047F30((void *)&_mh_execute_header, v2, v3, "%s [%d]: %s: _hidEventSem non-NULL when already tracking this process in previous spin", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_10009359C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: _hidEventSem non-NULL when already tracking this process in previous spin", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10009360C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: _hidEventSem non-NULL when already tracking this process in previous spin", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10009367C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Previous spin waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000936E8()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Previous spin waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093754()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Previous spin waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093780()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Previous spin waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000937AC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Requires HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093818()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Requires HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093884()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Requires HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000938B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Requires HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000938DC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093948()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already waiting for HID event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000939B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000939E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Already waiting for HID event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093A0C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already waiting for HID event from previous spin, canceling this spin", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093A78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already waiting for HID event from previous spin, canceling this spin", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093AA4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No sampled process for hid event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093B10()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: No sampled process for hid event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093B7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: No sampled process for hid event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093BA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "No sampled process for hid event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093BD4(uint64_t a1)
{
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  objc_msgSend(*(id *)(a1 + 416), "machAbsTimeSeconds");
  sub_10006EA64();
  sub_10006EA54();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0xCu);
  sub_100047FE4();
}

void sub_100093C70(uint64_t a1, uint64_t a2, NSObject *a3)
{
  double v3;
  double v5;
  uint64_t v6;
  int v7;
  double v8;

  objc_msgSend(*(id *)(a1 + 416), "machAbsTimeSeconds");
  sub_10006EA64();
  v7 = 134217984;
  v8 = v3 - v5;
  sub_10006EA0C((void *)&_mh_execute_header, a3, v6, "Got hid event from %.1fs earlier than the spin we monitored, continuing to wait", (uint8_t *)&v7);
  sub_100047FE4();
}

void sub_100093D0C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Got hid event", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093D78()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Got hid event", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093DA4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Attempted to change sampling target after done sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093E10()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Attempted to change sampling target after done sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093E7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempted to change sampling target after done sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093EA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Attempted to change sampling target after done sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093ED4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Pids is ignored when sampling all processes", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093F40()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Pids is ignored when sampling all processes", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100093FAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Pids is ignored when sampling all processes", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100093FD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Pids is ignored when sampling all processes", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094004()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_10006E988();
  sub_10006EA18((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempted to change sampling interval to %uus while already sampling/sampled at %uus", v2, v3);
  sub_1000301E8();
}

void sub_100094068()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_10006E988();
  sub_10006EA40((void *)&_mh_execute_header, v0, v1, "Attempted to change sampling interval to %uus while already sampling/sampled at %uus", v2, v3);
  sub_1000301E8();
}

void sub_1000940D4()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_10006E988();
  sub_10006EA18((void *)&_mh_execute_header, v0, v1, "Unable to format: Attempted to change occasional data interval to %uus while already sampling/sampled at %uus", v2, v3);
  sub_1000301E8();
}

void sub_100094138()
{
  uint64_t v0;
  os_log_t v1;
  int v2;
  int v3;

  sub_10006E988();
  sub_10006EA40((void *)&_mh_execute_header, v0, v1, "Attempted to change occasional data interval to %uus while already sampling/sampled at %uus", v2, v3);
  sub_1000301E8();
}

void sub_1000941A4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Asked to stop sooner than the existing timeout", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094210()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Asked to stop sooner than the existing timeout", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009427C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Asked to stop sooner than the existing timeout", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000942A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Asked to stop sooner than the existing timeout", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000942D4(int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047FF8(a1);
  sub_1000571E4();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Setting sampling timeout for %.2f seconds from now", v3, v4, v5, v6, v7);
}

void sub_100094368(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: Setting sampling timeout for %.2f seconds from now", a5, a6, a7, a8, 0);
  sub_1000301E8();
}

void sub_1000943D0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Lost race: already done sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009443C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Lost race: already done sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000944A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Lost race: already done sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000944D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Lost race: already done sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094500()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Monitoring timeout was extended, doing nothing", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009456C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Monitoring timeout was extended, doing nothing", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000945D8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Monitoring timeout was extended, doing nothing", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094604()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Monitoring timeout was extended, doing nothing", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094630()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Monitoring timed out", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009469C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Monitoring timed out", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094708()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Monitoring timed out", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094734()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Monitoring timed out", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094760()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_10006E948();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Must provide both queue and block", v3, v4, v5, v6, v7);
  sub_10006E9A0();
}

void sub_1000947DC()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047FF8(v0);
  sub_10006E948();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Must provide both queue and block", v3, v4, v5, v6, v7);
  sub_10006E9A0();
}

void sub_100094858(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: Must provide both queue and block", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000948C8(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: Must provide both queue and block", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100094938()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to allocate proc exit dispatch source", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000949A4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to allocate proc exit dispatch source", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094A10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to allocate proc exit dispatch source", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094A3C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to allocate proc exit dispatch source", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094A68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Can't stop when kernel exits", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094A94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: No target process to monitor for exiting", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094AC0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: exited", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094B2C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: exited", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094B98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: exited", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094BC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "exited", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094BF0(int *a1)
{
  void *v1;
  os_log_t v2;
  os_log_type_t v3;
  const char *v4;
  uint8_t *v5;

  sub_10006E930(a1);
  sub_1000571E4();
  sub_10006EA54();
  _os_log_fault_impl(v1, v2, v3, v4, v5, 0x18u);
  sub_100047FE4();
}

void sub_100094C80(int *a1, unsigned __int8 a2, NSObject *a3)
{
  _DWORD *v6;
  int v7;
  int v8;
  _DWORD *v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;

  v6 = sub_10006E930(a1);
  v7 = *a1;
  v8 = 136446722;
  v9 = v6;
  v10 = 1024;
  v11 = v7;
  v12 = 1024;
  v13 = a2;
  _os_log_debug_impl((void *)&_mh_execute_header, a3, OS_LOG_TYPE_DEBUG, "%{public}s [%d]: Already not sampling when stopped with reason %d", (uint8_t *)&v8, 0x18u);
  sub_100047FE4();
}

void sub_100094D2C(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Already not sampling when stopped with reason %d", (uint8_t *)v2, 8u);
  sub_100047E4C();
}

void sub_100094D9C(unsigned __int8 a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_debug_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_DEBUG, "Already not sampling when stopped with reason %d", (uint8_t *)v2, 8u);
  sub_100047E4C();
}

void sub_100094E10()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: No HID event required", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094E7C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: No HID event required", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094EE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: No HID event required", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094F14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "No HID event required", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094F40()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Canceling spin with no HID event where process exited", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100094FAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Canceling spin with no HID event where process exited", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100094FD8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Received HID event, reporting spin", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095044()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Received HID event, reporting spin", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000950B0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Received HID event, reporting spin", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000950DC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Received HID event, reporting spin", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095108()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Canceling spin with no HID event in its time range", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095174()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Canceling spin with no HID event in its time range", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000951A0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Timed out waiting for HID event, canceling spin", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009520C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Timed out waiting for HID event, canceling spin", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095238()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Waiting for HID event...", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000952A4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Waiting for HID event...", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000952D0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Removing self from processes waiting on HID event list", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009533C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E920(v0);
  sub_10006E93C();
  sub_1000571E4();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Removing self from processes waiting on HID event list", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000953A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Removing self from processes waiting on HID event list", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000953D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Removing self from processes waiting on HID event list", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095400()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_1000302B4(*(_DWORD *)(*(_QWORD *)v0 + 72));
  sub_10006E93C();
  sub_10006E948();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: %s: Mismatched sample providers", v3, v4, v5, v6, v7);
  sub_10006E9A0();
}

void sub_100095488()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_1000302B4(*(_DWORD *)(*(_QWORD *)v0 + 72));
  sub_10006E93C();
  sub_10006E948();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s [%d]: %s: Mismatched sample providers", v3, v4, v5, v6, v7);
  sub_10006E9A0();
}

void sub_10009550C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a1, a3, "Unable to format: %s: Mismatched sample providers", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_10009557C(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D900((void *)&_mh_execute_header, a1, a3, "%s: Mismatched sample providers", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_1000955EC()
{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;
  int v5;

  sub_10006EA70(__stack_chk_guard);
  LODWORD(v2) = 136315906;
  sub_10006E9D0();
  sub_10006EA2C((void *)&_mh_execute_header, v0, v1, "%s: save report fail %d %d %d", v2, v3, v4, v5);
}

void sub_10009565C()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_10006E930(v0);
  sub_1000571E4();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Waiting for sampling to complete", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000956C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Waiting for sampling to complete", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000956F4()
{
  uint64_t v0;
  os_log_t v1;
  const char *v2;
  int v3;
  int v4;
  int v5;

  sub_10006EA70(__stack_chk_guard);
  LODWORD(v2) = 136315906;
  sub_10006E9D0();
  sub_10006EA2C((void *)&_mh_execute_header, v0, v1, "%s: save report fail %d %d %d", v2, v3, v4, v5);
}

void sub_100095764()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to create SPSampledProcess", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000957CC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to create SPSampledProcess", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095834()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to create SPSampledProcess", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095860()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Unable to create SPSampledProcess", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009588C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Failed to start sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000958F4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Failed to start sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009595C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Failed to start sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095988()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Failed to start sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000959B4()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Not overriding existing sampling callback", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095A1C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Not overriding existing sampling callback", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095A84()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Not overriding existing sampling callback", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095AB0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Not overriding existing sampling callback", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095ADC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling with incompatible parameters", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095B44()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already sampling with incompatible parameters", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095BAC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling with incompatible parameters", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095BD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Already sampling with incompatible parameters", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095C04()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling, not overriding existing callback", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095C6C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already sampling, not overriding existing callback", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095CD4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling, not overriding existing callback", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095D00()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Already sampling, not overriding existing callback", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095D2C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling, overriding existing callback", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095D94()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DB4((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Already sampling, overriding existing callback", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095DFC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling, overriding existing callback", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095E28()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Already sampling, overriding existing callback", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095E54()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Already sampling with sensitive strings", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_100095EBC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling with sensitive strings", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100095EE8(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100047E54(a1);
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: Unable to find existing %sWindowServer-based sampled process", v3, v4, v5, v6, 2u);
  sub_100047C98();
}

void sub_100095F78(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100047E54(a1);
  sub_100047F1C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: Unable to find existing %sWindowServer-based sampled process", v3, v4, v5, v6, 2u);
  sub_100047C98();
}

void sub_100096020(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10003D8E4((void *)&_mh_execute_header, a2, a3, "Unable to format: Unable to find existing %sWindowServer-based sampled process", a5, a6, a7, a8, 2u);
  sub_1000301E8();
}

void sub_100096084(char a1, NSObject *a2, uint64_t a3)
{
  const char *v3;
  int v4;
  const char *v5;

  v3 = "";
  if ((a1 & 1) != 0)
    v3 = "non-";
  v4 = 136315138;
  v5 = v3;
  sub_10006EA0C((void *)&_mh_execute_header, a2, a3, "Unable to find existing %sWindowServer-based sampled process", (uint8_t *)&v4);
  sub_1000301E8();
}

void sub_100096104()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_100047DA0((void *)&_mh_execute_header, v1, v2, "Unable to format: %s [%d]: process doesn't exist, not sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_10009616C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  sub_100047E28();
  sub_100047E44(v0);
  sub_100047CF0();
  sub_10004805C((void *)&_mh_execute_header, v1, v2, "%{public}s [%d]: process doesn't exist, not sampling", v3, v4, v5, v6, v7);
  sub_100047D94();
}

void sub_1000961D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: process doesn't exist, not sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096200()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "process doesn't exist, not sampling", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009622C()
{
  int v0;
  int *v1;
  void *v2;
  os_log_t v3;
  os_log_type_t v4;
  const char *v5;
  uint8_t *v6;

  sub_100047E28();
  sub_100047E54(v0);
  __error();
  v1 = __error();
  strerror(*v1);
  sub_100047FB8();
  sub_10006EA54();
  _os_log_fault_impl(v2, v3, v4, v5, v6, 0x22u);
  sub_100047C98();
}

void sub_1000962B8()
{
  NSObject *v0;
  int v1;
  int *v2;
  uint8_t v3[40];

  sub_100047E28();
  sub_100047E54(v1);
  __error();
  v2 = __error();
  strerror(*v2);
  sub_100047FB8();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s [%d]: Unable to get path: %d (%s)", v3, 0x22u);
  sub_100047C98();
}

void sub_10009634C(uint64_t a1, void *a2)
{
  NSObject *v2;
  unsigned int *v3;
  uint8_t *v4;
  unsigned int v5;

  v5 = sub_10007518C(a1, a2);
  *(_DWORD *)v4 = 67109120;
  *v3 = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_FAULT, "Unable to format: pid %d doesn't exist", v4, 8u);
  sub_10005386C();
}

void sub_10009639C(uint64_t a1, void *a2)
{
  NSObject *v2;
  unsigned int *v3;
  uint8_t *v4;
  unsigned int v5;

  v5 = sub_10007518C(a1, a2);
  *(_DWORD *)v4 = 67109120;
  *v3 = v5;
  _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "pid %d doesn't exist", v4, 8u);
  sub_10005386C();
}

void sub_1000963EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000497A8();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Stackshot failed: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096450()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000497A8();
  sub_100048108((void *)&_mh_execute_header, v0, v1, "Stackshot failed: %d", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000964B4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Created shared SPStackshotProvider", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000964E0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Created shared SPStackshotProvider", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009650C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Avoiding inspecting live processes for stackshot report due to audio running", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096538()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  sub_1000751D8(__stack_chk_guard);
  v2[0] = 136315394;
  sub_1000751B8();
  sub_10004CE54((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Still have %d clients sampling when dealloc'ed", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_1000965A8()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  sub_1000751D8(__stack_chk_guard);
  v2[0] = 136315394;
  sub_1000751B8();
  sub_10004CE80((void *)&_mh_execute_header, v0, v1, "%s: Still have %d clients sampling when dealloc'ed", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_100096618(uint64_t a1, _DWORD *a2, int a3)
{
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  *a2 = 136315650;
  sub_10007516C(a1, (uint64_t)a2, a3);
  sub_1000751CC((void *)&_mh_execute_header, v5, v3, "Unable to format: %s: Unable to create sampling thread: %d (%s)", v4);
}

void sub_100096660(uint64_t a1, _DWORD *a2, int a3)
{
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  *a2 = 136315650;
  sub_10007516C(a1, (uint64_t)a2, a3);
  sub_1000751F8((void *)&_mh_execute_header, v5, v3, "%s: Unable to create sampling thread: %d (%s)", v4);
}

void sub_1000966A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Starting sampling thread", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000966D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already have a sampling thread", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096700()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Already have a sampling thread", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009672C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling completed, waiting for SIGINFO...", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096758(_DWORD *a1, uint64_t a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  *a1 = 136315394;
  sub_1000751E4((uint64_t)a1, a2, (uint64_t)"stackshotData.length < 4294967295U");
  sub_10007515C((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: bad stackshot data length %lu", v4);
}

void sub_100096798(_DWORD *a1, uint64_t a2)
{
  os_log_t v2;
  uint8_t *v3;

  *a1 = 136315394;
  sub_1000751E4((uint64_t)a1, a2, (uint64_t)"stackshotData.length < 4294967295U");
  _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%s: bad stackshot data length %lu", v3, 0x16u);
}

void sub_1000967E4(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: Unable to update sampling pid list", v3);
}

void sub_100096810(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100075150((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to update sampling pid list", v3);
}

void sub_10009683C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: failed to set sampling thread's priority", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096868()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "failed to set sampling thread's priority", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096894()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: failed to set the sampling thread to a fixed-priority policy", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000968C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "failed to set the sampling thread to a fixed-priority policy", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000968EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: No sampling thread to stop", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096918()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "No sampling thread to stop", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096944()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Stopping sampling thread", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096970()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling completed, generating report...", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009699C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling completed, processing symbols...", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000969C8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling completed, waiting for SIGINFO...", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000969F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: shared instance has 0 references", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096A20()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "shared instance has 0 references", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096A4C(uint64_t a1, uint64_t a2, uint64_t a3, NSObject *a4)
{
  *(_DWORD *)a2 = 138412546;
  *(_QWORD *)(a2 + 4) = a1;
  *(_WORD *)(a2 + 12) = 1024;
  *(_DWORD *)(a2 + 14) = a3;
  sub_10004CE54((void *)&_mh_execute_header, a4, a3, "Unable to format: No one's sampling when requested to adjust sampling target to %@ %d", (uint8_t *)a2);
}

void sub_100096A98(uint64_t a1, char a2, uint64_t a3, NSObject *a4)
{
  *(_DWORD *)a3 = 138543618;
  *(_QWORD *)(a3 + 4) = a1;
  *(_WORD *)(a3 + 12) = 1024;
  *(_DWORD *)(a3 + 14) = a2 & 1;
  sub_10004CE80((void *)&_mh_execute_header, a4, a3, "No one's sampling when requested to adjust sampling target to %{public}@ %d", (uint8_t *)a3);
}

void sub_100096AE8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Changing to sampling everything", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096B14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Upping sampling to include non-main threads", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096B40(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(_QWORD *)(a2 + 4) = a1;
  sub_10003D8F4((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unable to format: Changing to sampling %s also", (uint8_t *)a2);
}

void sub_100096B7C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Sampling everything", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096BA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Sampling everything", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096BD4(uint64_t a1, uint64_t a2, NSObject *a3)
{
  *(_DWORD *)a2 = 136315138;
  *(_QWORD *)(a2 + 4) = a1;
  sub_10003D8F4((void *)&_mh_execute_header, a3, (uint64_t)a3, "Unable to format: Sampling only %s", (uint8_t *)a2);
}

void sub_100096C10()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Caught a sampling provider that isn't sampling, but has already sampled", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096C3C()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100075150((void *)&_mh_execute_header, v0, v1, "Caught a sampling provider that isn't sampling, but has already sampled", v2);
  sub_100047E4C();
}

void sub_100096C6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Already sampling with sensitive strings, so can't start monitoring since we don't want sensitive strings", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096C98()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100075150((void *)&_mh_execute_header, v0, v1, "Already sampling with sensitive strings, so can't start monitoring since we don't want sensitive strings", v2);
  sub_100047E4C();
}

void sub_100096CC8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000497A8();
  sub_100048118((void *)&_mh_execute_header, v0, v1, "Unable to format: Turned on occasional data gathering at %us-intervals for additional client", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096D2C()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000751D8(__stack_chk_guard);
  sub_1000751A0();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "Unable to format: Already sampling with %uus-interval stackshots and %us-interval occasional data", v1, 0xEu);
  sub_1000301E8();
}

void sub_100096DA0()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000751D8(__stack_chk_guard);
  sub_1000751A0();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Already sampling with %uus-interval stackshots and %us-interval occasional data", v1, 0xEu);
  sub_1000301E8();
}

void sub_100096E14()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Stackshot provider shared instance done", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096E40()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Stackshot provider shared instance done", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096E6C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Stackshot provider shared instance not yet done", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096E98()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047E34((void *)&_mh_execute_header, v0, v1, "Stackshot provider shared instance not yet done", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096EC4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: shared instance isn't self", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096EF0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "shared instance isn't self", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100096F1C(uint64_t a1, NSObject *a2)
{
  int *v3;
  uint64_t v4;
  uint8_t v5[40];

  __error();
  v3 = __error();
  strerror(*v3);
  sub_100047E84();
  sub_1000751CC((void *)&_mh_execute_header, a2, v4, "Unable to format: Unable to open %s to save stackshots: %d (%s)", v5);
  sub_100047C98();
}

void sub_100096FA8(uint64_t a1, NSObject *a2)
{
  int *v3;
  uint64_t v4;
  uint8_t v5[40];

  __error();
  v3 = __error();
  strerror(*v3);
  sub_100047E84();
  sub_1000751F8((void *)&_mh_execute_header, a2, v4, "Unable to open %s to save stackshots: %d (%s)", v5);
  sub_100047C98();
}

void sub_100097034(uint64_t a1, NSObject *a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 136315138;
  v4 = a1;
  sub_10003D8F4((void *)&_mh_execute_header, a2, a3, "Unable to format: Saving stackshots to %s", (uint8_t *)&v3);
  sub_1000301E8();
}

void sub_10009709C()
{
  int v0;
  os_log_t v1;
  uint8_t v2[24];

  sub_100047EA8();
  sub_10007515C((void *)&_mh_execute_header, v0, v1, "Unable to format: filePath %s cut off with date (needed %zu chars)", v2);
  sub_1000301E8();
}

void sub_100097100()
{
  int v0;
  os_log_t v1;
  uint8_t v2[24];

  sub_100047EA8();
  sub_10007515C((void *)&_mh_execute_header, v0, v1, "filePath %s cut off with date (needed %zu chars)", v2);
  sub_1000301E8();
}

void sub_100097164(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100053800((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to format: Unable to cache load info", v3);
}

void sub_100097190(_BYTE *a1, _BYTE *a2)
{
  NSObject *v2;
  uint8_t *v3;

  sub_10005380C(a1, a2);
  sub_100075150((void *)&_mh_execute_header, v2, (uint64_t)v2, "Unable to cache load info", v3);
}

void sub_1000971BC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Unable to process samples fast enough, throttling sampling rate to avoid bloating memory. Use -noThrottle to avoid this.", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000971E8()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[16];

  sub_100047EC8();
  sub_100075150((void *)&_mh_execute_header, v0, v1, "Unable to process samples fast enough, throttling sampling rate to avoid bloating memory. Use -noThrottle to avoid this.", v2);
  sub_100047E4C();
}

void sub_100097218()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: ERROR trying to create sample store from %s: Unknown error", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100097278()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10003D954();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "ERROR trying to create sample store from %s: Unknown error", v1, 0xCu);
  sub_1000301E8();
}

void sub_1000972E4()
{
  uint64_t v0;
  os_log_t v1;

  sub_100060C48(__stack_chk_guard);
  sub_10005382C();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: ERROR trying to create sample store from %s: %@");
  sub_1000301E8();
}

void sub_100097344()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100060C48(__stack_chk_guard);
  sub_10005382C();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "ERROR trying to create sample store from %s: %@", v1, 0x16u);
  sub_1000301E8();
}

void sub_1000973B4(os_log_t log)
{
  uint8_t v1[16];

  *(_WORD *)v1 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: Avoiding inspecting live processes for tailspin file due to audio running", v1, 2u);
}

void sub_1000973F4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_10003D954();
  sub_10003D8E4((void *)&_mh_execute_header, v0, v1, "Unable to format: Could not open %s as a ktrace file for unknown reason", v2, v3, v4, v5, v6);
  sub_1000301E8();
}

void sub_100097454()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_10003D954();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Could not open %s as a ktrace file for unknown reason", v1, 0xCu);
  sub_1000301E8();
}

void sub_1000974C0()
{
  uint64_t v0;
  os_log_t v1;

  sub_100060C48(__stack_chk_guard);
  sub_10005382C();
  sub_100047E14((void *)&_mh_execute_header, v0, v1, "Unable to format: Could not open %s as a ktrace file: %@");
  sub_1000301E8();
}

void sub_100097520()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_100060C48(__stack_chk_guard);
  sub_10005382C();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Could not open %s as a ktrace file: %@", v1, 0x16u);
  sub_1000301E8();
}

void sub_100097590(void *a1, uint64_t a2, NSObject *a3)
{
  uint64_t v4;
  int v5[10];

  objc_msgSend(objc_msgSend(a1, "debugDescription"), "UTF8String");
  objc_msgSend(sub_100082F4C(), "UTF8String");
  v5[0] = 136315650;
  sub_100082F14();
  sub_100082F08((void *)&_mh_execute_header, a3, v4, "Unable to format: %s: bodies (%s) and angle bracket contents (%s)", (uint8_t *)v5);
  sub_100047C98();
}

void sub_100097624(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  objc_msgSend(objc_msgSend(a1, "debugDescription"), "UTF8String");
  objc_msgSend(sub_100082F4C(), "UTF8String");
  sub_100082F14();
  sub_100048084((void *)&_mh_execute_header, v1, v2, "%s: bodies (%s) and angle bracket contents (%s)", v3, v4, v5, v6, 2u);
  sub_100047C98();
}

void sub_1000976B0(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136315138;
  v2 = "bodies || angleBracketContents || stateInfo";
  _os_log_fault_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_FAULT, "Unable to format: %s: No frame bodies, state, nor angle bracket contents", (uint8_t *)&v1, 0xCu);
  sub_1000301E8();
}

void sub_10009772C(os_log_t log)
{
  int v1;
  const char *v2;

  v1 = 136315138;
  v2 = "bodies || angleBracketContents || stateInfo";
  _os_log_error_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_ERROR, "%s: No frame bodies, state, nor angle bracket contents", (uint8_t *)&v1, 0xCu);
  sub_1000301E8();
}

void sub_1000977A8()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_100097828()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint8_t v7;

  __error();
  v0 = __error();
  sub_100047F14(v0);
  sub_100047E84();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "Unable to open %s: %d (%s)", v3, v4, v5, v6, v7);
  sub_100047C98();
}

void sub_1000978A8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: No report version. Not a spindump file?", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_1000978D4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: No report version. Not a spindump file?", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097900()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to parse text of the report: spindump report version 20+ required", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_10009792C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Unable to parse text of the report: spindump report version 20+ required", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097958()
{
  _DWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  *v0 = 136315650;
  sub_100082F30(v1, (uint64_t)v0, v2);
  sub_100082F08((void *)&_mh_execute_header, v5, v3, "Unable to format: %s: Unable to compile regex %s: %s", v4);
}

void sub_10009799C()
{
  _DWORD *v0;
  uint64_t v1;
  uint64_t v2;
  uint8_t *v3;
  os_log_t v4;

  sub_10003D984();
  *v0 = 136315650;
  sub_100082F30(v1, (uint64_t)v0, v2);
  _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%s: Unable to compile regex %s: %s", v3, 0x20u);
}

void sub_1000979E8(uint64_t a1, _DWORD *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  *a2 = 136315394;
  sub_100082E90(a1, (uint64_t)a2, (uint64_t)"regex");
  sub_10007515C((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: Unable to compile regex %s", v4);
}

void sub_100097A28(uint64_t a1, _DWORD *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  *a2 = 136315394;
  sub_100082E90(a1, (uint64_t)a2, (uint64_t)"regex");
  sub_100082ED8((void *)&_mh_execute_header, v2, v3, "%s: Unable to compile regex %s", v4);
}

void sub_100097A68()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to find any Binary Images", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097A94()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Unable to find any Binary Images", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097AC0(uint64_t a1, _DWORD *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  *a2 = 136315394;
  sub_100082E90(a1, (uint64_t)a2, (uint64_t)"heaviestNode.angleBracketContents || heaviestNode.stateInfo");
  sub_10007515C((void *)&_mh_execute_header, v2, v3, "Unable to format: %s: No angle bracket contents nor state info for non-frame (%s)", v4);
}

void sub_100097B00(uint64_t a1, _DWORD *a2)
{
  int v2;
  os_log_t v3;
  uint8_t *v4;

  *a2 = 136315394;
  sub_100082E90(a1, (uint64_t)a2, (uint64_t)"heaviestNode.angleBracketContents || heaviestNode.stateInfo");
  sub_100082ED8((void *)&_mh_execute_header, v2, v3, "%s: No angle bracket contents nor state info for non-frame (%s)", v4);
}

void sub_100097B40()
{
  _DWORD *v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  *v0 = 136315650;
  sub_10007516C(v1, (uint64_t)v0, v2);
  sub_1000751CC((void *)&_mh_execute_header, v5, v3, "Unable to format: %s: Non-frame line has count but no indent level (%d: %s)", v4);
}

void sub_100097B84()
{
  _DWORD *v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  *v0 = 136315650;
  sub_10007516C(v1, (uint64_t)v0, v2);
  sub_1000751F8((void *)&_mh_execute_header, v5, v3, "%s: Non-frame line has count but no indent level (%d: %s)", v4);
}

void sub_100097BC8()
{
  _DWORD *v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  *v0 = 136315650;
  sub_10007516C(v1, (uint64_t)v0, v2);
  sub_1000751CC((void *)&_mh_execute_header, v5, v3, "Unable to format: %s: frame match with no count (%d: %s)", v4);
}

void sub_100097C0C()
{
  _DWORD *v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  *v0 = 136315650;
  sub_10007516C(v1, (uint64_t)v0, v2);
  sub_1000751F8((void *)&_mh_execute_header, v5, v3, "%s: frame match with no count (%d: %s)", v4);
}

void sub_100097C50()
{
  _DWORD *v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  *v0 = 136315650;
  sub_10007516C(v1, (uint64_t)v0, v2);
  sub_1000751CC((void *)&_mh_execute_header, v5, v3, "Unable to format: %s: frame match with no count and whitespace (%d: %s)", v4);
}

void sub_100097C94()
{
  _DWORD *v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  *v0 = 136315650;
  sub_10007516C(v1, (uint64_t)v0, v2);
  sub_1000751F8((void *)&_mh_execute_header, v5, v3, "%s: frame match with no count and whitespace (%d: %s)", v4);
}

void sub_100097CD8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Symbolicating...", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097D04()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Stacks will be filtered to the sample index range specified, but process and thread summary information and timestamps will still reflect full time range", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097D30()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Original report is not in timeline mode, so unable to filter to start/end indexes", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097D5C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Original report is not in timeline mode, so unable to filter to start/end indexes", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097D88()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Original report is not in timeline mode, so unable to output timeline mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097DB4()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_10004C534((void *)&_mh_execute_header, v0, v1, "Parsing spindump text: Original report is not in timeline mode, so unable to output timeline mode", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097DE0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to detect incremental indentation, using 2", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097E0C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Unable to detect initial indentation, using 2", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097E38()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  sub_10004CF58(v0, v1, v2, 1.5047e-36);
  sub_10004CE54((void *)&_mh_execute_header, v5, v3, "Unable to format: Parsing spindump text requires a seekable file: %d (%s)", v4);
}

void sub_100097E70()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint8_t *v4;
  NSObject *v5;

  sub_10003D984();
  sub_10004CF58(v0, v1, v2, 1.5047e-36);
  sub_10004CE80((void *)&_mh_execute_header, v5, v3, "Parsing spindump text requires a seekable file: %d (%s)", v4);
}

void sub_100097EA8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_100047EC8();
  sub_100047DFC((void *)&_mh_execute_header, v0, v1, "Unable to format: Parsing spindump text: Detected condensed report variant", v2, v3, v4, v5, v6);
  sub_100047E4C();
}

void sub_100097ED4()
{
  os_log_t v0;
  uint8_t v1[16];

  sub_100047EC8();
  _os_log_debug_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEBUG, "Parsing spindump text: Detected condensed report variant", v1, 2u);
  sub_100047E4C();
}

void sub_100097F0C()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  sub_100082EA4(__stack_chk_guard);
  v2[0] = 136315394;
  sub_1000751B8();
  sub_10004CE54((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: Unable to allocate %d buffer", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_100097F7C()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  sub_100082EA4(__stack_chk_guard);
  v2[0] = 136315394;
  sub_1000751B8();
  sub_10004CE80((void *)&_mh_execute_header, v0, v1, "%s: Unable to allocate %d buffer", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_100097FEC()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  sub_100082EA4(__stack_chk_guard);
  v2[0] = 136315394;
  sub_1000751B8();
  sub_10004CE54((void *)&_mh_execute_header, v0, v1, "Unable to format: %s: bufSize overflow (%d)", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_10009805C()
{
  NSObject *v0;
  uint64_t v1;
  int v2[6];

  sub_100082EA4(__stack_chk_guard);
  v2[0] = 136315394;
  sub_1000751B8();
  sub_10004CE80((void *)&_mh_execute_header, v0, v1, "%s: bufSize overflow (%d)", (uint8_t *)v2);
  sub_1000301E8();
}

void sub_1000980CC()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: load info has binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098140()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: load info has binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_1000981B4()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: frame regex returned binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098228()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: frame regex returned binary but no offset into binary (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_10009829C()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100082EC0();
  sub_10004CE54((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: Parsing spindump text: Unable to find load info for (%d: %@)", v1);
  sub_1000301E8();
}

void sub_100098304()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100082EC0();
  sub_10004CE80((void *)&_mh_execute_header, v0, (uint64_t)v0, "Parsing spindump text: Unable to find load info for (%d: %@)", v1);
  sub_1000301E8();
}

void sub_10009836C()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: frame match with no count and whitespace (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_1000983E0()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: frame match with no count and whitespace (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098454()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  __error();
  v0 = __error();
  strerror(*v0);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: ftello failed: %d (%s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_1000984E0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  __error();
  v0 = __error();
  sub_100047F14(v0);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: ftello failed: %d (%s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098564()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100082EC0();
  sub_10004CE54((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: Parsing spindump text: No load infos, ended at line (%d: %@)", v1);
  sub_1000301E8();
}

void sub_1000985CC()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100082EC0();
  sub_10004CE54((void *)&_mh_execute_header, v0, (uint64_t)v0, "Unable to format: Parsing spindump text: Unexpected line in load infos, ignoring (%d: %@)", v1);
  sub_1000301E8();
}

void sub_100098634()
{
  NSObject *v0;
  uint8_t v1[24];

  sub_100082EC0();
  sub_10004CE80((void *)&_mh_execute_header, v0, (uint64_t)v0, "Parsing spindump text: Unexpected line in load infos, ignoring (%d: %@)", v1);
  sub_1000301E8();
}

void sub_10009869C()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: No uuid in load info (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098710()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: No uuid in load info (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098784()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: No UUID in (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_1000987F8()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: No UUID in (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_10009886C()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: Parsing spindump text: No binary index (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_1000988E0()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: Parsing spindump text: No binary index (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098954(void *a1, NSObject *a2)
{
  id v4;
  id v5;
  int v6;
  id v7;
  __int16 v8;
  id v9;

  v4 = objc_msgSend(a1, "uuid");
  v5 = objc_msgSend(a1, "path");
  if (!v5)
    v5 = objc_msgSend(a1, "name");
  v6 = 138412546;
  v7 = v4;
  v8 = 2112;
  v9 = v5;
  _os_log_fault_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_FAULT, "Unable to format: Parsing spindump text: Unable to find symbol owner for %@ %@", (uint8_t *)&v6, 0x16u);
}

void sub_100098A0C(uint64_t a1, id *a2, NSObject *a3)
{
  uint64_t v4;
  uint8_t v5[40];

  sub_100082F58(a1, a2);
  sub_100082F64();
  sub_100082EE8();
  sub_100082F08((void *)&_mh_execute_header, a3, v4, "Unable to format: Parsing spindump text: Unable to find segment %@ in %@ %@", v5);
  sub_100047C98();
}

void sub_100098A8C(uint64_t a1, id *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  sub_100082F58(a1, a2);
  sub_100082F64();
  sub_100082EE8();
  sub_100048084((void *)&_mh_execute_header, v2, v3, "Parsing spindump text: Unable to find segment %@ in %@ %@", v4, v5, v6, v7, v8);
  sub_100047C98();
}

void sub_100098B04()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047CDC((void *)&_mh_execute_header, v1, v2, "Unable to format: %s: frame match with no whitespace indent (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

void sub_100098B78()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_100053860();
  sub_100082EB8(v0, __stack_chk_guard);
  sub_100082E70();
  sub_100047F30((void *)&_mh_execute_header, v1, v2, "%s: frame match with no whitespace indent (%d: %s)", v3, v4, v5, v6, 2u);
  sub_10006E9A0();
}

id objc_msgSend_JSONObjectWithData_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "JSONObjectWithData:options:error:");
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UTF8String");
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UUID");
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UUIDString");
}

id objc_msgSend__performSamplePrinterWork_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_performSamplePrinterWork:");
}

id objc_msgSend__samplePrinterForSampleStore_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_samplePrinterForSampleStore:");
}

id objc_msgSend__saveReportToStream_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_saveReportToStream:");
}

id objc_msgSend__setupSampleStore_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_setupSampleStore:");
}

id objc_msgSend_adamID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "adamID");
}

id objc_msgSend_addAuxiliaryData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addAuxiliaryData:");
}

id objc_msgSend_addDscSymDir_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addDscSymDir:");
}

id objc_msgSend_addDsymPaths_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addDsymPaths:");
}

id objc_msgSend_addKCDataStackshot_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addKCDataStackshot:");
}

id objc_msgSend_addKCDataStackshots_createSeparateSamplePerStackshot_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addKCDataStackshots:createSeparateSamplePerStackshot:");
}

id objc_msgSend_addMicrostackshotsFromData_ofTypes_inTimeRangeStart_end_onlyPid_onlyTid_statistics_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addMicrostackshotsFromData:ofTypes:inTimeRangeStart:end:onlyPid:onlyTid:statistics:");
}

id objc_msgSend_addObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addObject:");
}

id objc_msgSend_addPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addPath:");
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allKeys");
}

id objc_msgSend_allSampledProcesses(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allSampledProcesses");
}

id objc_msgSend_allSignpostTrackers(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allSignpostTrackers");
}

id objc_msgSend_appendBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendBytes:length:");
}

id objc_msgSend_appendFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendFormat:");
}

id objc_msgSend_appendString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendString:");
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "array");
}

id objc_msgSend_arrayWithContentsOfURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithContentsOfURL:error:");
}

id objc_msgSend_auxiliaryDataForTimestamp_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "auxiliaryDataForTimestamp:");
}

id objc_msgSend_binaryVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "binaryVersion");
}

id objc_msgSend_binaryWithUUID_absolutePath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "binaryWithUUID:absolutePath:");
}

id objc_msgSend_bundleIdentifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bundleIdentifier");
}

id objc_msgSend_bundleName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bundleName");
}

id objc_msgSend_bundleShortVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bundleShortVersion");
}

id objc_msgSend_bundleVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bundleVersion");
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bytes");
}

id objc_msgSend_bytes_duplicate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bytes_duplicate");
}

id objc_msgSend_bytes_missing_load_info(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bytes_missing_load_info");
}

id objc_msgSend_bytes_not_microstackshots(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bytes_not_microstackshots");
}

id objc_msgSend_bytes_out_of_order(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bytes_out_of_order");
}

id objc_msgSend_cacheLoadInfoForProcess_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "cacheLoadInfoForProcess:");
}

id objc_msgSend_cacheSymbolOwnerWithOptions_pid_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "cacheSymbolOwnerWithOptions:pid:");
}

id objc_msgSend_callTreeAggregation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "callTreeAggregation");
}

id objc_msgSend_callTreeSortAttributes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "callTreeSortAttributes");
}

id objc_msgSend_callTreeTimestampsTimeDomain(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "callTreeTimestampsTimeDomain");
}

id objc_msgSend_canOpenFileAsKTraceFile_errorOut_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "canOpenFileAsKTraceFile:errorOut:");
}

id objc_msgSend_category(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "category");
}

id objc_msgSend_clearCoreSymbolicationCaches(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "clearCoreSymbolicationCaches");
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "code");
}

id objc_msgSend_cohortID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "cohortID");
}

id objc_msgSend_columnNum(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "columnNum");
}

id objc_msgSend_compare_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "compare:");
}

id objc_msgSend_componentsJoinedByString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "componentsJoinedByString:");
}

id objc_msgSend_containsObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "containsObject:");
}

id objc_msgSend_containsString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "containsString:");
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copy");
}

id objc_msgSend_copySampledProcessForPid_isWSBased_createIfUnsampled_wasSampled_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copySampledProcessForPid:isWSBased:createIfUnsampled:wasSampled:");
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "count");
}

id objc_msgSend_countByEnumeratingWithState_objects_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "countByEnumeratingWithState:objects:count:");
}

id objc_msgSend_createHIDExitSource(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createHIDExitSource");
}

id objc_msgSend_customOutput(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "customOutput");
}

id objc_msgSend_dataGatheringOptions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataGatheringOptions");
}

id objc_msgSend_dataUsingEncoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataUsingEncoding:");
}

id objc_msgSend_dataUsingEncoding_allowLossyConversion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataUsingEncoding:allowLossyConversion:");
}

id objc_msgSend_dataWithPropertyList_format_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithPropertyList:format:options:error:");
}

id objc_msgSend_debugDescription(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "debugDescription");
}

id objc_msgSend_decimalNumberWithMantissa_exponent_isNegative_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "decimalNumberWithMantissa:exponent:isNegative:");
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "defaultManager");
}

id objc_msgSend_deleteHIDExitSource(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "deleteHIDExitSource");
}

id objc_msgSend_deltaSecondsTo_timeDomainPriorityList_timeDomainUsed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "deltaSecondsTo:timeDomainPriorityList:timeDomainUsed:");
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "description");
}

id objc_msgSend_developerType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "developerType");
}

id objc_msgSend_diagnostic(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "diagnostic");
}

id objc_msgSend_diagnostics(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "diagnostics");
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionary");
}

id objc_msgSend_dictionaryWithObjects_forKeys_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithObjects:forKeys:count:");
}

id objc_msgSend_dispatchQueue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dispatchQueue");
}

id objc_msgSend_dispatchQueueLabel(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dispatchQueueLabel");
}

id objc_msgSend_dispatchQueues(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dispatchQueues");
}

id objc_msgSend_displayBlockedThreads(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "displayBlockedThreads");
}

id objc_msgSend_displayRunnableThreads(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "displayRunnableThreads");
}

id objc_msgSend_distributorID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "distributorID");
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "domain");
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "doubleValue");
}

id objc_msgSend_dropTransaction(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dropTransaction");
}

id objc_msgSend_durationNote(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "durationNote");
}

id objc_msgSend_encodedStringWithError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "encodedStringWithError:");
}

id objc_msgSend_end(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "end");
}

id objc_msgSend_endTime(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "endTime");
}

id objc_msgSend_endTimestamp(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "endTimestamp");
}

id objc_msgSend_enumerateKeysAndObjectsUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateKeysAndObjectsUsingBlock:");
}

id objc_msgSend_enumerateSymbols_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateSymbols:");
}

id objc_msgSend_enumerateTaskStatesBetweenStartTime_startSampleIndex_endTime_endSampleIndex_reverseOrder_block_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateTaskStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:");
}

id objc_msgSend_enumerateTasks_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateTasks:");
}

id objc_msgSend_enumerateThreadStatesBetweenStartTime_startSampleIndex_endTime_endSampleIndex_reverseOrder_block_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateThreadStatesBetweenStartTime:startSampleIndex:endTime:endSampleIndex:reverseOrder:block:");
}

id objc_msgSend_environment(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "environment");
}

id objc_msgSend_error(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "error");
}

id objc_msgSend_event(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "event");
}

id objc_msgSend_eventEnd(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "eventEnd");
}

id objc_msgSend_eventNote(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "eventNote");
}

id objc_msgSend_eventStart(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "eventStart");
}

id objc_msgSend_eventTimeRange(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "eventTimeRange");
}

id objc_msgSend_exceptionWithName_reason_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "exceptionWithName:reason:userInfo:");
}

id objc_msgSend_extraDuration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "extraDuration");
}

id objc_msgSend_fileDescriptor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileDescriptor");
}

id objc_msgSend_fileExistsAtPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileExistsAtPath:");
}

id objc_msgSend_fileName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileName");
}

id objc_msgSend_fileSystemRepresentation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileSystemRepresentation");
}

id objc_msgSend_fileURLWithPath_isDirectory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileURLWithPath:isDirectory:");
}

id objc_msgSend_filterToDisplayTimeIndexStart_end_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "filterToDisplayTimeIndexStart:end:");
}

id objc_msgSend_filterToStartTimeIndex_endTimeIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "filterToStartTimeIndex:endTimeIndex:");
}

id objc_msgSend_filterToTimestampRangeStart_end_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "filterToTimestampRangeStart:end:");
}

id objc_msgSend_finishedSamplingLiveSystem(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "finishedSamplingLiveSystem");
}

id objc_msgSend_firstMatchInString_options_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "firstMatchInString:options:range:");
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "firstObject");
}

id objc_msgSend_firstThreadStateOnOrAfterTime_sampleIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "firstThreadStateOnOrAfterTime:sampleIndex:");
}

id objc_msgSend_gatherLoadInfoForPid_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "gatherLoadInfoForPid:");
}

id objc_msgSend_gatherMachineArchitecture(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "gatherMachineArchitecture");
}

id objc_msgSend_ge_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ge:");
}

id objc_msgSend_getCString_maxLength_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getCString:maxLength:encoding:");
}

id objc_msgSend_gt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "gt:");
}

id objc_msgSend_guessMissingTimesBasedOnTimestamp_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "guessMissingTimesBasedOnTimestamp:");
}

id objc_msgSend_hardwareModel(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hardwareModel");
}

id objc_msgSend_hasAnySpindumpReports(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasAnySpindumpReports");
}

id objc_msgSend_hasPrefix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasPrefix:");
}

id objc_msgSend_hasSourceInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasSourceInfo");
}

id objc_msgSend_hasSuffix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasSuffix:");
}

id objc_msgSend_hasTriggerThresholdCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasTriggerThresholdCount");
}

id objc_msgSend_hasTriggerThresholdDurationSingle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasTriggerThresholdDurationSingle");
}

id objc_msgSend_hasTriggerThresholdDurationSum(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasTriggerThresholdDurationSum");
}

id objc_msgSend_hasTriggerThresholdDurationUnion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasTriggerThresholdDurationUnion");
}

id objc_msgSend_hidEventTimestamp(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hidEventTimestamp");
}

id objc_msgSend_hidEvents(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hidEvents");
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "identifier");
}

id objc_msgSend_incidentUUID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "incidentUUID");
}

id objc_msgSend_includeBinaryFormatInReport(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "includeBinaryFormatInReport");
}

id objc_msgSend_incompleteIntervalStarts(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "incompleteIntervalStarts");
}

id objc_msgSend_indexOfFirstSampleOnOrAfterTimestamp_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "indexOfFirstSampleOnOrAfterTimestamp:");
}

id objc_msgSend_indexOfLastSampleOnOrBeforeTimestamp_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "indexOfLastSampleOnOrBeforeTimestamp:");
}

id objc_msgSend_individuationFieldName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "individuationFieldName");
}

id objc_msgSend_individuationIdentifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "individuationIdentifier");
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "init");
}

id objc_msgSend_initFileURLWithFileSystemRepresentation_isDirectory_relativeToURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initFileURLWithFileSystemRepresentation:isDirectory:relativeToURL:");
}

id objc_msgSend_initFileURLWithPath_isDirectory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initFileURLWithPath:isDirectory:");
}

id objc_msgSend_initForFileParsing(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initForFileParsing");
}

id objc_msgSend_initForLiveSampling(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initForLiveSampling");
}

id objc_msgSend_initWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytes:length:");
}

id objc_msgSend_initWithBytesNoCopy_length_deallocator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytesNoCopy:length:deallocator:");
}

id objc_msgSend_initWithBytesNoCopy_length_encoding_freeWhenDone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytesNoCopy:length:encoding:freeWhenDone:");
}

id objc_msgSend_initWithBytesNoCopy_length_freeWhenDone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytesNoCopy:length:freeWhenDone:");
}

id objc_msgSend_initWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithCapacity:");
}

id objc_msgSend_initWithContentsOfFile_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithContentsOfFile:options:error:");
}

id objc_msgSend_initWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithFormat:");
}

id objc_msgSend_initWithIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithIdentifier:");
}

id objc_msgSend_initWithInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithInt:");
}

id objc_msgSend_initWithObjects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithObjects:");
}

id objc_msgSend_initWithObjectsAndKeys_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithObjectsAndKeys:");
}

id objc_msgSend_initWithPattern_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithPattern:options:error:");
}

id objc_msgSend_initWithPid_isWSBased_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithPid:isWSBased:");
}

id objc_msgSend_initWithReportReason_reportedSignpostTracker_task_timeRange_thread_dispatchQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithReportReason:reportedSignpostTracker:task:timeRange:thread:dispatchQueue:");
}

id objc_msgSend_initWithSampleStore_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithSampleStore:");
}

id objc_msgSend_initWithStackshotProvider_timestamp_numSamples_numSamplesAvoidedDueToAudio_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithStackshotProvider:timestamp:numSamples:numSamplesAvoidedDueToAudio:");
}

id objc_msgSend_initWithTailspin_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithTailspin:error:");
}

id objc_msgSend_initWithUTF8String_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithUTF8String:");
}

id objc_msgSend_initWithUUIDString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithUUIDString:");
}

id objc_msgSend_initWithWorkflowTracker_signpostTracker_diagnostic_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithWorkflowTracker:signpostTracker:diagnostic:");
}

id objc_msgSend_instructionAtOffsetIntoBinary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "instructionAtOffsetIntoBinary:");
}

id objc_msgSend_instructionAtOffsetIntoSegment_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "instructionAtOffsetIntoSegment:");
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "intValue");
}

id objc_msgSend_interrupt(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "interrupt");
}

id objc_msgSend_intervals(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "intervals");
}

id objc_msgSend_io(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "io");
}

id objc_msgSend_isAbsolutePath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isAbsolutePath");
}

id objc_msgSend_isBeta(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isBeta");
}

id objc_msgSend_isComparable_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isComparable:");
}

id objc_msgSend_isEqual_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqual:");
}

id objc_msgSend_isEqualToString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqualToString:");
}

id objc_msgSend_isPidSuspended(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isPidSuspended");
}

id objc_msgSend_isSpindumpFile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isSpindumpFile:");
}

id objc_msgSend_isSubsetOfSet_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isSubsetOfSet:");
}

id objc_msgSend_isUnresponsive(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isUnresponsive");
}

id objc_msgSend_isWSBased(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isWSBased");
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastObject");
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastPathComponent");
}

id objc_msgSend_lastThreadStateOnOrBeforeTime_sampleIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastThreadStateOnOrBeforeTime:sampleIndex:");
}

id objc_msgSend_le_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "le:");
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "length");
}

id objc_msgSend_lengthOfBytesUsingEncoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lengthOfBytesUsingEncoding:");
}

id objc_msgSend_lineNum(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lineNum");
}

id objc_msgSend_localizedDescription(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "localizedDescription");
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "longLongValue");
}

id objc_msgSend_lt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lt:");
}

id objc_msgSend_macf(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "macf");
}

id objc_msgSend_machAbsTime(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "machAbsTime");
}

id objc_msgSend_machAbsTimeSeconds(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "machAbsTimeSeconds");
}

id objc_msgSend_machContTime(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "machContTime");
}

id objc_msgSend_machContTimeNs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "machContTimeNs");
}

id objc_msgSend_machContTimeSeconds(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "machContTimeSeconds");
}

id objc_msgSend_machTimebase(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "machTimebase");
}

id objc_msgSend_mainBinary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "mainBinary");
}

id objc_msgSend_mainBinaryPath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "mainBinaryPath");
}

id objc_msgSend_mainThread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "mainThread");
}

id objc_msgSend_maximumEventDuration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "maximumEventDuration");
}

id objc_msgSend_minusSet_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "minusSet:");
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "mutableCopy");
}

id objc_msgSend_name(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "name");
}

id objc_msgSend_null(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "null");
}

id objc_msgSend_numSamples(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numSamples");
}

id objc_msgSend_numSamplesAvoidedDueToAudio(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numSamplesAvoidedDueToAudio");
}

id objc_msgSend_numSymbols(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numSymbols");
}

id objc_msgSend_num_duplicate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "num_duplicate");
}

id objc_msgSend_num_frames(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "num_frames");
}

id objc_msgSend_num_load_infos(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "num_load_infos");
}

id objc_msgSend_num_microstackshots_filtered_out(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "num_microstackshots_filtered_out");
}

id objc_msgSend_num_missing_load_info(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "num_missing_load_info");
}

id objc_msgSend_num_out_of_order(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "num_out_of_order");
}

id objc_msgSend_numberOfMatchesInString_options_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberOfMatchesInString:options:range:");
}

id objc_msgSend_numberWithBool_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithBool:");
}

id objc_msgSend_numberWithDouble_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithDouble:");
}

id objc_msgSend_numberWithInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithInt:");
}

id objc_msgSend_numberWithInteger_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithInteger:");
}

id objc_msgSend_numberWithUnsignedInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedInt:");
}

id objc_msgSend_numberWithUnsignedLongLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedLongLong:");
}

id objc_msgSend_objectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectAtIndex:");
}

id objc_msgSend_objectAtIndexedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectAtIndexedSubscript:");
}

id objc_msgSend_objectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectForKey:");
}

id objc_msgSend_objectForKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectForKeyedSubscript:");
}

id objc_msgSend_occasionalDataIntervalSec(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "occasionalDataIntervalSec");
}

id objc_msgSend_offsetIntoSegment(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "offsetIntoSegment");
}

id objc_msgSend_omitFramesBelowSampleCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitFramesBelowSampleCount");
}

id objc_msgSend_omitSensitiveStrings(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitSensitiveStrings");
}

id objc_msgSend_omitStacksAboveBasePriority(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitStacksAboveBasePriority");
}

id objc_msgSend_omitStacksBelowBasePriority(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitStacksBelowBasePriority");
}

id objc_msgSend_omitStacksOnAC(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitStacksOnAC");
}

id objc_msgSend_omitStacksOnBattery(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitStacksOnBattery");
}

id objc_msgSend_omitStacksWithUserActive(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitStacksWithUserActive");
}

id objc_msgSend_omitStacksWithUserIdle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "omitStacksWithUserIdle");
}

id objc_msgSend_optIn3rdParty(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "optIn3rdParty");
}

id objc_msgSend_options(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "options");
}

id objc_msgSend_parseKTraceFile_warningsOut_errorOut_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "parseKTraceFile:warningsOut:errorOut:");
}

id objc_msgSend_parseSpindumpFile_andReportToStream_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "parseSpindumpFile:andReportToStream:");
}

id objc_msgSend_parseStackshotsFromKTraceFile_warningsOut_errorOut_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "parseStackshotsFromKTraceFile:warningsOut:errorOut:");
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "path");
}

id objc_msgSend_performSamplePrinterWork_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "performSamplePrinterWork:");
}

id objc_msgSend_performSampleStoreWork_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "performSampleStoreWork:");
}

id objc_msgSend_pid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "pid");
}

id objc_msgSend_pmi(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "pmi");
}

id objc_msgSend_postprocess(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "postprocess");
}

id objc_msgSend_printHeavyStacks(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "printHeavyStacks");
}

id objc_msgSend_printOptions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "printOptions");
}

id objc_msgSend_printToStream_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "printToStream:");
}

id objc_msgSend_processSortAttributes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "processSortAttributes");
}

id objc_msgSend_rangeWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "rangeWithName:");
}

id objc_msgSend_reason(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reason");
}

id objc_msgSend_registerForTaskWithIdentifier_usingQueue_launchHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "registerForTaskWithIdentifier:usingQueue:launchHandler:");
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeAllObjects");
}

id objc_msgSend_removeItemAtURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeItemAtURL:error:");
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeLastObject");
}

id objc_msgSend_removeObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObject:");
}

id objc_msgSend_removeObjectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObjectAtIndex:");
}

id objc_msgSend_removeObjectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObjectForKey:");
}

id objc_msgSend_removeSelfFromPidCache(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeSelfFromPidCache");
}

id objc_msgSend_reportOmittingNetworkBoundIntervals(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportOmittingNetworkBoundIntervals");
}

id objc_msgSend_reportOtherSignpostWithName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportOtherSignpostWithName");
}

id objc_msgSend_reportProcessesWithName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportProcessesWithName");
}

id objc_msgSend_reportReason(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportReason");
}

id objc_msgSend_reportSpindumpForDispatchQueueWithLabel(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportSpindumpForDispatchQueueWithLabel");
}

id objc_msgSend_reportSpindumpForMainThread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportSpindumpForMainThread");
}

id objc_msgSend_reportSpindumpForThisDispatchQueue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportSpindumpForThisDispatchQueue");
}

id objc_msgSend_reportSpindumpForThisThread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportSpindumpForThisThread");
}

id objc_msgSend_reportSpindumpForThreadWithName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportSpindumpForThreadWithName");
}

id objc_msgSend_reportTimeEnd(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportTimeEnd");
}

id objc_msgSend_reportTimeStart(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportTimeStart");
}

id objc_msgSend_reportTimeThreshold(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportTimeThreshold");
}

id objc_msgSend_reportedSignpostTracker(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reportedSignpostTracker");
}

id objc_msgSend_requireHIDEvent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "requireHIDEvent:");
}

id objc_msgSend_sampleCountInSampleIndexRangeStart_end_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleCountInSampleIndexRangeStart:end:");
}

id objc_msgSend_sampleOnlyMainThreads(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleOnlyMainThreads");
}

id objc_msgSend_sampleProcesses_onlyMainThreads_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleProcesses:onlyMainThreads:");
}

id objc_msgSend_sampleStore(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleStore");
}

id objc_msgSend_sampleStoreForFile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleStoreForFile:");
}

id objc_msgSend_sampleStoreForFile_stackshotsOnly_parsePastLastStackshot_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleStoreForFile:stackshotsOnly:parsePastLastStackshot:");
}

id objc_msgSend_sampleStoreForSpindumpFile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleStoreForSpindumpFile:");
}

id objc_msgSend_sampleTimestamps(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sampleTimestamps");
}

id objc_msgSend_samplingIntervalUs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "samplingIntervalUs");
}

id objc_msgSend_samplingMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "samplingMode");
}

id objc_msgSend_saveBinaryFormatToStream_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "saveBinaryFormatToStream:");
}

id objc_msgSend_saveReportToStream_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "saveReportToStream:");
}

id objc_msgSend_segmentWithName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "segmentWithName:");
}

id objc_msgSend_sendDiagnosticReport_forType_forSourceID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sendDiagnosticReport:forType:forSourceID:");
}

id objc_msgSend_set(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "set");
}

id objc_msgSend_setActionTaken_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setActionTaken:");
}

id objc_msgSend_setAttemptedSamplingInterval_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAttemptedSamplingInterval:");
}

id objc_msgSend_setBytesWritten_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setBytesWritten:");
}

id objc_msgSend_setBytesWrittenLimit_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setBytesWrittenLimit:");
}

id objc_msgSend_setBytes_not_microstackshots_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setBytes_not_microstackshots:");
}

id objc_msgSend_setCallTreeAggregation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCallTreeAggregation:");
}

id objc_msgSend_setCallTreeTimestampsTimeDomain_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCallTreeTimestampsTimeDomain:");
}

id objc_msgSend_setCancelOnMemoryPressure_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCancelOnMemoryPressure:");
}

id objc_msgSend_setCpuDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCpuDuration:");
}

id objc_msgSend_setCpuLimit_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCpuLimit:");
}

id objc_msgSend_setCpuLimitDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCpuLimitDuration:");
}

id objc_msgSend_setCpuUsed_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCpuUsed:");
}

id objc_msgSend_setCustomOutput_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCustomOutput:");
}

id objc_msgSend_setDataGatheringOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDataGatheringOptions:");
}

id objc_msgSend_setDateFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDateFormat:");
}

id objc_msgSend_setDisplayBlockedThreads_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDisplayBlockedThreads:");
}

id objc_msgSend_setDisplayBody_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDisplayBody:");
}

id objc_msgSend_setDisplayFooter_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDisplayFooter:");
}

id objc_msgSend_setDisplayHeader_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDisplayHeader:");
}

id objc_msgSend_setDisplayIdleWorkQueueThreads_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDisplayIdleWorkQueueThreads:");
}

id objc_msgSend_setDisplayRunnableThreads_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDisplayRunnableThreads:");
}

id objc_msgSend_setDisplayRunningThreads_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDisplayRunningThreads:");
}

id objc_msgSend_setDsymPaths_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDsymPaths:");
}

id objc_msgSend_setDurationNote_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDurationNote:");
}

id objc_msgSend_setEndIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEndIndex:");
}

id objc_msgSend_setEvent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEvent:");
}

id objc_msgSend_setEventNote_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEventNote:");
}

id objc_msgSend_setEventTimeRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEventTimeRange:");
}

id objc_msgSend_setExpirationHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setExpirationHandler:");
}

id objc_msgSend_setExtraDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setExtraDuration:");
}

id objc_msgSend_setFindDsymsForIDs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setFindDsymsForIDs:");
}

id objc_msgSend_setForceOneBasedTimeIndexes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setForceOneBasedTimeIndexes:");
}

id objc_msgSend_setHeaderNote_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHeaderNote:");
}

id objc_msgSend_setHeaderOnly_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHeaderOnly:");
}

id objc_msgSend_setHwPageSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHwPageSize:");
}

id objc_msgSend_setIncidentUUID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIncidentUUID:");
}

id objc_msgSend_setIncludeBinaryFormatInReport_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIncludeBinaryFormatInReport:");
}

id objc_msgSend_setIncludeTextualFormatInReport_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIncludeTextualFormatInReport:");
}

id objc_msgSend_setIncludeUserIdleAndBatteryStateInStacks_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIncludeUserIdleAndBatteryStateInStacks:");
}

id objc_msgSend_setIsHeavy_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIsHeavy:");
}

id objc_msgSend_setIsUrgent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIsUrgent:");
}

id objc_msgSend_setKPerfPETParsePastLastStackshot_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setKPerfPETParsePastLastStackshot:");
}

id objc_msgSend_setMachTimebase_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setMachTimebase:");
}

id objc_msgSend_setMachineArchitecture_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setMachineArchitecture:");
}

id objc_msgSend_setMainBinaryPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setMainBinaryPath:");
}

id objc_msgSend_setMicrostackshotsFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setMicrostackshotsFormat:");
}

id objc_msgSend_setObject_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setObject:forKey:");
}

id objc_msgSend_setObject_forKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setObject:forKeyedSubscript:");
}

id objc_msgSend_setOccasionalDataIntervalSec_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOccasionalDataIntervalSec:");
}

id objc_msgSend_setOmitFramesBelowSampleCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitFramesBelowSampleCount:");
}

id objc_msgSend_setOmitSensitiveStrings_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitSensitiveStrings:");
}

id objc_msgSend_setOmitStacksAboveBasePriority_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitStacksAboveBasePriority:");
}

id objc_msgSend_setOmitStacksBelowBasePriority_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitStacksBelowBasePriority:");
}

id objc_msgSend_setOmitStacksOnAC_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitStacksOnAC:");
}

id objc_msgSend_setOmitStacksOnBattery_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitStacksOnBattery:");
}

id objc_msgSend_setOmitStacksWithUserActive_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitStacksWithUserActive:");
}

id objc_msgSend_setOmitStacksWithUserIdle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitStacksWithUserIdle:");
}

id objc_msgSend_setOmitTasksBelowPercentOfTotalSamples_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitTasksBelowPercentOfTotalSamples:");
}

id objc_msgSend_setOmitThirdPartyProcessStacks_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOmitThirdPartyProcessStacks:");
}

id objc_msgSend_setOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setOptions:");
}

id objc_msgSend_setPatchTruncatedStacks_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPatchTruncatedStacks:");
}

id objc_msgSend_setPrintHeavyStacks_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPrintHeavyStacks:");
}

id objc_msgSend_setPrintJson_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPrintJson:");
}

id objc_msgSend_setPrintOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPrintOptions:");
}

id objc_msgSend_setPrintSpinSignatureStack_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPrintSpinSignatureStack:");
}

id objc_msgSend_setPrintTargetThreadOnly_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPrintTargetThreadOnly:");
}

id objc_msgSend_setPriority_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPriority:");
}

id objc_msgSend_setReason_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setReason:");
}

id objc_msgSend_setReportTimeEnd_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setReportTimeEnd:");
}

id objc_msgSend_setReportTimeStart_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setReportTimeStart:");
}

id objc_msgSend_setReportTimeThreshold_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setReportTimeThreshold:");
}

id objc_msgSend_setRequiresExternalPower_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRequiresExternalPower:");
}

id objc_msgSend_setRequiresNetworkConnectivity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRequiresNetworkConnectivity:");
}

id objc_msgSend_setSampleOnlyMainThreads_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSampleOnlyMainThreads:");
}

id objc_msgSend_setSamplingCompletionHandlerQueue_andBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSamplingCompletionHandlerQueue:andBlock:");
}

id objc_msgSend_setSamplingIntervalUs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSamplingIntervalUs:");
}

id objc_msgSend_setSamplingMode_withAdditionalSampledProcesses_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSamplingMode:withAdditionalSampledProcesses:");
}

id objc_msgSend_setSamplingTimeoutAtTime_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSamplingTimeoutAtTime:");
}

id objc_msgSend_setSanitizePaths_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSanitizePaths:");
}

id objc_msgSend_setScheduleAfter_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setScheduleAfter:");
}

id objc_msgSend_setShareWithAppDevs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setShareWithAppDevs:");
}

id objc_msgSend_setShouldGatherKextStat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setShouldGatherKextStat:");
}

id objc_msgSend_setShouldSymbolicate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setShouldSymbolicate:");
}

id objc_msgSend_setShouldUseBulkSymbolication_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setShouldUseBulkSymbolication:");
}

id objc_msgSend_setSignature_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSignature:");
}

id objc_msgSend_setSignpostCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSignpostCount:");
}

id objc_msgSend_setSignpostDurationSingle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSignpostDurationSingle:");
}

id objc_msgSend_setSignpostDurationSum_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSignpostDurationSum:");
}

id objc_msgSend_setSignpostDurationUnion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSignpostDurationUnion:");
}

id objc_msgSend_setStackshotsOnlyIncludeSpecificProcesses_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setStackshotsOnlyIncludeSpecificProcesses:");
}

id objc_msgSend_setStartIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setStartIndex:");
}

id objc_msgSend_setStepsNote_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setStepsNote:");
}

id objc_msgSend_setStopWhenProcessExits_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setStopWhenProcessExits:");
}

id objc_msgSend_setSwiftAsyncCallTreeAggregation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSwiftAsyncCallTreeAggregation:");
}

id objc_msgSend_setSwiftAsyncDisplayCRootCallstacks_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSwiftAsyncDisplayCRootCallstacks:");
}

id objc_msgSend_setSwiftAsyncPrintLeafyCCallstackOnTopOfCRootCallstacksAlways_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSwiftAsyncPrintLeafyCCallstackOnTopOfCRootCallstacksAlways:");
}

id objc_msgSend_setSwiftAsyncPrintLeafyCCallstackOnTopOfSwiftAsyncCallstacksAlways_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSwiftAsyncPrintLeafyCCallstackOnTopOfSwiftAsyncCallstacksAlways:");
}

id objc_msgSend_setSymbolicate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSymbolicate:");
}

id objc_msgSend_setSystemstatsFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSystemstatsFormat:");
}

id objc_msgSend_setTargetDispatchQueueId_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetDispatchQueueId:");
}

id objc_msgSend_setTargetHIDEventEndMachAbs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetHIDEventEndMachAbs:");
}

id objc_msgSend_setTargetHIDEventMachAbs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetHIDEventMachAbs:");
}

id objc_msgSend_setTargetProcess_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetProcess:");
}

id objc_msgSend_setTargetProcessAbsolutePath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetProcessAbsolutePath:");
}

id objc_msgSend_setTargetProcessId_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetProcessId:");
}

id objc_msgSend_setTargetProcessWithHint_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetProcessWithHint:");
}

id objc_msgSend_setTargetThreadId_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTargetThreadId:");
}

id objc_msgSend_setTaskAggregation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTaskAggregation:");
}

id objc_msgSend_setTaskCompleted(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTaskCompleted");
}

id objc_msgSend_setTaskExpiredWithRetryAfter_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTaskExpiredWithRetryAfter:error:");
}

id objc_msgSend_setUseDsymForUUIDForEverything_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setUseDsymForUUIDForEverything:");
}

id objc_msgSend_setVerbose_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setVerbose:");
}

id objc_msgSend_setVmPageSize_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setVmPageSize:");
}

id objc_msgSend_setWithObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWithObject:");
}

id objc_msgSend_setWorkflowDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWorkflowDuration:");
}

id objc_msgSend_setWorkflowDurationOmittingNetworkBoundIntervals_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWorkflowDurationOmittingNetworkBoundIntervals:");
}

id objc_msgSend_setWorkflowEventTimedOut_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWorkflowEventTimedOut:");
}

id objc_msgSend_setWrError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrError:");
}

id objc_msgSend_setWrSignpostCategory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostCategory:");
}

id objc_msgSend_setWrSignpostCount_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostCount:");
}

id objc_msgSend_setWrSignpostCountThreshold_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostCountThreshold:");
}

id objc_msgSend_setWrSignpostDurationSingle_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostDurationSingle:");
}

id objc_msgSend_setWrSignpostDurationSingleThreshold_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostDurationSingleThreshold:");
}

id objc_msgSend_setWrSignpostDurationSum_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostDurationSum:");
}

id objc_msgSend_setWrSignpostDurationSumThreshold_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostDurationSumThreshold:");
}

id objc_msgSend_setWrSignpostDurationUnion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostDurationUnion:");
}

id objc_msgSend_setWrSignpostDurationUnionThreshold_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostDurationUnionThreshold:");
}

id objc_msgSend_setWrSignpostName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostName:");
}

id objc_msgSend_setWrSignpostSubsystem_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrSignpostSubsystem:");
}

id objc_msgSend_setWrTriggeringSignpostCategory_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrTriggeringSignpostCategory:");
}

id objc_msgSend_setWrTriggeringSignpostName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrTriggeringSignpostName:");
}

id objc_msgSend_setWrTriggeringSignpostSubsystem_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrTriggeringSignpostSubsystem:");
}

id objc_msgSend_setWrWorkflowDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrWorkflowDuration:");
}

id objc_msgSend_setWrWorkflowDurationOmittingNetworkBoundIntervals_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrWorkflowDurationOmittingNetworkBoundIntervals:");
}

id objc_msgSend_setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrWorkflowDurationOmittingNetworkBoundIntervalsThreshold:");
}

id objc_msgSend_setWrWorkflowDurationThreshold_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrWorkflowDurationThreshold:");
}

id objc_msgSend_setWrWorkflowName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrWorkflowName:");
}

id objc_msgSend_setWrWorkflowTimeoutDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWrWorkflowTimeoutDuration:");
}

id objc_msgSend_setWriteDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWriteDuration:");
}

id objc_msgSend_setWriteLimitDuration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWriteLimitDuration:");
}

id objc_msgSend_sharedInstance(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sharedInstance");
}

id objc_msgSend_sharedInstanceLock(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sharedInstanceLock");
}

id objc_msgSend_sharedScheduler(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sharedScheduler");
}

id objc_msgSend_signature(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signature");
}

id objc_msgSend_signpost(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signpost");
}

id objc_msgSend_signpostCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signpostCount");
}

id objc_msgSend_signpostDurationSingle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signpostDurationSingle");
}

id objc_msgSend_signpostDurationSum(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signpostDurationSum");
}

id objc_msgSend_signpostDurationUnion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signpostDurationUnion");
}

id objc_msgSend_signpostTracker(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "signpostTracker");
}

id objc_msgSend_snapshotWithSamplingIntervalUs_andOccasionalDataIntervalSec_andOnlySampleProcesses_andOnlySampleMainThreads_andOmitSensitiveStrings_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "snapshotWithSamplingIntervalUs:andOccasionalDataIntervalSec:andOnlySampleProcesses:andOnlySampleMainThreads:andOmitSensitiveStrings:");
}

id objc_msgSend_sortUsingComparator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sortUsingComparator:");
}

id objc_msgSend_stackshotProvider(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stackshotProvider");
}

id objc_msgSend_start(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "start");
}

id objc_msgSend_startSampling(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startSampling");
}

id objc_msgSend_startSamplingThread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startSamplingThread");
}

id objc_msgSend_startTime(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startTime");
}

id objc_msgSend_startTimestamp(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startTimestamp");
}

id objc_msgSend_startWithSamplingIntervalUs_andOccasionalDataIntervalSec_andOnlySampleProcesses_andOnlySampleMainThreads_andOmitSensitiveStrings_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startWithSamplingIntervalUs:andOccasionalDataIntervalSec:andOnlySampleProcesses:andOnlySampleMainThreads:andOmitSensitiveStrings:");
}

id objc_msgSend_startingSamplingLiveSystem(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startingSamplingLiveSystem");
}

id objc_msgSend_stats(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stats");
}

id objc_msgSend_statsWithEventEndNs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "statsWithEventEndNs:");
}

id objc_msgSend_steps(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "steps");
}

id objc_msgSend_stepsNote(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stepsNote");
}

id objc_msgSend_stopAndWaitForAllSamplingToComplete_withCompletionCallbackOnQueue_withBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stopAndWaitForAllSamplingToComplete:withCompletionCallbackOnQueue:withBlock:");
}

id objc_msgSend_stopSamplingThread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stopSamplingThread");
}

id objc_msgSend_stopSamplingWithReason_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stopSamplingWithReason:");
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "string");
}

id objc_msgSend_stringByReplacingOccurrencesOfString_withString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringByReplacingOccurrencesOfString:withString:");
}

id objc_msgSend_stringFromDate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringFromDate:");
}

id objc_msgSend_stringWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithFormat:");
}

id objc_msgSend_stringWithUTF8String_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithUTF8String:");
}

id objc_msgSend_subarrayWithRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "subarrayWithRange:");
}

id objc_msgSend_submitTaskRequest_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "submitTaskRequest:error:");
}

id objc_msgSend_substringWithRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "substringWithRange:");
}

id objc_msgSend_subsystem(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "subsystem");
}

id objc_msgSend_suspendCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "suspendCount");
}

id objc_msgSend_swiftAsyncCallTreeAggregation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "swiftAsyncCallTreeAggregation");
}

id objc_msgSend_symbolicateAllInstructionsWithOptions_pid_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "symbolicateAllInstructionsWithOptions:pid:");
}

id objc_msgSend_systemstatsFormat(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "systemstatsFormat");
}

id objc_msgSend_takeTransaction(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "takeTransaction");
}

id objc_msgSend_targetDispatchQueueId(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "targetDispatchQueueId");
}

id objc_msgSend_targetHIDEventEndMachAbs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "targetHIDEventEndMachAbs");
}

id objc_msgSend_targetHIDEventMachAbs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "targetHIDEventMachAbs");
}

id objc_msgSend_targetProcess(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "targetProcess");
}

id objc_msgSend_targetProcessId(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "targetProcessId");
}

id objc_msgSend_targetProcessName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "targetProcessName");
}

id objc_msgSend_targetThreadId(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "targetThreadId");
}

id objc_msgSend_task(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "task");
}

id objc_msgSend_taskAggregation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "taskAggregation");
}

id objc_msgSend_taskRequestForIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "taskRequestForIdentifier:");
}

id objc_msgSend_tasksByPid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tasksByPid");
}

id objc_msgSend_thread(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "thread");
}

id objc_msgSend_threadID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "threadID");
}

id objc_msgSend_threadId(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "threadId");
}

id objc_msgSend_threads(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "threads");
}

id objc_msgSend_tidToPidDict(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tidToPidDict");
}

id objc_msgSend_timeOfLastResponse(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeOfLastResponse");
}

id objc_msgSend_timeRange(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeRange");
}

id objc_msgSend_timeRangeStart_end_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeRangeStart:end:");
}

id objc_msgSend_timer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timer");
}

id objc_msgSend_timestamp(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timestamp");
}

id objc_msgSend_timestampWithMachAbsTime_machAbsTimeSec_machContTime_machContTimeSec_wallTime_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timestampWithMachAbsTime:machAbsTimeSec:machContTime:machContTimeSec:wallTime:");
}

id objc_msgSend_timestampWithMachAbsTime_machContTime_wallTime_machTimebase_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timestampWithMachAbsTime:machContTime:wallTime:machTimebase:");
}

id objc_msgSend_total(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "total");
}

id objc_msgSend_triggerEventTimeout(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "triggerEventTimeout");
}

id objc_msgSend_triggerThresholdCount(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "triggerThresholdCount");
}

id objc_msgSend_triggerThresholdDurationSingle(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "triggerThresholdDurationSingle");
}

id objc_msgSend_triggerThresholdDurationSum(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "triggerThresholdDurationSum");
}

id objc_msgSend_triggerThresholdDurationUnion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "triggerThresholdDurationUnion");
}

id objc_msgSend_unionSet_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unionSet:");
}

id objc_msgSend_unknown_type(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unknown_type");
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedLongLongValue");
}

id objc_msgSend_useDsymForUUIDFor_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "useDsymForUUIDFor:");
}

id objc_msgSend_uuid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "uuid");
}

id objc_msgSend_waitForSamplingToComplete(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "waitForSamplingToComplete");
}

id objc_msgSend_wallTime(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "wallTime");
}

id objc_msgSend_workflow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workflow");
}

id objc_msgSend_workflowDiagnostics(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workflowDiagnostics");
}

id objc_msgSend_workflowDuration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workflowDuration");
}

id objc_msgSend_workflowDurationOmittingNetworkBoundIntervals(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workflowDurationOmittingNetworkBoundIntervals");
}

id objc_msgSend_workflowEventTimedOut(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workflowEventTimedOut");
}

id objc_msgSend_workflowTracker(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workflowTracker");
}

id objc_msgSend_writeToURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToURL:error:");
}

id objc_msgSend_zero(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "zero");
}

