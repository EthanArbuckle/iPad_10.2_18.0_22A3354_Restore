id MantaMCURestoreInfoCoreGetTags(void *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  id v4;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  MRUPersonalizationInfo *v11;
  MRULogHelper *v12;
  void *v14;
  void *v15;
  id v16;
  id v17;
  id v18;
  void *v19;
  void *v20;
  void *v21;
  MRUPersonalizationInfo *v22;
  uint64_t v23;
  MRUPersonalizationInfo *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  id v29;
  void *v30;
  id v31;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  id v37;
  MRULogHelper *v38;
  _QWORD *v39;
  id obj;
  uint64_t v41;
  void *v42;
  void *v43;
  id v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _QWORD v49[3];
  _QWORD v50[3];
  _BYTE v51[128];

  v4 = 0;
  if (!a1)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v43 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    goto LABEL_20;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v43 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if (!a2)
    goto LABEL_20;
  v39 = a4;
  v6 = a1;
  v12 = -[MRULogHelper initWithOptions:logFunction:logContext:]([MRULogHelper alloc], "initWithOptions:logFunction:logContext:", v6, a2, a3);
  v14 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("DeviceInfo")));
  v7 = v14;
  if (v14)
  {
    v15 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKeyedSubscript:", CFSTR("PersonalizationInfoArray")));
    v8 = v15;
    if (v15 && objc_msgSend(v15, "count") == (id)1)
    {
      -[MRULogHelper verboseLog:](v12, "verboseLog:", CFSTR("infoArray: %@\n"), v8);
      v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
      v43 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableArray array](NSMutableArray, "array"));
      v45 = 0u;
      v46 = 0u;
      v47 = 0u;
      v48 = 0u;
      v16 = v8;
      v17 = objc_msgSend(v16, "countByEnumeratingWithState:objects:count:", &v45, v51, 16);
      obj = v16;
      if (v17)
      {
        v18 = v17;
        v37 = v6;
        v38 = v12;
        v36 = v7;
        v4 = 0;
        v10 = 0;
        v11 = 0;
        v41 = *(_QWORD *)v46;
        while (2)
        {
          v19 = 0;
          v20 = v4;
          v21 = v10;
          v22 = v11;
          do
          {
            if (*(_QWORD *)v46 != v41)
              objc_enumerationMutation(obj);
            v23 = *(_QWORD *)(*((_QWORD *)&v45 + 1) + 8 * (_QWORD)v19);
            v24 = [MRUPersonalizationInfo alloc];
            v44 = v20;
            v11 = -[MRUPersonalizationInfo initWithOptions:error:](v24, "initWithOptions:error:", v23, &v44);
            v4 = v44;

            if (!v11)
            {
              -[MRULogHelper log:](v38, "log:", CFSTR("Failed to create personalizationInfo with options: %@\n"), v23);
              v10 = v21;
              v8 = obj;
              goto LABEL_24;
            }
            v25 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo tag](v11, "tag"));
            objc_msgSend(v42, "addObject:", v25);

            v26 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo ticketName](v11, "ticketName"));
            objc_msgSend(v43, "addObject:", v26);

            v27 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo objectName](v11, "objectName"));
            v28 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v11, "hardwareInfo"));
            v29 = objc_msgSend(v28, "chipID");
            v30 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v11, "hardwareInfo"));
            v10 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%@-%x-%llx"), v27, v29, objc_msgSend(v30, "ecid")));

            v19 = (char *)v19 + 1;
            v20 = v4;
            v21 = v10;
            v22 = v11;
          }
          while (v18 != v19);
          v8 = obj;
          v18 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v45, v51, 16);
          if (v18)
            continue;
          break;
        }
LABEL_24:

        v7 = v36;
        v6 = v37;
        v12 = v38;
        if (v4)
        {
          v9 = v42;
          goto LABEL_19;
        }
      }
      else
      {

        v11 = 0;
        v10 = 0;
      }
      v49[0] = CFSTR("BuildIdentityTags");
      v33 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v42));
      v50[0] = v33;
      v49[1] = CFSTR("ResponseTags");
      v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v43));
      v49[2] = CFSTR("LoopInstance");
      v50[1] = v34;
      v50[2] = v10;
      v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v50, v49, 3));

      v8 = obj;
      v9 = v42;
      -[MRULogHelper verboseLog:](v12, "verboseLog:", CFSTR("[%@]: getTags result:\n %@\n"), CFSTR("MantaMRI"), v35);
      v31 = v35;

      v4 = 0;
      goto LABEL_22;
    }
    v4 = 0;
  }
  else
  {
    v4 = 0;
    v8 = 0;
  }
  v9 = 0;
  v43 = 0;
  v10 = 0;
  v11 = 0;
LABEL_19:
  a4 = v39;
LABEL_20:
  v31 = 0;
  if (a4)
    *a4 = 0;
LABEL_22:

  return v31;
}

id MantaMCURestoreInfoCoreCopyFirmware(void *a1, uint64_t a2, uint64_t a3)
{
  id v6;
  void *v7;
  void *v8;
  id v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  MRUPersonalizationInfo *v21;
  MRULogHelper *v22;
  void *v23;
  uint64_t v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  const __CFString *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  id v37;
  uint64_t v39;
  id v40;
  id v41;
  void *v42;
  id v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  id v51;
  void *v52;
  unsigned int v53;
  void *v54;
  unsigned __int8 v55;
  id v56;
  void *v57;
  id v58;
  void *v59;
  void *v60;
  unsigned __int8 v61;
  id v62;
  MRUPersonalizationInfo *v63;
  void *v64;
  unsigned __int8 v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  id v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  void *v83;
  id v84;
  id v85;
  id v86;
  id v87;
  id v88[2];

  v76 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = 0;
  v14 = 0;
  v15 = 0;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  v19 = 0;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  if (a1 && a2)
  {
    v6 = a1;
    v22 = -[MRULogHelper initWithOptions:logFunction:logContext:]([MRULogHelper alloc], "initWithOptions:logFunction:logContext:", v6, a2, a3);
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("DeviceInfo")));
    v7 = v23;
    if (v23)
    {
      v24 = objc_claimAutoreleasedReturnValue(objc_msgSend(v23, "objectForKeyedSubscript:", CFSTR("PersonalizationInfoArray")));
      if (v24)
      {
        v25 = (void *)v24;
        v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("BundleDataDict")));
        v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("FirmwareData")));
        v69 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("BuildIdentity")));
        v28 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("BundlePath")));
        v82 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("DestBundlePath")));
        if (v27)
        {
          v9 = v27;
          -[MRULogHelper verboseLog:](v22, "verboseLog:", CFSTR("[%@]: Using firmwareOverride\n"), CFSTR("MantaMRI"));
          v16 = v26;
          v11 = 0;
          v13 = 0;
          v14 = 0;
          v15 = 0;
          v19 = 0;
          v20 = 0;
          v21 = 0;
          v8 = v25;
          v17 = v9;
          v10 = v28;
          v12 = v82;
          v18 = v69;
          goto LABEL_10;
        }
        v39 = objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "firstObject"));
        v88[0] = 0;
        v21 = -[MRUPersonalizationInfo initWithOptions:error:]([MRUPersonalizationInfo alloc], "initWithOptions:error:", v39, v88);
        v40 = v88[0];
        if (!v21)
        {
          v43 = v40;
          -[MRULogHelper log:](v22, "log:", CFSTR("Failed to create personalizationInfo with options %@: %@"), v39, v40);
          v15 = v43;
          v9 = 0;
          v16 = v26;
          v11 = 0;
          v13 = 0;
          v14 = 0;
          v8 = v25;
          v17 = 0;
          v19 = 0;
          v10 = v28;
          v12 = v82;
          v18 = v69;
          v20 = (void *)v39;
          goto LABEL_10;
        }
        v68 = v39;
        if (v26)
        {
          v41 = v40;
          v42 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo tag](v21, "tag"));
          v9 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "objectForKeyedSubscript:", v42));

          -[MRULogHelper verboseLog:](v22, "verboseLog:", CFSTR("[%@]: Using firmware from bundle data, %@"), CFSTR("MantaMRI"), v21);
          v15 = v41;
          v16 = v26;
          v11 = 0;
          v13 = 0;
          v14 = 0;
          v8 = v25;
          v17 = 0;
          v19 = 0;
LABEL_14:
          v10 = v28;
          v12 = v82;
LABEL_15:
          v20 = (void *)v68;
          v18 = v69;
          goto LABEL_10;
        }
        if (!v69)
        {
          v58 = v40;
          -[MRULogHelper log:](v22, "log:", CFSTR("No buildIdentity key"));
          v15 = v58;
          v9 = 0;
          v11 = 0;
          v13 = 0;
          v14 = 0;
          v16 = 0;
          v8 = v25;
          v17 = 0;
          v18 = 0;
          v19 = 0;
          v10 = v28;
          v12 = v82;
          v20 = (void *)v68;
          goto LABEL_10;
        }
        v80 = v40;
        if (v28)
        {
          v44 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo tag](v21, "tag"));
          v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v44, "stringByAppendingString:", CFSTR(".Info.Path")));
          v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v69, "valueForKeyPath:", v45));

          if (v11)
          {
            v66 = v11;
            v46 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v28, "URLByAppendingPathComponent:", v11));
            v11 = (uint64_t)v46;
            if (v46)
            {
              v47 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v46, "path"));
              v87 = v80;
              v9 = (id)objc_claimAutoreleasedReturnValue(+[NSData dataWithContentsOfFile:options:error:](NSData, "dataWithContentsOfFile:options:error:", v47, 0, &v87));
              v74 = v87;

              if (!v9)
              {
                -[MRULogHelper log:](v22, "log:", CFSTR("%@"), v66);
                -[MRULogHelper log:](v22, "log:", CFSTR("Failed to load file %@:%@"), v11, v74);
                v19 = (void *)v66;
                v13 = 0;
                v14 = 0;
                v16 = 0;
                v8 = v25;
                v17 = 0;
                v15 = v74;
                goto LABEL_14;
              }
              v19 = (void *)v66;
              if (!v82)
              {
                v12 = 0;
                v13 = 0;
                v14 = 0;
                v16 = 0;
                v8 = v25;
                v17 = 0;
                v15 = v74;
                v10 = v28;
                goto LABEL_15;
              }
              v48 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v82, "URLByAppendingPathComponent:", v66));
              if (v48)
              {
                v81 = v48;
                v49 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v48, "URLByDeletingLastPathComponent"));
                if (v49)
                {
                  v78 = (void *)v11;
                  v64 = v49;
                  v50 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v49, "path"));
                  v86 = v74;
                  v65 = objc_msgSend(v76, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v50, 1, 0, &v86);
                  v51 = v86;

                  if ((v65 & 1) != 0 || (objc_msgSend(v51, "isFileExistsError") & 1) != 0)
                  {
                    v75 = v25;
                    v52 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "path"));
                    v53 = objc_msgSend(v76, "fileExistsAtPath:", v52);

                    v63 = v21;
                    v72 = v7;
                    if (v53)
                    {
                      v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "path"));
                      v85 = v51;
                      v55 = objc_msgSend(v76, "removeItemAtPath:error:", v54, &v85);
                      v56 = v85;

                      if ((v55 & 1) == 0)
                      {
                        -[MRULogHelper log:](v22, "log:", CFSTR("Failed to remove file at %@: %@"), v81, v56);
                        v13 = v81;
                        v16 = 0;
                        v17 = 0;
                        v15 = v56;
                        v8 = v25;
                        v10 = v28;
                        v12 = v82;
                        v20 = (void *)v68;
                        v18 = v69;
                        v21 = v63;
                        v11 = (uint64_t)v78;
                        goto LABEL_47;
                      }
                      v57 = v56;
                    }
                    else
                    {
                      v57 = v51;
                    }
                    v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v78, "path"));
                    v60 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v81, "path"));
                    v84 = v57;
                    v61 = objc_msgSend(v76, "copyItemAtPath:toPath:error:", v59, v60, &v84);
                    v62 = v84;

                    if ((v61 & 1) != 0)
                    {
                      v16 = 0;
                      v17 = 0;
                      v7 = v72;
                      v8 = v75;
                      v19 = (void *)v66;
                      v10 = v28;
                      v13 = v81;
                      v12 = v82;
                      v20 = (void *)v68;
                      v18 = v69;
                      v21 = v63;
                      v11 = (uint64_t)v78;
                      v15 = v62;
LABEL_48:
                      v14 = v64;
                      goto LABEL_10;
                    }
                    v11 = (uint64_t)v78;
                    -[MRULogHelper log:](v22, "log:", CFSTR("Failed to copy %@ to %@: %@"), v78, v81, v62);
                    v13 = v81;
                    v15 = v62;
                    v16 = 0;
                    v17 = 0;
                    v7 = v72;
                    v8 = v75;
                    v10 = v28;
                    v12 = v82;
                    v20 = (void *)v68;
                    v18 = v69;
                    v21 = v63;
LABEL_47:
                    v19 = (void *)v66;
                    goto LABEL_48;
                  }
                  -[MRULogHelper log:](v22, "log:", CFSTR("Failed to create directory at '%@': %@"), v64, v51);
                  v14 = v64;
                  v16 = 0;
                  v8 = v25;
                  v17 = 0;
                  v10 = v28;
                  v12 = v82;
                  v20 = (void *)v68;
                  v18 = v69;
                  v15 = v51;
                  v11 = (uint64_t)v78;
                }
                else
                {
                  -[MRULogHelper log:](v22, "log:", CFSTR("Failed to compose destDirURL"));
                  v14 = 0;
                  v16 = 0;
                  v8 = v25;
                  v17 = 0;
                  v15 = v74;
                  v10 = v28;
                  v12 = v82;
                  v20 = (void *)v68;
                  v18 = v69;
                }
                v19 = (void *)v66;
                v13 = v81;
                goto LABEL_10;
              }
              -[MRULogHelper log:](v22, "log:", CFSTR("Failed to compose destFileURL"));
              v13 = 0;
              v14 = 0;
              v16 = 0;
              v8 = v25;
              v17 = 0;
              v15 = v74;
              v10 = v28;
              v12 = v82;
            }
            else
            {
              -[MRULogHelper log:](v22, "log:", CFSTR("Failed to compose file url"));
              v9 = 0;
              v13 = 0;
              v14 = 0;
              v16 = 0;
              v8 = v25;
              v17 = 0;
              v10 = v28;
              v15 = v80;
              v12 = v82;
            }
            v20 = (void *)v68;
            v18 = v69;
            v19 = (void *)v66;
            goto LABEL_10;
          }
          -[MRULogHelper log:](v22, "log:", CFSTR("Failed to get filePathSuffix"));
          v9 = 0;
          v13 = 0;
          v14 = 0;
          v16 = 0;
          v8 = v25;
          v17 = 0;
          v19 = 0;
          v10 = v28;
        }
        else
        {
          -[MRULogHelper log:](v22, "log:", CFSTR("No bundleURL"));
          v9 = 0;
          v10 = 0;
          v11 = 0;
          v13 = 0;
          v14 = 0;
          v16 = 0;
          v8 = v25;
          v17 = 0;
          v19 = 0;
        }
        v15 = v80;
        v12 = v82;
        goto LABEL_15;
      }
      v29 = CFSTR("No infoArray in deviceInfo dict");
    }
    else
    {
      v29 = CFSTR("No deviceInfo in options dict");
    }
    -[MRULogHelper log:](v22, "log:", v29);
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = 0;
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    v21 = 0;
  }
LABEL_10:
  v79 = v13;
  v83 = v12;
  v77 = (void *)v11;
  v67 = v10;
  v70 = v6;
  v71 = v7;
  v73 = v8;
  v30 = v18;
  v31 = v20;
  v32 = v15;
  v33 = v19;
  v34 = v14;
  v35 = v16;
  v36 = v17;
  v37 = v9;

  return v37;
}

void *MantaMCURestoreInfoCoreCreateRequest(void *a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  id v5;
  void *v7;
  void *v8;
  MRUPersonalizationInfo *v9;
  void *v10;
  id v11;
  void *v12;
  id v13;
  id v14;
  MRULogHelper *v16;
  void *v17;
  id v18;
  uint64_t v19;
  void *v20;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  __CFString **v39;
  __CFString *v40;
  __CFString *v41;
  FTABFile *v42;
  FTABFile *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  id v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  __CFString *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  MRULogHelper *v66;
  id v67;
  _QWORD v68[4];
  _QWORD v69[4];
  _BYTE v70[48];

  v5 = 0;
  if (!a1)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v66 = 0;
    v13 = 0;
    v14 = 0;
    goto LABEL_18;
  }
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v66 = 0;
  v13 = 0;
  v14 = 0;
  if (!a2)
    goto LABEL_18;
  v5 = a1;
  v16 = -[MRULogHelper initWithOptions:logFunction:logContext:]([MRULogHelper alloc], "initWithOptions:logFunction:logContext:", v5, a2, a3);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("DeviceInfo")));
  v66 = v16;
  if (!v7)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    v13 = 0;
LABEL_17:
    v14 = 0;
    goto LABEL_18;
  }
  v13 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("FirmwareData")));
  if (!v13)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
LABEL_16:
    v11 = 0;
    v12 = 0;
    goto LABEL_17;
  }
  v17 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("PersonalizationInfoArray")));
  v10 = v17;
  if (!v17)
  {
    v8 = 0;
    v9 = 0;
    goto LABEL_16;
  }
  v67 = 0;
  v65 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "firstObject"));
  v9 = -[MRUPersonalizationInfo initWithOptions:error:]([MRUPersonalizationInfo alloc], "initWithOptions:error:", v65, &v67);
  v18 = v67;
  v14 = v18;
  if (!v9)
  {
    v11 = 0;
    v12 = 0;
    v8 = v65;
    goto LABEL_18;
  }
  v64 = v18;
  v19 = objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "objectForKeyedSubscript:", CFSTR("LocalSigningID")));
  if (v19)
    v12 = (void *)v19;
  else
    v12 = &__kCFBooleanFalse;
  if ((objc_msgSend(v12, "BOOLValue") & 1) == 0)
  {
    v11 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionary](NSMutableDictionary, "dictionary"));
    v22 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo ticketName](v9, "ticketName"));
    v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(CFSTR("@"), "stringByAppendingString:", v22));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, v23);

    v57 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
    v24 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v57, "boardID")));
    v25 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo boardIDPropertyName](v9, "boardIDPropertyName"));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v24, v25);

    v58 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
    v26 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v58, "chipID")));
    v27 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo chipIDPropertyName](v9, "chipIDPropertyName"));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v26, v27);

    v59 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
    v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", objc_msgSend(v59, "ecid")));
    v29 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo ecidPropertyName](v9, "ecidPropertyName"));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v28, v29);

    v30 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo nonce](v9, "nonce"));
    v31 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo noncePropertyName](v9, "noncePropertyName"));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v30, v31);

    v60 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
    if (objc_msgSend(v60, "productionStatus"))
      v32 = &__kCFBooleanTrue;
    else
      v32 = &__kCFBooleanFalse;
    v33 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo productionModePropertyName](v9, "productionModePropertyName"));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v32, v33);

    v61 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
    v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", objc_msgSend(v61, "securityDomain")));
    v35 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo securityDomainPropertyName](v9, "securityDomainPropertyName"));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v34, v35);

    v62 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
    if (objc_msgSend(v62, "securityMode"))
      v36 = &__kCFBooleanTrue;
    else
      v36 = &__kCFBooleanFalse;
    v37 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo securityModePropertyName](v9, "securityModePropertyName"));
    objc_msgSend(v11, "setObject:forKeyedSubscript:", v36, v37);

    v38 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo objectName](v9, "objectName"));
    v63 = v38;
    if ((objc_msgSend(v38, "isEqualToString:", CFSTR("RestoreRTKitOS")) & 1) != 0)
    {
      v39 = kFTABSubfileRRKO;
    }
    else
    {
      if (!objc_msgSend(v38, "isEqualToString:", CFSTR("RTKitOS")))
        goto LABEL_37;
      v39 = kFTABSubfileRKOS;
    }
    v40 = *v39;
    if (v40)
    {
      v41 = v40;
      -[MRULogHelper verboseLog:](v66, "verboseLog:", CFSTR("[%@]: %@ is FTAB subfile with tag '%@', extracting\n"), CFSTR("MantaMRI"), v38, v40);
      v42 = -[FTABFile initWithData:]([FTABFile alloc], "initWithData:", v13);
      if (v42)
      {
        v43 = v42;
        v56 = v41;
        v44 = (void *)objc_claimAutoreleasedReturnValue(-[FTABFile subfileWithTag:](v42, "subfileWithTag:", v41));
        if (v44)
        {
          v45 = v44;
          v46 = objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", objc_msgSend(v44, "dataPointer"), objc_msgSend(v44, "dataLength")));

          -[MRULogHelper verboseLog:](v66, "verboseLog:", CFSTR("[%@]: Extracted %@ from FTAB"), CFSTR("MantaMRI"), v63);
          v13 = (id)v46;
LABEL_38:
          v47 = ccsha384_di();
          v48 = objc_msgSend(v13, "length");
          v13 = objc_retainAutorelease(v13);
          ccdigest(v47, v48, objc_msgSend(v13, "bytes"), v70);
          v68[0] = CFSTR("Digest");
          v55 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v70, 48));
          v69[0] = v55;
          v68[1] = CFSTR("EPRO");
          v54 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
          if (objc_msgSend(v54, "productionStatus"))
            v49 = &__kCFBooleanTrue;
          else
            v49 = &__kCFBooleanFalse;
          v69[1] = v49;
          v68[2] = CFSTR("ESEC");
          v50 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo hardwareInfo](v9, "hardwareInfo"));
          if (objc_msgSend(v50, "securityMode"))
            v51 = &__kCFBooleanTrue;
          else
            v51 = &__kCFBooleanFalse;
          v68[3] = CFSTR("Trusted");
          v69[2] = v51;
          v69[3] = &__kCFBooleanTrue;
          v52 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v69, v68, 4));
          v53 = (void *)objc_claimAutoreleasedReturnValue(-[MRUPersonalizationInfo tag](v9, "tag"));
          objc_msgSend(v11, "setObject:forKeyedSubscript:", v52, v53);

          v11 = v11;
          v20 = v11;
LABEL_20:
          v16 = v66;
          goto LABEL_21;
        }

      }
      v14 = v64;
      v8 = v65;
LABEL_18:
      v64 = v14;
      v65 = v8;
      v20 = 0;
      if (a4)
        *a4 = 0;
      goto LABEL_20;
    }
LABEL_37:
    v56 = 0;
    goto LABEL_38;
  }
  v11 = 0;
  v20 = &__NSDictionary0__struct;
LABEL_21:

  return v20;
}

void sub_1000C6DDC()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136315650;
  sub_1000BBDD8();
  sub_1000BBDC4((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
  sub_1000BBDBC();
}

void sub_1000C6E48(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "-[FTABFile parseFileData]";
  sub_1000BBDA4((void *)&_mh_execute_header, a1, a3, "%s: File too short", (uint8_t *)&v3);
  sub_1000A4540();
}

void sub_1000C6EBC(unsigned __int8 *a1, NSObject *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = 136316162;
  v7 = "-[FTABFile parseFileData]";
  v8 = 1024;
  v9 = v2;
  v10 = 1024;
  v11 = v3;
  v12 = 1024;
  v13 = v4;
  v14 = 1024;
  v15 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: File tag parse error (%02x %02x %02x %02x)", (uint8_t *)&v6, 0x24u);
  sub_1000BBDBC();
}

void sub_1000C6F68()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_1000BBE0C();
  sub_1000BBDFC();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x18u);
  sub_1000A4540();
}

void sub_1000C6FE4()
{
  os_log_t v0;
  int v1[4];
  __int16 v2;
  uint64_t v3;

  v1[0] = 136315650;
  sub_1000BBE0C();
  v2 = 2048;
  v3 = 16;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Error parsing file offset list (offset=%u, length=%lu)", (uint8_t *)v1, 0x1Cu);
  sub_1000BBDBC();
}

void sub_1000C706C(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "-[FTABFile parseFileData]";
  sub_1000BBDA4((void *)&_mh_execute_header, a1, a3, "%s: Manifest parameters are invalid", (uint8_t *)&v3);
  sub_1000A4540();
}

void sub_1000C70E0()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_1000BBDFC();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x3Cu);
}

void sub_1000C71BC()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136315650;
  sub_1000BBDD8();
  sub_1000BBDC4((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
  sub_1000BBDBC();
}

void sub_1000C7228(void *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "path"));
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Unable to create file at %@", v4, v5, v6, v7, v8);

  sub_1000BBDB0();
}

void sub_1000C72A0(void *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "path"));
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Unable to delete file at %@", v4, v5, v6, v7, v8);

  sub_1000BBDB0();
}

void sub_1000C7318(void *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "tag"));
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Failed to write '%@'", v4, v5, v6, v7, v8);

  sub_1000BBDB0();
}

void sub_1000C7390(void *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "tag"));
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Failed to write '%@' header", v4, v5, v6, v7, v8);

  sub_1000BBDB0();
}

void sub_1000C7408(void *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "absoluteString"));
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Failed to open file handle for writing to '%@'", v4, v5, v6, v7, v8);

  sub_1000BBDB0();
}

uint64_t sub_1000C9680@<X0>(const void *a1@<X0>, const void *a2@<X1>, _QWORD *a3@<X8>)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t result;

  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 0, "%s::%s: RoseUpdater Version: %s\n", v7, v8, v9, v10, v11, (char)"RoseRestoreHost");
  v12 = operator new(0xF8uLL);
  sub_1000D3018((uint64_t)v12);
  *v12 = off_100182AA0;
  v12[29] = 0;
  v12[30] = 0;
  *a3 = v12;
  result = sub_1000C9904((uint64_t)v12, a1, a2);
  if ((result & 1) == 0)
  {
    *a3 = 0;
    return (*(uint64_t (**)(_QWORD *))(*v12 + 24))(v12);
  }
  return result;
}

void sub_1000C9744(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  *v1 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v2 + 24))(v2);
  _Unwind_Resume(a1);
}

__CFDictionary *sub_1000C9774(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  __CFDictionary *v7;
  std::__shared_weak_count *v8;
  unint64_t *p_shared_owners;
  unint64_t v10;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  std::__shared_weak_count *v25;

  if (*(_BYTE *)(a3 + 17))
  {
    v12 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v12, 2u, "%s::%s: security mode demotion disallowed for Rose\n", v13, v14, v15, v16, v17, (char)"RoseRestoreHost");
    return 0;
  }
  else
  {
    v4 = a2[1];
    v24 = *a2;
    v25 = (std::__shared_weak_count *)v4;
    if (v4)
    {
      v5 = (unint64_t *)(v4 + 8);
      do
        v6 = __ldxr(v5);
      while (__stxr(v6 + 1, v5));
    }
    v7 = sub_1000D0B1C(a1, &v24, a3);
    v8 = v25;
    if (v25)
    {
      p_shared_owners = (unint64_t *)&v25->__shared_owners_;
      do
        v10 = __ldaxr(p_shared_owners);
      while (__stlxr(v10 - 1, p_shared_owners));
      if (!v10)
      {
        ((void (*)(std::__shared_weak_count *))v8->__on_zero_shared)(v8);
        std::__shared_weak_count::__release_weak(v8);
      }
    }
    if (v7)
    {
      if (*(_BYTE *)(a3 + 16))
        CFDictionaryRemoveValue(v7, CFSTR("Rap,RestoreRTKitOS"));
    }
    else
    {
      v18 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v18, 2u, "%s::%s: failed to create output request dictionary\n", v19, v20, v21, v22, v23, (char)"RoseRestoreHost");
    }
  }
  return v7;
}

void sub_1000C988C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  sub_1000CB5E0((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000C98A0(_QWORD *a1)
{
  *a1 = off_100182AA0;
  sub_1000CB5E0((uint64_t)(a1 + 29));
  return sub_1000D2814((uint64_t)a1);
}

void sub_1000C98D0(_QWORD *a1)
{
  void *v2;

  *a1 = off_100182AA0;
  sub_1000CB5E0((uint64_t)(a1 + 29));
  v2 = (void *)sub_1000D2814((uint64_t)a1);
  operator delete(v2);
}

uint64_t sub_1000C9904(uint64_t a1, CFTypeRef cf, const void *a3)
{
  CFTypeID v6;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  CFTypeID v9;
  const __CFData *v10;
  const __CFData *v11;
  CFTypeID v12;
  const UInt8 *BytePtr;
  _DWORD **v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  char **v18;
  unint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  char *v28;
  char *v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  _QWORD *v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  char *v39;
  char *v40;
  char *v41;
  char *v42;
  char *v43;
  uint64_t v44;
  _QWORD *v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  char *v54;
  char *v55;
  _BYTE *v56;
  _BYTE *v57;
  uint64_t v58;
  char v59;
  CFTypeID TypeID;
  CFTypeID v61;
  CFTypeID v62;
  CFTypeID v63;
  CFTypeID v64;
  CFTypeID v65;
  CFTypeID v66;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  __int128 __src;
  __int128 v105;
  __int128 v106;
  const __CFString *v107;
  CFTypeID v108;
  unint64_t v109[6];
  unint64_t v110;

  if (!cf || (v6 = CFGetTypeID(cf), v6 != CFDictionaryGetTypeID()))
  {
    v68 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v68, 2u, "%s::%s: Bad options\n", v69, v70, v71, v72, v73, (char)"RoseRestoreHost");
    return 0;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("DeviceInfo"));
  if (!Value || (v8 = Value, v9 = CFGetTypeID(Value), v9 != CFDictionaryGetTypeID()))
  {
    v74 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v74, 2u, "%s::%s: No device info\n", v75, v76, v77, v78, v79, (char)"RoseRestoreHost");
    return 0;
  }
  v10 = (const __CFData *)CFDictionaryGetValue(v8, CFSTR("Rap,ChipID"));
  if (!v10 || (v11 = v10, v12 = CFGetTypeID(v10), v12 != CFDataGetTypeID()))
  {
    v80 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v80, 2u, "%s::%s: No chip ID\n", v81, v82, v83, v84, v85, (char)"RoseRestoreHost");
    return 0;
  }
  if (CFDataGetLength(v11) != 2)
  {
    v86 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v86, 2u, "%s::%s: Bad chip ID size\n", v87, v88, v89, v90, v91, (char)"RoseRestoreHost");
    return 0;
  }
  BytePtr = CFDataGetBytePtr(v11);
  sub_1000CD498(*(unsigned __int16 *)BytePtr, &__src);
  v14 = (_DWORD **)(a1 + 232);
  sub_1000C9FF8(a1 + 232, &__src);
  v15 = (std::__shared_weak_count *)*((_QWORD *)&__src + 1);
  if (*((_QWORD *)&__src + 1))
  {
    v16 = (unint64_t *)(*((_QWORD *)&__src + 1) + 8);
    do
      v17 = __ldaxr(v16);
    while (__stlxr(v17 - 1, v16));
    if (!v17)
    {
      ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
      std::__shared_weak_count::__release_weak(v15);
    }
  }
  if (!*v14)
  {
    v92 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v92, 2u, "%s::%s: failed to create capabilities\n", v93, v94, v95, v96, v97, (char)"RoseRestoreHost");
    return 0;
  }
  __src = *(_OWORD *)&off_100182AD0;
  v105 = *(_OWORD *)&off_100182AE0;
  v18 = (char **)(a1 + 40);
  sub_1000CB638((char *)(a1 + 40), (char *)&__src, (uint64_t)&v106, 4uLL);
  if (sub_1000CD69C(*(_DWORD **)(a1 + 232)))
  {
    v19 = *(_QWORD *)(a1 + 56);
    v20 = *(_QWORD **)(a1 + 48);
    if ((unint64_t)v20 >= v19)
    {
      v22 = ((char *)v20 - *v18) >> 3;
      if ((unint64_t)(v22 + 1) >> 61)
        sub_1000CB780();
      v23 = v19 - (_QWORD)*v18;
      v24 = v23 >> 2;
      if (v23 >> 2 <= (unint64_t)(v22 + 1))
        v24 = v22 + 1;
      if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFF8)
        v25 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v25 = v24;
      if (v25)
        v26 = (char *)sub_1000CB794(a1 + 56, v25);
      else
        v26 = 0;
      v27 = &v26[8 * v22];
      v28 = &v26[8 * v25];
      *(_QWORD *)v27 = CFSTR("Rap,RTKitIOConfig");
      v21 = v27 + 8;
      v30 = *(char **)(a1 + 40);
      v29 = *(char **)(a1 + 48);
      if (v29 != v30)
      {
        do
        {
          v31 = *((_QWORD *)v29 - 1);
          v29 -= 8;
          *((_QWORD *)v27 - 1) = v31;
          v27 -= 8;
        }
        while (v29 != v30);
        v29 = *v18;
      }
      *(_QWORD *)(a1 + 40) = v27;
      *(_QWORD *)(a1 + 48) = v21;
      *(_QWORD *)(a1 + 56) = v28;
      if (v29)
        operator delete(v29);
    }
    else
    {
      *v20 = CFSTR("Rap,RTKitIOConfig");
      v21 = v20 + 1;
    }
    *(_QWORD *)(a1 + 48) = v21;
  }
  if (sub_1000CD6AC(*v14))
  {
    v32 = *(_QWORD *)(a1 + 56);
    v33 = *(_QWORD **)(a1 + 48);
    if ((unint64_t)v33 >= v32)
    {
      v35 = ((char *)v33 - *v18) >> 3;
      if ((unint64_t)(v35 + 1) >> 61)
        sub_1000CB780();
      v36 = v32 - (_QWORD)*v18;
      v37 = v36 >> 2;
      if (v36 >> 2 <= (unint64_t)(v35 + 1))
        v37 = v35 + 1;
      if ((unint64_t)v36 >= 0x7FFFFFFFFFFFFFF8)
        v38 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v38 = v37;
      if (v38)
        v39 = (char *)sub_1000CB794(a1 + 56, v38);
      else
        v39 = 0;
      v40 = &v39[8 * v35];
      v41 = &v39[8 * v38];
      *(_QWORD *)v40 = CFSTR("Rap,RestoreRTKitOS");
      v34 = v40 + 8;
      v43 = *(char **)(a1 + 40);
      v42 = *(char **)(a1 + 48);
      if (v42 != v43)
      {
        do
        {
          v44 = *((_QWORD *)v42 - 1);
          v42 -= 8;
          *((_QWORD *)v40 - 1) = v44;
          v40 -= 8;
        }
        while (v42 != v43);
        v42 = *v18;
      }
      *(_QWORD *)(a1 + 40) = v40;
      *(_QWORD *)(a1 + 48) = v34;
      *(_QWORD *)(a1 + 56) = v41;
      if (v42)
        operator delete(v42);
    }
    else
    {
      *v33 = CFSTR("Rap,RestoreRTKitOS");
      v34 = v33 + 1;
    }
    *(_QWORD *)(a1 + 48) = v34;
  }
  __src = *(_OWORD *)&off_100182B00;
  v105 = *(_OWORD *)&off_100182B10;
  v106 = *(_OWORD *)&off_100182B20;
  v107 = CFSTR("Rap,SecurityDomain");
  sub_1000CB638((char *)(a1 + 64), (char *)&__src, (uint64_t)&v108, 7uLL);
  *(_QWORD *)&__src = CFSTR("@Rap,Ticket");
  sub_1000CB638((char *)(a1 + 88), (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  *(_QWORD *)&__src = CFSTR("Rap,Ticket");
  sub_1000CB638((char *)(a1 + 112), (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  __src = off_100182B38;
  v105 = *(_OWORD *)&off_100182B48;
  v106 = off_100182B58;
  v45 = (_QWORD *)(a1 + 136);
  sub_1000CB7C8((char *)(a1 + 136), (char *)&__src, (uint64_t)&v107, 3uLL);
  if (sub_1000CD69C(*(_DWORD **)(a1 + 232)))
  {
    v46 = *(_QWORD *)(a1 + 152);
    v47 = *(_QWORD *)(a1 + 144);
    if (v47 >= v46)
    {
      v49 = (uint64_t)(v47 - *v45) >> 4;
      v50 = v49 + 1;
      if ((unint64_t)(v49 + 1) >> 60)
        sub_1000CB780();
      v51 = v46 - *v45;
      if (v51 >> 3 > v50)
        v50 = v51 >> 3;
      if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFF0)
        v52 = 0xFFFFFFFFFFFFFFFLL;
      else
        v52 = v50;
      if (v52)
        v53 = (char *)sub_1000CB918(a1 + 152, v52);
      else
        v53 = 0;
      v54 = &v53[16 * v49];
      v55 = &v53[16 * v52];
      *(_QWORD *)v54 = CFSTR("Rap,RTKitIOConfig");
      v54[8] = 1;
      v48 = v54 + 16;
      v57 = *(_BYTE **)(a1 + 136);
      v56 = *(_BYTE **)(a1 + 144);
      if (v56 != v57)
      {
        do
        {
          v58 = *((_QWORD *)v56 - 2);
          v56 -= 16;
          v59 = v56[8];
          *((_QWORD *)v54 - 2) = v58;
          v54 -= 16;
          v54[8] = v59;
        }
        while (v56 != v57);
        v56 = (_BYTE *)*v45;
      }
      *(_QWORD *)(a1 + 136) = v54;
      *(_QWORD *)(a1 + 144) = v48;
      *(_QWORD *)(a1 + 152) = v55;
      if (v56)
        operator delete(v56);
    }
    else
    {
      *(_QWORD *)v47 = CFSTR("Rap,RTKitIOConfig");
      *(_BYTE *)(v47 + 8) = 1;
      v48 = (char *)(v47 + 16);
    }
    *(_QWORD *)(a1 + 144) = v48;
  }
  TypeID = CFNumberGetTypeID();
  *(_QWORD *)&__src = CFSTR("Rap,ChipID");
  *((_QWORD *)&__src + 1) = TypeID;
  v61 = CFNumberGetTypeID();
  *(_QWORD *)&v105 = CFSTR("Rap,BoardID");
  *((_QWORD *)&v105 + 1) = v61;
  v62 = CFNumberGetTypeID();
  *(_QWORD *)&v106 = CFSTR("Rap,SecurityDomain");
  *((_QWORD *)&v106 + 1) = v62;
  v63 = CFBooleanGetTypeID();
  v107 = CFSTR("Rap,ProductionMode");
  v108 = v63;
  v64 = CFBooleanGetTypeID();
  v109[0] = (unint64_t)CFSTR("Rap,SecurityMode");
  v109[1] = v64;
  v65 = CFNumberGetTypeID();
  v109[2] = (unint64_t)CFSTR("Rap,ECID");
  v109[3] = v65;
  v66 = CFDataGetTypeID();
  v109[4] = (unint64_t)CFSTR("Rap,Nonce");
  v109[5] = v66;
  sub_1000CB94C((uint64_t **)(a1 + 160), (unint64_t *)&__src, &v110);
  if (sub_1000CD69C(*(_DWORD **)(a1 + 232)))
    *(_QWORD *)(a1 + 184) = CFSTR("Rap,FdrRootCaDigest");
  if (sub_1000CD69C(*v14))
    *(_QWORD *)(a1 + 192) = CFSTR("Rap,FDRAllowUnsealed");
  *(_QWORD *)&__src = CFSTR("Rap,RTKitOS");
  WORD4(__src) = 1;
  *(_QWORD *)&v105 = CFSTR("Rap,RestoreRTKitOS");
  WORD4(v105) = 1;
  *(_QWORD *)&v106 = CFSTR("Rap,SoftwareBinaryDsp1");
  WORD4(v106) = 0;
  v107 = CFSTR("Rap,RTKitIOConfig");
  LOWORD(v108) = 0;
  sub_1000CBE6C((uint64_t **)(a1 + 200), (unint64_t *)&__src, v109);
  *(_QWORD *)(a1 + 224) = CFSTR("Rose");
  if ((sub_1000D28CC(a1, (uint64_t)cf, a3) & 1) == 0)
  {
    v98 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v98, 2u, "%s::%s: failed to initialize base class\n", v99, v100, v101, v102, v103, (char)"RoseRestoreHost");
    return 0;
  }
  return 1;
}

uint64_t sub_1000C9FF8(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

const void *sub_1000CA05C(uint64_t a1, const __CFDictionary *a2, int a3)
{
  void **v5;
  __int128 v6;
  void **v7;
  __int128 v8;
  void **v9;
  __int128 v10;
  void **v11;
  __int128 v12;
  const __CFDictionary *Value;
  const __CFDictionary *v14;
  CFTypeID v15;
  const __CFData *v16;
  CFTypeID TypeID;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  const void *v25;
  const void *v26;
  CFTypeID v27;
  CFTypeID v28;
  int v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  std::string *v37;
  __int128 v38;
  std::string *v39;
  __int128 v40;
  const void *v41;
  const void *v42;
  CFTypeID v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const void *v51;
  const void *v52;
  CFTypeID v53;
  uint64_t (***v54)(_QWORD, __int128 *);
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const void *v68;
  const void *v69;
  CFTypeID v70;
  uint64_t (***v71)(_QWORD, __int128 *);
  void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t (***v78)(_QWORD, __int128 *);
  uint64_t v79;
  int v80;
  int v81;
  char v82;
  char v83;
  const void *v84;
  const void *v85;
  CFTypeID v86;
  void *v87;
  std::string *v88;
  __int128 v89;
  std::string *v90;
  __int128 v91;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  const char *v99;
  void *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  const char *v124;
  void *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  void *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  void *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  void *v145[2];
  char v146;
  void *v147[2];
  char v148;
  void *v149[2];
  char v150;
  void *v151[2];
  char v152;
  void *v153[2];
  char v154;
  void *v155[2];
  char v156;
  void *__p[2];
  char v158;
  void *v159[2];
  char v160;
  void *v161[2];
  char v162;
  void *v163[2];
  char v164;
  void *v165[2];
  char v166;
  std::string v167;
  std::string v168;
  void *v169[2];
  char v170;
  void *v171[2];
  char v172;
  void *v173[2];
  char v174;
  void *v175[2];
  char v176;
  __int128 v177;
  std::string::size_type v178;
  __int128 v179;
  void *v180;
  __int128 v181;
  void *v182;
  __int128 v183;
  void *v184;
  __int128 __dst;
  void *v186;

  sub_1000CD7D4((uint64_t)&v183);
  v5 = (void **)sub_1000CB3A0((uint64_t)&v183, (unint64_t *)&off_100182AF8);
  if (*((char *)v5 + 23) < 0)
  {
    sub_1000CB554(&__dst, *v5, (unint64_t)v5[1]);
  }
  else
  {
    v6 = *(_OWORD *)v5;
    v186 = v5[2];
    __dst = v6;
  }
  sub_1000CC004((uint64_t)&v183, *((char **)&v183 + 1));
  sub_1000CD7D4((uint64_t)&v181);
  v7 = (void **)sub_1000CB3A0((uint64_t)&v181, (unint64_t *)off_100182B68);
  if (*((char *)v7 + 23) < 0)
  {
    sub_1000CB554(&v183, *v7, (unint64_t)v7[1]);
  }
  else
  {
    v8 = *(_OWORD *)v7;
    v184 = v7[2];
    v183 = v8;
  }
  sub_1000CC004((uint64_t)&v181, *((char **)&v181 + 1));
  sub_1000CD7D4((uint64_t)&v179);
  v9 = (void **)sub_1000CB3A0((uint64_t)&v179, (unint64_t *)&off_100182B70);
  if (*((char *)v9 + 23) < 0)
  {
    sub_1000CB554(&v181, *v9, (unint64_t)v9[1]);
  }
  else
  {
    v10 = *(_OWORD *)v9;
    v182 = v9[2];
    v181 = v10;
  }
  sub_1000CC004((uint64_t)&v179, *((char **)&v179 + 1));
  sub_1000CD7D4((uint64_t)&v177);
  v11 = (void **)sub_1000CB3A0((uint64_t)&v177, (unint64_t *)&off_100182AF0);
  if (*((char *)v11 + 23) < 0)
  {
    sub_1000CB554(&v179, *v11, (unint64_t)v11[1]);
  }
  else
  {
    v12 = *(_OWORD *)v11;
    v180 = v11[2];
    v179 = v12;
  }
  sub_1000CC004((uint64_t)&v177, *((char **)&v177 + 1));
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DeviceInfo"));
  v14 = Value;
  if (!Value || (v15 = CFGetTypeID(Value), v15 != CFDictionaryGetTypeID()))
  {
    sub_1000CB3F4(v175, "copyFirmwareUpdater: failed to get device info list");
    sub_1000D3514(a1 + 24, (uint64_t)v175, 4001, 0);
    if (v176 < 0)
      operator delete(v175[0]);
    v93 = sub_1000D3C90();
    v99 = "%s::%s: failed to get device info list\n";
    goto LABEL_112;
  }
  v16 = (const __CFData *)CFDictionaryGetValue(v14, CFSTR("Rap,RestoreBootNonce"));
  if (v16 && (TypeID = CFDataGetTypeID(), TypeID == CFGetTypeID(v16)))
  {
    v18 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v18, 0, "%s::%s: Restore boot nonce present!\n", v19, v20, v21, v22, v23, (char)"RoseRestoreHost");
    if (CFDataGetLength(v16) != 8)
    {
      sub_1000CB3F4(v173, "copyFirmwareUpdater: nonce is of unexpected size");
      sub_1000D3514(a1 + 24, (uint64_t)v173, 1005, 0);
      if (v174 < 0)
        operator delete(v173[0]);
      v93 = sub_1000D3C90();
      v99 = "%s::%s: nonce is of unexpected size\n";
      goto LABEL_112;
    }
    v143 = *(_QWORD *)CFDataGetBytePtr(v16);
  }
  else
  {
    v143 = 0;
  }
  v24 = CFDictionaryGetValue(v14, CFSTR("Rap,ChipRev"));
  v25 = CFDictionaryGetValue(v14, CFSTR("Rap,BoardID"));
  if (!v24
    || (v26 = v25) == 0
    || (v27 = CFDataGetTypeID(), v27 != CFGetTypeID(v24))
    || (v28 = CFDataGetTypeID(), v28 != CFGetTypeID(v26)))
  {
    sub_1000CB3F4(v171, "copyFirmwareUpdater: unexpected device info parameters");
    sub_1000D3514(a1 + 24, (uint64_t)v171, 1005, 0);
    if (v172 < 0)
      operator delete(v171[0]);
    v93 = sub_1000D3C90();
    v99 = "%s::%s: unexpected device info parameters\n";
    goto LABEL_112;
  }
  if (CFDataGetLength((CFDataRef)v24) != 2 || CFDataGetLength((CFDataRef)v26) != 2)
  {
    sub_1000CB3F4(v169, "copyFirmwareUpdater: bad device info parameters");
    sub_1000D3514(a1 + 24, (uint64_t)v169, 1005, 0);
    if (v170 < 0)
      operator delete(v169[0]);
    v93 = sub_1000D3C90();
    v99 = "%s::%s: bad device info parameters\n";
LABEL_112:
    v44 = 0;
    v71 = 0;
    v54 = 0;
    sub_1000D3D08((uint64_t)v93, 2u, v99, v94, v95, v96, v97, v98, (char)"RoseRestoreHost");
    v85 = 0;
    goto LABEL_88;
  }
  v29 = *(unsigned __int16 *)CFDataGetBytePtr((CFDataRef)v24);
  CFDataGetBytePtr((CFDataRef)v26);
  v30 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v30, 0, "%s::%s: Rose Hardware Info (Board ID: 0x%04x, Chip Revision: 0x%04x)\n", v31, v32, v33, v34, v35, (char)"RoseRestoreHost");
  v36 = sub_1000D3C90();
  sub_1000CB3F4(&v167, "RoseRestoreHost");
  v37 = std::string::append(&v167, "::");
  v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v168.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  v39 = std::string::append(&v168, "copyFirmwareUpdater");
  v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
  v178 = v39->__r_.__value_.__r.__words[2];
  v177 = v40;
  v39->__r_.__value_.__l.__size_ = 0;
  v39->__r_.__value_.__r.__words[2] = 0;
  v39->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v36, (uint64_t *)&v177, 0, (uint64_t)"Firmware File Dictionary: ", (uint64_t)a2);
  if (SHIBYTE(v178) < 0)
    operator delete((void *)v177);
  if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v168.__r_.__value_.__l.__data_);
  if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v167.__r_.__value_.__l.__data_);
  v41 = sub_1000D29F8(CFSTR("Rap,RTKitOS"), a2, a3);
  v42 = v41;
  if (v41)
  {
    v43 = CFGetTypeID(v41);
    if (v43 == CFDataGetTypeID())
    {
      sub_1000D4498(v42, 0, v29, &v177);
      v44 = v177;
      if (!(_QWORD)v177)
      {
        sub_1000CB3F4(v163, "copyFirmware: failed to init bundle firmware");
        sub_1000D3514(a1 + 24, (uint64_t)v163, 4000, 0);
        if (v164 < 0)
          operator delete(v163[0]);
        v125 = sub_1000D3C90();
        v44 = 0;
        v71 = 0;
        v54 = 0;
        sub_1000D3D08((uint64_t)v125, 2u, "%s::%s: failed to init bundle firmware\n", v126, v127, v128, v129, v130, (char)"RoseRestoreHost");
        v84 = 0;
        v52 = 0;
        v69 = 0;
        v85 = 0;
        goto LABEL_82;
      }
      if (!(*(unsigned int (**)(_QWORD, __int128 *))(*(_QWORD *)v177 + 16))(v177, &v181)
        || ((*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v44 + 16))(v44, &v183) & 1) == 0)
      {
        sub_1000CB3F4(v161, "copyFirmware: bundle firmware specified is invalid");
        sub_1000D3514(a1 + 24, (uint64_t)v161, 1000, 0);
        if (v162 < 0)
          operator delete(v161[0]);
        v106 = sub_1000D3C90();
        v71 = 0;
        v54 = 0;
        sub_1000D3D08((uint64_t)v106, 2u, "%s::%s: bundle firmware specified is invalid\n", v107, v108, v109, v110, v111, (char)"RoseRestoreHost");
        v84 = 0;
        v52 = 0;
        v69 = 0;
        v85 = 0;
        goto LABEL_82;
      }
      if (sub_1000CD69C(*(_DWORD **)(a1 + 232))
        && ((*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v44 + 16))(v44, &v179) & 1) == 0)
      {
        v45 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v45, 3u, "%s::%s: copyfirmware: ICNF missing in bundle firmware\n", v46, v47, v48, v49, v50, (char)"RoseRestoreHost");
      }
      if (CFDictionaryContainsKey(a2, *(const void **)(a1 + 8)))
      {
        v51 = sub_1000D29F8(*(void **)(a1 + 8), a2, a3);
        v52 = v51;
        if (!v51 || (v53 = CFGetTypeID(v51), v53 != CFDataGetTypeID()))
        {
          sub_1000CB3F4(v159, "copyFirmware: rooted override data unavailable");
          sub_1000D3514(a1 + 24, (uint64_t)v159, 1000, 0);
          if (v160 < 0)
            operator delete(v159[0]);
          v55 = sub_1000D3C90();
          v61 = "%s::%s: rooted override data unavailable\n";
          goto LABEL_126;
        }
        sub_1000D4498(v52, 0, v29, &v177);
        v54 = (uint64_t (***)(_QWORD, __int128 *))v177;
        if (!(_QWORD)v177)
        {
          sub_1000CB3F4(__p, "copyFirmware: failed to init ftab file object");
          sub_1000D3514(a1 + 24, (uint64_t)__p, 4000, 0);
          if (v158 < 0)
            operator delete(__p[0]);
          v55 = sub_1000D3C90();
          v61 = "%s::%s: failed to init ftab file object\n";
LABEL_126:
          v71 = 0;
          v54 = 0;
          sub_1000D3D08((uint64_t)v55, 2u, v61, v56, v57, v58, v59, v60, (char)"RoseRestoreHost");
          v84 = 0;
          v69 = 0;
          v85 = 0;
LABEL_82:
          CFRelease(v42);
          if (v69)
            CFRelease(v69);
          if (v52)
            CFRelease(v52);
          if (v84)
            CFRelease(v84);
          goto LABEL_88;
        }
      }
      else
      {
        v62 = sub_1000D3C90();
        v54 = 0;
        sub_1000D3D08((uint64_t)v62, 0, "%s::%s: no firmware override specified\n", v63, v64, v65, v66, v67, (char)"RoseRestoreHost");
        v52 = 0;
      }
      if (CFDictionaryContainsKey(a2, CFSTR("Rap,RestoreRTKitOS")))
      {
        v68 = sub_1000D29F8(CFSTR("Rap,RestoreRTKitOS"), a2, a3);
        v69 = v68;
        if (v68 && (v70 = CFGetTypeID(v68), v70 == CFDataGetTypeID()))
        {
          sub_1000D4498(v69, 0, v29, &v177);
          v71 = (uint64_t (***)(_QWORD, __int128 *))v177;
          if ((_QWORD)v177)
          {
            if (((*(uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)v177 + 16))(v177, &__dst) & 1) == 0)
            {
              sub_1000CB3F4(v151, "copyFirmware: bundle cert firmware doesn't have rrko");
              sub_1000D3514(a1 + 24, (uint64_t)v151, 1000, 0);
              if (v152 < 0)
                operator delete(v151[0]);
              v72 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v72, 2u, "%s::%s: bundle cert firmware doesn't have 'rrko'\n", v73, v74, v75, v76, v77, (char)"RoseRestoreHost");
LABEL_140:
              v84 = 0;
LABEL_144:
              v85 = 0;
              goto LABEL_82;
            }
LABEL_57:
            v78 = v71;
            v79 = v44;
            if (v54)
            {
              v80 = (*v54)[2](v54, &__dst);
              v81 = (*v54)[2](v54, &v183);
              if (v80)
                v78 = v54;
              else
                v78 = v71;
              if (v81)
                v79 = (uint64_t)v54;
              else
                v79 = v44;
            }
            v82 = (*(uint64_t (**)(uint64_t, __int128 *))(*(_QWORD *)v79 + 16))(v79, &__dst);
            if (v78)
              v83 = v82;
            else
              v83 = 1;
            if ((v83 & 1) != 0)
            {
              v84 = 0;
            }
            else
            {
              v84 = (const void *)(**v78)(v78, &__dst);
              if (!v84)
              {
                sub_1000CB3F4(v149, "copyFirmware: could not get 'rrko' object from ftab");
                sub_1000D3514(a1 + 24, (uint64_t)v149, 1000, 0);
                if (v150 < 0)
                  operator delete(v149[0]);
                v131 = sub_1000D3C90();
                sub_1000D3D08((uint64_t)v131, 2u, "%s::%s: could not get 'rrko' object from ftab\n", v132, v133, v134, v135, v136, (char)"RoseRestoreHost");
                goto LABEL_140;
              }
              if ((sub_1000D648C(v79, &__dst, (const __CFData *)v84) & 1) == 0)
              {
                sub_1000CB3F4(v147, "copyFirmware: could not add 'rrko' object to final ftab");
                sub_1000D3514(a1 + 24, (uint64_t)v147, 1000, 0);
                if (v148 < 0)
                  operator delete(v147[0]);
                v137 = sub_1000D3C90();
                sub_1000D3D08((uint64_t)v137, 2u, "%s::%s: could not add 'rrko' object to final ftab\n", v138, v139, v140, v141, v142, (char)"RoseRestoreHost");
                goto LABEL_144;
              }
            }
            if (v143)
              sub_1000D62C0(v79, v143);
            v85 = (const void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v79 + 40))(v79);
            if (v85 && (v86 = CFDataGetTypeID(), v86 == CFGetTypeID(v85)))
            {
              v87 = sub_1000D3C90();
              sub_1000CB3F4(&v167, "RoseRestoreHost");
              v88 = std::string::append(&v167, "::");
              v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
              v168.__r_.__value_.__r.__words[2] = v88->__r_.__value_.__r.__words[2];
              *(_OWORD *)&v168.__r_.__value_.__l.__data_ = v89;
              v88->__r_.__value_.__l.__size_ = 0;
              v88->__r_.__value_.__r.__words[2] = 0;
              v88->__r_.__value_.__r.__words[0] = 0;
              v90 = std::string::append(&v168, "copyFirmwareUpdater");
              v91 = *(_OWORD *)&v90->__r_.__value_.__l.__data_;
              v178 = v90->__r_.__value_.__r.__words[2];
              v177 = v91;
              v90->__r_.__value_.__l.__size_ = 0;
              v90->__r_.__value_.__r.__words[2] = 0;
              v90->__r_.__value_.__r.__words[0] = 0;
              sub_1000D42F0((uint64_t)v87, (uint64_t *)&v177, 3u, (uint64_t)"outData", (uint64_t)v85);
              if (SHIBYTE(v178) < 0)
                operator delete((void *)v177);
              if (SHIBYTE(v168.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v168.__r_.__value_.__l.__data_);
              if (SHIBYTE(v167.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v167.__r_.__value_.__l.__data_);
              (*(void (**)(uint64_t))(*(_QWORD *)v79 + 24))(v79);
            }
            else
            {
              sub_1000CB3F4(v145, "copyFirmware: could not create output data");
              sub_1000D3514(a1 + 24, (uint64_t)v145, 1000, 0);
              if (v146 < 0)
                operator delete(v145[0]);
              v112 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v112, 2u, "%s::%s: could not create output data\n", v113, v114, v115, v116, v117, (char)"RoseRestoreHost");
            }
            goto LABEL_82;
          }
          sub_1000CB3F4(v153, "copyFirmware: failed to init certification firmware");
          sub_1000D3514(a1 + 24, (uint64_t)v153, 4000, 0);
          if (v154 < 0)
            operator delete(v153[0]);
          v118 = sub_1000D3C90();
          v124 = "%s::%s: failed to init certification firmware\n";
        }
        else
        {
          sub_1000CB3F4(v155, "copyFirmware: rrko bundle data unavailable");
          sub_1000D3514(a1 + 24, (uint64_t)v155, 1000, 0);
          if (v156 < 0)
            operator delete(v155[0]);
          v118 = sub_1000D3C90();
          v124 = "%s::%s: rrko bundle data unavailable\n";
        }
        v71 = 0;
        sub_1000D3D08((uint64_t)v118, 2u, v124, v119, v120, v121, v122, v123, (char)"RoseRestoreHost");
        v84 = 0;
        v85 = 0;
        goto LABEL_82;
      }
      v71 = 0;
      v69 = 0;
      goto LABEL_57;
    }
  }
  sub_1000CB3F4(v165, "copyFirmware: rkos bundle data unavailable");
  sub_1000D3514(a1 + 24, (uint64_t)v165, 1000, 0);
  if (v166 < 0)
    operator delete(v165[0]);
  v100 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v100, 2u, "%s::%s: rkos bundle data unavailable\n", v101, v102, v103, v104, v105, (char)"RoseRestoreHost");
  v84 = 0;
  v52 = 0;
  v69 = 0;
  v85 = 0;
  v54 = 0;
  v71 = 0;
  v44 = 0;
  if (v42)
    goto LABEL_82;
LABEL_88:
  if (SHIBYTE(v180) < 0)
    operator delete((void *)v179);
  if (SHIBYTE(v182) < 0)
    operator delete((void *)v181);
  if (SHIBYTE(v184) < 0)
    operator delete((void *)v183);
  if (SHIBYTE(v186) < 0)
    operator delete((void *)__dst);
  if (v54)
    ((void (*)(uint64_t (***)(_QWORD, __int128 *)))(*v54)[7])(v54);
  if (v71)
    ((void (*)(uint64_t (***)(_QWORD, __int128 *)))(*v71)[7])(v71);
  if (v44)
    (*(void (**)(uint64_t))(*(_QWORD *)v44 + 56))(v44);
  return v85;
}

void sub_1000CB080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *__p,uint64_t a62,int a63)
{
  char a66;
  uint64_t v66;

  if (a66 < 0)
    operator delete(__p);
  if (*(char *)(v66 - 185) < 0)
    operator delete(*(void **)(v66 - 208));
  if (*(char *)(v66 - 153) < 0)
    operator delete(*(void **)(v66 - 176));
  if (*(char *)(v66 - 121) < 0)
    operator delete(*(void **)(v66 - 144));
  if (*(char *)(v66 - 89) < 0)
    operator delete(*(void **)(v66 - 112));
  _Unwind_Resume(a1);
}

_QWORD *sub_1000CB3A0(uint64_t a1, unint64_t *a2)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *(_QWORD **)(a1 + 8);
  if (!v2)
LABEL_8:
    sub_1000CC054("map::at:  key not found");
  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = v2[4];
      if (v3 >= v4)
        break;
      v2 = (_QWORD *)*v2;
      if (!v2)
        goto LABEL_8;
    }
    if (v4 >= v3)
      return v2 + 5;
    v2 = (_QWORD *)v2[1];
    if (!v2)
      goto LABEL_8;
  }
}

_QWORD *sub_1000CB3F4(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    sub_1000CB4A4();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void sub_1000CB4A4()
{
  sub_1000CB4B8("basic_string");
}

void sub_1000CB4B8(const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1000CB508(exception, a1);
}

void sub_1000CB4F4(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1000CB508(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  return result;
}

void sub_1000CB52C()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
}

void *sub_1000CB554(_BYTE *__dst, void *__src, unint64_t a3)
{
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;

  v5 = __dst;
  if (a3 > 0x16)
  {
    if (a3 >= 0x7FFFFFFFFFFFFFF8)
      sub_1000CB4A4();
    v6 = (a3 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a3 | 7) != 0x17)
      v6 = a3 | 7;
    v7 = v6 + 1;
    v8 = operator new(v6 + 1);
    v5[1] = a3;
    v5[2] = v7 | 0x8000000000000000;
    *v5 = v8;
    v5 = v8;
  }
  else
  {
    __dst[23] = a3;
  }
  return memmove(v5, __src, a3 + 1);
}

uint64_t sub_1000CB5E0(uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

char *sub_1000CB638(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      sub_1000CB780();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = sub_1000CB740(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *sub_1000CB740(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    sub_1000CB780();
  result = (char *)sub_1000CB794((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void sub_1000CB780()
{
  sub_1000CB4B8("vector");
}

void *sub_1000CB794(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    sub_1000CB52C();
  return operator new(8 * a2);
}

char *sub_1000CB7C8(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  size_t v18;
  void *v19;
  char *v20;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      sub_1000CB780();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = sub_1000CB8D8(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v17 - 7;
      v19 = v9;
      v20 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9 - 7);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v17 - 7;
    v19 = v9;
    v20 = v16;
LABEL_18:
    result = (char *)memmove(v19, v20, v18);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *sub_1000CB8D8(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    sub_1000CB780();
  result = (char *)sub_1000CB918((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *sub_1000CB918(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    sub_1000CB52C();
  return operator new(16 * a2);
}

uint64_t **sub_1000CB94C(uint64_t **result, unint64_t *a2, unint64_t *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  char v9;
  uint64_t **v10;
  uint64_t *v11;
  uint64_t *v12;

  v5 = result;
  if (result[2])
  {
    v6 = *result;
    v7 = result[1];
    *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1])
      v8 = (uint64_t *)v6[1];
    else
      v8 = v6;
    v10 = result;
    v11 = v8;
    v12 = v8;
    if (v8)
    {
      v11 = sub_1000CBCCC((uint64_t)v8);
      while (a2 != a3)
      {
        sub_1000CBA50(v5, a2, v8);
        if ((v9 & 1) != 0)
        {
          v8 = v11;
          v12 = v11;
          if (!v11)
          {
            a2 += 2;
            break;
          }
          v11 = sub_1000CBCCC((uint64_t)v11);
        }
        else
        {
          v8 = v12;
        }
        a2 += 2;
        if (!v8)
          break;
      }
    }
    result = (uint64_t **)sub_1000CBD20((uint64_t)&v10);
  }
  while (a2 != a3)
  {
    result = sub_1000CBDB4(v5, a2, a2);
    a2 += 2;
  }
  return result;
}

void sub_1000CBA3C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000CBD20((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000CBA50(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t **v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t **v7;
  unint64_t v8;
  uint64_t v9;

  v4 = a1 + 1;
  v5 = a1[1];
  v6 = *a2;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v6 >= v8)
          break;
        v5 = *v7;
        v4 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= v6)
        return (uint64_t *)v7;
      v5 = v7[1];
      if (!v5)
      {
        v4 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    v9 = a2[1];
    a3[4] = v6;
    a3[5] = v9;
    sub_1000CBAE0(a1, (uint64_t)v7, v4, a3);
  }
  return a3;
}

uint64_t *sub_1000CBAE0(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = sub_1000CBB34(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *sub_1000CBB34(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

_QWORD *sub_1000CBCCC(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;

  result = *(_QWORD **)(a1 + 16);
  if (result)
  {
    v3 = (_QWORD *)*result;
    if (*result == a1)
    {
      *result = 0;
      while (1)
      {
        v4 = (_QWORD *)result[1];
        if (!v4)
          break;
        do
        {
          result = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; v3 = (_QWORD *)result[1])
      {
        do
        {
          result = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t sub_1000CBD20(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  sub_1000CBD74(*(_QWORD *)a1, *(_QWORD **)(a1 + 16));
  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v3 = (_QWORD *)v2[2];
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = (_QWORD *)v3[2];
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    sub_1000CBD74(*(_QWORD *)a1, v2);
  }
  return a1;
}

void sub_1000CBD74(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1000CBD74(a1, *a2);
    sub_1000CBD74(a1, a2[1]);
    operator delete(a2);
  }
}

uint64_t **sub_1000CBDB4(uint64_t **a1, unint64_t *a2, _OWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v10 + 2) = *a3;
    sub_1000CBAE0(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t **sub_1000CBE6C(uint64_t **result, unint64_t *a2, unint64_t *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  char v9;
  uint64_t **v10;
  uint64_t *v11;
  uint64_t *v12;

  v5 = result;
  if (result[2])
  {
    v6 = *result;
    v7 = result[1];
    *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1])
      v8 = (uint64_t *)v6[1];
    else
      v8 = v6;
    v10 = result;
    v11 = v8;
    v12 = v8;
    if (v8)
    {
      v11 = sub_1000CBCCC((uint64_t)v8);
      while (a2 != a3)
      {
        sub_1000CBF70(v5, a2, (uint64_t)v8);
        if ((v9 & 1) != 0)
        {
          v8 = v11;
          v12 = v11;
          if (!v11)
          {
            a2 += 2;
            break;
          }
          v11 = sub_1000CBCCC((uint64_t)v11);
        }
        else
        {
          v8 = v12;
        }
        a2 += 2;
        if (!v8)
          break;
      }
    }
    result = (uint64_t **)sub_1000CBD20((uint64_t)&v10);
  }
  while (a2 != a3)
  {
    result = sub_1000CBDB4(v5, a2, a2);
    a2 += 2;
  }
  return result;
}

void sub_1000CBF5C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000CBD20((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t **sub_1000CBF70(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t **v4;
  uint64_t *v5;
  unint64_t v6;
  uint64_t **v7;
  unint64_t v8;

  v4 = a1 + 1;
  v5 = a1[1];
  v6 = *a2;
  if (v5)
  {
    while (1)
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v6 >= v8)
          break;
        v5 = *v7;
        v4 = v7;
        if (!*v7)
          goto LABEL_9;
      }
      if (v8 >= v6)
        return v7;
      v5 = v7[1];
      if (!v5)
      {
        v4 = v7 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
    v7 = a1 + 1;
LABEL_9:
    *(_QWORD *)(a3 + 32) = v6;
    *(_WORD *)(a3 + 40) = *((_WORD *)a2 + 4);
    sub_1000CBAE0(a1, (uint64_t)v7, v4, (uint64_t *)a3);
  }
  return (uint64_t **)a3;
}

void sub_1000CC004(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1000CC004(a1, *(_QWORD *)a2);
    sub_1000CC004(a1, *((_QWORD *)a2 + 1));
    if (a2[63] < 0)
      operator delete(*((void **)a2 + 5));
    operator delete(a2);
  }
}

void sub_1000CC054(const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  sub_1000CC0A4(exception, a1);
}

void sub_1000CC090(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *sub_1000CC0A4(std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  return result;
}

uint64_t RoseUpdaterGetTags(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  void *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  CFIndex v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t (***v34)(_QWORD);

  v8 = sub_1000D3C90();
  v9 = sub_1000D3ADC((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    v13 = v9;
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: failed to init logging\n", v15, v16, v17, v18, v19, (char)"RoseRestoreInfo");
    v20 = kCFAllocatorDefault;
    v21 = v13;
LABEL_9:
    v11 = 0;
    *a4 = CFErrorCreate(v20, CFSTR("RoseRestoreInfo"), v21, 0);
    return v11;
  }
  sub_1000C9680(a1, CFSTR("RoseRestoreInfo"), &v34);
  v10 = (uint64_t)v34;
  if (!v34)
  {
    v22 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v22, 2u, "%s::%s: failed to create host object\n", v23, v24, v25, v26, v27, (char)"RoseRestoreInfo");
    v20 = kCFAllocatorDefault;
    v21 = 4000;
    goto LABEL_9;
  }
  v11 = (**v34)(v34);
  if (!v11)
  {
    v28 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: failed to get tags\n", v29, v30, v31, v32, v33, (char)"RoseRestoreInfo");
    *a4 = sub_1000D27D8(v10);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  return v11;
}

void sub_1000CC234(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t RoseUpdaterCopyFirmware(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  void *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFAllocator *v20;
  CFIndex v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  v8 = sub_1000D3C90();
  v9 = sub_1000D3ADC((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    v13 = v9;
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: failed to init logging\n", v15, v16, v17, v18, v19, (char)"RoseRestoreInfo");
    v20 = kCFAllocatorDefault;
    v21 = v13;
LABEL_9:
    v11 = 0;
    *a4 = CFErrorCreate(v20, CFSTR("RoseRestoreInfo"), v21, 0);
    return v11;
  }
  sub_1000C9680(a1, CFSTR("RoseRestoreInfo"), &v34);
  v10 = v34;
  if (!v34)
  {
    v22 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v22, 2u, "%s::%s: failed to create host object\n", v23, v24, v25, v26, v27, (char)"RoseRestoreInfo");
    v20 = kCFAllocatorDefault;
    v21 = 4000;
    goto LABEL_9;
  }
  v11 = sub_1000CF334(v34);
  if (!v11)
  {
    v28 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: failed to copy firmware\n", v29, v30, v31, v32, v33, (char)"RoseRestoreInfo");
    *a4 = sub_1000D27D8(v10);
  }
  (*(void (**)(uint64_t))(*(_QWORD *)v10 + 24))(v10);
  return v11;
}

void sub_1000CC3B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t RoseUpdaterCreateRequest(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  void *v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  const void *Value;
  CFTypeID TypeID;
  uint64_t v14;
  unint64_t *p_shared_owners;
  unint64_t v16;
  uint64_t v17;
  std::__shared_weak_count *v18;
  unint64_t *v19;
  unint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  CFErrorRef v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  std::__shared_weak_count *v34;
  unint64_t *v35;
  unint64_t v36;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  CFIndex v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *__p[2];
  char v64;
  uint64_t v65;
  std::__shared_weak_count *v66;
  void *v67[2];
  char v68;
  _BYTE v69[8];
  char *v70;
  uint64_t v71;
  _QWORD v72[2];
  __int16 v73;
  uint64_t v74;
  std::__shared_weak_count *v75;
  _BYTE v76[16];

  sub_1000D3354(v76, CFSTR("RoseRestoreInfo"));
  v74 = 0;
  v75 = 0;
  v73 = 0;
  v72[0] = CFSTR("Rap,ProductionMode");
  v72[1] = CFSTR("Rap,SecurityMode");
  v8 = sub_1000D3C90();
  v9 = sub_1000D3ADC((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    v44 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v44, 2u, "%s::%s: failed to init logging\n", v45, v46, v47, v48, v49, (char)"RoseRestoreInfo");
    v50 = v9;
LABEL_38:
    v17 = 0;
    *a4 = CFErrorCreate(kCFAllocatorDefault, CFSTR("RoseRestoreInfo"), v50, 0);
    goto LABEL_28;
  }
  sub_1000DBDD4(a1, "demoteProd", &v71);
  v10 = v71;
  if (HIDWORD(v71) != 4006)
  {
    if (HIDWORD(v71))
    {
      v57 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v57, 2u, "%s::%s: failed to parse debug arguments\n", v58, v59, v60, v61, v62, (char)"RoseRestoreInfo");
      v50 = v10 >> 32;
      goto LABEL_38;
    }
    LOBYTE(v73) = (_DWORD)v71 == 1;
  }
  sub_1000C9680(a1, CFSTR("RoseRestoreInfo"), &v71);
  v11 = v71;
  if (!v71)
  {
    v51 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v51, 2u, "%s::%s: failed to create host object\n", v52, v53, v54, v55, v56, (char)"RoseRestoreInfo");
    v50 = 4000;
    goto LABEL_38;
  }
  Value = CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
  if (Value && (TypeID = CFDataGetTypeID(), TypeID == CFGetTypeID(Value)))
  {
    sub_1000CD7D4((uint64_t)v69);
    sub_1000D97C4((uint64_t)v69, Value, 0, &v71);
    sub_1000CC858(&v74, &v71);
    v14 = v71;
    v71 = 0;
    if (v14)
      (*(void (**)(uint64_t))(*(_QWORD *)v14 + 56))(v14);
    sub_1000CC004((uint64_t)v69, v70);
    if (v74)
    {
      v65 = v74;
      v66 = v75;
      if (v75)
      {
        p_shared_owners = (unint64_t *)&v75->__shared_owners_;
        do
          v16 = __ldxr(p_shared_owners);
        while (__stxr(v16 + 1, p_shared_owners));
      }
      v17 = (*(uint64_t (**)(uint64_t, uint64_t *, _QWORD *))(*(_QWORD *)v11 + 8))(v11, &v65, v72);
      v18 = v66;
      if (v66)
      {
        v19 = (unint64_t *)&v66->__shared_owners_;
        do
          v20 = __ldaxr(v19);
        while (__stlxr(v20 - 1, v19));
        if (!v20)
        {
          ((void (*)(std::__shared_weak_count *))v18->__on_zero_shared)(v18);
          std::__shared_weak_count::__release_weak(v18);
        }
      }
      if (v17)
        goto LABEL_27;
      v21 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v21, 2u, "%s::%s: failed to create request dict\n", v22, v23, v24, v25, v26, (char)"RoseRestoreInfo");
      sub_1000CB3F4(__p, "RoseUpdaterCreateRequest: failed to create request dict");
      sub_1000D3514((uint64_t)v76, (uint64_t)__p, 4001, 0);
      if (v64 < 0)
        operator delete(__p[0]);
      v27 = sub_1000D27D8(v11);
    }
    else
    {
      v28 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: Failed to find firmware\n", v29, v30, v31, v32, v33, (char)"RoseRestoreInfo");
      sub_1000CB3F4(v67, "RoseUpdaterCreateRequest: failed to open firmware");
      sub_1000D3514((uint64_t)v76, (uint64_t)v67, 1000, 0);
      if (v68 < 0)
        operator delete(v67[0]);
      v27 = sub_1000D3358((uint64_t)v76);
    }
    v17 = 0;
    *a4 = v27;
  }
  else
  {
    v38 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v38, 0, "%s::%s: Invalid or no firmware file present in restore options\n", v39, v40, v41, v42, v43, (char)"RoseRestoreInfo");
    v17 = 0;
  }
LABEL_27:
  (*(void (**)(uint64_t))(*(_QWORD *)v11 + 24))(v11);
LABEL_28:
  v34 = v75;
  if (v75)
  {
    v35 = (unint64_t *)&v75->__shared_owners_;
    do
      v36 = __ldaxr(v35);
    while (__stlxr(v36 - 1, v35));
    if (!v36)
    {
      ((void (*)(std::__shared_weak_count *))v34->__on_zero_shared)(v34);
      std::__shared_weak_count::__release_weak(v34);
    }
  }
  sub_1000D369C(v76);
  return v17;
}

void sub_1000CC7A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,char a26,uint64_t a27)
{
  uint64_t v27;
  uint64_t v28;

  if (a17 < 0)
    operator delete(__p);
  (*(void (**)(uint64_t))(*(_QWORD *)v27 + 24))(v27);
  sub_1000CB5E0(v28 - 64);
  sub_1000D369C(v28 - 48);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000CC858(_QWORD *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *v5;
  std::__shared_weak_count *v6;
  unint64_t *p_shared_owners;
  unint64_t v8;

  v4 = *a2;
  if (*a2)
  {
    v5 = operator new(0x20uLL);
    *v5 = &off_100182BA0;
    v5[1] = 0;
    v5[2] = 0;
    v5[3] = v4;
  }
  else
  {
    v5 = 0;
  }
  *a2 = 0;
  v6 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v5;
  if (v6)
  {
    p_shared_owners = (unint64_t *)&v6->__shared_owners_;
    do
      v8 = __ldaxr(p_shared_owners);
    while (__stlxr(v8 - 1, p_shared_owners));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v6->__on_zero_shared)(v6);
      std::__shared_weak_count::__release_weak(v6);
    }
  }
  return a1;
}

__CFDictionary *RoseUpdaterGetSharedInfo(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  void *v8;
  int v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFDictionary *Mutable;
  const __CFDictionary *Value;
  const __CFDictionary *v18;
  CFTypeID v19;
  const __CFData *v20;
  const __CFData *v21;
  CFTypeID v22;
  const UInt8 *BytePtr;
  size_t Length;
  const __CFData *v25;
  const __CFData *v26;
  CFTypeID v27;
  const UInt8 *v28;
  size_t v29;
  std::__shared_weak_count *size;
  char v31;
  unint64_t *p_shared_owners;
  unint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  CFStringRef v58;
  const void *ValueForKeyPathInDict;
  CFTypeID v60;
  CFStringRef v61;
  const void *v62;
  CFTypeID v63;
  void *v64;
  const void *v65;
  CFTypeID TypeID;
  void *v67;
  std::string *v68;
  __int128 v69;
  std::string *v70;
  __int128 v71;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  CFErrorRef v79;
  void *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  void *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  const char *v92;
  void *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  void *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  const char *v105;
  void *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  const char *v112;
  void *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  std::string __dst;
  std::string v120;
  void *__p[2];
  std::string::size_type v122;
  void *v123[2];
  char v124;
  void *v125[2];
  char v126;
  _BYTE v127[8];
  char *v128;
  void *v129[2];
  char v130;
  void *v131[2];
  char v132;
  void *v133[2];
  char v134;
  void *v135[2];
  char v136;
  void *v137[2];
  char v138;
  void *v139[2];
  char v140;
  void *v141[2];
  char v142;
  void *v143[2];
  char v144;
  _BYTE v145[22];
  _WORD v146[5];

  sub_1000D3354(v145, CFSTR("RoseRestoreInfo"));
  v8 = sub_1000D3C90();
  v9 = sub_1000D3ADC((uint64_t)v8, a1, a2, a3);
  if (v9)
  {
    v73 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v73, 2u, "%s::%s: failed to init logging\n", v74, v75, v76, v77, v78, (char)"RoseRestoreInfo");
    v79 = CFErrorCreate(kCFAllocatorDefault, CFSTR("RoseRestoreInfo"), v9, 0);
    v64 = 0;
    Mutable = 0;
    *a4 = v79;
    goto LABEL_41;
  }
  v10 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v10, 0, "%s::%s: performing Rose pairing operation -- sharing digest dictionary\n", v11, v12, v13, v14, v15, (char)"RoseRestoreInfo");
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    sub_1000CB3F4(v143, "RoseUpdaterGetSharedInfo: Failed to allocate shared info dict");
    sub_1000D3514((uint64_t)v145, (uint64_t)v143, 4000, 0);
    if (v144 < 0)
      operator delete(v143[0]);
    v80 = sub_1000D3C90();
    v64 = 0;
    sub_1000D3D08((uint64_t)v80, 2u, "%s::%s: Failed to allocate shared info dictionary\n", v81, v82, v83, v84, v85, (char)"RoseRestoreInfo");
    Mutable = 0;
    goto LABEL_41;
  }
  LOWORD(__dst.__r_.__value_.__l.__data_) = 0;
  v146[0] = 0;
  __p[0] = 0;
  __p[1] = 0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  v18 = Value;
  if (!Value || (v19 = CFGetTypeID(Value), v19 != CFDictionaryGetTypeID()))
  {
    v40 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v40, 0, "%s::%s: Could not obtain deviceInfo dictionary. Sharing all digest information.\n", v41, v42, v43, v44, v45, (char)"RoseRestoreInfo");
    goto LABEL_20;
  }
  v20 = (const __CFData *)CFDictionaryGetValue(v18, CFSTR("Rap,ChipID"));
  v21 = v20;
  if (!v20 || (v22 = CFGetTypeID(v20), v22 != CFDataGetTypeID()))
  {
    v99 = sub_1000D3C90();
    v105 = "%s::%s: chipID is empty or isn't data type\n";
LABEL_84:
    sub_1000D3D08((uint64_t)v99, 2u, v105, v100, v101, v102, v103, v104, (char)"RoseRestoreInfo");
    goto LABEL_18;
  }
  if (CFDataGetLength(v21) != 2)
  {
    v99 = sub_1000D3C90();
    v105 = "%s::%s: chipID is not 2 bytes in length. Assuming Rose-SE pairing is not supported.\n";
    goto LABEL_84;
  }
  BytePtr = CFDataGetBytePtr(v21);
  Length = CFDataGetLength(v21);
  memcpy(&__dst, BytePtr, Length);
  v25 = (const __CFData *)CFDictionaryGetValue(v18, CFSTR("Rap,BoardID"));
  v26 = v25;
  if (!v25 || (v27 = CFGetTypeID(v25), v27 != CFDataGetTypeID()))
  {
    v99 = sub_1000D3C90();
    v105 = "%s::%s: boardID is empty or isn't data type\n";
    goto LABEL_84;
  }
  if (CFDataGetLength(v26) != 2)
  {
    v99 = sub_1000D3C90();
    v105 = "%s::%s: boardID is not 2 bytes in length. Assuming Rose-SE pairing is not supported.\n";
    goto LABEL_84;
  }
  v28 = CFDataGetBytePtr(v26);
  v29 = CFDataGetLength(v26);
  memcpy(v146, v28, v29);
  sub_1000CD498(LOWORD(__dst.__r_.__value_.__l.__data_), &v120);
  size = (std::__shared_weak_count *)v120.__r_.__value_.__l.__size_;
  *(_OWORD *)__p = *(_OWORD *)&v120.__r_.__value_.__l.__data_;
  if (v120.__r_.__value_.__r.__words[0])
  {
    v31 = sub_1000CD6BC((int *)v120.__r_.__value_.__l.__data_, v146[0]);
    if (!size)
      goto LABEL_17;
  }
  else
  {
    v113 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v113, 2u, "%s::%s: failed to create capabilities\n", v114, v115, v116, v117, v118, (char)"RoseRestoreInfo");
    v31 = 0;
    if (!size)
      goto LABEL_17;
  }
  p_shared_owners = (unint64_t *)&size->__shared_owners_;
  do
    v33 = __ldaxr(p_shared_owners);
  while (__stlxr(v33 - 1, p_shared_owners));
  if (!v33)
  {
    ((void (*)(std::__shared_weak_count *))size->__on_zero_shared)(size);
    std::__shared_weak_count::__release_weak(size);
  }
LABEL_17:
  if ((v31 & 1) == 0)
  {
LABEL_18:
    v34 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v34, 0, "%s::%s: Returning empty sharing digest dictionary -- Rose-SE pairing not supported for this device.\n", v35, v36, v37, v38, v39, (char)"RoseRestoreInfo");
    goto LABEL_46;
  }
LABEL_20:
  v46 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v46, 0, "%s::%s: Rose-SE pairing is supported for this device\n", v47, v48, v49, v50, v51, (char)"RoseRestoreInfo");
  sub_1000DBDD4(a1, "buildIDRoseSEPair", __p);
  if ((unint64_t)__p[0] >> 32 || !LODWORD(__p[0]))
  {
    v65 = CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
    if (v65 && (TypeID = CFDataGetTypeID(), TypeID == CFGetTypeID(v65)))
    {
      sub_1000CD7D4((uint64_t)v127);
      sub_1000D97C4((uint64_t)v127, v65, 0, __p);
      v64 = __p[0];
      __p[0] = 0;
      sub_1000CC004((uint64_t)v127, v128);
      if (v64)
      {
        ValueForKeyPathInDict = sub_1000DA1B8((uint64_t)v64, CFSTR("Rap,RTKitOS"));
        v62 = sub_1000DA1B8((uint64_t)v64, CFSTR("Rap,SoftwareBinaryDsp1"));
        goto LABEL_33;
      }
      sub_1000CB3F4(v125, "RoseUpdaterGetSharedInfo: Failed to open firmware");
      sub_1000D3514((uint64_t)v145, (uint64_t)v125, 1000, 0);
      if (v126 < 0)
        operator delete(v125[0]);
      v86 = sub_1000D3C90();
      v92 = "%s::%s: Failed to open firmware\n";
    }
    else
    {
      sub_1000CB3F4(v129, "RoseUpdaterGetSharedInfo: Invalid or no firmware file present in restore options");
      sub_1000D3514((uint64_t)v145, (uint64_t)v129, 1000, 0);
      if (v130 < 0)
        operator delete(v129[0]);
      v86 = sub_1000D3C90();
      v92 = "%s::%s: Invalid or no firmware file present in restore options\n";
    }
    v64 = 0;
    sub_1000D3D08((uint64_t)v86, 2u, v92, v87, v88, v89, v90, v91, (char)"RoseRestoreInfo");
  }
  else
  {
    v52 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v52, 0, "%s::%s: forcing pairing with build ID: %u\n", v53, v54, v55, v56, v57, (char)"RoseRestoreInfo");
    v58 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@.%@.%@"), CFSTR("BuildIdentity"), CFSTR("Rap,RTKitOS"), CFSTR("Digest"), __dst.__r_.__value_.__r.__words[0]);
    if (v58)
    {
      ValueForKeyPathInDict = (const void *)AMSupportGetValueForKeyPathInDict(kCFAllocatorDefault, a1, v58);
      CFRelease(v58);
      if (ValueForKeyPathInDict)
      {
        v60 = CFDataGetTypeID();
        if (v60 == CFGetTypeID(ValueForKeyPathInDict))
        {
          v61 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@.%@.%@"), CFSTR("BuildIdentity"), CFSTR("Rap,SoftwareBinaryDsp1"), CFSTR("Digest"));
          if (v61)
          {
            v62 = (const void *)AMSupportGetValueForKeyPathInDict(kCFAllocatorDefault, a1, v61);
            CFRelease(v61);
            if (v62)
            {
              v63 = CFDataGetTypeID();
              if (v63 == CFGetTypeID(v62))
              {
                v64 = 0;
LABEL_33:
                if (ValueForKeyPathInDict && v62)
                {
                  CFDictionarySetValue(Mutable, CFSTR("SE,RapSwBinDsp"), v62);
                  CFDictionarySetValue(Mutable, CFSTR("SE,RapRTKitOS"), ValueForKeyPathInDict);
                  v67 = sub_1000D3C90();
                  sub_1000CB3F4(&__dst, "RoseRestoreInfo");
                  v68 = std::string::append(&__dst, "::");
                  v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
                  v120.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
                  *(_OWORD *)&v120.__r_.__value_.__l.__data_ = v69;
                  v68->__r_.__value_.__l.__size_ = 0;
                  v68->__r_.__value_.__r.__words[2] = 0;
                  v68->__r_.__value_.__r.__words[0] = 0;
                  v70 = std::string::append(&v120, "RoseUpdaterGetSharedInfo");
                  v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
                  v122 = v70->__r_.__value_.__r.__words[2];
                  *(_OWORD *)__p = v71;
                  v70->__r_.__value_.__l.__size_ = 0;
                  v70->__r_.__value_.__r.__words[2] = 0;
                  v70->__r_.__value_.__r.__words[0] = 0;
                  sub_1000D42F0((uint64_t)v67, (uint64_t *)__p, 0, (uint64_t)"Rose-SE Shared Info: ", (uint64_t)Mutable);
                  if (SHIBYTE(v122) < 0)
                    operator delete(__p[0]);
                  if (SHIBYTE(v120.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v120.__r_.__value_.__l.__data_);
                  if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(__dst.__r_.__value_.__l.__data_);
                }
                else
                {
                  sub_1000CB3F4(v123, "RoseUpdaterGetSharedInfo: Missing required firmware measurements");
                  sub_1000D3514((uint64_t)v145, (uint64_t)v123, 4001, 0);
                  if (v124 < 0)
                    operator delete(v123[0]);
                  v93 = sub_1000D3C90();
                  sub_1000D3D08((uint64_t)v93, 2u, "%s::%s: Missing required firmware measurements\n", v94, v95, v96, v97, v98, (char)"RoseRestoreInfo");
                }
                goto LABEL_41;
              }
              sub_1000CB3F4(v131, "RoseUpdaterGetSharedInfo: sbd1 digest is of an unexpected type");
              sub_1000D3514((uint64_t)v145, (uint64_t)v131, 1005, 0);
              if (v132 < 0)
                operator delete(v131[0]);
              v106 = sub_1000D3C90();
              v112 = "%s::%s: sbd1 digest is of an unexpected type\n";
            }
            else
            {
              sub_1000CB3F4(v133, "RoseUpdaterGetSharedInfo: failed to get dict entry for sbd1 digest");
              sub_1000D3514((uint64_t)v145, (uint64_t)v133, 1005, 0);
              if (v134 < 0)
                operator delete(v133[0]);
              v106 = sub_1000D3C90();
              v112 = "%s::%s: failed to get dict entry for sbd1 digest\n";
            }
          }
          else
          {
            sub_1000CB3F4(v135, "RoseUpdaterGetSharedInfo: failed to create build ID key path for sdb1");
            sub_1000D3514((uint64_t)v145, (uint64_t)v135, 1005, 0);
            if (v136 < 0)
              operator delete(v135[0]);
            v106 = sub_1000D3C90();
            v112 = "%s::%s: failed to create build ID key path for sdb1\n";
          }
        }
        else
        {
          sub_1000CB3F4(v137, "RoseUpdaterGetSharedInfo: rkos digest is of an unexpected type");
          sub_1000D3514((uint64_t)v145, (uint64_t)v137, 1005, 0);
          if (v138 < 0)
            operator delete(v137[0]);
          v106 = sub_1000D3C90();
          v112 = "%s::%s: rkos digest is of an unexpected type\n";
        }
      }
      else
      {
        sub_1000CB3F4(v139, "RoseUpdaterGetSharedInfo: failed to get dict entry rkos digest");
        sub_1000D3514((uint64_t)v145, (uint64_t)v139, 4000, 0);
        if (v140 < 0)
          operator delete(v139[0]);
        v106 = sub_1000D3C90();
        v112 = "%s::%s: failed to get dict entry rkos digest\n";
      }
    }
    else
    {
      sub_1000CB3F4(v141, "RoseUpdaterGetSharedInfo: failed to create build ID key path for rkos");
      sub_1000D3514((uint64_t)v145, (uint64_t)v141, 1005, 0);
      if (v142 < 0)
        operator delete(v141[0]);
      v106 = sub_1000D3C90();
      v112 = "%s::%s: failed to create build ID key path for rkos\n";
    }
    sub_1000D3D08((uint64_t)v106, 2u, v112, v107, v108, v109, v110, v111, (char)"RoseRestoreInfo");
    v64 = 0;
  }
LABEL_41:
  if (sub_1000D3594((uint64_t)v145))
  {
    *a4 = sub_1000D3358((uint64_t)v145);
    if (Mutable)
    {
      CFRelease(Mutable);
      Mutable = 0;
    }
  }
  if (v64)
    (*(void (**)(void *))(*(_QWORD *)v64 + 56))(v64);
LABEL_46:
  sub_1000D369C(v145);
  return Mutable;
}

void sub_1000CD264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *a25,uint64_t a26,int a27,__int16 a28,char a29,char a30,void *a31,uint64_t a32,int a33,__int16 a34,char a35,char a36,uint64_t a37,uint64_t a38,int a39,__int16 a40,char a41,char a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,int a48,__int16 a49,char a50,char a51,void *__p,uint64_t a53,int a54,__int16 a55,char a56,char a57,uint64_t a58,uint64_t a59,int a60,__int16 a61,char a62,char a63)
{
  uint64_t v63;

  if (a57 < 0)
    operator delete(__p);
  sub_1000D369C(v63 - 112);
  _Unwind_Resume(a1);
}

void sub_1000CD3E0(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000CD3F4(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 56))(result);
  return result;
}

uint64_t sub_1000CD40C(uint64_t a1, uint64_t a2)
{
    return a1 + 24;
  else
    return 0;
}

BOOL sub_1000CD44C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

void sub_1000CD498(int a1@<W0>, _QWORD *a2@<X8>)
{
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v4 = operator new(4uLL);
  sub_1000CD710(a2, (uint64_t)v4);
  if (*a2)
  {
    if ((sub_1000CD564((_DWORD *)*a2, a1) & 1) == 0)
    {
      v11 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v11, 2u, "%s::%s: failed to initialize object\n", v12, v13, v14, v15, v16, (char)"RoseCapabilities");
      sub_1000CD640(a2);
    }
  }
  else
  {
    v5 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v5, 2u, "%s::%s: failed to create capabilities object\n", v6, v7, v8, v9, v10, (char)"RoseCapabilities");
  }
}

void sub_1000CD550(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000CB5E0(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CD564(_DWORD *a1, int a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  if (a2 == 8228)
  {
    v10 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v10, 0, "%s::%s: Identified chip as R2\n", v11, v12, v13, v14, v15, (char)"RoseCapabilities");
    result = 1;
    *a1 = 1;
  }
  else if (a2 == 8198)
  {
    v3 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v3, 0, "%s::%s: Identified chip as R1\n", v4, v5, v6, v7, v8, (char)"RoseCapabilities");
    *a1 = 0;
    return 1;
  }
  else
  {
    v16 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v16, 2u, "%s::%s: Unrecognized chipID 0x%x\n", v17, v18, v19, v20, v21, (char)"RoseCapabilities");
    return 0;
  }
  return result;
}

void sub_1000CD640(_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

BOOL sub_1000CD69C(_DWORD *a1)
{
  return *a1 != 0;
}

BOOL sub_1000CD6AC(_DWORD *a1)
{
  return *a1 == 0;
}

uint64_t sub_1000CD6BC(int *a1, unsigned int a2)
{
  int v2;
  unint64_t v3;
  int v4;
  char v5;

  v2 = *a1;
  v3 = (0x15001100100uLL >> a2) & 1;
  if (a2 > 0x28)
    LOBYTE(v3) = 0;
  LOBYTE(v4) = (a2 & 0xFC) == 8;
  if (v2)
    v4 = *a1;
  if (v2 == 1)
    v5 = v3;
  else
    v5 = v4;
  return v5 & 1;
}

void sub_1000CD700(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

_QWORD *sub_1000CD710(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = operator new(0x20uLL);
  *v4 = &off_100182C00;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1000CD754(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void sub_1000CD770(std::__shared_weak_count *a1)
{
  void *v1;

  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

void sub_1000CD784(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 24);
  if (v1)
    operator delete(v1);
}

uint64_t sub_1000CD794(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void sub_1000CD7D4(uint64_t a1@<X8>)
{
  uint64_t i;
  const __CFString *v3;
  _QWORD v4[4];
  _QWORD v5[4];
  _QWORD v6[4];
  _QWORD v7[3];

  v3 = CFSTR("Rap,SoftwareBinaryDsp1");
  sub_1000CB3F4(v4, "sbd1");
  v4[3] = CFSTR("Rap,RTKitOS");
  sub_1000CB3F4(v5, "rkos");
  v5[3] = CFSTR("Rap,RestoreRTKitOS");
  sub_1000CB3F4(v6, "rrko");
  v6[3] = CFSTR("Rap,RTKitIOConfig");
  sub_1000CB3F4(v7, "icnf");
  sub_1000CD94C(a1, (unint64_t *)&v3, 4);
  for (i = 0; i != -16; i -= 4)
  {
    if (SHIBYTE(v7[i + 2]) < 0)
      operator delete((void *)v7[i]);
  }
}

void sub_1000CD8EC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v12;

  v12 = 0;
  while (1)
  {
    if (*(char *)(v10 + v12 + 127) < 0)
      operator delete(*(void **)(v10 + v12 + 104));
    v12 -= 32;
    if (v12 == -128)
      _Unwind_Resume(exception_object);
  }
}

uint64_t sub_1000CD94C(uint64_t a1, unint64_t *a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (_QWORD *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 32 * a3;
    do
    {
      sub_1000CD9C8((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 4;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1000CD9B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000CC004(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000CD9C8(uint64_t **a1, _QWORD *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v6 = (uint64_t **)sub_1000CDA48(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    sub_1000CDBF0((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000CBAE0(a1, v10, v6, v8);
    return v8;
  }
  return result;
}

_QWORD *sub_1000CDA48(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (v10[4] < *a5)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = v16[4];
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = v20[4];
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

_QWORD *sub_1000CDBF0@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *result;

  v5 = a1 + 8;
  v6 = operator new(0x40uLL);
  *(_QWORD *)(a3 + 8) = v5;
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 16) = 0;
  v6[4] = *(_QWORD *)a2;
  result = v6 + 5;
  if (*(char *)(a2 + 31) < 0)
  {
    result = sub_1000CB554(result, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)result = *(_OWORD *)(a2 + 8);
    result[2] = *(_QWORD *)(a2 + 24);
  }
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1000CDC7C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_1000CDC98(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1000CDC98(uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 63) < 0)
      operator delete(__p[5]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t sub_1000CDCE4(uint64_t result, uint64_t a2, uint64_t a3, char a4)
{
  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  *(_BYTE *)(result + 16) = a4;
  *(_BYTE *)(result + 17) = 1;
  return result;
}

uint64_t sub_1000CDCF8(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t sub_1000CDD00(uint64_t a1)
{
  unint64_t v2;
  size_t v3;
  unint64_t v4;
  unint64_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = *(_QWORD *)a1;
  if (*(_QWORD *)a1)
  {
    v3 = *(_QWORD *)(a1 + 8);
    if (v3)
    {
      if (*(_BYTE *)(a1 + 17))
      {
        if (*(_BYTE *)(a1 + 16))
        {
          if (v2 % sysconf(29))
          {
            v4 = sysconf(29);
            v5 = sysconf(29);
            v6 = sub_1000D3C90();
            v3 += v2 % v5;
            sub_1000D3D08((uint64_t)v6, 4u, "%s::%s: unmaping new length for page alignment (alignedLength: %zu. originalLength: %zu)\n", v7, v8, v9, v10, v11, (char)"ACFUDataContainer");
            v2 = v2 / v4 * v4;
          }
          if (munmap((void *)v2, v3) == -1)
          {
            v12 = sub_1000D3C90();
            v13 = __error();
            strerror(*v13);
            sub_1000D3D08((uint64_t)v12, 2u, "%s::%s: failed to unmap file: (%s)\n", v14, v15, v16, v17, v18, (char)"ACFUDataContainer");
          }
        }
        else
        {
          free(*(void **)a1);
        }
      }
    }
  }
  return a1;
}

void sub_1000CDE30(const __CFData *a1@<X0>, uint64_t *a2@<X8>)
{
  _DWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = operator new(0x20uLL);
  *(_QWORD *)v4 = 0;
  v4[2] = -1;
  *((_QWORD *)v4 + 2) = 0;
  *((_WORD *)v4 + 12) = 0;
  *a2 = (uint64_t)v4;
  if ((sub_1000CDED4((CFMutableDataRef *)v4, a1) & 1) == 0)
  {
    sub_1000CEE60(a2, 0);
    v5 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v5, 2u, "%s::%s: failed to init data container object\n", v6, v7, v8, v9, v10, (char)"ACFUDataContainer");
  }
}

void sub_1000CDEBC(_Unwind_Exception *a1)
{
  uint64_t *v1;

  sub_1000CEE60(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CDED4(CFMutableDataRef *a1, const __CFData *a2)
{
  CFTypeID TypeID;
  CFMutableDataRef MutableCopy;
  const char *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      MutableCopy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, a2);
      *a1 = MutableCopy;
      if (MutableCopy)
        return 1;
      v7 = "%s::%s: failed to allocate space for file object\n";
    }
    else
    {
      v7 = "%s::%s: data is of an unsupported type\n";
    }
  }
  else
  {
    v7 = "%s::%s: bad parameter!\n";
  }
  v8 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v8, 2u, v7, v9, v10, v11, v12, v13, (char)"ACFUDataContainer");
  return 0;
}

void sub_1000CDF90(const void *a1@<X0>, uint64_t *a2@<X8>)
{
  _DWORD *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v4 = operator new(0x20uLL);
  *(_QWORD *)v4 = 0;
  v4[2] = -1;
  *((_QWORD *)v4 + 2) = 0;
  *((_WORD *)v4 + 12) = 0;
  *a2 = (uint64_t)v4;
  if ((sub_1000CE034((uint64_t *)v4, a1) & 1) == 0)
  {
    sub_1000CEE60(a2, 0);
    v5 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v5, 2u, "%s::%s: failed to init data container object\n", v6, v7, v8, v9, v10, (char)"ACFUDataContainer");
  }
}

void sub_1000CE01C(_Unwind_Exception *a1)
{
  uint64_t *v1;

  sub_1000CEE60(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CE034(uint64_t *a1, const void *a2)
{
  CFTypeID TypeID;
  uint64_t v5;
  const char *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (a2)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(a2))
    {
      v5 = AMSupportSafeRetain(a2);
      *a1 = v5;
      if (v5)
        return 1;
      v7 = "%s::%s: failed to allocate space for file object\n";
    }
    else
    {
      v7 = "%s::%s: data is of an unsupported type\n";
    }
  }
  else
  {
    v7 = "%s::%s: bad parameter!\n";
  }
  v8 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v8, 2u, v7, v9, v10, v11, v12, v13, (char)"ACFUDataContainer");
  return 0;
}

void sub_1000CE0E0(const __CFString *a1@<X0>, char a2@<W1>, uint64_t *a3@<X8>)
{
  _DWORD *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v6 = operator new(0x20uLL);
  *(_QWORD *)v6 = 0;
  v6[2] = -1;
  *((_QWORD *)v6 + 2) = 0;
  *((_WORD *)v6 + 12) = 0;
  *a3 = (uint64_t)v6;
  if ((sub_1000CE194((uint64_t)v6, a1, a2) & 1) == 0)
  {
    sub_1000CEE60(a3, 0);
    v7 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v7, 2u, "%s::%s: failed to init data container object\n", v8, v9, v10, v11, v12, (char)"ACFUDataContainer");
  }
}

void sub_1000CE17C(_Unwind_Exception *a1)
{
  uint64_t *v1;

  sub_1000CEE60(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CE194(uint64_t a1, const __CFString *a2, char a3)
{
  const char *v6;
  const char *v7;
  int v8;
  const char *v9;
  const char *v10;
  void *v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  const char *v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const char *v27;
  CFStringRef Copy;
  char v29;
  __CFData *v30;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  int *v39;
  __int128 v40;
  uint64_t v41;
  char *v42[2];
  uint64_t v43;

  sub_1000DC1B8(a2, &v40);
  v43 = v41;
  *(_OWORD *)v42 = v40;
  if ((SHIBYTE(v41) & 0x80000000) == 0)
  {
    if (HIBYTE(v41))
    {
      v6 = (const char *)v42;
      goto LABEL_6;
    }
LABEL_40:
    v32 = sub_1000D3C90();
    v38 = "%s::%s: failed to acquire file path string\n";
LABEL_44:
    sub_1000D3D08((uint64_t)v32, 2u, v38, v33, v34, v35, v36, v37, (char)"ACFUDataContainer");
    goto LABEL_21;
  }
  if (!v42[1])
    goto LABEL_40;
  v6 = v42[0];
LABEL_6:
  if (access(v6, 0))
  {
    *(_BYTE *)(a1 + 25) = 1;
    if (v43 >= 0)
      v7 = (const char *)v42;
    else
      v7 = v42[0];
    v8 = open(v7, 514, 438);
  }
  else
  {
    if (v43 >= 0)
      v9 = (const char *)v42;
    else
      v9 = v42[0];
    if (access(v9, 6))
    {
      if (v43 >= 0)
        v10 = (const char *)v42;
      else
        v10 = v42[0];
      if (access(v10, 4))
      {
        v11 = sub_1000D3C90();
        v12 = __error();
        strerror(*v12);
        v18 = "%s::%s: no read or write permissions to file: (%s)\n";
LABEL_20:
        sub_1000D3D08((uint64_t)v11, 2u, v18, v13, v14, v15, v16, v17, (char)"ACFUDataContainer");
LABEL_21:
        v19 = 0;
        goto LABEL_37;
      }
      v21 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v21, 2u, "%s::%s: no write permissions to file... attempting to open file as read-only\n", v22, v23, v24, v25, v26, (char)"ACFUDataContainer");
      if (v43 >= 0)
        v27 = (const char *)v42;
      else
        v27 = v42[0];
      v8 = open(v27, 0);
    }
    else
    {
      *(_BYTE *)(a1 + 25) = 1;
      if (v43 >= 0)
        v20 = (const char *)v42;
      else
        v20 = v42[0];
      v8 = open(v20, 2);
    }
  }
  *(_DWORD *)(a1 + 8) = v8;
  if (v8 < 0)
  {
    v11 = sub_1000D3C90();
    v39 = __error();
    strerror(*v39);
    v18 = "%s::%s: failed to open file error: (%s)\n";
    goto LABEL_20;
  }
  Copy = CFStringCreateCopy(kCFAllocatorDefault, a2);
  *(_QWORD *)(a1 + 16) = Copy;
  if (!Copy)
  {
    v32 = sub_1000D3C90();
    v38 = "%s::%s: failed to create copy of file path\n";
    goto LABEL_44;
  }
  if ((a3 & 1) == 0)
  {
    v30 = sub_1000DBAD8((uint64_t)a2);
    *(_QWORD *)a1 = v30;
    if (v30)
    {
      v29 = 0;
      goto LABEL_36;
    }
    v32 = sub_1000D3C90();
    v38 = "%s::%s: failed to acquire firmware data from file path\n";
    goto LABEL_44;
  }
  v29 = 1;
LABEL_36:
  *(_BYTE *)(a1 + 24) = v29;
  v19 = 1;
LABEL_37:
  if (SHIBYTE(v43) < 0)
    operator delete(v42[0]);
  return v19;
}

void sub_1000CE3F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__CFData *sub_1000CE410(uint64_t a1)
{
  const __CFString *v2;
  void **v3;
  uint64_t v4;
  __CFData *v5;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  void *v14;
  int *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  void *__p[2];
  uint64_t v30;
  stat v31;

  if (!*(_BYTE *)(a1 + 24))
  {
    v4 = *(_QWORD *)a1;
    if (*(_QWORD *)a1)
    {
      AMSupportSafeRetain(v4);
      return *(__CFData **)a1;
    }
    else
    {
      v21 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v21, 2u, "%s::%s: object does not hold any data\n", v22, v23, v24, v25, v26, (char)"ACFUDataContainer");
      return 0;
    }
  }
  sub_1000CB3F4(__p, "");
  v2 = *(const __CFString **)(a1 + 16);
  if (!v2)
  {
    v7 = sub_1000D3C90();
    v13 = "%s::%s: file path has not been initialized\n";
LABEL_19:
    sub_1000D3D08((uint64_t)v7, 2u, v13, v8, v9, v10, v11, v12, (char)"ACFUDataContainer");
    goto LABEL_21;
  }
  sub_1000DC1B8(v2, &v27);
  if (SHIBYTE(v30) < 0)
    operator delete(__p[0]);
  v30 = v28;
  *(_OWORD *)__p = v27;
  if (SHIBYTE(v28) < 0)
  {
    if (__p[1])
    {
      v3 = (void **)__p[0];
      goto LABEL_12;
    }
    goto LABEL_18;
  }
  if (!HIBYTE(v28))
  {
LABEL_18:
    v7 = sub_1000D3C90();
    v13 = "%s::%s: failed to acquire file path c string\n";
    goto LABEL_19;
  }
  v3 = __p;
LABEL_12:
  if (stat((const char *)v3, &v31) != -1)
  {
    v5 = sub_1000CE5BC(a1, 0, v31.st_size);
    goto LABEL_14;
  }
  v14 = sub_1000D3C90();
  v15 = __error();
  strerror(*v15);
  sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: failed to obtain file stats: (%s)\n", v16, v17, v18, v19, v20, (char)"ACFUDataContainer");
LABEL_21:
  v5 = 0;
LABEL_14:
  if (SHIBYTE(v30) < 0)
    operator delete(__p[0]);
  return v5;
}

void sub_1000CE59C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__CFData *sub_1000CE5BC(uint64_t a1, unsigned int a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v6;
  uint64_t v7;
  unint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  off_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  UInt8 *v24;
  UInt8 *v25;
  __CFData *v26;
  __CFData *Mutable;
  void *v28;
  int *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  void *v36;
  unsigned int v37;
  const UInt8 *BytePtr;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void *v64;
  int *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;

  if (!a3)
  {
    v40 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v40, 2u, "%s::%s: invalid length value\n", v41, v42, v43, v44, v45, (char)"ACFUDataContainer");
    return 0;
  }
  v3 = a3;
  v6 = sub_1000CE8C8(a1);
  if (!v6)
  {
    v46 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v46, 2u, "%s::%s: failed to get backing length\n", v47, v48, v49, v50, v51, (char)"ACFUDataContainer");
    return 0;
  }
  if (v6 <= a2)
  {
    v52 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v52, 2u, "%s::%s: offset out of range\n", v53, v54, v55, v56, v57, (char)"ACFUDataContainer");
    return 0;
  }
  v7 = a2;
  v8 = v6 - a2;
  if (v8 < v3)
  {
    v9 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v9, 4u, "%s::%s: reducing requested length %zu -> %zu\n", v10, v11, v12, v13, v14, (char)"ACFUDataContainer");
    v3 = v8;
  }
  if (!*(_BYTE *)(a1 + 24))
  {
    if (*(_QWORD *)a1)
    {
      Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
      if (Mutable)
      {
        BytePtr = CFDataGetBytePtr(*(CFDataRef *)a1);
        CFDataAppendBytes(Mutable, &BytePtr[v7], v3);
        return Mutable;
      }
      v36 = sub_1000D3C90();
      v35 = "%s::%s: failed to create mutable data in unoptimized path\n";
      goto LABEL_26;
    }
    v71 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v71, 2u, "%s::%s: object does not hold any data\n", v72, v73, v74, v75, v76, (char)"ACFUDataContainer");
    return 0;
  }
  if ((*(_DWORD *)(a1 + 8) & 0x80000000) != 0)
  {
    v58 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v58, 2u, "%s::%s: invalid file descriptor\n", v59, v60, v61, v62, v63, (char)"ACFUDataContainer");
    return 0;
  }
  v15 = (double)(a2 / sysconf(29));
  v16 = (v15 * (double)sysconf(29));
  v17 = a2 - v16;
  v18 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v18, 4u, "%s::%s: paging in new length for page alignment (Requested: %zu. Aligned: %zu)\n", v19, v20, v21, v22, v23, (char)"ACFUDataContainer");
  v24 = (UInt8 *)mmap(0, v3 + v17, 1, 2, *(_DWORD *)(a1 + 8), v16);
  if (v24 == (UInt8 *)-1)
  {
    v64 = sub_1000D3C90();
    v65 = __error();
    strerror(*v65);
    sub_1000D3D08((uint64_t)v64, 2u, "%s::%s: failed to map file: (%s)\n", v66, v67, v68, v69, v70, (char)"ACFUDataContainer");
    return 0;
  }
  v25 = v24;
  v26 = CFDataCreateMutable(kCFAllocatorDefault, 0);
  Mutable = v26;
  if (!v26)
  {
    v36 = sub_1000D3C90();
    v35 = "%s::%s: failed to create mutable data in optimized path\n";
LABEL_26:
    v37 = 2;
    goto LABEL_12;
  }
  CFDataAppendBytes(v26, &v25[v17], v3);
  if (munmap(v25, v3 + v17) == -1)
  {
    v28 = sub_1000D3C90();
    v29 = __error();
    strerror(*v29);
    v35 = "%s::%s: failed to un-map file: (%s)\n";
    v36 = v28;
    v37 = 4;
LABEL_12:
    sub_1000D3D08((uint64_t)v36, v37, v35, v30, v31, v32, v33, v34, (char)"ACFUDataContainer");
  }
  return Mutable;
}

CFIndex sub_1000CE8C8(uint64_t a1)
{
  void **v1;
  off_t st_size;
  void *v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *__p[2];
  char v12;
  stat v13;

  if (!*(_BYTE *)(a1 + 24))
    return CFDataGetLength(*(CFDataRef *)a1);
  sub_1000DC1B8(*(const __CFString **)(a1 + 16), __p);
  if (v12 >= 0)
    v1 = __p;
  else
    v1 = (void **)__p[0];
  if (stat((const char *)v1, &v13) == -1)
  {
    v4 = sub_1000D3C90();
    v5 = __error();
    strerror(*v5);
    sub_1000D3D08((uint64_t)v4, 2u, "%s::%s: failed to determine file size for path '%s' (%s)\n", v6, v7, v8, v9, v10, (char)"ACFUDataContainer");
    st_size = 0;
  }
  else
  {
    st_size = v13.st_size;
  }
  if (v12 < 0)
    operator delete(__p[0]);
  return st_size;
}

void sub_1000CE9A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1000CE9C4(size_t __size@<X2>, uint64_t a2@<X0>, unsigned int a3@<W1>, uint64_t *a4@<X8>)
{
  uint64_t v8;
  uint64_t v9;
  void *v10;
  off_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  _QWORD *v19;
  char v20;
  const __CFData *v21;
  void *v22;
  void *v23;
  const UInt8 *BytePtr;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const char *v31;
  unsigned int v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const char *v52;

  *a4 = 0;
  if (!__size)
  {
    v25 = sub_1000D3C90();
    v31 = "%s::%s: invalid offset value\n";
    v32 = 2;
    goto LABEL_11;
  }
  if (*(_BYTE *)(a2 + 24))
  {
    if ((*(_DWORD *)(a2 + 8) & 0x80000000) != 0)
    {
      v33 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v33, 2u, "%s::%s: invalid file descriptor\n", v34, v35, v36, v37, v38, (char)"ACFUDataContainer");
      return;
    }
    v8 = sysconf(29);
    v9 = sysconf(29);
    v10 = sub_1000D3C90();
    v11 = ((double)v9 * (double)(a3 / v8));
    v12 = a3 - v11;
    sub_1000D3D08((uint64_t)v10, 4u, "%s::%s: paging in new length for page alignment (Requested: %zu. Aligned: %zu)\n", v13, v14, v15, v16, v17, (char)"ACFUDataContainer");
    v18 = (char *)mmap(0, v12 + __size, 1, 1, *(_DWORD *)(a2 + 8), v11);
    if (v18 == (char *)-1)
    {
      v39 = sub_1000D3C90();
      v40 = __error();
      strerror(*v40);
      sub_1000D3D08((uint64_t)v39, 2u, "%s::%s: failed to map file: (%s)\n", v41, v42, v43, v44, v45, (char)"ACFUDataContainer");
      return;
    }
    v19 = operator new(0x18uLL);
    *v19 = &v18[v12];
    v20 = 1;
    goto LABEL_9;
  }
  v21 = *(const __CFData **)a2;
  if (!*(_QWORD *)a2)
  {
    v46 = sub_1000D3C90();
    v52 = "%s::%s: object does not hold any data\n";
LABEL_18:
    sub_1000D3D08((uint64_t)v46, 2u, v52, v47, v48, v49, v50, v51, (char)"ACFUDataContainer");
    return;
  }
  v22 = malloc(__size);
  if (!v22)
  {
    v46 = sub_1000D3C90();
    v52 = "%s::%s: unable to allocate data\n";
    goto LABEL_18;
  }
  v23 = v22;
  BytePtr = CFDataGetBytePtr(v21);
  memcpy(v23, &BytePtr[a3], __size);
  v19 = operator new(0x18uLL);
  v20 = 0;
  *v19 = v23;
LABEL_9:
  v19[1] = __size;
  *((_BYTE *)v19 + 16) = v20;
  *((_BYTE *)v19 + 17) = 1;
  sub_1000CEE8C(a4, (uint64_t)v19);
  if (*(_QWORD *)*a4)
    return;
  v25 = sub_1000D3C90();
  v31 = "%s::%s: failed to create file data\n";
  v32 = 4;
LABEL_11:
  sub_1000D3D08((uint64_t)v25, v32, v31, v26, v27, v28, v29, v30, (char)"ACFUDataContainer");
}

void sub_1000CEC0C(_Unwind_Exception *a1)
{
  uint64_t *v1;

  sub_1000CEE8C(v1, 0);
  _Unwind_Resume(a1);
}

uint64_t sub_1000CEC34(uint64_t a1, uint64_t a2)
{
  const void *v4;
  uint64_t v5;
  const __CFString *v6;
  CFURLRef v7;
  CFURLRef v8;
  const void *v9;
  uint64_t v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  if (*(_BYTE *)(a1 + 24))
  {
    v19 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: cannot setData for a memory optimized data container.\n", v20, v21, v22, v23, v24, (char)"ACFUDataContainer");
    return 0;
  }
  v4 = *(const void **)a1;
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)a1 = 0;
  }
  v5 = AMSupportSafeRetain(a2);
  *(_QWORD *)a1 = v5;
  if (!v5)
  {
    v25 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v25, 2u, "%s::%s: failed obtain new file data\n", v26, v27, v28, v29, v30, (char)"ACFUDataContainer");
    return 0;
  }
  if (!*(_BYTE *)(a1 + 25))
    return 1;
  v6 = *(const __CFString **)(a1 + 16);
  if (!v6)
  {
    v31 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v31, 2u, "%s::%s: file path has not been initialized\n", v32, v33, v34, v35, v36, (char)"ACFUDataContainer");
    return 0;
  }
  v7 = CFURLCreateWithString(kCFAllocatorDefault, v6, 0);
  if (!v7)
  {
    v37 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v37, 2u, "%s::%s: failed to create path url\n", v38, v39, v40, v41, v42, (char)"ACFUDataContainer");
    return 0;
  }
  v8 = v7;
  v9 = *(const void **)a1;
  v10 = 1;
  v11 = AMSupportWriteDataToFileURL(kCFAllocatorDefault, v9, v7, 1);
  CFRelease(v8);
  if (v11)
  {
    v12 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v12, 2u, "%s::%s: failed to overwrite file (%d)\n", v13, v14, v15, v16, v17, (char)"ACFUDataContainer");
    return 0;
  }
  return v10;
}

uint64_t sub_1000CEDB0(_BYTE *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (!a1[24])
    return *(_QWORD *)a1;
  v1 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v1, 2u, "%s::%s: cannot aquire reference for a memory optimized data container. Please use copyData() instead\n", v2, v3, v4, v5, v6, (char)"ACFUDataContainer");
  return 0;
}

uint64_t sub_1000CEE04(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 24);
}

uint64_t sub_1000CEE0C(uint64_t a1)
{
  int v2;
  const void *v3;

  v2 = *(_DWORD *)(a1 + 8);
  if ((v2 & 0x80000000) == 0)
    close(v2);
  if (*(_QWORD *)a1)
  {
    CFRelease(*(CFTypeRef *)a1);
    *(_QWORD *)a1 = 0;
  }
  v3 = *(const void **)(a1 + 16);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 16) = 0;
  }
  return a1;
}

void sub_1000CEE60(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    v4 = (void *)sub_1000CEE0C(v3);
    operator delete(v4);
  }
}

void sub_1000CEE8C(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  void *v4;

  v3 = *a1;
  *a1 = a2;
  if (v3)
  {
    v4 = (void *)sub_1000CDD00(v3);
    operator delete(v4);
  }
}

__CFDictionary *sub_1000CEEB8(uint64_t a1)
{
  __CFDictionary *Mutable;
  CFArrayRef v3;
  CFArrayRef v4;
  CFArrayRef v5;
  CFArrayRef v6;
  const void *Value;
  CFTypeID v8;
  void *v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  std::string v39;
  std::string v40;
  void *__p[2];
  std::string::size_type v42;
  void *v43[2];
  char v44;
  void *v45[2];
  char v46;
  void *v47[2];
  char v48;
  void *v49[2];
  char v50;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v3 = sub_1000CF274((const void ***)(a1 + 40));
    if (v3)
    {
      v4 = v3;
      v5 = sub_1000CF274((const void ***)(a1 + 112));
      if (v5)
      {
        v6 = v5;
        Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DeviceInfo"));
        if (Value && (v8 = CFGetTypeID(Value), v8 == CFDictionaryGetTypeID()))
        {
          CFDictionaryAddValue(Mutable, CFSTR("BuildIdentityTags"), v4);
          CFDictionaryAddValue(Mutable, CFSTR("ResponseTags"), v6);
          v9 = sub_1000D3C90();
          sub_1000CB3F4(&v39, "ACFURestoreHost");
          v10 = std::string::append(&v39, "::");
          v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
          v40.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v40.__r_.__value_.__l.__data_ = v11;
          v10->__r_.__value_.__l.__size_ = 0;
          v10->__r_.__value_.__r.__words[2] = 0;
          v10->__r_.__value_.__r.__words[0] = 0;
          v12 = std::string::append(&v40, "getTags");
          v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
          v42 = v12->__r_.__value_.__r.__words[2];
          *(_OWORD *)__p = v13;
          v12->__r_.__value_.__l.__size_ = 0;
          v12->__r_.__value_.__r.__words[2] = 0;
          v12->__r_.__value_.__r.__words[0] = 0;
          sub_1000D42F0((uint64_t)v9, (uint64_t *)__p, 0, (uint64_t)"Request Tags:", (uint64_t)Mutable);
          if (SHIBYTE(v42) < 0)
            operator delete(__p[0]);
          if (SHIBYTE(v40.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v40.__r_.__value_.__l.__data_);
          if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v39.__r_.__value_.__l.__data_);
        }
        else
        {
          sub_1000CB3F4(v43, "getTags: failed to get device info list");
          sub_1000D3514(a1 + 24, (uint64_t)v43, 4001, 0);
          if (v44 < 0)
            operator delete(v43[0]);
          v15 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v15, 2u, "%s::%s: failed to get device info list\n", v16, v17, v18, v19, v20, (char)"ACFURestoreHost");
        }
        CFRelease(v6);
      }
      else
      {
        sub_1000CB3F4(v45, "getTags: failed to create response tag list");
        sub_1000D3514(a1 + 24, (uint64_t)v45, 4000, 0);
        if (v46 < 0)
          operator delete(v45[0]);
        v33 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v33, 2u, "%s::%s: failed to create response tag list\n", v34, v35, v36, v37, v38, (char)"ACFURestoreHost");
      }
      CFRelease(v4);
    }
    else
    {
      sub_1000CB3F4(v47, "getTags: failed to create build identity tag list");
      sub_1000D3514(a1 + 24, (uint64_t)v47, 4000, 0);
      if (v48 < 0)
        operator delete(v47[0]);
      v27 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v27, 2u, "%s::%s: failed to create build identity tag list\n", v28, v29, v30, v31, v32, (char)"ACFURestoreHost");
    }
  }
  else
  {
    sub_1000CB3F4(v49, "getTags: failed to allocate output dictionary");
    sub_1000D3514(a1 + 24, (uint64_t)v49, 4000, 0);
    if (v50 < 0)
      operator delete(v49[0]);
    v21 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v21, 2u, "%s::%s: failed to allocate output dictionary\n", v22, v23, v24, v25, v26, (char)"ACFURestoreHost");
  }
  return Mutable;
}

void sub_1000CF1D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,int a34,__int16 a35,char a36,char a37)
{
  uint64_t v37;

  if (*(char *)(v37 - 97) < 0)
    operator delete(*(void **)(v37 - 120));
  _Unwind_Resume(exception_object);
}

CFArrayRef sub_1000CF274(const void ***a1)
{
  CFMutableArrayRef Mutable;
  __CFArray *v3;
  const void **i;
  const void *v5;
  CFArrayRef Copy;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    v3 = Mutable;
    for (i = *a1; i != a1[1]; ++i)
    {
      v5 = *i;
      CFArrayAppendValue(v3, v5);
    }
    Copy = CFArrayCreateCopy(kCFAllocatorDefault, v3);
    CFRelease(v3);
    return Copy;
  }
  else
  {
    v8 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v8, 2u, "%s::%s: failed to create tag list from vector\n", v9, v10, v11, v12, v13, (char)"ACFURestoreHost");
    return 0;
  }
}

uint64_t sub_1000CF334(uint64_t a1)
{
  CFStringRef v2;
  __CFString *v3;
  const void *v4;
  void *v5;
  std::string *v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  CFTypeID v20;
  CFMutableDictionaryRef MutableCopy;
  __CFDictionary *v22;
  const void *v23;
  const void *v24;
  CFTypeID v25;
  uint64_t v26;
  uint64_t v27;
  __CFDictionary *Mutable;
  __CFString *v29;
  CFMutableDictionaryRef v30;
  const void *v31;
  const void *v32;
  CFTypeID v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  CFTypeID v36;
  const void *v37;
  CFTypeID TypeID;
  int v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  std::string *v47;
  std::string *v48;
  __int128 v49;
  std::string *v50;
  __int128 v51;
  int v52;
  uint64_t URLFromString;
  const void *v54;
  const void *v55;
  uint64_t v56;
  char v57;
  const void *v58;
  void *v59;
  std::string *v60;
  __int128 v61;
  std::string *v62;
  __int128 v63;
  void *v64;
  std::string *v65;
  __int128 v66;
  std::string *v67;
  __int128 v68;
  void *v69;
  std::string *v70;
  __int128 v71;
  std::string *v72;
  __int128 v73;
  int v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const void *v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  void *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  BOOL v101;
  char v102;
  void *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  const void *v109;
  const char *v110;
  void **v111;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  void *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  const void *v126;
  void *v127;
  std::string *v128;
  std::string *v129;
  __int128 v130;
  std::string *v131;
  __int128 v132;
  void *v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  const void *v140;
  int v141;
  int v142;
  void *v143;
  std::string *v144;
  __int128 v145;
  std::string *v146;
  __int128 v147;
  void *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  void *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  void *v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  void *v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  void *v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  void *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  void *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  void *v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  void *v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  void *v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  void *v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  const void *v221;
  int v222;
  uint64_t v223;
  __CFString *v224;
  _QWORD v225[2];
  char v226;
  void *v227[2];
  char v228;
  void *v229[2];
  char v230;
  _QWORD v231[2];
  char v232;
  _QWORD v233[2];
  char v234;
  _QWORD v235[2];
  char v236;
  void *v237[2];
  char v238;
  void *v239[2];
  char v240;
  void *__p[2];
  char v242;
  std::string cf;
  CFTypeRef v244;
  void *value;
  void *v246[2];
  char v247;
  void *v248[2];
  char v249;
  void *v250[2];
  char v251;
  void *v252[2];
  char v253;
  std::string v254;
  std::string __dst;
  std::string v256;

  v2 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Firmware/%@/Rooted/ftab.bin"), *(_QWORD *)(a1 + 224));
  if (!v2)
  {
    v167 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v167, 2u, "%s::%s: failed to allocate data for personalized path\n", v168, v169, v170, v171, v172, (char)"ACFURestoreHost");
    return 0;
  }
  v3 = (__CFString *)v2;
  v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DestBundlePath"));
  if (v4)
  {
    v5 = sub_1000D3C90();
    v6 = (std::string *)sub_1000CB3F4(&v254, "ACFURestoreHost");
    v7 = std::string::append(v6, "::");
    v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    __dst.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    v9 = std::string::append(&__dst, "copyFirmware");
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v256.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v256.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v5, (uint64_t *)&v256, 0, (uint64_t)"personalizedURL: ", (uint64_t)v4);
    if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v256.__r_.__value_.__l.__data_);
    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst.__r_.__value_.__l.__data_);
    if (SHIBYTE(v254.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v254.__r_.__value_.__l.__data_);
  }
  v11 = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 16), CFSTR("BundleDataDict"));
  v12 = sub_1000D3C90();
  if (!v11)
  {
    sub_1000D3D08((uint64_t)v12, 0, "%s::%s: running host invoked restore info -- using bundleURL\n", v13, v14, v15, v16, v17, (char)"ACFURestoreHost");
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v30 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v30)
      {
        v22 = v30;
        v31 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("BundlePath"));
        if (!v31 || (v32 = v31, v33 = CFURLGetTypeID(), v33 != CFGetTypeID(v32)))
        {
          sub_1000CB3F4(v250, "copyFirmware: failed to get src bundle URL");
          sub_1000D3514(a1 + 24, (uint64_t)v250, 4001, 0);
          if (v251 < 0)
            operator delete(v250[0]);
          v179 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v179, 2u, "%s::%s: failed to get src bundle URL\n", v180, v181, v182, v183, v184, (char)"ACFURestoreHost");
          goto LABEL_203;
        }
        v34 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("Options"));
        v224 = v3;
        if (!v34 || (v35 = v34, v36 = CFGetTypeID(v34), v36 != CFDictionaryGetTypeID()))
        {
          v37 = 0;
          v222 = 0;
LABEL_51:
          v221 = v37;
          v56 = *(_QWORD *)(a1 + 136);
          if (v56 != *(_QWORD *)(a1 + 144))
          {
            v57 = 0;
            v223 = a1 + 24;
            while (1)
            {
              v244 = 0;
              value = 0;
              v58 = sub_1000D0810(*(_QWORD *)(a1 + 16), *(_QWORD *)v56);
              sub_1000DC1B8(*(const __CFString **)v56, &v256);
              if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
              {
                if (v256.__r_.__value_.__l.__size_)
                {
                  sub_1000CB554(&__dst, v256.__r_.__value_.__l.__data_, v256.__r_.__value_.__l.__size_);
                  goto LABEL_59;
                }
              }
              else if (*((_BYTE *)&v256.__r_.__value_.__s + 23))
              {
                __dst = v256;
                goto LABEL_59;
              }
              sub_1000CB3F4(&__dst, "UNDEF");
LABEL_59:
              if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v256.__r_.__value_.__l.__data_);
              v256 = __dst;
              if (v58)
              {
                if (v4)
                {
                  if (AMSupportCopyURLWithAppendedComponent(kCFAllocatorDefault, v4, v58, 0, &v244)
                    || !v244)
                  {
                    sub_1000CB3F4(v239, "copyFirmware: failed to create personalized FW URL");
                    sub_1000D3514(v223, (uint64_t)v239, 4000, 0);
                    if (v240 < 0)
                      operator delete(v239[0]);
                    v88 = sub_1000D3C90();
                    sub_1000D3D08((uint64_t)v88, 2u, "%s::%s: copyFirmware: failed to create personalized FW URL (status: %d)\n", v89, v90, v91, v92, v93, (char)"ACFURestoreHost");
                    goto LABEL_92;
                  }
                  if (sub_1000DC3CC((uint64_t)v244))
                  {
                    v59 = sub_1000D3C90();
                    sub_1000CB3F4(&cf, "ACFURestoreHost");
                    v60 = std::string::append(&cf, "::");
                    v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
                    v254.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&v254.__r_.__value_.__l.__data_ = v61;
                    v60->__r_.__value_.__l.__size_ = 0;
                    v60->__r_.__value_.__r.__words[2] = 0;
                    v60->__r_.__value_.__r.__words[0] = 0;
                    v62 = std::string::append(&v254, "copyFirmware");
                    v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
                    __dst.__r_.__value_.__r.__words[2] = v62->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v63;
                    v62->__r_.__value_.__l.__size_ = 0;
                    v62->__r_.__value_.__r.__words[2] = 0;
                    v62->__r_.__value_.__r.__words[0] = 0;
                    sub_1000D42F0((uint64_t)v59, (uint64_t *)&__dst, 0, (uint64_t)"Firmware Object: ", *(_QWORD *)v56);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v254.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v254.__r_.__value_.__l.__data_);
                    if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(cf.__r_.__value_.__l.__data_);
                    v64 = sub_1000D3C90();
                    sub_1000CB3F4(&cf, "ACFURestoreHost");
                    v65 = std::string::append(&cf, "::");
                    v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
                    v254.__r_.__value_.__r.__words[2] = v65->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&v254.__r_.__value_.__l.__data_ = v66;
                    v65->__r_.__value_.__l.__size_ = 0;
                    v65->__r_.__value_.__r.__words[2] = 0;
                    v65->__r_.__value_.__r.__words[0] = 0;
                    v67 = std::string::append(&v254, "copyFirmware");
                    v68 = *(_OWORD *)&v67->__r_.__value_.__l.__data_;
                    __dst.__r_.__value_.__r.__words[2] = v67->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v68;
                    v67->__r_.__value_.__l.__size_ = 0;
                    v67->__r_.__value_.__r.__words[2] = 0;
                    v67->__r_.__value_.__r.__words[0] = 0;
                    sub_1000D42F0((uint64_t)v64, (uint64_t *)&__dst, 0, (uint64_t)"Personalized Bundle FW URL: ", (uint64_t)v244);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v254.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v254.__r_.__value_.__l.__data_);
                    if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(cf.__r_.__value_.__l.__data_);
                    v57 = 1;
                  }
                  else if (v244)
                  {
                    CFRelease(v244);
                    v57 = 0;
                    v244 = 0;
                  }
                  else
                  {
                    v57 = 0;
                  }
                }
                if (AMSupportCopyURLWithAppendedComponent(kCFAllocatorDefault, v32, v58, 0, &value)
                  || !value)
                {
                  sub_1000CB3F4(v237, "copyFirmware: failed to create default FW URL");
                  sub_1000D3514(v223, (uint64_t)v237, 4000, 0);
                  if (v238 < 0)
                    operator delete(v237[0]);
                  v82 = sub_1000D3C90();
                  sub_1000D3D08((uint64_t)v82, 2u, "%s::%s: copyFirmware: failed to create default FW URL, (status: %d)\n", v83, v84, v85, v86, v87, (char)"ACFURestoreHost");
LABEL_92:
                  v74 = 4;
                  goto LABEL_102;
                }
                if ((v57 & 1) != 0)
                  v81 = v244;
                else
                  v81 = value;
                CFDictionaryAddValue(Mutable, *(const void **)v56, v81);
                CFDictionaryAddValue(v22, *(const void **)v56, value);
                if (value)
                {
                  CFRelease(value);
                  v74 = 0;
                  value = 0;
                }
                else
                {
                  v74 = 0;
                }
              }
              else
              {
                if (!*(_BYTE *)(v56 + 8))
                {
                  sub_1000CB3F4(__p, "copyFirmware: failed to find FW");
                  sub_1000D3514(v223, (uint64_t)__p, 4001, 0);
                  if (v242 < 0)
                    operator delete(__p[0]);
                  v75 = sub_1000D3C90();
                  sub_1000D3D08((uint64_t)v75, 2u, "%s::%s: copyFirmware: failed to find FW (%s) in build ID\n", v76, v77, v78, v79, v80, (char)"ACFURestoreHost");
                  goto LABEL_92;
                }
                v69 = sub_1000D3C90();
                sub_1000CB3F4(&cf, "ACFURestoreHost");
                v70 = std::string::append(&cf, "::");
                v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
                v254.__r_.__value_.__r.__words[2] = v70->__r_.__value_.__r.__words[2];
                *(_OWORD *)&v254.__r_.__value_.__l.__data_ = v71;
                v70->__r_.__value_.__l.__size_ = 0;
                v70->__r_.__value_.__r.__words[2] = 0;
                v70->__r_.__value_.__r.__words[0] = 0;
                v72 = std::string::append(&v254, "copyFirmware");
                v73 = *(_OWORD *)&v72->__r_.__value_.__l.__data_;
                __dst.__r_.__value_.__r.__words[2] = v72->__r_.__value_.__r.__words[2];
                *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v73;
                v72->__r_.__value_.__l.__size_ = 0;
                v72->__r_.__value_.__r.__words[2] = 0;
                v72->__r_.__value_.__r.__words[0] = 0;
                sub_1000D42F0((uint64_t)v69, (uint64_t *)&__dst, 0, (uint64_t)"skipping optional file...", *(_QWORD *)v56);
                if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(__dst.__r_.__value_.__l.__data_);
                if (SHIBYTE(v254.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(v254.__r_.__value_.__l.__data_);
                if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0)
                  operator delete(cf.__r_.__value_.__l.__data_);
                v74 = 29;
              }
LABEL_102:
              if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
              {
                operator delete(v256.__r_.__value_.__l.__data_);
                if (!v74)
                  goto LABEL_107;
              }
              else if (!v74)
              {
                goto LABEL_107;
              }
              if (v74 != 29)
              {
                v27 = 0;
                goto LABEL_184;
              }
LABEL_107:
              v56 += 16;
              if (v56 == *(_QWORD *)(a1 + 144))
                goto LABEL_116;
            }
          }
          v57 = 0;
LABEL_116:
          v27 = (*(uint64_t (**)(uint64_t, __CFDictionary *, _QWORD))(*(_QWORD *)a1 + 40))(a1, Mutable, 0);
          if (v27)
          {
            v94 = v222;
          }
          else
          {
            v94 = v222;
            if ((v57 & 1) != 0)
            {
              v95 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v95, 0, "%s::%s: attempting copyFirmwareUpdater again with source bundle file map\n", v96, v97, v98, v99, v100, (char)"ACFURestoreHost");
              v27 = (*(uint64_t (**)(uint64_t, __CFDictionary *, _QWORD))(*(_QWORD *)a1 + 40))(a1, v22, 0);
            }
            if (!v27)
            {
              sub_1000CB3F4(v235, "copyFirmware: updater failed to find firmware data with bundleURL");
              sub_1000D3514(a1 + 24, (uint64_t)v235, 4000, 0);
              v27 = 0;
              v110 = "%s::%s: updater failed to find firmware data with bundleURL\n";
              if (v236 < 0)
              {
                v111 = (void **)v235;
                goto LABEL_193;
              }
              goto LABEL_194;
            }
          }
          if (v4)
            v101 = v221 == 0;
          else
            v101 = 1;
          if (v101)
            v102 = 1;
          else
            v102 = v94;
          if ((v102 & 1) != 0)
          {
            if (v94)
            {
              v103 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v103, 0, "%s::%s: removing any personalized bits of rooted firmware\n", v104, v105, v106, v107, v108, (char)"ACFURestoreHost");
              v109 = CFDictionaryGetValue(Mutable, *(const void **)(a1 + 8));
              if ((sub_1000DC540(v109) & 1) == 0)
              {
                sub_1000CB3F4(v231, "copyFirmware: failed to remove rooted fw personalized bits");
                sub_1000D3514(a1 + 24, (uint64_t)v231, 1004, 0);
                v110 = "%s::%s: failed to remove rooted fw personalized bits\n";
                if (v232 < 0)
                {
                  v111 = (void **)v231;
                  goto LABEL_193;
                }
                goto LABEL_194;
              }
            }
          }
          else
          {
            v112 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v112, 0, "%s::%s: copying preflighted rooted firmware into the dst bundle...\n", v113, v114, v115, v116, v117, (char)"ACFURestoreHost");
            if (sub_1000D0954(v118, *(CFDictionaryRef *)(a1 + 16), (uint64_t)v224, v27))
            {
              sub_1000CB3F4(v233, "copyFirmware: failed to perform destination bundle copy of rooted firmware");
              sub_1000D3514(a1 + 24, (uint64_t)v233, 4003, 0);
              v110 = "%s::%s: failed to perform destination bundle copy of rooted firmware\n";
              if (v234 < 0)
              {
                v111 = (void **)v233;
LABEL_193:
                operator delete(*v111);
              }
LABEL_194:
              v173 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v173, 2u, v110, v174, v175, v176, v177, v178, (char)"ACFURestoreHost");
LABEL_184:
              v29 = v224;
              goto LABEL_185;
            }
          }
          if ((v4 == 0) | v57 & 1)
          {
            if ((v57 & 1) != 0)
            {
              v119 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v119, 0, "%s::%s: removing any personalized bits of bundle firmware\n", v120, v121, v122, v123, v124, (char)"ACFURestoreHost");
              v125 = *(_QWORD *)(a1 + 136);
              if (v125 != *(_QWORD *)(a1 + 144))
              {
                while (1)
                {
                  v126 = CFDictionaryGetValue(Mutable, *(const void **)v125);
                  if (v126 || !*(_BYTE *)(v125 + 8))
                  {
                    if ((sub_1000DC540(v126) & 1) == 0)
                    {
                      sub_1000CB3F4(v225, "copyFirmware: failed to remove bundle fw personalized bits");
                      sub_1000D3514(a1 + 24, (uint64_t)v225, 1004, 0);
                      v110 = "%s::%s: failed to remove bundle fw personalized bits\n";
                      if (v226 < 0)
                      {
                        v111 = (void **)v225;
                        goto LABEL_193;
                      }
                      goto LABEL_194;
                    }
                  }
                  else
                  {
                    v127 = sub_1000D3C90();
                    v128 = (std::string *)sub_1000CB3F4(&v254, "ACFURestoreHost");
                    v129 = std::string::append(v128, "::");
                    v130 = *(_OWORD *)&v129->__r_.__value_.__l.__data_;
                    __dst.__r_.__value_.__r.__words[2] = v129->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v130;
                    v129->__r_.__value_.__l.__size_ = 0;
                    v129->__r_.__value_.__r.__words[2] = 0;
                    v129->__r_.__value_.__r.__words[0] = 0;
                    v131 = std::string::append(&__dst, "copyFirmware");
                    v132 = *(_OWORD *)&v131->__r_.__value_.__l.__data_;
                    v256.__r_.__value_.__r.__words[2] = v131->__r_.__value_.__r.__words[2];
                    *(_OWORD *)&v256.__r_.__value_.__l.__data_ = v132;
                    v131->__r_.__value_.__l.__size_ = 0;
                    v131->__r_.__value_.__r.__words[2] = 0;
                    v131->__r_.__value_.__r.__words[0] = 0;
                    sub_1000D42F0((uint64_t)v127, (uint64_t *)&v256, 0, (uint64_t)"skipping removal of optional file...", *(_QWORD *)v125);
                    if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v256.__r_.__value_.__l.__data_);
                    if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(__dst.__r_.__value_.__l.__data_);
                    if (SHIBYTE(v254.__r_.__value_.__r.__words[2]) < 0)
                      operator delete(v254.__r_.__value_.__l.__data_);
                  }
                  v125 += 16;
                  if (v125 == *(_QWORD *)(a1 + 144))
                    goto LABEL_184;
                }
              }
            }
            goto LABEL_184;
          }
          v133 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v133, 0, "%s::%s: copying preflighted bundle firmware into the dst bundle...\n", v134, v135, v136, v137, v138, (char)"ACFURestoreHost");
          v139 = *(_QWORD *)(a1 + 136);
          if (v139 == *(_QWORD *)(a1 + 144))
            goto LABEL_184;
          while (1)
          {
            v140 = sub_1000D0810(*(_QWORD *)(a1 + 16), *(_QWORD *)v139);
            sub_1000DC1B8(*(const __CFString **)v139, &v256);
            if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
            {
              if (v256.__r_.__value_.__l.__size_)
              {
                v141 = sub_1000CB554(&__dst, v256.__r_.__value_.__l.__data_, v256.__r_.__value_.__l.__size_);
                goto LABEL_153;
              }
            }
            else if (*((_BYTE *)&v256.__r_.__value_.__s + 23))
            {
              __dst = v256;
              goto LABEL_153;
            }
            v141 = sub_1000CB3F4(&__dst, "UNDEF");
LABEL_153:
            if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v256.__r_.__value_.__l.__data_);
            v256 = __dst;
            if (v140)
            {
              if (!sub_1000D0954(v141, *(CFDictionaryRef *)(a1 + 16), (uint64_t)v140, v27))
              {
                v142 = 0;
                goto LABEL_170;
              }
              sub_1000CB3F4(v227, "copyFirmware: failed to perform destination bundle copy of rooted firmware");
              sub_1000D3514(a1 + 24, (uint64_t)v227, 4003, 0);
              if (v228 < 0)
                operator delete(v227[0]);
              v154 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v154, 2u, "%s::%s: failed to perform destination bundle copy of rooted firmware\n", v155, v156, v157, v158, v159, (char)"ACFURestoreHost");
              goto LABEL_169;
            }
            if (!*(_BYTE *)(v139 + 8))
            {
              sub_1000CB3F4(v229, "copyFirmware: failed to find FW in personalized path");
              sub_1000D3514(a1 + 24, (uint64_t)v229, 4001, 0);
              if (v230 < 0)
                operator delete(v229[0]);
              v148 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v148, 2u, "%s::%s: failed to find FW (%s) in build ID in personalized path\n", v149, v150, v151, v152, v153, (char)"ACFURestoreHost");
LABEL_169:
              v142 = 4;
              goto LABEL_170;
            }
            v143 = sub_1000D3C90();
            sub_1000CB3F4(&cf, "ACFURestoreHost");
            v144 = std::string::append(&cf, "::");
            v145 = *(_OWORD *)&v144->__r_.__value_.__l.__data_;
            v254.__r_.__value_.__r.__words[2] = v144->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v254.__r_.__value_.__l.__data_ = v145;
            v144->__r_.__value_.__l.__size_ = 0;
            v144->__r_.__value_.__r.__words[2] = 0;
            v144->__r_.__value_.__r.__words[0] = 0;
            v146 = std::string::append(&v254, "copyFirmware");
            v147 = *(_OWORD *)&v146->__r_.__value_.__l.__data_;
            __dst.__r_.__value_.__r.__words[2] = v146->__r_.__value_.__r.__words[2];
            *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v147;
            v146->__r_.__value_.__l.__size_ = 0;
            v146->__r_.__value_.__r.__words[2] = 0;
            v146->__r_.__value_.__r.__words[0] = 0;
            sub_1000D42F0((uint64_t)v143, (uint64_t *)&__dst, 0, (uint64_t)"skipping copying of optional file...", *(_QWORD *)v139);
            if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__dst.__r_.__value_.__l.__data_);
            if (SHIBYTE(v254.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v254.__r_.__value_.__l.__data_);
            if (SHIBYTE(cf.__r_.__value_.__r.__words[2]) < 0)
              operator delete(cf.__r_.__value_.__l.__data_);
            v142 = 48;
LABEL_170:
            if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(v256.__r_.__value_.__l.__data_);
              if (v142)
              {
LABEL_174:
                if (v142 != 48)
                  goto LABEL_184;
              }
            }
            else if (v142)
            {
              goto LABEL_174;
            }
            v139 += 16;
            if (v139 == *(_QWORD *)(a1 + 144))
              goto LABEL_184;
          }
        }
        cf.__r_.__value_.__r.__words[0] = 0;
        v37 = CFDictionaryGetValue(v35, CFSTR("ACFUFirmware"));
        if (!v37 || (TypeID = CFStringGetTypeID(), TypeID != CFGetTypeID(v37)))
        {
          v52 = 0;
LABEL_50:
          v222 = v52;
          goto LABEL_51;
        }
        if (!v4)
          goto LABEL_42;
        v39 = AMSupportCopyURLWithAppendedComponent(kCFAllocatorDefault, v4, v3, 0, &cf);
        if (!cf.__r_.__value_.__r.__words[0] || v39)
        {
          sub_1000CB3F4(v248, "copyFirmware: failed to create personalized rooted FW URL");
          sub_1000D3514(a1 + 24, (uint64_t)v248, 4000, 0);
          if (v249 < 0)
            operator delete(v248[0]);
          v215 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v215, 2u, "%s::%s: failed to create personalized rooted FW URL (status: %d)\n", v216, v217, v218, v219, v220, (char)"ACFURestoreHost");
          goto LABEL_216;
        }
        if (sub_1000DC3CC((uint64_t)cf.__r_.__value_.__l.__data_))
        {
          v40 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v40, 0, "%s::%s: rooted firmware was personalized already so we should use that to update\n", v41, v42, v43, v44, v45, (char)"ACFURestoreHost");
          v46 = sub_1000D3C90();
          v47 = (std::string *)sub_1000CB3F4(&v254, "ACFURestoreHost");
          v48 = std::string::append(v47, "::");
          v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
          __dst.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
          *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v49;
          v48->__r_.__value_.__l.__size_ = 0;
          v48->__r_.__value_.__r.__words[2] = 0;
          v48->__r_.__value_.__r.__words[0] = 0;
          v50 = std::string::append(&__dst, "copyFirmware");
          v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
          v256.__r_.__value_.__r.__words[2] = v50->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v256.__r_.__value_.__l.__data_ = v51;
          v50->__r_.__value_.__l.__size_ = 0;
          v50->__r_.__value_.__r.__words[2] = 0;
          v50->__r_.__value_.__r.__words[0] = 0;
          sub_1000D42F0((uint64_t)v46, (uint64_t *)&v256, 0, (uint64_t)"Rooted FW URL: ", (uint64_t)cf.__r_.__value_.__l.__data_);
          if (SHIBYTE(v256.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v256.__r_.__value_.__l.__data_);
          if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__dst.__r_.__value_.__l.__data_);
          if (SHIBYTE(v254.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v254.__r_.__value_.__l.__data_);
          v52 = 1;
          goto LABEL_43;
        }
        if (cf.__r_.__value_.__r.__words[0])
        {
          CFRelease(cf.__r_.__value_.__l.__data_);
          v52 = 0;
          cf.__r_.__value_.__r.__words[0] = 0;
        }
        else
        {
LABEL_42:
          v52 = 0;
        }
LABEL_43:
        URLFromString = AMSupportCreateURLFromString(kCFAllocatorDefault, v37);
        if (URLFromString)
        {
          v54 = (const void *)URLFromString;
          if (v52)
            v55 = (const void *)cf.__r_.__value_.__r.__words[0];
          else
            v55 = (const void *)URLFromString;
          CFDictionaryAddValue(Mutable, *(const void **)(a1 + 8), v55);
          CFDictionaryAddValue(v22, *(const void **)(a1 + 8), v54);
          if (cf.__r_.__value_.__r.__words[0])
          {
            CFRelease(cf.__r_.__value_.__l.__data_);
            cf.__r_.__value_.__r.__words[0] = 0;
          }
          CFRelease(v54);
          goto LABEL_50;
        }
        sub_1000CB3F4(v246, "copyFirmware: failed to create src rooted FW URL");
        sub_1000D3514(a1 + 24, (uint64_t)v246, 4000, 0);
        if (v247 < 0)
          operator delete(v246[0]);
        v209 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v209, 2u, "%s::%s: copyFirmware: failed to create src rooted FW URL\n", v210, v211, v212, v213, v214, (char)"ACFURestoreHost");
LABEL_216:
        v27 = 0;
        goto LABEL_18;
      }
      v203 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v203, 2u, "%s::%s: failed to allocate source bundle firmware path dictionary (type: %hhu)\n", v204, v205, v206, v207, v208, (char)"ACFURestoreHost");
    }
    else
    {
      v197 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v197, 2u, "%s::%s: failed to allocate bundle firmware path dictionary (type: %hhu)\n", v198, v199, v200, v201, v202, (char)"ACFURestoreHost");
    }
    v27 = 0;
    goto LABEL_207;
  }
  sub_1000D3D08((uint64_t)v12, 0, "%s::%s: running device invoked restore info -- using bundleData\n", v13, v14, v15, v16, v17, (char)"ACFURestoreHost");
  v18 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("BundleDataDict"));
  if (v18 && (v19 = v18, v20 = CFDictionaryGetTypeID(), v20 == CFGetTypeID(v19)))
  {
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v19);
    if (MutableCopy)
    {
      v22 = MutableCopy;
      v23 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("FirmwareData"));
      if (v23)
      {
        v24 = v23;
        v25 = CFDataGetTypeID();
        if (v25 == CFGetTypeID(v24))
          CFDictionarySetValue(v22, *(const void **)(a1 + 8), v24);
      }
      v26 = (*(uint64_t (**)(uint64_t, __CFDictionary *, uint64_t))(*(_QWORD *)a1 + 40))(a1, v22, 1);
      if (v26)
      {
        v27 = v26;
        Mutable = 0;
LABEL_18:
        v29 = v3;
LABEL_185:
        CFRelease(v29);
        goto LABEL_186;
      }
      sub_1000CB3F4(v252, "copyFirmware: updater failed to find firmware data with bundleData");
      sub_1000D3514(a1 + 24, (uint64_t)v252, 4000, 0);
      if (v253 < 0)
        operator delete(v252[0]);
      v191 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v191, 2u, "%s::%s: updater failed to find firmware data with bundleData\n", v192, v193, v194, v195, v196, (char)"ACFURestoreHost");
      Mutable = 0;
LABEL_203:
      v27 = 0;
      goto LABEL_18;
    }
    v185 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v185, 2u, "%s::%s: failed to create mutable copy of source device firmware data dictionary (type: %hhu)\n", v186, v187, v188, v189, v190, (char)"ACFURestoreHost");
  }
  else
  {
    v161 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v161, 2u, "%s::%s: failed due to incompatible bundle data dictionary\n", v162, v163, v164, v165, v166, (char)"ACFURestoreHost");
  }
  v27 = 0;
  Mutable = 0;
LABEL_207:
  v22 = (__CFDictionary *)v3;
LABEL_186:
  CFRelease(v22);
  if (Mutable)
    CFRelease(Mutable);
  return v27;
}

void sub_1000D060C(_Unwind_Exception *a1)
{
  uint64_t v1;

  if (*(char *)(v1 - 225) < 0)
    operator delete(*(void **)(v1 - 248));
  _Unwind_Resume(a1);
}

const void *sub_1000D0810(uint64_t a1, uint64_t a2)
{
  CFStringRef v3;
  CFStringRef v4;
  const void *ValueForKeyPathInDict;
  CFTypeID TypeID;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v3 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@.%@.%@.%@"), CFSTR("BuildIdentity"), a2, CFSTR("Info"), CFSTR("Path"));
  if (v3)
  {
    v4 = v3;
    ValueForKeyPathInDict = (const void *)AMSupportGetValueForKeyPathInDict(kCFAllocatorDefault, a1, v3);
    if (ValueForKeyPathInDict)
    {
      TypeID = CFStringGetTypeID();
      if (TypeID != CFGetTypeID(ValueForKeyPathInDict))
      {
        v20 = sub_1000D3C90();
        CFGetTypeID(ValueForKeyPathInDict);
        sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: path has wrong type %lu\n", v21, v22, v23, v24, v25, (char)"ACFURestoreHost");
      }
    }
    else
    {
      v14 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: failed to get dict entry\n", v15, v16, v17, v18, v19, (char)"ACFURestoreHost");
    }
    CFRelease(v4);
  }
  else
  {
    v8 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v8, 2u, "%s::%s: failed to create build ID key path\n", v9, v10, v11, v12, v13, (char)"ACFURestoreHost");
    return 0;
  }
  return ValueForKeyPathInDict;
}

uint64_t sub_1000D0954(int a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4)
{
  const void *Value;
  const void *v7;
  CFTypeID v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CFTypeRef cf;

  cf = 0;
  Value = CFDictionaryGetValue(theDict, CFSTR("DestBundlePath"));
  if (!Value || (v7 = Value, v8 = CFURLGetTypeID(), v8 != CFGetTypeID(v7)))
  {
    v16 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v16, 0, "%s::%s: destination bundle was not specified, so we are skipping the copy step...\n", v17, v18, v19, v20, v21, (char)"ACFURestoreHost");
    goto LABEL_9;
  }
  if (AMSupportCopyURLWithAppendedComponent(kCFAllocatorDefault, v7, a3, 0, &cf))
  {
    v24 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v24, 2u, "%s::%s: failed to create destination path URL (status: %d)\n", v25, v26, v27, v28, v29, (char)"ACFURestoreHost");
    v22 = 4000;
    goto LABEL_10;
  }
  if (AMSupportMakeDirectory(cf, v9))
  {
    v30 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v30, 2u, "%s::%s: failed to create directory @ dstPathURL (status: %d)\n", v31, v32, v33, v34, v35, (char)"ACFURestoreHost");
    v22 = 1003;
    goto LABEL_10;
  }
  if (AMSupportWriteDataToFileURL(kCFAllocatorDefault, a4, cf, 1))
  {
    v36 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v36, 2u, "%s::%s: failed to copy data to dstPathURL (status: %d)\n", v37, v38, v39, v40, v41, (char)"ACFURestoreHost");
    goto LABEL_16;
  }
  if (sub_1000DC3CC((uint64_t)cf))
  {
LABEL_9:
    v22 = 0;
    goto LABEL_10;
  }
  v10 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v10, 2u, "%s::%s: destination path does not exist after creation attempt (status: %d)\n", v11, v12, v13, v14, v15, (char)"ACFURestoreHost");
LABEL_16:
  v22 = 1004;
LABEL_10:
  if (cf)
    CFRelease(cf);
  return v22;
}

__CFDictionary *sub_1000D0B1C(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v7;
  const void **i;
  const void *v9;
  std::string::size_type v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void *Value;
  const void *v18;
  CFTypeID TypeID;
  const void *v20;
  const void *v21;
  CFTypeID v22;
  char v23;
  char v24;
  char v25;
  const void *v26;
  const void *v27;
  CFTypeID v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const void *v35;
  const void *v36;
  const void *v37;
  CFTypeID v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const void *v46;
  const __CFDictionary *v47;
  const void *v48;
  __CFDictionary *v49;
  _BOOL4 v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const void **p_dst;
  _BOOL4 v65;
  const void **v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  const __CFDictionary *v85;
  const __CFDictionary *v86;
  void *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  const void *v93;
  const void *v94;
  CFTypeID v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  void *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  const void *v109;
  CFTypeID v110;
  void *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  CFMutableDataRef v117;
  CFMutableDataRef v118;
  void *v119;
  std::string *v120;
  __int128 v121;
  std::string *v122;
  __int128 v123;
  const __CFBoolean *v124;
  const __CFBoolean *v125;
  CFTypeID v126;
  void *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  std::string *v134;
  __int128 v135;
  std::string *v136;
  __int128 v137;
  void *v139;
  void *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  void *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  void *v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  void *v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  void *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  const __CFDictionary *theDict;
  uint64_t v184;
  const __CFData *v185;
  const __CFData *v186;
  uint64_t v187;
  std::string v188;
  void *v189[2];
  char v190;
  void *v191[2];
  char v192;
  void *v193[2];
  char v194;
  void *v195[2];
  char v196;
  void *v197[2];
  char v198;
  void *v199[2];
  char v200;
  void *v201[2];
  char v202;
  std::string __dst;
  std::string __src;
  void *v205[2];
  char v206;
  void *__p[2];
  char v208;
  void *v209[2];
  char v210;
  uint64_t v211[3];
  void *v212[2];
  char v213;
  uint64_t v214[3];
  void *v215[2];
  char v216;
  uint64_t v217[3];
  _QWORD v218[2];
  char v219;
  _QWORD v220[2];
  char v221;
  void *v222[2];
  char v223;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    sub_1000CB3F4(v222, "createRequest: Failed to allocate output dictionary");
    v146 = a1 + 24;
    sub_1000D3514(v146, (uint64_t)v222, 4000, 0);
    if (v223 < 0)
      operator delete(v222[0]);
    v147 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v147, 2u, "%s::%s: Failed to allocate output dictionary\n", v148, v149, v150, v151, v152, (char)"ACFURestoreHost");
    sub_1000D3594(v146);
    return 0;
  }
  v7 = Mutable;
  for (i = *(const void ***)(a1 + 88); i != *(const void ***)(a1 + 96); ++i)
  {
    v9 = *i;
    CFDictionaryAddValue(v7, v9, kCFBooleanTrue);
  }
  sub_1000DBDD4(*(const __CFDictionary **)(a1 + 16), "validateDeviceId", &__src);
  v10 = __src.__r_.__value_.__r.__words[0];
  if (!__src.__r_.__value_.__r.__words[0])
  {
    v11 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v11, 0, "%s::%s: skipping device identity validation against build identity\n", v12, v13, v14, v15, v16, (char)"ACFURestoreHost");
  }
  Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("BuildIdentity"));
  if (!Value || (v18 = Value, TypeID = CFDictionaryGetTypeID(), TypeID != CFGetTypeID(v18)))
  {
    sub_1000CB3F4(v220, "createRequest: Failed to get build identity dict from options");
    sub_1000D3514(a1 + 24, (uint64_t)v220, 4001, 0);
    if (v221 < 0)
    {
      v139 = (void *)v220[0];
LABEL_125:
      operator delete(v139);
    }
LABEL_126:
    v140 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v140, 2u, "%s::%s: failed to get build identity dict from options\n", v141, v142, v143, v144, v145, (char)"ACFURestoreHost");
    goto LABEL_117;
  }
  v20 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DeviceInfo"));
  if (!v20 || (v21 = v20, v22 = CFDictionaryGetTypeID(), v22 != CFGetTypeID(v21)))
  {
    sub_1000CB3F4(v218, "createRequest: Failed to get build identity dict from options");
    sub_1000D3514(a1 + 24, (uint64_t)v218, 4001, 0);
    if (v219 < 0)
    {
      v139 = (void *)v218[0];
      goto LABEL_125;
    }
    goto LABEL_126;
  }
  if (v10
    && (sub_1000D30A0(v217, a1 + 160),
        v23 = sub_1000D1B28((const __CFString ***)(a1 + 64), (const __CFString ***)(a1 + 40), (const __CFDictionary *)v21, (const __CFDictionary *)v18, (uint64_t)v217), sub_1000CBD74((uint64_t)v217, (_QWORD *)v217[1]), (v23 & 1) == 0))
  {
    sub_1000CB3F4(v215, "createRequest: Failed to validate device identity tags");
    sub_1000D3514(a1 + 24, (uint64_t)v215, 4009, 0);
    if (v216 < 0)
      operator delete(v215[0]);
    v165 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v165, 2u, "%s::%s: failed to validate device identity tags\n", v166, v167, v168, v169, v170, (char)"ACFURestoreHost");
  }
  else
  {
    sub_1000D30A0(v214, a1 + 160);
    v24 = sub_1000D24F4((unint64_t **)(a1 + 40), (uint64_t)v214, (CFDictionaryRef)v18, v7);
    sub_1000CBD74((uint64_t)v214, (_QWORD *)v214[1]);
    if ((v24 & 1) != 0)
    {
      sub_1000D30A0(v211, a1 + 160);
      v25 = sub_1000D24F4((unint64_t **)(a1 + 64), (uint64_t)v211, (CFDictionaryRef)v21, v7);
      sub_1000CBD74((uint64_t)v211, (_QWORD *)v211[1]);
      if ((v25 & 1) != 0)
      {
        if (*(_QWORD *)a3)
        {
          v26 = CFDictionaryGetValue((CFDictionaryRef)v21, *(const void **)a3);
          if (!v26 || (v27 = v26, v28 = CFDataGetTypeID(), v28 != CFGetTypeID(v27)))
          {
            sub_1000CB3F4(__p, "createRequest: Production mode not present in device info. This is fatal!");
            sub_1000D3514(a1 + 24, (uint64_t)__p, 4001, 0);
            if (v208 < 0)
              operator delete(__p[0]);
            v29 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v29, 2u, "%s::%s: production mode not present in device info. This is fatal!\n", v30, v31, v32, v33, v34, (char)"ACFURestoreHost");
            goto LABEL_117;
          }
        }
        else
        {
          v27 = 0;
        }
        v35 = *(const void **)(a3 + 8);
        if (v35)
        {
          v36 = CFDictionaryGetValue((CFDictionaryRef)v21, v35);
          if (!v36 || (v37 = v36, v38 = CFDataGetTypeID(), v38 != CFGetTypeID(v37)))
          {
            sub_1000CB3F4(v205, "createRequest: Security mode not present in device info. This is fatal!");
            sub_1000D3514(a1 + 24, (uint64_t)v205, 4001, 0);
            if (v206 < 0)
              operator delete(v205[0]);
            v39 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v39, 2u, "%s::%s: security mode not present in device info. This is fatal!\n", v40, v41, v42, v43, v44, (char)"ACFURestoreHost");
            goto LABEL_117;
          }
        }
        else
        {
          v37 = 0;
        }
        v185 = (const __CFData *)v37;
        v186 = (const __CFData *)v27;
        theDict = (const __CFDictionary *)v21;
        v45 = *(_QWORD *)(a1 + 136);
        if (v45 != *(_QWORD *)(a1 + 144))
        {
          v187 = a1 + 200;
          v184 = a1 + 24;
          do
          {
            v46 = sub_1000DA1B8(*a2, *(const void **)v45);
            v47 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v18, *(const void **)v45);
            sub_1000DC1B8(*(const __CFString **)v45, &__src);
            if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
            {
              if (__src.__r_.__value_.__l.__size_)
              {
                sub_1000CB554(&__dst, __src.__r_.__value_.__l.__data_, __src.__r_.__value_.__l.__size_);
                goto LABEL_36;
              }
            }
            else if (*((_BYTE *)&__src.__r_.__value_.__s + 23))
            {
              __dst = __src;
              goto LABEL_36;
            }
            sub_1000CB3F4(&__dst, "UNDEF");
LABEL_36:
            if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
              operator delete(__src.__r_.__value_.__l.__data_);
            __src = __dst;
            if (!v47)
            {
              if (!*(_BYTE *)(v45 + 8) && v46)
              {
                sub_1000CB3F4(v201, "createRequest: could not find FW in build ID");
                sub_1000D3514(v184, (uint64_t)v201, 1005, 0);
                if (v202 < 0)
                  operator delete(v201[0]);
                v51 = sub_1000D3C90();
                sub_1000D3D08((uint64_t)v51, 2u, "%s::%s: could not find FW (%s) in build ID\n", v52, v53, v54, v55, v56, (char)"ACFURestoreHost");
                goto LABEL_49;
              }
LABEL_50:
              v58 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v58, 0, "%s::%s: Tag '%s' doesn't exist -- moving along\n", v59, v60, v61, v62, v63, (char)"ACFURestoreHost");
              v57 = 24;
              goto LABEL_69;
            }
            if (!v46)
              goto LABEL_50;
            v48 = CFDictionaryGetValue(v47, CFSTR("Trusted"));
            v49 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (!v49)
            {
              sub_1000CB3F4(v199, "createRequest: failed to allocate internal data structure");
              sub_1000D3514(v184, (uint64_t)v199, 4000, 0);
              if (v200 < 0)
                operator delete(v199[0]);
              v67 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v67, 2u, "%s::%s: failed to allocate internal data structure\n", v68, v69, v70, v71, v72, (char)"ACFURestoreHost");
              goto LABEL_49;
            }
            if (*(_QWORD *)a3)
            {
              if (*(_BYTE *)(a3 + 16))
                v50 = *(_BYTE *)sub_1000CB3A0(v187, (unint64_t *)v45) != 0;
              else
                v50 = 0;
              sub_1000D26B4(v186, (uint64_t)&__dst);
              if (__dst.__r_.__value_.__s.__data_[8])
              {
                sub_1000CB3F4(v197, "createRequest: epro data to BOOLean conversion failure");
                sub_1000D3514(v184, (uint64_t)v197, 1005, 0);
                if (v198 < 0)
                  operator delete(v197[0]);
                v73 = sub_1000D3C90();
                sub_1000D3D08((uint64_t)v73, 2u, "%s::%s: epro data to BOOLean conversion failure\n", v74, v75, v76, v77, v78, (char)"ACFURestoreHost");
                goto LABEL_49;
              }
              if (v50)
              {
                CFDictionaryAddValue(v49, CFSTR("DPRO"), kCFBooleanTrue);
                p_dst = (const void **)&kCFBooleanFalse;
              }
              else
              {
                p_dst = (const void **)&__dst;
              }
              CFDictionaryAddValue(v49, CFSTR("EPRO"), *p_dst);
            }
            if (*(_QWORD *)(a3 + 8))
            {
              if (*(_BYTE *)(a3 + 17))
                v65 = *((_BYTE *)sub_1000CB3A0(v187, (unint64_t *)v45) + 1) != 0;
              else
                v65 = 0;
              sub_1000D26B4(v185, (uint64_t)&__dst);
              if (__dst.__r_.__value_.__s.__data_[8])
              {
                sub_1000CB3F4(v195, "createRequest: esec data to BOOLean conversion failure");
                sub_1000D3514(v184, (uint64_t)v195, 1005, 0);
                if (v196 < 0)
                  operator delete(v195[0]);
                v79 = sub_1000D3C90();
                sub_1000D3D08((uint64_t)v79, 2u, "%s::%s: esec data to BOOLean conversion failure\n", v80, v81, v82, v83, v84, (char)"ACFURestoreHost");
LABEL_49:
                v57 = 4;
                goto LABEL_69;
              }
              if (v65)
              {
                CFDictionaryAddValue(v49, CFSTR("DSEC"), kCFBooleanTrue);
                v66 = (const void **)&kCFBooleanFalse;
              }
              else
              {
                v66 = (const void **)&__dst;
              }
              CFDictionaryAddValue(v49, CFSTR("ESEC"), *v66);
            }
            CFDictionaryAddValue(v49, CFSTR("Digest"), v46);
            if (v48)
              CFDictionaryAddValue(v49, CFSTR("Trusted"), v48);
            CFDictionaryAddValue(v7, *(const void **)v45, v49);
            CFRelease(v49);
            v57 = 0;
LABEL_69:
            if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
            {
              operator delete(__src.__r_.__value_.__l.__data_);
              if (v57)
              {
LABEL_73:
                if (v57 != 24)
                  goto LABEL_117;
              }
            }
            else if (v57)
            {
              goto LABEL_73;
            }
            v45 += 16;
          }
          while (v45 != *(_QWORD *)(a1 + 144));
        }
        if (!*(_QWORD *)(a1 + 184))
          goto LABEL_106;
        v85 = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("Options"));
        if (v85)
        {
          v86 = v85;
          if (CFDictionaryContainsKey(v85, CFSTR("TrustObjectDigest")))
          {
            v87 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v87, 0, "%s::%s: Using FDR trust object hash in updater options override\n", v88, v89, v90, v91, v92, (char)"ACFURestoreHost");
            v93 = CFDictionaryGetValue(v86, CFSTR("TrustObjectDigest"));
            if (!v93 || (v94 = v93, v95 = CFDataGetTypeID(), v95 != CFGetTypeID(v94)))
            {
              sub_1000CB3F4(v193, "createRequest: Invalid FDR trust object hash in updater options override");
              sub_1000D3514(a1 + 24, (uint64_t)v193, 1005, 0);
              if (v194 < 0)
                operator delete(v193[0]);
              v96 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v96, 2u, "%s::%s: Invalid FDR trust object hash in updater options override\n", v97, v98, v99, v100, v101, (char)"ACFURestoreHost");
              goto LABEL_117;
            }
            goto LABEL_97;
          }
        }
        v102 = CFDictionaryContainsKey(theDict, CFSTR("ACFU,FDRTrustObjectHash"));
        v103 = sub_1000D3C90();
        if (v102)
        {
          sub_1000D3D08((uint64_t)v103, 0, "%s::%s: Using FDR trust object hash in client updater override\n", v104, v105, v106, v107, v108, (char)"ACFURestoreHost");
          v109 = CFDictionaryGetValue(theDict, CFSTR("ACFU,FDRTrustObjectHash"));
          if (v109)
          {
            v94 = v109;
            v110 = CFDataGetTypeID();
            if (v110 == CFGetTypeID(v94))
            {
LABEL_97:
              v111 = sub_1000D3C90();
              sub_1000D3D08((uint64_t)v111, 0, "%s::%s: Applying FDR trust object hash override\n", v112, v113, v114, v115, v116, (char)"ACFURestoreHost");
              CFDictionarySetValue(v7, *(const void **)(a1 + 184), v94);
LABEL_100:
              v119 = sub_1000D3C90();
              sub_1000CB3F4(&v188, "ACFURestoreHost");
              v120 = std::string::append(&v188, "::");
              v121 = *(_OWORD *)&v120->__r_.__value_.__l.__data_;
              __dst.__r_.__value_.__r.__words[2] = v120->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v121;
              v120->__r_.__value_.__l.__size_ = 0;
              v120->__r_.__value_.__r.__words[2] = 0;
              v120->__r_.__value_.__r.__words[0] = 0;
              v122 = std::string::append(&__dst, "createRequest");
              v123 = *(_OWORD *)&v122->__r_.__value_.__l.__data_;
              __src.__r_.__value_.__r.__words[2] = v122->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__src.__r_.__value_.__l.__data_ = v123;
              v122->__r_.__value_.__l.__size_ = 0;
              v122->__r_.__value_.__r.__words[2] = 0;
              v122->__r_.__value_.__r.__words[0] = 0;
              sub_1000D42F0((uint64_t)v119, (uint64_t *)&__src, 4u, (uint64_t)"FDR Trust Object Digest: ", (uint64_t)v94);
              if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__src.__r_.__value_.__l.__data_);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__dst.__r_.__value_.__l.__data_);
              if (SHIBYTE(v188.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v188.__r_.__value_.__l.__data_);
LABEL_106:
              if (*(_QWORD *)(a1 + 192))
              {
                v124 = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("ACFU,FDRAllowUnsealed"));
                if (v124)
                {
                  v125 = v124;
                  v126 = CFGetTypeID(v124);
                  if (v126 == CFBooleanGetTypeID())
                  {
                    if (CFBooleanGetValue(v125))
                    {
                      v127 = sub_1000D3C90();
                      sub_1000D3D08((uint64_t)v127, 0, "%s::%s: allowing unsealed FDR data\n", v128, v129, v130, v131, v132, (char)"ACFURestoreHost");
                      CFDictionaryAddValue(v7, *(const void **)(a1 + 192), kCFBooleanTrue);
                    }
                  }
                }
              }
              v133 = sub_1000D3C90();
              sub_1000CB3F4(&v188, "ACFURestoreHost");
              v134 = std::string::append(&v188, "::");
              v135 = *(_OWORD *)&v134->__r_.__value_.__l.__data_;
              __dst.__r_.__value_.__r.__words[2] = v134->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__dst.__r_.__value_.__l.__data_ = v135;
              v134->__r_.__value_.__l.__size_ = 0;
              v134->__r_.__value_.__r.__words[2] = 0;
              v134->__r_.__value_.__r.__words[0] = 0;
              v136 = std::string::append(&__dst, "createRequest");
              v137 = *(_OWORD *)&v136->__r_.__value_.__l.__data_;
              __src.__r_.__value_.__r.__words[2] = v136->__r_.__value_.__r.__words[2];
              *(_OWORD *)&__src.__r_.__value_.__l.__data_ = v137;
              v136->__r_.__value_.__l.__size_ = 0;
              v136->__r_.__value_.__r.__words[2] = 0;
              v136->__r_.__value_.__r.__words[0] = 0;
              sub_1000D42F0((uint64_t)v133, (uint64_t *)&__src, 0, (uint64_t)"Request Dictionary:", (uint64_t)v7);
              if (SHIBYTE(__src.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__src.__r_.__value_.__l.__data_);
              if (SHIBYTE(__dst.__r_.__value_.__r.__words[2]) < 0)
                operator delete(__dst.__r_.__value_.__l.__data_);
              if (SHIBYTE(v188.__r_.__value_.__r.__words[2]) < 0)
                operator delete(v188.__r_.__value_.__l.__data_);
              goto LABEL_117;
            }
          }
          sub_1000CB3F4(v191, "createRequest: Invalid FDR trust object hash in client updater override");
          sub_1000D3514(a1 + 24, (uint64_t)v191, 1005, 0);
          if (v192 < 0)
            operator delete(v191[0]);
          v171 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v171, 2u, "%s::%s: Invalid FDR trust object hash in client updater override\n", v172, v173, v174, v175, v176, (char)"ACFURestoreHost");
        }
        else
        {
          sub_1000D3D08((uint64_t)v103, 0, "%s::%s: Requesting FDR trust object hash\n", v104, v105, v106, v107, v108, (char)"ACFURestoreHost");
          v117 = CFDataCreateMutable(kCFAllocatorDefault, 0);
          if (v117)
          {
            v118 = v117;
            CFDictionarySetValue(v7, *(const void **)(a1 + 184), v117);
            CFRelease(v118);
            v94 = 0;
            goto LABEL_100;
          }
          sub_1000CB3F4(v189, "createRequest: Failed to create empty trust object hash");
          sub_1000D3514(a1 + 24, (uint64_t)v189, 4000, 0);
          if (v190 < 0)
            operator delete(v189[0]);
          v177 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v177, 2u, "%s::%s: Failed to create empty trust object hash\n", v178, v179, v180, v181, v182, (char)"ACFURestoreHost");
        }
      }
      else
      {
        sub_1000CB3F4(v209, "createRequest: Failed to build parameters out of device identity");
        sub_1000D3514(a1 + 24, (uint64_t)v209, 4004, 0);
        if (v210 < 0)
          operator delete(v209[0]);
        v159 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v159, 2u, "%s::%s: failed to build parameters out of device identity\n", v160, v161, v162, v163, v164, (char)"ACFURestoreHost");
      }
    }
    else
    {
      sub_1000CB3F4(v212, "createRequest: Failed to build parameters out of build identity");
      sub_1000D3514(a1 + 24, (uint64_t)v212, 4004, 0);
      if (v213 < 0)
        operator delete(v212[0]);
      v153 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v153, 2u, "%s::%s: failed to build parameters out of build identity\n", v154, v155, v156, v157, v158, (char)"ACFURestoreHost");
    }
  }
LABEL_117:
  if (sub_1000D3594(a1 + 24))
  {
    CFRelease(v7);
    return 0;
  }
  return v7;
}

void sub_1000D1924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  if (a27 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D1B28(const __CFString ***a1, const __CFString ***a2, const __CFDictionary *a3, const __CFDictionary *a4, uint64_t a5)
{
  const __CFString **v5;
  const __CFString **v6;
  const __CFDictionary *v7;
  const __CFDictionary *v8;
  const __CFString **v10;
  const __CFString **v11;
  const __CFString *Value;
  const __CFString *v13;
  _QWORD *v14;
  const __CFString *v15;
  _QWORD *v16;
  unint64_t v17;
  BOOL v18;
  _QWORD *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  int v27;
  char v28;
  char v29;
  CFTypeID v30;
  CFTypeID v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  std::string *v63;
  __int128 v64;
  std::string *v65;
  __int128 v66;
  void *v67;
  std::string *v68;
  __int128 v69;
  std::string *v70;
  __int128 v71;
  void *v72;
  std::string *v73;
  __int128 v74;
  std::string *v75;
  __int128 v76;
  void *v77;
  std::string *v78;
  __int128 v79;
  std::string *v80;
  __int128 v81;
  const __CFString **v84;
  CFTypeID v87;
  CFTypeRef cf2;
  CFTypeRef cf;
  _QWORD *v90;
  std::string v91;
  std::string __p;
  __int128 v93;
  std::string::size_type v94;
  void *v95;
  char v96;

  v5 = *a1;
  v6 = a1[1];
  if (*a1 == v6)
  {
    v29 = 1;
    return v29 & 1;
  }
  v7 = a4;
  v8 = a3;
  cf2 = 0;
  cf = 0;
  v84 = a1[1];
  v90 = (_QWORD *)(a5 + 8);
  while (1)
  {
    v11 = *a2;
    v10 = a2[1];
    if (*a2 != v10)
    {
      while (*v11 != *v5)
      {
        if (++v11 == v10)
        {
          v11 = a2[1];
          break;
        }
      }
    }
    if (v11 == v10)
      goto LABEL_30;
    sub_1000DC1B8(*v5, &v95);
    Value = (const __CFString *)CFDictionaryGetValue(v8, *v5);
    if (!Value)
    {
      v20 = sub_1000D3C90();
      v26 = "%s::%s: tag '%s' not found in device info, skipping validation\n";
      goto LABEL_24;
    }
    v13 = (const __CFString *)CFDictionaryGetValue(v7, *v5);
    if (!v13)
    {
      v20 = sub_1000D3C90();
      v26 = "%s::%s: tag '%s' not found in build identity, skipping validation\n";
      goto LABEL_24;
    }
    v14 = (_QWORD *)*v90;
    if (!*v90)
      goto LABEL_21;
    v15 = *v5;
    v16 = v90;
    do
    {
      v17 = v14[4];
      v18 = v17 >= (unint64_t)v15;
      if (v17 >= (unint64_t)v15)
        v19 = v14;
      else
        v19 = v14 + 1;
      if (v18)
        v16 = v14;
      v14 = (_QWORD *)*v19;
    }
    while (*v19);
    if (v16 == v90 || (unint64_t)v15 < v16[4])
    {
LABEL_21:
      v20 = sub_1000D3C90();
      v26 = "%s::%s: tag '%s' not found in tss-request map, skipping validation\n";
LABEL_24:
      v27 = 3;
      sub_1000D3D08((uint64_t)v20, 3u, v26, v21, v22, v23, v24, v25, (char)"ACFURestoreHost");
      v28 = 0;
      goto LABEL_25;
    }
    v30 = CFGetTypeID(Value);
    v87 = CFGetTypeID(v13);
    v31 = *sub_1000CB3A0(a5, (unint64_t *)v5);
    v32 = sub_1000D3C90();
    sub_1000DC2A4(v30, 1, &v93);
    sub_1000DC2A4(v31, 1, &__p);
    sub_1000D3D08((uint64_t)v32, 4u, "%s::%s: attempting to convert tag '%s' from device info type (%s) to tss-request map type (%s)\n", v33, v34, v35, v36, v37, (char)"ACFURestoreHost");
    if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p.__r_.__value_.__l.__data_);
    if (SHIBYTE(v94) < 0)
    {
      operator delete((void *)v93);
      if (!cf)
        goto LABEL_39;
LABEL_38:
      CFRelease(cf);
      goto LABEL_39;
    }
    if (cf)
      goto LABEL_38;
LABEL_39:
    cf = sub_1000D2AC4(Value, v31);
    if (cf)
    {
      v38 = sub_1000D3C90();
      sub_1000DC2A4(v87, 1, &v93);
      sub_1000DC2A4(v31, 1, &__p);
      sub_1000D3D08((uint64_t)v38, 4u, "%s::%s: attempting to convert tag '%s' from build identity type (%s) to tss-request map type (%s)\n", v39, v40, v41, v42, v43, (char)"ACFURestoreHost");
      v8 = a3;
      v7 = a4;
      v6 = v84;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v94) < 0)
        operator delete((void *)v93);
      if (cf2)
        CFRelease(cf2);
      cf2 = sub_1000D2AC4(v13, v31);
      if (cf2)
      {
        if (CFEqual(cf, cf2))
        {
          v27 = 0;
          v28 = 1;
          goto LABEL_25;
        }
        v56 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v56, 2u, "%s::%s: tag '%s' has different values in device info and build identity\n", v57, v58, v59, v60, v61, (char)"ACFURestoreHost");
        v62 = sub_1000D3C90();
        sub_1000CB3F4(&v91, "ACFURestoreHost");
        v63 = std::string::append(&v91, "::");
        v64 = *(_OWORD *)&v63->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v63->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v64;
        v63->__r_.__value_.__l.__size_ = 0;
        v63->__r_.__value_.__r.__words[2] = 0;
        v63->__r_.__value_.__r.__words[0] = 0;
        v65 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        v66 = *(_OWORD *)&v65->__r_.__value_.__l.__data_;
        v94 = v65->__r_.__value_.__r.__words[2];
        v93 = v66;
        v65->__r_.__value_.__l.__size_ = 0;
        v65->__r_.__value_.__r.__words[2] = 0;
        v65->__r_.__value_.__r.__words[0] = 0;
        sub_1000D42F0((uint64_t)v62, (uint64_t *)&v93, 2u, (uint64_t)"device info value: ", (uint64_t)Value);
        if (SHIBYTE(v94) < 0)
          operator delete((void *)v93);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91.__r_.__value_.__l.__data_);
        v67 = sub_1000D3C90();
        sub_1000CB3F4(&v91, "ACFURestoreHost");
        v68 = std::string::append(&v91, "::");
        v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v68->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v69;
        v68->__r_.__value_.__l.__size_ = 0;
        v68->__r_.__value_.__r.__words[2] = 0;
        v68->__r_.__value_.__r.__words[0] = 0;
        v70 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        v71 = *(_OWORD *)&v70->__r_.__value_.__l.__data_;
        v94 = v70->__r_.__value_.__r.__words[2];
        v93 = v71;
        v70->__r_.__value_.__l.__size_ = 0;
        v70->__r_.__value_.__r.__words[2] = 0;
        v70->__r_.__value_.__r.__words[0] = 0;
        sub_1000D42F0((uint64_t)v67, (uint64_t *)&v93, 2u, (uint64_t)"device info value converted: ", (uint64_t)cf);
        if (SHIBYTE(v94) < 0)
          operator delete((void *)v93);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91.__r_.__value_.__l.__data_);
        v72 = sub_1000D3C90();
        sub_1000CB3F4(&v91, "ACFURestoreHost");
        v73 = std::string::append(&v91, "::");
        v74 = *(_OWORD *)&v73->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v73->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v74;
        v73->__r_.__value_.__l.__size_ = 0;
        v73->__r_.__value_.__r.__words[2] = 0;
        v73->__r_.__value_.__r.__words[0] = 0;
        v75 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
        v94 = v75->__r_.__value_.__r.__words[2];
        v93 = v76;
        v75->__r_.__value_.__l.__size_ = 0;
        v75->__r_.__value_.__r.__words[2] = 0;
        v75->__r_.__value_.__r.__words[0] = 0;
        sub_1000D42F0((uint64_t)v72, (uint64_t *)&v93, 2u, (uint64_t)"build identity value: ", (uint64_t)v13);
        if (SHIBYTE(v94) < 0)
          operator delete((void *)v93);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91.__r_.__value_.__l.__data_);
        v77 = sub_1000D3C90();
        sub_1000CB3F4(&v91, "ACFURestoreHost");
        v78 = std::string::append(&v91, "::");
        v79 = *(_OWORD *)&v78->__r_.__value_.__l.__data_;
        __p.__r_.__value_.__r.__words[2] = v78->__r_.__value_.__r.__words[2];
        *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v79;
        v78->__r_.__value_.__l.__size_ = 0;
        v78->__r_.__value_.__r.__words[2] = 0;
        v78->__r_.__value_.__r.__words[0] = 0;
        v80 = std::string::append(&__p, "validateDeviceInfoAgainstBuildIdentity");
        v81 = *(_OWORD *)&v80->__r_.__value_.__l.__data_;
        v94 = v80->__r_.__value_.__r.__words[2];
        v93 = v81;
        v80->__r_.__value_.__l.__size_ = 0;
        v80->__r_.__value_.__r.__words[2] = 0;
        v80->__r_.__value_.__r.__words[0] = 0;
        sub_1000D42F0((uint64_t)v77, (uint64_t *)&v93, 2u, (uint64_t)"build identity value converted: ", (uint64_t)cf2);
        if (SHIBYTE(v94) < 0)
          operator delete((void *)v93);
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v91.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v91.__r_.__value_.__l.__data_);
      }
      else
      {
        v50 = sub_1000D3C90();
        sub_1000DC2A4(v87, 1, &v93);
        sub_1000DC2A4(v31, 1, &__p);
        sub_1000D3D08((uint64_t)v50, 2u, "%s::%s: failed to convert tag '%s' from build identity type (%s) to tss-request map type (%s)\n", v51, v52, v53, v54, v55, (char)"ACFURestoreHost");
        v8 = a3;
        v7 = a4;
        v6 = v84;
        if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
          operator delete(__p.__r_.__value_.__l.__data_);
        if (SHIBYTE(v94) < 0)
          operator delete((void *)v93);
        cf2 = 0;
      }
    }
    else
    {
      v44 = sub_1000D3C90();
      sub_1000DC2A4(v30, 1, &v93);
      sub_1000DC2A4(v31, 1, &__p);
      sub_1000D3D08((uint64_t)v44, 2u, "%s::%s: failed to convert tag '%s' from device info type (%s) to tss-request map type (%s)\n", v45, v46, v47, v48, v49, (char)"ACFURestoreHost");
      v8 = a3;
      v7 = a4;
      v6 = v84;
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (SHIBYTE(v94) < 0)
        operator delete((void *)v93);
      cf = 0;
    }
    v28 = 0;
    v27 = 8;
LABEL_25:
    if (v96 < 0)
      break;
    if ((v28 & 1) == 0)
      goto LABEL_29;
LABEL_30:
    if (++v5 == v6)
    {
      v29 = 1;
LABEL_84:
      if (cf)
        CFRelease(cf);
      if (cf2)
        CFRelease(cf2);
      return v29 & 1;
    }
  }
  operator delete(v95);
  if ((v28 & 1) != 0)
    goto LABEL_30;
LABEL_29:
  v29 = 1;
  switch(v27)
  {
    case 0:
    case 3:
      goto LABEL_30;
    case 2:
      goto LABEL_84;
    case 8:
      v29 = 0;
      goto LABEL_84;
    default:
      return v29 & 1;
  }
  return v29 & 1;
}

void sub_1000D2408(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *__p,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 121) < 0)
    operator delete(*(void **)(v33 - 144));
  if (a33 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (*(char *)(v33 - 89) < 0)
    operator delete(*(void **)(v33 - 112));
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D24F4(unint64_t **a1, uint64_t a2, CFDictionaryRef theDict, __CFDictionary *a4)
{
  unint64_t *v4;
  _QWORD *v8;
  _QWORD *v9;
  const void *v10;
  _QWORD *v11;
  unint64_t v12;
  BOOL v13;
  _QWORD *v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *Value;
  const __CFString *v22;
  CFTypeID *v23;
  uint64_t result;
  const void *v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *__p[2];
  char v34;

  v4 = *a1;
  if (*a1 != a1[1])
  {
    v8 = (_QWORD *)(a2 + 8);
    do
    {
      v9 = (_QWORD *)*v8;
      v10 = (const void *)*v4;
      if (!*v8)
        goto LABEL_14;
      v11 = v8;
      do
      {
        v12 = v9[4];
        v13 = v12 >= (unint64_t)v10;
        if (v12 >= (unint64_t)v10)
          v14 = v9;
        else
          v14 = v9 + 1;
        if (v13)
          v11 = v9;
        v9 = (_QWORD *)*v14;
      }
      while (*v14);
      if (v11 != v8 && (unint64_t)v10 >= v11[4])
      {
        Value = (const __CFString *)CFDictionaryGetValue(theDict, v10);
        if (Value)
        {
          v22 = Value;
          v23 = sub_1000CB3A0(a2, v4);
          result = (uint64_t)sub_1000D2AC4(v22, *v23);
          if (!result)
            return result;
          v25 = (const void *)result;
          CFDictionarySetValue(a4, (const void *)*v4, (const void *)result);
          CFRelease(v25);
          goto LABEL_20;
        }
        sub_1000DC1B8((const __CFString *)*v4, __p);
        v26 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v26, 3u, "%s::%s: tag '%s' not found in identity dictionary, ignoring\n", v27, v28, v29, v30, v31, (char)"ACFURestoreHost");
      }
      else
      {
LABEL_14:
        sub_1000DC1B8((const __CFString *)*v4, __p);
        v15 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v15, 3u, "%s::%s: tag '%s' not found in tss-request map, ignoring\n", v16, v17, v18, v19, v20, (char)"ACFURestoreHost");
      }
      if (v34 < 0)
        operator delete(__p[0]);
LABEL_20:
      ++v4;
    }
    while (v4 != a1[1]);
  }
  return 1;
}

void sub_1000D2694(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1000D26B4(const __CFData *a1@<X0>, uint64_t a2@<X8>)
{
  CFBooleanRef v4;
  CFNumberRef v5;
  const __CFNumber *v6;
  _BOOL4 v7;
  CFNumberRef v8;
  char v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFNumberRef otherNumber;
  uint64_t valuePtr;

  v4 = kCFBooleanFalse;
  otherNumber = 0;
  valuePtr = 0;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  if (v5)
  {
    v6 = v5;
    v7 = sub_1000D2F34(a1, &otherNumber);
    if (v7)
    {
      v8 = otherNumber;
      if (CFNumberCompare(v6, otherNumber, 0))
        v4 = kCFBooleanTrue;
    }
    else
    {
      v16 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v16, 2u, "%s::%s: CFData to CFBoolean conversion failure\n", v17, v18, v19, v20, v21, (char)"ACFURestoreHost");
      v8 = otherNumber;
    }
    v9 = !v7;
    CFRelease(v6);
    if (v8)
      CFRelease(v8);
  }
  else
  {
    v10 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v10, 2u, "%s::%s: CFData to CFBoolean conversion failure\n", v11, v12, v13, v14, v15, (char)"ACFURestoreHost");
    v9 = 1;
  }
  *(_QWORD *)a2 = v4;
  *(_BYTE *)(a2 + 8) = v9;
}

CFErrorRef sub_1000D27D8(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 24;
  if (sub_1000D3594(a1 + 24))
    return sub_1000D3358(v1);
  else
    return 0;
}

uint64_t sub_1000D2814(uint64_t a1)
{
  const void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  *(_QWORD *)a1 = off_100182C78;
  v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 16) = 0;
  }
  sub_1000CBD74(a1 + 200, *(_QWORD **)(a1 + 208));
  sub_1000CBD74(a1 + 160, *(_QWORD **)(a1 + 168));
  v3 = *(void **)(a1 + 136);
  if (v3)
  {
    *(_QWORD *)(a1 + 144) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 112);
  if (v4)
  {
    *(_QWORD *)(a1 + 120) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 88);
  if (v5)
  {
    *(_QWORD *)(a1 + 96) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(a1 + 64);
  if (v6)
  {
    *(_QWORD *)(a1 + 72) = v6;
    operator delete(v6);
  }
  v7 = *(void **)(a1 + 40);
  if (v7)
  {
    *(_QWORD *)(a1 + 48) = v7;
    operator delete(v7);
  }
  sub_1000D369C(a1 + 24);
  return a1;
}

uint64_t sub_1000D28CC(uint64_t a1, uint64_t a2, const void *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 0, "%s::%s: ACFU Version: %s\n", v7, v8, v9, v10, v11, (char)"ACFURestoreHost");
  if (a2)
    v12 = a3 == 0;
  else
    v12 = 1;
  v13 = !v12;
  if (v12)
  {
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: bad parameter: options %p, domain %p\n", v15, v16, v17, v18, v19, (char)"ACFURestoreHost");
  }
  else
  {
    *(_QWORD *)(a1 + 16) = a2;
    AMSupportSafeRetain(a2);
    sub_1000D35A8((const void **)(a1 + 24), a3);
  }
  if (*(_QWORD *)(a1 + 40) == *(_QWORD *)(a1 + 48)
    || *(_QWORD *)(a1 + 136) == *(_QWORD *)(a1 + 144)
    || *(_QWORD *)(a1 + 64) == *(_QWORD *)(a1 + 72)
    || *(_QWORD *)(a1 + 88) == *(_QWORD *)(a1 + 96)
    || *(_QWORD *)(a1 + 112) == *(_QWORD *)(a1 + 120)
    || !*(_QWORD *)(a1 + 176)
    || !*(_QWORD *)(a1 + 216)
    || !*(_QWORD *)(a1 + 224))
  {
    v20 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: initialization failure due to incomplete parameters\n", v21, v22, v23, v24, v25, (char)"ACFURestoreHost");
    return 0;
  }
  return v13;
}

const void *sub_1000D29F8(void *key, CFDictionaryRef theDict, int a3)
{
  const void *Value;
  const void *v5;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v19 = 0;
  if (!key)
  {
    v7 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v7, 2u, "%s::%s: key value not provided\n", v8, v9, v10, v11, v12, (char)"ACFURestoreHost");
    return 0;
  }
  if (!theDict)
  {
    v13 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: firmware file dictionary not provided\n", v14, v15, v16, v17, v18, (char)"ACFURestoreHost");
    return 0;
  }
  Value = CFDictionaryGetValue(theDict, key);
  v5 = Value;
  if (a3)
  {
    if (Value)
      AMSupportSafeRetain(Value);
  }
  else
  {
    AMSupportCreateDataFromFileURL(kCFAllocatorDefault, &v19);
    return (const void *)v19;
  }
  return v5;
}

CFTypeRef sub_1000D2AC4(const __CFString *a1, CFTypeID a2)
{
  CFTypeID v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFTypeRef result;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *__p[2];
  char v61;
  CFTypeRef cf;
  char v63;
  char v64;

  v4 = CFGetTypeID(a1);
  v5 = sub_1000D3C90();
  sub_1000DC2A4(a2, 1, &cf);
  sub_1000DC2A4(v4, 1, __p);
  sub_1000D3D08((uint64_t)v5, 4u, "%s::%s: desired type %s, received type %s\n", v6, v7, v8, v9, v10, (char)"ACFURestoreHost");
  if (v61 < 0)
    operator delete(__p[0]);
  if (v64 < 0)
    operator delete((void *)cf);
  if (v4 == a2)
  {
    v11 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v11, 4u, "%s::%s: no conversion necessary\n", v12, v13, v14, v15, v16, (char)"ACFURestoreHost");
    return CFRetain(a1);
  }
  if (CFNumberGetTypeID() != a2 || v4 != CFStringGetTypeID())
  {
    if (CFNumberGetTypeID() == a2 && v4 == CFDataGetTypeID())
    {
      v30 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v30, 4u, "%s::%s: converting from data to number\n", v31, v32, v33, v34, v35, (char)"ACFURestoreHost");
      cf = 0;
      if (!sub_1000D2F34((const __CFData *)a1, (CFNumberRef *)&cf))
      {
        v36 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v36, 2u, "%s::%s: failed to convert from number to data\n", v37, v38, v39, v40, v41, (char)"ACFURestoreHost");
        goto LABEL_15;
      }
    }
    else
    {
      if (CFBooleanGetTypeID() != a2 || v4 != CFDataGetTypeID())
      {
        v48 = sub_1000D3C90();
        sub_1000DC2A4(a2, 1, &cf);
        sub_1000DC2A4(v4, 1, __p);
        sub_1000D3D08((uint64_t)v48, 2u, "%s::%s: unsupported conversion: desired type %s, received type %s\n", v49, v50, v51, v52, v53, (char)"ACFURestoreHost");
        if (v61 < 0)
          operator delete(__p[0]);
        if (v64 < 0)
          operator delete((void *)cf);
        return 0;
      }
      v42 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v42, 4u, "%s::%s: converting from data to BOOLean\n", v43, v44, v45, v46, v47, (char)"ACFURestoreHost");
      sub_1000D26B4((const __CFData *)a1, (uint64_t)&cf);
      if (v63)
      {
        v54 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v54, 2u, "%s::%s: failed to convert from data to BOOLean\n", v55, v56, v57, v58, v59, (char)"ACFURestoreHost");
        return 0;
      }
    }
    return cf;
  }
  v18 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v18, 4u, "%s::%s: converting from string to number\n", v19, v20, v21, v22, v23, (char)"ACFURestoreHost");
  cf = 0;
  if (sub_1000D2DCC(a1, (CFNumberRef *)&cf))
    return cf;
  v24 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v24, 2u, "%s::%s: failed to convert from string to number\n", v25, v26, v27, v28, v29, (char)"ACFURestoreHost");
LABEL_15:
  result = cf;
  if (!cf)
    return result;
  CFRelease(cf);
  return 0;
}

void sub_1000D2D90(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, void *a19, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a18 < 0)
    operator delete(__p);
  if (a24 < 0)
    operator delete(a19);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D2DCC(const __CFString *a1, CFNumberRef *a2)
{
  std::string::size_type size;
  CFNumberRef v4;
  uint64_t v5;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  std::string __str;
  int valuePtr;

  valuePtr = 0;
  sub_1000DC1B8(a1, &__str);
  size = HIBYTE(__str.__r_.__value_.__r.__words[2]);
  if ((__str.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = __str.__r_.__value_.__l.__size_;
  if (size)
  {
    valuePtr = std::stoi(&__str, 0, 0);
    v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
    *a2 = v4;
    if (v4)
    {
      v5 = 1;
      goto LABEL_6;
    }
    v7 = sub_1000D3C90();
    v13 = "%s::%s: Failed to create CF number from int value\n";
  }
  else
  {
    v7 = sub_1000D3C90();
    v13 = "%s::%s: failed to get string\n";
  }
  sub_1000D3D08((uint64_t)v7, 2u, v13, v8, v9, v10, v11, v12, (char)"ACFURestoreHost");
  v5 = 0;
LABEL_6:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  return v5;
}

BOOL sub_1000D2F34(const __CFData *a1, CFNumberRef *a2)
{
  size_t Length;
  const UInt8 *BytePtr;
  const __CFAllocator *v6;
  uint64_t *p_valuePtr;
  CFNumberType v8;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int valuePtr;
  uint64_t __dst;

  Length = CFDataGetLength(a1);
  BytePtr = CFDataGetBytePtr(a1);
  if (Length - 1 >= 8)
  {
    v10 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v10, 2u, "%s::%s: data length %ld is not within range\n", v11, v12, v13, v14, v15, (char)"ACFURestoreHost");
  }
  else
  {
    if (Length < 5)
    {
      valuePtr = 0;
      memcpy(&valuePtr, BytePtr, Length);
      v6 = kCFAllocatorDefault;
      p_valuePtr = (uint64_t *)&valuePtr;
      v8 = kCFNumberSInt32Type;
    }
    else
    {
      __dst = 0;
      memcpy(&__dst, BytePtr, Length);
      v6 = kCFAllocatorDefault;
      p_valuePtr = &__dst;
      v8 = kCFNumberSInt64Type;
    }
    *a2 = CFNumberCreate(v6, v8, p_valuePtr);
  }
  return Length - 1 < 8;
}

uint64_t sub_1000D3018(uint64_t a1)
{
  *(_QWORD *)a1 = off_100182C78;
  *(_QWORD *)(a1 + 8) = CFSTR("ACFU,RootedFW");
  *(_QWORD *)(a1 + 16) = 0;
  sub_1000D3354(a1 + 24, CFSTR("RestoreHost"));
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_OWORD *)(a1 + 120) = 0u;
  *(_OWORD *)(a1 + 136) = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = a1 + 168;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 200) = a1 + 208;
  return a1;
}

uint64_t *sub_1000D30A0(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000D30F4(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_1000D30DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000CBD74(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000D30F4(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_1000D3178(v5, v6, v4 + 4, (_OWORD *)v4 + 2);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *sub_1000D3178(uint64_t **a1, _QWORD *a2, unint64_t *a3, _OWORD *a4)
{
  void **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (void **)sub_1000CDA48(a1, a2, &v11, &v10, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x30uLL);
    *((_OWORD *)v7 + 2) = *a4;
    sub_1000CBAE0(a1, v11, v8, v7);
  }
  return v7;
}

_QWORD *sub_1000D31FC(_QWORD *__dst, __int128 *a2, uint64_t a3, uint64_t a4)
{
  __int128 v7;

  if (*((char *)a2 + 23) < 0)
  {
    sub_1000CB554(__dst, *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v7 = *a2;
    __dst[2] = *((_QWORD *)a2 + 2);
    *(_OWORD *)__dst = v7;
  }
  __dst[3] = a3;
  __dst[4] = a4;
  AMSupportSafeRetain(a4);
  return __dst;
}

void sub_1000D3264(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D3280(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 32) = 0;
  }
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
  return a1;
}

_QWORD *sub_1000D32C4(_QWORD *a1, uint64_t a2)
{
  void ***v4;
  void **v5;
  void **v7;

  a1[1] = 0;
  v4 = (void ***)(a1 + 1);
  v5 = (void **)operator new(0x18uLL);
  *v5 = 0;
  v5[1] = 0;
  v5[2] = 0;
  v7 = 0;
  sub_1000D36A0(v4, v5);
  sub_1000D36A0(&v7, 0);
  *a1 = a2;
  AMSupportSafeRetain(a2);
  return a1;
}

void sub_1000D3338(_Unwind_Exception *a1)
{
  void ***v1;

  sub_1000D36A0(v1, 0);
  _Unwind_Resume(a1);
}

CFErrorRef sub_1000D3358(uint64_t a1)
{
  __CFDictionary *Mutable;
  uint64_t v3;
  const char *v4;
  CFStringRef v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFErrorRef v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const char *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  if (**(_QWORD **)(a1 + 8) == *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8))
  {
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 4u, "%s::%s: Looks like there is no error present; Nothing to be done here.\n",
      v15,
      v16,
      v17,
      v18,
      v19,
      (char)"ACFUError");
    return 0;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  v4 = (const char *)(v3 - 40);
  if (*(char *)(v3 - 17) < 0)
    v4 = *(const char **)v4;
  v5 = CFStringCreateWithCString(kCFAllocatorDefault, v4, 0x8000100u);
  if (v5)
  {
    CFDictionaryAddValue(Mutable, kCFErrorDescriptionKey, v5);
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    if (*(_QWORD *)(v6 - 8))
    {
      v7 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v7, 3u, "%s::%s: Populating underlying error\n", v8, v9, v10, v11, v12, (char)"ACFUError");
      CFDictionaryAddValue(Mutable, kCFErrorUnderlyingErrorKey, *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) - 8));
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
    }
    v13 = CFErrorCreate(kCFAllocatorDefault, *(CFErrorDomain *)a1, *(_QWORD *)(v6 - 16), Mutable);
    if (v13)
    {
      if (!Mutable)
        goto LABEL_10;
      goto LABEL_9;
    }
    v21 = "%s::%s: failed to create CFError object\n";
  }
  else
  {
    v21 = "%s::%s: failed to create CFString for error object\n";
  }
  v22 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v22, 2u, v21, v23, v24, v25, v26, v27, (char)"ACFUError");
  v13 = 0;
  if (Mutable)
LABEL_9:
    CFRelease(Mutable);
LABEL_10:
  if (v5)
    CFRelease(v5);
  return v13;
}

uint64_t sub_1000D3514(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t *v4;
  unint64_t v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v8;

  v7 = a4;
  v8 = a3;
  v4 = *(uint64_t **)(a1 + 8);
  v5 = v4[1];
  if (v5 >= v4[2])
  {
    result = sub_1000D3750(v4, a2, &v8, &v7);
  }
  else
  {
    sub_1000D3874((_DWORD)v4 + 16, (_QWORD *)v4[1], a2, &v8, &v7);
    result = v5 + 40;
    v4[1] = v5 + 40;
  }
  v4[1] = result;
  return result;
}

void sub_1000D358C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

BOOL sub_1000D3594(uint64_t a1)
{
  return *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8) != **(_QWORD **)(a1 + 8);
}

const void *sub_1000D35A8(const void **a1, const void *a2)
{
  __CFArray *Mutable;
  const __CFArray *Copy;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 3, &kCFTypeArrayCallBacks);
  CFArrayAppendValue(Mutable, *a1);
  CFArrayAppendValue(Mutable, a2);
  Copy = CFArrayCreateCopy(kCFAllocatorDefault, Mutable);
  if (*a1)
  {
    CFRelease(*a1);
    *a1 = 0;
  }
  *a1 = CFStringCreateByCombiningStrings(kCFAllocatorDefault, Copy, CFSTR("::"));
  if (Mutable)
    CFRelease(Mutable);
  if (Copy)
    CFRelease(Copy);
  return *a1;
}

uint64_t sub_1000D365C(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)a1;
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)a1 = 0;
  }
  sub_1000D36A0((void ***)(a1 + 8), 0);
  return a1;
}

void sub_1000D36A0(void ***a1, void **a2)
{
  void **v2;
  void **v3;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    v3 = v2;
    sub_1000D36E0(&v3);
    operator delete(v2);
  }
}

void sub_1000D36E0(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = sub_1000D3280(v4 - 40);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1000D3750(uint64_t *a1, uint64_t a2, uint64_t *a3, uint64_t *a4)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  char *v14;
  char *v15;
  _QWORD *v16;
  char *v17;
  uint64_t *v18;

  v5 = 0xCCCCCCCCCCCCCCCDLL * ((a1[1] - *a1) >> 3);
  v6 = v5 + 1;
  if (v5 + 1 > 0x666666666666666)
    sub_1000CB780();
  if (0x999999999999999ALL * ((a1[2] - *a1) >> 3) > v6)
    v6 = 0x999999999999999ALL * ((a1[2] - *a1) >> 3);
  if (0xCCCCCCCCCCCCCCCDLL * ((a1[2] - *a1) >> 3) >= 0x333333333333333)
    v10 = 0x666666666666666;
  else
    v10 = v6;
  v18 = a1 + 2;
  if (v10)
    v11 = (char *)sub_1000D3984((uint64_t)(a1 + 2), v10);
  else
    v11 = 0;
  v14 = v11;
  v15 = &v11[40 * v5];
  v17 = &v11[40 * v10];
  sub_1000D3874((_DWORD)a1 + 16, v15, a2, a3, a4);
  v16 = v15 + 40;
  sub_1000D3910(a1, &v14);
  v12 = a1[1];
  sub_1000D3A90((uint64_t)&v14);
  return v12;
}

void sub_1000D3860(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000D3A90((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1000D3874(int a1, _QWORD *__dst, uint64_t a3, uint64_t *a4, uint64_t *a5)
{
  void *__p[2];
  uint64_t v9;

  if (*(char *)(a3 + 23) < 0)
  {
    sub_1000CB554(__p, *(void **)a3, *(_QWORD *)(a3 + 8));
  }
  else
  {
    *(_OWORD *)__p = *(_OWORD *)a3;
    v9 = *(_QWORD *)(a3 + 16);
  }
  sub_1000D31FC(__dst, (__int128 *)__p, *a4, *a5);
  if (SHIBYTE(v9) < 0)
    operator delete(__p[0]);
}

void sub_1000D38F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D3910(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1000D39C8((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000D3984(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x666666666666667)
    sub_1000CB52C();
  return operator new(40 * a2);
}

uint64_t sub_1000D39C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void **v13;
  __int128 v14;

  if (a3 != a5)
  {
    v10 = 0;
    v11 = a7 - 40;
    do
    {
      v12 = v11 + v10;
      v13 = (void **)(a3 + v10 - 40);
      if (*(char *)(a3 + v10 - 17) < 0)
      {
        sub_1000CB554((_BYTE *)v12, *v13, *(_QWORD *)(a3 + v10 - 32));
      }
      else
      {
        v14 = *(_OWORD *)v13;
        *(_QWORD *)(v12 + 16) = *(_QWORD *)(a3 + v10 - 24);
        *(_OWORD *)v12 = v14;
      }
      *(_OWORD *)(v11 + v10 + 24) = *(_OWORD *)(a3 + v10 - 16);
      v10 -= 40;
    }
    while (a3 + v10 != a5);
  }
  return a6;
}

void sub_1000D3A70(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v2;

  for (; v2; v2 += 40)
    sub_1000D3280(v1 + v2);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D3A90(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 40;
    sub_1000D3280(i - 40);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t sub_1000D3ADC(uint64_t a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4)
{
  const void *Value;
  const void *v9;
  CFTypeID TypeID;
  const __CFBoolean *v11;
  const __CFBoolean *v12;
  CFTypeID v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unsigned int v34;

  if (theDict)
  {
    Value = CFDictionaryGetValue(theDict, CFSTR("Options"));
    if (Value
      && (v9 = Value, TypeID = CFDictionaryGetTypeID(), TypeID == CFGetTypeID(v9))
      && (v11 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v9, CFSTR("RestoreInternal"))) != 0)
    {
      v12 = v11;
      v13 = CFGetTypeID(v11);
      v14 = 2;
      if (v13 == CFBooleanGetTypeID())
      {
        if (CFBooleanGetValue(v12) == 1)
          v14 = 3;
        else
          v14 = 2;
      }
    }
    else
    {
      v14 = 2;
    }
    *(_QWORD *)(a1 + 72) = a3;
    *(_QWORD *)(a1 + 80) = a4;
    sub_1000DBDD4(theDict, "logLevel", &v33);
    v15 = v34;
    if (v34 == 4006)
    {
      sub_1000D3C90();
      sub_1000D3D08((uint64_t)&unk_1001A8280, 3u, "%s::%s: Key: %s not found while parsing debugArgs, but this is not error\n", v16, v17, v18, v19, v20, (char)"ACFULogging");
LABEL_16:
      v21 = v14;
      goto LABEL_17;
    }
    if (v34)
    {
      sub_1000D3C90();
      sub_1000D3D08((uint64_t)&unk_1001A8280, 0, "%s::%s: Failed to parse debugArgs\n", v28, v29, v30, v31, v32, (char)"ACFULogging");
      return v15;
    }
    v21 = v33;
    if (v33 >= 5)
    {
      sub_1000D3C90();
      sub_1000D3D08((uint64_t)&unk_1001A8280, 3u, "%s::%s: Unexpected value: %u for Key: %s\n", v22, v23, v24, v25, v26, (char)"ACFULogging");
      goto LABEL_16;
    }
  }
  else
  {
    *(_QWORD *)(a1 + 72) = a3;
    *(_QWORD *)(a1 + 80) = a4;
    v21 = 2;
  }
LABEL_17:
  v15 = 0;
  *(_DWORD *)(a1 + 88) = v21;
  return v15;
}

void *sub_1000D3C90()
{
  unsigned __int8 v0;

  v0 = atomic_load((unsigned __int8 *)&qword_1001A8EE8);
  if ((v0 & 1) == 0 && __cxa_guard_acquire(&qword_1001A8EE8))
  {
    sub_1000D3DE8((uint64_t)&unk_1001A8280);
    __cxa_atexit((void (*)(void *))sub_1000D3E70, &unk_1001A8280, (void *)&_mh_execute_header);
    __cxa_guard_release(&qword_1001A8EE8);
  }
  return &unk_1001A8280;
}

void sub_1000D3D08(uint64_t a1, unsigned int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (*(_QWORD *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 88) < (signed int)a2)
      return;
  }
  else if (!os_log_type_enabled(*(os_log_t *)(a1 + 3168), *(os_log_type_t *)(a1 + a2)))
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (vsnprintf((char *)(a1 + 92), 0xC00uLL, a3, &a9) >= 0xC01)
    strcpy((char *)(a1 + 3099), "\n------ Internal buffer is too small, truncating bytes! ------\n");
  sub_1000D3EA0((_QWORD *)a1, *(os_log_type_t *)(a1 + a2), a1 + 92);
  std::mutex::unlock((std::mutex *)(a1 + 8));
}

void sub_1000D3DD4(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D3DE8(uint64_t a1)
{
  os_log_t v2;
  void *v3;

  *(_DWORD *)a1 = 17830144;
  *(_BYTE *)(a1 + 4) = 2;
  *(_QWORD *)(a1 + 8) = 850045863;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 80) = 0;
  *(_DWORD *)(a1 + 88) = 2;
  bzero((void *)(a1 + 92), 0xC00uLL);
  *(_QWORD *)(a1 + 3168) = 0;
  v2 = os_log_create("com.apple.AppleConvergedFirmwareUpdater", "service");
  v3 = *(void **)(a1 + 3168);
  *(_QWORD *)(a1 + 3168) = v2;

  return a1;
}

uint64_t sub_1000D3E70(uint64_t a1)
{

  std::mutex::~mutex((std::mutex *)(a1 + 8));
  return a1;
}

void sub_1000D3EA0(_QWORD *a1, os_log_type_t a2, uint64_t type)
{
  void (*v4)(_QWORD, uint64_t);
  NSObject *v6;
  int v7;
  uint64_t v8;

  v4 = (void (*)(_QWORD, uint64_t))a1[9];
  if (v4)
  {
    v4(a1[10], type);
  }
  else
  {
    v6 = a1[396];
    if (os_log_type_enabled(v6, a2))
    {
      v7 = 136315138;
      v8 = type;
      _os_log_impl((void *)&_mh_execute_header, v6, a2, "%s", (uint8_t *)&v7, 0xCu);
    }
  }
}

void sub_1000D3F7C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, unint64_t a5, char a6)
{
  uint64_t v8;
  uint64_t v10;
  std::mutex *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  char v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char *v27;
  unsigned __int8 *v28;
  unsigned int v29;
  char v30;
  uint64_t i;
  int v32;
  int v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  uint64_t v37;
  std::mutex *v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v43;
  char v44;
  __int128 v45;
  __int128 v46;
  _BYTE v47[32];
  __int128 v48;

  v8 = a3;
  v10 = a1;
  if (*(_QWORD *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 88) < (int)a3)
      return;
  }
  else if (!os_log_type_enabled(*(os_log_t *)(a1 + 3168), *(os_log_type_t *)(a1 + a3)))
  {
    return;
  }
  v11 = (std::mutex *)(v10 + 8);
  std::mutex::lock((std::mutex *)(v10 + 8));
  if (a5)
  {
    v38 = (std::mutex *)(v10 + 8);
    v17 = 0;
    v18 = a5 - 224;
    v19 = 0xFFFFFFFFLL;
    if (a5 <= 0x3E80)
    {
      v18 = 0;
      v20 = 0;
    }
    else
    {
      v19 = 112;
      v20 = a6;
    }
    v44 = v20;
    v43 = v19;
    v39 = v19 + v18;
    v40 = v10;
    v41 = a5;
    do
    {
      v21 = v44 ^ 1;
      if (v17 != v43)
        v21 = 1;
      if ((v21 & 1) == 0)
      {
        if (*((char *)a2 + 23) >= 0)
          LOBYTE(v22) = (_BYTE)a2;
        else
          v22 = *a2;
        sub_1000D4270(v10, v8, "%s -- middle of buffer snipped -- \n", v12, v13, v14, v15, v16, v22);
        v17 = v39;
      }
      *(_OWORD *)&v47[16] = 0u;
      v48 = 0u;
      if (a5 - v17 >= 0x10)
        v23 = 16;
      else
        v23 = a5 - v17;
      v46 = 0uLL;
      *(_OWORD *)v47 = 0uLL;
      v45 = 0uLL;
      if (v23)
      {
        v24 = v8;
        v25 = (54 - 3 * v23) - 3;
        v26 = v23;
        v27 = (char *)&v45 + 1;
        v28 = (unsigned __int8 *)(a4 + v17);
        do
        {
          v29 = *v28++;
          v30 = a0123456789abcd_0[v29 & 0xF];
          *(v27 - 1) = a0123456789abcd_0[(unint64_t)v29 >> 4];
          *v27 = v30;
          v27[1] = 32;
          v27 += 3;
          v25 += 3;
          --v26;
        }
        while (v26);
        memset(v27 - 1, 32, 3 * (17 - v23));
        for (i = 0; i != v23; ++i)
        {
          v32 = *(unsigned __int8 *)(a4 + v17 + i);
          if ((v32 - 32) >= 0x5F)
            LOBYTE(v32) = 46;
          *((_BYTE *)&v45 + v25 + i) = v32;
        }
        v33 = v25 + i;
        v34 = v24;
        v10 = v40;
        a5 = v41;
      }
      else
      {
        *(_DWORD *)&v47[15] = 538976288;
        *(_QWORD *)&v35 = 0x2020202020202020;
        *((_QWORD *)&v35 + 1) = 0x2020202020202020;
        v46 = v35;
        *(_OWORD *)v47 = v35;
        v34 = v8;
        v33 = 51;
        v45 = v35;
      }
      strcpy((char *)&v45 + v33, "\r\n");
      if (*((char *)a2 + 23) >= 0)
        LOBYTE(v36) = (_BYTE)a2;
      else
        v36 = *a2;
      sub_1000D4270(v10, v34, "%s %04zx  %s", v12, v13, v14, v15, v16, v36);
      v8 = v34;
      v17 += 16;
    }
    while (v17 < a5);
    v11 = v38;
    if ((v44 & 1) != 0)
    {
      if (*((char *)a2 + 23) >= 0)
        LOBYTE(v37) = (_BYTE)a2;
      else
        v37 = *a2;
      sub_1000D4270(v10, v34, "%s (snipped)\n", v12, v13, v14, v15, v16, v37);
    }
  }
  std::mutex::unlock(v11);
}

void sub_1000D4254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, std::mutex *a13)
{
  std::mutex::unlock(a13);
  _Unwind_Resume(a1);
}

void sub_1000D4270(uint64_t a1, unsigned int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;

  v11 = a1 + 92;
  if (vsnprintf((char *)(a1 + 92), 0xC00uLL, a3, &a9) >= 0xC01)
    strcpy((char *)(a1 + 3099), "\n------ Internal buffer is too small, truncating bytes! ------\n");
  sub_1000D3EA0((_QWORD *)a1, *(os_log_type_t *)(a1 + a2), v11);
}

void sub_1000D42F0(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  const __CFString *v16;
  const __CFString *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void **v23;
  const char *v24;
  __int128 v25;
  uint64_t v26;
  void *__p[2];
  uint64_t v28;

  __p[0] = 0;
  __p[1] = 0;
  v28 = 0;
  if (*(_QWORD *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 88) < (signed int)a3)
      return;
  }
  else if (!os_log_type_enabled(*(os_log_t *)(a1 + 3168), *(os_log_type_t *)(a1 + a3)))
  {
    return;
  }
  std::mutex::lock((std::mutex *)(a1 + 8));
  if (a5)
  {
    if (*((char *)a2 + 23) >= 0)
      v15 = a2;
    else
      v15 = (uint64_t *)*a2;
    v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%s: %s\n %@\n"), v15, a4, a5);
    v17 = v16;
    if (v16)
    {
      sub_1000DC1B8(v16, &v25);
      v28 = v26;
      *(_OWORD *)__p = v25;
      if (SHIBYTE(v26) < 0)
      {
        if (__p[1])
          LOBYTE(v23) = __p[0];
        else
          v23 = (void **)"UNDEF";
      }
      else
      {
        v23 = __p;
        if (!HIBYTE(v26))
          v23 = (void **)"UNDEF";
      }
      sub_1000D4270(a1, a3, "%s", v18, v19, v20, v21, v22, (char)v23);
      CFRelease(v17);
      goto LABEL_18;
    }
    v24 = "%s::%s: failed to format CFString\n";
  }
  else
  {
    v24 = "%s::%s: CFType to be printed is NULL\n";
  }
  sub_1000D4270(a1, 2u, v24, v10, v11, v12, v13, v14, (char)"ACFULogging");
LABEL_18:
  std::mutex::unlock((std::mutex *)(a1 + 8));
  if (SHIBYTE(v28) < 0)
    operator delete(__p[0]);
}

void sub_1000D4470(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  std::mutex *v20;

  std::mutex::unlock(v20);
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1000D4498(const void *a1@<X0>, uint64_t a2@<X1>, int a3@<W2>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v23;
  unsigned int v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  const char *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40[3];
  void **v41;

  v8 = operator new(0x60uLL);
  sub_1000DB148((uint64_t)v8);
  *v8 = off_100182CC8;
  v8[7] = 0;
  v8[6] = 0;
  v8[5] = v8 + 6;
  *((_DWORD *)v8 + 16) = 0;
  v8[11] = 0;
  v8[10] = 0;
  v8[9] = v8 + 10;
  if ((a2 & 2) != 0)
  {
    v32 = sub_1000D8464((uint64_t)v8);
    operator delete(v32);
    v33 = "%s::%s: function does not support memory optimization flow\n";
LABEL_16:
    v34 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v34, 2u, v33, v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
    v8 = 0;
LABEL_12:
    *a4 = v8;
    return;
  }
  if ((sub_1000D8528(v8, a1) & 1) == 0)
  {
    (*(void (**)(_QWORD *))(*v8 + 56))(v8);
    v33 = "%s::%s: failed to open file\n";
    goto LABEL_16;
  }
  if (a3 == 0xFFFF)
  {
LABEL_9:
    if (a2 >= 3)
    {
      v17 = sub_1000D3C90();
      v23 = "%s::%s: invalid optimization mask\n";
      v24 = 2;
    }
    else
    {
      *((_DWORD *)v8 + 16) = a2;
      v17 = sub_1000D3C90();
      v23 = "%s::%s: Object initialized!\n";
      v24 = 4;
    }
    sub_1000D3D08((uint64_t)v17, v24, v23, v18, v19, v20, v21, v22, (char)"ACFUFTABFile");
    goto LABEL_12;
  }
  sub_1000D4724(a3, v40);
  v9 = v40[0];
  v10 = v40[1];
  while (1)
  {
    if (v9 == v10)
    {
      v11 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v11, 4u, "%s::%s: Didn't find a matching embedded ftab\n", v12, v13, v14, v15, v16, (char)"ACFUFTABFile");
      v41 = (void **)v40;
      sub_1000D8BA4(&v41);
      goto LABEL_9;
    }
    if ((*(unsigned int (**)(_QWORD *, uint64_t))(*v8 + 16))(v8, v9))
      break;
    v9 += 24;
  }
  v25 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v25, 0, "%s::%s: Using embedded ftab '%s'\n", v26, v27, v28, v29, v30, (char)"ACFUFTABFile");
  v31 = (*(uint64_t (**)(_QWORD *, uint64_t))*v8)(v8, v9);
  sub_1000D4498(v31, a2, 0xFFFFLL);
  v41 = (void **)v40;
  sub_1000D8BA4(&v41);
  (*(void (**)(_QWORD *))(*v8 + 56))(v8);
}

void sub_1000D46D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 56))(v1);
  _Unwind_Resume(a1);
}

void sub_1000D4724(unsigned int a1@<W0>, uint64_t *a2@<X8>)
{
  unsigned int v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  __int128 v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  int v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  __int128 v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  __int128 v37;
  uint64_t v38;
  int v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const char *v46;
  void *__p[2];
  uint64_t v48;
  char __str[5];
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  uint64_t *v54;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  v3 = a1 >> 4;
  if (a1 >= 0x40)
  {
    v40 = sub_1000D3C90();
    v46 = "%s::%s: Chip major revision seems unreasonable: %d\n";
LABEL_32:
    sub_1000D3D08((uint64_t)v40, 2u, v46, v41, v42, v43, v44, v45, (char)"ACFUFTABFile");
    return;
  }
  if ((a1 & 0xF) >= 6)
  {
    v40 = sub_1000D3C90();
    v46 = "%s::%s: Chip minor revision seems unreasonable: %d\n";
    goto LABEL_32;
  }
  snprintf(__str, 5uLL, "_%c%cf", v3 + 97, a1 & 0xF | 0x30);
  v4 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v4, 4u, "%s::%s: %s\n", v5, v6, v7, v8, v9, (char)"ACFUFTABFile");
  sub_1000CB3F4(__p, __str);
  v10 = a2[2];
  v11 = a2[1];
  if (v11 >= v10)
  {
    v13 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v11 - *a2) >> 3);
    v14 = v13 + 1;
    if (v13 + 1 > 0xAAAAAAAAAAAAAAALL)
      sub_1000CB780();
    v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v10 - *a2) >> 3);
    if (2 * v15 > v14)
      v14 = 2 * v15;
    if (v15 >= 0x555555555555555)
      v16 = 0xAAAAAAAAAAAAAAALL;
    else
      v16 = v14;
    v54 = a2 + 2;
    if (v16)
      v17 = (char *)sub_1000D95E4((uint64_t)(a2 + 2), v16);
    else
      v17 = 0;
    v18 = &v17[24 * v13];
    v50 = v17;
    v51 = v18;
    v53 = &v17[24 * v16];
    v19 = *(_OWORD *)__p;
    *((_QWORD *)v18 + 2) = v48;
    *(_OWORD *)v18 = v19;
    __p[1] = 0;
    v48 = 0;
    __p[0] = 0;
    v52 = v18 + 24;
    sub_1000D9570(a2, &v50);
    v20 = a2[1];
    sub_1000D973C((uint64_t)&v50);
    v21 = SHIBYTE(v48);
    a2[1] = v20;
    if (v21 < 0)
      operator delete(__p[0]);
  }
  else
  {
    v12 = *(_OWORD *)__p;
    *(_QWORD *)(v11 + 16) = v48;
    *(_OWORD *)v11 = v12;
    a2[1] = v11 + 24;
  }
  snprintf(__str, 5uLL, "_%cxf", v3 + 97);
  v22 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v22, 4u, "%s::%s: %s\n", v23, v24, v25, v26, v27, (char)"ACFUFTABFile");
  sub_1000CB3F4(__p, __str);
  v29 = a2[1];
  v28 = a2[2];
  if (v29 >= v28)
  {
    v31 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v29 - *a2) >> 3);
    v32 = v31 + 1;
    if (v31 + 1 > 0xAAAAAAAAAAAAAAALL)
      sub_1000CB780();
    v33 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v28 - *a2) >> 3);
    if (2 * v33 > v32)
      v32 = 2 * v33;
    if (v33 >= 0x555555555555555)
      v34 = 0xAAAAAAAAAAAAAAALL;
    else
      v34 = v32;
    v54 = a2 + 2;
    if (v34)
      v35 = (char *)sub_1000D95E4((uint64_t)(a2 + 2), v34);
    else
      v35 = 0;
    v36 = &v35[24 * v31];
    v50 = v35;
    v51 = v36;
    v53 = &v35[24 * v34];
    v37 = *(_OWORD *)__p;
    *((_QWORD *)v36 + 2) = v48;
    *(_OWORD *)v36 = v37;
    __p[1] = 0;
    v48 = 0;
    __p[0] = 0;
    v52 = v36 + 24;
    sub_1000D9570(a2, &v50);
    v38 = a2[1];
    sub_1000D973C((uint64_t)&v50);
    v39 = SHIBYTE(v48);
    a2[1] = v38;
    if (v39 < 0)
      operator delete(__p[0]);
  }
  else
  {
    v30 = *(_OWORD *)__p;
    *(_QWORD *)(v29 + 16) = v48;
    *(_OWORD *)v29 = v30;
    a2[1] = v29 + 24;
  }
}

void sub_1000D4A64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, uint64_t a18, char a19)
{
  sub_1000D973C((uint64_t)&a19);
  if (a17 < 0)
    operator delete(__p);
  sub_1000D8BA4((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D4AB4(uint64_t a1, const __CFData *a2)
{
  return sub_1000D4ABC(a1, a2, 0);
}

uint64_t sub_1000D4ABC(uint64_t a1, CFDataRef theData, CFDataRef *a3)
{
  uint64_t v6;
  const __CFData *v7;
  int v8;
  CFIndex Length;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  CFIndex v17;
  CFIndex v18;
  int v19;
  int v20;
  uint64_t v21;
  BOOL v22;
  CFIndex v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const UInt8 *BytePtr;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  CFRange v80;

  if (!a3)
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (!v6)
    {
      v68 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v68, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v69, v70, v71, v72, v73, (char)"ACFUFTABFile");
      return 0;
    }
    if (sub_1000CEE04(v6))
    {
      v74 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v74, 2u, "%s::%s: function cannot directly manipulate file data with optimized flow\n", v75, v76, v77, v78, v79, (char)"ACFUFTABFile");
      return 0;
    }
  }
  if (!theData)
  {
    v38 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v38, 2u, "%s::%s: no manifest input provided\n", v39, v40, v41, v42, v43, (char)"ACFUFTABFile");
    return 0;
  }
  if (CFDataGetLength(theData) <= 0)
  {
    v44 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v44, 2u, "%s::%s: manifest data has no bytes\n", v45, v46, v47, v48, v49, (char)"ACFUFTABFile");
    return 0;
  }
  if (a3)
  {
    if (!*a3)
    {
      v50 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v50, 2u, "%s::%s: firmware data container is invalid\n", v51, v52, v53, v54, v55, (char)"ACFUFTABFile");
      return 0;
    }
    if ((sub_1000D4E68(a1, *a3, 0) & 1) == 0)
    {
      v56 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v56, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v57, v58, v59, v60, v61, (char)"ACFUFTABFile");
      return 0;
    }
    if (*(_DWORD *)(a1 + 64) != 1)
    {
      v7 = *a3;
      if (*a3)
        goto LABEL_11;
LABEL_21:
      v32 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v32, 2u, "%s::%s: could not obtain file data\n", v33, v34, v35, v36, v37, (char)"ACFUFTABFile");
      return 0;
    }
    return sub_1000D5370(a1, theData, 0);
  }
  if (*(_DWORD *)(a1 + 64) == 1)
    return sub_1000D5370(a1, theData, 0);
  v7 = (const __CFData *)sub_1000CEDB0(*(_BYTE **)(a1 + 8));
  if (!v7)
    goto LABEL_21;
LABEL_11:
  v8 = *((_DWORD *)CFDataGetBytePtr(v7) + 10);
  Length = CFDataGetLength(theData);
  if (*((_DWORD *)CFDataGetBytePtr(v7) + 5))
  {
    v10 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v10, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v11, v12, v13, v14, v15, (char)"ACFUFTABFile");
    sub_1000D5A08(v16, v7);
    v17 = *((unsigned int *)CFDataGetBytePtr(v7) + 4);
    v80.length = *((unsigned int *)CFDataGetBytePtr(v7) + 5);
    v80.location = v17;
    CFDataDeleteBytes(v7, v80);
    *((_DWORD *)CFDataGetBytePtr(v7) + 4) = 0;
    *((_DWORD *)CFDataGetBytePtr(v7) + 5) = 0;
  }
  v18 = CFDataGetLength(v7);
  v19 = v8 - 1;
  v20 = *(_DWORD *)&CFDataGetBytePtr(v7)[16 * v19 + 52];
  v21 = ((*(_DWORD *)&CFDataGetBytePtr(v7)[16 * v19 + 56] + v20) + 3) & 0x1FFFFFFFCLL;
  v22 = __OFSUB__(v21, v18);
  v23 = v21 - v18;
  if (v23 < 0 != v22)
  {
    v62 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v62, 2u, "%s::%s: something went wrong, extra bytes in file\n", v63, v64, v65, v66, v67, (char)"ACFUFTABFile");
  }
  else
  {
    if (!((v23 < 0) ^ v22 | (v23 == 0)))
    {
      v24 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v24, 0, "%s::%s: padding %ld byte(s) at the end of ftab\n", v25, v26, v27, v28, v29, (char)"ACFUFTABFile");
      CFDataIncreaseLength(v7, v23);
    }
    *((_DWORD *)CFDataGetBytePtr(v7) + 5) = Length;
    *((_DWORD *)CFDataGetBytePtr(v7) + 4) = v21;
    BytePtr = CFDataGetBytePtr(theData);
    CFDataAppendBytes(v7, BytePtr, Length);
    if (a3)
      return sub_1000D4E68(a1, *a3, 0);
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1))
      return sub_1000D5BDC(a1);
  }
  return 0;
}

uint64_t sub_1000D4E68(uint64_t a1, CFDataRef theData, char a3)
{
  __CFData *v6;
  uint64_t v7;
  uint64_t *v8;
  __CFData *v9;
  const UInt8 *BytePtr;
  const UInt8 *v11;
  __CFData *v12;
  __CFData *v13;
  const UInt8 *v14;
  const UInt8 *v15;
  const UInt8 *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  const UInt8 *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  const UInt8 *v24;
  const UInt8 *v25;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  __CFData *v30;
  __CFData *v31;
  const UInt8 *v32;
  const UInt8 *v33;
  unint64_t v34;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  void *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  void *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  const char *v109;
  void *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  __CFData *cf;

  v6 = theData;
  if (!theData)
  {
    v8 = (uint64_t *)(a1 + 8);
    v7 = *(_QWORD *)(a1 + 8);
    if (!v7)
    {
      v6 = 0;
      v109 = "%s::%s: no file data?!\n";
      goto LABEL_69;
    }
    if (sub_1000CEE04(v7))
    {
      if ((a3 & 1) != 0)
      {
        v6 = 0;
        v109 = "%s::%s: header only validation unsupported with optimized data\n";
        goto LABEL_69;
      }
      v9 = sub_1000CE5BC(*v8, 0, 0x30uLL);
      v6 = v9;
      if (v9)
      {
        BytePtr = CFDataGetBytePtr(v9);
        if (!BytePtr)
        {
LABEL_68:
          v109 = "%s::%s: failed to get byte pointer\n";
          goto LABEL_69;
        }
        v11 = BytePtr;
        v12 = sub_1000CE5BC(*v8, 16 * *((_DWORD *)BytePtr + 10) + 32, 0x10uLL);
        if (v12)
        {
          v13 = v12;
          v14 = CFDataGetBytePtr(v12);
          if (v14)
          {
            v15 = &v11[*((unsigned int *)v14 + 1) + *((unsigned int *)v14 + 2)];
            CFRelease(v13);
            v16 = v11;
            goto LABEL_12;
          }
          CFRelease(v13);
          goto LABEL_68;
        }
        v109 = "%s::%s: failed to aquire ftab file header\n";
LABEL_69:
        v110 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v110, 2u, v109, v111, v112, v113, v114, v115, (char)"ACFUFTABFile");
        sub_1000CEE60(v8, 0);
        goto LABEL_61;
      }
LABEL_64:
      v109 = "%s::%s: failed to copy ftab header\n";
      goto LABEL_69;
    }
    v6 = sub_1000CE410(*v8);
    if (!v6)
      goto LABEL_64;
  }
  v11 = CFDataGetBytePtr(v6);
  v16 = CFDataGetBytePtr(v6);
  v15 = &v16[CFDataGetLength(v6)];
LABEL_12:
  if ((unint64_t)(v15 - v16) <= 0x30)
  {
    v73 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v73, 2u, "%s::%s: file is smaller than the ftab header size\n", v74, v75, v76, v77, v78, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  v17 = *((unsigned int *)v11 + 10);
  v18 = (unint64_t)&v16[16 * v17 + 48];
  if (v18 > (unint64_t)v15)
  {
    v79 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v79, 2u, "%s::%s: header is bigger than the file\n", v80, v81, v82, v83, v84, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  v19 = *((unsigned int *)v11 + 5);
  v20 = &v16[*((unsigned int *)v11 + 4)];
  if ((a3 & 1) == 0 && &v20[v19] > v15)
  {
    v85 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v85, 2u, "%s::%s: manifest present beyond the bounds of the file data\n", v86, v87, v88, v89, v90, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  if (*((_QWORD *)v11 + 4) != 0x62617466736F6B72)
  {
    v91 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v91, 2u, "%s::%s: invalid FTAB file\n", v92, v93, v94, v95, v96, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  if ((v17 - 1) >= 0x4F)
  {
    v97 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v97, 2u, "%s::%s: too many files specified or there are no files. Limit is %d. Num Files: %d\n", v98, v99, v100, v101, v102, (char)"ACFUFTABFile");
    goto LABEL_58;
  }
  if ((_DWORD)v19 && (unint64_t)v20 < v18)
  {
    v103 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v103, 2u, "%s::%s: manifest present in space allocated for header\n", v104, v105, v106, v107, v108, (char)"ACFUFTABFile");
LABEL_58:
    v31 = 0;
    if (theData)
      return 0;
    goto LABEL_59;
  }
  cf = v6;
  if (theData)
  {
    v21 = 0;
    v22 = 0;
    while (1)
    {
      v23 = *(unsigned int *)&CFDataGetBytePtr(theData)[v21 + 52];
      v24 = CFDataGetBytePtr(theData);
      if ((a3 & 1) == 0)
      {
        v25 = &v16[v23 + *(unsigned int *)&v24[v21 + 56]];
        if (v25 > v15 || (unint64_t)v25 < v18)
        {
          v61 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v61, 2u, "%s::%s: Payload is out of valid range\n", v62, v63, v64, v65, v66, (char)"ACFUFTABFile");
          goto LABEL_49;
        }
      }
      if ((unint64_t)&v16[*(unsigned int *)&CFDataGetBytePtr(theData)[v21 + 52]] < v18)
        break;
      ++v22;
      v21 += 16;
      if (v22 >= *((unsigned int *)v11 + 10))
        return 1;
    }
    v37 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v37, 2u, "%s::%s: File indicated is within header space\n", v38, v39, v40, v41, v42, (char)"ACFUFTABFile");
LABEL_49:
    v31 = 0;
LABEL_50:
    v6 = cf;
    if (theData)
      return 0;
LABEL_59:
    sub_1000CEE60((uint64_t *)(a1 + 8), 0);
    if (v31)
      CFRelease(v31);
LABEL_61:
    v27 = 0;
    if (!v6)
      return v27;
    goto LABEL_43;
  }
  v28 = 0;
  v29 = 48;
  do
  {
    v30 = sub_1000CE5BC(*(_QWORD *)(a1 + 8), v29, 0x10uLL);
    v31 = v30;
    if (!v30)
    {
      v43 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v43, 2u, "%s::%s: failed to acquire ftab file header\n", v44, v45, v46, v47, v48, (char)"ACFUFTABFile");
      goto LABEL_50;
    }
    v32 = CFDataGetBytePtr(v30);
    if (!v32)
    {
      v49 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v49, 2u, "%s::%s: failed to acquire cf data byte pointer\n", v50, v51, v52, v53, v54, (char)"ACFUFTABFile");
      goto LABEL_50;
    }
    v33 = &v16[*((unsigned int *)v32 + 1)];
    if ((a3 & 1) == 0)
    {
      v34 = (unint64_t)&v33[*((unsigned int *)v32 + 2)];
      if (v34 > (unint64_t)v15 || v34 < v18)
      {
        v67 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v67, 2u, "%s::%s: payload is out of valid range\n", v68, v69, v70, v71, v72, (char)"ACFUFTABFile");
        goto LABEL_50;
      }
    }
    if ((unint64_t)v33 < v18)
    {
      v55 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v55, 2u, "%s::%s: file indicated is within header space\n", v56, v57, v58, v59, v60, (char)"ACFUFTABFile");
      goto LABEL_50;
    }
    CFRelease(v31);
    ++v28;
    v29 += 16;
  }
  while (v28 < *((_DWORD *)v11 + 10));
  v27 = 1;
  v6 = cf;
  if (!cf)
    return v27;
LABEL_43:
  CFRelease(v6);
  return v27;
}

uint64_t sub_1000D5370(uint64_t a1, const __CFData *a2, CFDataRef *a3)
{
  const __CFData *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  CFIndex v16;
  uint64_t v17;
  int v18;
  const UInt8 *BytePtr;
  CFMutableDataRef Mutable;
  int v21;
  unsigned int v22;
  unsigned int v23;
  int Length;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  CFIndex v33;
  CFIndex v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  CFIndex v50;
  int v51;
  const UInt8 *v52;
  const UInt8 *v53;
  const UInt8 *v54;
  int v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __CFData *v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const UInt8 *v72;
  const UInt8 *v73;
  const UInt8 *v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const UInt8 *v81;
  const UInt8 *v82;
  void *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  const __CFData *v89;
  uint64_t v90;
  uint64_t v91;
  void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  void *v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  void *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  void *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  void *v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  void *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  CFIndex v129;
  CFIndex v130;
  uint64_t v131;
  unsigned int v132;
  int v133;
  unsigned int v134;
  const UInt8 *v135;
  uint64_t v136;
  uint64_t v137;
  const __CFData *theData;
  __CFData *v139;
  uint64_t *v140;
  void *v141;
  char v142;
  CFRange v143;

  if (!a3)
  {
    v64 = *(_QWORD *)(a1 + 8);
    if (!v64)
    {
      v117 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v117, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v118, v119, v120, v121, v122, (char)"ACFUFTABFile");
      return 0;
    }
    if (sub_1000CEE04(v64))
    {
      v123 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v123, 2u, "%s::%s: function cannot directly manipulate file data with optimized flow\n", v124, v125, v126, v127, v128, (char)"ACFUFTABFile");
      return 0;
    }
    v6 = (const __CFData *)sub_1000CEDB0(*(_BYTE **)(a1 + 8));
    if (v6)
      goto LABEL_5;
LABEL_25:
    v65 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v65, 2u, "%s::%s: could not obtain file data\n", v66, v67, v68, v69, v70, (char)"ACFUFTABFile");
    return 0;
  }
  if (!*a3)
  {
    v98 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v98, 2u, "%s::%s: firmware data container is invalid\n", v99, v100, v101, v102, v103, (char)"ACFUFTABFile");
    return 0;
  }
  if ((sub_1000D4E68(a1, *a3, 0) & 1) == 0)
  {
    v104 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v104, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v105, v106, v107, v108, v109, (char)"ACFUFTABFile");
    return 0;
  }
  v6 = *a3;
  if (!*a3)
    goto LABEL_25;
LABEL_5:
  v7 = *((unsigned int *)CFDataGetBytePtr(v6) + 10);
  if (*((_DWORD *)CFDataGetBytePtr(v6) + 5))
  {
    v8 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v8, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v9, v10, v11, v12, v13, (char)"ACFUFTABFile");
    v15 = sub_1000D5A08(v14, v6);
    v16 = *((unsigned int *)CFDataGetBytePtr(v6) + 4);
    v143.length = *((unsigned int *)CFDataGetBytePtr(v6) + 5);
    v143.location = v16;
    CFDataDeleteBytes(v6, v143);
    if (v15 && (_DWORD)v7)
    {
      v17 = 0;
      do
      {
        v18 = *((_DWORD *)CFDataGetBytePtr(v6) + 5);
        BytePtr = CFDataGetBytePtr(v6);
        *(_DWORD *)&BytePtr[v17 + 52] -= v18;
        v17 += 16;
      }
      while (16 * v7 != v17);
    }
    *((_DWORD *)CFDataGetBytePtr(v6) + 4) = 0;
    *((_DWORD *)CFDataGetBytePtr(v6) + 5) = 0;
  }
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    v92 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v92, 2u, "%s::%s: could not allocate data\n", v93, v94, v95, v96, v97, (char)"ACFUFTABFile");
    return 0;
  }
  v139 = Mutable;
  v140 = (uint64_t *)a1;
  v135 = CFDataGetBytePtr(v6);
  v131 = *((unsigned int *)CFDataGetBytePtr(v6) + 13);
  v137 = *(unsigned int *)&CFDataGetBytePtr(v6)[16 * (v7 - 1) + 52];
  v136 = *(unsigned int *)&CFDataGetBytePtr(v6)[16 * (v7 - 1) + 56];
  v21 = *((_DWORD *)CFDataGetBytePtr(v6) + 13);
  v22 = ((v21 + 3) & 0xFFFFFFFC) - v21;
  v23 = v22 + *((_DWORD *)CFDataGetBytePtr(v6) + 13);
  *((_DWORD *)CFDataGetBytePtr(v6) + 4) = v23;
  theData = a2;
  Length = CFDataGetLength(a2);
  *((_DWORD *)CFDataGetBytePtr(v6) + 5) = Length;
  v25 = sub_1000D3C90();
  CFDataGetBytePtr(v6);
  CFDataGetBytePtr(v6);
  sub_1000D3D08((uint64_t)v25, 0, "%s::%s: manifestOffset: %u, manifestSize: %u\n", v26, v27, v28, v29, v30, (char)"ACFUFTABFile");
  v31 = *((_DWORD *)CFDataGetBytePtr(v6) + 4);
  v32 = *((_DWORD *)CFDataGetBytePtr(v6) + 5) + v31;
  v33 = v22;
  v34 = ((v32 + 3) & 0xFFFFFFFC) - v32;
  v35 = sub_1000D3C90();
  v133 = v21;
  v134 = (v21 + 3) & 0xFFFFFFFC;
  sub_1000D3D08((uint64_t)v35, 0, "%s::%s: startOfManifestUnaligned: %ld, startOfManifestAligned: %ld, paddingBeforeManifestStart: %u\n", v36, v37, v38, v39, v40, (char)"ACFUFTABFile");
  v41 = sub_1000D3C90();
  v132 = (v32 + 3) & 0xFFFFFFFC;
  v42 = v32;
  sub_1000D3D08((uint64_t)v41, 0, "%s::%s: endOfManifestUnaligned: %ld, endOfManifestAligned: %ld, paddingAfterManifestEnd: %u\n", v43, v44, v45, v46, v47, (char)"ACFUFTABFile");
  if ((_DWORD)v7)
  {
    v48 = 0;
    v129 = ((v32 + 3) & 0xFFFFFFFC) - v32;
    v130 = v33;
    v49 = v129 + v33;
    v50 = 16 * v7;
    while (1)
    {
      v51 = *((_DWORD *)CFDataGetBytePtr(v6) + 5);
      v52 = CFDataGetBytePtr(v6);
      *(_DWORD *)&v52[v48 + 52] += v49 + v51;
      if (!a3)
      {
        v53 = CFDataGetBytePtr(v6);
        v142 = 4;
        LODWORD(v141) = *(_DWORD *)&v53[v48 + 48];
        BYTE4(v141) = 0;
        v54 = CFDataGetBytePtr(v6);
        v55 = sub_1000D5EF8(a1, (uint64_t)&v141, *(_DWORD *)&v54[v48 + 52], 0);
        if ((v55 & 1) == 0)
        {
          v56 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v56, 2u, "%s::%s: failed to update cache\n", v57, v58, v59, v60, v61, (char)"ACFUFTABFile");
        }
        if (v142 < 0)
          operator delete(v141);
        if (!v55)
          break;
      }
      v48 += 16;
      if (v50 == v48)
      {
        v62 = v139;
        v33 = v130;
        v63 = v131;
        v34 = v129;
        goto LABEL_27;
      }
    }
    v91 = 0;
    v62 = v139;
    goto LABEL_46;
  }
  v50 = 0;
  v62 = v139;
  v63 = v131;
LABEL_27:
  v71 = v63;
  v72 = &v135[v63];
  v73 = CFDataGetBytePtr(v6);
  CFDataAppendBytes(v62, v73, 48);
  v74 = CFDataGetBytePtr(v6);
  CFDataAppendBytes(v62, v74 + 48, v50);
  if (v134 != v133)
  {
    v75 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v75, 0, "%s::%s: paddingBeforeManifestStart %u bytes\n", v76, v77, v78, v79, v80, (char)"ACFUFTABFile");
    CFDataIncreaseLength(v62, v33);
  }
  v81 = CFDataGetBytePtr(theData);
  v82 = CFDataGetBytePtr(v6);
  CFDataAppendBytes(v62, v81, *((unsigned int *)v82 + 5));
  if (v132 != v42)
  {
    v83 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v83, 0, "%s::%s: paddingAfterManifestEnd %u bytes\n", v84, v85, v86, v87, v88, (char)"ACFUFTABFile");
    CFDataIncreaseLength(v62, v34);
  }
  CFDataAppendBytes(v62, v72, v137 - v71 + v136);
  if (!a3)
  {
    if (sub_1000CEC34(v140[1], (uint64_t)v62)
      && (*(unsigned int (**)(uint64_t *))(*v140 + 88))(v140))
    {
      v90 = sub_1000D5BDC((uint64_t)v140);
      goto LABEL_36;
    }
LABEL_45:
    v91 = 0;
    goto LABEL_46;
  }
  if (*a3)
  {
    CFRelease(*a3);
    *a3 = 0;
  }
  v89 = (const __CFData *)AMSupportSafeRetain(v62);
  *a3 = v89;
  if (!v89)
  {
    v110 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v110, 2u, "%s::%s: failed obtain new file data\n", v111, v112, v113, v114, v115, (char)"ACFUFTABFile");
    goto LABEL_45;
  }
  v90 = sub_1000D4E68((uint64_t)v140, v89, 0);
LABEL_36:
  v91 = v90;
LABEL_46:
  CFRelease(v62);
  return v91;
}

void sub_1000D59EC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 89) < 0)
    operator delete(*(void **)(v1 - 112));
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D5A08(int a1, CFDataRef theData)
{
  int v3;
  const UInt8 *v4;
  unsigned int v5;
  unsigned int v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  const UInt8 *v15;
  uint64_t result;
  int v17;
  int v18;
  CFIndex v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const UInt8 *BytePtr;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFRange v33;
  CFRange v34;

  if (theData && (v3 = *((_DWORD *)CFDataGetBytePtr(theData) + 5), v4 = CFDataGetBytePtr(theData), v3))
  {
    v5 = *((_DWORD *)v4 + 4);
    if (v5 >= *((_DWORD *)CFDataGetBytePtr(theData) + 13))
    {
      v17 = *((_DWORD *)CFDataGetBytePtr(theData) + 10) - 1;
      v18 = *(_DWORD *)&CFDataGetBytePtr(theData)[16 * v17 + 52];
      v19 = (*(_DWORD *)&CFDataGetBytePtr(theData)[16 * v17 + 56] + v18);
      v20 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v20, 0, "%s::%s: manifest at the end - startOfManifest: %u, endOfFiles: %u, padding: %u\n", v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
      v34.location = v19;
      v34.length = v5 - v19;
      CFDataDeleteBytes(theData, v34);
      BytePtr = CFDataGetBytePtr(theData);
      result = 0;
      *((_DWORD *)BytePtr + 4) = v19;
    }
    else
    {
      v6 = *((_DWORD *)CFDataGetBytePtr(theData) + 13) - (v5 + v3);
      v7 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v7, 0, "%s::%s: manifest is at top - endOfManifest: %u, startOfFiles: %u, paddingAfterManifestEnd: %u\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
      v33.location = (*((_DWORD *)CFDataGetBytePtr(theData) + 4) + v3);
      v33.length = v6;
      CFDataDeleteBytes(theData, v33);
      if (*((_DWORD *)CFDataGetBytePtr(theData) + 10))
      {
        v13 = 0;
        v14 = 52;
        do
        {
          v15 = CFDataGetBytePtr(theData);
          *(_DWORD *)&v15[v14] -= v6;
          ++v13;
          v14 += 16;
        }
        while (v13 < *((unsigned int *)CFDataGetBytePtr(theData) + 10));
      }
      return 1;
    }
  }
  else
  {
    v27 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v27, 2u, "%s::%s: no manifest preset in dataref\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
    return 0;
  }
  return result;
}

BOOL sub_1000D5BDC(uint64_t a1)
{
  uint64_t v2;
  __CFData *v3;
  __CFData *v4;
  const UInt8 *BytePtr;
  uint64_t v6;
  BOOL v7;
  int v8;
  unsigned int v9;
  __CFData *v10;
  const UInt8 *v11;
  uint64_t v12;
  char v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *__p;
  char v59;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
  {
    v34 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v34, 2u, "%s::%s: no file data?!\n", v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
    return 0;
  }
  v3 = sub_1000CE5BC(v2, 0, 0x30uLL);
  if (!v3)
  {
    v40 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v40, 2u, "%s::%s: failed to copy ftab header\n", v41, v42, v43, v44, v45, (char)"ACFUFTABFile");
    return 0;
  }
  v4 = v3;
  BytePtr = CFDataGetBytePtr(v3);
  if (!BytePtr)
  {
    v46 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v46, 2u, "%s::%s: failed to copy ftab header\n", v47, v48, v49, v50, v51, (char)"ACFUFTABFile");
    v7 = 0;
    goto LABEL_23;
  }
  v6 = *((unsigned int *)BytePtr + 10);
  CFRelease(v4);
  if (*(_QWORD *)(a1 + 56) != v6)
  {
    v52 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v52, 2u, "%s::%s: number of files in cache is invalid\n", v53, v54, v55, v56, v57, (char)"ACFUFTABFile");
    return 0;
  }
  if (!(_DWORD)v6)
    return 1;
  v7 = 0;
  v8 = 0;
  v9 = 48;
  do
  {
    v10 = sub_1000CE5BC(*(_QWORD *)(a1 + 8), v9, 0x10uLL);
    if (!v10)
    {
      v28 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: failed to copy ftab file header\n", v29, v30, v31, v32, v33, (char)"ACFUFTABFile");
      return 0;
    }
    v4 = v10;
    v11 = CFDataGetBytePtr(v10);
    v59 = 4;
    LODWORD(__p) = *(_DWORD *)v11;
    BYTE4(__p) = 0;
    v12 = sub_1000D8F34(a1 + 40, (const void **)&__p);
    if (a1 + 48 == v12)
    {
      v14 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: cache does not have entry for file %s. Cache is invalid\n", v15, v16, v17, v18, v19, (char)"ACFUFTABFile");
    }
    else
    {
      if (*(_DWORD *)(v12 + 60) == *((_DWORD *)v11 + 1))
      {
        if (*(_DWORD *)(v12 + 56) == *((_DWORD *)v11 + 2))
        {
          CFRelease(v4);
          v4 = 0;
          v13 = 1;
          goto LABEL_12;
        }
        v20 = sub_1000D3C90();
        v26 = "%s::%s: cache does not hold correct size for file %s. Cache size: %d. FTAB size: %d. Cache is invalid\n";
      }
      else
      {
        v20 = sub_1000D3C90();
        v26 = "%s::%s: cache does not hold correct offset for file %s. Cache offset: %d. FTAB offset: %d. Cache is invalid\n";
      }
      sub_1000D3D08((uint64_t)v20, 2u, v26, v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
    }
    v13 = 0;
LABEL_12:
    if (v59 < 0)
      operator delete(__p);
    if ((v13 & 1) == 0)
      break;
    v7 = ++v8 >= v6;
    v9 += 16;
  }
  while ((_DWORD)v6 != v8);
  if (!v4)
    return v7;
LABEL_23:
  CFRelease(v4);
  return v7;
}

void sub_1000D5ED8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D5EF8(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t **v19;
  const void **v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  __int128 *v40;

  v8 = (uint64_t **)(a1 + 40);
  v9 = sub_1000D8F34(a1 + 40, (const void **)a2);
  v10 = *(unsigned __int8 *)(a2 + 23);
  if ((v10 & 0x80u) != 0)
    v10 = *(_QWORD *)(a2 + 8);
  if (v10 == 4)
  {
    v11 = v9;
    v12 = a1 + 48;
    if (!(a4 | a3))
    {
      v21 = sub_1000D3C90();
      if (v12 == v11)
      {
        sub_1000D3D08((uint64_t)v21, 4u, "%s::%s: attempting to delete file from cache that does not exist. File: %s\n", v22, v23, v24, v25, v26, (char)"ACFUFTABFile");
      }
      else
      {
        sub_1000D3D08((uint64_t)v21, 4u, "%s::%s: removing file from FTAB cache. File: %s\n", v22, v23, v24, v25, v26, (char)"ACFUFTABFile");
        sub_1000D8FC0(v8, (const void **)a2);
      }
      return 1;
    }
    if (v12 != v9)
    {
      v13 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v13, 4u, "%s::%s: ftab cache entry updated. File: %s, offset: %u, size: %u\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
      if (a3)
      {
        v40 = (__int128 *)a2;
        *((_DWORD *)sub_1000D9438(v8, (const void **)a2, (uint64_t)&unk_100167457, &v40) + 15) = a3;
      }
      if (!a4)
        return 1;
      v40 = (__int128 *)a2;
      v19 = v8;
      v20 = (const void **)a2;
      goto LABEL_15;
    }
    v27 = sub_1000D3C90();
    if (a3 && a4)
    {
      sub_1000D3D08((uint64_t)v27, 4u, "%s::%s: Adding new file to FTAB cache. File: %s, offset: %u, size: %u\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
      v40 = (__int128 *)a2;
      *((_DWORD *)sub_1000D9438(v8, (const void **)a2, (uint64_t)&unk_100167457, &v40) + 15) = a3;
      v40 = (__int128 *)a2;
      v19 = v8;
      v20 = (const void **)a2;
LABEL_15:
      *((_DWORD *)sub_1000D9438(v19, v20, (uint64_t)&unk_100167457, &v40) + 14) = a4;
      return 1;
    }
    sub_1000D3D08((uint64_t)v27, 2u, "%s::%s: attempting to add new file to cache, but not both size and offset are provided. File: %s\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
  }
  else
  {
    v34 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v34, 2u, "%s::%s: specified tag name is invalid! Tag name: %s\n", v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
  }
  return 0;
}

void sub_1000D6188(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  __CFData *v5;
  __CFData *v6;
  const UInt8 *BytePtr;
  unint64_t v8;
  unsigned int v9;
  __CFData *v10;
  __CFData *v11;
  int v12;
  const char *v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v4 = *(_QWORD *)(a1 + 8);
  if (!v4)
  {
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: file data was invalid\n", v15, v16, v17, v18, v19, (char)"ACFUFTABFile");
LABEL_13:
    v11 = 0;
    v12 = 1;
    goto LABEL_9;
  }
  v5 = sub_1000CE5BC(v4, 0, 0x30uLL);
  if (!v5)
  {
    v20 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: failed to copy ftab header\n", v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
    goto LABEL_13;
  }
  v6 = v5;
  BytePtr = CFDataGetBytePtr(v5);
  if (!BytePtr)
  {
    v12 = 1;
    v13 = "%s::%s: failed to copy ftab header\n";
    goto LABEL_16;
  }
  v8 = *((unsigned int *)BytePtr + 5);
  if (!(_DWORD)v8 || (v9 = *((_DWORD *)BytePtr + 4)) == 0)
  {
    v12 = 1001;
    v13 = "%s::%s: no manifest found in ftab\n";
LABEL_16:
    v26 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v26, 2u, v13, v27, v28, v29, v30, v31, (char)"ACFUFTABFile");
    v11 = 0;
    goto LABEL_8;
  }
  v10 = sub_1000CE5BC(*(_QWORD *)(a1 + 8), v9, v8);
  if (!v10)
  {
    v12 = 4000;
    v13 = "%s::%s: failed to create manifest data output\n";
    goto LABEL_16;
  }
  v11 = v10;
  v12 = 0;
LABEL_8:
  CFRelease(v6);
LABEL_9:
  *(_QWORD *)a2 = v11;
  *(_DWORD *)(a2 + 8) = v12;
}

uint64_t sub_1000D62C0(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  const __CFData *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    if (sub_1000CEE04(v3))
    {
      v19 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: function is not supported in memory optimized flow. Memory optimized files are read only\n", v20, v21, v22, v23, v24, (char)"ACFUFTABFile");
    }
    else
    {
      v5 = (const __CFData *)sub_1000CEDB0(*(_BYTE **)(a1 + 8));
      if (v5)
      {
        *((_QWORD *)CFDataGetBytePtr(v5) + 1) = a2;
        v6 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v6, 0, "%s::%s: Boot nonce set for FTAB. Boot nonce value: %llu\n", v7, v8, v9, v10, v11, (char)"ACFUFTABFile");
        return 1;
      }
      v25 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v25, 2u, "%s::%s: could not obtain file data\n", v26, v27, v28, v29, v30, (char)"ACFUFTABFile");
    }
  }
  else
  {
    v13 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: file data was invalid\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
  }
  return 0;
}

uint64_t sub_1000D63B4(uint64_t a1)
{
  uint64_t v1;
  __CFData *v2;
  __CFData *v3;
  const UInt8 *BytePtr;
  uint64_t v5;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v1 = *(_QWORD *)(a1 + 8);
  if (!v1)
  {
    v7 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v7, 2u, "%s::%s: file data was invalid\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
    return 0;
  }
  v2 = sub_1000CE5BC(v1, 0, 0x30uLL);
  if (!v2)
  {
    v13 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: failed to copy ftab header\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
    return 0;
  }
  v3 = v2;
  BytePtr = CFDataGetBytePtr(v2);
  if (BytePtr)
  {
    v5 = *((_QWORD *)BytePtr + 1);
  }
  else
  {
    v19 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: failed to copy ftab header\n", v20, v21, v22, v23, v24, (char)"ACFUFTABFile");
    v5 = 0;
  }
  CFRelease(v3);
  return v5;
}

uint64_t sub_1000D648C(uint64_t a1, _QWORD *a2, const __CFData *a3)
{
  return sub_1000D6494(a1, a2, a3, 0);
}

uint64_t sub_1000D6494(uint64_t a1, _QWORD *a2, CFDataRef theData, CFDataRef *a4)
{
  uint64_t v7;
  uint64_t v8;
  const __CFData *v9;
  CFMutableDataRef Mutable;
  const UInt8 *BytePtr;
  const UInt8 *v12;
  const UInt8 *v13;
  const UInt8 *v14;
  char v15;
  const char *v16;
  size_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  const UInt8 *v26;
  uint64_t v27;
  const UInt8 *v28;
  CFDataRef v29;
  CFIndex v30;
  const UInt8 *v31;
  uint64_t v32;
  const UInt8 *v33;
  uint64_t **v34;
  uint64_t v35;
  unint64_t v36;
  const UInt8 *v37;
  const UInt8 *v38;
  const UInt8 *v39;
  int v40;
  int v41;
  const UInt8 *v42;
  const UInt8 *v43;
  const UInt8 *v44;
  int v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const UInt8 *v58;
  int v59;
  const UInt8 *v60;
  const UInt8 *v61;
  const UInt8 *v62;
  const UInt8 *v63;
  const UInt8 *v64;
  const UInt8 *v65;
  CFIndex v66;
  const __CFData *v67;
  uint64_t v68;
  const __CFData *v69;
  char v70;
  void *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  void *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  void *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  void *v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  void *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  void *v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  void *v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  void *v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const __CFData *v162;
  const __CFData *v163;
  __CFData *theDataa;
  const UInt8 *v165;
  const UInt8 *v166;
  void *__p[2];
  char v168;
  char __dst[4];
  int v170;
  int Length;
  int v172;
  CFRange v173;

  v7 = a1;
  if (!a4 && !*(_QWORD *)(a1 + 8))
  {
    v138 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v138, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v139, v140, v141, v142, v143, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if (!theData)
  {
    v78 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v78, 2u, "%s::%s: file data provided is not valid\n", v79, v80, v81, v82, v83, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if (CFDataGetLength(theData) <= 0)
  {
    v84 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v84, 2u, "%s::%s: file data has no bytes\n", v85, v86, v87, v88, v89, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  v8 = *((unsigned __int8 *)a2 + 23);
  if ((v8 & 0x80u) != 0)
    v8 = a2[1];
  if (v8 != 4)
  {
    v90 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v90, 2u, "%s::%s: tag is either larger or smaller than limit %u (size: %lu)\n", v91, v92, v93, v94, v95, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if ((*(unsigned int (**)(uint64_t, _QWORD *))(*(_QWORD *)v7 + 16))(v7, a2))
  {
    v96 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v96, 2u, "%s::%s: cowardly retreating because tag '%s' exists. I refuse to overwrite existing files!\n", v97, v98, v99, v100, v101, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  if (a4)
  {
    if (*a4)
    {
      if ((sub_1000D4E68(v7, *a4, 0) & 1) != 0)
      {
        v9 = *a4;
        if (*a4)
          goto LABEL_13;
LABEL_62:
        v71 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v71, 2u, "%s::%s: could not obtain file data\n", v72, v73, v74, v75, v76, (char)"ACFUFTABFile");
        v67 = 0;
        Mutable = 0;
        goto LABEL_87;
      }
      v114 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v114, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v115, v116, v117, v118, v119, (char)"ACFUFTABFile");
    }
    else
    {
      v108 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v108, 2u, "%s::%s: firmware data container is invalid\n", v109, v110, v111, v112, v113, (char)"ACFUFTABFile");
    }
LABEL_90:
    LOBYTE(v7) = 0;
    return v7 & 1;
  }
  if (sub_1000CEE04(*(_QWORD *)(v7 + 8)))
  {
    v34 = (uint64_t **)(v7 + 72);
    if (!sub_1000D8C30(v7 + 72, (const void **)a2))
    {
      v7 = AMSupportSafeRetain(theData);
      __p[0] = a2;
      sub_1000D8D14(v34, (const void **)a2, (uint64_t)&unk_100167457, (__int128 **)__p)[7] = v7;
      LOBYTE(v7) = 1;
      return v7 & 1;
    }
    v156 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v156, 2u, "%s::%s: cowardly retreating because tag '%s' exists in runtime MMIO File Data. I refuse to overwrite existing files!\n", v157, v158, v159, v160, v161, (char)"ACFUFTABFile");
    goto LABEL_90;
  }
  v9 = (const __CFData *)sub_1000CEDB0(*(_BYTE **)(v7 + 8));
  if (!v9)
    goto LABEL_62;
LABEL_13:
  Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (!Mutable)
  {
    v102 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v102, 2u, "%s::%s: could not allocate data\n", v103, v104, v105, v106, v107, (char)"ACFUFTABFile");
LABEL_81:
    v67 = 0;
    goto LABEL_87;
  }
  BytePtr = CFDataGetBytePtr(v9);
  v166 = &BytePtr[*((unsigned int *)CFDataGetBytePtr(v9) + 13)];
  v12 = CFDataGetBytePtr(v9);
  v13 = &BytePtr[*(unsigned int *)&v12[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 52]];
  v14 = CFDataGetBytePtr(v9);
  v165 = &v13[*(unsigned int *)&v14[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 56]];
  CFDataGetBytePtr(v9);
  v15 = *((_BYTE *)a2 + 23);
  if (v15 >= 0)
    v16 = (const char *)a2;
  else
    v16 = (const char *)*a2;
  if (v15 >= 0)
    v17 = *((unsigned __int8 *)a2 + 23);
  else
    v17 = a2[1];
  strncpy(__dst, v16, v17);
  v162 = theData;
  Length = CFDataGetLength(theData);
  v172 = 0;
  theDataa = Mutable;
  if (!*((_DWORD *)CFDataGetBytePtr(v9) + 5))
  {
    v163 = 0;
    v25 = 0;
    LODWORD(v27) = 0;
    goto LABEL_29;
  }
  v18 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v18, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v19, v20, v21, v22, v23, (char)"ACFUFTABFile");
  v25 = sub_1000D5A08(v24, v9);
  v26 = &BytePtr[*((unsigned int *)CFDataGetBytePtr(v9) + 4)];
  v27 = *((unsigned int *)CFDataGetBytePtr(v9) + 5);
  v28 = CFDataGetBytePtr(v9);
  v29 = CFDataCreate(kCFAllocatorDefault, v26, *((unsigned int *)v28 + 5));
  if (!v29)
  {
    v120 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v120, 2u, "%s::%s: failed to obtain copy of manifest\n", v121, v122, v123, v124, v125, (char)"ACFUFTABFile");
    goto LABEL_81;
  }
  v163 = v29;
  v30 = *((unsigned int *)CFDataGetBytePtr(v9) + 4);
  v173.length = *((unsigned int *)CFDataGetBytePtr(v9) + 5);
  v173.location = v30;
  CFDataDeleteBytes(v9, v173);
  if (v25)
  {
    v166 = &BytePtr[*((unsigned int *)CFDataGetBytePtr(v9) + 13) - v27];
    v31 = CFDataGetBytePtr(v9);
    v32 = *(unsigned int *)&v31[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 52];
    v33 = CFDataGetBytePtr(v9);
    v165 = &BytePtr[v32 - v27 + *(unsigned int *)&v33[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 56]];
  }
  *((_DWORD *)CFDataGetBytePtr(v9) + 5) = 0;
  *((_DWORD *)CFDataGetBytePtr(v9) + 4) = 0;
LABEL_29:
  if (!*((_DWORD *)CFDataGetBytePtr(v9) + 10))
  {
LABEL_48:
    v58 = CFDataGetBytePtr(v9);
    v59 = *(_DWORD *)&v58[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 52];
    v60 = CFDataGetBytePtr(v9);
    v170 = *(_DWORD *)&v60[16 * (*((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1) + 56] + v59;
    v61 = CFDataGetBytePtr(v9);
    ++*((_DWORD *)v61 + 10);
    v62 = CFDataGetBytePtr(v9);
    Mutable = theDataa;
    CFDataAppendBytes(theDataa, v62, 48);
    v63 = CFDataGetBytePtr(v9) + 48;
    v64 = CFDataGetBytePtr(v9);
    CFDataAppendBytes(theDataa, v63, 16 * (*((_DWORD *)v64 + 10) - 1));
    CFDataAppendBytes(theDataa, (const UInt8 *)__dst, 16);
    CFDataAppendBytes(theDataa, v166, v165 - v166);
    v65 = CFDataGetBytePtr(v162);
    v66 = CFDataGetLength(v162);
    CFDataAppendBytes(theDataa, v65, v66);
    if (a4)
    {
      v67 = v163;
      if (*a4)
      {
        CFRelease(*a4);
        *a4 = 0;
      }
      v68 = AMSupportSafeRetain(theDataa);
      *a4 = (CFDataRef)v68;
      if (!v68)
      {
        v126 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v126, 2u, "%s::%s: failed obtain new file data\n", v127, v128, v129, v130, v131, (char)"ACFUFTABFile");
        goto LABEL_87;
      }
      if (!v163)
      {
        v69 = (const __CFData *)v68;
        goto LABEL_66;
      }
      if (sub_1000D4ABC(v7, v163, a4))
      {
        v69 = *a4;
LABEL_66:
        v70 = sub_1000D4E68(v7, v69, 0);
        goto LABEL_67;
      }
      goto LABEL_83;
    }
    v67 = v163;
    if ((sub_1000CEC34(*(_QWORD *)(v7 + 8), (uint64_t)theDataa) & 1) != 0)
    {
      if ((sub_1000D5EF8(v7, (uint64_t)a2, v170, Length) & 1) != 0)
      {
        if (v163 && (sub_1000D4ABC(v7, v163, 0) & 1) == 0)
        {
LABEL_83:
          v132 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v132, 2u, "%s::%s: failed to update manifest\n", v133, v134, v135, v136, v137, (char)"ACFUFTABFile");
          goto LABEL_87;
        }
        if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v7 + 88))(v7))
        {
          v70 = sub_1000D5BDC(v7);
LABEL_67:
          LOBYTE(v7) = v70;
          goto LABEL_68;
        }
      }
      else
      {
        v150 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v150, 2u, "%s::%s: failed to update cache\n", v151, v152, v153, v154, v155, (char)"ACFUFTABFile");
      }
    }
    else
    {
      v144 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v144, 2u, "%s::%s: failed to update file data\n", v145, v146, v147, v148, v149, (char)"ACFUFTABFile");
    }
LABEL_87:
    LOBYTE(v7) = 0;
    if (!Mutable)
    {
LABEL_69:
      if (v67)
        CFRelease(v67);
      return v7 & 1;
    }
LABEL_68:
    CFRelease(Mutable);
    goto LABEL_69;
  }
  v35 = 0;
  v36 = 0;
  while (1)
  {
    v37 = CFDataGetBytePtr(v9);
    *(_DWORD *)&v37[v35 + 52] += 16;
    if (!a4)
    {
      v38 = CFDataGetBytePtr(v9);
      v168 = 4;
      LODWORD(__p[0]) = *(_DWORD *)&v38[v35 + 48];
      BYTE4(__p[0]) = 0;
      v39 = CFDataGetBytePtr(v9);
      v40 = sub_1000D5EF8(v7, (uint64_t)__p, *(_DWORD *)&v39[v35 + 52], 0);
      if ((v40 & 1) != 0)
      {
        v41 = 0;
      }
      else
      {
        v46 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v46, 2u, "%s::%s: failed to update cache\n", v47, v48, v49, v50, v51, (char)"ACFUFTABFile");
        v41 = 4;
      }
      if (v168 < 0)
        operator delete(__p[0]);
      if (!v40)
        break;
    }
    if (v25)
    {
      v42 = CFDataGetBytePtr(v9);
      *(_DWORD *)&v42[v35 + 52] -= v27;
      if (!a4)
      {
        v43 = CFDataGetBytePtr(v9);
        v168 = 4;
        LODWORD(__p[0]) = *(_DWORD *)&v43[v35 + 48];
        BYTE4(__p[0]) = 0;
        v44 = CFDataGetBytePtr(v9);
        v45 = sub_1000D5EF8(v7, (uint64_t)__p, *(_DWORD *)&v44[v35 + 52], 0);
        if ((v45 & 1) != 0)
        {
          v41 = 0;
        }
        else
        {
          v52 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v52, 2u, "%s::%s: failed to update cache\n", v53, v54, v55, v56, v57, (char)"ACFUFTABFile");
          v41 = 4;
        }
        if (v168 < 0)
          operator delete(__p[0]);
        if (!v45)
          break;
      }
    }
    ++v36;
    v35 += 16;
    if (v36 >= *((unsigned int *)CFDataGetBytePtr(v9) + 10))
      goto LABEL_48;
  }
  if ((v41 | 4) == 4)
  {
    LOBYTE(v7) = 0;
    v67 = v163;
    Mutable = theDataa;
    goto LABEL_68;
  }
  return v7 & 1;
}

void sub_1000D6DE0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D6E00(uint64_t a1, unsigned __int8 *a2, CFDataRef theData, CFDataRef *a4)
{
  const __CFData *v5;
  uint64_t v8;
  const __CFData *v9;
  const UInt8 *BytePtr;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const UInt8 *v14;
  int v15;
  unint64_t v16;
  unsigned __int8 *v17;
  size_t v18;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  CFIndex v35;
  const UInt8 *v36;
  char v37;
  const UInt8 *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  const UInt8 *v47;
  const UInt8 *v48;
  CFIndex v49;
  unint64_t v50;
  uint64_t v51;
  int v52;
  const UInt8 *v53;
  unint64_t v54;
  const UInt8 *v55;
  uint64_t v56;
  uint64_t v57;
  __int128 **v58;
  unsigned __int8 *v59;
  CFIndex Length;
  int v61;
  CFIndex v62;
  unint64_t v63;
  uint64_t v64;
  const UInt8 *v65;
  const UInt8 *v66;
  const UInt8 *v67;
  int v68;
  int v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  CFIndex v76;
  unsigned int v77;
  uint64_t v78;
  CFIndex v79;
  CFIndex v80;
  const UInt8 *v81;
  const UInt8 *v82;
  const UInt8 *v83;
  const UInt8 *v84;
  const UInt8 *v85;
  const UInt8 *v86;
  int v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  int v94;
  uint64_t v95;
  const UInt8 *v96;
  int v97;
  int v98;
  int v99;
  uint64_t v100;
  CFIndex v101;
  CFIndex v102;
  const UInt8 *v103;
  CFIndex v104;
  int v105;
  CFIndex v106;
  CFIndex v107;
  const UInt8 *v108;
  CFIndex v109;
  char v110;
  const UInt8 *v111;
  int v112;
  int v113;
  char v114;
  void *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  void *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  void *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  void *v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  void *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  void *v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  void *v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  void *v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  void *v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  void *v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  const __CFData *v194;
  uint64_t v195;
  __int128 *__s2[2];
  char v197;
  CFRange v198;
  CFRange v199;
  CFRange v200;
  CFRange v201;
  CFRange v202;
  CFRange v203;

  v5 = theData;
  if (!a4 && !*(_QWORD *)(a1 + 8))
  {
    v158 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v158, 2u, "%s::%s: file data must be valid or firmware data must be provided\n", v159, v160, v161, v162, v163, (char)"ACFUFTABFile");
    goto LABEL_29;
  }
  if (!theData)
  {
    v116 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v116, 2u, "%s::%s: file data provided is not valid\n", v117, v118, v119, v120, v121, (char)"ACFUFTABFile");
    goto LABEL_30;
  }
  if (CFDataGetLength(theData) <= 0)
  {
    v122 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v122, 2u, "%s::%s: input data has no bytes\n", v123, v124, v125, v126, v127, (char)"ACFUFTABFile");
    goto LABEL_29;
  }
  v8 = a2[23];
  if ((v8 & 0x80u) != 0)
    v8 = *((_QWORD *)a2 + 1);
  if (v8 != 4)
  {
    v128 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v128, 2u, "%s::%s: tag is either larger or smaller than limit %u (size: %lu)\n", v129, v130, v131, v132, v133, (char)"ACFUFTABFile");
    goto LABEL_29;
  }
  if (a4)
  {
    if (!*a4)
    {
      v134 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v134, 2u, "%s::%s: firmware data container is invalid\n", v135, v136, v137, v138, v139, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    if ((sub_1000D4E68(a1, *a4, 0) & 1) == 0)
    {
      v140 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v140, 2u, "%s::%s: firmware data is invalid and does not meet ftab standards\n", v141, v142, v143, v144, v145, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    v9 = *a4;
    BytePtr = CFDataGetBytePtr(*a4);
    if (!BytePtr)
    {
      v146 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v146, 2u, "%s::%s: failed to copy ftab header\n", v147, v148, v149, v150, v151, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    v11 = *((unsigned int *)BytePtr + 10);
    if (!(_DWORD)v11)
    {
      v152 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v152, 2u, "%s::%s: cannot update a file if no files exist\n", v153, v154, v155, v156, v157, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    v12 = 0;
    v13 = 16 * v11;
    while (1)
    {
      v14 = CFDataGetBytePtr(v9);
      v197 = 4;
      LODWORD(__s2[0]) = *(_DWORD *)&v14[v12 + 48];
      BYTE4(__s2[0]) = 0;
      v15 = (char)a2[23];
      v16 = v15 >= 0 ? a2[23] : *((_QWORD *)a2 + 1);
      v17 = v15 >= 0 ? a2 : *(unsigned __int8 **)a2;
      v18 = v16 >= 4 ? 4 : v16;
      if (!memcmp(v17, __s2, v18) && v16 == 4)
        break;
      v12 += 16;
      if (v13 == v12)
        goto LABEL_28;
    }
    v31 = *(_DWORD *)&CFDataGetBytePtr(v9)[v12 + 56];
    v32 = *(_DWORD *)&CFDataGetBytePtr(v9)[v12 + 52];
    goto LABEL_40;
  }
  if (!sub_1000CEE04(*(_QWORD *)(a1 + 8)))
  {
    v33 = sub_1000CEDB0(*(_BYTE **)(a1 + 8));
    if (!v33)
    {
      v164 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v164, 2u, "%s::%s: could not obtain file data\n", v165, v166, v167, v168, v169, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    v9 = (const __CFData *)v33;
    if (((*(uint64_t (**)(uint64_t, unsigned __int8 *))(*(_QWORD *)a1 + 16))(a1, a2) & 1) == 0)
    {
LABEL_28:
      v20 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: cannot update tag '%s' because it does not exist\n", v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
      goto LABEL_29;
    }
    v34 = sub_1000D8F34(a1 + 40, (const void **)a2);
    v31 = *(_DWORD *)(v34 + 56);
    v32 = *(_DWORD *)(v34 + 60);
LABEL_40:
    v35 = v31;
    if (CFDataGetLength(v5) == v31)
    {
      v36 = CFDataGetBytePtr(v5);
      v198.location = v32;
      v198.length = v31;
      CFDataReplaceBytes(v9, v198, v36, v31);
      if (a4)
      {
        v37 = sub_1000D4E68(a1, *a4, 0);
LABEL_52:
        v26 = v37;
        v5 = 0;
        goto LABEL_119;
      }
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)a1 + 88))(a1))
      {
        v37 = sub_1000D5BDC(a1);
        goto LABEL_52;
      }
      goto LABEL_29;
    }
    v38 = CFDataGetBytePtr(v9);
    CFDataGetBytePtr(v9);
    v195 = a1;
    if (!*((_DWORD *)CFDataGetBytePtr(v9) + 5))
    {
      v194 = 0;
      goto LABEL_54;
    }
    v39 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v39, 0, "%s::%s: manifest existing in FTAB is being deleted\n", v40, v41, v42, v43, v44, (char)"ACFUFTABFile");
    v46 = sub_1000D5A08(v45, v9);
    v47 = &v38[*((unsigned int *)CFDataGetBytePtr(v9) + 4)];
    v48 = CFDataGetBytePtr(v9);
    v194 = CFDataCreate(kCFAllocatorDefault, v47, *((unsigned int *)v48 + 5));
    if (v194)
    {
      v49 = *((unsigned int *)CFDataGetBytePtr(v9) + 4);
      v199.length = *((unsigned int *)CFDataGetBytePtr(v9) + 5);
      v199.location = v49;
      CFDataDeleteBytes(v9, v199);
      if (v46 && *((_DWORD *)CFDataGetBytePtr(v9) + 10))
      {
        v50 = 0;
        v51 = 52;
        do
        {
          v52 = *((_DWORD *)CFDataGetBytePtr(v9) + 5);
          v53 = CFDataGetBytePtr(v9);
          *(_DWORD *)&v53[v51] -= v52;
          ++v50;
          v51 += 16;
        }
        while (v50 < *((unsigned int *)CFDataGetBytePtr(v9) + 10));
      }
      *((_DWORD *)CFDataGetBytePtr(v9) + 5) = 0;
      *((_DWORD *)CFDataGetBytePtr(v9) + 4) = 0;
LABEL_54:
      if (*((_DWORD *)CFDataGetBytePtr(v9) + 10))
      {
        v54 = 0;
        do
        {
          v55 = CFDataGetBytePtr(v9);
          v197 = 4;
          LODWORD(__s2[0]) = *(_DWORD *)&v55[16 * v54 + 48];
          BYTE4(__s2[0]) = 0;
          v56 = a2[23];
          if ((v56 & 0x80u) == 0)
            v57 = a2[23];
          else
            v57 = *((_QWORD *)a2 + 1);
          if (v57 == 4)
          {
            if ((v56 & 0x80) != 0)
            {
              if (!memcmp(*(const void **)a2, __s2, *((_QWORD *)a2 + 1)))
                break;
            }
            else
            {
              if (!a2[23])
                break;
              v58 = __s2;
              v59 = a2;
              while (*v59 == *(unsigned __int8 *)v58)
              {
                ++v59;
                v58 = (__int128 **)((char *)v58 + 1);
                if (!--v56)
                  goto LABEL_70;
              }
            }
          }
          ++v54;
        }
        while (v54 < *((unsigned int *)CFDataGetBytePtr(v9) + 10));
      }
      else
      {
        LODWORD(v54) = 0;
      }
LABEL_70:
      Length = CFDataGetLength(v5);
      v61 = CFDataGetLength(v5);
      if (Length >= v35)
      {
        v76 = (v61 - v35);
        CFDataIncreaseLength(v9, v76);
        v77 = *((_DWORD *)CFDataGetBytePtr(v9) + 10) - 1;
        if (v77 > v54)
        {
          v78 = 16 * v77 + 56;
          while (1)
          {
            v79 = (*(_DWORD *)&CFDataGetBytePtr(v9)[v78 - 4] + v76);
            v80 = *(unsigned int *)&CFDataGetBytePtr(v9)[v78];
            v81 = CFDataGetBytePtr(v9);
            v82 = &v81[*(unsigned int *)&CFDataGetBytePtr(v9)[v78 - 4]];
            v83 = CFDataGetBytePtr(v9);
            v200.location = v79;
            v200.length = v80;
            CFDataReplaceBytes(v9, v200, v82, *(unsigned int *)&v83[v78]);
            v84 = CFDataGetBytePtr(v9);
            *(_DWORD *)&v84[v78 - 4] += v76;
            if (!a4)
            {
              v85 = CFDataGetBytePtr(v9);
              v197 = 4;
              LODWORD(__s2[0]) = *(_DWORD *)&v85[v78 - 8];
              BYTE4(__s2[0]) = 0;
              v86 = CFDataGetBytePtr(v9);
              v87 = sub_1000D5EF8(v195, (uint64_t)__s2, *(_DWORD *)&v86[v78 - 4], 0);
              if ((v87 & 1) != 0)
              {
                v69 = 0;
              }
              else
              {
                v88 = sub_1000D3C90();
                sub_1000D3D08((uint64_t)v88, 2u, "%s::%s: could not update ftab cache\n", v89, v90, v91, v92, v93, (char)"ACFUFTABFile");
                v69 = 4;
              }
              if (v197 < 0)
                operator delete(__s2[0]);
              if (!v87)
                break;
            }
            --v77;
            v78 -= 16;
            if (v54 >= v77)
              goto LABEL_102;
          }
LABEL_112:
          if (v69)
          {
            v5 = v194;
            goto LABEL_30;
          }
LABEL_114:
          v5 = v194;
          if (!v194 || (sub_1000D4ABC(v195, v194, 0) & 1) != 0)
          {
            if (!(*(unsigned int (**)(uint64_t))(*(_QWORD *)v195 + 88))(v195))
              goto LABEL_30;
            v110 = sub_1000D5BDC(v195);
LABEL_118:
            v26 = v110;
            goto LABEL_119;
          }
          goto LABEL_130;
        }
LABEL_102:
        v105 = CFDataGetLength(v5);
        v95 = v54;
        *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v54 + 56] = v105;
        if (a4)
        {
          v106 = *(unsigned int *)&CFDataGetBytePtr(v9)[16 * v54 + 52];
          v107 = CFDataGetLength(v5);
          v108 = CFDataGetBytePtr(v5);
          v109 = CFDataGetLength(v5);
          v203.location = v106;
          v203.length = v107;
          CFDataReplaceBytes(v9, v203, v108, v109);
          goto LABEL_104;
        }
        v111 = CFDataGetBytePtr(v9);
        v197 = 4;
        LODWORD(__s2[0]) = *(_DWORD *)&v111[16 * v54 + 48];
        BYTE4(__s2[0]) = 0;
        v112 = *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v54 + 52];
        v113 = CFDataGetLength(v5);
        v114 = sub_1000D5EF8(v195, (uint64_t)__s2, v112, v113);
        if ((v114 & 1) != 0)
        {
          v69 = 0;
        }
        else
        {
          v188 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v188, 2u, "%s::%s: could not update ftab cache\n", v189, v190, v191, v192, v193, (char)"ACFUFTABFile");
          v69 = 4;
        }
        if (v197 < 0)
          operator delete(__s2[0]);
        if ((v114 & 1) == 0)
          goto LABEL_112;
      }
      else
      {
        v62 = (v35 - v61);
        v63 = (v54 + 1);
        if (v63 < *((_DWORD *)CFDataGetBytePtr(v9) + 10))
        {
          v64 = 16 * (v54 + 1);
          do
          {
            v65 = CFDataGetBytePtr(v9);
            *(_DWORD *)&v65[v64 + 52] -= v62;
            if (!a4)
            {
              v66 = CFDataGetBytePtr(v9);
              v197 = 4;
              LODWORD(__s2[0]) = *(_DWORD *)&v66[v64 + 48];
              BYTE4(__s2[0]) = 0;
              v67 = CFDataGetBytePtr(v9);
              v68 = sub_1000D5EF8(v195, (uint64_t)__s2, *(_DWORD *)&v67[v64 + 52], 0);
              if ((v68 & 1) != 0)
              {
                v69 = 0;
              }
              else
              {
                v70 = sub_1000D3C90();
                sub_1000D3D08((uint64_t)v70, 2u, "%s::%s: could not update ftab cache\n", v71, v72, v73, v74, v75, (char)"ACFUFTABFile");
                v69 = 4;
              }
              if (v197 < 0)
                operator delete(__s2[0]);
              if (!v68)
                goto LABEL_112;
            }
            ++v63;
            v64 += 16;
          }
          while (v63 < *((unsigned int *)CFDataGetBytePtr(v9) + 10));
        }
        v94 = CFDataGetLength(v5);
        v95 = v54;
        *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v54 + 56] = v94;
        if (!a4)
        {
          v96 = CFDataGetBytePtr(v9);
          v197 = 4;
          LODWORD(__s2[0]) = *(_DWORD *)&v96[16 * v54 + 48];
          BYTE4(__s2[0]) = 0;
          v97 = *(_DWORD *)&CFDataGetBytePtr(v9)[16 * v54 + 52];
          v98 = CFDataGetLength(v5);
          v99 = sub_1000D5EF8(v195, (uint64_t)__s2, v97, v98);
          if ((v99 & 1) != 0)
          {
            v69 = 0;
          }
          else
          {
            v182 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v182, 2u, "%s::%s: could not update ftab cache\n", v183, v184, v185, v186, v187, (char)"ACFUFTABFile");
            v69 = 4;
          }
          if (v197 < 0)
            operator delete(__s2[0]);
          if (!v99)
            goto LABEL_112;
        }
        v100 = *(unsigned int *)&CFDataGetBytePtr(v9)[16 * v54 + 52];
        v201.location = CFDataGetLength(v5) + v100;
        v201.length = v62;
        CFDataDeleteBytes(v9, v201);
      }
      v101 = *(unsigned int *)&CFDataGetBytePtr(v9)[16 * v95 + 52];
      v102 = CFDataGetLength(v5);
      v103 = CFDataGetBytePtr(v5);
      v104 = CFDataGetLength(v5);
      v202.location = v101;
      v202.length = v102;
      CFDataReplaceBytes(v9, v202, v103, v104);
      if (!a4)
        goto LABEL_114;
LABEL_104:
      v5 = v194;
      if (!v194 || (sub_1000D4ABC(v195, v194, a4) & 1) != 0)
      {
        v110 = sub_1000D4E68(v195, *a4, 0);
        goto LABEL_118;
      }
LABEL_130:
      v176 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v176, 2u, "%s::%s: failed to update manifest\n", v177, v178, v179, v180, v181, (char)"ACFUFTABFile");
      goto LABEL_30;
    }
    v170 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v170, 2u, "%s::%s: failed to obtain copy of manifest\n", v171, v172, v173, v174, v175, (char)"ACFUFTABFile");
LABEL_29:
    v5 = 0;
LABEL_30:
    v26 = 0;
    goto LABEL_119;
  }
  v27 = sub_1000D8F34(a1 + 72, (const void **)a2);
  if (a1 + 80 != v27)
  {
    v28 = v27;
    v29 = *(const void **)(v27 + 56);
    if (v29)
    {
      CFRelease(v29);
      *(_QWORD *)(v28 + 56) = 0;
    }
  }
  v30 = AMSupportSafeRetain(v5);
  __s2[0] = (__int128 *)a2;
  v5 = 0;
  sub_1000D8D14((uint64_t **)(a1 + 72), (const void **)a2, (uint64_t)&unk_100167457, __s2)[7] = v30;
  v26 = 1;
LABEL_119:
  AMSupportSafeRelease(v5);
  return v26 & 1;
}

void sub_1000D7974(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  if (a20 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D799C(uint64_t a1, int a2)
{
  uint64_t v3;
  const __CFData *v5;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    if (sub_1000CEE04(v3))
    {
      v13 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: function is not supported in memory optimized flow. Memory optimized files are read only\n", v14, v15, v16, v17, v18, (char)"ACFUFTABFile");
    }
    else
    {
      v5 = (const __CFData *)sub_1000CEDB0(*(_BYTE **)(a1 + 8));
      if (v5)
      {
        *((_DWORD *)CFDataGetBytePtr(v5) + 1) = a2;
        return 1;
      }
      v19 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: could not obtain file data\n", v20, v21, v22, v23, v24, (char)"ACFUFTABFile");
    }
  }
  else
  {
    v7 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v7, 2u, "%s::%s: file data was invalid\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
  }
  return 0;
}

__CFData *sub_1000D7A64(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __CFData *result;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  if (!sub_1000CEE04(*(_QWORD *)(a1 + 8))
    || (v4 = sub_1000D8F34(a1 + 72, (const void **)a2), a1 + 80 == v4))
  {
    if (!*(_QWORD *)(a1 + 8))
    {
      v14 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: file data was invalid\n", v15, v16, v17, v18, v19, (char)"ACFUFTABFile");
      return 0;
    }
    v12 = *(unsigned __int8 *)(a2 + 23);
    if ((v12 & 0x80u) != 0)
      v12 = *(_QWORD *)(a2 + 8);
    if (v12 != 4)
    {
      v20 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: specified tag name is invalid!\n", v21, v22, v23, v24, v25, (char)"ACFUFTABFile");
      return 0;
    }
    v13 = sub_1000D8F34(a1 + 40, (const void **)a2);
    if (a1 + 48 == v13)
    {
      v26 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v26, 2u, "%s::%s: file '%s' does not exist\n", v27, v28, v29, v30, v31, (char)"ACFUFTABFile");
      return 0;
    }
    result = sub_1000CE5BC(*(_QWORD *)(a1 + 8), *(_DWORD *)(v13 + 60), *(unsigned int *)(v13 + 56));
    if (!result)
    {
      v32 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v32, 2u, "%s::%s: failed to copy file data\n", v33, v34, v35, v36, v37, (char)"ACFUFTABFile");
      return 0;
    }
  }
  else
  {
    result = (__CFData *)AMSupportSafeRetain(*(_QWORD *)(v4 + 56));
    if (!result)
    {
      v6 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v6, 2u, "%s::%s: failed to retain file data\n", v7, v8, v9, v10, v11, (char)"ACFUFTABFile");
      return 0;
    }
  }
  return result;
}

void sub_1000D7BE8(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, unsigned int a4@<W3>, uint64_t *a5@<X8>)
{
  uint64_t v7;
  uint64_t v9;
  uint64_t v12;
  UInt8 *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  uint64_t v34;
  CFRange v35;

  *a5 = 0;
  v7 = *(_QWORD *)(a1 + 8);
  if (!v7)
  {
    v27 = sub_1000D3C90();
    v33 = "%s::%s: file data was invalid\n";
    goto LABEL_19;
  }
  v9 = *(unsigned __int8 *)(a2 + 23);
  if ((v9 & 0x80u) != 0)
    v9 = *(_QWORD *)(a2 + 8);
  if (v9 != 4)
  {
    v27 = sub_1000D3C90();
    v33 = "%s::%s: specified tag name is invalid!\n";
    goto LABEL_19;
  }
  if (!sub_1000CEE04(v7) || (v12 = sub_1000D8F34(a1 + 72, (const void **)a2), a1 + 80 == v12))
  {
    v23 = sub_1000D8F34(a1 + 40, (const void **)a2);
    if (a1 + 48 == v23)
    {
      v27 = sub_1000D3C90();
      v33 = "%s::%s: file does not exist\n";
    }
    else
    {
      sub_1000CE9C4(a4, *(_QWORD *)(a1 + 8), *(_DWORD *)(v23 + 60) + a3, &v34);
      v24 = v34;
      v34 = 0;
      sub_1000CEE8C(a5, v24);
      v25 = v34;
      v34 = 0;
      if (v25)
      {
        v26 = (void *)sub_1000CDE2C(v25);
        operator delete(v26);
      }
      if (*a5)
        return;
      v27 = sub_1000D3C90();
      v33 = "%s::%s: failed to obtain data ref\n";
    }
LABEL_19:
    sub_1000D3D08((uint64_t)v27, 2u, v33, v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
    return;
  }
  v13 = (UInt8 *)malloc(a4);
  if (!v13)
  {
    v16 = sub_1000D3C90();
    v22 = "%s::%s: failed to allocate data\n";
    goto LABEL_21;
  }
  v14 = (uint64_t)v13;
  v35.location = a3;
  v35.length = a4;
  CFDataGetBytes(*(CFDataRef *)(v12 + 56), v35, v13);
  v15 = operator new(0x18uLL);
  sub_1000CDCE4((uint64_t)v15, v14, a4, 0);
  sub_1000CEE8C(a5, (uint64_t)v15);
  if (!*a5)
  {
    v16 = sub_1000D3C90();
    v22 = "%s::%s: failed to obtain data ref\n";
LABEL_21:
    sub_1000D3D08((uint64_t)v16, 2u, v22, v17, v18, v19, v20, v21, (char)"ACFUFTABFile");
  }
}

void sub_1000D7DC8(_Unwind_Exception *a1)
{
  uint64_t *v1;

  sub_1000CEE8C(v1, 0);
  _Unwind_Resume(a1);
}

CFDataRef sub_1000D7E04(uint64_t *a1)
{
  uint64_t v2;
  uint64_t *v3;
  int v4;
  const __CFData *v5;
  uint64_t *v6;
  uint64_t *v7;
  BOOL v8;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  CFDataRef v34;

  v34 = 0;
  v2 = a1[1];
  if (!v2)
  {
    v22 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v22, 2u, "%s::%s: file data was invalid\n", v23, v24, v25, v26, v27, (char)"ACFUFTABFile");
    return v34;
  }
  v34 = sub_1000CE410(v2);
  if (!v34)
  {
    v28 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: failed to obtain file data\n", v29, v30, v31, v32, v33, (char)"ACFUFTABFile");
    return v34;
  }
  if (sub_1000CEE04(a1[1]))
  {
    v3 = (uint64_t *)a1[9];
    if (v3 != a1 + 10)
    {
      do
      {
        v4 = (*(uint64_t (**)(uint64_t *, uint64_t *))(*a1 + 16))(a1, v3 + 4);
        v5 = (const __CFData *)v3[7];
        if (v4)
        {
          if ((sub_1000D6E00((uint64_t)a1, (unsigned __int8 *)v3 + 32, v5, &v34) & 1) == 0)
          {
            v10 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v10, 2u, "%s::%s: failed to update file\n", v11, v12, v13, v14, v15, (char)"ACFUFTABFile");
            return v34;
          }
        }
        else if ((sub_1000D6494((uint64_t)a1, v3 + 4, v5, &v34) & 1) == 0)
        {
          v16 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v16, 2u, "%s::%s: failed to add new file\n", v17, v18, v19, v20, v21, (char)"ACFUFTABFile");
          return v34;
        }
        v6 = (uint64_t *)v3[1];
        if (v6)
        {
          do
          {
            v7 = v6;
            v6 = (uint64_t *)*v6;
          }
          while (v6);
        }
        else
        {
          do
          {
            v7 = (uint64_t *)v3[2];
            v8 = *v7 == (_QWORD)v3;
            v3 = v7;
          }
          while (!v8);
        }
        v3 = v7;
      }
      while (v7 != a1 + 10);
    }
  }
  return v34;
}

void sub_1000D7F80(uint64_t a1)
{
  uint64_t v2;
  int v3;
  uint64_t v4;
  __CFData *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFData *v12;
  const UInt8 *BytePtr;
  const UInt8 *v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  unsigned int v52;
  __CFData *v53;
  __CFData *v54;
  const UInt8 *v55;
  CC_LONG v56;
  uint64_t v57;
  void *v58;
  const UInt8 *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  void *v65;
  std::string *v66;
  __int128 v67;
  std::string *v68;
  __int128 v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  std::string v100;
  std::string v101;
  void *__p[2];
  std::string::size_type v103;
  void *v104;
  char v105;
  unsigned __int8 md[48];

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
  {
    v82 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v82, 2u, "%s::%s: file data was invalid\n", v83, v84, v85, v86, v87, (char)"ACFUFTABFile");
    return;
  }
  v3 = sub_1000CEE04(v2);
  v4 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    v5 = sub_1000CE5BC(v4, 0, 0x30uLL);
    if (!v5)
    {
      v6 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v6, 2u, "%s::%s: failed to copy ftab header\n", v7, v8, v9, v10, v11, (char)"ACFUFTABFile");
      return;
    }
  }
  else
  {
    v5 = sub_1000CE410(v4);
    if (!v5)
    {
      v94 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v94, 2u, "%s::%s: could not obtain file data\n", v95, v96, v97, v98, v99, (char)"ACFUFTABFile");
      return;
    }
  }
  v12 = v5;
  BytePtr = CFDataGetBytePtr(v5);
  v14 = BytePtr;
  if (BytePtr)
  {
    v15 = *((_DWORD *)BytePtr + 10);
    sub_1000DB164(a1);
    v16 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v16, 4u, "%s::%s: =========== FTAB Header ===========\n", v17, v18, v19, v20, v21, (char)"ACFUFTABFile");
    v22 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v22, 4u, "%s::%s: Generation: %u, Valid: %u, BootNonce: 0x%08llx\n", v23, v24, v25, v26, v27, (char)"ACFUFTABFile");
    v28 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v28, 4u, "%s::%s: Manifest Offset: %u, Manifest Length: %u, Magic: %s\n", v29, v30, v31, v32, v33, (char)"ACFUFTABFile");
    v34 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v34, 4u, "%s::%s: Num Files: %u\n", v35, v36, v37, v38, v39, (char)"ACFUFTABFile");
    v40 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v40, 4u, "%s::%s: =========== FTAB Header ===========\n\n", v41, v42, v43, v44, v45, (char)"ACFUFTABFile");
    v46 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v46, 4u, "%s::%s: =========== FTAB Payloads ===========\n", v47, v48, v49, v50, v51, (char)"ACFUFTABFile");
    CFRelease(v12);
    if (v15)
    {
      v52 = 48;
      while (1)
      {
        v53 = sub_1000CE5BC(*(_QWORD *)(a1 + 8), v52, 0x10uLL);
        v54 = v53;
        if (!v53)
          break;
        v55 = CFDataGetBytePtr(v53);
        v57 = *((unsigned int *)v55 + 1);
        v56 = *((_DWORD *)v55 + 2);
        v105 = 4;
        LODWORD(v104) = *(_DWORD *)v55;
        BYTE4(v104) = 0;
        v59 = &v14[v57];
        v58 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v58, 4u, "%s::%s: Tag: %s :: Offset: 0x%04x Raw address: 0x%lx, size: %u\n", v60, v61, v62, v63, v64, (char)"ACFUFTABFile");
        if ((sub_1000CEE04(*(_QWORD *)(a1 + 8)) & 1) == 0 && CC_SHA384(v59, v56, md) == md)
        {
          v65 = sub_1000D3C90();
          sub_1000CB3F4(&v100, "ACFUFTABFile");
          v66 = std::string::append(&v100, "::");
          v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
          v101.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v101.__r_.__value_.__l.__data_ = v67;
          v66->__r_.__value_.__l.__size_ = 0;
          v66->__r_.__value_.__r.__words[2] = 0;
          v66->__r_.__value_.__r.__words[0] = 0;
          v68 = std::string::append(&v101, "prettyLog");
          v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
          v103 = v68->__r_.__value_.__r.__words[2];
          *(_OWORD *)__p = v69;
          v68->__r_.__value_.__l.__size_ = 0;
          v68->__r_.__value_.__r.__words[2] = 0;
          v68->__r_.__value_.__r.__words[0] = 0;
          sub_1000D3F7C((uint64_t)v65, (uint64_t *)__p, 4, (uint64_t)md, 0x30uLL, 1);
          if (SHIBYTE(v103) < 0)
            operator delete(__p[0]);
          if (SHIBYTE(v101.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v101.__r_.__value_.__l.__data_);
          if (SHIBYTE(v100.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v100.__r_.__value_.__l.__data_);
        }
        CFRelease(v54);
        if (v105 < 0)
          operator delete(v104);
        v52 += 16;
        if (!--v15)
          goto LABEL_21;
      }
      v76 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v76, 2u, "%s::%s: failed to copy ftab file header\n", v77, v78, v79, v80, v81, (char)"ACFUFTABFile");
    }
    else
    {
LABEL_21:
      v70 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v70, 4u, "%s::%s: =========== FTAB Payloads ===========\n\n", v71, v72, v73, v74, v75, (char)"ACFUFTABFile");
    }
  }
  else
  {
    v88 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v88, 2u, "%s::%s: failed to copy ftab header\n", v89, v90, v91, v92, v93, (char)"ACFUFTABFile");
    CFRelease(v12);
  }
}

void sub_1000D8390(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34,void *a35,uint64_t a36,int a37,__int16 a38,char a39,char a40)
{
  if (a34 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (a21 < 0)
    operator delete(a16);
  if (a40 < 0)
    operator delete(a35);
  _Unwind_Resume(exception_object);
}

BOOL sub_1000D8404(uint64_t a1, const void **a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*(_QWORD *)(a1 + 8))
    return sub_1000D8C30(a1 + 40, a2) != 0;
  v3 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v3, 2u, "%s::%s: file data was invalid\n", v4, v5, v6, v7, v8, (char)"ACFUFTABFile");
  return 0;
}

_QWORD *sub_1000D8464(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  const void *v5;
  _QWORD *v6;
  _QWORD *v7;
  BOOL v8;

  *(_QWORD *)a1 = off_100182CC8;
  v2 = (_QWORD *)(a1 + 80);
  v3 = a1 + 72;
  v4 = *(_QWORD **)(a1 + 72);
  if (v4 != (_QWORD *)(a1 + 80))
  {
    do
    {
      v5 = (const void *)v4[7];
      if (v5)
      {
        CFRelease(v5);
        v4[7] = 0;
      }
      v6 = (_QWORD *)v4[1];
      if (v6)
      {
        do
        {
          v7 = v6;
          v6 = (_QWORD *)*v6;
        }
        while (v6);
      }
      else
      {
        do
        {
          v7 = (_QWORD *)v4[2];
          v8 = *v7 == (_QWORD)v4;
          v4 = v7;
        }
        while (!v8);
      }
      v4 = v7;
    }
    while (v7 != v2);
  }
  sub_1000D8B54(v3, *(char **)(a1 + 80));
  sub_1000D8B54(a1 + 40, *(char **)(a1 + 48));
  return sub_1000DB568((_QWORD *)a1);
}

void sub_1000D8514(uint64_t a1)
{
  _QWORD *v1;

  v1 = sub_1000D8464(a1);
  operator delete(v1);
}

uint64_t sub_1000D8528(_QWORD *a1, const void *a2)
{
  const char *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  a1[3] = CFSTR("ftab.bin");
  if (sub_1000DB5BC((uint64_t)a1, a2))
  {
    if ((*(unsigned int (**)(_QWORD *))(*a1 + 88))(a1))
    {
      if (sub_1000D85E8((uint64_t)a1))
      {
        if (sub_1000D5BDC((uint64_t)a1))
          return 1;
        v4 = "%s::%s: cache is invalid\n";
      }
      else
      {
        v4 = "%s::%s: failed to initialize file cache\n";
      }
    }
    else
    {
      v4 = "%s::%s: firmware file is invalid\n";
    }
  }
  else
  {
    v4 = "%s::%s: firmware file failed to initialize\n";
  }
  v5 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v5, 2u, v4, v6, v7, v8, v9, v10, (char)"ACFUFTABFile");
  return 0;
}

uint64_t sub_1000D85E8(uint64_t a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFData *v9;
  __CFData *v10;
  const UInt8 *BytePtr;
  int v12;
  char v13;
  int v14;
  unsigned int v15;
  __CFData *v16;
  const UInt8 *v17;
  char v18;
  char v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *__p;
  char v59;

  v2 = *(_QWORD *)(a1 + 8);
  if (!v2)
  {
    v39 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v39, 2u, "%s::%s: no file data?!\n", v40, v41, v42, v43, v44, (char)"ACFUFTABFile");
    goto LABEL_26;
  }
  if (*(_QWORD *)(a1 + 56))
  {
    v3 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v3, 4u, "%s::%s: ftab cache had entries before ftab container was initialized. Clearing cache before moving on.\n", v4, v5, v6, v7, v8, (char)"ACFUFTABFile");
    sub_1000D8B54(a1 + 40, *(char **)(a1 + 48));
    *(_QWORD *)(a1 + 40) = a1 + 48;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    v2 = *(_QWORD *)(a1 + 8);
  }
  v9 = sub_1000CE5BC(v2, 0, 0x30uLL);
  if (!v9)
  {
    v45 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v45, 2u, "%s::%s: failed to copy ftab header\n", v46, v47, v48, v49, v50, (char)"ACFUFTABFile");
    goto LABEL_26;
  }
  v10 = v9;
  BytePtr = CFDataGetBytePtr(v9);
  if (BytePtr)
  {
    v12 = *((_DWORD *)BytePtr + 10);
    CFRelease(v10);
    if (v12)
    {
      v13 = 0;
      v14 = v12 - 1;
      v15 = 48;
      do
      {
        v16 = sub_1000CE5BC(*(_QWORD *)(a1 + 8), v15, 0x10uLL);
        if (!v16)
        {
          v27 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v27, 2u, "%s::%s: failed to copy ftab file header\n", v28, v29, v30, v31, v32, (char)"ACFUFTABFile");
          v18 = v13;
          return v18 & 1;
        }
        v10 = v16;
        v17 = CFDataGetBytePtr(v16);
        if (!v17)
        {
          v33 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v33, 2u, "%s::%s: failed to copy file header\n", v34, v35, v36, v37, v38, (char)"ACFUFTABFile");
          v18 = v13;
          goto LABEL_21;
        }
        v59 = 4;
        LODWORD(__p) = *(_DWORD *)v17;
        BYTE4(__p) = 0;
        v18 = sub_1000D5EF8(a1, (uint64_t)&__p, *((_DWORD *)v17 + 1), *((_DWORD *)v17 + 2));
        if ((v18 & 1) != 0)
        {
          CFRelease(v10);
          v10 = 0;
        }
        else
        {
          v21 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v21, 2u, "%s::%s: failed to initialize cache\n", v22, v23, v24, v25, v26, (char)"ACFUFTABFile");
        }
        if (v59 < 0)
          operator delete(__p);
        if (v14-- != 0)
          v20 = v18;
        else
          v20 = 0;
        v15 += 16;
        v13 = 1;
      }
      while ((v20 & 1) != 0);
      if (!v10)
        return v18 & 1;
      goto LABEL_21;
    }
LABEL_26:
    v18 = 0;
    return v18 & 1;
  }
  v52 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v52, 2u, "%s::%s: failed to copy ftab header\n", v53, v54, v55, v56, v57, (char)"ACFUFTABFile");
  v18 = 0;
LABEL_21:
  CFRelease(v10);
  return v18 & 1;
}

void sub_1000D880C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000D8828(_QWORD *a1, const void *a2)
{
  const char *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  a1[3] = CFSTR("ftab.bin");
  if (sub_1000DB6EC((uint64_t)a1, a2))
  {
    if ((*(unsigned int (**)(_QWORD *))(*a1 + 88))(a1))
    {
      if (sub_1000D85E8((uint64_t)a1))
      {
        if (sub_1000D5BDC((uint64_t)a1))
          return 1;
        v4 = "%s::%s: cache is invalid\n";
      }
      else
      {
        v4 = "%s::%s: failed to initialize file cache\n";
      }
    }
    else
    {
      v4 = "%s::%s: firmware file is invalid\n";
    }
  }
  else
  {
    v4 = "%s::%s: firmware file failed to initialize\n";
  }
  v5 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v5, 2u, v4, v6, v7, v8, v9, v10, (char)"ACFUFTABFile");
  return 0;
}

uint64_t sub_1000D88E8(_QWORD *a1, uint64_t a2, char a3)
{
  const char *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  a1[3] = CFSTR("ftab.bin");
  if (sub_1000DB81C((uint64_t)a1, a2, a3))
  {
    if ((*(unsigned int (**)(_QWORD *))(*a1 + 88))(a1))
    {
      if (sub_1000D85E8((uint64_t)a1))
      {
        if (sub_1000D5BDC((uint64_t)a1))
          return 1;
        v5 = "%s::%s: cache is invalid\n";
      }
      else
      {
        v5 = "%s::%s: failed to initialize file cache\n";
      }
    }
    else
    {
      v5 = "%s::%s: firmware file is invalid\n";
    }
  }
  else
  {
    v5 = "%s::%s: firmware file failed to initialize\n";
  }
  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 2u, v5, v7, v8, v9, v10, v11, (char)"ACFUFTABFile");
  return 0;
}

uint64_t sub_1000D89A8(uint64_t a1)
{
  return sub_1000D4E68(a1, 0, 0);
}

CFIndex sub_1000D89B4(uint64_t a1, const void **a2)
{
  uint64_t v3;
  uint64_t v5;
  CFIndex result;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    if (!sub_1000CEE04(v3) || (v5 = sub_1000D8F34(a1 + 72, a2), a1 + 80 == v5))
    {
      v13 = sub_1000D8F34(a1 + 40, a2);
      if (a1 + 48 != v13)
        return *(unsigned int *)(v13 + 56);
    }
    else
    {
      result = CFDataGetLength(*(CFDataRef *)(v5 + 56));
      if ((_DWORD)result)
        return result;
      v7 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v7, 2u, "%s::%s: failed obtain file size\n", v8, v9, v10, v11, v12, (char)"ACFUFTABFile");
    }
  }
  else
  {
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: file data was invalid\n", v15, v16, v17, v18, v19, (char)"ACFUFTABFile");
  }
  return 0;
}

uint64_t sub_1000D8A88(_QWORD *a1)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *__p[2];
  char v11;

  sub_1000CB3F4(__p, "bver");
  if (a1[1])
  {
    if ((*(unsigned int (**)(_QWORD *, void **))(*a1 + 16))(a1, __p))
    {
      v2 = (*(uint64_t (**)(_QWORD *, void **))*a1)(a1, __p);
      goto LABEL_6;
    }
  }
  else
  {
    v3 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v3, 2u, "%s::%s: file data was invalid\n", v4, v5, v6, v7, v8, (char)"ACFUFTABFile");
  }
  v2 = 0;
LABEL_6:
  if (v11 < 0)
    operator delete(__p[0]);
  return v2;
}

void sub_1000D8B38(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  if (a17 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1000D8B54(uint64_t a1, char *a2)
{
  if (a2)
  {
    sub_1000D8B54(a1, *(_QWORD *)a2);
    sub_1000D8B54(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

void sub_1000D8BA4(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_1000D8BE4((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_1000D8BE4(uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 24)
  {
    if (*(char *)(i - 1) < 0)
      operator delete(*(void **)(i - 24));
  }
  a1[1] = v2;
}

uint64_t sub_1000D8C30(uint64_t a1, const void **a2)
{
  const void **v2;
  uint64_t v4;
  uint64_t v5;

  v2 = *(const void ***)(a1 + 8);
  if (v2)
  {
    v4 = a1 + 16;
    v5 = 1;
    do
    {
      if (!sub_1000D8CAC(v4, a2, v2 + 4))
      {
        if (!sub_1000D8CAC(v4, v2 + 4, a2))
          return v5;
        ++v2;
      }
      v2 = (const void **)*v2;
    }
    while (v2);
  }
  return 0;
}

BOOL sub_1000D8CAC(uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

uint64_t *sub_1000D8D14(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;

  v6 = (uint64_t **)sub_1000D8DA8((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    sub_1000D8E44((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000CBAE0(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

_QWORD *sub_1000D8DA8(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!sub_1000D8CAC(v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!sub_1000D8CAC(v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

_BYTE *sub_1000D8E44@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 32;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_1000CB554(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  *((_QWORD *)v6 + 7) = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1000D8ECC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_1000D8EE8(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1000D8EE8(uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t sub_1000D8F34(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = sub_1000D8CAC(v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || sub_1000D8CAC(v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

uint64_t sub_1000D8FC0(uint64_t **a1, const void **a2)
{
  uint64_t v3;

  v3 = sub_1000D8F34((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  sub_1000D9004(a1, v3);
  return 1;
}

uint64_t *sub_1000D9004(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;

  v3 = sub_1000D9044(a1, (uint64_t *)a2);
  if (*(char *)(a2 + 55) < 0)
    operator delete(*(void **)(a2 + 32));
  operator delete((void *)a2);
  return v3;
}

uint64_t *sub_1000D9044(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  sub_1000D90B4(v6, a2);
  return v3;
}

uint64_t *sub_1000D90B4(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t *sub_1000D9438(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;

  v6 = (uint64_t **)sub_1000D8DA8((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    sub_1000D94CC((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000CBAE0(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

_BYTE *sub_1000D94CC@<X0>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  _BYTE *result;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  result = v6 + 32;
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    result = sub_1000CB554(result, *(void **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)result = v9;
  }
  *((_QWORD *)v6 + 7) = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1000D9554(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_1000D8EE8(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D9570(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1000D9628((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000D95E4(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    sub_1000CB52C();
  return operator new(24 * a2);
}

uint64_t sub_1000D9628(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v9;
  __int128 v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 != a5)
  {
    v9 = a7;
    do
    {
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v9 - 8) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v9 - 24) = v10;
      v9 -= 24;
      *(_QWORD *)(a3 - 16) = 0;
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(a3 - 24) = 0;
      v7 -= 24;
      a3 -= 24;
    }
    while (a3 != a5);
    *((_QWORD *)&v15 + 1) = v9;
  }
  v13 = 1;
  sub_1000D96C4((uint64_t)v12);
  return a6;
}

uint64_t sub_1000D96C4(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1000D96F8(a1);
  return a1;
}

void sub_1000D96F8(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    if (*(char *)(v1 + 23) < 0)
      operator delete(*(void **)v1);
    v1 += 24;
  }
}

uint64_t sub_1000D973C(uint64_t a1)
{
  sub_1000D9770(a1, *(void ***)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1000D9770(uint64_t a1, void **a2)
{
  void **v2;
  void **v5;

  v2 = *(void ***)(a1 + 16);
  if (v2 != a2)
  {
    do
    {
      v5 = v2 - 3;
      *(_QWORD *)(a1 + 16) = v2 - 3;
      if (*((char *)v2 - 1) < 0)
      {
        operator delete(*v5);
        v5 = *(void ***)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

void sub_1000D97C4(uint64_t a1@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, _QWORD *a4@<X8>)
{
  _DWORD *v8;
  uint64_t v9[3];

  v8 = operator new(0x58uLL);
  sub_1000DA0C0((uint64_t)v8);
  *(_QWORD *)v8 = &off_100182D58;
  v8[21] = 0;
  *a4 = v8;
  sub_1000D9FE8(v9, a1);
  LOBYTE(a3) = sub_1000D98B4((uint64_t)v8, (uint64_t)v9, a2, a3);
  sub_1000CC004((uint64_t)v9, (char *)v9[1]);
  if ((a3 & 1) == 0)
  {
    *a4 = 0;
    (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 56))(v8);
  }
}

void sub_1000D9870(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
  uint64_t v11;
  _QWORD *v12;

  sub_1000CC004((uint64_t)&a10, a11);
  *v12 = 0;
  (*(void (**)(uint64_t))(*(_QWORD *)v11 + 56))(v11);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D98B4(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4)
{
  BOOL v7;
  const void *v8;
  uint64_t v9;
  const void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const void *v44;
  int v45;
  uint64_t *v46[3];

  sub_1000D9FE8((uint64_t *)v46, a2);
  v7 = sub_1000DA918(a1, v46);
  sub_1000CC004((uint64_t)v46, (char *)v46[1]);
  if (!v7)
  {
    v26 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v26, 2u, "%s::%s: failed to initialize base object\n", v27, v28, v29, v30, v31, (char)"RTKitFirmware");
    return 0;
  }
  sub_1000D4498(a3, a4, 0xFFFF, &v44);
  v8 = v44;
  v44 = 0;
  v9 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = v8;
  if (v9)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v9 + 56))(v9);
    v10 = v44;
    v44 = 0;
    if (v10)
      (*(void (**)(const void *))(*(_QWORD *)v10 + 56))(v10);
    v8 = *(const void **)(a1 + 32);
  }
  if (!v8)
  {
    v32 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v32, 2u, "%s::%s: failed to create firmware\n", v33, v34, v35, v36, v37, (char)"RTKitFirmware");
    return 0;
  }
  sub_1000D6188((uint64_t)v11, (uint64_t)&v44);
  if (!v45)
  {
    v18 = v44;
    *(_QWORD *)(a1 + 48) = v44;
    if (v18)
      goto LABEL_11;
    v38 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v38, 2u, "%s::%s: failed to create manifest\n", v39, v40, v41, v42, v43, (char)"RTKitFirmware");
    return 0;
  }
  if (v45 != 1001)
  {
    v20 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: failed to get manifest, error: %d\n", v21, v22, v23, v24, v25, (char)"RTKitFirmware");
    return 0;
  }
  v12 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v12, 0, "%s::%s: No manifest present\n", v13, v14, v15, v16, v17, (char)"RTKitFirmware");
  *(_QWORD *)(a1 + 48) = 0;
LABEL_11:
  if ((a4 & 2) != 0)
    *(_BYTE *)(a1 + 80) = 1;
  *(_DWORD *)(a1 + 56) = 1;
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 64))(a1);
}

void sub_1000D9A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, char *a15)
{
  sub_1000CC004((uint64_t)&a14, a15);
  _Unwind_Resume(a1);
}

CFDataRef sub_1000D9AB0(uint64_t a1)
{
  const void *v1;
  void *v2;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  UInt8 bytes[8];

  v1 = *(const void **)(a1 + 32);
  if (v1
  {
    *(_QWORD *)bytes = sub_1000D63B4((uint64_t)v2);
    return CFDataCreate(kCFAllocatorDefault, bytes, 8);
  }
  else
  {
    v4 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v4, 2u, "%s::%s: Invalid firmware file\n", v5, v6, v7, v8, v9, (char)"RTKitFirmware");
    return 0;
  }
}

uint64_t sub_1000D9B3C(uint64_t a1, const __CFData *a2)
{
  const void *v2;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v2 = *(const void **)(a1 + 32);
  if (v2
  {
    if (a2)
    {
      v5 = (uint64_t)v4;
      if (CFDataGetLength(a2) == 8)
      {
        v6 = *(_QWORD *)CFDataGetBytePtr(a2);
        return sub_1000D62C0(v5, v6);
      }
    }
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: Bad parameter\n", v15, v16, v17, v18, v19, (char)"RTKitFirmware");
  }
  else
  {
    v8 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v8, 2u, "%s::%s: Invalid firmware file\n", v9, v10, v11, v12, v13, (char)"RTKitFirmware");
  }
  return 0;
}

uint64_t sub_1000D9C0C(uint64_t a1, CFDictionaryRef theDict)
{
  const void *Value;
  const void *v5;
  CFTypeID v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  Value = CFDictionaryGetValue(theDict, CFSTR("FirmwareData"));
  if (Value)
  {
    v5 = Value;
    AMSupportSafeRetain(Value);
    v6 = CFGetTypeID(v5);
    if (v6 == CFDataGetTypeID())
    {
      sub_1000D4498(v5, *(unsigned int *)(a1 + 84), 0xFFFF, &v30);
      v7 = v30;
      v30 = 0;
      v8 = *(_QWORD *)(a1 + 32);
      *(_QWORD *)(a1 + 32) = v7;
      if (v8)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v8 + 56))(v8);
        v9 = v30;
        v30 = 0;
        if (v9)
          (*(void (**)(uint64_t))(*(_QWORD *)v9 + 56))(v9);
        v7 = *(_QWORD *)(a1 + 32);
      }
      if (v7)
      {
        v10 = sub_1000DA2F0((const void **)a1, theDict);
      }
      else
      {
        v24 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v24, 2u, "%s::%s: Failed to open firmware in restore options\n", v25, v26, v27, v28, v29, (char)"RTKitFirmware");
        v10 = 1000;
      }
    }
    else
    {
      v18 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v18, 2u, "%s::%s: Unrecognized CF object!\n", v19, v20, v21, v22, v23, (char)"RTKitFirmware");
      v10 = 4002;
    }
    CFRelease(v5);
  }
  else
  {
    v12 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v12, 2u, "%s::%s: Failed to find firmware in restore options\n", v13, v14, v15, v16, v17, (char)"RTKitFirmware");
    return 4001;
  }
  return v10;
}

uint64_t sub_1000D9D70(uint64_t a1)
{
  const void *v2;
  void *v3;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v2 = *(const void **)(a1 + 32);
  if (v2
  {
    if ((sub_1000D799C((uint64_t)v3, 1) & 1) != 0)
    {
      if (*(_QWORD *)(a1 + 48))
      {
        return sub_1000DA1CC(a1);
      }
      else
      {
        v17 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v17, 2u, "%s::%s: No manifest provided with firmware. Manifest is required!\n", v18, v19, v20, v21, v22, (char)"RTKitFirmware");
        return 1001;
      }
    }
    else
    {
      v11 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v11, 2u, "%s::%s: Failed to set ftab validity\n", v12, v13, v14, v15, v16, (char)"RTKitFirmware");
      return 1004;
    }
  }
  else
  {
    v5 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v5, 2u, "%s::%s: Invalid firmware file\n", v6, v7, v8, v9, v10, (char)"RTKitFirmware");
    return 1000;
  }
}

uint64_t sub_1000D9E6C(uint64_t a1, const __CFData *a2)
{
  const void *v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v4 = *(const void **)(a1 + 32);
  if (v4
  {
    if ((sub_1000D4AB4((uint64_t)v5, a2) & 1) == 0)
    {
      v14 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: Failed to set manifest\n", v15, v16, v17, v18, v19, (char)"RTKitFirmware");
      return 0;
    }
    v6 = 1;
  }
  else
  {
    v7 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v7, 2u, "%s::%s: Invalid firmware file\n", v8, v9, v10, v11, v12, (char)"RTKitFirmware");
    v6 = 0;
  }
  sub_1000DACD4(a1, a2);
  return v6;
}

uint64_t sub_1000D9F40(uint64_t a1, uint64_t a2)
{
  const void *v2;
  void *v4;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(const void **)(a1 + 32);
  if (v2)
  {
    if (v4)
      return (*(uint64_t (**)(void *, uint64_t))(*(_QWORD *)v4 + 32))(v4, a2);
  }
  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 2u, "%s::%s: Invalid firmware file\n", v7, v8, v9, v10, v11, (char)"RTKitFirmware");
  return 0;
}

void sub_1000D9FD4(uint64_t a1)
{
  void *v1;

  v1 = (void *)sub_1000DA3CC(a1);
  operator delete(v1);
}

uint64_t *sub_1000D9FE8(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000DA03C(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_1000DA024(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000CC004(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000DA03C(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_1000CD9C8(v5, v6, v4 + 4, (uint64_t)(v4 + 4));
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t sub_1000DA0C0(uint64_t result)
{
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)result = &off_100182DD0;
  *(_QWORD *)(result + 8) = result + 16;
  *(_QWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 48) = 0;
  *(_DWORD *)(result + 56) = 1;
  *(_QWORD *)(result + 64) = 0;
  *(_QWORD *)(result + 72) = 0;
  *(_BYTE *)(result + 80) = 0;
  return result;
}

void sub_1000DA0F0(uint64_t a1)
{
  sub_1000DB164(*(_QWORD *)(a1 + 32));
}

uint64_t sub_1000DA0F8(uint64_t a1, unint64_t a2)
{
  uint64_t (***v2)(_QWORD, _QWORD *);
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  _QWORD *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;

  v18 = a2;
  v2 = *(uint64_t (****)(_QWORD, _QWORD *))(a1 + 32);
  if (v2)
  {
    v5 = *(_QWORD **)(a1 + 16);
    v3 = (_QWORD *)(a1 + 16);
    v4 = v5;
    if (v5)
    {
      v6 = v3;
      do
      {
        v7 = v4[4];
        v8 = v7 >= a2;
        if (v7 >= a2)
          v9 = v4;
        else
          v9 = v4 + 1;
        if (v8)
          v6 = v4;
        v4 = (_QWORD *)*v9;
      }
      while (*v9);
      if (v6 != v3 && v6[4] <= a2)
      {
        v11 = sub_1000CB3A0((uint64_t)(v3 - 1), &v18);
        return (**v2)(v2, v11);
      }
    }
  }
  else
  {
    v12 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v12, 2u, "%s::%s: file not open\n", v13, v14, v15, v16, v17, (char)"ACFUFirmware");
  }
  return 0;
}

const void *sub_1000DA1B8(uint64_t a1, const void *a2)
{
  if (a2)
    return CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2);
  else
    return 0;
}

uint64_t sub_1000DA1CC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  if (*(_QWORD *)(a1 + 32))
  {
    v2 = *(_QWORD *)(a1 + 64);
    if (v2)
    {
      if (!sub_1000DC3CC(v2) && AMSupportMakeDirectory(*(_QWORD *)(a1 + 64), v3))
      {
        v23 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v23, 2u, "%s::%s: failed to create directory to save firmware (status: %d)\n", v24, v25, v26, v27, v28, (char)"ACFUFirmware");
        return 1003;
      }
      else if ((sub_1000DB298(*(_QWORD *)(a1 + 32), *(const __CFURL **)(a1 + 64)) & 1) != 0)
      {
        return 0;
      }
      else
      {
        v17 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v17, 2u, "%s::%s: Failed to save packaged firmware file\n", v18, v19, v20, v21, v22, (char)"ACFUFirmware");
        return 1004;
      }
    }
    else
    {
      v11 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v11, 2u, "%s::%s: savePath for FW not specified. This needs to be specified.\n", v12, v13, v14, v15, v16, (char)"ACFUFirmware");
      return 1014;
    }
  }
  else
  {
    v5 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v5, 2u, "%s::%s: fFirmwareFile has not been initialized.\n", v6, v7, v8, v9, v10, (char)"ACFUFirmware");
    return 1000;
  }
}

uint64_t sub_1000DA2F0(const void **a1, CFDictionaryRef theDict)
{
  const void *Value;
  const void *v4;
  CFTypeID v5;
  uint64_t v6;
  const char *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  Value = CFDictionaryGetValue(theDict, a1[9]);
  if (!Value)
  {
    v6 = 1001;
    v8 = "%s::%s: Manifest is not available\n";
LABEL_9:
    v9 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v9, 2u, v8, v10, v11, v12, v13, v14, (char)"ACFUFirmware");
    return v6;
  }
  v4 = Value;
  v5 = CFGetTypeID(Value);
  if (v5 != CFDataGetTypeID())
  {
    v6 = 4002;
    v8 = "%s::%s: Manifest is not present in expected data type\n";
    goto LABEL_9;
  }
  (*((void (**)(const void **, const void *))*a1 + 9))(a1, v4);
  if (((*((uint64_t (**)(const void **))*a1 + 8))(a1) & 1) == 0)
  {
    v6 = 1013;
    v8 = "%s::%s: Failed to measure firmware\n";
    goto LABEL_9;
  }
  return 0;
}

uint64_t sub_1000DA3CC(uint64_t a1)
{
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  uint64_t v6;

  *(_QWORD *)a1 = &off_100182DD0;
  v2 = *(const void **)(a1 + 48);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 48) = 0;
  }
  v3 = *(const void **)(a1 + 64);
  if (v3)
  {
    CFRelease(v3);
    *(_QWORD *)(a1 + 64) = 0;
  }
  v4 = *(const void **)(a1 + 72);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 72) = 0;
  }
  v5 = *(const void **)(a1 + 40);
  if (v5)
  {
    CFRelease(v5);
    *(_QWORD *)(a1 + 40) = 0;
  }
  v6 = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a1 + 32) = 0;
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 56))(v6);
  sub_1000CC004(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

uint64_t sub_1000DA468()
{
  void *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v0 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v0, 2u, "%s::%s: This function has not been implemented\n", v1, v2, v3, v4, v5, (char)"ACFUFirmware");
  return 0;
}

CFDataRef sub_1000DA4AC(uint64_t a1, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  int v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const void *v17;
  const void *v18;
  const void *v19;
  void *v20;
  int v21;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CC_SHA512_CTX v35;
  CC_SHA256_CTX c;
  unsigned __int8 md[8];

  v3 = a3;
  if ((*(char *)(a2 + 23) & 0x80000000) == 0)
  {
    if (*(_BYTE *)(a2 + 23))
      goto LABEL_3;
LABEL_9:
    v7 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v7, 2u, "%s::%s: no firmware file provided\n", v8, v9, v10, v11, v12, (char)"ACFUFirmware");
    return 0;
  }
  if (!*(_QWORD *)(a2 + 8))
    goto LABEL_9;
LABEL_3:
  if (!a3)
  {
    v29 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v29, 2u, "%s::%s: empty file\n", v30, v31, v32, v33, v34, (char)"ACFUFirmware");
    return 0;
  }
  v6 = *(_DWORD *)(a1 + 56);
  switch(v6)
  {
    case 2:
      CC_SHA512_Init(&v35);
      break;
    case 1:
      CC_SHA384_Init(&v35);
      break;
    case 0:
      CC_SHA256_Init(&c);
      break;
  }
  v13 = 0;
  do
  {
    if (v3 >= 0x100000)
      v14 = 0x100000;
    else
      v14 = v3;
    (*(void (**)(unsigned __int8 *__return_ptr, _QWORD, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 32)
                                                                                             + 8))(md, *(_QWORD *)(a1 + 32), a2, v13, v14);
    v15 = *(_QWORD *)md;
    if (!*(_QWORD *)md)
    {
      v23 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v23, 2u, "%s::%s: failed to obtain file data\n", v24, v25, v26, v27, v28, (char)"ACFUFirmware");
      return 0;
    }
    v16 = *(_DWORD *)(a1 + 56);
    if (v16)
    {
      if (v16 == 1)
      {
        v19 = (const void *)sub_1000CDCF8(*(uint64_t *)md);
        CC_SHA384_Update(&v35, v19, v14);
      }
      else if (v16 == 2)
      {
        v17 = (const void *)sub_1000CDCF8(*(uint64_t *)md);
        CC_SHA512_Update(&v35, v17, v14);
      }
    }
    else
    {
      v18 = (const void *)sub_1000CDCF8(*(uint64_t *)md);
      CC_SHA256_Update(&c, v18, v14);
    }
    v13 = (v14 + v13);
    v3 -= v14;
    v20 = (void *)sub_1000CDE2C(v15);
    operator delete(v20);
  }
  while (v3);
  v21 = *(_DWORD *)(a1 + 56);
  if (v21 == 2)
  {
    CC_SHA512_Final(md, &v35);
    return CFDataCreate(kCFAllocatorDefault, md, 64);
  }
  else if (v21 == 1)
  {
    CC_SHA384_Final(md, &v35);
    return CFDataCreate(kCFAllocatorDefault, md, 48);
  }
  else
  {
    if (v21)
      return 0;
    CC_SHA256_Final(md, &c);
    return CFDataCreate(kCFAllocatorDefault, md, 32);
  }
}

void sub_1000DA730(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

CFDataRef sub_1000DA760(uint64_t a1, CFDataRef theData)
{
  int v3;
  const UInt8 *v4;
  CC_LONG v5;
  const __CFAllocator *v6;
  CFIndex v7;
  const UInt8 *BytePtr;
  CC_LONG Length;
  const UInt8 *v10;
  CC_LONG v11;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned __int8 md[64];

  v3 = *(_DWORD *)(a1 + 56);
  switch(v3)
  {
    case 2:
      BytePtr = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(theData);
      if (CC_SHA512(BytePtr, Length, md) == md)
      {
        v6 = kCFAllocatorDefault;
        v7 = 64;
        return CFDataCreate(v6, md, v7);
      }
      v19 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: SHA512 failed\n", v20, v21, v22, v23, v24, (char)"ACFUFirmware");
      break;
    case 1:
      v10 = CFDataGetBytePtr(theData);
      v11 = CFDataGetLength(theData);
      if (CC_SHA384(v10, v11, md) == md)
      {
        v6 = kCFAllocatorDefault;
        v7 = 48;
        return CFDataCreate(v6, md, v7);
      }
      v25 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v25, 2u, "%s::%s: SHA384 failed\n", v26, v27, v28, v29, v30, (char)"ACFUFirmware");
      break;
    case 0:
      v4 = CFDataGetBytePtr(theData);
      v5 = CFDataGetLength(theData);
      if (CC_SHA256(v4, v5, md) == md)
      {
        v6 = kCFAllocatorDefault;
        v7 = 32;
        return CFDataCreate(v6, md, v7);
      }
      v13 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: SHA256 failed\n", v14, v15, v16, v17, v18, (char)"ACFUFirmware");
      break;
  }
  return 0;
}

BOOL sub_1000DA918(uint64_t a1, uint64_t **a2)
{
  uint64_t **v3;
  CFMutableDictionaryRef Mutable;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = (uint64_t **)(a1 + 8);
  if (v3 != a2)
    sub_1000DAE9C(v3, *a2, a2 + 1);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_QWORD *)(a1 + 40) = Mutable;
  if (!Mutable)
  {
    v6 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v6, 2u, "%s::%s: Failed to allocate measurements dict\n", v7, v8, v9, v10, v11, (char)"ACFUFirmware");
  }
  return Mutable != 0;
}

uint64_t sub_1000DA9B8(uint64_t a1)
{
  _QWORD *v1;
  _QWORD *v2;
  unsigned int v4;
  unsigned int v5;
  const __CFData *v6;
  const __CFData *v7;
  CFDataRef v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  BOOL v17;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *__p[2];
  uint64_t v26;
  __int128 __dst;
  uint64_t v28;
  void *__src[2];
  uint64_t v30;

  v1 = *(_QWORD **)(a1 + 8);
  v2 = (_QWORD *)(a1 + 16);
  if (v1 == (_QWORD *)(a1 + 16))
    return 1;
  while (1)
  {
    if (!*(_BYTE *)(a1 + 80))
    {
      v6 = (const __CFData *)sub_1000DA0F8(a1, v1[4]);
      if (v6)
      {
        v7 = v6;
        v8 = sub_1000DA760(a1, v6);
        CFRelease(v7);
        if (!v8)
          break;
        goto LABEL_16;
      }
      sub_1000DC1B8((const __CFString *)v1[4], __src);
      if (SHIBYTE(v30) < 0)
      {
        if (__src[1])
        {
          sub_1000CB554(&__dst, __src[0], (unint64_t)__src[1]);
          goto LABEL_29;
        }
      }
      else if (HIBYTE(v30))
      {
        __dst = *(_OWORD *)__src;
        v28 = v30;
        goto LABEL_29;
      }
      sub_1000CB3F4(&__dst, "UNDEF");
LABEL_29:
      if (SHIBYTE(v30) < 0)
        operator delete(__src[0]);
      goto LABEL_31;
    }
    v4 = (*(uint64_t (**)(uint64_t, _QWORD *))(*(_QWORD *)a1 + 40))(a1, v1 + 5);
    if (!v4)
    {
      sub_1000DC1B8((const __CFString *)v1[4], __src);
      if (SHIBYTE(v30) < 0)
      {
        if (__src[1])
        {
          sub_1000CB554(&__dst, __src[0], (unint64_t)__src[1]);
          goto LABEL_23;
        }
      }
      else if (HIBYTE(v30))
      {
        __dst = *(_OWORD *)__src;
        v28 = v30;
        goto LABEL_23;
      }
      sub_1000CB3F4(&__dst, "UNDEF");
LABEL_23:
      if (SHIBYTE(v30) < 0)
        operator delete(__src[0]);
LABEL_31:
      *(_OWORD *)__src = __dst;
      v30 = v28;
      v9 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v9, 3u, "%s::%s: no fw for tag '%s'\n", v10, v11, v12, v13, v14, (char)"ACFUFirmware");
      if (SHIBYTE(v30) < 0)
        operator delete(__src[0]);
      goto LABEL_33;
    }
    v5 = v4;
    if (*((char *)v1 + 63) < 0)
    {
      sub_1000CB554(__p, (void *)v1[5], v1[6]);
    }
    else
    {
      *(_OWORD *)__p = *(_OWORD *)(v1 + 5);
      v26 = v1[7];
    }
    v8 = sub_1000DA4AC(a1, (uint64_t)__p, v5);
    if (SHIBYTE(v26) < 0)
      operator delete(__p[0]);
    if (!v8)
      break;
LABEL_16:
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), (const void *)v1[4], v8);
    CFRelease(v8);
LABEL_33:
    v15 = (_QWORD *)v1[1];
    if (v15)
    {
      do
      {
        v16 = v15;
        v15 = (_QWORD *)*v15;
      }
      while (v15);
    }
    else
    {
      do
      {
        v16 = (_QWORD *)v1[2];
        v17 = *v16 == (_QWORD)v1;
        v1 = v16;
      }
      while (!v17);
    }
    v1 = v16;
    if (v16 == v2)
      return 1;
  }
  v19 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: failed to measure fw\n", v20, v21, v22, v23, v24, (char)"ACFUFirmware");
  return 0;
}

void sub_1000DAC98(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *__p,uint64_t a25,int a26,__int16 a27,char a28,char a29)
{
  if (a29 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL sub_1000DACD4(uint64_t a1, const __CFData *a2)
{
  const void *v4;
  const __CFData *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  __int128 v16;
  const UInt8 *BytePtr;
  CFIndex Length;
  std::string v20;
  std::string v21;
  __int128 v22;
  std::string::size_type v23;

  v4 = *(const void **)(a1 + 48);
  if (v4)
  {
    CFRelease(v4);
    *(_QWORD *)(a1 + 48) = 0;
  }
  AMSupportSafeRetain(a2);
  *(_QWORD *)(a1 + 48) = a2;
  v5 = sub_1000DA760(a1, a2);
  v6 = sub_1000D3C90();
  if (v5)
  {
    sub_1000D3D08((uint64_t)v6, 0, "%s::%s: Manifest digest\n", v7, v8, v9, v10, v11, (char)"ACFUFirmware");
    v12 = sub_1000D3C90();
    sub_1000CB3F4(&v20, "ACFUFirmware");
    v13 = std::string::append(&v20, "::");
    v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    v15 = std::string::append(&v21, "setManifest");
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v23 = v15->__r_.__value_.__r.__words[2];
    v22 = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    BytePtr = CFDataGetBytePtr(v5);
    Length = CFDataGetLength(v5);
    sub_1000D3F7C((uint64_t)v12, (uint64_t *)&v22, 0, (uint64_t)BytePtr, Length, 1);
    if (SHIBYTE(v23) < 0)
      operator delete((void *)v22);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v21.__r_.__value_.__l.__data_);
    if (SHIBYTE(v20.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v20.__r_.__value_.__l.__data_);
    CFRelease(v5);
  }
  else
  {
    sub_1000D3D08((uint64_t)v6, 2u, "%s::%s: Digest of manifest failed\n", v7, v8, v9, v10, v11, (char)"ACFUFirmware");
  }
  return v5 != 0;
}

void sub_1000DAE50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t **sub_1000DAE9C(uint64_t **result, _QWORD *a2, _QWORD *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t **v14;
  uint64_t *v15;
  uint64_t *v16;

  v5 = result;
  if (result[2])
  {
    v6 = *result;
    v7 = result[1];
    *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1])
      v8 = (uint64_t *)v6[1];
    else
      v8 = v6;
    v14 = result;
    v15 = v8;
    v16 = v8;
    if (v8)
    {
      v15 = sub_1000CBCCC((uint64_t)v8);
      if (a2 != a3)
      {
        v9 = a2;
        do
        {
          v8[4] = v9[4];
          std::string::operator=((std::string *)(v8 + 5), (const std::string *)(v9 + 5));
          sub_1000DB008(v5, v16);
          v8 = v15;
          v16 = v15;
          if (v15)
            v15 = sub_1000CBCCC((uint64_t)v15);
          v10 = (_QWORD *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              v10 = (_QWORD *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (_QWORD *)v9[2];
              v11 = *a2 == (_QWORD)v9;
              v9 = a2;
            }
            while (!v11);
          }
          if (!v8)
            break;
          v9 = a2;
        }
        while (a2 != a3);
      }
    }
    result = (uint64_t **)sub_1000DB074((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      result = (uint64_t **)sub_1000DB0C8((uint64_t)v5, (uint64_t)(a2 + 4));
      v12 = (_QWORD *)a2[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (_QWORD *)a2[2];
          v11 = *v13 == (_QWORD)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1000DAFF4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000DB074((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *sub_1000DB008(uint64_t **a1, uint64_t *a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t **v5;

  v3 = a1 + 1;
  v4 = a1[1];
  if (v4)
  {
    do
    {
      while (1)
      {
        v3 = (uint64_t **)v4;
        if (a2[4] >= (unint64_t)v4[4])
          break;
        v4 = (uint64_t *)*v4;
        v5 = v3;
        if (!*v3)
          goto LABEL_8;
      }
      v4 = (uint64_t *)v4[1];
    }
    while (v4);
    v5 = v3 + 1;
  }
  else
  {
    v5 = a1 + 1;
  }
LABEL_8:
  sub_1000CBAE0(a1, (uint64_t)v3, v5, a2);
  return a2;
}

uint64_t sub_1000DB074(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  sub_1000CC004(*(_QWORD *)a1, *(char **)(a1 + 16));
  v2 = *(_QWORD *)(a1 + 8);
  if (v2)
  {
    v3 = *(_QWORD *)(v2 + 16);
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = *(_QWORD *)(v3 + 16);
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    sub_1000CC004(*(_QWORD *)a1, (char *)v2);
  }
  return a1;
}

uint64_t *sub_1000DB0C8(uint64_t a1, uint64_t a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t **v5;
  uint64_t *v7;

  sub_1000CDBF0(a1, a2, (uint64_t)&v7);
  v3 = (uint64_t **)(a1 + 8);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
    do
    {
      while (1)
      {
        v3 = (uint64_t **)v4;
        if (v7[4] >= (unint64_t)v4[4])
          break;
        v4 = (uint64_t *)*v4;
        v5 = v3;
        if (!*v3)
          goto LABEL_8;
      }
      v4 = (uint64_t *)v4[1];
    }
    while (v4);
    v5 = v3 + 1;
  }
  else
  {
    v5 = (uint64_t **)(a1 + 8);
  }
LABEL_8:
  sub_1000CBAE0((uint64_t **)a1, (uint64_t)v3, v5, v7);
  return v7;
}

uint64_t sub_1000DB148(uint64_t result)
{
  *(_QWORD *)result = &off_100182E40;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_BYTE *)(result + 32) = 1;
  return result;
}

void sub_1000DB164(uint64_t a1)
{
  const __CFData *v1;
  const __CFData *v2;
  const UInt8 *BytePtr;
  unint64_t Length;
  _BYTE *v5;
  char v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  _OWORD v25[7];
  __int128 v26;

  v26 = 0u;
  memset(v25, 0, sizeof(v25));
  v1 = (const __CFData *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1);
  if (v1)
  {
    v2 = v1;
    BytePtr = CFDataGetBytePtr(v1);
    Length = CFDataGetLength(v2);
    if (Length > 0x7F)
    {
      v19 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: data exceeds local buffer size\n", v20, v21, v22, v23, v24, (char)"ACFUFile");
    }
    else
    {
      if (Length)
      {
        v5 = v25;
        do
        {
          v6 = *BytePtr++;
          *v5++ = v6;
          --Length;
        }
        while (Length);
      }
      HIBYTE(v26) = 0;
      v7 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v7, 0, "%s::%s: Firmware Version: %s\n", v8, v9, v10, v11, v12, (char)"ACFUFile");
    }
    CFRelease(v2);
  }
  else
  {
    v13 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: no data to log\n", v14, v15, v16, v17, v18, (char)"ACFUFile");
  }
}

uint64_t sub_1000DB298(uint64_t a1, const __CFURL *a2)
{
  uint64_t v3;
  CFURLRef v5;
  const __CFURL *v6;
  uint64_t v7;
  uint64_t v8;
  CFIndex v9;
  off_t v10;
  void *v11;
  const __CFString *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  void *__p;
  char v75;

  if (!a2)
  {
    v20 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: bad parameters\n", v21, v22, v23, v24, v25, (char)"ACFUFile");
    return 0;
  }
  if (!*(_QWORD *)(a1 + 24))
  {
    v26 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v26, 2u, "%s::%s: file name not specified\n", v27, v28, v29, v30, v31, (char)"ACFUFile");
    return 0;
  }
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
  {
    v32 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v32, 2u, "%s::%s: no file data?!\n", v33, v34, v35, v36, v37, (char)"ACFUFile");
    return 0;
  }
  if (sub_1000CEE04(v3))
  {
    v38 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v38, 2u, "%s::%s: cannot save data using optimized flow\n", v39, v40, v41, v42, v43, (char)"ACFUFile");
    return 0;
  }
  v5 = CFURLCreateCopyAppendingPathComponent(kCFAllocatorDefault, a2, *(CFStringRef *)(a1 + 24), 0);
  if (!v5)
  {
    v44 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v44, 2u, "%s::%s: could not create URL to file\n", v45, v46, v47, v48, v49, (char)"ACFUFile");
    return 0;
  }
  v6 = v5;
  if (!sub_1000DC3CC((uint64_t)v5) && AMSupportMakeDirectory(v6, v7))
  {
    v68 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v68, 2u, "%s::%s: failed to create directory to save firmware (status: %d)\n", v69, v70, v71, v72, v73, (char)"ACFUFile");
    goto LABEL_26;
  }
  v8 = sub_1000CEDB0(*(_BYTE **)(a1 + 8));
  if (!v8)
  {
    v50 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v50, 2u, "%s::%s: failed to obtain reference of data from data container\n", v51, v52, v53, v54, v55, (char)"ACFUFile");
LABEL_26:
    v18 = 0;
    goto LABEL_14;
  }
  if (AMSupportWriteDataToFileURL(kCFAllocatorDefault, v8, v6, 1))
  {
    v56 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v56, 2u, "%s::%s: failed to save file (%d)\n", v57, v58, v59, v60, v61, (char)"ACFUFile");
    goto LABEL_26;
  }
  v9 = sub_1000CE8C8(*(_QWORD *)(a1 + 8));
  v10 = sub_1000DB974(v6);
  v11 = sub_1000D3C90();
  v12 = CFURLGetString(v6);
  sub_1000DC1B8(v12, &__p);
  sub_1000D3D08((uint64_t)v11, 0, "%s::%s: Wrote %zu of %zu bytes to %s\n", v13, v14, v15, v16, v17, (char)"ACFUFile");
  if (v75 < 0)
    operator delete(__p);
  if (v9 != v10)
  {
    v62 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v62, 2u, "%s::%s: Failed to write some or all of data\n", v63, v64, v65, v66, v67, (char)"ACFUFile");
    goto LABEL_26;
  }
  v18 = 1;
LABEL_14:
  CFRelease(v6);
  return v18;
}

void sub_1000DB544(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

__CFData *sub_1000DB560(uint64_t a1)
{
  return sub_1000CE410(*(_QWORD *)(a1 + 8));
}

_QWORD *sub_1000DB568(_QWORD *a1)
{
  const void *v2;

  *a1 = &off_100182E40;
  v2 = (const void *)a1[2];
  if (v2)
  {
    CFRelease(v2);
    a1[2] = 0;
  }
  sub_1000CEE60(a1 + 1, 0);
  return a1;
}

uint64_t sub_1000DB5BC(uint64_t a1, const void *a2)
{
  CFTypeID TypeID;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  if (!*(_QWORD *)(a1 + 24))
  {
    v10 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v10, 2u, "%s::%s: no file name specified\n", v11, v12, v13, v14, v15, (char)"ACFUFile");
    return 0;
  }
  if (!a2)
  {
    v16 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v16, 2u, "%s::%s: bad parameter!\n", v17, v18, v19, v20, v21, (char)"ACFUFile");
    return 0;
  }
  TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    v22 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v22, 2u, "%s::%s: data is of an unsupported type\n", v23, v24, v25, v26, v27, (char)"ACFUFile");
    return 0;
  }
  sub_1000CDE30((const __CFData *)a2, &v34);
  v5 = (uint64_t *)(a1 + 8);
  v6 = v34;
  v34 = 0;
  sub_1000CEE60(v5, v6);
  v7 = v34;
  v34 = 0;
  if (v7)
  {
    v8 = (void *)sub_1000CEE5C(v7);
    operator delete(v8);
  }
  if (!*v5)
  {
    v28 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: failed to create data container\n", v29, v30, v31, v32, v33, (char)"ACFUFile");
    return 0;
  }
  return 1;
}

uint64_t sub_1000DB6EC(uint64_t a1, const void *a2)
{
  CFTypeID TypeID;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  if (!*(_QWORD *)(a1 + 24))
  {
    v10 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v10, 2u, "%s::%s: no file name specified\n", v11, v12, v13, v14, v15, (char)"ACFUFile");
    return 0;
  }
  if (!a2)
  {
    v16 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v16, 2u, "%s::%s: bad parameter!\n", v17, v18, v19, v20, v21, (char)"ACFUFile");
    return 0;
  }
  TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(a2))
  {
    v22 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v22, 2u, "%s::%s: data is of an unsupported type\n", v23, v24, v25, v26, v27, (char)"ACFUFile");
    return 0;
  }
  sub_1000CDF90(a2, &v34);
  v5 = (uint64_t *)(a1 + 8);
  v6 = v34;
  v34 = 0;
  sub_1000CEE60(v5, v6);
  v7 = v34;
  v34 = 0;
  if (v7)
  {
    v8 = (void *)sub_1000CEE5C(v7);
    operator delete(v8);
  }
  if (!*v5)
  {
    v28 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: failed to create data container\n", v29, v30, v31, v32, v33, (char)"ACFUFile");
    return 0;
  }
  return 1;
}

BOOL sub_1000DB81C(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v4;
  const __CFString *v6;
  const __CFString *v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  _BOOL8 v13;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  if (!a2)
  {
    v15 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v15, 2u, "%s::%s: bad parameter!\n", v16, v17, v18, v19, v20, (char)"ACFUFile");
    return 0;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (!v4)
  {
    v21 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v21, 2u, "%s::%s: file name does not exist\n", v22, v23, v24, v25, v26, (char)"ACFUFile");
    return 0;
  }
  v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@/%@"), a2, v4);
  if (!v6)
  {
    v27 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v27, 2u, "%s::%s: failed to create ftab file path\n", v28, v29, v30, v31, v32, (char)"ACFUFile");
    return 0;
  }
  v7 = v6;
  sub_1000CE0E0(v6, a3, &v39);
  v8 = (uint64_t *)(a1 + 8);
  v9 = v39;
  v39 = 0;
  sub_1000CEE60(v8, v9);
  v10 = v39;
  v39 = 0;
  if (v10)
  {
    v11 = (void *)sub_1000CEE5C(v10);
    operator delete(v11);
  }
  v12 = *v8;
  v13 = *v8 != 0;
  if (!v12)
  {
    v33 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v33, 2u, "%s::%s: failed to create data container\n", v34, v35, v36, v37, v38, (char)"ACFUFile");
  }
  CFRelease(v7);
  return v13;
}

off_t sub_1000DB974(const __CFURL *a1)
{
  int v2;
  int v3;
  off_t st_size;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  stat v25;
  UInt8 buffer[1024];

  bzero(buffer, 0x400uLL);
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    v6 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v6, 2u, "%s::%s: failed to get file system reprensetation\n", v7, v8, v9, v10, v11, (char)"ACFUCommon");
    st_size = 0;
    v3 = -1;
    goto LABEL_5;
  }
  v2 = open((const char *)buffer, 0);
  v3 = v2;
  if (v2 < 0)
  {
    v12 = sub_1000D3C90();
    v13 = __error();
    strerror(*v13);
    sub_1000D3D08((uint64_t)v12, 2u, "%s::%s: failed to open file (%s)\n", v14, v15, v16, v17, v18, (char)"ACFUCommon");
    st_size = 0;
    goto LABEL_5;
  }
  if (fstat(v2, &v25))
  {
    v19 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: failed to get file stats\n", v20, v21, v22, v23, v24, (char)"ACFUCommon");
    st_size = 0;
    if (!v3)
      return st_size;
    goto LABEL_5;
  }
  st_size = v25.st_size;
  if (v3)
LABEL_5:
    close(v3);
  return st_size;
}

__CFData *sub_1000DBAD8(uint64_t a1)
{
  const __CFURL *URLFromString;
  const __CFURL *v3;
  off_t v4;
  unint64_t v5;
  FILE *v6;
  FILE *v7;
  __CFData *Mutable;
  uint64_t v9;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  UInt8 __ptr[4096];
  UInt8 v60[1024];

  bzero(__ptr, 0x1000uLL);
  if (!a1)
  {
    v23 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v23, 2u, "%s::%s: no file path provided\n", v24, v25, v26, v27, v28, (char)"ACFUCommon");
    return 0;
  }
  URLFromString = (const __CFURL *)AMSupportCreateURLFromString(kCFAllocatorDefault, a1);
  if (!URLFromString)
  {
    v29 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v29, 2u, "%s::%s: failed to create url from string\n", v30, v31, v32, v33, v34, (char)"ACFUCommon");
    return 0;
  }
  v3 = URLFromString;
  v4 = sub_1000DB974(URLFromString);
  if (v4)
  {
    v5 = v4;
    bzero(v60, 0x400uLL);
    if (CFURLGetFileSystemRepresentation(v3, 1u, v60, 1024))
    {
      v6 = fopen((const char *)v60, "r");
      if (v6)
      {
        v7 = v6;
        Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
        if (Mutable)
        {
          while (1)
          {
            v9 = v5 >= 0x1000 ? 4096 : v5;
            if (v9 != fread(__ptr, 1uLL, v9, v7))
              break;
            if (feof(v7) || ferror(v7) < 0)
            {
              v11 = sub_1000D3C90();
              ferror(v7);
              sub_1000D3D08((uint64_t)v11, 2u, "%s::%s: file i/o error (code: %d)\n", v12, v13, v14, v15, v16, (char)"ACFUCommon");
              goto LABEL_19;
            }
            CFDataAppendBytes(Mutable, __ptr, v9);
            v5 -= v9;
            if (!v5)
              goto LABEL_14;
          }
          v17 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v17, 2u, "%s::%s: read less bytes than required (read: %zu, required: %zu)\n", v18, v19, v20, v21, v22, (char)"ACFUCommon");
LABEL_19:
          CFRelease(Mutable);
          Mutable = 0;
        }
        else
        {
          v53 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v53, 2u, "%s::%s: failed to create mutable data\n", v54, v55, v56, v57, v58, (char)"ACFUCommon");
        }
LABEL_14:
        fclose(v7);
        goto LABEL_15;
      }
    }
    else
    {
      v41 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v41, 2u, "%s::%s: failed to get file system reprensetation\n", v42, v43, v44, v45, v46, (char)"ACFUCommon");
    }
    v47 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v47, 2u, "%s::%s: bad input file parameters\n", v48, v49, v50, v51, v52, (char)"ACFUCommon");
  }
  else
  {
    v35 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v35, 2u, "%s::%s: file is empty (file size: %zu)\n", v36, v37, v38, v39, v40, (char)"ACFUCommon");
  }
  Mutable = 0;
LABEL_15:
  CFRelease(v3);
  return Mutable;
}

void sub_1000DBDD4(const __CFDictionary *a1@<X0>, const char *a2@<X1>, _DWORD *a3@<X8>)
{
  const __CFDictionary *v5;
  const __CFDictionary *Value;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  CFTypeID TypeID;
  const __CFString *v15;
  const __CFString *v16;
  CFTypeID v17;
  char *v18;
  int v19;
  int v20;
  size_t v21;
  BOOL v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  int v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  void *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  std::string __str;
  char *__stringp;
  char buffer[16];
  __int128 v76;
  __int128 v77;
  __int128 v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  __int128 v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;

  v105 = 0u;
  v106 = 0u;
  v103 = 0u;
  v104 = 0u;
  v101 = 0u;
  v102 = 0u;
  v99 = 0u;
  v100 = 0u;
  v97 = 0u;
  v98 = 0u;
  v95 = 0u;
  v96 = 0u;
  v93 = 0u;
  v94 = 0u;
  v91 = 0u;
  v92 = 0u;
  v89 = 0u;
  v90 = 0u;
  v87 = 0u;
  v88 = 0u;
  v85 = 0u;
  v86 = 0u;
  v83 = 0u;
  v84 = 0u;
  v81 = 0u;
  v82 = 0u;
  v79 = 0u;
  v80 = 0u;
  v77 = 0u;
  v78 = 0u;
  *(_OWORD *)buffer = 0u;
  v76 = 0u;
  if (!a1)
  {
    v37 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v37, 2u, "%s::%s: Empty options dict\n", v38, v39, v40, v41, v42, (char)"ACFUCommon");
LABEL_29:
    v19 = 0;
    v20 = 4006;
    goto LABEL_30;
  }
  if (!a2)
  {
    v43 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v43, 2u, "%s::%s: Invalid arguments to parseDebugArgs\n", v44, v45, v46, v47, v48, (char)"ACFUCommon");
    v19 = 0;
    v20 = 4005;
    goto LABEL_30;
  }
  v5 = a1;
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("Options"));
  v7 = sub_1000D3C90();
  if (Value)
    v13 = "%s::%s: Found updater options in dictionary\n";
  else
    v13 = "%s::%s: Assuming updater options dictionary is being passed\n";
  if (Value)
    v5 = Value;
  sub_1000D3D08((uint64_t)v7, 3u, v13, v8, v9, v10, v11, v12, (char)"ACFUCommon");
  TypeID = CFDictionaryGetTypeID();
  if (TypeID != CFGetTypeID(v5))
  {
    v49 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v49, 2u, "%s::%s: Invalid Type of Updater Options dict\n", v50, v51, v52, v53, v54, (char)"ACFUCommon");
LABEL_32:
    v19 = 0;
    v20 = 4002;
    goto LABEL_30;
  }
  v15 = (const __CFString *)CFDictionaryGetValue(v5, CFSTR("ACFUDebugArgs"));
  if (!v15)
  {
    v55 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v55, 2u, "%s::%s: Empty DebugArgs\n", v56, v57, v58, v59, v60, (char)"ACFUCommon");
    goto LABEL_29;
  }
  v16 = v15;
  v17 = CFStringGetTypeID();
  if (v17 != CFGetTypeID(v16))
  {
    v61 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v61, 2u, "%s::%s: Invalid Type of DebugArgs\n", v62, v63, v64, v65, v66, (char)"ACFUCommon");
    goto LABEL_32;
  }
  if (CFStringGetCString(v16, buffer, 512, 0x8000100u))
  {
    __stringp = buffer;
    v18 = strsep(&__stringp, " ");
    if (v18)
    {
      v19 = 0;
      v20 = 4006;
      while (1)
      {
        v21 = strlen(a2);
        if (!strncmp(v18, a2, v21))
        {
          v22 = v18[v21] == 61;
          v23 = sub_1000D3C90();
          if (!v22)
          {
            sub_1000D3D08((uint64_t)v23, 2u, "%s::%s: Invalid token: %s\n", v24, v25, v26, v27, v28, (char)"ACFUCommon");
            goto LABEL_24;
          }
          sub_1000D3D08((uint64_t)v23, 3u, "%s::%s: Token: %s\n", v24, v25, v26, v27, v28, (char)"ACFUCommon");
          v29 = strchr(v18, 61);
          if (!v29)
          {
            v31 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v31, 2u, "%s::%s: Missing = for key: %s\n", v32, v33, v34, v35, v36, (char)"ACFUCommon");
            goto LABEL_24;
          }
          sub_1000CB3F4(&__str, v29 + 1);
          v30 = std::stoul(&__str, 0, 0);
          if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
            operator delete(__str.__r_.__value_.__l.__data_);
          v20 = 0;
          v19 = v30;
        }
        v18 = strsep(&__stringp, " ");
        if (!v18)
          goto LABEL_30;
      }
    }
    goto LABEL_29;
  }
  v67 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v67, 2u, "%s::%s: Failed to get DebugArgs buffer\n", v68, v69, v70, v71, v72, (char)"ACFUCommon");
  v19 = 0;
LABEL_24:
  v20 = 4007;
LABEL_30:
  *a3 = v19;
  a3[1] = v20;
}

#error "1000DC184: call analysis failed (funcsize=28)"

void sub_1000DC1B8(const __CFString *a1@<X0>, _QWORD *a2@<X8>)
{
  CFStringEncoding SystemEncoding;
  const char *CStringPtr;
  char *v6;
  char *v7;
  CFIndex v8;
  char *v9;
  CFStringEncoding v10;
  __int128 v11;
  uint64_t v12;

  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a1)
  {
    SystemEncoding = CFStringGetSystemEncoding();
    CStringPtr = CFStringGetCStringPtr(a1, SystemEncoding);
    if (CStringPtr)
    {
      v6 = (char *)CStringPtr;
      v7 = 0;
    }
    else
    {
      v8 = CFStringGetLength(a1) + 1;
      v9 = (char *)malloc(v8);
      v7 = v9;
      v6 = "";
      if (v9)
      {
        bzero(v9, v8);
        v10 = CFStringGetSystemEncoding();
        if (CFStringGetCString(a1, v7, v8, v10))
          v6 = v7;
      }
    }
  }
  else
  {
    v7 = 0;
    v6 = "";
  }
  sub_1000CB3F4(&v11, v6);
  *(_OWORD *)a2 = v11;
  a2[2] = v12;
  if (v7)
    free(v7);
}

void sub_1000DC2A4(CFTypeID a1@<X0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  CFStringRef v6;
  const __CFString *v7;
  const __CFString *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __int128 v21;
  uint64_t v22;

  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  v6 = CFCopyTypeIDDescription(a1);
  v7 = v6;
  if (!v6)
  {
    v15 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v15, 2u, "%s::%s: failed to copy type description for type ID %lu\n", v16, v17, v18, v19, v20, (char)"ACFUCommon");
    return;
  }
  if (!a2)
  {
    CFRetain(v6);
    v8 = v7;
    goto LABEL_6;
  }
  v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@ (%lu)"), v6, a1);
  if (v8)
  {
LABEL_6:
    sub_1000DC1B8(v8, &v21);
    *(_OWORD *)a3 = v21;
    a3[2] = v22;
    CFRelease(v8);
    goto LABEL_7;
  }
  v9 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v9, 2u, "%s::%s: failed to create full description for type ID %lu\n", v10, v11, v12, v13, v14, (char)"ACFUCommon");
LABEL_7:
  CFRelease(v7);
}

void sub_1000DC3B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

BOOL sub_1000DC3CC(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  std::string *v9;
  __int128 v10;
  std::string *v11;
  __int128 v12;
  std::string v14;
  std::string v15;
  __int128 v16;
  std::string::size_type v17;
  char v18;

  v18 = 0;
  if (AMSupportFileURLExists(a1, &v18))
  {
    v2 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v2, 2u, "%s::%s: failed to determine if url exists (%u)\n", v3, v4, v5, v6, v7, (char)"ACFUCommon");
    v8 = sub_1000D3C90();
    sub_1000CB3F4(&v14, "ACFUCommon");
    v9 = std::string::append(&v14, "::");
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v15.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v15.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    v11 = std::string::append(&v15, "doesPathExist");
    v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
    v17 = v11->__r_.__value_.__r.__words[2];
    v16 = v12;
    v11->__r_.__value_.__l.__size_ = 0;
    v11->__r_.__value_.__r.__words[2] = 0;
    v11->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v8, (uint64_t *)&v16, 0, (uint64_t)"Path URL: ", a1);
    if (SHIBYTE(v17) < 0)
      operator delete((void *)v16);
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v15.__r_.__value_.__l.__data_);
    if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v14.__r_.__value_.__l.__data_);
  }
  return v18 == 1;
}

void sub_1000DC4F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  if (*(char *)(v23 - 41) < 0)
    operator delete(*(void **)(v23 - 64));
  if (a23 < 0)
    operator delete(__p);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DC540(const void *a1)
{
  CFTypeID v2;
  void *v3;
  std::string *v4;
  __int128 v5;
  std::string *v6;
  __int128 v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  std::string v21;
  std::string v22;
  __int128 v23;
  std::string::size_type v24;

  if (a1 && (v2 = CFURLGetTypeID(), v2 == CFGetTypeID(a1)))
  {
    v3 = sub_1000D3C90();
    sub_1000CB3F4(&v21, "ACFUCommon");
    v4 = std::string::append(&v21, "::");
    v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v22.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v22.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    v6 = std::string::append(&v22, "removeFileWithURL");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v24 = v6->__r_.__value_.__r.__words[2];
    v23 = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v3, (uint64_t *)&v23, 0, (uint64_t)"Removing file at URL: ", (uint64_t)a1);
    if (SHIBYTE(v24) < 0)
      operator delete((void *)v23);
    if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v22.__r_.__value_.__l.__data_);
    if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v21.__r_.__value_.__l.__data_);
    if (!AMSupportRemoveFile(a1))
      return 1;
    v8 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v8, 2u, "%s::%s: failed to remove file (%u)\n", v9, v10, v11, v12, v13, (char)"ACFUCommon");
  }
  else
  {
    v14 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v14, 2u, "%s::%s: failed due to unexpected data type\n", v15, v16, v17, v18, v19, (char)"ACFUCommon");
  }
  return 0;
}

void sub_1000DC6A0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  if (*(char *)(v23 - 41) < 0)
    operator delete(*(void **)(v23 - 64));
  if (a23 < 0)
    operator delete(__p);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1000DC6EC(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_1000CB740(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000DC748(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1000DC764(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  std::ostream::sentry::sentry(v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, &std::ctype<char>::id);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!sub_1000DC8C8(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  std::ostream::sentry::~sentry(v13);
  return a1;
}

void sub_1000DC86C(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  std::ostream::sentry::~sentry(&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1000DC84CLL);
}

void sub_1000DC8B4(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t sub_1000DC8C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      sub_1000DCA04(__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_1000DC9E8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1000DCA04(_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    sub_1000CB4A4();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(_QWORD *)v3 = &off_100182EC8;
  if (*(_DWORD *)(v3 + 56) != 54)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return a1;
}

void sub_1000DCB20(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000DCB48(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *a1 = &off_1001830A8;
  v2 = (void *)a1[19];
  if (v2)
  {
    a1[20] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }
  v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  v6 = (void *)a1[4];
  if (v6)
  {
    a1[5] = v6;
    operator delete(v6);
  }
  return a1;
}

SERestoreInfo::SN300V2DeviceInfo *SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo(SERestoreInfo::SN300V2DeviceInfo *this, SERestoreInfo **a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_100182EC8;
  if (*((_DWORD *)v3 + 14) != 54)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return this;
}

void sub_1000DCC40(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

void sub_1000DCC68(_QWORD *__p)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *__p = &off_1001830A8;
  v2 = (void *)__p[19];
  if (v2)
  {
    __p[20] = v2;
    operator delete(v2);
  }
  v3 = (void *)__p[14];
  if (v3)
  {
    __p[15] = v3;
    operator delete(v3);
  }
  v4 = (void *)__p[11];
  if (v4)
  {
    __p[12] = v4;
    operator delete(v4);
  }
  v5 = (void *)__p[8];
  if (v5)
  {
    __p[9] = v5;
    operator delete(v5);
  }
  v6 = (void *)__p[4];
  if (v6)
  {
    __p[5] = v6;
    operator delete(v6);
  }
  operator delete(__p);
}

_QWORD *sub_1000DCCE8@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_1000DCDC0(a2, *(const void **)(a1 + 112), *(_QWORD *)(a1 + 120), *(_QWORD *)(a1 + 120) - *(_QWORD *)(a1 + 112));
}

uint64_t sub_1000DCD14(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

_QWORD *sub_1000DCD1C(_QWORD *a1)
{
  void *__p[2];
  char v4;

  sub_1000CB3F4(__p, "Wrong DeviceInfo");
  SERestoreInfo::SEException::SEException((uint64_t)a1, (__int128 *)__p, 2, CFSTR("SEUpdaterErrorDomain"));
  if (v4 < 0)
    operator delete(__p[0]);
  *a1 = &off_100182F30;
  return a1;
}

void sub_1000DCD90(std::exception *a1)
{
  void *v1;

  SERestoreInfo::SEException::~SEException(a1);
  operator delete(v1);
}

uint64_t sub_1000DCDA4(uint64_t a1)
{
  uint64_t result;

  result = a1 + 8;
  if (*(char *)(a1 + 31) < 0)
    return *(_QWORD *)result;
  return result;
}

_QWORD *sub_1000DCDC0(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = sub_1000DCE38(result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000DCE1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1000DCE38(_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    sub_1000CB780();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

uint64_t SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(_QWORD *)v3 = &off_100182F58;
  if (*(_DWORD *)(v3 + 56) != 44)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return a1;
}

void sub_1000DCEEC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN300VDeviceInfo *SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo(SERestoreInfo::SN300VDeviceInfo *this, SERestoreInfo **a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_100182F58;
  if (*((_DWORD *)v3 + 14) != 44)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return this;
}

void sub_1000DCF88(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(_QWORD *)v3 = &off_100182FA8;
  if (*(_DWORD *)(v3 + 56) != 55)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return a1;
}

void sub_1000DD024(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SE310SDeviceInfo *SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo(SERestoreInfo::SE310SDeviceInfo *this, SERestoreInfo **a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_100182FA8;
  if (*((_DWORD *)v3 + 14) != 55)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return this;
}

void sub_1000DD0C0(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(_QWORD *)v3 = &off_100182FF8;
  if (*(_DWORD *)(v3 + 56) != 210)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return a1;
}

void sub_1000DD15C(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN210VDeviceInfo *SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo(SERestoreInfo::SN210VDeviceInfo *this, SERestoreInfo **a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_100182FF8;
  if (*((_DWORD *)v3 + 14) != 210)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return this;
}

void sub_1000DD1F8(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

_QWORD *RootCA::getRootKeyId@<X0>(int a1@<W0>, int a2@<W1>, _QWORD *a3@<X8>)
{
  const void *v4;
  void *v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  std::string::size_type v13;
  std::string *v14;
  __int128 v15;
  void *v16;
  void *exception;
  std::string *v19;
  __int128 v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  std::string::size_type size;
  std::string *v25;
  __int128 v26;
  void *v27;
  std::string v28;
  std::string v29;
  std::string v30;
  std::string v31;
  __int128 v32;
  std::string::size_type v33;

  if (a2 > 199)
  {
    if (a2 != 210 && a2 != 200)
    {
LABEL_12:
      if (a1 == 1)
      {
        *a3 = 0;
        a3[1] = 0;
        v4 = &unk_1001A7F30;
      }
      else
      {
        if (a1)
        {
          exception = __cxa_allocate_exception(0x48uLL);
          std::to_string(&v29, a1);
          v19 = std::string::insert(&v29, 0, "Unknown RootCAId: ");
          v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
          v30.__r_.__value_.__r.__words[2] = v19->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v20;
          v19->__r_.__value_.__l.__size_ = 0;
          v19->__r_.__value_.__r.__words[2] = 0;
          v19->__r_.__value_.__r.__words[0] = 0;
          v21 = std::string::append(&v30, " for SEChipType ");
          v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
          v31.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
          *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v22;
          v21->__r_.__value_.__l.__size_ = 0;
          v21->__r_.__value_.__r.__words[2] = 0;
          v21->__r_.__value_.__r.__words[0] = 0;
          std::to_string(&v28, a2);
          if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            v23 = &v28;
          else
            v23 = (std::string *)v28.__r_.__value_.__r.__words[0];
          if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
            size = HIBYTE(v28.__r_.__value_.__r.__words[2]);
          else
            size = v28.__r_.__value_.__l.__size_;
          v25 = std::string::append(&v31, (const std::string::value_type *)v23, size);
          v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
          v33 = v25->__r_.__value_.__r.__words[2];
          v32 = v26;
          v25->__r_.__value_.__l.__size_ = 0;
          v25->__r_.__value_.__r.__words[2] = 0;
          v25->__r_.__value_.__r.__words[0] = 0;
          v27 = (void *)SERestoreInfo::SEException::SEException(exception, &v32, 16, CFSTR("SEUpdaterErrorDomain"));
        }
        *a3 = 0;
        a3[1] = 0;
        v4 = &unk_1001A7F10;
      }
      goto LABEL_11;
    }
  }
  else if (a2 != 100 && a2 != 115)
  {
    goto LABEL_12;
  }
  if (a1 == 1)
  {
    *a3 = 0;
    a3[1] = 0;
    v4 = &unk_1001A7EF0;
  }
  else
  {
    if (a1)
    {
      v7 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v29, a1);
      v8 = std::string::insert(&v29, 0, "Unknown RootCAId: ");
      v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
      v30.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v30.__r_.__value_.__l.__data_ = v9;
      v8->__r_.__value_.__l.__size_ = 0;
      v8->__r_.__value_.__r.__words[2] = 0;
      v8->__r_.__value_.__r.__words[0] = 0;
      v10 = std::string::append(&v30, " for SEChipType ");
      v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
      v31.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v31.__r_.__value_.__l.__data_ = v11;
      v10->__r_.__value_.__l.__size_ = 0;
      v10->__r_.__value_.__r.__words[2] = 0;
      v10->__r_.__value_.__r.__words[0] = 0;
      std::to_string(&v28, a2);
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v12 = &v28;
      else
        v12 = (std::string *)v28.__r_.__value_.__r.__words[0];
      if ((v28.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = HIBYTE(v28.__r_.__value_.__r.__words[2]);
      else
        v13 = v28.__r_.__value_.__l.__size_;
      v14 = std::string::append(&v31, (const std::string::value_type *)v12, v13);
      v15 = *(_OWORD *)&v14->__r_.__value_.__l.__data_;
      v33 = v14->__r_.__value_.__r.__words[2];
      v32 = v15;
      v14->__r_.__value_.__l.__size_ = 0;
      v14->__r_.__value_.__r.__words[2] = 0;
      v14->__r_.__value_.__r.__words[0] = 0;
      v16 = (void *)SERestoreInfo::SEException::SEException(v7, &v32, 16, CFSTR("SEUpdaterErrorDomain"));
    }
    *a3 = 0;
    a3[1] = 0;
    v4 = &unk_1001A7ED0;
  }
LABEL_11:
  a3[2] = 0;
  return sub_1000DCDC0(a3, v4, (uint64_t)v4 + 32, 0x20uLL);
}

void sub_1000DD4B4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, void *a15, uint64_t a16, int a17, __int16 a18, char a19, char a20,void *a21,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  uint64_t v33;

  if (*(char *)(v33 - 41) < 0)
    operator delete(*(void **)(v33 - 64));
  if (a14 < 0)
    operator delete(__p);
  if (a33 < 0)
    operator delete(a28);
  if (a26 < 0)
    operator delete(a21);
  if (a20 < 0)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

SERestoreInfo::IcefallDeviceInfo *SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo(SERestoreInfo::IcefallDeviceInfo *this, SERestoreInfo **a2)
{
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  _DWORD *v9;
  uint64_t v10;
  _QWORD *exception;
  _QWORD v13[3];
  int v14;
  const __CFString *v15;
  CFTypeID TypeID;
  char *v17;
  int v18;
  const __CFString *v19;
  CFTypeID v20;
  char *v21;
  int v22;
  const __CFString *v23;
  CFTypeID v24;
  char *v25;
  int v26;
  const __CFString *v27;
  CFTypeID v28;
  char *v29;
  int v30;
  const __CFString *v31;
  CFTypeID v32;
  char *v33;
  int v34;
  const __CFString *v35;
  CFTypeID v36;
  char *v37;
  int v38;
  const __CFString *v39;
  CFTypeID v40;
  char *v41;
  int v42;

  *((_OWORD *)this + 1) = 0u;
  v4 = (char *)this + 16;
  *(_QWORD *)this = off_100183048;
  v5 = (char *)this + 40;
  *((_OWORD *)this + 4) = 0u;
  v6 = (char *)this + 64;
  v7 = (char *)this + 88;
  *((_OWORD *)this + 7) = 0u;
  v8 = (char *)this + 112;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 16) = 0;
  v13[0] = CFSTR("SE,ChipID");
  v9 = (_DWORD *)((char *)this + 144);
  v13[1] = CFNumberGetTypeID();
  v13[2] = v9;
  v14 = 4;
  v15 = CFSTR("SE,FactoryMode");
  TypeID = CFBooleanGetTypeID();
  v17 = (char *)this + 153;
  v18 = 1;
  v19 = CFSTR("SE,ID");
  v20 = CFDataGetTypeID();
  v21 = v4;
  v22 = 24;
  v23 = CFSTR("SE,Nonce");
  v24 = CFDataGetTypeID();
  v25 = v5;
  v26 = 20;
  v27 = CFSTR("SE,RootKeyIdentifier");
  v28 = CFDataGetTypeID();
  v29 = v6;
  v30 = 32;
  v31 = CFSTR("SE,OsKeysIdentifier");
  v32 = CFDataGetTypeID();
  v33 = v7;
  v34 = 32;
  v35 = CFSTR("SE,BLFWKeysIdentifier");
  v36 = CFDataGetTypeID();
  v37 = v8;
  v38 = 32;
  v39 = CFSTR("SE,IsDev");
  v10 = 0;
  v40 = CFBooleanGetTypeID();
  v41 = (char *)this + 10;
  v42 = 1;
  *((_DWORD *)this + 37) = 6;
  *((_WORD *)this + 76) = 7;
  do
  {
    SERestoreInfo::getValueFromCFDict(*a2, (const __CFDictionary *)v13[v10], (const __CFString *)v13[v10 + 1], (BOOL *)v13[v10 + 2], (void *)LODWORD(v13[v10 + 3]));
    v10 += 4;
  }
  while (v10 != 32);
  if (*v9 != 131601)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return this;
}

void sub_1000DD81C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void **v7;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  __cxa_free_exception(v2);
  v9 = *v7;
  if (*v7)
  {
    v1[15] = v9;
    operator delete(v9);
  }
  v10 = *v6;
  if (*v6)
  {
    v1[12] = v10;
    operator delete(v10);
  }
  v11 = *v5;
  if (*v5)
  {
    v1[9] = v11;
    operator delete(v11);
  }
  v12 = *v4;
  if (*v4)
  {
    v1[6] = v12;
    operator delete(v12);
  }
  v13 = *v3;
  if (*v3)
  {
    v1[3] = v13;
    operator delete(v13);
  }
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo(uint64_t a1, uint64_t a2)
{
  _QWORD *exception;

  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)a1 = off_100183048;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  *(_DWORD *)(a1 + 148) = 6;
  *(_WORD *)(a1 + 152) = 7;
  SERestoreInfo::IcefallDeviceInfo::updateFromMQ(a1, a2);
  if (*(_DWORD *)(a1 + 144) != 131601)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return a1;
}

void sub_1000DD934(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  void **v3;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  __cxa_free_exception(v2);
  v5 = (void *)v1[14];
  if (v5)
  {
    v1[15] = v5;
    operator delete(v5);
  }
  v6 = (void *)v1[11];
  if (v6)
  {
    v1[12] = v6;
    operator delete(v6);
  }
  v7 = (void *)v1[8];
  if (v7)
  {
    v1[9] = v7;
    operator delete(v7);
  }
  v8 = (void *)v1[5];
  if (v8)
  {
    v1[6] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v1[3] = v9;
    operator delete(v9);
  }
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::IcefallDeviceInfo::updateFromMQ(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v4;
  _QWORD *exception;

  v2 = *(_QWORD *)(a2 + 8);
  if (!v2 || (*(_QWORD *)(a2 + 16) & 0xFFFFFFFFFFFFFFFDLL) != 0x9D || *(_WORD *)v2 != 257)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DD88C(exception);
  }
  *(_BYTE *)(a1 + 10) = *(_BYTE *)(v2 + 3) == 0;
  sub_1000DDD98((_QWORD *)(a1 + 16), (char *)(v2 + 4), (char *)(v2 + 28), 0x18uLL);
  sub_1000DDD98((_QWORD *)(a1 + 40), (char *)(v2 + 28), (char *)(v2 + 48), 0x14uLL);
  sub_1000DDD98((_QWORD *)(a1 + 64), (char *)(v2 + 48), (char *)(v2 + 80), 0x20uLL);
  sub_1000DDD98((_QWORD *)(a1 + 88), (char *)(v2 + 112), (char *)(v2 + 144), 0x20uLL);
  sub_1000DDD98((_QWORD *)(a1 + 112), (char *)(v2 + 80), (char *)(v2 + 112), 0x20uLL);
  *(_QWORD *)(a1 + 136) = *(_QWORD *)(v2 + 144);
  v4 = *(unsigned __int8 *)(v2 + 2);
  *(_DWORD *)(a1 + 144) = *(_DWORD *)(v2 + 153);
  *(_DWORD *)(a1 + 148) = v4;
  return 1;
}

void sub_1000DDAAC(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::IcefallDeviceInfo::updateDict(SERestoreInfo::IcefallDeviceInfo *this, __CFDictionary *a2, char a3)
{
  CFNumberRef v6;
  CFNumberRef v7;
  CFDataRef v8;
  uint64_t v9;
  uint64_t v10;
  CFDataRef v11;
  CFDataRef v12;
  uint64_t v13;
  uint64_t v14;
  CFDataRef v15;
  CFDataRef v16;
  uint64_t v17;
  uint64_t v18;
  CFDataRef v19;
  const void **v20;
  CFDataRef v21;
  uint64_t v22;
  uint64_t v23;
  CFDataRef v24;
  CFDataRef v25;
  uint64_t v26;
  uint64_t v27;
  CFDataRef v28;
  int valuePtr;

  valuePtr = *((_DWORD *)this + 36);
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v6)
    sub_1000DDF1C();
  v7 = v6;
  CFDictionarySetValue(a2, CFSTR("SE,ChipID"), v6);
  CFRelease(v7);
  v8 = CFDataCreate(0, *((const UInt8 **)this + 2), *((_QWORD *)this + 3) - *((_QWORD *)this + 2));
  if (!v8)
    sub_1000DDF44(0, v9, v10);
  v11 = v8;
  CFDictionarySetValue(a2, CFSTR("SE,ID"), v8);
  CFRelease(v11);
  v12 = CFDataCreate(0, *((const UInt8 **)this + 5), *((_QWORD *)this + 6) - *((_QWORD *)this + 5));
  if (!v12)
    sub_1000DDF44(0, v13, v14);
  v15 = v12;
  CFDictionarySetValue(a2, CFSTR("SE,Nonce"), v12);
  CFRelease(v15);
  if (*((_BYTE *)this + 153))
    CFDictionarySetValue(a2, CFSTR("SE,FactoryMode"), kCFBooleanTrue);
  v16 = CFDataCreate(0, *((const UInt8 **)this + 8), *((_QWORD *)this + 9) - *((_QWORD *)this + 8));
  if (!v16)
    sub_1000DDF44(0, v17, v18);
  v19 = v16;
  CFDictionarySetValue(a2, CFSTR("SE,RootKeyIdentifier"), v16);
  CFRelease(v19);
  if ((a3 & 1) == 0)
  {
    if (*((_BYTE *)this + 10))
      v20 = (const void **)&kCFBooleanTrue;
    else
      v20 = (const void **)&kCFBooleanFalse;
    CFDictionarySetValue(a2, CFSTR("SE,IsDev"), *v20);
    v21 = CFDataCreate(0, *((const UInt8 **)this + 14), *((_QWORD *)this + 15) - *((_QWORD *)this + 14));
    if (!v21)
      sub_1000DDF44(0, v22, v23);
    v24 = v21;
    CFDictionarySetValue(a2, CFSTR("SE,BLFWKeysIdentifier"), v21);
    CFRelease(v24);
    v25 = CFDataCreate(0, *((const UInt8 **)this + 11), *((_QWORD *)this + 12) - *((_QWORD *)this + 11));
    if (!v25)
      sub_1000DDF44(0, v26, v27);
    v28 = v25;
    CFDictionarySetValue(a2, CFSTR("SE,OsKeysIdentifier"), v25);
    CFRelease(v28);
  }
}

void sub_1000DDCD4(_QWORD *a1)
{
  _QWORD *v1;

  v1 = sub_1000DDD1C(a1);
  operator delete(v1);
}

_QWORD *sub_1000DDCE8@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  return sub_1000DCDC0(a2, *(const void **)(a1 + 88), *(_QWORD *)(a1 + 96), *(_QWORD *)(a1 + 96) - *(_QWORD *)(a1 + 88));
}

uint64_t sub_1000DDD14(uint64_t a1)
{
  return *(unsigned int *)(a1 + 144);
}

_QWORD *sub_1000DDD1C(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *a1 = off_100183048;
  v2 = (void *)a1[14];
  if (v2)
  {
    a1[15] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[11];
  if (v3)
  {
    a1[12] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[8];
  if (v4)
  {
    a1[9] = v4;
    operator delete(v4);
  }
  v5 = (void *)a1[5];
  if (v5)
  {
    a1[6] = v5;
    operator delete(v5);
  }
  v6 = (void *)a1[2];
  if (v6)
  {
    a1[3] = v6;
    operator delete(v6);
  }
  return a1;
}

_QWORD *sub_1000DDD98(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;

  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      sub_1000CB780();
    v10 = 2 * v8;
    if (2 * v8 <= a4)
      v10 = a4;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = sub_1000DCE38(v7, v11);
    v9 = (char *)v7[1];
    goto LABEL_17;
  }
  v12 = (_BYTE *)result[1];
  v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    v16 = a3 - __src;
    if (v16)
      result = memmove(v9, __src, v16);
    v15 = &v9[v16];
    goto LABEL_20;
  }
  v14 = &__src[v13];
  if (v12 != v9)
  {
    result = memmove((void *)*result, __src, v13);
    v9 = (char *)v7[1];
  }
  if (a3 != v14)
    result = memmove(v9, v14, a3 - v14);
  v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

_QWORD *sub_1000DDEA4(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    sub_1000DCE38(a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1000DDEF8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1000DDF14(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 59, a4);
}

void sub_1000DDF1C()
{
  __assert_rtn("_CFDictionarySetInteger32", "SERestoreInfoHelpers.hpp", 42, "num != nullptr");
}

void sub_1000DDF44(uint64_t a1, uint64_t a2, uint64_t a3)
{
  sub_1000DDF14("_CFDictionarySetData", "SERestoreInfoHelpers.hpp", a3, "tmpData");
}

void SERestoreInfo::P73BaseDeviceInfo::parseManifest(uint64_t a1@<X0>, unsigned __int8 **a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t *v6;
  void *v7;
  void *v8;
  void *exception;
  void *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  std::string *v15;
  __int128 v16;
  void *v17;
  std::string v18;
  void *v19[2];
  char v20;
  void *__p[2];
  char v22;
  unint64_t v23[2];
  __int128 v24;
  std::string::size_type v25;
  void *v26[2];
  char v27;
  _QWORD v28[2];
  unint64_t v29;
  unint64_t v30;

  v3 = *(_QWORD *)(a1 + 16);
  v28[0] = *(_QWORD *)(a1 + 8);
  v28[1] = v3;
  v4 = DERDecodeItem((uint64_t)v28, &v29);
  sub_1000CB3F4(v26, "Fail to parse MQR: cannot decode top level tag");
  sub_1000DE3A8(v4, (uint64_t)v26);
  if (v27 < 0)
    operator delete(v26[0]);
  if (v29 != P73BaseManifestQueryResponseDerSpec::ManifestResponseSequenceTag)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v24, "Fail to parse MQR: wrong top level tag");
    v10 = (void *)SERestoreInfo::SEException::SEException(exception, &v24, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  v23[0] = 0;
  v23[1] = 0;
  v5 = DERParseSequenceContent(&v30, 1u, (uint64_t)&unk_1001675A0, (unint64_t)v23, 0x10uLL);
  sub_1000CB3F4(__p, "Fail to parse MQR");
  sub_1000DE3A8((uint64_t)v5, (uint64_t)__p);
  if (v22 < 0)
    operator delete(__p[0]);
  *((_OWORD *)a2 + 13) = 0u;
  *((_OWORD *)a2 + 14) = 0u;
  *((_OWORD *)a2 + 11) = 0u;
  *((_OWORD *)a2 + 12) = 0u;
  *((_OWORD *)a2 + 9) = 0u;
  *((_OWORD *)a2 + 10) = 0u;
  *((_OWORD *)a2 + 7) = 0u;
  *((_OWORD *)a2 + 8) = 0u;
  *((_OWORD *)a2 + 5) = 0u;
  *((_OWORD *)a2 + 6) = 0u;
  *((_OWORD *)a2 + 3) = 0u;
  *((_OWORD *)a2 + 4) = 0u;
  *((_OWORD *)a2 + 1) = 0u;
  *((_OWORD *)a2 + 2) = 0u;
  *(_OWORD *)a2 = 0u;
  v6 = DERParseSequenceContent(v23, 0xFu, (uint64_t)&unk_1001675B8, (unint64_t)a2, 0xF0uLL);
  sub_1000CB3F4(v19, "Fail to parse MQR.data");
  sub_1000DE3A8((uint64_t)v6, (uint64_t)v19);
  if (v20 < 0)
    operator delete(v19[0]);
  if (a2[1] != (unsigned __int8 *)1
    || (unint64_t)a2[3] > 2
    || (unint64_t)a2[5] > 2
    || (unint64_t)a2[7] > 2
    || (unint64_t)a2[9] > 2
    || a2[15] != (unsigned __int8 *)1
    || (unint64_t)a2[25] > 2
    || a2[13] != (unsigned __int8 *)24
    || a2[17] != (unsigned __int8 *)20
    || a2[19] != (unsigned __int8 *)32
    || a2[21] != (unsigned __int8 *)32
    || a2[11] != (unsigned __int8 *)2
    || a2[23] != (unsigned __int8 *)1)
  {
    v7 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v24, "size of MQRD doesn't match");
    v8 = (void *)SERestoreInfo::SEException::SEException(v7, &v24, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  if (**a2 == 1)
  {
    if (a2[27] != (unsigned __int8 *)3 || a2[29] != (unsigned __int8 *)32)
      goto LABEL_30;
  }
  else
  {
    if (**a2)
    {
      v13 = **a2;
      v14 = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v18, v13);
      v15 = std::string::insert(&v18, 0, "Unsupported manifest query version: ");
      v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
      v25 = v15->__r_.__value_.__r.__words[2];
      v24 = v16;
      v15->__r_.__value_.__l.__size_ = 0;
      v15->__r_.__value_.__r.__words[2] = 0;
      v15->__r_.__value_.__r.__words[0] = 0;
      v17 = (void *)SERestoreInfo::SEException::SEException(v14, &v24, 7, CFSTR("SEUpdaterErrorDomain"));
    }
    if ((unint64_t)a2[27] | (unint64_t)a2[29])
    {
LABEL_30:
      v11 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v24, "size of factoryPostflightState or cometRootKeyId doesn't match");
      v12 = (void *)SERestoreInfo::SEException::SEException(v11, &v24, 2, CFSTR("SEUpdaterErrorDomain"));
    }
  }
}

void sub_1000DE2F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,uint64_t a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000DE3A8(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  void *exception;
  void *v5;

  if ((_DWORD)result)
  {
    v2 = result;
    exception = __cxa_allocate_exception(0x48uLL);
    v5 = (void *)SERestoreInfo::SEException::SEException(exception, a2, v2, CFSTR("libDERErrorDomain"));
  }
  return result;
}

double SERestoreInfo::P73BaseDeviceInfo::init(SERestoreInfo::P73BaseDeviceInfo *this)
{
  double result;
  char v3;
  char v4;
  char v5;
  char v6;
  char v7;

  *((_DWORD *)this + 14) = 0;
  *((_DWORD *)this + 2) = 1;
  v7 = 0;
  sub_1000DF490((char **)this + 4, 0x18uLL, &v7);
  v6 = 0;
  sub_1000DF490((char **)this + 8, 0x14uLL, &v6);
  v5 = 0;
  sub_1000DF490((char **)this + 11, 0x20uLL, &v5);
  v4 = 0;
  sub_1000DF490((char **)this + 14, 0x20uLL, &v4);
  *((_QWORD *)this + 17) = 0;
  *(_QWORD *)((char *)this + 20) = 0;
  *(_QWORD *)((char *)this + 12) = 0;
  *((_DWORD *)this + 7) = 23195;
  *((_DWORD *)this + 36) = 0;
  v3 = 0;
  sub_1000DF490((char **)this + 19, 0x20uLL, &v3);
  result = 0.0;
  *((_QWORD *)this + 22) = 0;
  *((_DWORD *)this + 46) = 0;
  return result;
}

uint64_t SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(uint64_t a1, uint64_t a2)
{
  _OWORD v5[15];

  *(_QWORD *)a1 = &off_1001830A8;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_QWORD *)(a1 + 128) = 0;
  SERestoreInfo::P73BaseDeviceInfo::init((SERestoreInfo::P73BaseDeviceInfo *)a1);
  memset(v5, 0, sizeof(v5));
  SERestoreInfo::P73BaseDeviceInfo::parseManifest(a2, (unsigned __int8 **)v5);
  SERestoreInfo::P73BaseDeviceInfo::updateDeviceInfo(a1, (unsigned __int8 **)v5);
  return a1;
}

void sub_1000DE574(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;

  v6 = *v4;
  if (*v4)
  {
    v1[20] = v6;
    operator delete(v6);
  }
  v7 = (void *)v1[14];
  if (v7)
  {
    v1[15] = v7;
    operator delete(v7);
  }
  v8 = (void *)v1[11];
  if (v8)
  {
    v1[12] = v8;
    operator delete(v8);
  }
  v9 = *v3;
  if (*v3)
  {
    v1[9] = v9;
    operator delete(v9);
  }
  v10 = *v2;
  if (*v2)
  {
    v1[5] = v10;
    operator delete(v10);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *SERestoreInfo::P73BaseDeviceInfo::updateDeviceInfo(uint64_t a1, unsigned __int8 **a2)
{
  unsigned __int8 *v4;
  int v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;
  unsigned int v9;
  unsigned __int8 *v10;
  int v11;
  unsigned __int8 *v12;
  int v13;
  unsigned __int8 *v14;
  int v15;
  unsigned __int8 *v16;
  int v17;
  unsigned __int8 *v18;
  int v19;
  unsigned __int8 *v20;
  int v21;
  unsigned __int8 *v22;
  int v23;
  unsigned __int8 *v24;
  int v25;
  unsigned __int8 *v26;
  int v27;
  unsigned int v28;
  unsigned __int8 v29;
  uint64_t v30;
  unsigned int v31;
  int v32;
  uint64_t *v33;
  _QWORD **v34;
  _QWORD *v35;
  _QWORD **v36;
  BOOL v37;
  unsigned __int8 *v38;
  int v39;
  unsigned __int8 *v40;
  int v41;
  unsigned __int8 *v42;
  int v43;
  unsigned __int8 *v44;
  int v45;
  unsigned __int8 *v46;
  int v47;
  unsigned __int8 *v48;
  int v49;
  _QWORD *result;
  unint64_t v51;
  unsigned __int8 *v52;
  int v53;
  unsigned __int8 *v54;
  int v55;
  void *exception;
  void *v57;
  uint64_t i;
  char v59[8];
  _QWORD *v60;
  char v61[8];
  _QWORD *v62;
  char v63[8];
  _QWORD *v64;
  char v65[8];
  _QWORD *v66;
  unsigned int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _QWORD **v72;
  _QWORD *v73[3];
  int v74;
  uint64_t v75[3];
  int v76;
  uint64_t v77[3];
  int v78;
  uint64_t v79[3];

  v4 = a2[1];
  if (v4)
  {
    v5 = 0;
    v6 = *a2;
    do
    {
      v7 = *v6++;
      v5 = v7 | (v5 << 8);
      --v4;
    }
    while (v4);
  }
  else
  {
    v5 = 0;
  }
  *(_DWORD *)(a1 + 8) = v5;
  v8 = a2[3];
  if (v8)
  {
    v9 = 0;
    v10 = a2[2];
    do
    {
      v11 = *v10++;
      v9 = v11 | (v9 << 8);
      --v8;
    }
    while (v8);
  }
  else
  {
    v9 = 0;
  }
  *(_DWORD *)(a1 + 12) = v9;
  v12 = a2[5];
  if (v12)
  {
    v13 = 0;
    v14 = a2[4];
    do
    {
      v15 = *v14++;
      v13 = v15 | (v13 << 8);
      --v12;
    }
    while (v12);
  }
  else
  {
    v13 = 0;
  }
  *(_DWORD *)(a1 + 16) = v13;
  v16 = a2[7];
  if (v16)
  {
    v17 = 0;
    v18 = a2[6];
    do
    {
      v19 = *v18++;
      v17 = v19 | (v17 << 8);
      --v16;
    }
    while (v16);
  }
  else
  {
    v17 = 0;
  }
  *(_DWORD *)(a1 + 20) = v17;
  v20 = a2[9];
  if (v20)
  {
    v21 = 0;
    v22 = a2[8];
    do
    {
      v23 = *v22++;
      v21 = v23 | (v21 << 8);
      --v20;
    }
    while (v20);
  }
  else
  {
    v21 = 0;
  }
  *(_DWORD *)(a1 + 24) = v21;
  v24 = a2[15];
  if (!v24)
  {
    *(_DWORD *)(a1 + 56) = 0;
    goto LABEL_81;
  }
  v25 = 0;
  v26 = a2[14];
  do
  {
    v27 = *v26++;
    v25 = v27 | (v25 << 8);
    --v24;
  }
  while (v24);
  *(_DWORD *)(a1 + 56) = v25;
  if (v25 > 114)
  {
    if (v25 == 115)
    {
      v28 = 2;
      goto LABEL_41;
    }
    if (v25 != 210 && v25 != 200)
    {
LABEL_81:
      exception = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v72, "Unsupported chip ID");
      v57 = (void *)SERestoreInfo::SEException::SEException(exception, &v72, 2, CFSTR("SEUpdaterErrorDomain"));
    }
  }
  else
  {
    if ((v25 - 54) < 2)
    {
      v28 = 5;
      goto LABEL_41;
    }
    if (v25 == 44)
    {
      v28 = 4;
      goto LABEL_41;
    }
    if (v25 != 100)
      goto LABEL_81;
  }
  v28 = 3;
LABEL_41:
  *(_DWORD *)(a1 + 180) = v28;
  v67 = v28;
  v29 = atomic_load((unsigned __int8 *)&qword_1001A8F08);
  if ((v29 & 1) == 0 && __cxa_guard_acquire(&qword_1001A8F08))
  {
    v71 = 0x1400000F00;
    sub_1000DF6DC((uint64_t)v65, (unsigned int *)&v71, 1);
    LODWORD(v72) = 3;
    sub_1000DFD44((uint64_t *)v73, (uint64_t)v65);
    v70 = 0x1400000300;
    sub_1000DF6DC((uint64_t)v63, (unsigned int *)&v70, 1);
    v74 = 4;
    sub_1000DFD44(v75, (uint64_t)v63);
    v69 = 0x1400000100;
    sub_1000DF6DC((uint64_t)v61, (unsigned int *)&v69, 1);
    v76 = 5;
    sub_1000DFD44(v77, (uint64_t)v61);
    v68 = 0x1400000000;
    sub_1000DF6DC((uint64_t)v59, (unsigned int *)&v68, 1);
    v78 = 6;
    sub_1000DFD44(v79, (uint64_t)v59);
    sub_1000DF984((uint64_t)&unk_1001A8EF0, (unsigned int *)&v72, 4);
    for (i = 0; i != -16; i -= 4)
      sub_1000CBD74((uint64_t)&v79[i], (_QWORD *)v79[i + 1]);
    sub_1000CBD74((uint64_t)v59, v60);
    sub_1000CBD74((uint64_t)v61, v62);
    sub_1000CBD74((uint64_t)v63, v64);
    sub_1000CBD74((uint64_t)v65, v66);
    __cxa_guard_release(&qword_1001A8F08);
  }
  v30 = qword_1001A8EF8;
  if (!qword_1001A8EF8)
  {
LABEL_47:
    v32 = -1;
    goto LABEL_58;
  }
  while (1)
  {
    v31 = *(_DWORD *)(v30 + 32);
    if (v67 >= v31)
      break;
LABEL_46:
    v30 = *(_QWORD *)v30;
    if (!v30)
      goto LABEL_47;
  }
  if (v31 < v67)
  {
    v30 += 8;
    goto LABEL_46;
  }
  v33 = sub_1000DF688((uint64_t)&unk_1001A8EF0, &v67);
  sub_1000DFD44((uint64_t *)&v72, (uint64_t)v33);
  v34 = v72;
  v32 = -1;
  if (v72 != v73)
  {
    do
    {
      if (*((_DWORD *)v34 + 7) <= v9)
        v32 = *((_DWORD *)v34 + 8);
      v35 = v34[1];
      if (v35)
      {
        do
        {
          v36 = (_QWORD **)v35;
          v35 = (_QWORD *)*v35;
        }
        while (v35);
      }
      else
      {
        do
        {
          v36 = (_QWORD **)v34[2];
          v37 = *v36 == v34;
          v34 = v36;
        }
        while (!v37);
      }
      v34 = v36;
    }
    while (v36 != v73);
  }
  sub_1000CBD74((uint64_t)&v72, v73[0]);
LABEL_58:
  *(_DWORD *)(a1 + 184) = v32;
  v38 = a2[25];
  if (v38)
  {
    v39 = 0;
    v40 = a2[24];
    do
    {
      v41 = *v40++;
      v39 = v41 | (v39 << 8);
      --v38;
    }
    while (v38);
  }
  else
  {
    v39 = 0;
  }
  *(_DWORD *)(a1 + 140) = v39;
  v42 = a2[23];
  if (v42)
  {
    v43 = 0;
    v44 = a2[22];
    do
    {
      v45 = *v44++;
      v43 = v45 | (v43 << 8);
      --v42;
    }
    while (v42);
  }
  else
  {
    v43 = 0;
  }
  *(_DWORD *)(a1 + 136) = v43;
  v46 = a2[27];
  if (v46)
  {
    v47 = 0;
    v48 = a2[26];
    do
    {
      v49 = *v48++;
      v47 = v49 | (v47 << 8);
      --v46;
    }
    while (v46);
    *(_DWORD *)(a1 + 144) = v47;
  }
  sub_1000DDD98((_QWORD *)(a1 + 32), (char *)a2[12], (char *)&a2[13][(_QWORD)a2[12]], (unint64_t)a2[13]);
  sub_1000DDD98((_QWORD *)(a1 + 64), (char *)a2[16], (char *)&a2[17][(_QWORD)a2[16]], (unint64_t)a2[17]);
  sub_1000DDD98((_QWORD *)(a1 + 88), (char *)a2[18], (char *)&a2[19][(_QWORD)a2[18]], (unint64_t)a2[19]);
  result = sub_1000DDD98((_QWORD *)(a1 + 112), (char *)a2[20], (char *)&a2[21][(_QWORD)a2[20]], (unint64_t)a2[21]);
  v51 = (unint64_t)a2[29];
  if (v51)
    result = sub_1000DDD98((_QWORD *)(a1 + 152), (char *)a2[28], (char *)&a2[28][v51], v51);
  v52 = a2[11];
  if (v52)
  {
    v53 = 0;
    v54 = a2[10];
    do
    {
      v55 = *v54++;
      v53 = v55 | (v53 << 8);
      --v52;
    }
    while (v52);
  }
  else
  {
    v53 = 0;
  }
  *(_DWORD *)(a1 + 28) = v53;
  return result;
}

void sub_1000DEB40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11, uint64_t a12, uint64_t a13, char a14, _QWORD *a15, uint64_t a16, uint64_t a17, char a18, _QWORD *a19, uint64_t a20,uint64_t a21,char a22,_QWORD *a23)
{
  uint64_t v23;
  uint64_t i;

  for (i = 0; i != -128; i -= 32)
    sub_1000CBD74(v23 + i + 104, *(_QWORD **)(v23 + i + 112));
  sub_1000CBD74((uint64_t)&a10, a11);
  sub_1000CBD74((uint64_t)&a14, a15);
  sub_1000CBD74((uint64_t)&a18, a19);
  sub_1000CBD74((uint64_t)&a22, a23);
  __cxa_guard_abort(&qword_1001A8F08);
  _Unwind_Resume(a1);
}

SERestoreInfo::P73BaseDeviceInfo *SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(SERestoreInfo::P73BaseDeviceInfo *this, SERestoreInfo **a2)
{
  char *v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t i;
  _QWORD v10[3];
  int v11;
  const __CFString *v12;
  CFTypeID TypeID;
  char *v14;
  int v15;
  const __CFString *v16;
  CFTypeID v17;
  char *v18;
  int v19;
  const __CFString *v20;
  CFTypeID v21;
  char *v22;
  int v23;
  const __CFString *v24;
  CFTypeID v25;
  char *v26;
  int v27;

  *(_QWORD *)this = &off_1001830A8;
  *((_QWORD *)this + 4) = 0;
  v4 = (char *)this + 32;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 4) = 0u;
  v5 = (char *)this + 64;
  v6 = (char *)this + 88;
  *((_OWORD *)this + 7) = 0u;
  v7 = (char *)this + 112;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 6) = 0u;
  *((_QWORD *)this + 16) = 0;
  v10[0] = CFSTR("SE,ChipID");
  v10[1] = CFNumberGetTypeID();
  v10[2] = (char *)this + 56;
  v11 = 4;
  v12 = CFSTR("SE,ID");
  TypeID = CFDataGetTypeID();
  v14 = v4;
  v15 = 24;
  v16 = CFSTR("SE,Nonce");
  v17 = CFDataGetTypeID();
  v18 = v5;
  v19 = 20;
  v20 = CFSTR("SE,RootKeyIdentifier");
  v21 = CFDataGetTypeID();
  v22 = v6;
  v23 = 32;
  v24 = CFSTR("SE,OSUPubKeyID");
  v25 = CFDataGetTypeID();
  v26 = v7;
  v27 = 32;
  SERestoreInfo::P73BaseDeviceInfo::init(this);
  for (i = 0; i != 20; i += 4)
    SERestoreInfo::getValueFromCFDict(*a2, (const __CFDictionary *)v10[i], (const __CFString *)v10[i + 1], (BOOL *)v10[i + 2], (void *)LODWORD(v10[i + 3]));
  return this;
}

void sub_1000DEDF8(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v8 = *v6;
  if (*v6)
  {
    v1[20] = v8;
    operator delete(v8);
  }
  v9 = *v5;
  if (*v5)
  {
    v1[15] = v9;
    operator delete(v9);
  }
  v10 = *v4;
  if (*v4)
  {
    v1[12] = v10;
    operator delete(v10);
  }
  v11 = *v3;
  if (*v3)
  {
    v1[9] = v11;
    operator delete(v11);
  }
  v12 = *v2;
  if (*v2)
  {
    v1[5] = v12;
    operator delete(v12);
  }
  _Unwind_Resume(exception_object);
}

void SERestoreInfo::P73BaseDeviceInfo::updateDict(SERestoreInfo::P73BaseDeviceInfo *this, __CFDictionary *a2, char a3)
{
  CFNumberRef v6;
  CFNumberRef v7;
  CFDataRef v8;
  uint64_t v9;
  uint64_t v10;
  CFDataRef v11;
  CFDataRef v12;
  uint64_t v13;
  uint64_t v14;
  CFDataRef v15;
  CFDataRef v16;
  uint64_t v17;
  uint64_t v18;
  CFDataRef v19;
  CFDataRef v20;
  uint64_t v21;
  uint64_t v22;
  CFDataRef v23;
  int valuePtr;

  valuePtr = *((_DWORD *)this + 14);
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v6)
    sub_1000DDF1C();
  v7 = v6;
  CFDictionarySetValue(a2, CFSTR("SE,ChipID"), v6);
  CFRelease(v7);
  v8 = CFDataCreate(0, *((const UInt8 **)this + 4), *((_QWORD *)this + 5) - *((_QWORD *)this + 4));
  if (!v8)
    sub_1000DDF44(0, v9, v10);
  v11 = v8;
  CFDictionarySetValue(a2, CFSTR("SE,ID"), v8);
  CFRelease(v11);
  v12 = CFDataCreate(0, *((const UInt8 **)this + 8), *((_QWORD *)this + 9) - *((_QWORD *)this + 8));
  if (!v12)
    sub_1000DDF44(0, v13, v14);
  v15 = v12;
  CFDictionarySetValue(a2, CFSTR("SE,Nonce"), v12);
  CFRelease(v15);
  v16 = CFDataCreate(0, *((const UInt8 **)this + 11), *((_QWORD *)this + 12) - *((_QWORD *)this + 11));
  if (!v16)
    sub_1000DDF44(0, v17, v18);
  v19 = v16;
  CFDictionarySetValue(a2, CFSTR("SE,RootKeyIdentifier"), v16);
  CFRelease(v19);
  if ((a3 & 1) == 0)
  {
    v20 = CFDataCreate(0, *((const UInt8 **)this + 14), *((_QWORD *)this + 15) - *((_QWORD *)this + 14));
    if (!v20)
      sub_1000DDF44(0, v21, v22);
    v23 = v20;
    CFDictionarySetValue(a2, CFSTR("SE,OSUPubKeyID"), v20);
    CFRelease(v23);
  }
}

void SERestoreInfo::P73BaseDeviceInfo::getStateName(int a1@<W0>, _QWORD *a2@<X8>)
{
  uint64_t i;
  char *v5;
  int v6;
  uint64_t *v7;
  __int128 v8;
  _BYTE v9[8];
  char *v10;
  int v11;
  int v12;
  _QWORD v13[3];
  int v14;
  _QWORD v15[3];
  int v16;
  _QWORD v17[3];
  int v18;
  _QWORD v19[3];
  int v20;
  _QWORD v21[3];
  int v22;
  _QWORD v23[3];
  int v24;
  _QWORD v25[3];
  int v26;
  _QWORD v27[3];

  v11 = a1;
  v12 = 23195;
  sub_1000CB3F4(v13, "EXPORT_REQUIRED");
  v14 = 47411;
  sub_1000CB3F4(v15, "IMPORT_REQUIRED");
  v16 = 47361;
  sub_1000CB3F4(v17, "UOS1");
  v18 = 47362;
  sub_1000CB3F4(v19, "UOS2");
  v20 = 42241;
  sub_1000CB3F4(v21, "UOS1_ERROR");
  v22 = 42242;
  sub_1000CB3F4(v23, "UOS2_ERROR");
  v24 = 47545;
  sub_1000CB3F4(v25, "EXPORT_FINISHED");
  v26 = 47377;
  sub_1000CB3F4(v27, "UOS1_KTP");
  sub_1000E0380((uint64_t)v9, &v12, 8);
  for (i = 0; i != -32; i -= 4)
  {
    if (SHIBYTE(v27[i + 2]) < 0)
      operator delete((void *)v27[i]);
  }
  v5 = v10;
  if (!v10)
  {
LABEL_11:
    sub_1000CB3F4(a2, "UNK_STATE");
    goto LABEL_12;
  }
  while (1)
  {
    v6 = *((_DWORD *)v5 + 8);
    if (v6 <= a1)
      break;
LABEL_10:
    v5 = *(char **)v5;
    if (!v5)
      goto LABEL_11;
  }
  if (v6 < a1)
  {
    v5 += 8;
    goto LABEL_10;
  }
  v7 = sub_1000DF25C((uint64_t)v9, &v11);
  if (*((char *)v7 + 23) < 0)
  {
    sub_1000CB554(a2, (void *)*v7, v7[1]);
  }
  else
  {
    v8 = *(_OWORD *)v7;
    a2[2] = v7[2];
    *(_OWORD *)a2 = v8;
  }
LABEL_12:
  sub_1000CC004((uint64_t)v9, v10);
}

void sub_1000DF1D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, char *a11)
{
  sub_1000CC004((uint64_t)&a10, a11);
  _Unwind_Resume(a1);
}

void sub_1000DF254()
{
  JUMPOUT(0x1000DF24CLL);
}

uint64_t *sub_1000DF25C(uint64_t a1, int *a2)
{
  uint64_t *v2;
  int v3;
  int v4;

  v2 = *(uint64_t **)(a1 + 8);
  if (!v2)
LABEL_8:
    sub_1000CC054("map::at:  key not found");
  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = *((_DWORD *)v2 + 8);
      if (v3 >= v4)
        break;
      v2 = (uint64_t *)*v2;
      if (!v2)
        goto LABEL_8;
    }
    if (v4 >= v3)
      return v2 + 5;
    v2 = (uint64_t *)v2[1];
    if (!v2)
      goto LABEL_8;
  }
}

uint64_t sub_1000DF2B0(uint64_t a1)
{
  uint64_t v2;

  *(_QWORD *)(a1 + 112) = &off_100183198;
  *(_QWORD *)a1 = &off_100183170;
  v2 = a1 + 8;
  std::ios_base::init((std::ios_base *)(a1 + 112), (void *)(a1 + 8));
  *(_QWORD *)(a1 + 248) = 0;
  *(_DWORD *)(a1 + 256) = -1;
  *(_QWORD *)a1 = off_100183100;
  *(_QWORD *)(a1 + 112) = off_100183128;
  std::streambuf::basic_streambuf(v2);
  *(_QWORD *)(a1 + 8) = off_1001831D0;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1000DF354(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  std::ostream::~ostream(v2, off_100183140);
  std::ios::~ios(v1);
  _Unwind_Resume(a1);
}

BOOL SERestoreInfo::P73BaseDeviceInfo::isDev(SERestoreInfo::P73BaseDeviceInfo *this)
{
  int v2;
  _BOOL8 v3;
  const void *v4;
  size_t v5;
  _BYTE *v6;
  _BYTE *v8;
  _BYTE *v9;

  v2 = (*(uint64_t (**)(SERestoreInfo::P73BaseDeviceInfo *))(*(_QWORD *)this + 32))(this);
  v3 = 1;
  RootCA::getRootKeyId(1, v2, &v8);
  v4 = (const void *)*((_QWORD *)this + 11);
  v5 = *((_QWORD *)this + 12) - (_QWORD)v4;
  v6 = v8;
  if (v5 == v9 - v8)
    v3 = memcmp(v4, v8, v5) != 0;
  if (v6)
  {
    v9 = v6;
    operator delete(v6);
  }
  return v3;
}

uint64_t sub_1000DF404(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)(a1 + 112) = off_100183128;
  v2 = a1 + 112;
  *(_QWORD *)a1 = off_100183100;
  *(_QWORD *)(a1 + 8) = off_1001831D0;
  v3 = a1 + 8;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf(v3);
  std::ostream::~ostream(a1, off_100183140);
  std::ios::~ios(v2);
  return a1;
}

char *sub_1000DF490(char **a1, unint64_t a2, char *a3)
{
  unint64_t v4;
  unint64_t v6;
  char *result;
  uint64_t v8;
  size_t v9;
  char *v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  unint64_t v15;
  char *v16;
  char *v17;

  v4 = a2;
  v6 = (unint64_t)a1[2];
  result = *a1;
  if (v6 - (unint64_t)result >= a2)
  {
    v12 = a1[1] - result;
    if (v12 >= a2)
      v13 = a2;
    else
      v13 = a1[1] - result;
    for (; v13; --v13)
      *result++ = *a3;
    v14 = a2 >= v12;
    v15 = a2 - v12;
    if (v15 != 0 && v14)
    {
      v16 = a1[1];
      v17 = &v16[v15];
      do
      {
        *v16++ = *a3;
        --v15;
      }
      while (v15);
      a1[1] = v17;
    }
    else
    {
      a1[1] = &(*a1)[a2];
    }
  }
  else
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v6 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if ((v4 & 0x8000000000000000) != 0)
      sub_1000CB780();
    v8 = 2 * v6;
    if (2 * v6 <= v4)
      v8 = v4;
    if (v6 >= 0x3FFFFFFFFFFFFFFFLL)
      v9 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v9 = v8;
    result = sub_1000DCE38(a1, v9);
    v10 = a1[1];
    v11 = &v10[v4];
    do
    {
      *v10++ = *a3;
      --v4;
    }
    while (v4);
    a1[1] = v11;
  }
  return result;
}

_QWORD *sub_1000DF590(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *a1 = &off_1001830A8;
  v2 = (void *)a1[19];
  if (v2)
  {
    a1[20] = v2;
    operator delete(v2);
  }
  v3 = (void *)a1[14];
  if (v3)
  {
    a1[15] = v3;
    operator delete(v3);
  }
  v4 = (void *)a1[11];
  if (v4)
  {
    a1[12] = v4;
    operator delete(v4);
  }
  v5 = (void *)a1[8];
  if (v5)
  {
    a1[9] = v5;
    operator delete(v5);
  }
  v6 = (void *)a1[4];
  if (v6)
  {
    a1[5] = v6;
    operator delete(v6);
  }
  return a1;
}

void sub_1000DF60C(_QWORD *__p)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *__p = &off_1001830A8;
  v2 = (void *)__p[19];
  if (v2)
  {
    __p[20] = v2;
    operator delete(v2);
  }
  v3 = (void *)__p[14];
  if (v3)
  {
    __p[15] = v3;
    operator delete(v3);
  }
  v4 = (void *)__p[11];
  if (v4)
  {
    __p[12] = v4;
    operator delete(v4);
  }
  v5 = (void *)__p[8];
  if (v5)
  {
    __p[9] = v5;
    operator delete(v5);
  }
  v6 = (void *)__p[4];
  if (v6)
  {
    __p[5] = v6;
    operator delete(v6);
  }
  operator delete(__p);
}

uint64_t *sub_1000DF688(uint64_t a1, unsigned int *a2)
{
  uint64_t *v2;
  unsigned int v3;
  unsigned int v4;

  v2 = *(uint64_t **)(a1 + 8);
  if (!v2)
LABEL_8:
    sub_1000CC054("map::at:  key not found");
  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = *((_DWORD *)v2 + 8);
      if (v3 >= v4)
        break;
      v2 = (uint64_t *)*v2;
      if (!v2)
        goto LABEL_8;
    }
    if (v4 >= v3)
      return v2 + 5;
    v2 = (uint64_t *)v2[1];
    if (!v2)
      goto LABEL_8;
  }
}

uint64_t sub_1000DF6DC(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 8 * a3;
    do
    {
      sub_1000DF758((uint64_t **)a1, v4, a2, (uint64_t *)a2);
      a2 += 2;
      v6 -= 8;
    }
    while (v6);
  }
  return a1;
}

void sub_1000DF740(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000CBD74(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000DF758(uint64_t **a1, uint64_t *a2, unsigned int *a3, uint64_t *a4)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t *v11;

  v6 = sub_1000DF7DC(a1, a2, &v11, &v10, a3);
  v7 = (uint64_t *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (uint64_t *)operator new(0x28uLL);
    *(uint64_t *)((char *)v7 + 28) = *a4;
    sub_1000CBAE0(a1, (uint64_t)v11, v8, v7);
  }
  return v7;
}

uint64_t *sub_1000DF7DC(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  unsigned int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 7), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (uint64_t *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (*((_DWORD *)v10 + 7) < *a5)
      goto LABEL_17;
    v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = (uint64_t *)v16;
          v18 = *(_DWORD *)(v16 + 28);
          if (v15 >= v18)
            break;
          v16 = *v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 7))
  {
    v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = (uint64_t *)v20;
          v22 = *(_DWORD *)(v20 + 28);
          if (v6 >= v22)
            break;
          v20 = *v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t sub_1000DF984(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 32 * a3;
    do
    {
      sub_1000DFA00((uint64_t **)a1, v4, a2, a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1000DF9E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000DFCF8(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000DFA00(uint64_t **a1, uint64_t *a2, unsigned int *a3, _DWORD *a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;

  v6 = (uint64_t **)sub_1000DFA80(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    sub_1000DFC28((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000CBAE0(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *sub_1000DFA80(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t *v17;
  unsigned int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  unsigned int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (uint64_t *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5)
      goto LABEL_17;
    v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = (uint64_t *)v16;
          v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18)
            break;
          v16 = *v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = (uint64_t *)v20;
          v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22)
            break;
          v20 = *v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

uint64_t *sub_1000DFC28@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  void *v6;
  uint64_t *result;

  v5 = a1 + 8;
  v6 = operator new(0x40uLL);
  *(_QWORD *)(a3 + 8) = v5;
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 16) = 0;
  *((_DWORD *)v6 + 8) = *a2;
  result = sub_1000DFD44((uint64_t *)v6 + 5, (uint64_t)(a2 + 2));
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1000DFC94(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD **v2;
  uint64_t v3;

  *v1 = 0;
  sub_1000DFCB0(v3, v2);
  _Unwind_Resume(a1);
}

void sub_1000DFCB0(uint64_t a1, _QWORD **a2)
{
  if (*(_BYTE *)(a1 + 8))
  {
    sub_1000CBD74((uint64_t)(a2 + 5), a2[6]);
  }
  else if (!a2)
  {
    return;
  }
  operator delete(a2);
}

void sub_1000DFCF8(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1000DFCF8(a1, *a2);
    sub_1000DFCF8(a1, a2[1]);
    sub_1000CBD74((uint64_t)(a2 + 5), (_QWORD *)a2[6]);
    operator delete(a2);
  }
}

uint64_t *sub_1000DFD44(uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  sub_1000DFD98(a1, *(unsigned int **)a2, (unsigned int *)(a2 + 8));
  return a1;
}

void sub_1000DFD80(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000CBD74(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000DFD98(uint64_t *result, unsigned int *a2, unsigned int *a3)
{
  unsigned int *v4;
  uint64_t **v5;
  uint64_t *v6;
  unsigned int *v7;
  unsigned int *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = sub_1000DF758(v5, v6, v4 + 7, (uint64_t *)(v4 + 7));
      v7 = (unsigned int *)*((_QWORD *)v4 + 1);
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = *(unsigned int **)v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (unsigned int *)*((_QWORD *)v4 + 2);
          v9 = *(_QWORD *)v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t sub_1000DFE1C(_QWORD *a1)
{
  char *v1;

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  *((_QWORD *)v1 + 14) = off_100183128;
  *(_QWORD *)v1 = off_100183100;
  *((_QWORD *)v1 + 1) = off_1001831D0;
  if (v1[95] < 0)
    operator delete(*((void **)v1 + 9));
  std::streambuf::~streambuf(v1 + 8);
  std::ostream::~ostream(v1, off_100183140);
  return std::ios::~ios(v1 + 112);
}

void sub_1000DFEA8(char *a1)
{
  char *v2;
  char *v3;

  *((_QWORD *)a1 + 14) = off_100183128;
  v2 = a1 + 112;
  *(_QWORD *)a1 = off_100183100;
  *((_QWORD *)a1 + 1) = off_1001831D0;
  v3 = a1 + 8;
  if (a1[95] < 0)
    operator delete(*((void **)a1 + 9));
  std::streambuf::~streambuf(v3);
  std::ostream::~ostream(a1, off_100183140);
  std::ios::~ios(v2);
  operator delete(a1);
}

void sub_1000DFF34(_QWORD *a1)
{
  char *v1;

  v1 = (char *)a1 + *(_QWORD *)(*a1 - 24);
  *((_QWORD *)v1 + 14) = off_100183128;
  *(_QWORD *)v1 = off_100183100;
  *((_QWORD *)v1 + 1) = off_1001831D0;
  if (v1[95] < 0)
    operator delete(*((void **)v1 + 9));
  std::streambuf::~streambuf(v1 + 8);
  std::ostream::~ostream(v1, off_100183140);
  std::ios::~ios(v1 + 112);
  operator delete(v1);
}

uint64_t sub_1000DFFC8(uint64_t a1)
{
  *(_QWORD *)a1 = off_1001831D0;
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  return std::streambuf::~streambuf(a1);
}

void sub_1000E0008(uint64_t a1)
{
  void *v2;

  *(_QWORD *)a1 = off_1001831D0;
  if (*(char *)(a1 + 87) < 0)
    operator delete(*(void **)(a1 + 64));
  v2 = (void *)std::streambuf::~streambuf(a1);
  operator delete(v2);
}

double sub_1000E004C@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, unsigned int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double result;
  uint64_t v12;

  v5 = *(_QWORD *)(a1 + 88);
  v6 = *(_QWORD *)(a1 + 48);
  if (v5 < v6)
  {
    *(_QWORD *)(a1 + 88) = v6;
    v5 = v6;
  }
  if ((a4 & 0x18) == 0 || a3 == 1 && (a4 & 0x18) == 0x18)
    goto LABEL_14;
  if (v5)
  {
    v7 = (_QWORD *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0)
      v7 = (_QWORD *)*v7;
    v8 = v5 - (_QWORD)v7;
    if (a3)
      goto LABEL_10;
LABEL_17:
    v9 = a3;
    goto LABEL_20;
  }
  v8 = 0;
  if (!a3)
    goto LABEL_17;
LABEL_10:
  if (a3 != 2)
  {
    if (a3 == 1)
    {
      if ((a4 & 8) != 0)
        v9 = *(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16);
      else
        v9 = v6 - *(_QWORD *)(a1 + 40);
      goto LABEL_20;
    }
LABEL_14:
    v10 = -1;
    goto LABEL_15;
  }
  v9 = v8;
LABEL_20:
  v10 = -1;
  v12 = v9 + a2;
  if (v12 >= 0 && v8 >= v12 && (!v12 || ((a4 & 8) == 0 || *(_QWORD *)(a1 + 24)) && ((a4 & 0x10) == 0 || v6)))
  {
    if ((a4 & 8) != 0)
    {
      *(_QWORD *)(a1 + 24) = *(_QWORD *)(a1 + 16) + v12;
      *(_QWORD *)(a1 + 32) = v5;
    }
    if ((a4 & 0x10) != 0)
      *(_QWORD *)(a1 + 48) = *(_QWORD *)(a1 + 40) + v12;
    v10 = v12;
  }
LABEL_15:
  result = 0.0;
  *(_OWORD *)(a5 + 96) = 0u;
  *(_OWORD *)(a5 + 112) = 0u;
  *(_OWORD *)(a5 + 64) = 0u;
  *(_OWORD *)(a5 + 80) = 0u;
  *(_OWORD *)(a5 + 32) = 0u;
  *(_OWORD *)(a5 + 48) = 0u;
  *(_OWORD *)a5 = 0u;
  *(_OWORD *)(a5 + 16) = 0u;
  *(_QWORD *)(a5 + 128) = v10;
  return result;
}

uint64_t sub_1000E014C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, uint64_t))(*(_QWORD *)a1 + 32))(a1, *(_QWORD *)(a2 + 128), 0, a3);
}

uint64_t sub_1000E0164(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unsigned __int8 *v4;

  v1 = *(_QWORD *)(a1 + 88);
  v2 = *(_QWORD *)(a1 + 48);
  if (v1 < v2)
  {
    *(_QWORD *)(a1 + 88) = v2;
    v1 = v2;
  }
  if ((*(_BYTE *)(a1 + 96) & 8) == 0)
    return 0xFFFFFFFFLL;
  v3 = *(_QWORD *)(a1 + 32);
  if (v3 < v1)
  {
    *(_QWORD *)(a1 + 32) = v1;
    v3 = v1;
  }
  v4 = *(unsigned __int8 **)(a1 + 24);
  if ((unint64_t)v4 < v3)
    return *v4;
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_1000E01B4(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *(_QWORD *)(a1 + 88);
  v3 = *(_QWORD *)(a1 + 48);
  if (v2 < v3)
  {
    *(_QWORD *)(a1 + 88) = v3;
    v2 = v3;
  }
  v4 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 16) >= v4)
    return 0xFFFFFFFFLL;
  if ((_DWORD)a2 == -1)
  {
    a2 = 0;
    *(_QWORD *)(a1 + 24) = v4 - 1;
    *(_QWORD *)(a1 + 32) = v2;
    return a2;
  }
  if ((*(_BYTE *)(a1 + 96) & 0x10) == 0 && *(unsigned __int8 *)(v4 - 1) != a2)
    return 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 24) = v4 - 1;
  *(_QWORD *)(a1 + 32) = v2;
  *(_BYTE *)(v4 - 1) = a2;
  return a2;
}

uint64_t sub_1000E0220(uint64_t a1, int a2)
{
  unsigned __int8 v2;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  unint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::string::size_type v13;
  unsigned __int8 *v14;
  uint64_t v15;
  _QWORD *v16;

  if (a2 == -1)
    return 0;
  v2 = a2;
  v5 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(a1 + 24);
  v7 = *(unsigned __int8 **)(a1 + 48);
  v6 = *(unsigned __int8 **)(a1 + 56);
  if (v7 == v6)
  {
    if ((*(_BYTE *)(a1 + 96) & 0x10) == 0)
      return 0xFFFFFFFFLL;
    v10 = *(_QWORD *)(a1 + 40);
    v11 = *(_QWORD *)(a1 + 88);
    v12 = a1 + 64;
    std::string::push_back((std::string *)(a1 + 64), 0);
    if (*(char *)(a1 + 87) < 0)
      v13 = (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1;
    else
      v13 = 22;
    std::string::resize((std::string *)(a1 + 64), v13, 0);
    v14 = &v7[-v10];
    if (*(char *)(a1 + 87) < 0)
    {
      v12 = *(_QWORD *)(a1 + 64);
      v15 = *(_QWORD *)(a1 + 72);
    }
    else
    {
      v15 = *(unsigned __int8 *)(a1 + 87);
    }
    v6 = (unsigned __int8 *)(v12 + v15);
    v7 = &v14[v12];
    *(_QWORD *)(a1 + 40) = v12;
    *(_QWORD *)(a1 + 48) = &v14[v12];
    *(_QWORD *)(a1 + 56) = v6;
    v8 = v12 + v11 - v10;
  }
  else
  {
    v8 = *(_QWORD *)(a1 + 88);
  }
  if ((unint64_t)(v7 + 1) >= v8)
    v8 = (unint64_t)(v7 + 1);
  *(_QWORD *)(a1 + 88) = v8;
  if ((*(_BYTE *)(a1 + 96) & 8) != 0)
  {
    v16 = (_QWORD *)(a1 + 64);
    if (*(char *)(a1 + 87) < 0)
      v16 = (_QWORD *)*v16;
    *(_QWORD *)(a1 + 16) = v16;
    *(_QWORD *)(a1 + 24) = (char *)v16 + v4 - v5;
    *(_QWORD *)(a1 + 32) = v8;
  }
  if (v7 == v6)
    return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 104))(a1, v2);
  *(_QWORD *)(a1 + 48) = v7 + 1;
  *v7 = v2;
  return v2;
}

void sub_1000E0374(void *a1)
{
  __cxa_begin_catch(a1);
  __cxa_end_catch();
  JUMPOUT(0x1000E0270);
}

uint64_t sub_1000E0380(uint64_t a1, int *a2, uint64_t a3)
{
  uint64_t *v4;
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = 0;
  v4 = (uint64_t *)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)a1 = a1 + 8;
  if (a3)
  {
    v6 = 32 * a3;
    do
    {
      sub_1000E03FC((uint64_t **)a1, v4, a2, (uint64_t)a2);
      a2 += 8;
      v6 -= 32;
    }
    while (v6);
  }
  return a1;
}

void sub_1000E03E4(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000CC004(v1, *(char **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *sub_1000E03FC(uint64_t **a1, uint64_t *a2, int *a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;

  v6 = (uint64_t **)sub_1000E047C(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    sub_1000E0624((uint64_t)a1, a4, (uint64_t)&v8);
    sub_1000CBAE0(a1, (uint64_t)v10, v6, v8);
    return v8;
  }
  return result;
}

uint64_t *sub_1000E047C(_QWORD *a1, uint64_t *a2, uint64_t **a3, uint64_t *a4, int *a5)
{
  uint64_t *v5;
  int v6;
  int v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  BOOL v14;
  int v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  int v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = *((_DWORD *)a2 + 8), *a5 < v7))
  {
    v8 = (uint64_t *)*a2;
    if ((uint64_t *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (uint64_t *)*a2;
      do
      {
        v10 = v9;
        v9 = (uint64_t *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (uint64_t *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (*((_DWORD *)v10 + 8) < *a5)
      goto LABEL_17;
    v16 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = (uint64_t *)v16;
          v18 = *(_DWORD *)(v16 + 32);
          if (v15 >= v18)
            break;
          v16 = *v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = (uint64_t)a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (uint64_t *)a2[1];
    do
    {
      a4 = v12;
      v12 = (uint64_t *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (uint64_t *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= *((_DWORD *)a4 + 8))
  {
    v20 = *v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = (uint64_t *)v20;
          v22 = *(_DWORD *)(v20 + 32);
          if (v6 >= v22)
            break;
          v20 = *v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

_QWORD *sub_1000E0624@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _DWORD *v6;
  _QWORD *result;

  v5 = a1 + 8;
  v6 = operator new(0x40uLL);
  *(_QWORD *)(a3 + 8) = v5;
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 16) = 0;
  v6[8] = *(_DWORD *)a2;
  result = v6 + 10;
  if (*(char *)(a2 + 31) < 0)
  {
    result = sub_1000CB554(result, *(void **)(a2 + 8), *(_QWORD *)(a2 + 16));
  }
  else
  {
    *(_OWORD *)result = *(_OWORD *)(a2 + 8);
    result[2] = *(_QWORD *)(a2 + 24);
  }
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1000E06B0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  sub_1000CDC98(v3, v2);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000E06CC@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X8>)
{
  int v2;
  char *v3;
  char *v4;
  char *v5;

  v2 = *((_DWORD *)result + 24);
  if ((v2 & 0x10) != 0)
  {
    v3 = (char *)result[11];
    v4 = (char *)result[6];
    if (v3 < v4)
    {
      result[11] = v4;
      v3 = v4;
    }
    v5 = (char *)result[5];
  }
  else
  {
    if ((v2 & 8) == 0)
    {
      *a2 = 0;
      a2[1] = 0;
      a2[2] = 0;
      return result;
    }
    v5 = (char *)result[2];
    v3 = (char *)result[4];
  }
  return sub_1000E0718(a2, v5, v3, v3 - v5);
}

_QWORD *sub_1000E0718(_QWORD *result, char *a2, char *a3, unint64_t a4)
{
  _QWORD *v4;
  uint64_t v8;
  uint64_t v9;
  char v10;

  v4 = result;
  if (a4 >= 0x7FFFFFFFFFFFFFF8)
    sub_1000CB4A4();
  if (a4 > 0x16)
  {
    v8 = (a4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((a4 | 7) != 0x17)
      v8 = a4 | 7;
    v9 = v8 + 1;
    result = operator new(v8 + 1);
    v4[1] = a4;
    v4[2] = v9 | 0x8000000000000000;
    *v4 = result;
    v4 = result;
  }
  else
  {
    *((_BYTE *)result + 23) = a4;
  }
  while (a2 != a3)
  {
    v10 = *a2++;
    *(_BYTE *)v4 = v10;
    v4 = (_QWORD *)((char *)v4 + 1);
  }
  *(_BYTE *)v4 = 0;
  return result;
}

SERestoreInfo::UpdateTable *SERestoreInfo::UpdateTable::UpdateTable(SERestoreInfo::UpdateTable *this, DERItem *a2)
{
  unint64_t *v3;
  uint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  char *v7;
  BOOL v8;
  int v9;
  int v10;
  BOOL v11;
  _WORD *size;
  unsigned int v13;
  unsigned int v14;
  std::string::size_type v15;
  _WORD *v16;
  uint64_t v17;
  uint64_t v18;
  std::string::size_type v19;
  uint64_t v20;
  char *v21;
  char *v22;
  __int16 v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  _BYTE *v27;
  __int16 v28;
  int v29;
  __int16 v30;
  unsigned __int8 *v31;
  _WORD *v32;
  _QWORD *v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  std::runtime_error *v38;
  std::string *v39;
  std::string *v40;
  __int128 v41;
  void *v42;
  void *v43;
  uint64_t v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *exception;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  uint64_t *v59;
  __int128 v60;
  void *__p[2];
  __int128 v62;
  unint64_t v63;
  char *v64;
  uint64_t v65;
  unint64_t v66[2];
  char v67[16];
  char *v68;
  unint64_t v69;
  uint64_t v70[3];
  std::string v71;

  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  v59 = (uint64_t *)((char *)this + 8);
  *((_QWORD *)this + 3) = 0;
  v3 = DERParseSequenceContent((unint64_t *)a2, 3u, (uint64_t)&unk_100167760, (unint64_t)v67, 0x30uLL);
  if ((_DWORD)v3)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v60, "Cannot parse UpdateTable.");
    v52 = (void *)SERestoreInfo::SEException::SEException(exception, &v60, v3, CFSTR("libDERErrorDomain"));
  }
  v4 = DERParseInteger(&v68, this);
  if ((_DWORD)v4)
  {
    v53 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v60, "Cannot parse UpdateTable.bsn.");
    v54 = (void *)SERestoreInfo::SEException::SEException(v53, &v60, v4, CFSTR("libDERErrorDomain"));
  }
  v5 = DERDecodeSeqContentInit(&v69, v66);
  if ((_DWORD)v5)
  {
    v55 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v60, "Cannot parse UpdateTable entries");
    v56 = (void *)SERestoreInfo::SEException::SEException(v55, &v60, v5, CFSTR("libDERErrorDomain"));
  }
  while (1)
  {
    v6 = DERDecodeSeqNext(v66, &v63);
    if ((_DWORD)v6)
      break;
    v7 = v64;
    if (v64)
      v8 = v65 == 0;
    else
      v8 = 1;
    if (v8)
    {
      v38 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      v39 = (std::string *)sub_1000CB3F4(v70, "Assertion: ");
      v40 = std::string::append(v39, "entry.data && entry.length");
      v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
      v71.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v71.__r_.__value_.__l.__data_ = v41;
      v40->__r_.__value_.__l.__size_ = 0;
      v40->__r_.__value_.__r.__words[2] = 0;
      v40->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v38, &v71);
    }
    v9 = 0;
    *(_OWORD *)__p = 0u;
    v62 = 0u;
    v60 = 0u;
    do
    {
      if (v7 >= &v64[v65])
        break;
      v10 = *v7;
      if (*v7)
        v11 = (v10 & 1) == 0;
      else
        v11 = 0;
      if (!v11)
      {
        v42 = __cxa_allocate_exception(0x48uLL);
        sub_1000CB3F4(&v71, "Wrong length for updateTableEnry");
        v43 = (void *)SERestoreInfo::SEException::SEException(v42, &v71, 2, CFSTR("SEUpdaterErrorDomain"));
      }
      size = 0;
      ++v7;
      memset(&v71, 0, sizeof(v71));
      do
      {
        v13 = *(unsigned __int16 *)v7;
        v7 += 2;
        v14 = bswap32(v13) >> 16;
        if ((unint64_t)size >= v71.__r_.__value_.__r.__words[2])
        {
          v16 = (_WORD *)v71.__r_.__value_.__r.__words[0];
          v17 = (uint64_t)size - v71.__r_.__value_.__r.__words[0];
          if ((uint64_t)((uint64_t)size - v71.__r_.__value_.__r.__words[0]) <= -3)
            sub_1000CB780();
          v18 = v17 >> 1;
          if (v71.__r_.__value_.__r.__words[2] - v71.__r_.__value_.__r.__words[0] <= (v17 >> 1) + 1)
            v19 = v18 + 1;
          else
            v19 = v71.__r_.__value_.__r.__words[2] - v71.__r_.__value_.__r.__words[0];
          if (v71.__r_.__value_.__r.__words[2] - v71.__r_.__value_.__r.__words[0] >= 0x7FFFFFFFFFFFFFFELL)
            v20 = 0x7FFFFFFFFFFFFFFFLL;
          else
            v20 = v19;
          if (v20)
          {
            v21 = (char *)sub_1000E3DA8((uint64_t)&v71.__r_.__value_.__r.__words[2], v20);
            size = (_WORD *)v71.__r_.__value_.__l.__size_;
            v16 = (_WORD *)v71.__r_.__value_.__r.__words[0];
          }
          else
          {
            v21 = 0;
          }
          v22 = &v21[2 * v18];
          *(_WORD *)v22 = v14;
          v15 = (std::string::size_type)(v22 + 2);
          while (size != v16)
          {
            v23 = *--size;
            *((_WORD *)v22 - 1) = v23;
            v22 -= 2;
          }
          v71.__r_.__value_.__r.__words[0] = (std::string::size_type)v22;
          v71.__r_.__value_.__l.__size_ = v15;
          v71.__r_.__value_.__r.__words[2] = (std::string::size_type)&v21[2 * v20];
          if (v16)
            operator delete(v16);
        }
        else
        {
          *size = v14;
          v15 = (std::string::size_type)(size + 1);
        }
        v71.__r_.__value_.__l.__size_ = v15;
        v10 -= 2;
        size = (_WORD *)v15;
      }
      while ((_BYTE)v10);
      v24 = (_QWORD *)*((_QWORD *)&v60 + 1);
      if ((void *)*((_QWORD *)&v60 + 1) >= __p[0])
      {
        v25 = sub_1000E3DD8((uint64_t *)&v60, (uint64_t)&v71);
      }
      else
      {
        **((_QWORD **)&v60 + 1) = 0;
        v24[1] = 0;
        v24[2] = 0;
        sub_1000E4F48(v24, v71.__r_.__value_.__l.__data_, v71.__r_.__value_.__l.__size_, (uint64_t)(v71.__r_.__value_.__l.__size_ - v71.__r_.__value_.__r.__words[0]) >> 1);
        v25 = (uint64_t)(v24 + 3);
      }
      *((_QWORD *)&v60 + 1) = v25;
      if (v71.__r_.__value_.__r.__words[0])
      {
        v71.__r_.__value_.__l.__size_ = v71.__r_.__value_.__r.__words[0];
        operator delete(v71.__r_.__value_.__l.__data_);
      }
      ++v9;
    }
    while (v9 != 4);
    v27 = v7 + 1;
    v26 = *v7;
    if (*v7)
    {
      v28 = 0;
      v29 = *v7;
      do
      {
        --v29;
        v30 = *v27++;
        v28 = v30 | (v28 << 8);
      }
      while ((_BYTE)v29);
      v31 = (unsigned __int8 *)&v7[(v26 - 1)];
      v7 += v26;
      v27 = v31 + 2;
    }
    else
    {
      v28 = 0;
    }
    memset(&v71, 0, sizeof(v71));
    v32 = operator new(2uLL);
    *v32 = v28;
    v71.__r_.__value_.__l.__size_ = (std::string::size_type)(v32 + 1);
    v71.__r_.__value_.__r.__words[2] = (std::string::size_type)(v32 + 1);
    v33 = (_QWORD *)*((_QWORD *)&v60 + 1);
    v71.__r_.__value_.__r.__words[0] = (std::string::size_type)v32;
    if ((void *)*((_QWORD *)&v60 + 1) >= __p[0])
    {
      v34 = sub_1000E3DD8((uint64_t *)&v60, (uint64_t)&v71);
    }
    else
    {
      **((_QWORD **)&v60 + 1) = 0;
      v33[1] = 0;
      v33[2] = 0;
      sub_1000E4F48(v33, v71.__r_.__value_.__l.__data_, v71.__r_.__value_.__l.__size_, (uint64_t)(v71.__r_.__value_.__l.__size_ - v71.__r_.__value_.__r.__words[0]) >> 1);
      v34 = (uint64_t)(v33 + 3);
    }
    *((_QWORD *)&v60 + 1) = v34;
    if (v71.__r_.__value_.__r.__words[0])
    {
      v71.__r_.__value_.__l.__size_ = v71.__r_.__value_.__r.__words[0];
      operator delete(v71.__r_.__value_.__l.__data_);
    }
    if (*v27 != 32)
    {
      v47 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v71, "wrong updateTableEnry with wrong hash size");
      v48 = (void *)SERestoreInfo::SEException::SEException(v47, &v71, 15, CFSTR("SEUpdaterErrorDomain"));
    }
    sub_1000DDD98(&__p[1], v7 + 2, v7 + 34, 0x20uLL);
    if (*((_QWORD *)&v60 + 1) - (_QWORD)v60 != 120)
    {
      v49 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v71, "Missing element in updateTableEnry");
      v50 = (void *)SERestoreInfo::SEException::SEException(v49, &v71, 15, CFSTR("SEUpdaterErrorDomain"));
    }
    v35 = *((_QWORD *)this + 2);
    if (v35 >= *((_QWORD *)this + 3))
    {
      v36 = sub_1000E4934(v59, (uint64_t)&v60);
    }
    else
    {
      sub_1000E4A40((uint64_t)this + 24, *((_QWORD **)this + 2), (uint64_t)&v60);
      v36 = v35 + 48;
      *((_QWORD *)this + 2) = v35 + 48;
    }
    *((_QWORD *)this + 2) = v36;
    if (__p[1])
    {
      *(void **)&v62 = __p[1];
      operator delete(__p[1]);
    }
    v71.__r_.__value_.__r.__words[0] = (std::string::size_type)&v60;
    sub_1000E4104((void ***)&v71);
  }
  if ((_DWORD)v6 != 1)
  {
    v44 = v6;
    v45 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v60, "Wrong UpdateTable entries");
    v46 = (void *)SERestoreInfo::SEException::SEException(v45, &v60, v44, CFSTR("libDERErrorDomain"));
  }
  if (*((_QWORD *)this + 1) == *((_QWORD *)this + 2))
  {
    v57 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v60, "Size of UpdateTable.entries is zero");
    v58 = (void *)SERestoreInfo::SEException::SEException(v57, &v60, 15, CFSTR("SEUpdaterErrorDomain"));
  }
  return this;
}

void sub_1000E0E4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a16 < 0)
    operator delete(__p);
  a25 = a10;
  sub_1000E48B0((void ***)&a25);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E0F90(uint64_t a1)
{
  void *v2;
  void **v4;

  v2 = *(void **)(a1 + 24);
  if (v2)
  {
    *(_QWORD *)(a1 + 32) = v2;
    operator delete(v2);
  }
  v4 = (void **)a1;
  sub_1000E4104(&v4);
  return a1;
}

uint64_t SERestoreInfo::ImageBinary::print@<X0>(int *a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;
  size_t v14;
  _QWORD *v15;
  _QWORD *v16;
  void **v17;
  uint64_t v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  uint64_t v21;
  void *__p[2];
  unsigned __int8 v24;
  uint64_t (**v25)();
  _QWORD v26[10];
  char v27;
  uint64_t (**v28)();
  std::locale v29;

  sub_1000DF2B0((uint64_t)&v25);
  v6 = *(char *)(a2 + 23);
  if (v6 >= 0)
    v7 = a2;
  else
    v7 = *(_QWORD *)a2;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a2 + 23);
  else
    v8 = *(_QWORD *)(a2 + 8);
  v9 = sub_1000DC764(&v25, v7, v8);
  v10 = sub_1000DC764(v9, (uint64_t)"[", 1);
  v11 = (_QWORD *)std::ostream::operator<<(v10, a1[10]);
  v12 = sub_1000DC764(v11, (uint64_t)"] ", 2);
  v13 = sub_1000DC764(v12, (uint64_t)"{", 1);
  v14 = strlen(off_100183258[*a1]);
  v15 = sub_1000DC764(v13, (uint64_t)off_100183258[*a1], v14);
  v16 = sub_1000DC764(v15, (uint64_t)"}: ", 3);
  sub_1000E0718(__p, *((char **)a1 + 2), (char *)(*((_QWORD *)a1 + 2) + *((_QWORD *)a1 + 3)), *((_QWORD *)a1 + 3));
  if ((v24 & 0x80u) == 0)
    v17 = __p;
  else
    v17 = (void **)__p[0];
  if ((v24 & 0x80u) == 0)
    v18 = v24;
  else
    v18 = (uint64_t)__p[1];
  v19 = sub_1000DC764(v16, (uint64_t)v17, v18);
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
  v20 = std::locale::use_facet(&v29, &std::ctype<char>::id);
  v21 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v29);
  std::ostream::put(v19, v21);
  std::ostream::flush(v19);
  if ((char)v24 < 0)
    operator delete(__p[0]);
  sub_1000E06CC(v26, a3);
  v28 = off_100183128;
  v25 = off_100183100;
  v26[0] = off_1001831D0;
  if (v27 < 0)
    operator delete((void *)v26[8]);
  std::streambuf::~streambuf(v26);
  std::ostream::~ostream(&v25, off_100183140);
  return std::ios::~ios(&v28);
}

void sub_1000E11BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  sub_1000DF404((uint64_t)&a16);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::UpdateTableEntry::print@<X0>(unsigned __int16 ***a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  _QWORD *v10;
  void **v11;
  uint64_t v12;
  _QWORD *v13;
  _OWORD *v14;
  uint64_t i;
  void **v16;
  int v17;
  void **v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;
  uint64_t v22;
  std::locale::__imp *v23;
  std::locale::__imp *locale;
  int v25;
  _QWORD *v26;
  _QWORD *v27;
  const std::locale::facet *v28;
  uint64_t v29;
  uint64_t j;
  _OWORD *v32;
  std::locale v33;
  std::locale::__imp *v34;
  uint64_t v35;
  uint64_t (**v36)();
  _QWORD v37[10];
  char v38;
  uint64_t (**v39)();
  void *v40[2];
  unsigned __int8 v41;
  _QWORD v42[3];
  _QWORD v43[3];
  _QWORD v44[3];
  _QWORD v45[3];

  sub_1000DF2B0((uint64_t)&v36);
  v6 = *(char *)(a2 + 23);
  if (v6 >= 0)
    v7 = a2;
  else
    v7 = *(_QWORD *)a2;
  if (v6 >= 0)
    v8 = *(unsigned __int8 *)(a2 + 23);
  else
    v8 = *(_QWORD *)(a2 + 8);
  sub_1000DC764(&v36, v7, v8);
  if (a1[1] == *a1)
    sub_1000E4F34();
  v9 = ***a1;
  v10 = sub_1000DC764(&v36, (uint64_t)"|", 1);
  SERestoreInfo::P73BaseDeviceInfo::getStateName(v9, v40);
  if ((v41 & 0x80u) == 0)
    v11 = v40;
  else
    v11 = (void **)v40[0];
  if ((v41 & 0x80u) == 0)
    v12 = v41;
  else
    v12 = (uint64_t)v40[1];
  v13 = sub_1000DC764(v10, (uint64_t)v11, v12);
  sub_1000DC764(v13, (uint64_t)"| ", 2);
  if ((char)v41 < 0)
    operator delete(v40[0]);
  v14 = operator new(0x10uLL);
  *v14 = xmmword_100167750;
  sub_1000CB3F4(v40, "AMS");
  v32 = v14;
  sub_1000CB3F4(v42, "RSN");
  sub_1000CB3F4(v43, "CSN");
  sub_1000CB3F4(v44, "FSN");
  sub_1000CB3F4(v45, "ACTION");
  for (i = 0; i != 4; ++i)
  {
    v16 = &v40[3 * *((int *)v14 + i)];
    v17 = *((char *)v16 + 23);
    if (v17 >= 0)
      v18 = &v40[3 * *((int *)v14 + i)];
    else
      v18 = (void **)*v16;
    if (v17 >= 0)
      v19 = *((unsigned __int8 *)v16 + 23);
    else
      v19 = (uint64_t)v16[1];
    v20 = sub_1000DC764(&v36, (uint64_t)v18, v19);
    sub_1000DC764(v20, (uint64_t)" { ", 3);
    v21 = *((int *)v14 + i);
    if (0xAAAAAAAAAAAAAAABLL * (a1[1] - *a1) <= v21)
      sub_1000E4F34();
    v22 = (uint64_t)&(*a1)[3 * (int)v21];
    v33.__locale_ = 0;
    v34 = 0;
    v35 = 0;
    sub_1000E4F48(&v33, *(const void **)v22, *(_QWORD *)(v22 + 8), (uint64_t)(*(_QWORD *)(v22 + 8) - *(_QWORD *)v22) >> 1);
    locale = v33.__locale_;
    v23 = v34;
    if (v33.__locale_ != v34)
    {
      v25 = 0;
      do
      {
        if (v25)
          sub_1000DC764(&v36, (uint64_t)",", 1);
        *(_DWORD *)((char *)v37 + (_QWORD)*(v36 - 3)) = *(_DWORD *)((_BYTE *)v37 + (_QWORD)*(v36 - 3)) & 0xFFFFFFB5 | 8;
        v26 = sub_1000DC764(&v36, (uint64_t)"0x", 2);
        v27 = (_QWORD *)std::ostream::operator<<(v26, *(unsigned __int16 *)locale);
        sub_1000DC764(v27, (uint64_t)" ", 1);
        locale = (std::locale::__imp *)((char *)locale + 2);
        --v25;
      }
      while (locale != v23);
    }
    sub_1000DC764(&v36, (uint64_t)"} ", 2);
    v14 = v32;
    if (v33.__locale_)
    {
      v34 = v33.__locale_;
      operator delete(v33.__locale_);
    }
  }
  std::ios_base::getloc((const std::ios_base *)((char *)&v37[-1] + (_QWORD)*(v36 - 3)));
  v28 = std::locale::use_facet(&v33, &std::ctype<char>::id);
  v29 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v28->__vftable[2].~facet_0)(v28, 10);
  std::locale::~locale(&v33);
  std::ostream::put(&v36, v29);
  std::ostream::flush(&v36);
  sub_1000E06CC(v37, a3);
  for (j = 0; j != -15; j -= 3)
  {
    if (SHIBYTE(v45[j + 2]) < 0)
      operator delete((void *)v45[j]);
  }
  operator delete(v32);
  v39 = off_100183128;
  v36 = off_100183100;
  v37[0] = off_1001831D0;
  if (v38 < 0)
    operator delete((void *)v37[8]);
  std::streambuf::~streambuf(v37);
  std::ostream::~ostream(&v36, off_100183140);
  return std::ios::~ios(&v39);
}

void sub_1000E15FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::locale a12, uint64_t a13, uint64_t a14, char a15)
{
  void *v15;

  operator delete(v15);
  sub_1000DF404((uint64_t)&a15);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::UpdateTable::print@<X0>(unsigned int *a1@<X0>, void **a2@<X1>, _QWORD *a3@<X8>)
{
  int v6;
  void *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  uint64_t v14;
  unsigned __int16 ***i;
  unsigned __int16 ***v16;
  void *locale;
  uint64_t v18;
  void *__p[2];
  void *v21;
  std::locale v22;
  uint64_t v23;
  unsigned __int8 v24;
  uint64_t (**v25)();
  _QWORD v26[10];
  char v27;
  uint64_t (**v28)();

  sub_1000DF2B0((uint64_t)&v25);
  v6 = *((char *)a2 + 23);
  if (v6 >= 0)
    v7 = a2;
  else
    v7 = *a2;
  if (v6 >= 0)
    v8 = *((unsigned __int8 *)a2 + 23);
  else
    v8 = (uint64_t)a2[1];
  v9 = sub_1000DC764(&v25, (uint64_t)v7, v8);
  v10 = sub_1000DC764(v9, (uint64_t)"BSN: ", 5);
  *(_DWORD *)((char *)v10 + *(_QWORD *)(*v10 - 24) + 8) = *(_DWORD *)((_BYTE *)v10 + *(_QWORD *)(*v10 - 24) + 8) & 0xFFFFFFB5 | 8;
  v11 = sub_1000DC764(v10, (uint64_t)"0x", 2);
  v12 = (_QWORD *)std::ostream::operator<<(v11, *a1);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet(&v22, &std::ctype<char>::id);
  v14 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v22);
  std::ostream::put(v12, v14);
  std::ostream::flush(v12);
  v16 = (unsigned __int16 ***)*((_QWORD *)a1 + 1);
  for (i = (unsigned __int16 ***)*((_QWORD *)a1 + 2); v16 != i; v16 += 6)
  {
    if (*((char *)a2 + 23) < 0)
    {
      sub_1000CB554(__p, *a2, (unint64_t)a2[1]);
    }
    else
    {
      *(_OWORD *)__p = *(_OWORD *)a2;
      v21 = a2[2];
    }
    SERestoreInfo::UpdateTableEntry::print(v16, (uint64_t)__p, &v22);
    if ((v24 & 0x80u) == 0)
      locale = &v22;
    else
      locale = v22.__locale_;
    if ((v24 & 0x80u) == 0)
      v18 = v24;
    else
      v18 = v23;
    sub_1000DC764(&v25, (uint64_t)locale, v18);
    if ((char)v24 < 0)
      operator delete(v22.__locale_);
    if (SHIBYTE(v21) < 0)
      operator delete(__p[0]);
  }
  sub_1000E06CC(v26, a3);
  v28 = off_100183128;
  v25 = off_100183100;
  v26[0] = off_1001831D0;
  if (v27 < 0)
    operator delete((void *)v26[8]);
  std::streambuf::~streambuf(v26);
  std::ostream::~ostream(&v25, off_100183140);
  return std::ios::~ios(&v28);
}

void sub_1000E18F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, std::locale a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,char a22)
{
  std::locale::~locale(&a16);
  sub_1000DF404((uint64_t)&a22);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::updateMeasurement(SERestoreInfo::P73BaseDeliveryObject *this, CFDictionaryRef theDict, __CFError **a3)
{
  BOOL v6;
  CFTypeID v7;
  __CFDictionary *v8;
  CFMutableDictionaryRef Mutable;
  unint64_t *v10;
  unint64_t v11;
  std::string::size_type v12;
  CFDataRef v13;
  _BOOL4 isDev;
  __CFString **v15;
  int v16;
  char v17;
  std::runtime_error *exception;
  std::string *v20;
  __int128 v21;
  void *v22[2];
  char v23;
  void *v24[2];
  char v25;
  std::string value;
  std::string __p;
  char v28;

  if (!theDict || !a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&value, "Assertion: ");
    v20 = std::string::append(&value, "outError && outMeasurementDict");
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &__p);
  }
  value.__r_.__value_.__r.__words[0] = 0;
  if (CFDictionaryGetValueIfPresent(theDict, CFSTR("SE,UpdatePayload"), (const void **)&value.__r_.__value_.__l.__data_))
  {
    v6 = value.__r_.__value_.__r.__words[0] == 0;
  }
  else
  {
    v6 = 1;
  }
  if (!v6)
  {
    v7 = CFGetTypeID(value.__r_.__value_.__l.__data_);
    if (v7 == CFDictionaryGetTypeID())
    {
      if (value.__r_.__value_.__r.__words[0])
        v8 = (__CFDictionary *)CFRetain(value.__r_.__value_.__l.__data_);
      else
        v8 = 0;
      goto LABEL_12;
    }
  }
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v8 = Mutable;
    CFDictionarySetValue(theDict, CFSTR("SE,UpdatePayload"), Mutable);
LABEL_12:
    v10 = (unint64_t *)ccsha256_di();
    memset(&__p, 0, sizeof(__p));
    v11 = *v10;
    v28 = 0;
    if (v11)
    {
      sub_1000E4198(&__p, v11, &v28);
      v12 = __p.__r_.__value_.__r.__words[0];
    }
    else
    {
      v12 = 0;
    }
    ccdigest(v10, *((_QWORD *)this + 6), *((_QWORD *)this + 5), v12);
    v13 = CFDataCreate(0, (const UInt8 *)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]);
    if (v13)
    {
      isDev = SERestoreInfo::P73BaseDeliveryObject::isDev(this);
      v15 = kSETagMeasurementDevHash;
      if (!isDev)
        v15 = kSETagMeasurementProdHash;
      CFDictionarySetValue(v8, *v15, v13);
      v16 = 0;
    }
    else
    {
      sub_1000CB3F4(v22, "Fail to allocate tmpData");
      *a3 = SERestoreInfo::CreateCFError((const UInt8 *)v22, 3, 0, CFSTR("SEUpdaterErrorDomain"));
      if (v23 < 0)
        operator delete(v22[0]);
      v16 = 6;
    }
    if (__p.__r_.__value_.__r.__words[0])
    {
      __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
      operator delete(__p.__r_.__value_.__l.__data_);
    }
    if (v16 == 6)
    {
      v17 = 0;
      if (!v8)
      {
LABEL_24:
        if (v13)
          CFRelease(v13);
        return v17 & 1;
      }
    }
    else
    {
      v17 = 1;
      if (!v8)
        goto LABEL_24;
    }
    CFRelease(v8);
    goto LABEL_24;
  }
  sub_1000CB3F4(v24, "Fail to allocate imageProps");
  *a3 = SERestoreInfo::CreateCFError((const UInt8 *)v24, 3, 0, CFSTR("SEUpdaterErrorDomain"));
  if (v25 < 0)
    operator delete(v24[0]);
  v17 = 0;
  return v17 & 1;
}

void sub_1000E1BFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,void *a28,uint64_t a29,int a30,__int16 a31,char a32,char a33)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

BOOL SERestoreInfo::P73BaseDeliveryObject::isDev(SERestoreInfo::P73BaseDeliveryObject *this)
{
  uint64_t *v1;
  BOOL v5;
  BOOL v6;
  BOOL v8;
  BOOL v9;
  BOOL v11;
  BOOL v12;
  BOOL v14;
  BOOL v15;
  BOOL v17;
  BOOL v18;
  BOOL v20;
  BOOL v21;
  BOOL v23;
  BOOL v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v1 = (uint64_t *)*((_QWORD *)this + 8);
  if (*((_QWORD *)this + 9) - (_QWORD)v1 != 32)
    return 0;
  if (*v1 == 0x7B77E47DEC309FF8
    && v1[1] == 0x8BF8D2A44AE3A97CLL
    && v1[2] == 0xAD34DB13A59CC364
    && v1[3] == 0xAC0A2E6B4C223984)
  {
    return 1;
  }
  v5 = *v1 == 0x74975A216330E276 && v1[1] == 0x1F7F7DD3B6FB8D34;
  v6 = v5 && v1[2] == 0x3FA240FAC488FFFLL;
  if (v6 && v1[3] == 0x21EC7881080683DALL)
    return 1;
  v8 = *v1 == 0xD314CD88B2A173ABLL && v1[1] == 0xD0014B39DB0B4552;
  v9 = v8 && v1[2] == 0xC3B3802C47832D1BLL;
  if (v9 && v1[3] == 0x102CA645D536B9F3)
    return 1;
  v11 = *v1 == 0x43028028D9EE140FLL && v1[1] == 0x764EF91F0B455B82;
  v12 = v11 && v1[2] == 0x74D2E6CF8CD1659BLL;
  if (v12 && v1[3] == 0xBD4FC5BCF7FB4792)
    return 1;
  v14 = *v1 == 0x19016EC184635976 && v1[1] == 0xD25BD62A9019D9A3;
  v15 = v14 && v1[2] == 0xFD6855BA8DAED7D1;
  if (v15 && v1[3] == 0x3E6F156DACCAB98)
    return 1;
  v17 = *v1 == 0x4B4B6EEF8151F8B0 && v1[1] == 0x80D0BF7EE34277A5;
  v18 = v17 && v1[2] == 0xA6421FFAFBC6C2D3;
  if (v18 && v1[3] == 0x11CF79E52F051694)
    return 1;
  v20 = *v1 == 0x3B369AD4F6E8946ALL && v1[1] == 0x3A6B9A9BB3089AACLL;
  v21 = v20 && v1[2] == 0x8FA19016C1B6DB7CLL;
  if (v21 && v1[3] == 0x40ACEFB5D4F4787)
    return 1;
  v23 = *v1 == 0xFC41962122793EF7 && v1[1] == 0xB912209BBCCC0208;
  v24 = v23 && v1[2] == 0xA845838AEC9D85B0;
  if (v24 && v1[3] == 0x1DAD2E5A3D9AD8A8)
    return 1;
  v26 = *v1;
  v27 = v1[1];
  v29 = v1[2];
  v28 = v1[3];
  return v26 == 0xCBD1BDB61BAAD564
      && v27 == 0x957F8100699D3DAALL
      && v29 == 0xB07184D6337E1DBCLL
      && v28 == 0x710CE2BFF2A6DF1CLL;
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::updateVersionDict(SERestoreInfo::P73BaseDeliveryObject *this, __CFDictionary *a2, __CFError **a3)
{
  CFStringRef v5;
  _BOOL4 isDev;
  __CFString **v7;
  std::runtime_error *exception;
  std::string *v10;
  __int128 v11;
  std::string v12;
  std::string v13;

  if (!a2 || !a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v12, "Assertion: ");
    v10 = std::string::append(&v12, "outError && outDict");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v13.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v13);
  }
  v5 = CFStringCreateWithBytes(0, *((const UInt8 **)this + 12), *((_QWORD *)this + 13), 0x8000100u, 0);
  isDev = SERestoreInfo::P73BaseDeliveryObject::isDev(this);
  v7 = kSETagVersionDev;
  if (!isDev)
    v7 = kSETagVersionProd;
  CFDictionarySetValue(a2, *v7, v5);
  if (v5)
    CFRelease(v5);
  return 1;
}

void sub_1000E2110(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

BOOL SERestoreInfo::P73BaseDeliveryObject::matchID(uint64_t a1, uint64_t a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(uint64_t **)a2;
  if (*(_QWORD *)(a2 + 8) - *(_QWORD *)a2 != 32)
    return 0;
  v3 = *(uint64_t **)(a1 + 64);
  v4 = *v3;
  v5 = v3[1];
  v6 = *v2;
  v7 = v2[1];
  v9 = v3[2];
  v8 = v3[3];
  v11 = v2[2];
  v10 = v2[3];
  return v4 == v6 && v5 == v7 && v9 == v11 && v8 == v10;
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::print@<X0>(SERestoreInfo::P73BaseDeliveryObject *this@<X0>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  std::string *p_p;
  std::string::size_type size;
  _QWORD *v7;
  const std::locale::facet *v8;
  uint64_t v9;
  _QWORD *v10;
  std::string *v11;
  std::string::size_type v12;
  _QWORD *v13;
  const std::locale::facet *v14;
  uint64_t v15;
  _QWORD *v16;
  const std::locale::facet *v17;
  uint64_t v18;
  std::string *v19;
  std::string::size_type v20;
  _QWORD *v21;
  const std::locale::facet *v22;
  uint64_t v23;
  _QWORD *v24;
  const std::locale::facet *v25;
  uint64_t v26;
  SERestoreInfo::P73BaseDeliveryObject *v27;
  std::string *v28;
  std::string::size_type v29;
  SERestoreInfo::P73BaseDeliveryObject *v30;
  SERestoreInfo::P73BaseDeliveryObject *v31;
  BOOL v32;
  void *v34[2];
  char v35;
  void *v36[2];
  char v37;
  std::string __p;
  uint64_t (**v39)();
  _QWORD v40[10];
  char v41;
  uint64_t (**v42)();
  std::locale v43;

  sub_1000DF2B0((uint64_t)&v39);
  v4 = sub_1000DC764(&v39, (uint64_t)"Details: ", 9);
  sub_1000E0718(&__p, *((char **)this + 12), (char *)(*((_QWORD *)this + 12) + *((_QWORD *)this + 13)), *((_QWORD *)this + 13));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_p = &__p;
  else
    p_p = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    size = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    size = __p.__r_.__value_.__l.__size_;
  v7 = sub_1000DC764(v4, (uint64_t)p_p, size);
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v8 = std::locale::use_facet(&v43, &std::ctype<char>::id);
  v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v43);
  std::ostream::put(v7, v9);
  std::ostream::flush(v7);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v10 = sub_1000DC764(&v39, (uint64_t)"FactoryPostflight revision: ", 28);
  std::to_string(&__p, *((unsigned __int8 *)this + 152));
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v11 = &__p;
  else
    v11 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v12 = __p.__r_.__value_.__l.__size_;
  v13 = sub_1000DC764(v10, (uint64_t)v11, v12);
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(_QWORD *)(*v13 - 24)));
  v14 = std::locale::use_facet(&v43, &std::ctype<char>::id);
  v15 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
  std::locale::~locale(&v43);
  std::ostream::put(v13, v15);
  std::ostream::flush(v13);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  v16 = sub_1000DC764(&v39, (uint64_t)"UpdateTable: ", 13);
  std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(_QWORD *)(*v16 - 24)));
  v17 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  v18 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put(v16, v18);
  std::ostream::flush(v16);
  sub_1000CB3F4(v36, "\t");
  SERestoreInfo::UpdateTable::print((unsigned int *)this + 30, v36, &__p);
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v19 = &__p;
  else
    v19 = (std::string *)__p.__r_.__value_.__r.__words[0];
  if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v20 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
  else
    v20 = __p.__r_.__value_.__l.__size_;
  v21 = sub_1000DC764(v16, (uint64_t)v19, v20);
  std::ios_base::getloc((const std::ios_base *)((char *)v21 + *(_QWORD *)(*v21 - 24)));
  v22 = std::locale::use_facet(&v43, &std::ctype<char>::id);
  v23 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 10);
  std::locale::~locale(&v43);
  std::ostream::put(v21, v23);
  std::ostream::flush(v21);
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (v37 < 0)
    operator delete(v36[0]);
  v24 = sub_1000DC764(&v39, (uint64_t)"Binaries: ", 10);
  std::ios_base::getloc((const std::ios_base *)((char *)v24 + *(_QWORD *)(*v24 - 24)));
  v25 = std::locale::use_facet((const std::locale *)&__p, &std::ctype<char>::id);
  v26 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v25->__vftable[2].~facet_0)(v25, 10);
  std::locale::~locale((std::locale *)&__p);
  std::ostream::put(v24, v26);
  std::ostream::flush(v24);
  v27 = (SERestoreInfo::P73BaseDeliveryObject *)*((_QWORD *)this + 1);
  if (v27 != (SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 16))
  {
    do
    {
      sub_1000CB3F4(v34, "\t");
      SERestoreInfo::ImageBinary::print((int *)v27 + 10, (uint64_t)v34, &__p);
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v28 = &__p;
      else
        v28 = (std::string *)__p.__r_.__value_.__r.__words[0];
      if ((__p.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v29 = HIBYTE(__p.__r_.__value_.__r.__words[2]);
      else
        v29 = __p.__r_.__value_.__l.__size_;
      sub_1000DC764(&v39, (uint64_t)v28, v29);
      if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
        operator delete(__p.__r_.__value_.__l.__data_);
      if (v35 < 0)
        operator delete(v34[0]);
      v30 = (SERestoreInfo::P73BaseDeliveryObject *)*((_QWORD *)v27 + 1);
      if (v30)
      {
        do
        {
          v31 = v30;
          v30 = *(SERestoreInfo::P73BaseDeliveryObject **)v30;
        }
        while (v30);
      }
      else
      {
        do
        {
          v31 = (SERestoreInfo::P73BaseDeliveryObject *)*((_QWORD *)v27 + 2);
          v32 = *(_QWORD *)v31 == (_QWORD)v27;
          v27 = v31;
        }
        while (!v32);
      }
      v27 = v31;
    }
    while (v31 != (SERestoreInfo::P73BaseDeliveryObject *)((char *)this + 16));
  }
  sub_1000E06CC(v40, a2);
  v42 = off_100183128;
  v39 = off_100183100;
  v40[0] = off_1001831D0;
  if (v41 < 0)
    operator delete((void *)v40[8]);
  std::streambuf::~streambuf(v40);
  std::ostream::~ostream(&v39, off_100183140);
  return std::ios::~ios(&v42);
}

void sub_1000E2614(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21,std::locale a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,char a28)
{
  if (a21 < 0)
    operator delete(__p);
  sub_1000DF404((uint64_t)&a28);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73BaseDeliveryObject::parseFPRev(uint64_t a1)
{
  char *v1;
  unint64_t v2;
  std::string::size_type v3;
  std::string *p_str;
  uint64_t v5;
  unsigned __int8 v6;
  std::runtime_error *exception;
  std::string *v9;
  __int128 v10;
  std::string v11;
  std::string __str;
  char v13;

  v1 = *(char **)(a1 + 8);
  if (!v1 || (v2 = *(_QWORD *)(a1 + 16)) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v11, "Assertion: ");
    v9 = std::string::append(&v11, "data.data && data.length");
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    __str.__r_.__value_.__r.__words[2] = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__str.__r_.__value_.__l.__data_ = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &__str);
  }
  sub_1000E0718(&__str, v1, &v1[v2], v2);
  v3 = std::string::rfind(&__str, 45, 0xFFFFFFFFFFFFFFFFLL);
  if (v3 == -1)
    goto LABEL_16;
  std::string::basic_string(&v11, &__str, v3 + 1, 0xFFFFFFFFFFFFFFFFLL, (std::allocator<char> *)&v13);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  __str = v11;
  if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) < 0)
  {
    if (__str.__r_.__value_.__l.__size_ != 2)
      goto LABEL_16;
    p_str = (std::string *)__str.__r_.__value_.__r.__words[0];
  }
  else
  {
    if (SHIBYTE(v11.__r_.__value_.__r.__words[2]) != 2)
      goto LABEL_16;
    p_str = &__str;
  }
  v5 = 0;
  while ((p_str->__r_.__value_.__s.__data_[v5] & 0x80000000) == 0
       && (_DefaultRuneLocale.__runetype[p_str->__r_.__value_.__s.__data_[v5]] & 0x400) != 0)
  {
    if (++v5 == 2)
    {
      v6 = std::stoul(&__str, 0, 10);
      goto LABEL_17;
    }
  }
LABEL_16:
  v6 = -18;
LABEL_17:
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  return v6;
}

void sub_1000E2874(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void SERestoreInfo::P73BaseFirmware::updateMeasurementDict(__CFError *a1, uint64_t a2, _QWORD *a3)
{
  unsigned int **v6;
  void **v7;
  _OWORD *v8;
  char *v9;
  char *v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  int v19;
  SERestoreInfo::SERestoreInfoLog *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  unint64_t v24;
  const void *v25;
  size_t v26;
  char **v27;
  uint64_t *v28;
  std::__shared_weak_count *v29;
  unint64_t *v30;
  unint64_t v31;
  std::__shared_weak_count *v32;
  unint64_t *v33;
  unint64_t v34;
  char *v35;
  char *v36;
  char **v37;
  void **v38;
  SERestoreInfo::SEException *v39;
  void *v40;
  void *exception;
  void *v42;
  __CFError *v43[3];
  __n128 v44;
  __n128 v45;
  void *__p;
  char *v47;
  uint64_t v48;
  unsigned int **v49;
  unint64_t v50;

  v49 = 0;
  if (*a3)
  {
    (*(void (**)(void **__return_ptr))(*(_QWORD *)*a3 + 16))(&__p);
    v6 = (unsigned int **)operator new(0x18uLL);
    *v6 = 0;
    v6[1] = 0;
    v6[2] = 0;
    sub_1000DCDC0(v6, __p, (uint64_t)v47, v47 - (_BYTE *)__p);
    v43[0] = 0;
    v7 = (void **)v49;
    v49 = v6;
    if (v7)
    {
      sub_1000E4FFC((int)&v49, v7);
      v43[0] = 0;
    }
    if (__p)
    {
      v47 = (char *)__p;
      operator delete(__p);
    }
    if ((*(unsigned int (**)(_QWORD))(*(_QWORD *)*a3 + 32))(*a3) == 54)
    {
      v8 = operator new(0x20uLL);
      *v8 = xmmword_1001677A8;
      v8[1] = unk_1001677B8;
      v9 = (char *)operator new(0x20uLL);
      v10 = v9;
      *(_OWORD *)v9 = xmmword_1001677C8;
      *((_OWORD *)v9 + 1) = unk_1001677D8;
      v11 = *v49;
      if ((char *)v49[1] - (char *)*v49 == 32)
      {
        v12 = *(_QWORD *)v11;
        v13 = *((_QWORD *)v11 + 1);
        v15 = *((_QWORD *)v11 + 2);
        v14 = *((_QWORD *)v11 + 3);
        v16 = v12 == *(_QWORD *)v8 && v13 == *((_QWORD *)v8 + 1);
        v19 = v16 && v15 == *((_QWORD *)v8 + 2) && v14 == *((_QWORD *)v8 + 3);
      }
      else
      {
        v19 = 0;
      }
      v20 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get((SERestoreInfo::SERestoreInfoLog *)v9);
      SERestoreInfo::SERestoreInfoLog::printLog(v20, 2, "updateMeasurementDict", "KeyID 0x%X, overwriting with dev %d", bswap32(**v49), v19);
      if (v19)
        sub_1000DDD98(v49, v10, v10 + 32, 0x20uLL);
      operator delete(v10);
      operator delete(v8);
    }
  }
  v47 = 0;
  v48 = 0;
  __p = &v47;
  v43[0] = 0;
  v43[1] = a1;
  v21 = (*((_QWORD *)a1 + 3) - *((_QWORD *)a1 + 2)) >> 5;
  if (!(_DWORD)v21)
    goto LABEL_59;
  do
  {
    SERestoreInfo::SEFirmwareIter::operator*((uint64_t)v43);
    v22 = v45.n128_u64[0];
    v44 = v45;
    if (v45.n128_u64[1])
    {
      v23 = (unint64_t *)(v45.n128_u64[1] + 8);
      do
        v24 = __ldxr(v23);
      while (__stxr(v24 + 1, v23));
    }
    if (!v49
      || (v25 = *(const void **)(v22 + 64),
          v26 = *(_QWORD *)(v22 + 72) - (_QWORD)v25,
          v26 == (char *)v49[1] - (char *)*v49)
      && !memcmp(v25, *v49, v26))
    {
      v27 = (char **)sub_1000E50B8((uint64_t)&__p, (unsigned __int8 **)(v22 + 64));
      if (&v47 == v27)
      {
        sub_1000E53C0((uint64_t **)&__p, (unsigned __int8 **)(v44.n128_u64[0] + 64), v44.n128_u64[0] + 64, &v44);
      }
      else if (*(_DWORD *)(v44.n128_u64[0] + 160) > *((_DWORD *)v27[7] + 40))
      {
        v50 = v44.n128_u64[0] + 64;
        v28 = sub_1000E5198((uint64_t **)&__p, (unsigned __int8 **)(v44.n128_u64[0] + 64), (uint64_t)&unk_100167AA8, (uint64_t *)&v50);
        sub_1000C9FF8((uint64_t)(v28 + 7), (__int128 *)&v44);
      }
    }
    v29 = (std::__shared_weak_count *)v44.n128_u64[1];
    if (v44.n128_u64[1])
    {
      v30 = (unint64_t *)(v44.n128_u64[1] + 8);
      do
        v31 = __ldaxr(v30);
      while (__stlxr(v31 - 1, v30));
      if (!v31)
      {
        ((void (*)(std::__shared_weak_count *))v29->__on_zero_shared)(v29);
        std::__shared_weak_count::__release_weak(v29);
      }
    }
    v32 = (std::__shared_weak_count *)v45.n128_u64[1];
    if (v45.n128_u64[1])
    {
      v33 = (unint64_t *)(v45.n128_u64[1] + 8);
      do
        v34 = __ldaxr(v33);
      while (__stlxr(v34 - 1, v33));
      if (!v34)
      {
        ((void (*)(std::__shared_weak_count *))v32->__on_zero_shared)(v32);
        std::__shared_weak_count::__release_weak(v32);
      }
    }
    ++LODWORD(v43[0]);
  }
  while (LODWORD(v43[0]) != (_DWORD)v21);
  if (!v48)
  {
LABEL_59:
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v43, "No matching delivery object found.");
    v42 = (void *)SERestoreInfo::SEException::SEException(exception, v43, 24, CFSTR("SEUpdaterErrorDomain"));
  }
  v35 = (char *)__p;
  if (__p != &v47)
  {
    do
    {
      v43[0] = 0;
      (*(void (**)(_QWORD *, uint64_t, __CFError **))(**((_QWORD **)v35 + 7) + 16))(*((_QWORD **)v35 + 7), a2, v43);
      if (v43[0])
      {
        v39 = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
        v40 = (void *)SERestoreInfo::SEException::SEException(v39, v43[0]);
      }
      v36 = (char *)*((_QWORD *)v35 + 1);
      if (v36)
      {
        do
        {
          v37 = (char **)v36;
          v36 = *(char **)v36;
        }
        while (v36);
      }
      else
      {
        do
        {
          v37 = (char **)*((_QWORD *)v35 + 2);
          v16 = *v37 == v35;
          v35 = (char *)v37;
        }
        while (!v16);
      }
      v35 = (char *)v37;
    }
    while (v37 != &v47);
  }
  sub_1000E5034((uint64_t)&__p, v47);
  v38 = (void **)v49;
  v49 = 0;
  if (v38)
    sub_1000E4FFC((int)&v49, v38);
}

void sub_1000E2D08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  void *v23;
  uint64_t v24;
  void **v26;

  operator delete(v23);
  v26 = *(void ***)(v24 - 72);
  *(_QWORD *)(v24 - 72) = 0;
  if (v26)
    sub_1000E4FFC(v24 - 72, v26);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73BaseFirmware::makeDeliveryObject@<X0>(DERItem *a1@<X1>, _QWORD *a2@<X8>)
{
  BOOL v4;
  unint64_t *v5;
  char *v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  char *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  int64x2_t v32;
  uint64_t v33;
  uint64_t result;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  void *v41;
  void *v42;
  std::runtime_error *exception;
  std::string *v44;
  __int128 v45;
  std::runtime_error *v46;
  std::string *v47;
  std::string *v48;
  __int128 v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  void *v65;
  void *v66;
  void *v67;
  unint64_t *v68;
  void *v69;
  void *v70;
  void *v71;
  void *v72;
  void *v73;
  void *v74;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  void *v80;
  void *v81;
  void *v82;
  uint64_t (**v83)();
  __int128 v84;
  uint64_t v85;
  char *v86;
  char *v87;
  _QWORD v88[2];
  char *v89[2];
  char v90[16];
  uint64_t v91;
  DERItem v92;
  unint64_t v93;
  char v94[16];
  unint64_t v95[4];
  std::string v96;
  uint64_t v97;
  __int128 v98;
  __int128 v99;
  unint64_t v100[2];
  uint64_t (**v101)();
  __int128 v102;
  uint64_t v103;
  unint64_t v104;
  __int128 v105;
  unint64_t v106[2];
  unsigned int v107;
  std::string v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int64x2_t v112;
  _QWORD v113[2];
  char *v114[2];
  int64x2_t v115;
  char *v116;
  unint64_t v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120[2];
  uint64_t (**v121)();
  int64x2_t v122;
  uint64_t v123;
  _QWORD *v124;

  if (a1->data)
    v4 = a1->length == 0;
  else
    v4 = 1;
  if (v4)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v108, "Assertion: ");
    v44 = std::string::append(&v108, "input.data && input.length");
    v45 = *(_OWORD *)&v44->__r_.__value_.__l.__data_;
    v96.__r_.__value_.__r.__words[2] = v44->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v96.__r_.__value_.__l.__data_ = v45;
    v44->__r_.__value_.__l.__size_ = 0;
    v44->__r_.__value_.__r.__words[2] = 0;
    v44->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v96);
  }
  v5 = DERParseSequenceContent((unint64_t *)a1, 5u, (uint64_t)&unk_1001677E8, (unint64_t)&v96, 0x50uLL);
  if ((_DWORD)v5)
  {
    v68 = v5;
    v69 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v108, "Failed to parse as per DeliveryObjectItemSpec");
    v70 = (void *)SERestoreInfo::SEException::SEException(v69, &v108, v68, CFSTR("libDERErrorDomain"));
  }
  LODWORD(v108.__r_.__value_.__l.__data_) = 0;
  if (DERParseInteger(&v96.__r_.__value_.__l.__data_, &v108)
    || LODWORD(v108.__r_.__value_.__l.__data_)
    || v97 != 32)
  {
    v71 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v108, "Failed to validate delivery object");
    v72 = (void *)SERestoreInfo::SEException::SEException(v71, &v108, 15, CFSTR("SEUpdaterErrorDomain"));
  }
  v6 = (char *)operator new(0xC0uLL);
  *((_QWORD *)v6 + 1) = 0;
  *((_QWORD *)v6 + 2) = 0;
  *((_QWORD *)v6 + 3) = off_1001832D8;
  *(_QWORD *)v6 = off_100183370;
  *((_OWORD *)v6 + 8) = 0u;
  *((_OWORD *)v6 + 9) = 0u;
  *((_OWORD *)v6 + 10) = 0u;
  *((_OWORD *)v6 + 11) = 0u;
  *((_OWORD *)v6 + 7) = 0u;
  *((_QWORD *)v6 + 5) = 0;
  *((_QWORD *)v6 + 4) = v6 + 40;
  *((_QWORD *)v6 + 6) = 0;
  *((_QWORD *)v6 + 7) = off_100183340;
  *((_OWORD *)v6 + 4) = 0u;
  *((_OWORD *)v6 + 5) = 0u;
  *((_OWORD *)v6 + 6) = 0u;
  *((_QWORD *)v6 + 14) = off_100183340;
  *((_QWORD *)v6 + 19) = 0;
  *((_QWORD *)v6 + 20) = 0;
  *((_QWORD *)v6 + 21) = 0;
  v86 = v6 + 24;
  v87 = v6;
  sub_1000DDD98((_QWORD *)v6 + 11, (char *)v96.__r_.__value_.__r.__words[2], (char *)(v96.__r_.__value_.__r.__words[2] + 32), 0x20uLL);
  v108.__r_.__value_.__r.__words[0] = (std::string::size_type)off_100183340;
  *(_OWORD *)&v108.__r_.__value_.__r.__words[1] = v98;
  v109 = 0;
  sub_1000E3C54((_QWORD *)v6 + 14, &v108);
  sub_1000E42C4(&v108);
  v83 = off_100183340;
  v84 = *(_OWORD *)(v6 + 120);
  v85 = *((_QWORD *)v6 + 17);
  v6[176] = SERestoreInfo::P73BaseDeliveryObject::parseFPRev((uint64_t)&v83);
  sub_1000E42C4(&v83);
  v7 = DERParseSequence((uint64_t)&v99, 3u, (uint64_t)&unk_100167860, (unint64_t)v94, 0x30uLL);
  if ((_DWORD)v7)
  {
    v73 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v108, "Failed to parse updatePayload as per UpdatePayloadItemSpec");
    v74 = (void *)SERestoreInfo::SEException::SEException(v73, &v108, v7, CFSTR("libDERErrorDomain"));
  }
  v8 = DERParseSequenceContent(v95, 2u, (uint64_t)&unk_1001678A8, (unint64_t)&v92, 0x20uLL);
  if ((_DWORD)v8)
  {
    v75 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v108, "Failed to parse signedSection as per SignedSectionItemSpec");
    v76 = (void *)SERestoreInfo::SEException::SEException(v75, &v108, v8, CFSTR("libDERErrorDomain"));
  }
  SERestoreInfo::UpdateTable::UpdateTable((SERestoreInfo::UpdateTable *)&v108, &v92);
  *((_DWORD *)v6 + 36) = v108.__r_.__value_.__l.__data_;
  sub_1000E4308((void **)v6 + 19);
  *(_OWORD *)(v6 + 152) = *(_OWORD *)&v108.__r_.__value_.__r.__words[1];
  *((_QWORD *)v6 + 21) = v109;
  v109 = 0;
  *(_OWORD *)&v108.__r_.__value_.__r.__words[1] = 0uLL;
  v114[0] = &v108.__r_.__value_.__s.__data_[8];
  sub_1000E48B0((void ***)v114);
  if (!v100[0] || !v100[1])
  {
    v46 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v47 = (std::string *)sub_1000CB3F4(v114, "Assertion: ");
    v48 = std::string::append(v47, "binaryItem.data && binaryItem.length");
    v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
    v108.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v108.__r_.__value_.__l.__data_ = v49;
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v46, &v108);
  }
  v9 = DERDecodeSeqContentInit(v100, v120);
  if ((_DWORD)v9)
  {
    v77 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v108, "Cannot init sequence for DeliveryObject.binaries");
    v78 = (void *)SERestoreInfo::SEException::SEException(v77, &v108, v9, CFSTR("libDERErrorDomain"));
  }
  while (1)
  {
    v10 = DERDecodeSeqNext(v120, &v118);
    v11 = v10;
    if ((_DWORD)v10)
      break;
    LODWORD(v108.__r_.__value_.__l.__data_) = 0;
    v108.__r_.__value_.__l.__size_ = (std::string::size_type)off_100183340;
    v110 = 0;
    v111 = 0;
    v113[0] = 0;
    v112 = 0uLL;
    v107 = 0;
    v12 = DERParseSequenceContent(&v119, 4u, (uint64_t)&unk_100167A48, (unint64_t)v114, 0x40uLL);
    if ((_DWORD)v12)
    {
      v52 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v121, "Cannot parse ImageBinary.");
      v53 = (void *)SERestoreInfo::SEException::SEException(v52, &v121, v12, CFSTR("libDERErrorDomain"));
    }
    v13 = DERParseInteger(v114, &v107);
    if ((_DWORD)v13 || v107 >= 5)
    {
      v50 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v121, "ImageBinary.type is out of range.");
      v51 = (void *)SERestoreInfo::SEException::SEException(v50, &v121, v13, CFSTR("libDERErrorDomain"));
    }
    LODWORD(v108.__r_.__value_.__l.__data_) = v107;
    v121 = off_100183340;
    v122 = v115;
    v123 = 0;
    sub_1000E3C54(&v108.__r_.__value_.__l.__size_, &v121);
    sub_1000E42C4(&v121);
    v14 = DERParseInteger(&v116, &v111);
    if ((_DWORD)v14)
    {
      v54 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v121, "Cannot parse ImageBinary.index.");
      v55 = (void *)SERestoreInfo::SEException::SEException(v54, &v121, v14, CFSTR("libDERErrorDomain"));
    }
    v15 = DERDecodeSeqContentInit(&v117, v106);
    if ((_DWORD)v15)
    {
      v56 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v121, "Cannot init sequence for ImageBinary.apdus");
      v57 = (void *)SERestoreInfo::SEException::SEException(v56, &v121, v15, CFSTR("libDERErrorDomain"));
    }
    while (1)
    {
      v16 = DERDecodeSeqNext(v106, &v104);
      v17 = v16;
      if ((_DWORD)v16)
        break;
      v101 = off_100183340;
      v102 = v105;
      v103 = 0;
      v18 = v112.i64[1];
      if (v112.i64[1] >= v113[0])
      {
        v21 = (v112.i64[1] - v112.i64[0]) >> 5;
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 59)
          sub_1000CB780();
        v23 = v113[0] - v112.i64[0];
        if ((v113[0] - v112.i64[0]) >> 4 > v22)
          v22 = v23 >> 4;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFE0)
          v24 = 0x7FFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        v124 = v113;
        if (v24)
          v25 = (char *)sub_1000E43F4((uint64_t)v113, v24);
        else
          v25 = 0;
        v26 = &v25[32 * v21];
        *(_QWORD *)v26 = off_100183340;
        v27 = v102;
        *((_QWORD *)v26 + 3) = v103;
        *(_OWORD *)(v26 + 8) = v27;
        v29 = v112.i64[1];
        v28 = v112.i64[0];
        if (v112.i64[1] == v112.i64[0])
        {
          v32 = vdupq_n_s64(v112.u64[1]);
          v30 = &v25[32 * v21];
        }
        else
        {
          v30 = &v25[32 * v21];
          do
          {
            *((_QWORD *)v30 - 4) = off_100183340;
            v30 -= 32;
            v31 = *(_OWORD *)(v29 - 24);
            *((_QWORD *)v30 + 3) = *(_QWORD *)(v29 - 8);
            *(_OWORD *)(v30 + 8) = v31;
            v29 -= 32;
          }
          while (v29 != v28);
          v32 = v112;
        }
        v20 = v26 + 32;
        v112.i64[0] = (uint64_t)v30;
        v112.i64[1] = (uint64_t)(v26 + 32);
        v122 = v32;
        v33 = v113[0];
        v113[0] = &v25[32 * v24];
        v123 = v33;
        v121 = (uint64_t (**)())v32.i64[0];
        sub_1000E4428((uint64_t)&v121);
      }
      else
      {
        *(_QWORD *)v112.i64[1] = off_100183340;
        v19 = v102;
        *(_QWORD *)(v18 + 24) = v103;
        *(_OWORD *)(v18 + 8) = v19;
        v20 = (char *)(v18 + 32);
      }
      v112.i64[1] = (uint64_t)v20;
      sub_1000E42C4(&v101);
    }
    if ((_DWORD)v16 != 1)
    {
      v41 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v121, "Cannot parse ImageBinary.apdus");
      v42 = (void *)SERestoreInfo::SEException::SEException(v41, &v121, v17, CFSTR("libDERErrorDomain"));
    }
    sub_1000E4478((uint64_t)(v6 + 32), &v111, (uint64_t)&v108);
    v121 = (uint64_t (**)())&v112;
    sub_1000E4718((void ***)&v121);
    sub_1000E42C4(&v108.__r_.__value_.__l.__size_);
  }
  if ((_DWORD)v10 != 1)
  {
    v58 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v108, "Cannot parse DeliveryObject.binaries");
    v59 = (void *)SERestoreInfo::SEException::SEException(v58, &v108, v11, CFSTR("libDERErrorDomain"));
  }
  v108.__r_.__value_.__r.__words[0] = (std::string::size_type)off_100183340;
  *(_OWORD *)&v108.__r_.__value_.__r.__words[1] = v99;
  v109 = 0;
  sub_1000E3C54((_QWORD *)v6 + 7, &v108);
  sub_1000E42C4(&v108);
  *((_DWORD *)v6 + 45) = 0;
  *((_DWORD *)v6 + 46) = 0;
  result = (uint64_t)DERParseSequenceContent(&v93, 2u, (uint64_t)&unk_1001678D8, (unint64_t)v90, 0x20uLL);
  v35 = result;
  if ((_DWORD)result)
  {
    if ((_DWORD)result != 5)
    {
      v79 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v108, "Failed to parse updateProperties as per UpdatePropertiesItemSpec.");
      v80 = (void *)SERestoreInfo::SEException::SEException(v79, &v108, v35, CFSTR("libDERErrorDomain"));
    }
  }
  else
  {
    v101 = 0;
    v36 = DERDecodeSeqInit((uint64_t)&v91, &v101, &v121);
    if ((_DWORD)v36)
    {
      v81 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v108, "Cannot parse properties entries");
      v82 = (void *)SERestoreInfo::SEException::SEException(v81, &v108, v36, CFSTR("libDERErrorDomain"));
    }
    while (1)
    {
      result = DERDecodeSeqNext((unint64_t *)&v121, (unint64_t *)&v108);
      if ((_DWORD)result)
        break;
      v37 = DERDecodeItem((uint64_t)&v108.__r_.__value_.__l.__size_, (unint64_t *)&v108);
      if ((_DWORD)v37)
      {
        v60 = __cxa_allocate_exception(0x48uLL);
        sub_1000CB3F4(v114, "Cannot parse property");
        v61 = (void *)SERestoreInfo::SEException::SEException(v60, v114, v37, CFSTR("libDERErrorDomain"));
      }
      v38 = DERParseSequenceContent(&v108.__r_.__value_.__l.__size_, 2u, (uint64_t)&unk_100167908, (unint64_t)v88, 0x20uLL);
      if ((_DWORD)v38)
      {
        v62 = __cxa_allocate_exception(0x48uLL);
        sub_1000CB3F4(v114, "Failed to parse as per PropertyItemSpec");
        v63 = (void *)SERestoreInfo::SEException::SEException(v62, v114, v38, CFSTR("libDERErrorDomain"));
      }
      if (v88[1] == 4)
      {
        if (*(_DWORD *)v88[0] == 1768121715)
        {
          LODWORD(v118) = 0;
          v40 = DERParseInteger(v89, &v118);
          if ((_DWORD)v40)
          {
            v64 = __cxa_allocate_exception(0x48uLL);
            sub_1000CB3F4(v114, "Failed to parse 'seci' value");
            v65 = (void *)SERestoreInfo::SEException::SEException(v64, v114, v40, CFSTR("libDERErrorDomain"));
          }
          *((_DWORD *)v6 + 45) = v118;
        }
        else if (*(_DWORD *)v88[0] == 1986553203)
        {
          LODWORD(v118) = 0;
          v39 = DERParseInteger(v89, &v118);
          if ((_DWORD)v39)
          {
            v66 = __cxa_allocate_exception(0x48uLL);
            sub_1000CB3F4(v114, "Failed to parse 'sehv' value");
            v67 = (void *)SERestoreInfo::SEException::SEException(v66, v114, v39, CFSTR("libDERErrorDomain"));
          }
          *((_DWORD *)v6 + 46) = v118;
        }
      }
    }
  }
  *a2 = v6 + 24;
  a2[1] = v6;
  return result;
}

void sub_1000E3A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,void *__p)
{
  char a68;

  if (a68 < 0)
    operator delete(__p);
  sub_1000CB5E0((uint64_t)&a23);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000E3C54(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  const void *v5;
  const void *v6;

  if (a2 != a1)
  {
    v4 = a2[2];
    a1[1] = a2[1];
    a1[2] = v4;
    v5 = (const void *)a1[3];
    if (v5)
    {
      CFRelease(v5);
      a1[3] = 0;
    }
    v6 = (const void *)a2[3];
    if (v6)
      a1[3] = CFRetain(v6);
  }
  return a1;
}

void sub_1000E3CB0(uint64_t a1)
{
  void *v1;

  v1 = (void *)sub_1000E47F4(a1);
  operator delete(v1);
}

uint64_t sub_1000E3CC4(uint64_t a1)
{
  void *v2;
  void **v4;

  *(_QWORD *)a1 = off_1001832D8;
  v4 = (void **)(a1 + 128);
  sub_1000E48B0(&v4);
  sub_1000E42C4((_QWORD *)(a1 + 88));
  v2 = *(void **)(a1 + 64);
  if (v2)
  {
    *(_QWORD *)(a1 + 72) = v2;
    operator delete(v2);
  }
  sub_1000E42C4((_QWORD *)(a1 + 32));
  sub_1000E4850(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

void sub_1000E3D34(char *a1)
{
  void *v2;
  void **v3;

  *(_QWORD *)a1 = off_1001832D8;
  v3 = (void **)(a1 + 128);
  sub_1000E48B0(&v3);
  sub_1000E42C4((_QWORD *)a1 + 11);
  v2 = (void *)*((_QWORD *)a1 + 8);
  if (v2)
  {
    *((_QWORD *)a1 + 9) = v2;
    operator delete(v2);
  }
  sub_1000E42C4((_QWORD *)a1 + 4);
  sub_1000E4850((uint64_t)(a1 + 8), *((char **)a1 + 2));
  operator delete(a1);
}

void *sub_1000E3DA8(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    sub_1000CB52C();
  return operator new(2 * a2);
}

uint64_t sub_1000E3DD8(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    sub_1000CB780();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)sub_1000D95E4(v7, v9);
  else
    v10 = 0;
  v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v15 = v11;
  v16 = &v10[24 * v9];
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = 0;
  *((_QWORD *)v11 + 2) = 0;
  sub_1000E4F48(v11, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 1);
  v15 += 24;
  sub_1000E3EEC(a1, v14);
  v12 = a1[1];
  sub_1000E4078((uint64_t)v14);
  return v12;
}

void sub_1000E3ED8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000E4078((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E3EEC(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1000E3F60((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t sub_1000E3F60(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  sub_1000E4000((uint64_t)v11);
  return v9;
}

uint64_t sub_1000E4000(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1000E4034(a1);
  return a1;
}

void sub_1000E4034(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t sub_1000E4078(uint64_t a1)
{
  sub_1000E40AC(a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void sub_1000E40AC(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void sub_1000E4104(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_1000E4144((uint64_t *)v2);
    operator delete(**a1);
  }
}

void sub_1000E4144(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void sub_1000E4198(_QWORD *a1, unint64_t a2, _BYTE *a3)
{
  unint64_t v4;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  unint64_t v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  _BYTE *v13;
  char *v14;
  char *v15;
  _BYTE *v16;
  _BYTE *v17;
  char v18;

  v4 = a2;
  v7 = (_BYTE *)a1[1];
  v6 = a1[2];
  if (v6 - (uint64_t)v7 >= a2)
  {
    if (a2)
    {
      v13 = &v7[a2];
      do
      {
        *v7++ = *a3;
        --v4;
      }
      while (v4);
      v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = &v7[-*a1];
    v9 = (unint64_t)&v8[a2];
    if ((uint64_t)&v8[a2] < 0)
      sub_1000CB780();
    v10 = v6 - *a1;
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
      v12 = operator new(v11);
    else
      v12 = 0;
    v14 = &v8[(_QWORD)v12];
    v15 = &v8[(_QWORD)v12 + v4];
    v16 = &v8[(_QWORD)v12];
    do
    {
      *v16++ = *a3;
      --v4;
    }
    while (v4);
    v17 = (_BYTE *)*a1;
    if (v7 != (_BYTE *)*a1)
    {
      do
      {
        v18 = *--v7;
        *--v14 = v18;
      }
      while (v7 != v17);
      v7 = (_BYTE *)*a1;
    }
    *a1 = v14;
    a1[1] = v15;
    a1[2] = (char *)v12 + v11;
    if (v7)
      operator delete(v7);
  }
}

void sub_1000E42B0(_QWORD *a1)
{
  _QWORD *v1;

  v1 = sub_1000E42C4(a1);
  operator delete(v1);
}

_QWORD *sub_1000E42C4(_QWORD *a1)
{
  const void *v2;

  *a1 = off_100183340;
  v2 = (const void *)a1[3];
  if (v2)
  {
    CFRelease(v2);
    a1[3] = 0;
  }
  return a1;
}

void sub_1000E4308(void **a1)
{
  void *v1;
  uint64_t v3;
  void *v4;

  v1 = *a1;
  if (*a1)
  {
    v3 = (uint64_t)a1[1];
    v4 = *a1;
    if ((void *)v3 != v1)
    {
      do
      {
        v3 -= 48;
        sub_1000E4374((uint64_t)(a1 + 2), v3);
      }
      while ((void *)v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void sub_1000E4374(uint64_t a1, uint64_t a2)
{
  void *v3;
  void **v4;

  v3 = *(void **)(a2 + 24);
  if (v3)
  {
    *(_QWORD *)(a2 + 32) = v3;
    operator delete(v3);
  }
  v4 = (void **)a2;
  sub_1000E4104(&v4);
}

uint64_t sub_1000E43B4(uint64_t a1)
{
  void **v3;

  v3 = (void **)(a1 + 48);
  sub_1000E4718(&v3);
  sub_1000E42C4((_QWORD *)(a1 + 8));
  return a1;
}

void *sub_1000E43F4(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    sub_1000CB52C();
  return operator new(32 * a2);
}

uint64_t sub_1000E4428(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void (**v4)(void);

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void (***)(void))(i - 32);
    *(_QWORD *)(a1 + 16) = i - 32;
    (*v4)();
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t **sub_1000E4478(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  char *v4;
  uint64_t **v5;
  uint64_t *v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  void *__p;
  uint64_t v12;

  sub_1000E452C(a1, a2, a3, (uint64_t)&__p);
  v4 = (char *)__p;
  v5 = (uint64_t **)(a1 + 8);
  v6 = *(uint64_t **)(a1 + 8);
  if (v6)
  {
    v7 = *((unsigned __int16 *)__p + 16);
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v6;
        v9 = *((unsigned __int16 *)v6 + 16);
        if (v7 >= v9)
          break;
        v6 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v6 = v8[1];
      if (!v6)
      {
        v5 = v8 + 1;
        goto LABEL_10;
      }
    }
    __p = 0;
    if (v4)
      sub_1000E47A4((uint64_t)&v12, v4);
  }
  else
  {
    v8 = (uint64_t **)(a1 + 8);
LABEL_10:
    sub_1000CBAE0((uint64_t **)a1, (uint64_t)v8, v5, (uint64_t *)__p);
    return (uint64_t **)__p;
  }
  return v8;
}

uint64_t sub_1000E452C@<X0>(uint64_t a1@<X0>, _DWORD *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  void *v8;
  uint64_t result;

  v7 = a1 + 8;
  v8 = operator new(0x70uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  result = sub_1000E45B4((uint64_t)v8 + 32, a2, a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1000E4598(_Unwind_Exception *a1)
{
  _QWORD *v1;
  char *v2;
  uint64_t v3;

  *v1 = 0;
  sub_1000E47A4(v3, v2);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E45B4(uint64_t a1, _DWORD *a2, uint64_t a3)
{
  __int128 v4;
  int v5;
  uint64_t v6;

  *(_WORD *)a1 = *a2;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)a3;
  *(_QWORD *)(a1 + 16) = off_100183340;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a3 + 32);
  *(_OWORD *)(a1 + 24) = v4;
  v5 = *(_DWORD *)(a3 + 40);
  *(_QWORD *)(a1 + 56) = 0;
  v6 = a1 + 56;
  *(_DWORD *)(v6 - 8) = v5;
  *(_QWORD *)(v6 + 8) = 0;
  *(_QWORD *)(v6 + 16) = 0;
  sub_1000E463C((char *)v6, *(_QWORD *)(a3 + 48), *(_QWORD *)(a3 + 56), (uint64_t)(*(_QWORD *)(a3 + 56) - *(_QWORD *)(a3 + 48)) >> 5);
  return a1;
}

void sub_1000E4628(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000E42C4(v1);
  _Unwind_Resume(a1);
}

char *sub_1000E463C(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  uint64_t i;
  __int128 v8;

  if (a4)
  {
    v6 = result;
    result = sub_1000E46D8(result, a4);
    for (i = *((_QWORD *)v6 + 1); a2 != a3; i += 32)
    {
      *(_QWORD *)i = off_100183340;
      v8 = *(_OWORD *)(a2 + 8);
      *(_QWORD *)(i + 24) = *(_QWORD *)(a2 + 24);
      *(_OWORD *)(i + 8) = v8;
      a2 += 32;
    }
    *((_QWORD *)v6 + 1) = i;
  }
  return result;
}

void sub_1000E46C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  sub_1000E4718(&a9);
  _Unwind_Resume(a1);
}

char *sub_1000E46D8(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    sub_1000CB780();
  result = (char *)sub_1000E43F4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

void sub_1000E4718(void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  char *v6;
  char *v7;
  void (**v8)(char *);
  BOOL v9;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      v6 = v4 - 32;
      v7 = v4 - 32;
      do
      {
        v8 = *(void (***)(char *))v7;
        v7 -= 32;
        (*v8)(v6);
        v9 = v6 == v2;
        v6 = v7;
      }
      while (!v9);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void sub_1000E47A4(uint64_t a1, char *__p)
{
  void **v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (void **)(__p + 88);
    sub_1000E4718(&v3);
    sub_1000E42C4((_QWORD *)__p + 6);
  }
  if (__p)
    operator delete(__p);
}

uint64_t sub_1000E47F4(uint64_t a1)
{
  const void *v2;
  void **v4;

  *(_QWORD *)a1 = off_1001835E0;
  v2 = *(const void **)(a1 + 8);
  if (v2)
  {
    CFRelease(v2);
    *(_QWORD *)(a1 + 8) = 0;
  }
  v4 = (void **)(a1 + 16);
  sub_1000E4718(&v4);
  return a1;
}

void sub_1000E4850(uint64_t a1, char *a2)
{
  void **v4;

  if (a2)
  {
    sub_1000E4850(a1, *(_QWORD *)a2);
    sub_1000E4850(a1, *((_QWORD *)a2 + 1));
    v4 = (void **)(a2 + 88);
    sub_1000E4718(&v4);
    sub_1000E42C4((_QWORD *)a2 + 6);
    operator delete(a2);
  }
}

void sub_1000E48B0(void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 48;
        sub_1000E4374((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t sub_1000E4934(uint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  void *v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  uint64_t *v14;

  v3 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 4);
  v4 = v3 + 1;
  if (v3 + 1 > 0x555555555555555)
    sub_1000CB780();
  if (0x5555555555555556 * ((a1[2] - *a1) >> 4) > v4)
    v4 = 0x5555555555555556 * ((a1[2] - *a1) >> 4);
  if (0xAAAAAAAAAAAAAAABLL * ((a1[2] - *a1) >> 4) >= 0x2AAAAAAAAAAAAAALL)
    v6 = 0x555555555555555;
  else
    v6 = v4;
  v14 = a1 + 2;
  if (v6)
    v7 = (char *)sub_1000E4D38((uint64_t)(a1 + 2), v6);
  else
    v7 = 0;
  v10 = v7;
  v11 = &v7[48 * v3];
  v13 = &v7[48 * v6];
  sub_1000E4A40((uint64_t)(a1 + 2), v11, a2);
  v12 = v11 + 48;
  sub_1000E4CC4(a1, &v10);
  v8 = a1[1];
  sub_1000E4EC0(&v10);
  return v8;
}

void sub_1000E4A2C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000E4EC0((void **)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000E4A40(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  sub_1000E4AC0(a2, *(_QWORD *)a3, *(_QWORD *)(a3 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3));
  a2[3] = 0;
  a2[4] = 0;
  a2[5] = 0;
  return sub_1000DCDC0(a2 + 3, *(const void **)(a3 + 24), *(_QWORD *)(a3 + 32), *(_QWORD *)(a3 + 32) - *(_QWORD *)(a3 + 24));
}

void sub_1000E4AA8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000E4104((void ***)va);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000E4AC0(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    sub_1000E4B44(result, a4);
    result = sub_1000E4B94((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1000E4B24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  sub_1000E4104(&a9);
  _Unwind_Resume(a1);
}

char *sub_1000E4B44(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    sub_1000CB780();
  result = (char *)sub_1000D95E4((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

_QWORD *sub_1000E4B94(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      sub_1000E4F48(v4, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 1);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  v9 = 1;
  sub_1000E4C44((uint64_t)v8);
  return v4;
}

void sub_1000E4C30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000E4C44((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t sub_1000E4C44(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1000E4C78(a1);
  return a1;
}

void sub_1000E4C78(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  if (v1 != v2)
  {
    v3 = **(_QWORD **)(a1 + 16);
    do
    {
      v5 = *(void **)(v3 - 24);
      v3 -= 24;
      v4 = v5;
      if (v5)
      {
        *(_QWORD *)(v1 - 16) = v4;
        operator delete(v4);
      }
      v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t sub_1000E4CC4(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1000E4D7C((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000E4D38(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    sub_1000CB52C();
  return operator new(48 * a2);
}

uint64_t sub_1000E4D7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 48) = 0;
      *(_QWORD *)(v7 - 40) = 0;
      *(_QWORD *)(v7 - 32) = 0;
      v8 = *(_OWORD *)(a3 - 48);
      a3 -= 48;
      *(_OWORD *)(v7 - 48) = v8;
      *(_QWORD *)(v7 - 32) = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 24);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 40);
      *(_QWORD *)(a3 + 24) = 0;
      *(_QWORD *)(a3 + 32) = 0;
      *(_QWORD *)(a3 + 40) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 48;
      *((_QWORD *)&v14 + 1) -= 48;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  sub_1000E4E3C((uint64_t)v11);
  return v9;
}

uint64_t sub_1000E4E3C(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1000E4E70((uint64_t *)a1);
  return a1;
}

void sub_1000E4E70(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      sub_1000E4374(v3, v1);
      v1 += 48;
    }
    while (v1 != v2);
  }
}

void **sub_1000E4EC0(void **a1)
{
  sub_1000E4EF0(a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void sub_1000E4EF0(_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 48;
    sub_1000E4374(v4, i - 48);
  }
}

void sub_1000E4F34()
{
  sub_1000CC054("vector");
}

_QWORD *sub_1000E4F48(_QWORD *result, const void *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_1000E4FC0(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000E4FA4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *sub_1000E4FC0(_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    sub_1000CB780();
  result = (char *)sub_1000E3DA8((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

void sub_1000E4FFC(int a1, void **__p)
{
  void *v3;

  if (__p)
  {
    v3 = *__p;
    if (*__p)
    {
      __p[1] = v3;
      operator delete(v3);
    }
    operator delete(__p);
  }
}

void sub_1000E5034(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1000E5034(a1, *a2);
    sub_1000E5034(a1, a2[1]);
    sub_1000E507C((uint64_t)(a2 + 4));
    operator delete(a2);
  }
}

void sub_1000E507C(uint64_t a1)
{
  void *v2;

  sub_1000CB5E0(a1 + 24);
  v2 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
}

_QWORD *sub_1000E50B8(uint64_t a1, unsigned __int8 **a2)
{
  _QWORD *v3;
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;

  v3 = (_QWORD *)(a1 + 8);
  result = sub_1000E5134(a1, a2, *(_QWORD **)(a1 + 8), (_QWORD *)(a1 + 8));
  if (v3 != result)
  {
    v6 = result[4];
    v5 = result[5];
    if (v6 == v5)
      return result;
    v7 = *a2;
    v8 = v6 + 1;
    while (v7 != a2[1])
    {
      v9 = *v7;
      v10 = *(unsigned __int8 *)(v8 - 1);
      if (v9 < v10)
        break;
      ++v7;
      if (v10 < v9 || v8++ == v5)
        return result;
    }
  }
  return v3;
}

_QWORD *sub_1000E5134(uint64_t a1, _QWORD *a2, _QWORD *a3, _QWORD *a4)
{
  _QWORD *result;
  uint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;

  result = a4;
  if (a3)
  {
    v5 = a2[1];
    do
    {
      if (*a2 == v5)
      {
LABEL_12:
        result = a3;
      }
      else
      {
        v6 = (unsigned __int8 *)a3[4];
        v7 = *a2 + 1;
        while (v6 != (unsigned __int8 *)a3[5])
        {
          v8 = *v6;
          v9 = *(unsigned __int8 *)(v7 - 1);
          if (v8 < v9)
            break;
          ++v6;
          if (v9 < v8 || v7++ == v5)
            goto LABEL_12;
        }
        ++a3;
      }
      a3 = (_QWORD *)*a3;
    }
    while (a3);
  }
  return result;
}

uint64_t *sub_1000E5198(uint64_t **a1, unsigned __int8 **a2, uint64_t a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t *v10[3];
  uint64_t v11;

  v6 = (uint64_t **)sub_1000E5240((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    sub_1000E5300((uint64_t)a1, a4, (uint64_t)v10);
    sub_1000CBAE0(a1, v11, v8, v10[0]);
    v7 = v10[0];
    v10[0] = 0;
    sub_1000E537C((uint64_t)v10, 0);
  }
  return v7;
}

_QWORD *sub_1000E5240(uint64_t a1, _QWORD *a2, unsigned __int8 **a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  unsigned __int8 *v6;
  _QWORD *v7;
  unsigned __int8 *v8;
  unsigned __int8 *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
    v6 = a3[1];
    do
    {
      while (1)
      {
        v7 = v4;
        v8 = (unsigned __int8 *)v4[4];
        v9 = (unsigned __int8 *)v7[5];
        if (v8 != v9)
          break;
LABEL_12:
        if (*a3 != v6)
        {
          v15 = (uint64_t)(*a3 + 1);
          while (v8 != v9)
          {
            v16 = *v8;
            v17 = *(unsigned __int8 *)(v15 - 1);
            if (v16 < v17)
              break;
            ++v8;
            if (v17 < v16 || v15++ == (_QWORD)v6)
              goto LABEL_27;
          }
          result = v7 + 1;
          v4 = (_QWORD *)v7[1];
          if (v4)
            continue;
        }
        goto LABEL_27;
      }
      v10 = v8 + 1;
      v11 = *a3;
      while (v11 != v6)
      {
        v12 = *v11;
        v13 = *(v10 - 1);
        if (v12 < v13)
          break;
        ++v11;
        if (v13 < v12 || v10++ == v9)
          goto LABEL_12;
      }
      v4 = (_QWORD *)*v7;
      result = v7;
    }
    while (*v7);
  }
  else
  {
    v7 = result;
  }
LABEL_27:
  *a2 = v7;
  return result;
}

_QWORD *sub_1000E5300@<X0>(uint64_t a1@<X0>, uint64_t *a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *result;

  v5 = a1 + 8;
  v6 = operator new(0x48uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = *a2;
  v6[5] = 0;
  v6[6] = 0;
  v6[4] = 0;
  result = sub_1000DCDC0(v6 + 4, *(const void **)v7, *(_QWORD *)(v7 + 8), *(_QWORD *)(v7 + 8) - *(_QWORD *)v7);
  v6[7] = 0;
  v6[8] = 0;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1000E5364(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000E537C(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1000E537C(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1000E507C((uint64_t)v2 + 32);
    operator delete(v2);
  }
}

uint64_t *sub_1000E53C0(uint64_t **a1, unsigned __int8 **a2, uint64_t a3, __n128 *a4)
{
  uint64_t **v7;
  uint64_t *v8;
  uint64_t **v9;
  uint64_t *v11[3];
  uint64_t v12;

  v7 = (uint64_t **)sub_1000E5240((uint64_t)a1, &v12, a2);
  v8 = *v7;
  if (!*v7)
  {
    v9 = v7;
    sub_1000E5460((uint64_t)a1, a3, a4, (uint64_t)v11);
    sub_1000CBAE0(a1, v12, v9, v11[0]);
    v8 = v11[0];
    v11[0] = 0;
    sub_1000E537C((uint64_t)v11, 0);
  }
  return v8;
}

__n128 sub_1000E5460@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X1>, __n128 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  char *v8;
  __n128 result;

  v7 = a1 + 8;
  v8 = (char *)operator new(0x48uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *((_QWORD *)v8 + 5) = 0;
  *((_QWORD *)v8 + 6) = 0;
  *((_QWORD *)v8 + 4) = 0;
  sub_1000DCDC0((_QWORD *)v8 + 4, *(const void **)a2, *(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 8) - *(_QWORD *)a2);
  result = *a3;
  *(__n128 *)(v8 + 56) = *a3;
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_1000E54D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000E537C(v1, 0);
  _Unwind_Resume(a1);
}

void sub_1000E54EC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100183370;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000E5500(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100183370;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000E5524(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *SERestoreInfo::IcefallRestoreInfo::getImageTag@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v3;
  int v5;
  _QWORD *v6;

  v3 = atomic_load((unsigned __int8 *)&qword_1001A8F30);
  if ((v3 & 1) == 0)
  {
    v6 = a1;
    v5 = __cxa_guard_acquire(&qword_1001A8F30);
    a1 = v6;
    if (v5)
    {
      qword_1001A8F10 = (uint64_t)CFSTR("SE,Bootloader");
      *(_QWORD *)algn_1001A8F18 = CFSTR("SE,Firmware");
      qword_1001A8F20 = (uint64_t)CFSTR("SE,MigrationOS");
      unk_1001A8F28 = CFSTR("SE,OS");
      __cxa_guard_release(&qword_1001A8F30);
      a1 = v6;
    }
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return sub_1000E5784(a1, &qword_1001A8F10, (uint64_t)&qword_1001A8F30, 4uLL);
}

_QWORD *SERestoreInfo::IcefallRestoreInfo::getTagsInBI@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v3;
  int v5;
  _QWORD *v6;

  v3 = atomic_load((unsigned __int8 *)&qword_1001A8F60);
  if ((v3 & 1) == 0)
  {
    v6 = a1;
    v5 = __cxa_guard_acquire(&qword_1001A8F60);
    a1 = v6;
    if (v5)
    {
      qword_1001A8F38 = (uint64_t)CFSTR("SE,ChipID");
      unk_1001A8F40 = CFSTR("SE,Bootloader");
      qword_1001A8F48 = (uint64_t)CFSTR("SE,Firmware");
      unk_1001A8F50 = CFSTR("SE,MigrationOS");
      qword_1001A8F58 = (uint64_t)CFSTR("SE,OS");
      __cxa_guard_release(&qword_1001A8F60);
      a1 = v6;
    }
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return sub_1000E5784(a1, &qword_1001A8F38, (uint64_t)&qword_1001A8F60, 5uLL);
}

void sub_1000E56C8(SERestoreInfo::SERestoreInfoBase *a1)
{
  void *v1;

  SERestoreInfo::SERestoreInfoBase::~SERestoreInfoBase(a1);
  operator delete(v1);
}

__CFString *sub_1000E56DC(uint64_t a1)
{
  uint64_t v1;
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;
  __CFString **v5;
  __CFString *v6;
  unint64_t v7;
  __CFString **v8;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(std::__shared_weak_count **)(a1 + 24);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldxr(p_shared_owners);
    while (__stxr(v4 + 1, p_shared_owners));
    if (*(_BYTE *)(v1 + 10))
      v5 = kSETagMeasurementDevCMAC;
    else
      v5 = kSETagMeasurementProdCMAC;
    v6 = *v5;
    do
      v7 = __ldaxr(p_shared_owners);
    while (__stlxr(v7 - 1, p_shared_owners));
    if (!v7)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  else
  {
    v8 = kSETagMeasurementDevCMAC;
    if (!*(_BYTE *)(v1 + 10))
      v8 = kSETagMeasurementProdCMAC;
    return *v8;
  }
  return v6;
}

_QWORD *sub_1000E5784(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = sub_1000CB740(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1000E57E0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *SERestoreInfo::P73BaseRestoreInfo::getImageTag@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v3;
  int v5;
  _QWORD *v6;

  v3 = atomic_load((unsigned __int8 *)&qword_1001A8F70);
  if ((v3 & 1) == 0)
  {
    v6 = a1;
    v5 = __cxa_guard_acquire(&qword_1001A8F70);
    a1 = v6;
    if (v5)
    {
      qword_1001A8F68 = (uint64_t)CFSTR("SE,UpdatePayload");
      __cxa_guard_release(&qword_1001A8F70);
      a1 = v6;
    }
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return sub_1000E5784(a1, &qword_1001A8F68, (uint64_t)&qword_1001A8F70, 1uLL);
}

_QWORD *SERestoreInfo::P73BaseRestoreInfo::getTagsInBI@<X0>(_QWORD *a1@<X8>)
{
  unsigned __int8 v3;
  int v5;
  _QWORD *v6;

  v3 = atomic_load((unsigned __int8 *)&qword_1001A8F88);
  if ((v3 & 1) == 0)
  {
    v6 = a1;
    v5 = __cxa_guard_acquire(&qword_1001A8F88);
    a1 = v6;
    if (v5)
    {
      qword_1001A8F78 = (uint64_t)CFSTR("SE,ChipID");
      unk_1001A8F80 = CFSTR("SE,UpdatePayload");
      __cxa_guard_release(&qword_1001A8F88);
      a1 = v6;
    }
  }
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  return sub_1000E5784(a1, &qword_1001A8F78, (uint64_t)&qword_1001A8F88, 2uLL);
}

const __CFString *sub_1000E592C(uint64_t a1)
{
  SERestoreInfo::P73BaseDeviceInfo *v2;
  std::__shared_weak_count *v3;
  unint64_t *p_shared_owners;
  unint64_t v5;
  _BOOL4 isDev;
  unint64_t *v7;
  unint64_t v8;

  v2 = *(SERestoreInfo::P73BaseDeviceInfo **)(a1 + 16);
  v3 = *(std::__shared_weak_count **)(a1 + 24);
  if (v3)
  {
    p_shared_owners = (unint64_t *)&v3->__shared_owners_;
    do
      v5 = __ldxr(p_shared_owners);
    while (__stxr(v5 + 1, p_shared_owners));
  }
  isDev = SERestoreInfo::P73BaseDeviceInfo::isDev(v2);
  if (v3)
  {
    v7 = (unint64_t *)&v3->__shared_owners_;
    do
      v8 = __ldaxr(v7);
    while (__stlxr(v8 - 1, v7));
    if (!v8)
    {
      ((void (*)(std::__shared_weak_count *))v3->__on_zero_shared)(v3);
      std::__shared_weak_count::__release_weak(v3);
    }
  }
  if (isDev)
    return CFSTR("DevelopmentUpdatePayloadHash");
  else
    return CFSTR("ProductionUpdatePayloadHash");
}

void sub_1000E59D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000CB5E0((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::P73DeviceInfo::P73DeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(_QWORD *)v3 = &off_100183460;
  if (*(_DWORD *)(v3 + 56) != 115)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  if (sub_1000E5AA0(a1 + 88))
    sub_1000E5B2C((void **)(a1 + 88), a1 + 112);
  return a1;
}

void sub_1000E5A7C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  __cxa_free_exception(v2);
  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1000E5AA0(uint64_t a1)
{
  const void *v2;
  size_t v3;
  _BYTE *v4;
  _BOOL8 v5;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;

  v7 = 0;
  v8 = 0;
  v9 = 0;
  sub_1000DCDC0(&v7, &unk_100167B72, (uint64_t)&unk_100167B92, 0x20uLL);
  v2 = *(const void **)a1;
  v3 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v4 = v7;
  if (v3 == v8 - v7)
  {
    v5 = memcmp(v2, v7, v3) == 0;
    if (!v4)
      return v5;
    goto LABEL_5;
  }
  v5 = 0;
  if (v7)
  {
LABEL_5:
    v8 = v4;
    operator delete(v4);
  }
  return v5;
}

void sub_1000E5B2C(void **a1, uint64_t a2)
{
  const void *v4;
  size_t v5;
  _BYTE *v6;
  _BOOL4 v7;
  void *__p;
  char *v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;

  v10 = 0;
  v11 = 0;
  v12 = 0;
  sub_1000DCDC0(&v10, &unk_100167B92, (uint64_t)"N13SERestoreInfo11SEExceptionE", 0x20uLL);
  v4 = *(const void **)a2;
  v5 = *(_QWORD *)(a2 + 8) - *(_QWORD *)a2;
  v6 = v10;
  if (v5 != v11 - v10)
  {
    v7 = 0;
    if (!v10)
      goto LABEL_6;
    goto LABEL_5;
  }
  v7 = memcmp(v4, v10, v5) == 0;
  if (v6)
  {
LABEL_5:
    v11 = v6;
    operator delete(v6);
  }
LABEL_6:
  RootCA::getRootKeyId(v7, 115, &__p);
  if (&__p != a1)
    sub_1000DDD98(a1, (char *)__p, v9, v9 - (_BYTE *)__p);
  if (__p)
  {
    v9 = (char *)__p;
    operator delete(__p);
  }
}

void sub_1000E5BFC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void **SERestoreInfo::P73DeviceInfo::P73DeviceInfo(void **this, SERestoreInfo **a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo((SERestoreInfo::P73BaseDeviceInfo *)this, a2);
  *(_QWORD *)v3 = &off_100183460;
  if (*((_DWORD *)v3 + 14) != 115)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  if (sub_1000E5AA0((uint64_t)(this + 11)))
    sub_1000E5B2C(this + 11, (uint64_t)(this + 14));
  return this;
}

void sub_1000E5CAC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;

  __cxa_free_exception(v2);
  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SEException::SEException(uint64_t a1, __int128 *a2, int a3, CFTypeRef cf)
{
  void **v7;
  std::string::value_type *v8;
  __int128 v9;
  CFTypeRef v10;
  std::string *v11;
  __int128 v12;
  std::string *v13;
  __int128 v14;
  int v15;
  const std::string::value_type *v16;
  std::string::size_type v17;
  std::string *v18;
  std::string::size_type v19;
  char v20;
  uint64_t v21;
  std::string v23;
  std::string v24;
  std::string v25;
  _QWORD v26[2];

  *(_QWORD *)a1 = off_1001834B0;
  *(_QWORD *)(a1 + 8) = 0;
  v7 = (void **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  v8 = (std::string::value_type *)(a1 + 32);
  if (*((char *)a2 + 23) < 0)
  {
    sub_1000CB554((_BYTE *)(a1 + 32), *(void **)a2, *((_QWORD *)a2 + 1));
  }
  else
  {
    v9 = *a2;
    *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 2);
    *(_OWORD *)v8 = v9;
  }
  *(_DWORD *)(a1 + 64) = a3;
  if (cf)
  {
    v10 = CFRetain(cf);
    a3 = *(_DWORD *)(a1 + 64);
  }
  else
  {
    v10 = 0;
  }
  *(_QWORD *)(a1 + 56) = v10;
  std::to_string(&v23, a3);
  v11 = std::string::insert(&v23, 0, "(");
  v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
  v24.__r_.__value_.__r.__words[2] = v11->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v24.__r_.__value_.__l.__data_ = v12;
  v11->__r_.__value_.__l.__size_ = 0;
  v11->__r_.__value_.__r.__words[2] = 0;
  v11->__r_.__value_.__r.__words[0] = 0;
  v13 = std::string::append(&v24, ") ");
  v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v25.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v25.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = *(char *)(a1 + 55);
  if (v15 >= 0)
    v16 = v8;
  else
    v16 = *(const std::string::value_type **)(a1 + 32);
  if (v15 >= 0)
    v17 = *(unsigned __int8 *)(a1 + 55);
  else
    v17 = *(_QWORD *)(a1 + 40);
  v18 = std::string::append(&v25, v16, v17);
  v19 = v18->__r_.__value_.__r.__words[0];
  v26[0] = v18->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v26 + 7) = *(std::string::size_type *)((char *)&v18->__r_.__value_.__r.__words[1] + 7);
  v20 = HIBYTE(v18->__r_.__value_.__r.__words[2]);
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  if (*(char *)(a1 + 31) < 0)
    operator delete(*v7);
  v21 = v26[0];
  *(_QWORD *)(a1 + 8) = v19;
  *(_QWORD *)(a1 + 16) = v21;
  *(_QWORD *)(a1 + 23) = *(_QWORD *)((char *)v26 + 7);
  *(_BYTE *)(a1 + 31) = v20;
  if (SHIBYTE(v25.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v25.__r_.__value_.__l.__data_);
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  return a1;
}

void sub_1000E5E98(_Unwind_Exception *a1, int a2)
{
  if (!a2)
    _Unwind_Resume(a1);
  sub_1000CD700(a1);
}

SERestoreInfo::SEException *SERestoreInfo::SEException::SEException(SERestoreInfo::SEException *this, CFErrorRef err)
{
  void **v4;
  const __CFString *v5;
  const __CFString *v6;
  CFIndex Length;
  CFIndex Bytes;
  const void *Domain;
  std::string *v10;
  __int128 v11;
  std::string *v12;
  __int128 v13;
  int v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  std::string *v17;
  std::string::size_type v18;
  char v19;
  uint64_t v20;
  std::string v22;
  std::string usedBufLen;
  std::string __p;
  _QWORD v25[2];
  CFRange v26;
  CFRange v27;

  *(_QWORD *)this = off_1001834B0;
  *(_OWORD *)((char *)this + 8) = 0u;
  v4 = (void **)((char *)this + 8);
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  v5 = CFErrorCopyDescription(err);
  v6 = v5;
  if (v5)
  {
    Length = CFStringGetLength(v5);
    usedBufLen.__r_.__value_.__r.__words[0] = 0;
    v26.location = 0;
    v26.length = Length;
    Bytes = CFStringGetBytes(v6, v26, 0x8000100u, 0, 0, 0, 0, (CFIndex *)&usedBufLen);
    if (usedBufLen.__r_.__value_.__r.__words[0] && Bytes)
    {
      sub_1000DDEA4(&__p, usedBufLen.__r_.__value_.__r.__words[0]);
      v27.location = 0;
      v27.length = Length;
      if (CFStringGetBytes(v6, v27, 0x8000100u, 0, 0, (UInt8 *)__p.__r_.__value_.__l.__data_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0], 0))
      {
        sub_1000E61F8((std::string *)((char *)this + 32), __p.__r_.__value_.__l.__data_, (std::string::value_type *)__p.__r_.__value_.__l.__size_, __p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]);
      }
      if (__p.__r_.__value_.__r.__words[0])
      {
        __p.__r_.__value_.__l.__size_ = __p.__r_.__value_.__r.__words[0];
        operator delete(__p.__r_.__value_.__l.__data_);
      }
    }
    CFRelease(v6);
  }
  *((_DWORD *)this + 16) = CFErrorGetCode(err);
  Domain = CFErrorGetDomain(err);
  if (Domain)
    Domain = CFRetain(Domain);
  *((_QWORD *)this + 7) = Domain;
  std::to_string(&v22, *((int *)this + 16));
  v10 = std::string::insert(&v22, 0, "CF=(");
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  usedBufLen.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)&usedBufLen.__r_.__value_.__l.__data_ = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  v12 = std::string::append(&usedBufLen, ") ");
  v13 = *(_OWORD *)&v12->__r_.__value_.__l.__data_;
  __p.__r_.__value_.__r.__words[2] = v12->__r_.__value_.__r.__words[2];
  *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v13;
  v12->__r_.__value_.__l.__size_ = 0;
  v12->__r_.__value_.__r.__words[2] = 0;
  v12->__r_.__value_.__r.__words[0] = 0;
  v14 = *((char *)this + 55);
  if (v14 >= 0)
    v15 = (char *)this + 32;
  else
    v15 = (const std::string::value_type *)*((_QWORD *)this + 4);
  if (v14 >= 0)
    v16 = *((unsigned __int8 *)this + 55);
  else
    v16 = *((_QWORD *)this + 5);
  v17 = std::string::append(&__p, v15, v16);
  v18 = v17->__r_.__value_.__r.__words[0];
  v25[0] = v17->__r_.__value_.__l.__size_;
  *(_QWORD *)((char *)v25 + 7) = *(std::string::size_type *)((char *)&v17->__r_.__value_.__r.__words[1] + 7);
  v19 = HIBYTE(v17->__r_.__value_.__r.__words[2]);
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  if (*((char *)this + 31) < 0)
    operator delete(*v4);
  v20 = v25[0];
  *((_QWORD *)this + 1) = v18;
  *((_QWORD *)this + 2) = v20;
  *(_QWORD *)((char *)this + 23) = *(_QWORD *)((char *)v25 + 7);
  *((_BYTE *)this + 31) = v19;
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  if (SHIBYTE(usedBufLen.__r_.__value_.__r.__words[2]) < 0)
    operator delete(usedBufLen.__r_.__value_.__l.__data_);
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  return this;
}

void sub_1000E6100(_Unwind_Exception *a1, int a2)
{
  if (a2)
    sub_1000CD700(a1);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SEException::~SEException(std::exception *this)
{
  std::exception_vtbl *v2;

  this->__vftable = (std::exception_vtbl *)off_1001834B0;
  v2 = this[7].__vftable;
  if (v2)
  {
    CFRelease(v2);
    this[7].__vftable = 0;
  }
  if (SHIBYTE(this[6].__vftable) < 0)
    operator delete(this[4].__vftable);
  if (SHIBYTE(this[3].__vftable) < 0)
    operator delete(this[1].__vftable);
  std::exception::~exception(this);
}

{
  void *v1;

  SERestoreInfo::SEException::~SEException(this);
  operator delete(v1);
}

CFErrorRef SERestoreInfo::SEException::CreateCFError(SERestoreInfo::SEException *this)
{
  char *v2;
  CFErrorRef CFError;
  void *__p[2];
  char v6;

  v2 = (char *)this + 32;
  if (*((char *)this + 55) < 0)
    v2 = *(char **)v2;
  sub_1000CB3F4(__p, v2);
  CFError = SERestoreInfo::CreateCFError((const UInt8 *)__p, *((_DWORD *)this + 16), 0, *((const __CFString **)this + 7));
  if (v6 < 0)
    operator delete(__p[0]);
  return CFError;
}

void sub_1000E61F8(std::string *this, std::string::value_type *a2, std::string::value_type *a3, std::string::size_type a4)
{
  std::string *v8;
  std::string::size_type size;
  std::string::size_type v10;
  unint64_t v11;
  unint64_t v12;
  std::string::value_type v13;

  if ((SHIBYTE(this->__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    v8 = this;
    if (a4 <= 0x16)
      goto LABEL_11;
    size = HIBYTE(this->__r_.__value_.__r.__words[2]);
    v10 = 22;
    goto LABEL_6;
  }
  v11 = this->__r_.__value_.__r.__words[2];
  v10 = (v11 & 0x7FFFFFFFFFFFFFFFLL) - 1;
  if (v10 < a4)
  {
    size = this->__r_.__value_.__l.__size_;
LABEL_6:
    std::string::__grow_by(this, v10, a4 - v10, size, 0, size, 0);
    this->__r_.__value_.__l.__size_ = 0;
    LOBYTE(v12) = *((_BYTE *)&this->__r_.__value_.__s + 23);
    goto LABEL_8;
  }
  v12 = HIBYTE(v11);
LABEL_8:
  v8 = this;
  if ((v12 & 0x80) != 0)
    v8 = (std::string *)this->__r_.__value_.__r.__words[0];
LABEL_11:
  while (a2 != a3)
  {
    v13 = *a2++;
    v8->__r_.__value_.__s.__data_[0] = v13;
    v8 = (std::string *)((char *)v8 + 1);
  }
  v8->__r_.__value_.__s.__data_[0] = 0;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
    this->__r_.__value_.__l.__size_ = a4;
  else
    *((_BYTE *)&this->__r_.__value_.__s + 23) = a4 & 0x7F;
}

uint64_t SERestoreInfo::IcefallDeliveryObject::addApdu(uint64_t a1, int a2, unint64_t *a3)
{
  uint64_t result;
  uint64_t v5;
  unint64_t *v6;
  uint64_t **v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  unint64_t *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *exception;
  void *v18;
  _DWORD *v19[4];
  _QWORD v20[4];
  _DWORD *v21;
  _DWORD *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27[2];
  int v28;

  v28 = a2;
  result = (uint64_t)DERDecodeSeqContentInit(a3, v27);
  v5 = result;
  if ((_DWORD)result)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v19, "Cannot decode APDUs.");
    v18 = (void *)SERestoreInfo::SEException::SEException(exception, v19, v5, CFSTR("libDERErrorDomain"));
  }
  while (!(_DWORD)v5)
  {
    result = DERDecodeSeqNext(v27, &v25);
    v5 = result;
    if (!(_DWORD)result)
    {
      v6 = DERParseSequenceContent(&v26, 2u, (uint64_t)&unk_100167BD8, (unint64_t)&v21, 0x20uLL);
      if ((_DWORD)v6)
      {
        v12 = v6;
        v13 = __cxa_allocate_exception(0x48uLL);
        sub_1000CB3F4(v19, "Cannot parse per ApduItemSpec");
        v14 = (void *)SERestoreInfo::SEException::SEException(v13, v19, v12, CFSTR("libDERErrorDomain"));
      }
      if (v22 != (_DWORD *)5)
      {
        v10 = __cxa_allocate_exception(0x48uLL);
        sub_1000CB3F4(v19, "wrong apdu header size");
        v11 = (void *)SERestoreInfo::SEException::SEException(v10, v19, 15, CFSTR("SEUpdaterErrorDomain"));
      }
      if ((unint64_t)(v24 - 8242) <= 0xFFFFFFFFFFFFDFC8)
      {
        v15 = __cxa_allocate_exception(0x48uLL);
        sub_1000CB3F4(v19, "wrong apdu size");
        v16 = (void *)SERestoreInfo::SEException::SEException(v15, v19, 15, CFSTR("SEUpdaterErrorDomain"));
      }
      v19[0] = &v28;
      v7 = sub_1000E7940((uint64_t **)(a1 + 8), &v28, (uint64_t)&unk_100167E65, v19);
      v19[0] = off_100183340;
      v19[1] = v21;
      v19[2] = v22;
      v19[3] = 0;
      v20[0] = off_100183340;
      v20[1] = v23;
      v20[2] = v24;
      v20[3] = 0;
      sub_1000E6600((uint64_t *)v7 + 5, (uint64_t)v19);
      sub_1000E42C4(v20);
      result = (uint64_t)sub_1000E42C4(v19);
    }
  }
  if ((_DWORD)v5 != 1)
  {
    v8 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v19, "Fail to parse Apdu]");
    v9 = (void *)SERestoreInfo::SEException::SEException(v8, v19, v5, CFSTR("libDERErrorDomain"));
  }
  return result;
}

void sub_1000E659C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void **sub_1000E6600(uint64_t *a1, uint64_t a2)
{
  void **result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  __int128 v18;
  void *v19[5];

  v6 = a1[2];
  result = (void **)(a1 + 2);
  v5 = v6;
  v7 = (unint64_t)*(result - 1);
  if (v7 >= v6)
  {
    v11 = (uint64_t)(v7 - *a1) >> 6;
    v12 = v11 + 1;
    if ((unint64_t)(v11 + 1) >> 58)
      sub_1000CB780();
    v13 = v5 - *a1;
    if (v13 >> 5 > v12)
      v12 = v13 >> 5;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFC0)
      v14 = 0x3FFFFFFFFFFFFFFLL;
    else
      v14 = v12;
    v19[4] = result;
    if (v14)
      v15 = (char *)sub_1000E7A78((uint64_t)result, v14);
    else
      v15 = 0;
    v16 = &v15[64 * v11];
    v19[0] = v15;
    v19[1] = v16;
    v19[3] = &v15[64 * v14];
    *(_QWORD *)v16 = off_100183340;
    v17 = *(_QWORD *)(a2 + 24);
    *(_OWORD *)(v16 + 8) = *(_OWORD *)(a2 + 8);
    *((_QWORD *)v16 + 3) = v17;
    *((_QWORD *)v16 + 4) = off_100183340;
    v18 = *(_OWORD *)(a2 + 40);
    *((_QWORD *)v16 + 7) = *(_QWORD *)(a2 + 56);
    *(_OWORD *)(v16 + 40) = v18;
    v19[2] = v16 + 64;
    sub_1000E7A04(a1, v19);
    v10 = a1[1];
    result = sub_1000E7BDC(v19);
  }
  else
  {
    *(_QWORD *)v7 = off_100183340;
    v8 = *(_QWORD *)(a2 + 24);
    *(_OWORD *)(v7 + 8) = *(_OWORD *)(a2 + 8);
    *(_QWORD *)(v7 + 24) = v8;
    *(_QWORD *)(v7 + 32) = off_100183340;
    v9 = *(_OWORD *)(a2 + 40);
    *(_QWORD *)(v7 + 56) = *(_QWORD *)(a2 + 56);
    *(_OWORD *)(v7 + 40) = v9;
    v10 = v7 + 64;
    a1[1] = v7 + 64;
  }
  a1[1] = v10;
  return result;
}

void sub_1000E6734(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  sub_1000E7BDC((void **)va);
  _Unwind_Resume(a1);
}

_QWORD *SERestoreInfo::IcefallDeliveryObject::addMac(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t *i;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t **v7;
  void *exception;
  void *v10;
  _QWORD v11[4];
  int v12;
  int *v13;

  v12 = a2;
  for (i = *(uint64_t **)(a1 + 40); i; i = (uint64_t *)*i)
  {
    v4 = *((_DWORD *)i + 8);
    if (v4 <= a2)
    {
      if (v4 >= a2)
      {
        exception = __cxa_allocate_exception(0x48uLL);
        sub_1000CB3F4(v11, "Fail to addMac");
        v10 = (void *)SERestoreInfo::SEException::SEException(exception, v11, 15, CFSTR("SEUpdaterErrorDomain"));
      }
      ++i;
    }
  }
  v5 = *a3;
  v6 = a3[1];
  v11[0] = off_100183340;
  v11[1] = v5;
  v11[2] = v6;
  v11[3] = 0;
  v13 = &v12;
  v7 = sub_1000E7C68((uint64_t **)(a1 + 32), &v12, (uint64_t)&unk_100167E65, &v13);
  sub_1000E3C54(v7 + 5, v11);
  return sub_1000E42C4(v11);
}

void sub_1000E6830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  sub_1000E42C4(&__p);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::IcefallDeliveryObject::updateMeasurement(SERestoreInfo::IcefallDeliveryObject *this, CFDictionaryRef theDict, __CFError **a3)
{
  char *v5;
  char *v6;
  uint64_t v8;
  const void *v9;
  const void *Value;
  __CFDictionary *Mutable;
  const UInt8 *v12;
  int v13;
  CFDataRef v14;
  CFDataRef v15;
  __CFError *CFError;
  char *v17;
  char *v18;
  BOOL v19;
  const UInt8 *v20;
  void *v22;
  std::runtime_error *v23;
  std::string *v24;
  __int128 v25;
  std::runtime_error *v26;
  std::string *v27;
  __int128 v28;
  std::runtime_error *exception;
  std::string *v30;
  std::string *v31;
  __int128 v32;
  std::runtime_error *v33;
  std::string *v34;
  std::string *v35;
  __int128 v36;
  void *__p[2];
  char v38;
  UInt8 v39[23];
  char v40;
  UInt8 v41[23];
  char v42;
  std::string v43;
  const __CFString *v44;
  const __CFString *v45;
  std::string v46;
  std::string v47;

  if (!theDict)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v30 = (std::string *)sub_1000CB3F4(&v47, "Assertion: ");
    v31 = std::string::append(v30, "outMeasurementDict");
    v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v43);
  }
  if (!a3)
  {
    v33 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v34 = (std::string *)sub_1000CB3F4(&v47, "Assertion: ");
    v35 = std::string::append(v34, "outError");
    v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    v43.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v43.__r_.__value_.__l.__data_ = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v33, &v43);
  }
  v43.__r_.__value_.__r.__words[0] = (std::string::size_type)CFSTR("SE,Bootloader");
  v43.__r_.__value_.__l.__size_ = (std::string::size_type)CFSTR("SE,Bootloader");
  v43.__r_.__value_.__r.__words[2] = (std::string::size_type)CFSTR("SE,OS");
  v44 = CFSTR("SE,MigrationOS");
  v45 = CFSTR("SE,Firmware");
  v5 = (char *)*((_QWORD *)this + 4);
  v6 = (char *)this + 40;
  if (v5 == (char *)this + 40)
    return 1;
  while (1)
  {
    v8 = *((unsigned int *)v5 + 8);
    if (v8 >= 5)
    {
      sub_1000CB3F4(v41, "cmac.first is out of range");
      *a3 = SERestoreInfo::CreateCFError(v41, 2, 0, CFSTR("SEUpdaterErrorDomain"));
      if ((v42 & 0x80000000) == 0)
        return 0;
      v22 = *(void **)v41;
      goto LABEL_37;
    }
    v9 = (const void *)*((_QWORD *)&v43.__r_.__value_.__l.__data_ + v8);
    if (CFDictionaryContainsKey(theDict, v9))
      break;
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable)
    {
      sub_1000CB3F4(__p, "imageProps is nullptr");
      *a3 = SERestoreInfo::CreateCFError((const UInt8 *)__p, 3, 0, CFSTR("SEUpdaterErrorDomain"));
      if ((v38 & 0x80000000) == 0)
        return 0;
      v22 = __p[0];
      goto LABEL_37;
    }
LABEL_9:
    v12 = (const UInt8 *)*((_QWORD *)v5 + 6);
    if (!v12)
    {
      v23 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1000CB3F4(&v46, "Assertion: ");
      v24 = std::string::append(&v46, "cmac");
      v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v25;
      v24->__r_.__value_.__l.__size_ = 0;
      v24->__r_.__value_.__r.__words[2] = 0;
      v24->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v23, &v47);
    }
    if (*((_QWORD *)v5 + 7) != 16)
    {
      v26 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1000CB3F4(&v46, "Assertion: ");
      v27 = std::string::append(&v46, "cmac_len == CMAC_SIZE");
      v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
      v47.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v28;
      v27->__r_.__value_.__l.__size_ = 0;
      v27->__r_.__value_.__r.__words[2] = 0;
      v27->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v26, &v47);
    }
    v13 = *((unsigned __int8 *)this + 80);
    v14 = CFDataCreate(0, v12, 16);
    if (v14)
    {
      v15 = v14;
      if (v13)
        CFDictionarySetValue(Mutable, CFSTR("DevelopmentCMAC"), v14);
      else
        CFDictionaryAddValue(Mutable, CFSTR("ProductionCMAC"), v14);
      CFRelease(v15);
      goto LABEL_16;
    }
    v20 = (const UInt8 *)sub_1000CB3F4(&v47, "Cannot allocate for tmpData");
    CFError = SERestoreInfo::CreateCFError(v20, 3, 0, CFSTR("SEUpdaterErrorDomain"));
    *a3 = CFError;
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    {
      operator delete(v47.__r_.__value_.__l.__data_);
LABEL_16:
      CFError = *a3;
    }
    if (CFError)
    {
      CFRelease(Mutable);
      return 0;
    }
    CFDictionarySetValue(theDict, v9, Mutable);
    CFRelease(Mutable);
    v17 = (char *)*((_QWORD *)v5 + 1);
    if (v17)
    {
      do
      {
        v18 = v17;
        v17 = *(char **)v17;
      }
      while (v17);
    }
    else
    {
      do
      {
        v18 = (char *)*((_QWORD *)v5 + 2);
        v19 = *(_QWORD *)v18 == (_QWORD)v5;
        v5 = v18;
      }
      while (!v19);
    }
    v5 = v18;
    if (v18 == v6)
      return 1;
  }
  Value = CFDictionaryGetValue(theDict, v9);
  Mutable = (__CFDictionary *)CFRetain(Value);
  if (Mutable)
    goto LABEL_9;
  sub_1000CB3F4(v39, "imageProps is nullptr");
  *a3 = SERestoreInfo::CreateCFError(v39, 2, 0, CFSTR("SEUpdaterErrorDomain"));
  if (v40 < 0)
  {
    v22 = *(void **)v39;
LABEL_37:
    operator delete(v22);
  }
  return 0;
}

void sub_1000E6D18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, char a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,char a24,uint64_t a25,int a26,__int16 a27,char a28,char a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,int a40,__int16 a41,char a42,char a43)
{
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::IcefallDeliveryObject::updateVersionDict(SERestoreInfo::IcefallDeliveryObject *this, __CFDictionary *a2, __CFError **a3)
{
  char *v5;
  int v6;
  uint64_t *v7;
  unsigned int v8;
  CFStringRef v9;
  __CFString **v10;
  std::runtime_error *exception;
  std::string *v13;
  __int128 v14;
  std::runtime_error *v15;
  std::string *v16;
  __int128 v17;
  char __str[4];
  __int16 v19;
  std::string v20;
  std::string v21;

  if (!a2 || !a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v20, "Assertion: ");
    v13 = std::string::append(&v20, "outError && outDict");
    v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v14;
    v13->__r_.__value_.__l.__size_ = 0;
    v13->__r_.__value_.__r.__words[2] = 0;
    v13->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v21);
  }
  v19 = 0;
  *(_DWORD *)__str = 0;
  v5 = (char *)this + 56;
  LODWORD(v21.__r_.__value_.__l.__data_) = 2;
  v6 = *((unsigned __int8 *)sub_1000E7070((uint64_t)this + 56, (int *)&v21) + 1);
  LODWORD(v21.__r_.__value_.__l.__data_) = 2;
  v7 = sub_1000E7070((uint64_t)v5, (int *)&v21);
  v8 = snprintf(__str, 6uLL, "%d.%d", *(unsigned __int8 *)v7, v6);
  if (v8 - 6 <= 0xFFFFFFFA)
  {
    v15 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v20, "Assertion: ");
    v16 = std::string::append(&v20, "nchar>0 && nchar<sizeof(buffer)");
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    v21.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v21.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v15, &v21);
  }
  v9 = CFStringCreateWithBytes(0, (const UInt8 *)__str, v8, 0x8000100u, 0);
  v10 = kSETagVersionDev;
  if (!*((_BYTE *)this + 80))
    v10 = kSETagVersionProd;
  CFDictionarySetValue(a2, *v10, v9);
  if (v9)
    CFRelease(v9);
  return 1;
}

void sub_1000E7004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  void *v23;
  int v24;

  if (a23 < 0)
    operator delete(__p);
  if (a17 < 0)
  {
    operator delete(a12);
    if ((v24 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v24)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v23);
  goto LABEL_8;
}

uint64_t *sub_1000E7070(uint64_t a1, int *a2)
{
  uint64_t *v2;
  int v3;
  int v4;

  v2 = *(uint64_t **)(a1 + 8);
  if (!v2)
LABEL_8:
    sub_1000CC054("map::at:  key not found");
  v3 = *a2;
  while (1)
  {
    while (1)
    {
      v4 = *((_DWORD *)v2 + 7);
      if (v3 >= v4)
        break;
      v2 = (uint64_t *)*v2;
      if (!v2)
        goto LABEL_8;
    }
    if (v4 >= v3)
      return v2 + 4;
    v2 = (uint64_t *)v2[1];
    if (!v2)
      goto LABEL_8;
  }
}

BOOL SERestoreInfo::IcefallDeliveryObject::matchID(uint64_t a1, uint64_t a2)
{
  size_t v2;
  const void *v3;

  v2 = *(_QWORD *)(a1 + 104);
  v3 = *(const void **)a2;
  return v2 == *(_QWORD *)(a2 + 8) - (_QWORD)v3 && memcmp(*(const void **)(a1 + 96), v3, v2) == 0;
}

uint64_t SERestoreInfo::IcefallFirmware::makeDeliveryObject@<X0>(DERItem *a1@<X1>, uint64_t *a2@<X8>)
{
  char *v5;
  uint64_t v6;
  unint64_t *v7;
  char *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  void *v13;
  void *v14;
  unint64_t *v15;
  void *exception;
  void *v17;
  _QWORD v18[3];
  _QWORD v19[4];
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BYTE *v24;
  char *v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28[2];
  __int16 *v29[2];
  unint64_t v30;
  uint64_t v31[2];
  __int16 *v32[2];
  unint64_t v33;
  uint64_t v34[2];
  __int16 *v35[2];
  unint64_t v36[2];
  unint64_t v37;
  uint64_t v38[2];
  __int16 *v39[4];
  unint64_t v40;
  unint64_t v41[4];

  v5 = (char *)operator new(0xB0uLL);
  *((_QWORD *)v5 + 2) = 0;
  *(_QWORD *)v5 = off_100183590;
  *((_QWORD *)v5 + 1) = 0;
  *((_QWORD *)v5 + 3) = off_100183538;
  v6 = (uint64_t)(v5 + 24);
  *(_OWORD *)(v5 + 104) = 0u;
  *(_OWORD *)(v5 + 136) = 0u;
  *(_OWORD *)(v5 + 120) = 0u;
  *(_OWORD *)(v5 + 152) = 0u;
  *((_QWORD *)v5 + 5) = 0;
  *((_QWORD *)v5 + 4) = v5 + 40;
  *((_QWORD *)v5 + 8) = 0;
  *((_QWORD *)v5 + 6) = 0;
  *((_QWORD *)v5 + 7) = v5 + 64;
  *((_QWORD *)v5 + 12) = 0;
  *((_QWORD *)v5 + 11) = 0;
  *((_QWORD *)v5 + 9) = 0;
  *((_QWORD *)v5 + 10) = v5 + 88;
  v5[104] = 1;
  *((_QWORD *)v5 + 14) = off_100183340;
  *((_QWORD *)v5 + 18) = off_100183340;
  *((_QWORD *)v5 + 21) = 0;
  v41[2] = (unint64_t)(v5 + 24);
  v41[3] = (unint64_t)v5;
  v7 = DERParseSequenceContent((unint64_t *)a1, 0x16u, (uint64_t)&unk_100167C08, (unint64_t)v19, 0x160uLL);
  if ((_DWORD)v7)
  {
    v15 = v7;
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v18, "Fail to parse IcefallFW per DeliveryObjectItemSpec.");
    v17 = (void *)SERestoreInfo::SEException::SEException(exception, v18, v15, CFSTR("libDERErrorDomain"));
  }
  if (v19[1] != 2
    || (v8 = v25, v9 = v26, v25) && v26 > 1
    || *(_BYTE *)v19[0]
    || *(unsigned __int8 *)(v19[0] + 1) < 7u
    || v21 != 32
    || (v10 = v20) == 0
    || v23 != 32
    || (v11 = v22) == 0
    || v28[1] != 16
    || !v28[0]
    || v31[1] != 16
    || !v31[0]
    || v38[1] != 16
    || !v38[0]
    || v29[1] != (__int16 *)2
    || !v29[0]
    || v32[1] != (__int16 *)2
    || !v32[0]
    || v39[1] != (__int16 *)2
    || !v39[0]
    || v36[1] && v36[0] && (v34[1] != 16 || !v34[0] || v35[1] != (__int16 *)2 || !v35[0]))
  {
    v13 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v18, "Fail to validate delivery object.");
    v14 = (void *)SERestoreInfo::SEException::SEException(v13, v18, 15, CFSTR("SEUpdaterErrorDomain"));
  }
  v5[104] = *v24 == 0;
  *((_QWORD *)v5 + 15) = v11;
  *((_QWORD *)v5 + 16) = 32;
  *((_QWORD *)v5 + 19) = v10;
  *((_QWORD *)v5 + 20) = 32;
  if (v8 && v9)
    v5[105] = *v8;
  SERestoreInfo::IcefallDeliveryObject::addMac(v6, 0, v28);
  sub_1000E7548(v6, 0, v29);
  SERestoreInfo::IcefallDeliveryObject::addMac(v6, 4, v31);
  sub_1000E7548(v6, 4, v32);
  SERestoreInfo::IcefallDeliveryObject::addMac(v6, 2, v38);
  sub_1000E7548(v6, 2, v39);
  if (v34[0])
  {
    SERestoreInfo::IcefallDeliveryObject::addMac(v6, 3, v34);
    sub_1000E7548(v6, 3, v35);
  }
  SERestoreInfo::IcefallDeliveryObject::addApdu(v6, 6, &v27);
  SERestoreInfo::IcefallDeliveryObject::addApdu(v6, 8, v41);
  if (v37)
    SERestoreInfo::IcefallDeliveryObject::addApdu(v6, 7, &v37);
  SERestoreInfo::IcefallDeliveryObject::addApdu(v6, 0, &v30);
  SERestoreInfo::IcefallDeliveryObject::addApdu(v6, 4, &v33);
  result = SERestoreInfo::IcefallDeliveryObject::addApdu(v6, 2, &v40);
  if (v36[0])
    result = SERestoreInfo::IcefallDeliveryObject::addApdu(v6, 3, v36);
  *a2 = v6;
  a2[1] = (uint64_t)v5;
  return result;
}

void sub_1000E7504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  sub_1000CB5E0(v15 - 64);
  _Unwind_Resume(a1);
}

uint64_t **sub_1000E7548(uint64_t a1, int a2, __int16 **a3)
{
  __int16 v3;
  uint64_t **result;
  std::runtime_error *exception;
  std::string *v6;
  __int128 v7;
  std::string v8;
  std::string v9;
  int v10;

  v10 = a2;
  if (a3[1] != (__int16 *)2)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v8, "Assertion: ");
    v6 = std::string::append(&v8, "item.length == sizeof(uint16_t)");
    v7 = *(_OWORD *)&v6->__r_.__value_.__l.__data_;
    v9.__r_.__value_.__r.__words[2] = v6->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v9.__r_.__value_.__l.__data_ = v7;
    v6->__r_.__value_.__l.__size_ = 0;
    v6->__r_.__value_.__r.__words[2] = 0;
    v6->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v9);
  }
  v3 = **a3;
  v9.__r_.__value_.__r.__words[0] = (std::string::size_type)&v10;
  result = sub_1000E7748((uint64_t **)(a1 + 56), &v10, (uint64_t)&unk_100167E65, &v9);
  *((_WORD *)result + 16) = v3;
  return result;
}

void sub_1000E7624(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t sub_1000E7684(uint64_t a1)
{
  *(_QWORD *)a1 = off_100183538;
  sub_1000E42C4((_QWORD *)(a1 + 120));
  sub_1000E42C4((_QWORD *)(a1 + 88));
  sub_1000CBD74(a1 + 56, *(_QWORD **)(a1 + 64));
  sub_1000E7808(a1 + 32, *(_QWORD **)(a1 + 40));
  sub_1000E7850(a1 + 8, *(char **)(a1 + 16));
  return a1;
}

void sub_1000E76E0(void *a1)
{
  *(_QWORD *)a1 = off_100183538;
  sub_1000E42C4((_QWORD *)a1 + 15);
  sub_1000E42C4((_QWORD *)a1 + 11);
  sub_1000CBD74((uint64_t)a1 + 56, *((_QWORD **)a1 + 8));
  sub_1000E7808((uint64_t)a1 + 32, *((_QWORD **)a1 + 5));
  sub_1000E7850((uint64_t)a1 + 8, *((char **)a1 + 2));
  operator delete(a1);
}

void sub_1000E773C(_QWORD *a1@<X8>)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
}

uint64_t **sub_1000E7748(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  int v8;
  uint64_t **v9;
  int v10;
  _DWORD *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = *((_DWORD *)v6 + 7);
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = operator new(0x28uLL);
    v11[7] = **a4;
    *((_WORD *)v11 + 16) = 0;
    sub_1000CBAE0(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

void sub_1000E7808(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    sub_1000E7808(a1, *a2);
    sub_1000E7808(a1, a2[1]);
    sub_1000E42C4(a2 + 5);
    operator delete(a2);
  }
}

void sub_1000E7850(uint64_t a1, char *a2)
{
  void **v4;

  if (a2)
  {
    sub_1000E7850(a1, *(_QWORD *)a2);
    sub_1000E7850(a1, *((_QWORD *)a2 + 1));
    v4 = (void **)(a2 + 40);
    sub_1000E78A8(&v4);
    operator delete(a2);
  }
}

void sub_1000E78A8(void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    sub_1000E78E8(v2, *v2);
    operator delete(**a1);
  }
}

_QWORD *sub_1000E78E8(_QWORD *result, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  v3 = result;
  v4 = (_QWORD *)result[1];
  if (v4 != a2)
  {
    do
    {
      v5 = v4 - 8;
      sub_1000E42C4(v4 - 4);
      result = sub_1000E42C4(v5);
      v4 = v5;
    }
    while (v5 != a2);
  }
  v3[1] = a2;
  return result;
}

uint64_t **sub_1000E7940(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  int v8;
  uint64_t **v9;
  int v10;
  _DWORD *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = *((_DWORD *)v6 + 8);
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = operator new(0x40uLL);
    v11[8] = **a4;
    *((_QWORD *)v11 + 6) = 0;
    *((_QWORD *)v11 + 7) = 0;
    *((_QWORD *)v11 + 5) = 0;
    sub_1000CBAE0(a1, (uint64_t)v9, v7, (uint64_t *)v11);
    return (uint64_t **)v11;
  }
  return v9;
}

uint64_t sub_1000E7A04(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = sub_1000E7AAC((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *sub_1000E7A78(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    sub_1000CB52C();
  return operator new(a2 << 6);
}

uint64_t sub_1000E7AAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  uint64_t v11;
  _QWORD v13[3];
  char v14;
  __int128 v15;
  __int128 v16;

  v7 = a7;
  *(_QWORD *)&v16 = a6;
  *((_QWORD *)&v16 + 1) = a7;
  v15 = v16;
  v13[0] = a1;
  v13[1] = &v15;
  v13[2] = &v16;
  if (a3 == a5)
  {
    v11 = a6;
  }
  else
  {
    v8 = a7;
    do
    {
      *(_QWORD *)(v8 - 64) = off_100183340;
      v8 -= 64;
      v9 = *(_QWORD *)(a3 - 40);
      *(_OWORD *)(v8 + 8) = *(_OWORD *)(a3 - 56);
      *(_QWORD *)(v8 + 24) = v9;
      *(_QWORD *)(v8 + 32) = off_100183340;
      v10 = *(_OWORD *)(a3 - 24);
      *(_QWORD *)(v8 + 56) = *(_QWORD *)(a3 - 8);
      *(_OWORD *)(v8 + 40) = v10;
      v7 -= 64;
      a3 -= 64;
    }
    while (a3 != a5);
    *((_QWORD *)&v16 + 1) = v8;
    v11 = v16;
  }
  v14 = 1;
  sub_1000E7B64((uint64_t)v13);
  return v11;
}

uint64_t sub_1000E7B64(uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    sub_1000E7B98((_QWORD *)a1);
  return a1;
}

_QWORD *sub_1000E7B98(_QWORD *result)
{
  _QWORD *v1;
  _QWORD *v2;

  v1 = *(_QWORD **)(result[2] + 8);
  v2 = *(_QWORD **)(result[1] + 8);
  while (v1 != v2)
  {
    sub_1000E42C4(v1 + 4);
    result = sub_1000E42C4(v1);
    v1 += 8;
  }
  return result;
}

void **sub_1000E7BDC(void **a1)
{
  sub_1000E7C10(a1, (uint64_t)a1[1]);
  if (*a1)
    operator delete(*a1);
  return a1;
}

_QWORD *sub_1000E7C10(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  _QWORD *v5;

  v2 = result[2];
  if (v2 != a2)
  {
    v4 = result;
    do
    {
      v5 = (_QWORD *)(v2 - 64);
      v4[2] = v2 - 64;
      sub_1000E42C4((_QWORD *)(v2 - 32));
      result = sub_1000E42C4(v5);
      v2 = v4[2];
    }
    while (v2 != a2);
  }
  return result;
}

uint64_t **sub_1000E7C68(uint64_t **a1, int *a2, uint64_t a3, _DWORD **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t **v8;
  uint64_t **v9;
  int v10;
  int v11;
  _DWORD *v12;
  _QWORD v14[2];
  char v15;

  v7 = a1 + 1;
  v6 = a1[1];
  v8 = a1 + 1;
  v9 = a1 + 1;
  if (v6)
  {
    v10 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v11 = *((_DWORD *)v6 + 8);
        if (v10 >= v11)
          break;
        v6 = *v9;
        v8 = v9;
        if (!*v9)
          goto LABEL_9;
      }
      if (v11 >= v10)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v8 = v9 + 1;
        goto LABEL_9;
      }
    }
  }
  else
  {
LABEL_9:
    v12 = operator new(0x48uLL);
    v14[1] = v7;
    v12[8] = **a4;
    *((_QWORD *)v12 + 5) = off_100183340;
    *((_QWORD *)v12 + 8) = 0;
    v15 = 1;
    sub_1000CBAE0(a1, (uint64_t)v9, v8, (uint64_t *)v12);
    v14[0] = 0;
    sub_1000E7D5C((uint64_t)v14, 0);
    return (uint64_t **)v12;
  }
  return v9;
}

void sub_1000E7D5C(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;

  v2 = *(_QWORD **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      sub_1000E42C4(v2 + 5);
    operator delete(v2);
  }
}

void sub_1000E7DA0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100183590;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000E7DB4(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100183590;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000E7DD8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

uint64_t SERestoreInfo::SEFirmwareIter::operator*(uint64_t a1)
{
  return SERestoreInfo::SEFirmwareBase::get(*(SERestoreInfo::SEFirmwareBase **)(a1 + 8), *(_DWORD *)a1);
}

uint64_t SERestoreInfo::SEFirmwareBase::get(SERestoreInfo::SEFirmwareBase *this, unsigned int a2)
{
  uint64_t v2;
  std::runtime_error *exception;
  std::string *v5;
  __int128 v6;
  std::string v7;
  std::string v8;

  if ((a2 & 0x80000000) != 0
    || (v2 = *((_QWORD *)this + 2), a2 >= (unint64_t)((*((_QWORD *)this + 3) - v2) >> 5)))
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v7, "Assertion: ");
    v5 = std::string::append(&v7, "index>=0 && index<fObjs.size()");
    v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
    v8.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v8.__r_.__value_.__l.__data_ = v6;
    v5->__r_.__value_.__l.__size_ = 0;
    v5->__r_.__value_.__r.__words[2] = 0;
    v5->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v8);
  }
  *(_OWORD *)&v8.__r_.__value_.__l.__data_ = *(_OWORD *)(v2 + 32 * a2 + 8);
  return (*(uint64_t (**)(SERestoreInfo::SEFirmwareBase *, std::string *))(*(_QWORD *)this + 24))(this, &v8);
}

void sub_1000E7ED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

uint64_t SERestoreInfo::SEFirmwareBase::getFormatVer(SERestoreInfo::SEFirmwareBase *this, const __CFData *a2)
{
  uint64_t v3;
  uint64_t v4;
  std::runtime_error *exception;
  std::string *v7;
  __int128 v8;
  uint64_t v9;
  void *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  void *v14;
  _QWORD v15[2];
  std::string v16;
  unsigned int v17;
  std::string v18;

  if (!this)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v18, "Assertion: ");
    v7 = std::string::append(&v18, "source");
    v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v16.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v16.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v16);
  }
  v17 = -1;
  v15[0] = CFDataGetBytePtr(this);
  v15[1] = CFDataGetLength(this);
  v3 = DERParseSequence((uint64_t)v15, 2u, (uint64_t)&unk_100167EC8, (unint64_t)&v16, 0x20uLL);
  if ((_DWORD)v3)
  {
    v9 = v3;
    v10 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v18, " Fail to parse fw per SEFirmwareItemSpec");
    v11 = (void *)SERestoreInfo::SEException::SEException(v10, &v18, v9, CFSTR("libDERErrorDomain"));
  }
  v4 = DERParseInteger(&v16.__r_.__value_.__l.__data_, &v17);
  if ((_DWORD)v4)
  {
    v12 = v4;
    v13 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v18, "Cannot parse SEFirmware.version.");
    v14 = (void *)SERestoreInfo::SEException::SEException(v13, &v18, v12, CFSTR("libDERErrorDomain"));
  }
  return v17;
}

void sub_1000E80CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,int a21,__int16 a22,char a23,char a24)
{
  if (a24 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SERestoreInfo::SEFirmwareBase *SERestoreInfo::SEFirmwareBase::SEFirmwareBase(SERestoreInfo::SEFirmwareBase *this, CFDataRef theData)
{
  int64x2_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  __int128 v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  __int128 v21;
  int64x2_t v22;
  uint64_t v23;
  void *v25;
  void *v26;
  void *exception;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  std::string *v32;
  __int128 v33;
  void *v34;
  void *v35;
  void *v36;
  std::string v38;
  uint64_t v39;
  unint64_t v40;
  __int128 v41;
  unsigned int __val;
  _QWORD v43[2];
  unint64_t v44[2];
  uint64_t v45;
  char *v46[2];
  uint64_t v47;
  _BYTE v48[24];
  uint64_t v49;
  char *v50;

  *(_QWORD *)this = off_1001835E0;
  *((_QWORD *)this + 2) = 0;
  v3 = (int64x2_t *)((char *)this + 16);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  v45 = 0;
  v43[0] = CFDataGetBytePtr(theData);
  v43[1] = CFDataGetLength(theData);
  v4 = DERParseSequence((uint64_t)v43, 2u, (uint64_t)&unk_100167EC8, (unint64_t)v46, 0x20uLL);
  if ((_DWORD)v4)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v48, "Fail to parse SEFW.");
    v28 = (void *)SERestoreInfo::SEException::SEException(exception, v48, v4, CFSTR("libDERErrorDomain"));
  }
  __val = 0;
  v5 = DERParseInteger(v46, &__val);
  if ((_DWORD)v5)
  {
    v29 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v48, "Failed to parse SEFirmware.version.");
    v30 = (void *)SERestoreInfo::SEException::SEException(v29, v48, v5, CFSTR("libDERErrorDomain"));
  }
  if (__val >= 2)
  {
    v31 = __cxa_allocate_exception(0x48uLL);
    std::to_string(&v38, __val);
    v32 = std::string::insert(&v38, 0, "Unsupported firmware version: ");
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    *(_QWORD *)&v48[16] = *((_QWORD *)&v32->__r_.__value_.__l + 2);
    *(_OWORD *)v48 = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    v34 = (void *)SERestoreInfo::SEException::SEException(v31, v48, 7, CFSTR("SEUpdaterErrorDomain"));
  }
  v6 = DERDecodeSeqInit((uint64_t)&v47, &v45, v44);
  if ((_DWORD)v6)
  {
    v35 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v48, "Fail to DERDecodeSeqInit firmwareArray.");
    v36 = (void *)SERestoreInfo::SEException::SEException(v35, v48, v6, CFSTR("libDERErrorDomain"));
  }
  while (!(_DWORD)v6)
  {
    v6 = DERDecodeSeqNext(v44, &v40);
    if (!(_DWORD)v6)
    {
      v38.__r_.__value_.__r.__words[0] = (std::string::size_type)off_100183340;
      *(_OWORD *)&v38.__r_.__value_.__r.__words[1] = v41;
      v39 = 0;
      v7 = *((_QWORD *)this + 3);
      v8 = *((_QWORD *)this + 4);
      if (v7 >= v8)
      {
        v11 = (uint64_t)(v7 - v3->i64[0]) >> 5;
        v12 = v11 + 1;
        if ((unint64_t)(v11 + 1) >> 59)
          sub_1000CB780();
        v13 = v8 - v3->i64[0];
        if (v13 >> 4 > v12)
          v12 = v13 >> 4;
        if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFE0)
          v14 = 0x7FFFFFFFFFFFFFFLL;
        else
          v14 = v12;
        v50 = (char *)this + 32;
        if (v14)
          v15 = (char *)sub_1000E43F4((uint64_t)this + 32, v14);
        else
          v15 = 0;
        v16 = &v15[32 * v11];
        *(_QWORD *)v16 = off_100183340;
        v17 = *(_OWORD *)&v38.__r_.__value_.__r.__words[1];
        *((_QWORD *)v16 + 3) = v39;
        *(_OWORD *)(v16 + 8) = v17;
        v18 = *((_QWORD *)this + 2);
        v19 = *((_QWORD *)this + 3);
        if (v19 == v18)
        {
          v22 = vdupq_n_s64(v19);
          v20 = &v15[32 * v11];
        }
        else
        {
          v20 = &v15[32 * v11];
          do
          {
            *((_QWORD *)v20 - 4) = off_100183340;
            v20 -= 32;
            v21 = *(_OWORD *)(v19 - 24);
            *((_QWORD *)v20 + 3) = *(_QWORD *)(v19 - 8);
            *(_OWORD *)(v20 + 8) = v21;
            v19 -= 32;
          }
          while (v19 != v18);
          v22 = *v3;
        }
        v10 = v16 + 32;
        *((_QWORD *)this + 2) = v20;
        *((_QWORD *)this + 3) = v16 + 32;
        *(int64x2_t *)&v48[8] = v22;
        v23 = *((_QWORD *)this + 4);
        *((_QWORD *)this + 4) = &v15[32 * v14];
        v49 = v23;
        *(_QWORD *)v48 = v22.i64[0];
        sub_1000E4428((uint64_t)v48);
      }
      else
      {
        *(_QWORD *)v7 = off_100183340;
        v9 = *(_OWORD *)&v38.__r_.__value_.__r.__words[1];
        *(_QWORD *)(v7 + 24) = v39;
        *(_OWORD *)(v7 + 8) = v9;
        v10 = (char *)(v7 + 32);
      }
      *((_QWORD *)this + 3) = v10;
      sub_1000E42C4(&v38);
    }
  }
  if ((_DWORD)v6 != 1)
  {
    v25 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v48, "Fail to DERDecodeSeqNext firmwareArray.");
    v26 = (void *)SERestoreInfo::SEException::SEException(v25, v48, v6, CFSTR("libDERErrorDomain"));
  }
  *((_QWORD *)this + 1) = CFRetain(theData);
  return this;
}

void sub_1000E856C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *__p,uint64_t a31,int a32,__int16 a33,char a34,char a35)
{
  if (a35 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  sub_1000E4718((void ***)&a26);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SEFirmwareBase::updateMeasurementDict(SERestoreInfo::SEFirmwareBase *this, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  char v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  std::__shared_weak_count *v11;
  unint64_t *p_shared_owners;
  unint64_t v13;
  SERestoreInfo::SEException *exception;
  void *v15;
  void *v16;
  void *v17;
  void *__p[3];
  uint64_t v19;
  std::__shared_weak_count *v20;

  v3 = (*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 5;
  if (!(_DWORD)v3)
    goto LABEL_18;
  v7 = 0;
  v8 = 0;
  do
  {
    SERestoreInfo::SEFirmwareBase::get(this, v8);
    if (!*(_QWORD *)a3)
      goto LABEL_7;
    v9 = v19;
    (*(void (**)(void **__return_ptr))(**(_QWORD **)a3 + 16))(__p);
    v10 = (*(uint64_t (**)(uint64_t, void **))(*(_QWORD *)v9 + 32))(v9, __p);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v10)
    {
LABEL_7:
      __p[0] = 0;
      (*(void (**)(uint64_t, uint64_t, void **))(*(_QWORD *)v19 + 16))(v19, a2, __p);
      if (__p[0])
      {
        exception = (SERestoreInfo::SEException *)__cxa_allocate_exception(0x48uLL);
        v15 = (void *)SERestoreInfo::SEException::SEException(exception, (__CFError *)__p[0]);
      }
      v7 = 1;
    }
    v11 = v20;
    if (v20)
    {
      p_shared_owners = (unint64_t *)&v20->__shared_owners_;
      do
        v13 = __ldaxr(p_shared_owners);
      while (__stlxr(v13 - 1, p_shared_owners));
      if (!v13)
      {
        ((void (*)(std::__shared_weak_count *))v11->__on_zero_shared)(v11);
        std::__shared_weak_count::__release_weak(v11);
      }
    }
    ++v8;
  }
  while (v8 != (_DWORD)v3);
  if ((v7 & 1) == 0)
  {
LABEL_18:
    v16 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(__p, "Cannot found any matched delivery object");
    v17 = (void *)SERestoreInfo::SEException::SEException(v16, __p, 24, CFSTR("SEUpdaterErrorDomain"));
  }
}

void sub_1000E87BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

CFMutableDictionaryRef SEUpdaterGetTagsLogSink(SERestoreInfo::SERestoreInfoLog *a1, void (*a2)(void *, const char *), void *a3, __CFError **a4)
{
  SERestoreInfo::SERestoreInfoLog *v8;

  v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  SERestoreInfo::SERestoreInfoLog::registerLogSink(v8, a2, a3);
  return SEUpdaterGetTags(a1, a4);
}

CFMutableDictionaryRef SEUpdaterGetTags(SERestoreInfo::SERestoreInfoLog *a1, __CFError **a2)
{
  SERestoreInfo::SERestoreInfoLog *v4;
  std::string *v5;
  SERestoreInfo::SERestoreInfoLog *Value;
  SERestoreInfo::SERestoreInfoLog *v7;
  std::string *v8;
  CFTypeID v9;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFMutableStringRef Mutable;
  uint64_t v13;
  unsigned int v14;
  const char *CStringPtr;
  char *v17;
  SERestoreInfo::SERestoreInfoLog *v18;
  SERestoreInfo::SERestoreInfoLog *v19;
  std::string *v20;
  CFMutableDictionaryRef v21;
  CFMutableArrayRef v22;
  CFMutableArrayRef v23;
  std::string::size_type v24;
  unint64_t v25;
  CFMutableArrayRef v26;
  SERestoreInfo::SERestoreInfoBase *ChipID;
  __CFString *TSSResponseTicketTag;
  int v29;
  __CFError *CFError;
  CFErrorRef v31;
  SERestoreInfo::SERestoreInfoLog *v32;
  std::string *v33;
  std::string *v34;
  const UInt8 *v36;
  void *v37;
  std::runtime_error *exception;
  std::string *v39;
  __int128 v40;
  void *v41[2];
  char v42;
  std::string v43;
  SERestoreInfo::SERestoreInfoBase *v44;
  void *v45[2];
  char v46;
  void *__p[2];
  char v48;
  void *v49;
  char v50;
  CFErrorRef v51;
  std::string v52;

  v4 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  sub_1000CB3F4(&v52, "HelsinkiRestore-56.0.32");
  if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v5 = &v52;
  else
    v5 = (std::string *)v52.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v4, 2, "SEUpdaterGetTags", "Project version%s: %s", " beta", (const char *)v5);
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v52.__r_.__value_.__l.__data_);
  Value = (SERestoreInfo::SERestoreInfoLog *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  v7 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(Value);
  sub_1000E9060(Value, &v52);
  if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v8 = &v52;
  else
    v8 = (std::string *)v52.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v7, 2, "SEUpdaterGetTags", "[in] %s %s", "kSEOptionDeviceInfo", (const char *)v8);
  if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
  {
    operator delete(v52.__r_.__value_.__l.__data_);
    if (!Value)
      goto LABEL_27;
  }
  else if (!Value)
  {
    goto LABEL_27;
  }
  v9 = CFGetTypeID(Value);
  if (v9 == CFDataGetTypeID())
  {
    BytePtr = CFDataGetBytePtr(Value);
    Length = CFDataGetLength(Value);
    Mutable = CFStringCreateMutable(0, 2 * Length);
    if (Length >= 1)
    {
      v13 = 0;
      v14 = 1;
      do
      {
        CFStringAppendFormat(Mutable, 0, CFSTR("%02x"), BytePtr[v13]);
        v13 = v14;
      }
      while (Length > v14++);
    }
    CStringPtr = CFStringGetCStringPtr(Mutable, 0x8000100u);
    if (CStringPtr)
      v17 = (char *)CStringPtr;
    else
      v17 = "null value";
    v18 = (SERestoreInfo::SERestoreInfoLog *)sub_1000CB3F4(&v52, v17);
    if (Mutable)
      CFRelease(Mutable);
    v19 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v18);
    v20 = &v52;
    if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
      v20 = (std::string *)v52.__r_.__value_.__r.__words[0];
    SERestoreInfo::SERestoreInfoLog::printLog(v19, 2, "SEUpdaterGetTags", "[in] %s 0x%s", "SEManifest", (const char *)v20);
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v52.__r_.__value_.__l.__data_);
  }
LABEL_27:
  v51 = 0;
  v21 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v21)
  {
    v36 = (const UInt8 *)sub_1000CB3F4(&v49, "Cannot allocate memory for outputDict");
    CFError = SERestoreInfo::CreateCFError(v36, 3, 0, CFSTR("SEUpdaterErrorDomain"));
    v51 = CFError;
    if (v50 < 0)
    {
      v37 = v49;
LABEL_71:
      operator delete(v37);
    }
LABEL_72:
    v23 = 0;
LABEL_75:
    v26 = 0;
LABEL_42:
    v31 = v51;
    if (a2 && v51)
    {
      CFError = (__CFError *)CFRetain(v51);
      *a2 = CFError;
      v31 = v51;
    }
    if (v21 && v31)
    {
      CFRelease(v21);
      v21 = 0;
      v31 = v51;
    }
    v32 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(CFError);
    if (v31)
    {
      sub_1000E9060(v51, &v52);
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v33 = &v52;
      else
        v33 = (std::string *)v52.__r_.__value_.__r.__words[0];
      SERestoreInfo::SERestoreInfoLog::printLog(v32, 0, "SEUpdaterGetTags", "%s", (const char *)v33);
    }
    else
    {
      sub_1000E9060(v21, &v52);
      if ((v52.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v34 = &v52;
      else
        v34 = (std::string *)v52.__r_.__value_.__r.__words[0];
      SERestoreInfo::SERestoreInfoLog::printLog(v32, 2, "SEUpdaterGetTags", "[out] %s", (const char *)v34);
    }
    if (SHIBYTE(v52.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v52.__r_.__value_.__l.__data_);
    if (v51)
    {
      CFRelease(v51);
      v51 = 0;
    }
    if (v26)
      CFRelease(v26);
    if (v23)
      CFRelease(v23);
    return v21;
  }
  v22 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v22)
  {
    sub_1000CB3F4(__p, "Cannot allocate memory for tagsInBI");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)__p, 3, 0, CFSTR("SEUpdaterErrorDomain"));
    v51 = CFError;
    if (v48 < 0)
    {
      v37 = __p[0];
      goto LABEL_71;
    }
    goto LABEL_72;
  }
  v23 = v22;
  if (!a1)
  {
    sub_1000CB3F4(v45, "options is nullptr");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)v45, 2, 0, CFSTR("SEUpdaterErrorDomain"));
    v51 = CFError;
    if (v46 < 0)
      operator delete(v45[0]);
    goto LABEL_75;
  }
  SERestoreInfo::makeSERestoreInfo(a1, &v44);
  if (v51)
  {
    v26 = 0;
    v29 = 4;
  }
  else
  {
    if (!v44)
    {
      exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1000CB3F4(&v43, "Assertion: ");
      v39 = std::string::append(&v43, "restoreInfo");
      v40 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
      v52.__r_.__value_.__r.__words[2] = v39->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v52.__r_.__value_.__l.__data_ = v40;
      v39->__r_.__value_.__l.__size_ = 0;
      v39->__r_.__value_.__r.__words[2] = 0;
      v39->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(exception, &v52);
    }
    (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v44 + 16))(&v52);
    v24 = v52.__r_.__value_.__r.__words[0];
    if (v52.__r_.__value_.__l.__size_ != v52.__r_.__value_.__r.__words[0])
    {
      v25 = 0;
      do
      {
        CFArrayAppendValue(v23, *(const void **)(v24 + 8 * v25++));
        v24 = v52.__r_.__value_.__r.__words[0];
      }
      while (v25 < (uint64_t)(v52.__r_.__value_.__l.__size_ - v52.__r_.__value_.__r.__words[0]) >> 3);
    }
    CFDictionaryAddValue(v21, CFSTR("BuildIdentityTags"), v23);
    v26 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v26)
    {
      ChipID = (SERestoreInfo::SERestoreInfoBase *)SERestoreInfo::SERestoreInfoBase::getChipID(v44);
      TSSResponseTicketTag = SERestoreInfo::SERestoreInfoBase::getTSSResponseTicketTag(ChipID);
      CFArrayAppendValue(v26, TSSResponseTicketTag);
      CFDictionaryAddValue(v21, CFSTR("ResponseTags"), v26);
      v29 = 0;
    }
    else
    {
      sub_1000CB3F4(v41, "Cannot allocate memory for tagsInTssResponse");
      v51 = SERestoreInfo::CreateCFError((const UInt8 *)v41, 3, 0, CFSTR("SEUpdaterErrorDomain"));
      if (v42 < 0)
        operator delete(v41[0]);
      v29 = 4;
    }
    if (v52.__r_.__value_.__r.__words[0])
    {
      v52.__r_.__value_.__l.__size_ = v52.__r_.__value_.__r.__words[0];
      operator delete(v52.__r_.__value_.__l.__data_);
    }
  }
  CFError = v44;
  v44 = 0;
  if (CFError)
    CFError = (__CFError *)(*(uint64_t (**)(__CFError *))(*(_QWORD *)CFError + 8))(CFError);
  if ((v29 | 4) == 4)
    goto LABEL_42;
  return v21;
}

void sub_1000E8E64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,void *a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,void *a30,uint64_t a31,int a32,__int16 a33,char a34,char a35,uint64_t a36,uint64_t a37,int a38,__int16 a39,char a40,char a41)
{
  uint64_t v41;
  void *v44;
  uint64_t v45;
  SERestoreInfo::SEException *v46;
  void *v47;
  char *v48;

  if (a22 < 0)
    operator delete(__p);
  v44 = *(void **)(v41 - 96);
  if (v44)
  {
    *(_QWORD *)(v41 - 88) = v44;
    operator delete(v44);
  }
  v45 = a29;
  a29 = 0;
  if (v45)
    (*(void (**)(uint64_t))(*(_QWORD *)v45 + 8))(v45);
  if (a2 == 2)
  {
    v46 = (SERestoreInfo::SEException *)__cxa_begin_catch(a1);
    *(_QWORD *)(v41 - 104) = SERestoreInfo::SEException::CreateCFError(v46);
  }
  else
  {
    if (a2 != 1)
      _Unwind_Resume(a1);
    v47 = __cxa_begin_catch(a1);
    v48 = (char *)(*(uint64_t (**)(void *))(*(_QWORD *)v47 + 16))(v47);
    sub_1000CB3F4(&a11, v48);
    *(_QWORD *)(v41 - 104) = SERestoreInfo::CreateCFError((const UInt8 *)&a11, 31, 0, CFSTR("SEUpdaterErrorDomain"));
    if (a16 < 0)
      operator delete(a11);
  }
  __cxa_end_catch();
  JUMPOUT(0x1000E8BACLL);
}

void sub_1000E9038(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  __cxa_end_catch();
  JUMPOUT(0x1000E8F04);
}

void sub_1000E9060(void *a1@<X0>, _QWORD *a2@<X8>)
{
  CFTypeID v4;
  const __CFString *v5;
  const __CFString *v6;
  const char *CStringPtr;
  char *v8;

  if (a1)
  {
    v4 = CFGetTypeID(a1);
    if (v4 == CFErrorGetTypeID())
      v5 = CFErrorCopyDescription((CFErrorRef)a1);
    else
      v5 = CFCopyDescription(a1);
    v6 = v5;
    CStringPtr = CFStringGetCStringPtr(v5, 0x8000100u);
    if (CStringPtr)
      v8 = (char *)CStringPtr;
    else
      v8 = "null description";
    sub_1000CB3F4(a2, v8);
    if (v6)
      CFRelease(v6);
  }
  else
  {
    sub_1000CB3F4(a2, "null value");
  }
}

void sub_1000E9104(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 + 23) < 0)
    operator delete(*(void **)v1);
  _Unwind_Resume(exception_object);
}

void *SEUpdaterCreateRequestLogSink(SERestoreInfo::SERestoreInfoLog *a1, void (*a2)(void *, const char *), void *a3, _QWORD *a4)
{
  SERestoreInfo::SERestoreInfoLog *v8;

  v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  SERestoreInfo::SERestoreInfoLog::registerLogSink(v8, a2, a3);
  return SEUpdaterCreateRequest(a1, a4);
}

void *SEUpdaterCreateRequest(SERestoreInfo::SERestoreInfoLog *a1, _QWORD *a2)
{
  SERestoreInfo::SERestoreInfoLog *v4;
  void *Value;
  std::string *v6;
  SERestoreInfo::SERestoreInfoLog *v7;
  SERestoreInfo::SERestoreInfoLog *v8;
  void *v9;
  std::string *v10;
  SERestoreInfo::SERestoreInfoLog *v11;
  SERestoreInfo::SERestoreInfoLog *v12;
  void *v13;
  std::string *v14;
  const __CFDictionary *v15;
  SERestoreInfo::SERestoreInfoLog *v16;
  SERestoreInfo::SERestoreInfoLog *v17;
  std::string *v18;
  const void *RequestDict;
  void *v20;
  void *CFError;
  void *v22;
  SERestoreInfo::SERestoreInfoLog *v23;
  std::string *v24;
  std::string *v25;
  void *v27;
  std::runtime_error *exception;
  std::string *v29;
  __int128 v30;
  std::string v31;
  SERestoreInfo::SERestoreInfoBase *v32;
  void *__p[2];
  char v34;
  UInt8 v35[23];
  char v36;
  void *v37;
  std::string v38;

  v4 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  Value = (void *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  sub_1000E9060(Value, &v38);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = &v38;
  else
    v6 = (std::string *)v38.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v4, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionDeviceInfo", (const char *)v6);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
  v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v7);
  v9 = (void *)CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
  sub_1000E9060(v9, &v38);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v10 = &v38;
  else
    v10 = (std::string *)v38.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v8, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionFirmwareData", (const char *)v10);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
  v12 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v11);
  v13 = (void *)CFDictionaryGetValue(a1, CFSTR("BuildIdentity"));
  sub_1000E9060(v13, &v38);
  if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &v38;
  else
    v14 = (std::string *)v38.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v12, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionBuildIdentity", (const char *)v14);
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
  v15 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("SharedInfo"));
  if (v15)
  {
    v16 = (SERestoreInfo::SERestoreInfoLog *)CFDictionaryGetValue(v15, CFSTR("Rose"));
    v17 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v16);
    sub_1000E9060(v16, &v38);
    v18 = (v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
        ? &v38
        : (std::string *)v38.__r_.__value_.__r.__words[0];
    SERestoreInfo::SERestoreInfoLog::printLog(v17, 2, "SEUpdaterCreateRequest", "[in] %s %s", "kSEOptionRoseInfo", (const char *)v18);
    if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v38.__r_.__value_.__l.__data_);
  }
  v37 = 0;
  if (!a1)
  {
    sub_1000CB3F4(v35, "options is nullptr");
    CFError = SERestoreInfo::CreateCFError(v35, 2, 0, CFSTR("SEUpdaterErrorDomain"));
    v37 = CFError;
    if (v36 < 0)
    {
      v27 = *(void **)v35;
LABEL_54:
      operator delete(v27);
    }
LABEL_55:
    v20 = 0;
    goto LABEL_32;
  }
  if (!CFDictionaryContainsKey(a1, CFSTR("FirmwareData")) && !CFDictionaryContainsKey(a1, CFSTR("BuildIdentity")))
  {
    sub_1000CB3F4(__p, "fwData and buildIdentity are nullptr");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)__p, 2, 0, CFSTR("SEUpdaterErrorDomain"));
    v37 = CFError;
    if (v34 < 0)
    {
      v27 = __p[0];
      goto LABEL_54;
    }
    goto LABEL_55;
  }
  SERestoreInfo::makeSERestoreInfo(a1, &v32);
  if (v37)
    goto LABEL_29;
  if (!v32)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v31, "Assertion: ");
    v29 = std::string::append(&v31, "restoreInfo");
    v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
    v38.__r_.__value_.__r.__words[2] = v29->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v38.__r_.__value_.__l.__data_ = v30;
    v29->__r_.__value_.__l.__size_ = 0;
    v29->__r_.__value_.__r.__words[2] = 0;
    v29->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v38);
  }
  RequestDict = (const void *)SERestoreInfo::SERestoreInfoBase::getRequestDict(v32);
  if (!RequestDict)
LABEL_29:
    v20 = 0;
  else
    v20 = (void *)CFRetain(RequestDict);
  CFError = v32;
  v32 = 0;
  if (CFError)
    CFError = (void *)(*(uint64_t (**)(void *))(*(_QWORD *)CFError + 8))(CFError);
LABEL_32:
  v22 = v37;
  if (a2 && v37)
  {
    CFError = (void *)CFRetain(v37);
    *a2 = CFError;
    v22 = v37;
  }
  v23 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get((SERestoreInfo::SERestoreInfoLog *)CFError);
  if (v22)
  {
    sub_1000E9060(v37, &v38);
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v24 = &v38;
    else
      v24 = (std::string *)v38.__r_.__value_.__r.__words[0];
    SERestoreInfo::SERestoreInfoLog::printLog(v23, 0, "SEUpdaterCreateRequest", "%s", (const char *)v24);
  }
  else
  {
    sub_1000E9060(v20, &v38);
    if ((v38.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v25 = &v38;
    else
      v25 = (std::string *)v38.__r_.__value_.__r.__words[0];
    SERestoreInfo::SERestoreInfoLog::printLog(v23, 2, "SEUpdaterCreateRequest", "[out] %s", (const char *)v25);
  }
  if (SHIBYTE(v38.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v38.__r_.__value_.__l.__data_);
  if (v37)
    CFRelease(v37);
  return v20;
}

void sub_1000E9710(int a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  __cxa_end_catch();
  JUMPOUT(0x1000E9600);
}

void *SEUpdaterCopyFirmwareLogSink(SERestoreInfo::SERestoreInfoLog *a1, void (*a2)(void *, const char *), void *a3, CFTypeRef *a4)
{
  SERestoreInfo::SERestoreInfoLog *v8;

  v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  SERestoreInfo::SERestoreInfoLog::registerLogSink(v8, a2, a3);
  return SEUpdaterCopyFirmware(a1, a4);
}

void *SEUpdaterCopyFirmware(SERestoreInfo::SERestoreInfoLog *a1, CFTypeRef *a2)
{
  SERestoreInfo::SERestoreInfoLog *v4;
  void *Value;
  std::string *v6;
  SERestoreInfo::SERestoreInfoLog *v7;
  SERestoreInfo::SERestoreInfoLog *v8;
  void *v9;
  std::string *v10;
  SERestoreInfo::SERestoreInfoLog *v11;
  SERestoreInfo::SERestoreInfoLog *v12;
  void *v13;
  std::string *v14;
  SERestoreInfo::SERestoreInfoLog *v15;
  SERestoreInfo::SERestoreInfoLog *v16;
  void *v17;
  std::string *v18;
  const void *v19;
  std::string::size_type v20;
  uint64_t v21;
  const __CFDictionary *v22;
  const void *v23;
  const void *v24;
  int v25;
  int v26;
  int v27;
  void *result;
  SERestoreInfo::SERestoreInfoLog *v29;
  BOOL v30;
  SERestoreInfo::SERestoreInfoLog *v31;
  std::string *v32;
  std::string *v33;
  void **v34;
  const UInt8 *v35;
  std::runtime_error *exception;
  std::string *v37;
  std::string *v38;
  __int128 v39;
  _QWORD v40[2];
  char v41;
  _QWORD v42[2];
  char v43;
  _QWORD v44[2];
  char v45;
  _QWORD v46[2];
  char v47;
  _QWORD v48[2];
  char v49;
  _QWORD v50[2];
  char v51;
  _QWORD v52[2];
  char v53;
  _QWORD v54[3];
  void *v55;
  void *v56;
  char v57;
  CFErrorRef CFError;
  void *v59;
  CFTypeRef v60;
  std::string v61;

  v4 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(a1);
  Value = (void *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  sub_1000E9060(Value, &v61);
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v6 = &v61;
  else
    v6 = (std::string *)v61.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v4, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionDeviceInfo", (const char *)v6);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  v8 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v7);
  v9 = (void *)CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
  sub_1000E9060(v9, &v61);
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v10 = &v61;
  else
    v10 = (std::string *)v61.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v8, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionFirmwareData", (const char *)v10);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  v12 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v11);
  v13 = (void *)CFDictionaryGetValue(a1, CFSTR("BuildIdentity"));
  sub_1000E9060(v13, &v61);
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v14 = &v61;
  else
    v14 = (std::string *)v61.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v12, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionBuildIdentity", (const char *)v14);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  v16 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v15);
  v17 = (void *)CFDictionaryGetValue(a1, CFSTR("BundlePath"));
  sub_1000E9060(v17, &v61);
  if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v18 = &v61;
  else
    v18 = (std::string *)v61.__r_.__value_.__r.__words[0];
  SERestoreInfo::SERestoreInfoLog::printLog(v16, 2, "SEUpdaterCopyFirmware", "[in] %s %s", "kSEOptionSourceBundlePath", (const char *)v18);
  if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v61.__r_.__value_.__l.__data_);
  v59 = 0;
  v60 = 0;
  CFError = 0;
  if (!a1)
  {
    v35 = (const UInt8 *)sub_1000CB3F4(&v56, "options is nullptr");
    CFError = SERestoreInfo::CreateCFError(v35, 2, 0, CFSTR("SEUpdaterErrorDomain"));
    if (v57 < 0)
      operator delete(v56);
    goto LABEL_41;
  }
  v19 = CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
  if (v19)
  {
    v59 = (void *)CFRetain(v19);
    if (v59)
    {
LABEL_41:
      v29 = CFError;
      if (a2 && CFError)
      {
        *a2 = CFRetain(CFError);
        v29 = CFError;
      }
      if (v29 && v59)
      {
        CFRelease(v59);
        v59 = 0;
        v29 = CFError;
      }
      v30 = v29 == 0;
      v31 = (SERestoreInfo::SERestoreInfoLog *)SERestoreInfo::SERestoreInfoLog::get(v29);
      if (v30)
      {
        sub_1000E9060(v59, &v61);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v33 = &v61;
        else
          v33 = (std::string *)v61.__r_.__value_.__r.__words[0];
        SERestoreInfo::SERestoreInfoLog::printLog(v31, 2, "SEUpdaterCopyFirmware", "[out] %s", (const char *)v33);
      }
      else
      {
        sub_1000E9060(CFError, &v61);
        if ((v61.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v32 = &v61;
        else
          v32 = (std::string *)v61.__r_.__value_.__r.__words[0];
        SERestoreInfo::SERestoreInfoLog::printLog(v31, 0, "SEUpdaterCopyFirmware", "%s", (const char *)v32);
      }
      if (SHIBYTE(v61.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v61.__r_.__value_.__l.__data_);
      if (v60)
      {
        CFRelease(v60);
        v60 = 0;
      }
      if (CFError)
        CFRelease(CFError);
      return v59;
    }
  }
  else
  {
    v59 = 0;
  }
  SERestoreInfo::makeSERestoreInfo(a1, &v55);
  if (CFError)
    goto LABEL_68;
  if (!v55)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    v37 = (std::string *)sub_1000CB3F4(v54, "Assertion: ");
    v38 = std::string::append(v37, "restoreInfo");
    v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
    v61.__r_.__value_.__r.__words[2] = v38->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v61.__r_.__value_.__l.__data_ = v39;
    v38->__r_.__value_.__l.__size_ = 0;
    v38->__r_.__value_.__r.__words[2] = 0;
    v38->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v61);
  }
  (*(void (**)(std::string *__return_ptr))(*(_QWORD *)v55 + 24))(&v61);
  v20 = *(_QWORD *)v61.__r_.__value_.__l.__data_;
  v61.__r_.__value_.__l.__size_ = v61.__r_.__value_.__r.__words[0];
  operator delete(v61.__r_.__value_.__l.__data_);
  v21 = 0;
  v61.__r_.__value_.__r.__words[0] = (std::string::size_type)CFSTR("BuildIdentity");
  v61.__r_.__value_.__l.__size_ = v20;
  v61.__r_.__value_.__r.__words[2] = (std::string::size_type)CFSTR("Info");
  v22 = a1;
  do
  {
    v22 = (const __CFDictionary *)CFDictionaryGetValue(v22, *(const void **)((char *)&v61.__r_.__value_.__l.__data_ + v21));
    if (!v22)
    {
      sub_1000CB3F4(v52, "Missing dict along the path");
      CFError = SERestoreInfo::CreateCFError((const UInt8 *)v52, 16, 0, CFSTR("SEUpdaterErrorDomain"));
      if ((v53 & 0x80000000) == 0)
        goto LABEL_68;
      v34 = (void **)v52;
      goto LABEL_67;
    }
    v21 += 8;
  }
  while (v21 != 24);
  v23 = CFDictionaryGetValue(v22, CFSTR("Path"));
  if (!v23)
  {
    sub_1000CB3F4(v50, "Missing string for path key");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)v50, 16, 0, CFSTR("SEUpdaterErrorDomain"));
    if ((v51 & 0x80000000) == 0)
      goto LABEL_68;
    v34 = (void **)v50;
LABEL_67:
    operator delete(*v34);
    goto LABEL_68;
  }
  v24 = CFDictionaryGetValue(a1, CFSTR("BundlePath"));
  if (!v24)
  {
    sub_1000CB3F4(v48, "Missing kSEOptionSourceBundlePath");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)v48, 16, 0, CFSTR("SEUpdaterErrorDomain"));
    if ((v49 & 0x80000000) == 0)
      goto LABEL_68;
    v34 = (void **)v48;
    goto LABEL_67;
  }
  v25 = AMSupportPlatformCopyURLWithAppendedComponent(0, v24, v23, 0, &v60);
  if (v25)
  {
    sub_1000CB3F4(v46, "Fail to run AMSupportPlatformCopyURLWithAppendedComponent");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)v46, v25, 0, CFSTR("libAmSupportErrorDomain"));
    if ((v47 & 0x80000000) == 0)
      goto LABEL_68;
    v34 = (void **)v46;
    goto LABEL_67;
  }
  if (!v60)
  {
    sub_1000CB3F4(v44, "Fail to do AMSupportPlatformCopyURLWithAppendedComponent");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)v44, 3, 0, CFSTR("SEUpdaterErrorDomain"));
    if ((v45 & 0x80000000) == 0)
      goto LABEL_68;
    v34 = (void **)v44;
    goto LABEL_67;
  }
  v26 = AMSupportCreateDataFromFileURL(0, &v59);
  if (v26)
  {
    sub_1000CB3F4(v42, "Fail to run AMSupportCreateDataFromFileURL");
    CFError = SERestoreInfo::CreateCFError((const UInt8 *)v42, v26, 0, CFSTR("libAmSupportErrorDomain"));
    if ((v43 & 0x80000000) == 0)
      goto LABEL_68;
    v34 = (void **)v42;
    goto LABEL_67;
  }
  if (v59)
  {
    v27 = 0;
    goto LABEL_38;
  }
  sub_1000CB3F4(v40, "fileData is nullptr");
  CFError = SERestoreInfo::CreateCFError((const UInt8 *)v40, 3, 0, CFSTR("SEUpdaterErrorDomain"));
  if (v41 < 0)
  {
    v34 = (void **)v40;
    goto LABEL_67;
  }
LABEL_68:
  v27 = 4;
LABEL_38:
  result = v55;
  v55 = 0;
  if (result)
    result = (void *)(*(uint64_t (**)(void *))(*(_QWORD *)result + 8))(result);
  if ((v27 | 4) == 4)
    goto LABEL_41;
  return result;
}

void sub_1000E9E50(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, void *__p, uint64_t a18, int a19, __int16 a20,char a21,char a22,uint64_t a23,uint64_t a24,int a25,__int16 a26,char a27,char a28,uint64_t a29,uint64_t a30,int a31,__int16 a32,char a33,char a34,uint64_t a35,uint64_t a36,int a37,__int16 a38,char a39,char a40,uint64_t a41,uint64_t a42,int a43,__int16 a44,char a45,char a46,uint64_t a47,uint64_t a48,int a49,__int16 a50,char a51,char a52,uint64_t a53,uint64_t a54,int a55,__int16 a56,char a57,char a58)
{
  uint64_t v58;
  uint64_t v61;
  SERestoreInfo::SEException *v62;
  void *v63;
  char *v64;

  if (a22 < 0)
    operator delete(__p);
  v61 = *(_QWORD *)(v58 - 152);
  *(_QWORD *)(v58 - 152) = 0;
  if (v61)
    (*(void (**)(uint64_t))(*(_QWORD *)v61 + 8))(v61);
  if (a2 == 2)
  {
    v62 = (SERestoreInfo::SEException *)__cxa_begin_catch(exception_object);
    *(_QWORD *)(v58 - 120) = SERestoreInfo::SEException::CreateCFError(v62);
    __cxa_end_catch();
  }
  else
  {
    if (a2 != 1)
      _Unwind_Resume(exception_object);
    v63 = __cxa_begin_catch(exception_object);
    v64 = (char *)(*(uint64_t (**)(void *))(*(_QWORD *)v63 + 16))(v63);
    sub_1000CB3F4(&a11, v64);
    *(_QWORD *)(v58 - 120) = SERestoreInfo::CreateCFError((const UInt8 *)&a11, 31, 0, CFSTR("SEUpdaterErrorDomain"));
    if (a16 < 0)
      operator delete(a11);
    __cxa_end_catch();
  }
  JUMPOUT(0x1000E9A9CLL);
}

_QWORD *SERestoreInfo::SERestoreInfoBase::SERestoreInfoBase(_QWORD *a1, CFTypeRef cf, _QWORD *a3)
{
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  CFMutableDictionaryRef Mutable;
  void *exception;
  void *v10;
  _QWORD v11[3];

  *a1 = off_100183748;
  a1[2] = *a3;
  v4 = a3[1];
  a1[3] = v4;
  if (v4)
  {
    v5 = (unint64_t *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[1] = CFRetain(cf);
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  a1[4] = Mutable;
  if (!Mutable)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(v11, "Cannot allocate request dict");
    v10 = (void *)SERestoreInfo::SEException::SEException(exception, v11, 3, CFSTR("SEUpdaterErrorDomain"));
  }
  return a1;
}

void sub_1000EA184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  uint64_t v15;

  if (a15 < 0)
    operator delete(__p);
  sub_1000CB5E0(v15);
  _Unwind_Resume(a1);
}

void SERestoreInfo::SERestoreInfoBase::~SERestoreInfoBase(SERestoreInfo::SERestoreInfoBase *this)
{
  const void *v2;
  const void *v3;

  *(_QWORD *)this = off_100183748;
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
  {
    CFRelease(v2);
    *((_QWORD *)this + 1) = 0;
  }
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
  {
    CFRelease(v3);
    *((_QWORD *)this + 4) = 0;
  }
  sub_1000CB5E0((uint64_t)this + 16);
}

uint64_t SERestoreInfo::SERestoreInfoBase::getChipID(SERestoreInfo::SERestoreInfoBase *this)
{
  uint64_t v1;
  std::runtime_error *exception;
  std::string *v4;
  __int128 v5;
  std::string v6;
  std::string v7;

  v1 = *((_QWORD *)this + 2);
  if (!v1)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v6, "Assertion: ");
    v4 = std::string::append(&v6, "fDeviceInfo");
    v5 = *(_OWORD *)&v4->__r_.__value_.__l.__data_;
    v7.__r_.__value_.__r.__words[2] = v4->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v7.__r_.__value_.__l.__data_ = v5;
    v4->__r_.__value_.__l.__size_ = 0;
    v4->__r_.__value_.__r.__words[2] = 0;
    v4->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v7);
  }
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)v1 + 32))(v1);
}

void sub_1000EA2CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  int v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
  {
    operator delete(a10);
    if ((v22 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v22)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v21);
  goto LABEL_8;
}

__CFString *SERestoreInfo::SERestoreInfoBase::getTSSResponseTicketTag(SERestoreInfo::SERestoreInfoBase *this)
{
  __CFString **v1;

  v1 = kSETagResponseTicket;
  if ((int)this <= 199)
  {
    if ((_DWORD)this != 100 && (_DWORD)this != 115)
      goto LABEL_8;
  }
  else if ((_DWORD)this != 200 && (_DWORD)this != 210 && (_DWORD)this != 131601)
  {
LABEL_8:
    v1 = kSETagResponseTicketEC384;
  }
  return *v1;
}

uint64_t SERestoreInfo::SERestoreInfoBase::getRequestDict(SERestoreInfo::SERestoreInfoBase *this)
{
  __CFDictionary *v2;
  int v3;
  __CFString **v4;
  int v6;
  const __CFDictionary *v7;
  SERestoreInfo *Value;
  const __CFData *v9;
  SERestoreInfo::SEFirmwareBase *v10;
  uint64_t v11;
  std::__shared_weak_count *v12;
  unint64_t *p_shared_owners;
  unint64_t v14;
  std::__shared_weak_count *v15;
  unint64_t *v16;
  unint64_t v17;
  SERestoreInfo::SEFirmwareBase *v18;
  const __CFDictionary *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  const __CFDictionary *v23;
  const __CFDictionary *v24;
  CFTypeID TypeID;
  const __CFDictionary *v26;
  const __CFDictionary *v27;
  const void *v28;
  const void *v29;
  __CFDictionary *Mutable;
  const void *v31;
  const void *v32;
  __CFDictionary *v33;
  void *exception;
  void *v36;
  SERestoreInfo::SEFirmwareBase *context;
  void *__p[4];
  uint64_t v39;
  std::__shared_weak_count *v40;

  v2 = (__CFDictionary *)*((_QWORD *)this + 4);
  v3 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 32))(*((_QWORD *)this + 2));
  v4 = kSETagRequestTicket;
  if (v3 <= 199)
  {
    if (v3 != 100 && v3 != 115)
LABEL_10:
      v4 = kSETagRequestTicketEC384;
  }
  else if (v3 != 200 && v3 != 210 && v3 != 131601)
  {
    goto LABEL_10;
  }
  CFDictionaryAddValue(v2, *v4, kCFBooleanTrue);
  (*(void (**)(_QWORD, _QWORD, uint64_t))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2), *((_QWORD *)this + 4), 1);
  v6 = CFDictionaryContainsKey(*((CFDictionaryRef *)this + 1), CFSTR("FirmwareData"));
  v7 = (const __CFDictionary *)*((_QWORD *)this + 1);
  if (v6)
  {
    Value = (SERestoreInfo *)CFDictionaryGetValue(v7, CFSTR("FirmwareData"));
    SERestoreInfo::makeSEFirmware(Value, v9, &context);
    v10 = context;
    v12 = (std::__shared_weak_count *)*((_QWORD *)this + 3);
    v11 = *((_QWORD *)this + 4);
    v39 = *((_QWORD *)this + 2);
    v40 = v12;
    if (v12)
    {
      p_shared_owners = (unint64_t *)&v12->__shared_owners_;
      do
        v14 = __ldxr(p_shared_owners);
      while (__stxr(v14 + 1, p_shared_owners));
    }
    (*(void (**)(SERestoreInfo::SEFirmwareBase *, uint64_t, uint64_t *))(*(_QWORD *)v10 + 16))(v10, v11, &v39);
    v15 = v40;
    if (v40)
    {
      v16 = (unint64_t *)&v40->__shared_owners_;
      do
        v17 = __ldaxr(v16);
      while (__stlxr(v17 - 1, v16));
      if (!v17)
      {
        ((void (*)(std::__shared_weak_count *))v15->__on_zero_shared)(v15);
        std::__shared_weak_count::__release_weak(v15);
      }
    }
    v18 = context;
    context = 0;
    if (v18)
      (*(void (**)(SERestoreInfo::SEFirmwareBase *))(*(_QWORD *)v18 + 8))(v18);
  }
  else
  {
    if (!CFDictionaryContainsKey(v7, CFSTR("BuildIdentity")))
    {
      exception = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&context, "missing build identity");
      v36 = (void *)SERestoreInfo::SEException::SEException(exception, &context, 2, CFSTR("SEUpdaterErrorDomain"));
    }
    v19 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), CFSTR("BuildIdentity"));
    context = (SERestoreInfo::SEFirmwareBase *)*((_QWORD *)this + 4);
    (*(void (**)(void **__return_ptr, SERestoreInfo::SERestoreInfoBase *))(*(_QWORD *)this + 24))(__p, this);
    __p[3] = (void *)(*(uint64_t (**)(SERestoreInfo::SERestoreInfoBase *))(*(_QWORD *)this + 32))(this);
    CFDictionaryApplyFunction(v19, (CFDictionaryApplierFunction)sub_1000EA7F0, &context);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
  }
  v20 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), CFSTR("SEAC"));
  if (v20)
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), CFSTR("SEAC"), v20);
  v21 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), CFSTR("SERS"));
  if (v21)
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), CFSTR("SERS"), v21);
  v22 = CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), CFSTR("SESA"));
  if (v22)
    CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), CFSTR("SESA"), v22);
  v23 = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)this + 1), CFSTR("SharedInfo"));
  if (v23)
  {
    v24 = v23;
    TypeID = CFDictionaryGetTypeID();
    if (TypeID == CFGetTypeID(v24))
    {
      v26 = (const __CFDictionary *)CFDictionaryGetValue(v24, CFSTR("Rose"));
      if (v26)
      {
        v27 = v26;
        v28 = CFDictionaryGetValue(v26, CFSTR("SE,RapRTKitOS"));
        if (v28)
        {
          v29 = v28;
          Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(Mutable, CFSTR("Digest"), v29);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), CFSTR("SE,RapRTKitOS"), Mutable);
          if (Mutable)
            CFRelease(Mutable);
        }
        v31 = CFDictionaryGetValue(v27, CFSTR("SE,RapSwBinDsp"));
        if (v31)
        {
          v32 = v31;
          v33 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(v33, CFSTR("Digest"), v32);
          CFDictionaryAddValue(*((CFMutableDictionaryRef *)this + 4), CFSTR("SE,RapSwBinDsp"), v33);
          if (v33)
            CFRelease(v33);
        }
      }
    }
  }
  return *((_QWORD *)this + 4);
}

void sub_1000EA784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1000EA7F0(const __CFString *a1, const void *a2, uint64_t a3)
{
  CFTypeID v6;
  CFTypeID v7;
  CFStringRef *v8;
  unint64_t v9;
  CFComparisonResult v10;
  __CFDictionary *Mutable;
  CFTypeRef v13;
  const void *Value;
  std::runtime_error *exception;
  std::string *v16;
  __int128 v17;
  std::string v18;
  std::string __p;

  if (!a3)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v18, "Assertion: ");
    v16 = std::string::append(&v18, "p");
    v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
    __p.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
    *(_OWORD *)&__p.__r_.__value_.__l.__data_ = v17;
    v16->__r_.__value_.__l.__size_ = 0;
    v16->__r_.__value_.__r.__words[2] = 0;
    v16->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &__p);
  }
  v6 = CFGetTypeID(a1);
  if (v6 == CFStringGetTypeID())
  {
    v7 = CFGetTypeID(a2);
    if (v7 == CFDictionaryGetTypeID())
    {
      memset(&__p, 0, sizeof(__p));
      sub_1000DC6EC(&__p, *(const void **)(a3 + 8), *(_QWORD *)(a3 + 16), (uint64_t)(*(_QWORD *)(a3 + 16) - *(_QWORD *)(a3 + 8)) >> 3);
      v8 = (CFStringRef *)__p.__r_.__value_.__r.__words[0];
      if (__p.__r_.__value_.__l.__size_ == __p.__r_.__value_.__r.__words[0])
      {
        Mutable = 0;
        v13 = 0;
        if (!__p.__r_.__value_.__r.__words[0])
          goto LABEL_22;
        goto LABEL_21;
      }
      v9 = 0;
      do
      {
        v10 = CFStringCompare(v8[v9++], a1, 0);
        v8 = (CFStringRef *)__p.__r_.__value_.__r.__words[0];
      }
      while (v9 < (uint64_t)(__p.__r_.__value_.__l.__size_ - __p.__r_.__value_.__r.__words[0]) >> 3
           && v10 != kCFCompareEqualTo);
      if (v10)
      {
        Mutable = 0;
      }
      else
      {
        Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (Mutable)
        {
          Value = CFDictionaryGetValue((CFDictionaryRef)a2, *(const void **)(a3 + 32));
          if (Value)
          {
            v13 = CFRetain(Value);
            if (v13)
            {
              CFDictionaryAddValue(Mutable, *(const void **)(a3 + 32), v13);
              CFDictionarySetValue(*(CFMutableDictionaryRef *)a3, a1, Mutable);
            }
LABEL_20:
            v8 = (CFStringRef *)__p.__r_.__value_.__r.__words[0];
            if (!__p.__r_.__value_.__r.__words[0])
            {
LABEL_22:
              if (v13)
                CFRelease(v13);
              if (Mutable)
                CFRelease(Mutable);
              return;
            }
LABEL_21:
            __p.__r_.__value_.__l.__size_ = (std::string::size_type)v8;
            operator delete(v8);
            goto LABEL_22;
          }
        }
      }
      v13 = 0;
      goto LABEL_20;
    }
  }
}

void sub_1000EA9C8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

SERestoreInfo::SEFirmwareBase *SERestoreInfo::makeSEFirmware@<X0>(SERestoreInfo *this@<X0>, const __CFData *a2@<X1>, SERestoreInfo::SEFirmwareBase **a3@<X8>)
{
  unsigned int FormatVer;
  unsigned int v6;
  SERestoreInfo::SEFirmwareBase *v7;
  SERestoreInfo::SEFirmwareBase *result;
  uint64_t *v9;
  void *exception;
  std::string *v11;
  __int128 v12;
  void *v13;
  std::string v14;
  __int128 v15;
  std::string::size_type v16;

  FormatVer = SERestoreInfo::SEFirmwareBase::getFormatVer(this, a2);
  if (FormatVer == 1)
  {
    v7 = (SERestoreInfo::SEFirmwareBase *)operator new(0x28uLL);
    result = SERestoreInfo::SEFirmwareBase::SEFirmwareBase(v7, this);
  }
  else
  {
    v6 = FormatVer;
    if (FormatVer)
    {
      exception = __cxa_allocate_exception(0x48uLL);
      std::to_string(&v14, v6);
      v11 = std::string::insert(&v14, 0, "Unsupported firmware version: ");
      v12 = *(_OWORD *)&v11->__r_.__value_.__l.__data_;
      v16 = v11->__r_.__value_.__r.__words[2];
      v15 = v12;
      v11->__r_.__value_.__l.__size_ = 0;
      v11->__r_.__value_.__r.__words[2] = 0;
      v11->__r_.__value_.__r.__words[0] = 0;
      v13 = (void *)SERestoreInfo::SEException::SEException(exception, &v15, 15, CFSTR("SEUpdaterErrorDomain"));
    }
    v7 = (SERestoreInfo::SEFirmwareBase *)operator new(0x28uLL);
    result = SERestoreInfo::SEFirmwareBase::SEFirmwareBase(v7, this);
  }
  *(_QWORD *)v7 = v9 + 2;
  *a3 = v7;
  return result;
}

void sub_1000EAB48(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

void SERestoreInfo::makeSERestoreInfo(SERestoreInfo *this@<X0>, _QWORD *a2@<X8>)
{
  BOOL v6;
  CFTypeID v7;
  std::string::size_type v8;
  std::string::size_type size;
  CFTypeID v10;
  int v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t *v14;
  unint64_t v15;
  std::__shared_weak_count *v16;
  unint64_t *p_shared_owners;
  unint64_t v18;
  std::__shared_weak_count *v19;
  unint64_t *v20;
  unint64_t v21;
  std::runtime_error *v22;
  std::string *v23;
  __int128 v24;
  _QWORD *v25;
  _QWORD *v26;
  unint64_t *v27;
  unint64_t v28;
  unint64_t *v29;
  std::runtime_error *exception;
  std::string *v31;
  __int128 v32;
  std::runtime_error *v33;
  std::string *v34;
  __int128 v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  std::string::size_type v40;
  std::__shared_weak_count *v41;
  std::string::size_type v42;
  std::__shared_weak_count *v43;
  std::string v44;
  CFDataRef theData;
  unsigned __int128 v46;
  std::string v47;
  void *value;

  value = 0;
  if (!this)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v47, "Assertion: ");
    v31 = std::string::append(&v47, "options");
    v32 = *(_OWORD *)&v31->__r_.__value_.__l.__data_;
    v44.__r_.__value_.__r.__words[2] = v31->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v32;
    v31->__r_.__value_.__l.__size_ = 0;
    v31->__r_.__value_.__r.__words[2] = 0;
    v31->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v44);
  }
  *a2 = 0;
  if (CFDictionaryGetValueIfPresent(this, CFSTR("DeviceInfo"), (const void **)&value))
    v6 = value == 0;
  else
    v6 = 1;
  if (v6)
  {
    v36 = __cxa_allocate_exception(0x48uLL);
    sub_1000CB3F4(&v44, "Cannot find key kSEOptionDeviceInfo in options");
    v37 = (void *)SERestoreInfo::SEException::SEException(v36, &v44, 2, CFSTR("SEUpdaterErrorDomain"));
  }
  v46 = 0uLL;
  v7 = CFGetTypeID(value);
  if (v7 == CFDataGetTypeID())
  {
    v44.__r_.__value_.__r.__words[0] = (std::string::size_type)off_100183340;
    theData = (CFDataRef)CFRetain(value);
    v44.__r_.__value_.__l.__size_ = (std::string::size_type)CFDataGetBytePtr(theData);
    v44.__r_.__value_.__r.__words[2] = CFDataGetLength(theData);
    sub_1000EB190(&v47);
    size = v47.__r_.__value_.__l.__size_;
    v8 = v47.__r_.__value_.__r.__words[0];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = 0uLL;
    v46 = __PAIR128__(size, v8);
    sub_1000E42C4(&v44);
  }
  else
  {
    v10 = CFGetTypeID(value);
    if (v10 != CFDictionaryGetTypeID())
    {
      v38 = __cxa_allocate_exception(0x48uLL);
      sub_1000CB3F4(&v44, "kSEOptionDeviceInfo is neither CFData or CFDictionary");
      v39 = (void *)SERestoreInfo::SEException::SEException(v38, &v44, 16, CFSTR("SEUpdaterErrorDomain"));
    }
    v47.__r_.__value_.__r.__words[0] = (std::string::size_type)value;
    sub_1000EB430((const __CFDictionary *const *)&v47, &v44);
    size = v44.__r_.__value_.__l.__size_;
    v8 = v44.__r_.__value_.__r.__words[0];
    v46 = *(_OWORD *)&v44.__r_.__value_.__l.__data_;
  }
  if (!v8)
  {
    v33 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v47, "Assertion: ");
    v34 = std::string::append(&v47, "deviceInfo");
    v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
    v44.__r_.__value_.__r.__words[2] = v34->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v35;
    v34->__r_.__value_.__l.__size_ = 0;
    v34->__r_.__value_.__r.__words[2] = 0;
    v34->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v33, &v44);
  }
  v11 = (*(uint64_t (**)(std::string::size_type))(*(_QWORD *)v8 + 32))(v8);
  if (v11 <= 199)
  {
    if (((v11 - 54) > 0x3D || ((1 << (v11 - 54)) & 0x2000400000000003) == 0)
      && v11 != 44)
    {
LABEL_33:
      v22 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
      sub_1000CB3F4(&v47, "Assertion: ");
      v23 = std::string::append(&v47, "false");
      v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
      v44.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v44.__r_.__value_.__l.__data_ = v24;
      v23->__r_.__value_.__l.__size_ = 0;
      v23->__r_.__value_.__r.__words[2] = 0;
      v23->__r_.__value_.__r.__words[0] = 0;
      std::runtime_error::runtime_error(v22, &v44);
    }
LABEL_14:
    v12 = operator new(0x28uLL);
    v13 = v12;
    v42 = v8;
    v43 = (std::__shared_weak_count *)size;
    if (size)
    {
      v14 = (unint64_t *)(size + 8);
      do
        v15 = __ldxr(v14);
      while (__stxr(v15 + 1, v14));
    }
    sub_1000EB6D0(v12, this, (uint64_t *)&v42);
    *a2 = v13;
    v16 = v43;
    if (v43)
    {
      p_shared_owners = (unint64_t *)&v43->__shared_owners_;
      do
        v18 = __ldaxr(p_shared_owners);
      while (__stlxr(v18 - 1, p_shared_owners));
      goto LABEL_20;
    }
    goto LABEL_22;
  }
  if (v11 == 200)
    goto LABEL_14;
  if (v11 != 131601)
  {
    if (v11 != 210)
      goto LABEL_33;
    goto LABEL_14;
  }
  v25 = operator new(0x28uLL);
  v26 = v25;
  v40 = v8;
  v41 = (std::__shared_weak_count *)size;
  if (size)
  {
    v27 = (unint64_t *)(size + 8);
    do
      v28 = __ldxr(v27);
    while (__stxr(v28 + 1, v27));
  }
  sub_1000EB780(v25, this, (uint64_t *)&v40);
  *a2 = v26;
  v16 = v41;
  if (v41)
  {
    v29 = (unint64_t *)&v41->__shared_owners_;
    do
      v18 = __ldaxr(v29);
    while (__stlxr(v18 - 1, v29));
LABEL_20:
    if (!v18)
    {
      ((void (*)(std::__shared_weak_count *))v16->__on_zero_shared)(v16);
      std::__shared_weak_count::__release_weak(v16);
    }
  }
LABEL_22:
  v19 = (std::__shared_weak_count *)*((_QWORD *)&v46 + 1);
  if (*((_QWORD *)&v46 + 1))
  {
    v20 = (unint64_t *)(*((_QWORD *)&v46 + 1) + 8);
    do
      v21 = __ldaxr(v20);
    while (__stlxr(v21 - 1, v20));
    if (!v21)
    {
      ((void (*)(std::__shared_weak_count *))v19->__on_zero_shared)(v19);
      std::__shared_weak_count::__release_weak(v19);
    }
  }
}

void sub_1000EB02C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, char a20,uint64_t a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27)
{
  _QWORD *v27;
  void *v28;
  int v29;

  if (a18 < 0)
    operator delete(__p);
  if (a27 < 0)
  {
    operator delete(a22);
    if ((v29 & 1) == 0)
    {
LABEL_8:
      sub_1000CB5E0((uint64_t)&a20);
      *v27 = 0;
      _Unwind_Resume(a1);
    }
  }
  else if (!v29)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v28);
  goto LABEL_8;
}

double sub_1000EB190@<D0>(_OWORD *a1@<X8>)
{
  double result;
  double v3[3];

  sub_1000EB830(v3);
  result = v3[0];
  *a1 = *(_OWORD *)v3;
  return result;
}

void sub_1000EB1D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 __p, int a10, __int16 a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18, char a19, char a20,char a21)
{
  _OWORD *v21;

  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    sub_1000EB91C(&__p);
    *v21 = __p;
    __p = 0uLL;
    sub_1000CB5E0((uint64_t)&__p);
    JUMPOUT(0x1000EB1C4);
  }
  _Unwind_Resume(exception_object);
}

double sub_1000EB430@<D0>(const __CFDictionary *const *a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  double v4[3];

  sub_1000EBF90(a1, v4);
  result = v4[0];
  *a2 = *(_OWORD *)v4;
  return result;
}

void sub_1000EB478(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 __p, int a10, __int16 a11, char a12, char a13, char a14, char a15, char a16, char a17, char a18, char a19, char a20,char a21)
{
  _OWORD *v21;
  const __CFDictionary *const *v22;

  if (a2 == 1)
  {
    __cxa_begin_catch(exception_object);
    __cxa_end_catch();
    sub_1000EC034(v22, &__p);
    *v21 = __p;
    __p = 0uLL;
    sub_1000CB5E0((uint64_t)&__p);
    JUMPOUT(0x1000EB464);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *sub_1000EB6D0(_QWORD *a1, const void *a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v4 = (std::__shared_weak_count *)a3[1];
  v11 = *a3;
  v12 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  SERestoreInfo::SERestoreInfoBase::SERestoreInfoBase(a1, a2, &v11);
  v7 = v12;
  if (v12)
  {
    v8 = (unint64_t *)&v12->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  *a1 = &off_100183410;
  return a1;
}

void sub_1000EB76C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000CB5E0((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EB780(_QWORD *a1, const void *a2, uint64_t *a3)
{
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v11;
  std::__shared_weak_count *v12;

  v4 = (std::__shared_weak_count *)a3[1];
  v11 = *a3;
  v12 = v4;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldxr(p_shared_owners);
    while (__stxr(v6 + 1, p_shared_owners));
  }
  SERestoreInfo::SERestoreInfoBase::SERestoreInfoBase(a1, a2, &v11);
  v7 = v12;
  if (v12)
  {
    v8 = (unint64_t *)&v12->__shared_owners_;
    do
      v9 = __ldaxr(v8);
    while (__stlxr(v9 - 1, v8));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  *a1 = &off_1001833C0;
  return a1;
}

void sub_1000EB81C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  sub_1000CB5E0((uint64_t)&a9);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EB830@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xB8uLL);
  result = sub_1000EB888(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EB874(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EB888(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_100183790;
  a1[1] = 0;
  SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EB8C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EB8D4(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100183790;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EB8E8(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100183790;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EB90C(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EB91C@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = sub_1000EB974(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EB960(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EB974(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_1001837E0;
  a1[1] = 0;
  SERestoreInfo::P73DeviceInfo::P73DeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EB9AC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EB9C0(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001837E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EB9D4(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001837E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EB9F8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EBA08@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = sub_1000EBA60(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EBA4C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EBA60(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_100183830;
  a1[1] = 0;
  SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EBA98(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EBAAC(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100183830;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EBAC0(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100183830;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EBAE4(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EBAF4@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = sub_1000EBB4C(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EBB38(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EBB4C(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_100183880;
  a1[1] = 0;
  SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EBB84(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EBB98(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100183880;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EBBAC(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100183880;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EBBD0(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EBBE0@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = sub_1000EBC38(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EBC24(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EBC38(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_1001838D0;
  a1[1] = 0;
  SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EBC70(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EBC84(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001838D0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EBC98(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001838D0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EBCBC(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EBCCC@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = sub_1000EBD24(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EBD10(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EBD24(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_100183920;
  a1[1] = 0;
  SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EBD5C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EBD70(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100183920;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EBD84(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100183920;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EBDA8(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EBDB8@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = sub_1000EBE10(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EBDFC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EBE10(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_100183970;
  a1[1] = 0;
  SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EBE48(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EBE5C(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_100183970;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EBE70(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_100183970;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EBE94(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EBEA4@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0xD8uLL);
  result = sub_1000EBEFC(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1000EBEE8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EBEFC(_QWORD *a1)
{
  a1[2] = 0;
  *a1 = off_1001839C0;
  a1[1] = 0;
  SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo(a1 + 3);
  return a1;
}

void sub_1000EBF34(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void sub_1000EBF48(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)off_1001839C0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void sub_1000EBF5C(std::__shared_weak_count *a1)
{
  void *v1;

  a1->__vftable = (std::__shared_weak_count_vtbl *)off_1001839C0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  operator delete(v1);
}

uint64_t sub_1000EBF80(uint64_t a1)
{
  return (**(uint64_t (***)(uint64_t))(a1 + 24))(a1 + 24);
}

_QWORD *sub_1000EBF90@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xB8uLL);
  result = sub_1000EBFE8(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EBFD4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EBFE8(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_100183790;
  a1[1] = 0;
  SERestoreInfo::IcefallDeviceInfo::IcefallDeviceInfo((SERestoreInfo::IcefallDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC020(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC034@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = sub_1000EC08C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EC078(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC08C(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_1001837E0;
  a1[1] = 0;
  SERestoreInfo::P73DeviceInfo::P73DeviceInfo((SERestoreInfo::P73DeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC0C4(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC0D8@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = sub_1000EC130(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EC11C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC130(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_100183830;
  a1[1] = 0;
  SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo((SERestoreInfo::SN100VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC168(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC17C@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = sub_1000EC1D4(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EC1C0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC1D4(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_100183880;
  a1[1] = 0;
  SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo((SERestoreInfo::SN200VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC20C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC220@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = sub_1000EC278(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EC264(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC278(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_1001838D0;
  a1[1] = 0;
  SERestoreInfo::SN210VDeviceInfo::SN210VDeviceInfo((SERestoreInfo::SN210VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC2B0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC2C4@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = sub_1000EC31C(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EC308(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC31C(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_100183920;
  a1[1] = 0;
  SERestoreInfo::SN300VDeviceInfo::SN300VDeviceInfo((SERestoreInfo::SN300VDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC354(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC368@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = sub_1000EC3C0(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EC3AC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC3C0(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_100183970;
  a1[1] = 0;
  SERestoreInfo::SE310SDeviceInfo::SE310SDeviceInfo((SERestoreInfo::SE310SDeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC3F8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC40C@<X0>(const __CFDictionary *const *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0xD8uLL);
  result = sub_1000EC464(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1000EC450(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *sub_1000EC464(_QWORD *a1, const __CFDictionary *const *a2)
{
  a1[2] = 0;
  *a1 = off_1001839C0;
  a1[1] = 0;
  SERestoreInfo::SN300V2DeviceInfo::SN300V2DeviceInfo((SERestoreInfo::SN300V2DeviceInfo *)(a1 + 3), a2);
  return a1;
}

void sub_1000EC49C(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

CFErrorRef SERestoreInfo::CreateCFError(const UInt8 *a1, int a2, const void *a3, const __CFString *a4)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v9;
  CFIndex v10;
  const UInt8 *v11;
  CFStringRef v12;
  CFStringRef v13;
  CFErrorRef v14;
  std::runtime_error *exception;
  std::string *v17;
  __int128 v18;
  std::runtime_error *v19;
  std::string *v20;
  __int128 v21;
  std::string v22;
  std::string v23;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v22, "Assertion: ");
    v17 = std::string::append(&v22, "userInfo");
    v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v23);
  }
  v9 = Mutable;
  if ((char)a1[23] < 0)
  {
    v11 = a1;
    a1 = *(const UInt8 **)a1;
    v10 = *((_QWORD *)v11 + 1);
  }
  else
  {
    v10 = a1[23];
  }
  v12 = CFStringCreateWithBytes(kCFAllocatorDefault, a1, v10, 0x8000100u, 0);
  if (!v12)
  {
    v19 = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v22, "Assertion: ");
    v20 = std::string::append(&v22, "description");
    v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
    v23.__r_.__value_.__r.__words[2] = v20->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v21;
    v20->__r_.__value_.__l.__size_ = 0;
    v20->__r_.__value_.__r.__words[2] = 0;
    v20->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(v19, &v23);
  }
  v13 = v12;
  CFDictionaryAddValue(v9, kCFErrorLocalizedDescriptionKey, v12);
  CFRelease(v13);
  if (a3)
    CFDictionaryAddValue(v9, kCFErrorUnderlyingErrorKey, a3);
  v14 = CFErrorCreate(kCFAllocatorDefault, a4, a2, v9);
  CFRelease(v9);
  return v14;
}

void sub_1000EC69C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  void *v21;
  char v22;

  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  if ((v22 & 1) != 0)
    __cxa_free_exception(v21);
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::getValueFromCFDict(SERestoreInfo *this, const __CFDictionary *a2, const __CFString *a3, BOOL *a4, void *a5)
{
  unsigned int v6;
  uint64_t result;
  const __CFString *TypeID;
  void *v10;
  void *v11;
  uint64_t v12;
  char *BytePtr;
  std::runtime_error *exception;
  std::string *v15;
  __int128 v16;
  void *v17;
  void *v18;
  std::string value;
  std::string v20;

  if (!this || !a2 || !a4 || (v6 = a5) == 0)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&value, "Assertion: ");
    v15 = std::string::append(&value, "dict && key && out && outLen");
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v20.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v20.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v20);
  }
  value.__r_.__value_.__r.__words[0] = 0;
  result = CFDictionaryGetValueIfPresent(this, a2, (const void **)&value.__r_.__value_.__l.__data_);
  if ((_DWORD)result)
  {
    result = value.__r_.__value_.__r.__words[0];
    if (value.__r_.__value_.__r.__words[0])
    {
      result = CFGetTypeID(value.__r_.__value_.__l.__data_);
      if ((const __CFString *)result == a3)
      {
        TypeID = (const __CFString *)CFNumberGetTypeID();
        if (v6 >= 4 && TypeID == a3)
        {
          result = CFNumberGetValue((CFNumberRef)value.__r_.__value_.__l.__data_, kCFNumberSInt32Type, a4);
          if (!(_DWORD)result)
          {
            v10 = __cxa_allocate_exception(0x48uLL);
            sub_1000CB3F4(&v20, "Cannot read CFNumber ");
            v11 = (void *)SERestoreInfo::SEException::SEException(v10, &v20, 2, CFSTR("SEUpdaterErrorDomain"));
          }
        }
        else if ((const __CFString *)CFBooleanGetTypeID() == a3)
        {
          result = CFBooleanGetValue((CFBooleanRef)value.__r_.__value_.__l.__data_);
          *a4 = (_DWORD)result != 0;
        }
        else
        {
          if ((const __CFString *)CFDataGetTypeID() != a3)
          {
            v17 = __cxa_allocate_exception(0x48uLL);
            sub_1000CB3F4(&v20, "missing key ");
            v18 = (void *)SERestoreInfo::SEException::SEException(v17, &v20, 2, CFSTR("SEUpdaterErrorDomain"));
          }
          v12 = v6;
          BytePtr = (char *)CFDataGetBytePtr((CFDataRef)value.__r_.__value_.__l.__data_);
          result = CFDataGetLength((CFDataRef)value.__r_.__value_.__l.__data_);
          if (result <= v12)
            return (uint64_t)sub_1000DDD98(a4, BytePtr, &BytePtr[result], result);
        }
      }
    }
  }
  return result;
}

void sub_1000EC900(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  if (a21 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t SERestoreInfo::SERestoreInfoLog::get(SERestoreInfo::SERestoreInfoLog *this)
{
  if (qword_1001A8F90 != -1)
    dispatch_once(&qword_1001A8F90, &stru_100183A38);
  return SERestoreInfo::SERestoreInfoLog::instance;
}

void sub_1000EC9C4(id a1)
{
  _QWORD *v1;

  v1 = operator new(0x58uLL);
  *v1 = SERestoreInfo::SERestoreInfoLog::printToOsLog;
  v1[1] = 0;
  *((_DWORD *)v1 + 4) = 2;
  v1[3] = 850045863;
  *((_OWORD *)v1 + 2) = 0u;
  *((_OWORD *)v1 + 3) = 0u;
  *((_OWORD *)v1 + 4) = 0u;
  v1[10] = 0;
  SERestoreInfo::SERestoreInfoLog::instance = (uint64_t)v1;
}

void SERestoreInfo::SERestoreInfoLog::registerLogSink(SERestoreInfo::SERestoreInfoLog *this, void (*a2)(void *, const char *), void *a3)
{
  std::mutex *v6;

  v6 = (std::mutex *)((char *)this + 24);
  std::mutex::lock((std::mutex *)((char *)this + 24));
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  std::mutex::unlock(v6);
}

void SERestoreInfo::SERestoreInfoLog::printToOsLog(SERestoreInfo::SERestoreInfoLog *this, char *a2, const char *a3)
{
  unint64_t v3;
  std::string *v4;
  std::string v5;
  std::string __str;
  char v7;
  uint8_t buf[4];
  std::string *v9;

  sub_1000CB3F4(&__str, a2);
  v3 = 0;
  while ((SHIBYTE(__str.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
    if (v3 >= HIBYTE(__str.__r_.__value_.__r.__words[2]))
      return;
LABEL_6:
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      std::string::basic_string(&v5, &__str, v3, 0x3E8uLL, (std::allocator<char> *)&v7);
      if ((v5.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v4 = &v5;
      else
        v4 = (std::string *)v5.__r_.__value_.__r.__words[0];
      *(_DWORD *)buf = 136315138;
      v9 = v4;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s", buf, 0xCu);
      if (SHIBYTE(v5.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v5.__r_.__value_.__l.__data_);
    }
    v3 += 1000;
  }
  if (v3 < __str.__r_.__value_.__l.__size_)
    goto LABEL_6;
  operator delete(__str.__r_.__value_.__l.__data_);
}

void sub_1000ECB88(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, int a17, __int16 a18, char a19, char a20)
{
  _Unwind_Resume(exception_object);
}

char *SERestoreInfo::SERestoreInfoLog::FormatMsg(SERestoreInfo::SERestoreInfoLog *this, const char *a2, ...)
{
  int v2;
  BOOL v3;
  char *v5;
  va_list va;

  va_start(va, a2);
  v5 = 0;
  v2 = vasprintf(&v5, a2, va);
  if (v5)
    v3 = v2 <= 0;
  else
    v3 = 1;
  if (v3)
    return 0;
  else
    return v5;
}

char *SERestoreInfo::SERestoreInfoLog::createVerboseLogString(SERestoreInfo::SERestoreInfoLog *this, unsigned int a2, const char *a3, const char *a4)
{
  SERestoreInfo::SERestoreInfoLog *v7;
  std::runtime_error *exception;
  std::string *v10;
  __int128 v11;
  std::string v12;
  std::string v13;

  if (a2 >= 5)
  {
    exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
    sub_1000CB3F4(&v12, "Assertion: ");
    v10 = std::string::append(&v12, "level >= 0 && level < _LOG_LEVEL_MAX && \"level is not good\"");
    v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
    v13.__r_.__value_.__r.__words[2] = v10->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v13.__r_.__value_.__l.__data_ = v11;
    v10->__r_.__value_.__l.__size_ = 0;
    v10->__r_.__value_.__r.__words[2] = 0;
    v10->__r_.__value_.__r.__words[0] = 0;
    std::runtime_error::runtime_error(exception, &v13);
  }
  *(_OWORD *)&v13.__r_.__value_.__l.__data_ = 0uLL;
  v7 = (SERestoreInfo::SERestoreInfoLog *)gettimeofday((timeval *)&v13, 0);
  return SERestoreInfo::SERestoreInfoLog::FormatMsg(v7, "[%3.3ld.%1.1d] [%s] %s: %s", v13.__r_.__value_.__r.__words[0], SLODWORD(v13.__r_.__value_.__r.__words[1]) / 1000, off_100183A58[a2], a3, a4);
}

void sub_1000ECCEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, int a16, __int16 a17, char a18, char a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  void *v25;
  int v26;

  if (a25 < 0)
    operator delete(__p);
  if (a19 < 0)
  {
    operator delete(a14);
    if ((v26 & 1) == 0)
LABEL_8:
      _Unwind_Resume(a1);
  }
  else if (!v26)
  {
    goto LABEL_8;
  }
  __cxa_free_exception(v25);
  goto LABEL_8;
}

void SERestoreInfo::SERestoreInfoLog::printLogv(SERestoreInfo::SERestoreInfoLog *this, unsigned int a2, const char *a3, const char *a4, va_list a5)
{
  SERestoreInfo::SERestoreInfoLog *v8;
  char *v9;
  char *VerboseLogString;
  char *v12;

  v12 = 0;
  v8 = (SERestoreInfo::SERestoreInfoLog *)vasprintf(&v12, a4, a5);
  v9 = v12;
  if ((int)v8 >= 1 && v12 != 0)
  {
    VerboseLogString = SERestoreInfo::SERestoreInfoLog::createVerboseLogString(v8, a2, a3, v12);
    free(v9);
    if (VerboseLogString)
    {
      std::mutex::lock((std::mutex *)((char *)this + 24));
      (*(void (**)(_QWORD, char *))this)(*((_QWORD *)this + 1), VerboseLogString);
      std::mutex::unlock((std::mutex *)((char *)this + 24));
      free(VerboseLogString);
    }
  }
}

void SERestoreInfo::SERestoreInfoLog::printLog(SERestoreInfo::SERestoreInfoLog *this, signed int a2, const char *a3, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  if (*((_DWORD *)this + 4) >= a2)
    SERestoreInfo::SERestoreInfoLog::printLogv(this, a2, a3, a4, va);
}

uint64_t SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(_QWORD *)v3 = &off_100183A98;
  if (*(_DWORD *)(v3 + 56) != 100)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return a1;
}

void sub_1000ECE94(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN100VDeviceInfo *SERestoreInfo::SN100VDeviceInfo::SN100VDeviceInfo(SERestoreInfo::SN100VDeviceInfo *this, SERestoreInfo **a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_100183A98;
  if (*((_DWORD *)v3 + 14) != 100)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return this;
}

void sub_1000ECF30(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

uint64_t SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(a1, a2);
  *(_QWORD *)v3 = &off_100183AE8;
  if (*(_DWORD *)(v3 + 56) != 200)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return a1;
}

void sub_1000ECFCC(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

SERestoreInfo::SN200VDeviceInfo *SERestoreInfo::SN200VDeviceInfo::SN200VDeviceInfo(SERestoreInfo::SN200VDeviceInfo *this, SERestoreInfo **a2)
{
  SERestoreInfo::P73BaseDeviceInfo *v3;
  _QWORD *exception;

  v3 = SERestoreInfo::P73BaseDeviceInfo::P73BaseDeviceInfo(this, a2);
  *(_QWORD *)v3 = &off_100183AE8;
  if (*((_DWORD *)v3 + 14) != 200)
  {
    exception = __cxa_allocate_exception(0x48uLL);
    sub_1000DCD1C(exception);
  }
  return this;
}

void sub_1000ED068(_Unwind_Exception *a1)
{
  _QWORD *v1;

  sub_1000DCB48(v1);
  _Unwind_Resume(a1);
}

uint64_t computeFirmwareDigest(const void *a1, unint64_t a2, unsigned __int8 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CC_SHA256_CTX c;

  T200RestoreInfoLog("%s:%d Start\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"computeFirmwareDigest");
  if (a2 >> 20 > 4)
    return 2;
  memset(&c, 0, sizeof(c));
  CC_SHA256_Init(&c);
  T200RestoreInfoLog("%s:%d CC_SHA256_Init %d\n", v12, v13, v14, v15, v16, v17, v18, (char)"computeFirmwareDigest");
  CC_SHA256_Update(&c, a1, a2);
  T200RestoreInfoLog("%s:%d CC_SHA256_Update %d\n", v19, v20, v21, v22, v23, v24, v25, (char)"computeFirmwareDigest");
  v11 = CC_SHA256_Final(a3, &c);
  T200RestoreInfoLog("%s:%d CC_SHA256_Final %d\n", v26, v27, v28, v29, v30, v31, v32, (char)"computeFirmwareDigest");
  return v11;
}

CFErrorRef createCFError(char *cStr, unsigned int a2, const char *a3, uint64_t a4)
{
  CFStringRef v7;
  CFStringRef v8;
  CFStringRef v9;
  CFStringRef v10;
  CFStringRef v11;
  __CFDictionary *Mutable;
  CFErrorRef v13;

  v7 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (!v7)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "cfErrMsg", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200Updater/T200UpdaterPrivateHelper.c", 62, 0);
    return 0;
  }
  v8 = v7;
  if (a3 || (_DWORD)a4)
  {
    if (!a3)
    {
      v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@; %u"), v7, a4);
      goto LABEL_9;
    }
    v10 = CFStringCreateWithCString(kCFAllocatorDefault, a3, 0x8000100u);
    if (v10)
    {
      a3 = (const char *)v10;
      v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@; %@: %u"), v8, v10, a4);
LABEL_9:
      v9 = v11;
      goto LABEL_10;
    }
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "apiNameRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200Updater/T200UpdaterPrivateHelper.c", 69, 0);
    CFRelease(v8);
    return 0;
  }
  v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), v7);
  a3 = 0;
LABEL_10:
  if (v9)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryAddValue(Mutable, kCFErrorLocalizedDescriptionKey, v9);
    v13 = CFErrorCreate(kCFAllocatorDefault, CFSTR("T200ErrorDomain"), a2, Mutable);
    CFRelease(v9);
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "totalErrMsg", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200Updater/T200UpdaterPrivateHelper.c", 72, 0);
    Mutable = 0;
    v13 = 0;
  }
  CFRelease(v8);
  if (a3)
    CFRelease(a3);
  if (Mutable)
    CFRelease(Mutable);
  return v13;
}

const char *T200RestoreInfoLog(const char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char __str[4096];

  if (logSinkFunc)
  {
    vsnprintf(__str, 0x1000uLL, result, &a9);
    return (const char *)logSinkFunc(logContext, __str);
  }
  return result;
}

__CFDictionary *T200UpdaterGetTagsWithLogging(const __CFDictionary *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3, CFTypeRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *Mutable;
  __CFArray *v11;
  __CFArray *v12;
  __CFArray *v13;
  const void *Value;
  const void *v15;
  CFTypeID v16;
  CFTypeRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  char *v27;
  const char *v28;
  unsigned int v29;
  CFErrorRef CFError;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  logSinkFunc = a2;
  logContext = a3;
  T200RestoreInfoLog("%s:%d Start\n", (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"_T200UpdaterGetTagsWithLogging");
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "outputDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 622, 0);
    CFError = createCFError("Cannot allocate memory for outputDict", 3u, "CFDictionaryCreateMutable", 0);
    v11 = 0;
LABEL_17:
    v13 = 0;
    goto LABEL_21;
  }
  v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v11)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tagsInBIRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 625, 0);
    CFError = createCFError("Cannot allocate memory for tagsInBI", 3u, "CFArrayCreateMutable", 0);
    goto LABEL_17;
  }
  v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v13 = v12;
  if (v12)
  {
    CFArrayAppendValue(v12, CFSTR("BMU,Ticket"));
    if (a1)
    {
      Value = CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
      if (Value)
      {
        v15 = Value;
        v16 = CFGetTypeID(Value);
        if (v16 == CFDictionaryGetTypeID())
        {
          v17 = CFRetain(v15);
          CFArrayAppendValue(v11, CFSTR("BMU,FirmwareMap"));
          CFDictionaryAddValue(Mutable, CFSTR("BuildIdentityTags"), v11);
          CFDictionaryAddValue(Mutable, CFSTR("ResponseTags"), v13);
          T200RestoreInfoLog("%s:%d End\n", v18, v19, v20, v21, v22, v23, v24, (char)"_T200UpdaterGetTagsWithLogging");
LABEL_8:
          CFRelease(v13);
          v25 = v17;
          goto LABEL_9;
        }
      }
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 634, 0);
      v27 = "DeviceInfo is NULL";
      v28 = "CFDictionaryGetValue";
      v29 = 2;
    }
    else
    {
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "options", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 632, 0);
      v27 = "options is NULL";
      v29 = 2;
      v28 = 0;
    }
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tagsInTssResponse", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 628, 0);
    v27 = "Cannot allocate memory for tagsInTssResponse";
    v28 = "CFArrayCreateMutable";
    v29 = 3;
  }
  CFError = createCFError(v27, v29, v28, 0);
LABEL_21:
  if (a4 && CFError)
  {
    *a4 = CFRetain(CFError);
    T200RestoreInfoLog("%s:%d outputDict =\n", v31, v32, v33, v34, v35, v36, v37, (char)"_T200UpdaterGetTagsWithLogging");
    sub_1000EF990(Mutable);
    if (Mutable)
    {
      CFRelease(Mutable);
      Mutable = 0;
    }
  }
  else if (!CFError)
  {
    goto LABEL_27;
  }
  CFRelease(CFError);
LABEL_27:
  v17 = 0;
  v25 = 0;
  if (v13)
    goto LABEL_8;
LABEL_9:
  if (v11)
    CFRelease(v11);
  if (v25)
    CFRelease(v25);
  return Mutable;
}

const void *T200UpdaterCopyFirmwareWithLogging(const __CFDictionary *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  const void *Value;
  CFTypeID v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const void *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const void *v30;
  const __CFDictionary *v31;
  const __CFDictionary *v32;
  const void *v33;
  const __CFDictionary *v34;
  const __CFDictionary *v35;
  const void *v36;
  CFTypeRef v37;
  const void *v38;
  const void *v39;
  const void *v40;
  CFTypeID v41;
  BOOL v42;
  const __CFDictionary *v43;
  const __CFString *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  CFTypeRef v60;
  const void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  CFTypeRef v78;
  const __CFString *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t Directory;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  CFErrorRef v91;
  CFTypeRef v92;
  char *CStringPtr;
  const void *v94;
  const void *CFError;
  const __CFString *v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const void *v104;
  uint64_t v106;
  char *v107;
  const char *v108;
  char *v109;
  const char *v110;
  uint64_t v111;
  char *v112;
  const char *v113;
  unsigned int v114;
  uint64_t v115;
  char *v116;
  const char *v117;
  unsigned int v118;
  uint64_t v119;
  const __CFString *v120;
  _QWORD *v121;
  char v122;
  CFTypeRef cf;
  unsigned __int8 v124;
  const void *v125;
  CFURLRef v126;
  CFURLRef url;
  char buffer[16];
  __int128 v129;
  UInt8 v130[1024];
  UInt8 v131[1024];

  v8 = (_QWORD *)a4;
  logSinkFunc = a2;
  logContext = a3;
  T200RestoreInfoLog("%s:%d Start\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"_T200UpdaterCopyFirmwareWithLogging");
  if (!a1)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "options", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 680, 0);
    v107 = "options is NULL";
    v108 = 0;
    goto LABEL_88;
  }
  Value = CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  if (!Value || (v11 = CFGetTypeID(Value), v11 != CFDictionaryGetTypeID()))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 683, 0);
    v107 = "Missing device info";
    v108 = "CFDictionaryGetValue";
LABEL_88:
    CFError = createCFError(v107, 2u, v108, 0);
    v104 = 0;
    goto LABEL_73;
  }
  v126 = 0;
  url = 0;
  v125 = 0;
  v19 = "copyFirmwareData";
  T200RestoreInfoLog("%s:%d Start\n", v12, v13, v14, v15, v16, v17, v18, (char)"copyFirmwareData");
  if (CFStringGetCStringPtr(CFSTR("BMU,FirmwareMap"), 0x8000100u))
    T200RestoreInfoLog("%s:%d Start file_name=%s \n", v20, v21, v22, v23, v24, v25, v26, (char)"copyFirmwareData");
  v27 = CFDictionaryGetValue(a1, CFSTR("BuildIdentity"));
  if (!v27 || (v28 = (const __CFDictionary *)CFRetain(v27)) == 0)
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "buildIdentityDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 501, 0);
    v91 = createCFError("Missing kT200OptionBuildIdentity", 0xEu, 0, 0);
    v29 = 0;
    v35 = 0;
    v32 = 0;
    v61 = 0;
    v92 = 0;
    v38 = 0;
    v43 = 0;
    v79 = 0;
    v122 = 1;
    goto LABEL_44;
  }
  v29 = v28;
  v30 = CFDictionaryGetValue(v28, CFSTR("BMU,FirmwareMap"));
  if (!v30 || (v31 = (const __CFDictionary *)CFRetain(v30)) == 0)
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "imageDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 504, 0);
    CStringPtr = (char *)CFStringGetCStringPtr(CFSTR("BMU,FirmwareMap"), 0x600u);
    v91 = createCFError(CStringPtr, 0xEu, 0, 0);
    v122 = 0;
    v35 = 0;
    v32 = 0;
LABEL_41:
    v61 = 0;
    v92 = 0;
    v38 = 0;
LABEL_42:
    v43 = 0;
LABEL_43:
    v79 = 0;
    goto LABEL_44;
  }
  v32 = v31;
  v33 = CFDictionaryGetValue(v31, CFSTR("Info"));
  if (!v33 || (v34 = (const __CFDictionary *)CFRetain(v33)) == 0)
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "infoDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 507, 0);
    v91 = createCFError("Missing kT200BuildIdentityInfoKey", 0x14u, 0, 0);
    v122 = 0;
    v35 = 0;
    goto LABEL_41;
  }
  v35 = v34;
  v36 = CFDictionaryGetValue(v34, CFSTR("Path"));
  if (!v36 || (v37 = CFRetain(v36)) == 0)
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "relativePathStr", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 510, 0);
    v91 = createCFError("Missing kT200BuildIdentityPathKey", 0x14u, 0, 0);
    v122 = 0;
    goto LABEL_41;
  }
  v38 = v37;
  v39 = CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  if (!v39 || (v40 = v39, v41 = CFGetTypeID(v39), v42 = v41 == CFDictionaryGetTypeID(), v19 = "copyFirmwareData", !v42))
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 513, 0);
    v91 = createCFError("DeviceInfo is NULL", 2u, 0, 0);
    v122 = 0;
    v61 = 0;
    v92 = 0;
    goto LABEL_42;
  }
  v43 = (const __CFDictionary *)CFRetain(v40);
  if (!sub_1000EF9F4(v43))
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "chemistryID!=0", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 517, 0);
    v109 = "Missing ChemistryID";
    v110 = "getChemistryId";
LABEL_92:
    v91 = createCFError(v109, 0x14u, v110, 0);
    v122 = 0;
    v61 = 0;
    v92 = 0;
    goto LABEL_43;
  }
  v44 = (const __CFString *)sub_1000EFAD4(v43);
  if (!v44)
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "hw_version!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 521, 0);
    v109 = "Missing HWVersion";
    v110 = "CopyHWVersion";
    goto LABEL_92;
  }
  *(_OWORD *)buffer = 0u;
  v129 = 0u;
  v120 = v44;
  CFStringGetCString(v44, buffer, 32, 0x600u);
  v19 = "copyFirmwareData";
  T200RestoreInfoLog("%s:%d chemistry=%u silicon_ver=%s\n", v45, v46, v47, v48, v49, v50, v51, (char)"copyFirmwareData");
  v52 = CFDictionaryGetValue(a1, CFSTR("BundlePath"));
  if (!v52 || (v60 = CFRetain(v52)) == 0)
  {
    T200RestoreInfoLog("%s:%d Override is set \n", v53, v54, v55, v56, v57, v58, v59, (char)"copyFirmwareData");
    v94 = CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
    if (v94)
      v94 = CFRetain(v94);
    v79 = v120;
    v61 = 0;
    cf = 0;
    v125 = v94;
    if (!v94)
      goto LABEL_85;
    goto LABEL_39;
  }
  v61 = v60;
  v62 = AMSupportPlatformCopyURLWithAppendedComponent(0, v60, v38, 0, &url);
  if ((_DWORD)v62)
  {
    v111 = v62;
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "kAMSupportErrorNone == status", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 534, 0);
    v112 = "Fail to run AMSupportPlatformCopyURLWithAppendedComponent";
    v113 = "AMSupportPlatformCopyURLWithAppendedComponent";
    v114 = v111;
    v115 = v111;
LABEL_97:
    v91 = createCFError(v112, v114, v113, v115);
    v122 = 0;
    v92 = 0;
    v79 = v120;
    goto LABEL_44;
  }
  if (!url)
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "filePathURL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 535, 0);
    v112 = "Fail to do AMSupportPlatformCopyURLWithAppendedComponent";
    v113 = "AMSupportPlatformCopyURLWithAppendedComponent";
    v114 = 3;
LABEL_96:
    v115 = 0;
    goto LABEL_97;
  }
  if (!CFEqual(CFSTR("BMU,FirmwareMap"), CFSTR("BMU,FirmwareMap")))
  {
    cf = 0;
    v79 = v120;
    goto LABEL_84;
  }
  T200RestoreInfoLog("%s:%d Loading FW map url \n", v63, v64, v65, v66, v67, v68, v69, (char)"copyFirmwareData");
  if (!CFURLGetFileSystemRepresentation(url, 1u, v131, 1024))
  {
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "converted", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 539, 0);
    v112 = "Fail get the file path ";
    v114 = 3;
    v113 = 0;
    goto LABEL_96;
  }
  v70 = CFDictionaryGetValue(a1, CFSTR("DestBundlePath"));
  if (v70)
  {
    v78 = CFRetain(v70);
    v79 = v120;
    if (v78)
    {
      cf = v78;
      v81 = AMSupportPlatformCopyURLWithAppendedComponent(0, v78, v38, 0, &v126);
      if ((_DWORD)v81 || !v126)
      {
        v121 = v8;
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "(kAMSupportErrorNone == status) && (NULL != dstFilePathURL)", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 549, 0);
        v116 = "CreateFileData: Fail to run AMSupportPlatformCopyURLWithAppendedComponent with dstBundleURL";
        v117 = "AMSupportPlatformCopyURLWithAppendedComponent";
        v118 = 3;
LABEL_103:
        v119 = v81;
LABEL_104:
        v91 = createCFError(v116, v118, v117, v119);
        v122 = 0;
        v19 = "copyFirmwareData";
        goto LABEL_105;
      }
      Directory = AMSupportMakeDirectory(v126, v80);
      if ((_DWORD)Directory)
      {
        v81 = Directory;
        v121 = v8;
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "kAMSupportErrorNone == status", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 552, 0);
        v116 = "CreateFileData: Fail to run AMSupportMakeDirectory with dstFilePathURL";
        v117 = "AMSupportMakeDirectory";
        goto LABEL_102;
      }
      v83 = AMSupportCopyFile(kCFAllocatorDefault, url, v126);
      if ((_DWORD)v83)
      {
        v81 = v83;
        v121 = v8;
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "kAMSupportErrorNone == status", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 555, 0);
        v116 = "CreateFileData: Fail to run AMSupportCopyFile with dstFilePathURL";
        v117 = "AMSupportCopyFile";
        goto LABEL_102;
      }
      v124 = 0;
      AMSupportPlatformFileURLExists(v126, &v124);
      if (!v124)
      {
        v121 = v8;
        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "fileExists", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 559, 0);
        v119 = v124;
        v116 = "CreateFileData: AMSupportPlatformFileURLExists returned FALSE";
        v117 = "AMSupportPlatformFileURLExists";
        v118 = 33;
        goto LABEL_104;
      }
      CFURLGetFileSystemRepresentation(v126, 1u, v130, 1024);
      T200RestoreInfoLog("%s:%d Copy the file %s to  %s\n", v84, v85, v86, v87, v88, v89, v90, (char)"copyFirmwareData");
    }
    else
    {
      cf = 0;
    }
  }
  else
  {
    cf = 0;
    v79 = v120;
  }
  T200RestoreInfoLog("%s:%d Loading FW from %s\n", v71, v72, v73, v74, v75, v76, v77, (char)"copyFirmwareData");
  v106 = AMSupportCreateDataFromFileURL(kCFAllocatorDefault, &v125);
  if ((_DWORD)v106)
  {
    v81 = v106;
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "kAMSupportErrorNone == status", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 568, 0);
    v116 = "CreateFileData: Fail to run AMSupportCreateDataFromFileURL";
    v117 = "AMSupportCreateDataFromFileURL";
LABEL_102:
    v118 = 33;
    goto LABEL_103;
  }
  v19 = "copyFirmwareData";
LABEL_84:
  if (!v125)
  {
LABEL_85:
    v121 = v8;
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "firmwareData", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 572, 0);
    v91 = createCFError("firmwareData is NULL", 3u, 0, 0);
    v122 = 0;
LABEL_105:
    v92 = cf;
LABEL_44:
    cf = v92;
    if (v91)
    {
      CFError = CFRetain(v91);
      v96 = CFErrorCopyDescription(v91);
      if (CFStringGetCStringPtr(v96, 0x8000100u))
        T200RestoreInfoLog("%s:%d Error : %s\n", v97, v98, v99, v100, v101, v102, v103, (char)"copyFirmwareData");
      if (v96)
        CFRelease(v96);
      CFRelease(v91);
      LOBYTE(v19) = "copyFirmwareData";
      v8 = v121;
    }
    else
    {
      CFError = 0;
      v8 = v121;
    }
    goto LABEL_51;
  }
LABEL_39:
  CFError = 0;
  v122 = 0;
LABEL_51:
  if (url)
  {
    CFRelease(url);
    url = 0;
  }
  if (v126)
  {
    CFRelease(v126);
    v126 = 0;
  }
  if (v61)
    CFRelease(v61);
  if (cf)
    CFRelease(cf);
  if (v38)
    CFRelease(v38);
  if (v35)
    CFRelease(v35);
  if (v32)
    CFRelease(v32);
  if ((v122 & 1) == 0)
    CFRelease(v29);
  if (v43)
    CFRelease(v43);
  if (v79)
    CFRelease(v79);
  T200RestoreInfoLog("%s:%d End\n", v63, v64, v65, v66, v67, v68, v69, (char)v19);
  v104 = v125;
  if (!v125)
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "firmwareDataRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 689, 0);
LABEL_73:
  if (v8 && CFError)
  {
    *v8 = CFRetain(CFError);
LABEL_77:
    CFRelease(CFError);
    return v104;
  }
  if (CFError)
    goto LABEL_77;
  return v104;
}

CFTypeRef T200UpdaterCreateRequestWithLogging(const __CFDictionary *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  const void *v10;
  CFTypeRef v11;
  const void *v12;
  const void *v13;
  const __CFDictionary *v14;
  const __CFDictionary *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  CFTypeRef v24;
  CFErrorRef CFError;
  const __CFDictionary *v26;
  CFTypeRef v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CFTypeRef v35;
  CFTypeRef v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const void *v45;
  const void *v46;
  CFTypeID v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const void *v55;
  const __CFDictionary *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  CFMutableDictionaryRef v64;
  CFMutableDictionaryRef v65;
  __CFDictionary *v66;
  CFTypeRef v67;
  __CFDictionary *v68;
  CFTypeRef v69;
  const void *ValueForKeyPathInDict;
  CFTypeRef v71;
  CFTypeRef v72;
  CFTypeRef v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  CFDataRef v105;
  size_t Length;
  UInt8 *v107;
  UInt8 *v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  __CFDictionary *v128;
  __CFDictionary *v129;
  const void *v130;
  CFTypeID v131;
  const void *v132;
  const void *v133;
  CFTypeID v134;
  const __CFBoolean *v135;
  const __CFBoolean *v136;
  CFTypeID v137;
  CFBooleanRef v138;
  const void *v139;
  const void *v140;
  CFTypeID v141;
  const void *v142;
  const void *v143;
  CFTypeID v144;
  const void *v145;
  const void *v146;
  CFTypeID v147;
  const void *v148;
  const void *v149;
  CFTypeID v150;
  const void *v151;
  int v152;
  const void *v153;
  const void *v154;
  int v155;
  const void *v156;
  CFTypeID v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  const void *v165;
  const void *v166;
  CFTypeID v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  __CFDictionary *v196;
  char v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  FILE *v205;
  int v206;
  FILE *v207;
  int v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  FILE *v216;
  int v217;
  char *v218;
  const char *v219;
  unsigned int v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  CFTypeRef value;
  const __CFDictionary *v237;
  CFTypeRef cf;
  CFTypeRef v239;
  CFStringRef v240;
  CFTypeRef v241;
  CFMutableDictionaryRef v242;
  CFTypeRef v243;
  __CFDictionary *v244;
  __CFDictionary *theDict;
  CFStringRef v246;
  _QWORD *v247;
  __CFDictionary *Mutable;
  CFTypeRef v249;
  CFPropertyListRef v250;
  __CFDictionary *v251;
  UInt8 bytes[16];
  __int128 v253;
  CFRange v254;

  v8 = (_QWORD *)a4;
  logSinkFunc = a2;
  logContext = a3;
  T200RestoreInfoLog("%s:%d Start\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (char)"__T200UpdaterCreateRequestWithLogging");
  if (!a1)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "options", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 719, 0);
    CFError = createCFError("options is NULL", 2u, 0, 0);
    v26 = 0;
    v15 = 0;
    v24 = 0;
    v27 = 0;
    v12 = 0;
    goto LABEL_14;
  }
  if (!CFDictionaryContainsKey(a1, CFSTR("BuildIdentity"))
    || (v10 = CFDictionaryGetValue(a1, CFSTR("BuildIdentity"))) == 0
    || (v11 = CFRetain(v10)) == 0)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "buildIdentity", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 725, 0);
    CFError = createCFError("BuildIdentity is NULL in input options", 2u, 0, 0);
    v26 = 0;
    v15 = 0;
    v24 = 0;
    v27 = 0;
    v12 = 0;
    goto LABEL_13;
  }
  v12 = v11;
  if (!CFDictionaryContainsKey(a1, CFSTR("DeviceInfo"))
    || (v13 = CFDictionaryGetValue(a1, CFSTR("DeviceInfo"))) == 0
    || (v14 = (const __CFDictionary *)CFRetain(v13)) == 0)
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "T200Parameters", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 731, 0);
    CFError = createCFError("Cannot get DeviceInfo", 2u, 0, 0);
    v26 = 0;
    v15 = 0;
    v24 = 0;
    v27 = 0;
    goto LABEL_13;
  }
  v15 = v14;
  if (CFDictionaryContainsKey(v14, CFSTR("UpdaterOptions")))
  {
    v23 = CFDictionaryGetValue(v15, CFSTR("UpdaterOptions"));
    if (v23)
    {
      v24 = CFRetain(v23);
      goto LABEL_34;
    }
  }
  else
  {
    T200RestoreInfoLog("%s:%d Updater options is empty\n", v16, v17, v18, v19, v20, v21, v22, (char)"__T200UpdaterCreateRequestWithLogging");
  }
  v24 = 0;
LABEL_34:
  if (!CFDictionaryContainsKey(a1, CFSTR("Options")))
  {
    T200RestoreInfoLog("%s:%d Restore options is empty\n", v38, v39, v40, v41, v42, v43, v44, (char)"__T200UpdaterCreateRequestWithLogging");
    goto LABEL_38;
  }
  v45 = CFDictionaryGetValue(a1, CFSTR("Options"));
  if (!v45)
  {
LABEL_38:
    v27 = 0;
    goto LABEL_39;
  }
  v27 = CFRetain(v45);
LABEL_39:
  v46 = CFDictionaryGetValue(v15, CFSTR("LocalSigningID"));
  if (v46)
  {
    v47 = CFGetTypeID(v46);
    if (v47 == CFBooleanGetTypeID())
    {
      if (!CFDictionaryContainsKey(a1, CFSTR("FirmwareData")))
      {
        T200RestoreInfoLog("%s:%d Start\n", v48, v49, v50, v51, v52, v53, v54, (char)"_createRequestDictForTATSU");
        a1 = 0;
        goto LABEL_56;
      }
      v55 = CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
      if (v55)
      {
        v56 = (const __CFDictionary *)CFRetain(v55);
        if (v56)
        {
          a1 = v56;
          T200RestoreInfoLog("%s:%d Start\n", v57, v58, v59, v60, v61, v62, v63, (char)"_createMeasurementDict");
          theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          *(_OWORD *)bytes = 0u;
          v253 = 0u;
          v64 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v65 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v244 = v64;
          v242 = v65;
          if (v64)
          {
            v66 = v65;
            if (sub_1000EF9F4(v15))
            {
              v67 = sub_1000EFAD4(v15);
              v68 = Mutable;
              if (v67)
              {
                v69 = v67;
                v246 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@"), CFSTR("board_id"), 381);
                v250 = CFPropertyListCreateWithData(kCFAllocatorDefault, a1, 0, 0, 0);
                v241 = v69;
                if (v250)
                {
                  v243 = CFRetain(a1);
                  if (v243)
                  {
                    v240 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@.%@"), CFSTR("digest_der"), CFSTR("Digest"));
                    ValueForKeyPathInDict = (const void *)AMSupportGetValueForKeyPathInDict(kCFAllocatorDefault, v250, v240);
                    if (ValueForKeyPathInDict && (v71 = CFRetain(ValueForKeyPathInDict)) != 0)
                    {
                      cf = v71;
                      CFDictionarySetValue(Mutable, CFSTR("Digest"), v71);
                      CFDictionarySetValue(v66, CFSTR("BMU,DigestMap"), Mutable);
                      v72 = (CFTypeRef)AMSupportGetValueForKeyPathInDict(kCFAllocatorDefault, v250, v246);
                      if (v72)
                        v72 = CFRetain(v72);
                      if (v66)
                      {
                        v73 = v72;
                        v237 = (const __CFDictionary *)CFRetain(v66);
                        v72 = v73;
                      }
                      else
                      {
                        v237 = 0;
                      }
                      v239 = v72;
                      if (v72)
                        value = CFRetain(v72);
                      else
                        value = 0;
                      Length = CFDataGetLength(a1);
                      v107 = (UInt8 *)calloc(Length, 1uLL);
                      if (v107)
                      {
                        v108 = v107;
                        v254.location = 0;
                        v254.length = Length;
                        CFDataGetBytes(a1, v254, v107);
                        computeFirmwareDigest(v108, Length, bytes, v109, v110, v111, v112, v113);
                        v105 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
                        CFDictionarySetValue(theDict, CFSTR("Digest"), v105);
                        CFDictionarySetValue(v244, CFSTR("BMU,FirmwareMap"), theDict);
                        v26 = (const __CFDictionary *)CFRetain(v244);
                        T200RestoreInfoLog("%s:%d End\n", v114, v115, v116, v117, v118, v119, v120, (char)"_createMeasurementDict");
                        free(v108);
                        v97 = 0;
                        v68 = Mutable;
LABEL_68:
                        if (v68)
                          CFRelease(v68);
                        if (cf)
                          CFRelease(cf);
                        if (v240)
                          CFRelease(v240);
                        if (v105)
                          CFRelease(v105);
                        if (theDict)
                          CFRelease(theDict);
                        if (v244)
                          CFRelease(v244);
                        if (v242)
                          CFRelease(v242);
                        if (v243)
                          CFRelease(v243);
                        if (v239)
                          CFRelease(v239);
                        if (v250)
                          CFRelease(v250);
                        if (v241)
                          CFRelease(v241);
                        if (v246)
                          CFRelease(v246);
                        if ((_DWORD)v97)
                        {
                          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "ret == kT200Success", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 756, 0);
                          v218 = "_createMeasurementDict fails.";
                          v219 = "_createMeasurementDict";
                          v220 = v97;
                          v221 = v97;
LABEL_172:
                          CFError = createCFError(v218, v220, v219, v221);
                          goto LABEL_14;
                        }
                        T200RestoreInfoLog("%s:%d Start\n", v98, v99, v100, v101, v102, v103, v104, (char)"_createRequestDictForTATSU");
                        if (v26)
                        {
                          T200RestoreInfoLog("%s:%d Restore Options\n", v121, v122, v123, v124, v125, v126, v127, (char)"_createRequestDictForTATSU");
                          sub_1000EF990(v27);
                          v128 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                          if (v128)
                          {
                            v129 = v128;
                            CFDictionaryAddValue(v128, CFSTR("@BMU,Ticket"), kCFBooleanTrue);
                            v130 = CFDictionaryGetValue(v15, CFSTR("LocalSigningID"));
                            if (v130 && (v131 = CFGetTypeID(v130), v131 == CFBooleanGetTypeID()))
                            {
                              v132 = CFDictionaryGetValue(v15, CFSTR("ChipID"));
                              if (!v132 || (v133 = v132, v134 = CFGetTypeID(v132), v134 != CFNumberGetTypeID()))
                              {
                                v251 = v129;
                                v207 = __stderrp;
                                v208 = 280;
                                goto LABEL_158;
                              }
                              CFDictionarySetValue(v129, CFSTR("BMU,ChipID"), v133);
                              v135 = (const __CFBoolean *)CFDictionaryGetValue(v15, CFSTR("ProductionMode"));
                              if (v135)
                              {
                                v136 = v135;
                                v137 = CFGetTypeID(v135);
                                if (v137 == CFBooleanGetTypeID())
                                {
                                  if (CFBooleanGetValue(v136))
                                    v138 = kCFBooleanTrue;
                                  else
                                    v138 = kCFBooleanFalse;
                                  CFDictionaryAddValue(v129, CFSTR("BMU,ProductionMode"), v138);
                                  v139 = CFDictionaryGetValue(v15, CFSTR("UniqueID"));
                                  if (v139)
                                  {
                                    v140 = v139;
                                    v141 = CFGetTypeID(v139);
                                    if (v141 == CFNumberGetTypeID())
                                    {
                                      CFDictionaryAddValue(v129, CFSTR("BMU,UniqueID"), v140);
                                      v142 = CFDictionaryGetValue(v15, CFSTR("Nonce"));
                                      if (v142 && (v143 = v142, v144 = CFGetTypeID(v142), v144 == CFDataGetTypeID()))
                                      {
                                        CFDictionaryAddValue(v129, CFSTR("BMU,Nonce"), v143);
                                        v145 = CFDictionaryGetValue(v26, CFSTR("BMU,FirmwareMap"));
                                        if (v145
                                          && (v146 = v145, v147 = CFGetTypeID(v145), v147 == CFDictionaryGetTypeID()))
                                        {
                                          CFDictionaryAddValue(v129, CFSTR("BMU,FirmwareMap"), v146);
                                          if (!v237)
                                            goto LABEL_114;
                                          v148 = CFDictionaryGetValue(v237, CFSTR("BMU,DigestMap"));
                                          if (v148)
                                          {
                                            v149 = v148;
                                            v150 = CFGetTypeID(v148);
                                            if (v150 == CFDictionaryGetTypeID())
                                            {
                                              CFDictionaryAddValue(v129, CFSTR("BMU,DigestMap"), v149);
LABEL_114:
                                              if (value)
                                                CFDictionaryAddValue(v129, CFSTR("BMU,BoardID"), value);
                                              if (CFDictionaryContainsKey(v15, CFSTR("UpdaterOptions")))
                                              {
                                                v151 = CFDictionaryGetValue(v15, CFSTR("UpdaterOptions"));
                                                if (v151)
                                                  v151 = CFRetain(v151);
                                                v249 = v151;
                                                v152 = sub_1000EFB8C((const __CFDictionary *)v151, CFSTR("RestoreInternal"));
                                                v153 = CFDictionaryGetValue(v15, CFSTR("ForceFirmwareUpgrade"));
                                                if (!v153)
                                                {
                                                  if (v152 == 1)
                                                  {
                                                    if (sub_1000EFB8C((const __CFDictionary *)v27, CFSTR("SkipSameVersion")))
                                                    {
                                                      v165 = CFDictionaryGetValue(v15, CFSTR("RollbackFWVer"));
                                                      if (v165)
                                                      {
LABEL_132:
                                                        v167 = CFGetTypeID(v165);
                                                        if (v167 == CFBooleanGetTypeID())
                                                        {
                                                          if (CFBooleanGetValue((CFBooleanRef)v165) != 1)
                                                            goto LABEL_138;
                                                          goto LABEL_137;
                                                        }
                                                        v251 = v129;
                                                        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 335, 0);
LABEL_164:
                                                        v81 = 2;
                                                        T200RestoreInfoLog("%s:%d End,Failed with ret=%d\n", v209, v210, v211, v212, v213, v214, v215, (char)"_createRequestDictForTATSU");
                                                        v35 = 0;
                                                        v197 = 0;
                                                        v196 = v251;
                                                        goto LABEL_143;
                                                      }
                                                      goto LABEL_136;
                                                    }
                                                    v152 = 1;
                                                    goto LABEL_125;
                                                  }
LABEL_130:
                                                  v166 = CFDictionaryGetValue(v15, CFSTR("RollbackFWVer"));
                                                  if (v166)
                                                  {
                                                    v165 = v166;
                                                    goto LABEL_132;
                                                  }
                                                  if (v152 != 1)
                                                  {
LABEL_138:
                                                    if (sub_1000EFB8C((const __CFDictionary *)v27, CFSTR("EnableDeveloperCommands")))
                                                    {
                                                      T200RestoreInfoLog("%s:%d Add Entitlements kT200TagFAEnableOption\n", v175, v176, v177, v178, v179, v180, v181, (char)"_createRequestDictForTATSU");
                                                      CFDictionaryAddValue(v129, CFSTR("BMU,EnableDeveloperCommands"), kCFBooleanTrue);
                                                    }
                                                    if (sub_1000EFB8C((const __CFDictionary *)v27, CFSTR("EnableValidationCommands")))
                                                    {
                                                      T200RestoreInfoLog("%s:%d Add Entitlements kT200TagVNVEnableOption\n", v182, v183, v184, v185, v186, v187, v188, (char)"_createRequestDictForTATSU");
                                                      CFDictionaryAddValue(v129, CFSTR("BMU,EnableValidationCommands"), kCFBooleanTrue);
                                                    }
                                                    v35 = CFRetain(v129);
                                                    T200RestoreInfoLog("%s:%d End\n", v189, v190, v191, v192, v193, v194, v195, (char)"_createRequestDictForTATSU");
                                                    v81 = 0;
                                                    v196 = v129;
                                                    v197 = 1;
LABEL_143:
                                                    CFRelease(v196);
                                                    if (v249)
                                                      CFRelease(v249);
                                                    if ((v197 & 1) != 0)
                                                    {
                                                      if (v35)
                                                      {
                                                        T200RestoreInfoLog("%s:%d End\n", v198, v199, v200, v201, v202, v203, v204, (char)"__T200UpdaterCreateRequestWithLogging");
LABEL_20:
                                                        CFRelease(v26);
                                                        v36 = v35;
LABEL_21:
                                                        if (!v12)
                                                          goto LABEL_23;
                                                        goto LABEL_22;
                                                      }
                                                      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "requestDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 762, 0);
                                                      v218 = "TATSU request dict is NULL";
                                                      v219 = "_createRequestDictForTATSU";
                                                      v220 = 12;
                                                      v221 = v81;
                                                      goto LABEL_172;
                                                    }
                                                    goto LABEL_58;
                                                  }
LABEL_136:
                                                  if (sub_1000EFB8C((const __CFDictionary *)v27, CFSTR("RollbackFWVer")))
                                                  {
LABEL_137:
                                                    T200RestoreInfoLog("%s:%d Add Entitlements kT200TagEFFV\n", v168, v169, v170, v171, v172, v173, v174, (char)"_createRequestDictForTATSU");
                                                    CFDictionaryAddValue(v129, CFSTR("BMU,EnableFutureFWVersion"), kCFBooleanTrue);
                                                    goto LABEL_138;
                                                  }
                                                  goto LABEL_138;
                                                }
                                                v154 = v153;
                                                v247 = v8;
                                                v155 = v152;
                                              }
                                              else
                                              {
                                                v156 = CFDictionaryGetValue(v15, CFSTR("ForceFirmwareUpgrade"));
                                                if (!v156)
                                                {
                                                  v165 = CFDictionaryGetValue(v15, CFSTR("RollbackFWVer"));
                                                  v249 = 0;
                                                  if (!v165)
                                                    goto LABEL_138;
                                                  goto LABEL_132;
                                                }
                                                v154 = v156;
                                                v247 = v8;
                                                v249 = 0;
                                                v155 = 0;
                                              }
                                              v157 = CFGetTypeID(v154);
                                              if (v157 != CFBooleanGetTypeID())
                                              {
                                                v251 = v129;
                                                fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 321, 0);
                                                v8 = v247;
                                                goto LABEL_164;
                                              }
                                              v152 = v155;
                                              v8 = v247;
                                              if (CFBooleanGetValue((CFBooleanRef)v154) == 1)
                                              {
LABEL_125:
                                                T200RestoreInfoLog("%s:%d Add Entitlements kT200TagFWOverWrite\n", v158, v159, v160, v161, v162, v163, v164, (char)"_createRequestDictForTATSU");
                                                CFDictionaryAddValue(v129, CFSTR("BMU,ForceFirmwareUpgrade"), kCFBooleanTrue);
                                                goto LABEL_130;
                                              }
                                              goto LABEL_130;
                                            }
                                          }
                                          v251 = v129;
                                          v216 = __stderrp;
                                          v217 = 303;
                                        }
                                        else
                                        {
                                          v251 = v129;
                                          v216 = __stderrp;
                                          v217 = 298;
                                        }
                                        fprintf(v216, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpDict && (CFGetTypeID(tmpDict) == CFDictionaryGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", v217, 0);
                                      }
                                      else
                                      {
                                        v251 = v129;
                                        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpData && (CFGetTypeID(tmpData) == CFDataGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 294, 0);
                                      }
LABEL_163:
                                      v249 = 0;
                                      goto LABEL_164;
                                    }
                                  }
                                  v251 = v129;
                                  v207 = __stderrp;
                                  v208 = 290;
LABEL_158:
                                  fprintf(v207, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpNumb && (CFGetTypeID(tmpNumb) == CFNumberGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", v208, 0);
                                  goto LABEL_163;
                                }
                              }
                              v251 = v129;
                              v205 = __stderrp;
                              v206 = 285;
                            }
                            else
                            {
                              v251 = v129;
                              v205 = __stderrp;
                              v206 = 277;
                            }
                            fprintf(v205, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", v206, 0);
                            goto LABEL_163;
                          }
                          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "requestDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 270, 0);
                          v81 = 3;
LABEL_57:
                          T200RestoreInfoLog("%s:%d End,Failed with ret=%d\n", v74, v75, v76, v77, v78, v79, v80, (char)"_createRequestDictForTATSU");
LABEL_58:
                          fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "ret == kT200Success", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 761, 0);
                          CFError = createCFError("_createRequestDictForTATSU fails.", v81, "_createRequestDictForTATSU", v81);
                          goto LABEL_14;
                        }
LABEL_56:
                        fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "measurementDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 262, 0);
                        v26 = 0;
                        v81 = 2;
                        goto LABEL_57;
                      }
                      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "NULL != firmwareBytes", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 439, 0);
                      T200RestoreInfoLog("%s:%d firmwareBytes is NULL\n", v229, v230, v231, v232, v233, v234, v235, (char)"_createMeasurementDict");
                      v96 = 13;
                      v68 = Mutable;
                    }
                    else
                    {
                      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "derDigestData!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 427, 0);
                      T200RestoreInfoLog("%s:%d derDigestData is missing in Firmwaremap.plist\n", v82, v83, v84, v85, v86, v87, v88, (char)"_createMeasurementDict");
                      value = 0;
                      v237 = 0;
                      cf = 0;
                      v239 = 0;
                      v96 = 66;
                    }
                  }
                  else
                  {
                    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "fwData!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 422, 0);
                    T200RestoreInfoLog("%s:%d fwData is NULL\n", v222, v223, v224, v225, v226, v227, v228, (char)"_createMeasurementDict");
                    value = 0;
                    v237 = 0;
                    cf = 0;
                    v239 = 0;
                    v240 = 0;
                    v243 = 0;
                    v96 = 11;
                  }
                }
                else
                {
                  fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "dataDictRef!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 419, 0);
                  value = 0;
                  v237 = 0;
                  cf = 0;
                  v239 = 0;
                  v240 = 0;
                  v243 = 0;
                  v250 = 0;
                  v96 = 13;
                }
              }
              else
              {
                fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "hw_version!=NULL", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 412, 0);
                value = 0;
                v237 = 0;
                cf = 0;
                v239 = 0;
                v240 = 0;
                v241 = 0;
                v246 = 0;
                v243 = 0;
                v250 = 0;
                v96 = 11;
              }
LABEL_61:
              v97 = v96;
              T200RestoreInfoLog("%s:%d Failed with %d\n", v89, v90, v91, v92, v93, v94, v95, (char)"_createMeasurementDict");
              v26 = 0;
              v105 = 0;
              goto LABEL_68;
            }
            fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "chemistryID!=0", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 408, 0);
            value = 0;
            v237 = 0;
            cf = 0;
            v239 = 0;
            v240 = 0;
            v241 = 0;
            v246 = 0;
            v243 = 0;
            v250 = 0;
            v96 = 11;
          }
          else
          {
            fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "measurementDict", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 403, 0);
            value = 0;
            v237 = 0;
            cf = 0;
            v239 = 0;
            v240 = 0;
            v241 = 0;
            v246 = 0;
            v243 = 0;
            v250 = 0;
            v96 = 3;
          }
          v68 = Mutable;
          goto LABEL_61;
        }
      }
      fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "fwDataRef", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 754, 0);
      CFError = createCFError("FirmwareData is NULL in input options", 2u, 0, 0);
      v26 = 0;
LABEL_13:
      a1 = 0;
LABEL_14:
      if (v8 && CFError)
      {
        *v8 = CFRetain(CFError);
        T200RestoreInfoLog("%s:%d requestDict =\n", v28, v29, v30, v31, v32, v33, v34, (char)"__T200UpdaterCreateRequestWithLogging");
      }
      else if (!CFError)
      {
        goto LABEL_19;
      }
      CFRelease(CFError);
LABEL_19:
      v35 = 0;
      v36 = 0;
      if (!v26)
        goto LABEL_21;
      goto LABEL_20;
    }
  }
  fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmpBool && (CFGetTypeID(tmpBool) == CFBooleanGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 749, 0);
  v36 = 0;
  a1 = 0;
LABEL_22:
  CFRelease(v12);
LABEL_23:
  if (v15)
    CFRelease(v15);
  if (a1)
    CFRelease(a1);
  if (v27)
    CFRelease(v27);
  if (v24)
    CFRelease(v24);
  return v36;
}

void sub_1000EF990(const void *a1)
{
  const __CFString *v1;
  const char *CStringPtr;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1)
  {
    v1 = CFCopyDescription(a1);
    CStringPtr = CFStringGetCStringPtr(v1, 0x8000100u);
    if (CStringPtr)
      T200RestoreInfoLog("[DICT] %s\n", v3, v4, v5, v6, v7, v8, v9, (char)CStringPtr);
    if (v1)
      CFRelease(v1);
  }
}

uint64_t sub_1000EF9F4(const __CFDictionary *a1)
{
  const __CFNumber *Value;
  const __CFNumber *v2;
  CFTypeID v3;
  uint64_t valuePtr;

  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(a1, CFSTR("ChemistryID"));
  if (!Value || (v2 = Value, v3 = CFGetTypeID(Value), v3 != CFNumberGetTypeID()))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFNumberGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 196, 0);
    return 0;
  }
  if (!CFNumberGetValue(v2, kCFNumberSInt64Type, &valuePtr))
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "CFNumberGetValue((CFNumberRef)tmp, kCFNumberSInt64Type, &chemistryID_sint64)", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 197, 0);
    return 0;
  }
  return valuePtr;
}

CFTypeRef sub_1000EFAD4(const __CFDictionary *a1)
{
  const void *Value;
  const void *v2;
  CFTypeID v3;
  CFTypeRef result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  Value = CFDictionaryGetValue(a1, CFSTR("HWVersion"));
  if (Value && (v2 = Value, v3 = CFGetTypeID(Value), v3 == CFStringGetTypeID()))
  {
    result = CFRetain(v2);
    if (result)
      return result;
  }
  else
  {
    fprintf(__stderrp, "AssertMacros: %s, %s file: %s, line: %d, value: %lld\n", "tmp && (CFGetTypeID(tmp)==CFStringGetTypeID())", "", "/Library/Caches/com.apple.xbs/Sources/VeridianDylibs/T200RestoreInfo/T200RestoreInfo.c", 209, 0);
  }
  T200RestoreInfoLog("%s:%d Failed getting hw_version\n", v5, v6, v7, v8, v9, v10, v11, (char)"CopyHWVersion");
  return 0;
}

uint64_t sub_1000EFB8C(const __CFDictionary *a1, const void *a2)
{
  const __CFBoolean *Value;

  if (a1 && (Value = (const __CFBoolean *)CFDictionaryGetValue(a1, a2)) != 0)
    return CFBooleanGetValue(Value);
  else
    return 0;
}

void VinylRestoreHost::create(VinylRestoreHost *this@<X0>, const __CFDictionary *a2@<X1>, VinylRestoreHost **a3@<X8>)
{
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  VinylRestoreHost *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v7 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v7, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v8, v9, v10, v11, v12, (char)"VinylRestoreHost");
  v13 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v13, 0, "%s::%s: VinylUpdater Version: %s\n", v14, v15, v16, v17, v18, (char)"VinylRestoreHost");
  v19 = (VinylRestoreHost *)operator new(0xE8uLL);
  VinylRestoreHost::VinylRestoreHost(v19);
  *a3 = v19;
  if (((*(uint64_t (**)(VinylRestoreHost *, VinylRestoreHost *, const __CFDictionary *))(*(_QWORD *)v19 + 32))(v19, this, a2) & 1) == 0)
  {
    *a3 = 0;
    (*(void (**)(VinylRestoreHost *))(*(_QWORD *)v19 + 24))(v19);
    v20 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v20, 4u, "%s::%s: leaving: VinylRestoreHost: %s\n", v21, v22, v23, v24, v25, (char)"VinylRestoreHost");
  }
}

void sub_1000EFC9C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;

  *v1 = 0;
  _Unwind_Resume(exception_object);
}

CFMutableDictionaryRef VinylRestoreHost::createRequest(CFDictionaryRef *a1, const __CFData *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFPropertyListRef v10;
  void *v11;
  uint64_t (*v12)(uint64_t);
  CFTypeID v13;
  const __CFDictionary *v14;
  uint64_t (*v15)(uint64_t);
  void *v16;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  __int128 v20;
  CFMutableDictionaryRef RequestDict;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  void *v29;
  std::string *v30;
  __int128 v31;
  std::string *v32;
  __int128 v33;
  void *v34;
  std::string *v35;
  __int128 v36;
  std::string *v37;
  __int128 v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const char *v45;
  std::string v46;
  std::string v47;
  void *__p[2];
  std::string::size_type v49;
  CFErrorRef error;
  void *v51;
  const __CFDictionary *v52;

  v51 = 0;
  v52 = 0;
  error = 0;
  v4 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v4, 0, "%s::%s: entering: %s\n", v5, v6, v7, v8, v9, (char)"VinylRestoreHost");
  v10 = CFPropertyListCreateWithData(kCFAllocatorDefault, a2, 0, 0, &error);
  v11 = v51;
  v51 = (void *)v10;
  __p[0] = v11;
  sub_1000F1A90((const void **)__p);
  v12 = ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get;
  if (!v51)
    v12 = 0;
  if (!v12)
  {
    v29 = sub_1000D3C90();
    sub_1000CB3F4(&v46, "VinylRestoreHost");
    v30 = std::string::append(&v46, "::");
    v31 = *(_OWORD *)&v30->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v30->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v31;
    v30->__r_.__value_.__l.__size_ = 0;
    v30->__r_.__value_.__r.__words[2] = 0;
    v30->__r_.__value_.__r.__words[0] = 0;
    v32 = std::string::append(&v47, "createRequest");
    v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
    v49 = v32->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v33;
    v32->__r_.__value_.__l.__size_ = 0;
    v32->__r_.__value_.__r.__words[2] = 0;
    v32->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v29, (uint64_t *)__p, 2u, (uint64_t)"Failed to create propertylist from data, error: ", (uint64_t)error);
LABEL_19:
    if (SHIBYTE(v49) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v47.__r_.__value_.__l.__data_);
    if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v46.__r_.__value_.__l.__data_);
    goto LABEL_28;
  }
  v13 = CFGetTypeID(v51);
  if (v13 != CFDictionaryGetTypeID())
  {
    v34 = sub_1000D3C90();
    sub_1000CB3F4(&v46, "VinylRestoreHost");
    v35 = std::string::append(&v46, "::");
    v36 = *(_OWORD *)&v35->__r_.__value_.__l.__data_;
    v47.__r_.__value_.__r.__words[2] = v35->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v36;
    v35->__r_.__value_.__l.__size_ = 0;
    v35->__r_.__value_.__r.__words[2] = 0;
    v35->__r_.__value_.__r.__words[0] = 0;
    v37 = std::string::append(&v47, "createRequest");
    v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
    v49 = v37->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v38;
    v37->__r_.__value_.__l.__size_ = 0;
    v37->__r_.__value_.__r.__words[2] = 0;
    v37->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v34, (uint64_t *)__p, 2u, (uint64_t)"Deserialized plist data is not a dictionary firmwarePlist: ", (uint64_t)v51);
    goto LABEL_19;
  }
  v47.__r_.__value_.__r.__words[0] = (std::string::size_type)v51;
  sub_1000F1AF4(__p, (CFTypeRef *)&v47.__r_.__value_.__l.__data_);
  v14 = v52;
  v52 = (const __CFDictionary *)__p[0];
  __p[0] = v14;
  sub_1000F1A90((const void **)__p);
  if (v52)
    v15 = ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get;
  else
    v15 = 0;
  if (!v15)
  {
    v39 = sub_1000D3C90();
    v45 = "%s::%s: Failed fo retain firmwareDict\n";
LABEL_27:
    sub_1000D3D08((uint64_t)v39, 2u, v45, v40, v41, v42, v43, v44, (char)"VinylRestoreHost");
LABEL_28:
    RequestDict = 0;
    goto LABEL_16;
  }
  v16 = sub_1000D3C90();
  sub_1000CB3F4(&v46, "VinylRestoreHost");
  v17 = std::string::append(&v46, "::");
  v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v47.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v47.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  v19 = std::string::append(&v47, "createRequest");
  v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v49 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v16, (uint64_t *)__p, 0, (uint64_t)"firmwareDict: ", (uint64_t)v52);
  if (SHIBYTE(v49) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v47.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v47.__r_.__value_.__l.__data_);
  if (SHIBYTE(v46.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v46.__r_.__value_.__l.__data_);
  RequestDict = VinylRestoreHost::createRequestDict(a1, v52);
  if (!RequestDict)
  {
    v39 = sub_1000D3C90();
    v45 = "%s::%s: failed to create output request dictionary\n";
    goto LABEL_27;
  }
LABEL_16:
  v22 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v22, 4u, "%s::%s: leaving: %s\n", v23, v24, v25, v26, v27, (char)"VinylRestoreHost");
  sub_1000F1A90((const void **)&v51);
  sub_1000F1A90((const void **)&v52);
  return RequestDict;
}

void sub_1000F0048(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  uint64_t v30;

  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  sub_1000F1A90((const void **)(v30 - 48));
  sub_1000F1A90((const void **)(v30 - 40));
  _Unwind_Resume(a1);
}

uint64_t ctu::SharedRef<void const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,void const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t ctu::SharedRef<__CFDictionary const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

CFMutableDictionaryRef VinylRestoreHost::createRequestDict(CFDictionaryRef *this, const __CFDictionary *a2)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  std::string *v17;
  __int128 v18;
  std::string *v19;
  __int128 v20;
  VinylFirmware *Value;
  VinylFirmware *v22;
  VinylFirmware *v23;
  uint64_t (*v24)(uint64_t);
  uint64_t (*v25)(uint64_t);
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v27;
  __CFDictionary *v28;
  __CFDictionary *v29;
  CFMutableDictionaryRef v30;
  uint64_t (*v31)(uint64_t);
  uint64_t (*v32)(uint64_t);
  const __CFDictionary *v33;
  const void **v34;
  const void **v35;
  const void *v36;
  const void *v37;
  const void **v38;
  const void **v39;
  const void *v40;
  const void *v41;
  const __CFDictionary *v42;
  const void *v43;
  void *v44;
  std::string *v45;
  __int128 v46;
  std::string *v47;
  __int128 v48;
  const __CFDictionary *v49;
  const void *v50;
  void *v51;
  std::string *v52;
  __int128 v53;
  std::string *v54;
  __int128 v55;
  uint64_t (*v56)(uint64_t);
  void *v57;
  std::string *v58;
  __int128 v59;
  std::string *v60;
  __int128 v61;
  uint64_t (*v62)(uint64_t);
  void *v63;
  std::string *v64;
  __int128 v65;
  std::string *v66;
  __int128 v67;
  void *v68;
  std::string *v69;
  __int128 v70;
  std::string *v71;
  __int128 v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  void *v80;
  std::string *v81;
  __int128 v82;
  std::string *v83;
  __int128 v84;
  void *v85;
  std::string *v86;
  __int128 v87;
  std::string *v88;
  __int128 v89;
  void *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const char *v96;
  void *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  const char *v103;
  void *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  std::string v110;
  std::string v111;
  void *__p[2];
  std::string::size_type v113;
  CFMutableDictionaryRef theDict;
  __CFDictionary *v115;
  void *v116;
  void *v117;

  v4 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v4, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v5, v6, v7, v8, v9, (char)"VinylRestoreHost");
  v116 = 0;
  v117 = 0;
  v115 = 0;
  theDict = 0;
  v10 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v10, 4u, "%s::%s: VinylRestoreHost::createRequestDict\n", v11, v12, v13, v14, v15, (char)"VinylRestoreHost");
  v16 = sub_1000D3C90();
  sub_1000CB3F4(&v110, "VinylRestoreHost");
  v17 = std::string::append(&v110, "::");
  v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  v19 = std::string::append(&v111, "createRequestDict");
  v20 = *(_OWORD *)&v19->__r_.__value_.__l.__data_;
  v113 = v19->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v20;
  v19->__r_.__value_.__l.__size_ = 0;
  v19->__r_.__value_.__r.__words[2] = 0;
  v19->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v16, (uint64_t *)__p, 4u, (uint64_t)"firmwareInfoDict: ", (uint64_t)a2);
  if (SHIBYTE(v113) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v111.__r_.__value_.__l.__data_);
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v110.__r_.__value_.__l.__data_);
  Value = (VinylFirmware *)CFDictionaryGetValue(a2, CFSTR("eUICC,Im4pGold"));
  v22 = (VinylFirmware *)CFDictionaryGetValue(a2, CFSTR("eUICC,Im4pMain"));
  if (!Value || (v23 = v22) == 0)
  {
    v97 = sub_1000D3C90();
    v103 = "%s::%s: failed to get im4p values\n";
    goto LABEL_89;
  }
  VinylFirmware::generateMeasurement(Value, (CFDataRef *)&v111);
  __p[0] = v117;
  v117 = (void *)v111.__r_.__value_.__r.__words[0];
  v111.__r_.__value_.__r.__words[0] = 0;
  sub_1000F1A90((const void **)__p);
  sub_1000F1A90((const void **)&v111.__r_.__value_.__l.__data_);
  VinylFirmware::generateMeasurement(v23, (CFDataRef *)&v111);
  __p[0] = v116;
  v116 = (void *)v111.__r_.__value_.__r.__words[0];
  v111.__r_.__value_.__r.__words[0] = 0;
  sub_1000F1A90((const void **)__p);
  sub_1000F1A90((const void **)&v111.__r_.__value_.__l.__data_);
  v24 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  if (v117)
    v25 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  else
    v25 = 0;
  if (!v25)
    goto LABEL_87;
  if (!v116)
    v24 = 0;
  if (!v24)
  {
LABEL_87:
    v97 = sub_1000D3C90();
    v103 = "%s::%s: failed to get measurements\n";
LABEL_89:
    sub_1000D3D08((uint64_t)v97, 2u, v103, v98, v99, v100, v101, v102, (char)"VinylRestoreHost");
LABEL_96:
    Mutable = 0;
    goto LABEL_77;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v27 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v28 = v115;
  v115 = v27;
  __p[0] = v28;
  sub_1000F1A90((const void **)__p);
  v29 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v30 = theDict;
  theDict = v29;
  __p[0] = v30;
  sub_1000F1A90((const void **)__p);
  if (!Mutable
    || (v115
      ? (v31 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get)
      : (v31 = 0),
        !v31
     || (theDict
       ? (v32 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get)
       : (v32 = 0),
         !v32)))
  {
    v90 = sub_1000D3C90();
    v96 = "%s::%s: failed to get create request Dictionary\n";
LABEL_93:
    sub_1000D3D08((uint64_t)v90, 2u, v96, v91, v92, v93, v94, v95, (char)"VinylRestoreHost");
LABEL_94:
    if (!Mutable)
      goto LABEL_77;
    goto LABEL_95;
  }
  v33 = (const __CFDictionary *)CFDictionaryGetValue(this[2], CFSTR("DeviceInfo"));
  if (!v33)
  {
    v104 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v104, 2u, "%s::%s: failed to get deviceInfoDict\n", v105, v106, v107, v108, v109, (char)"VinylRestoreHost");
LABEL_95:
    CFRelease(Mutable);
    goto LABEL_96;
  }
  v34 = (const void **)this[8];
  v35 = (const void **)this[9];
  while (v34 != v35)
  {
    v36 = *v34;
    if (!CFDictionaryGetValue(v33, *v34))
    {
      v80 = sub_1000D3C90();
      sub_1000CB3F4(&v110, "VinylRestoreHost");
      v81 = std::string::append(&v110, "::");
      v82 = *(_OWORD *)&v81->__r_.__value_.__l.__data_;
      v111.__r_.__value_.__r.__words[2] = v81->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v82;
      v81->__r_.__value_.__l.__size_ = 0;
      v81->__r_.__value_.__r.__words[2] = 0;
      v81->__r_.__value_.__r.__words[0] = 0;
      v83 = std::string::append(&v111, "createRequestDict");
      v84 = *(_OWORD *)&v83->__r_.__value_.__l.__data_;
      v113 = v83->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v84;
      v83->__r_.__value_.__l.__size_ = 0;
      v83->__r_.__value_.__r.__words[2] = 0;
      v83->__r_.__value_.__r.__words[0] = 0;
      sub_1000D42F0((uint64_t)v80, (uint64_t *)__p, 2u, (uint64_t)"Failed to find deviceTag: ", (uint64_t)v36);
LABEL_80:
      if (SHIBYTE(v113) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v111.__r_.__value_.__l.__data_);
      if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v110.__r_.__value_.__l.__data_);
      goto LABEL_94;
    }
    v37 = CFDictionaryGetValue(v33, v36);
    CFDictionarySetValue(Mutable, v36, v37);
    ++v34;
  }
  v38 = (const void **)this[11];
  v39 = (const void **)this[12];
  while (v38 != v39)
  {
    v40 = *v38;
    if (!CFDictionaryGetValue(v33, *v38))
    {
      v85 = sub_1000D3C90();
      sub_1000CB3F4(&v110, "VinylRestoreHost");
      v86 = std::string::append(&v110, "::");
      v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
      v111.__r_.__value_.__r.__words[2] = v86->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v87;
      v86->__r_.__value_.__l.__size_ = 0;
      v86->__r_.__value_.__r.__words[2] = 0;
      v86->__r_.__value_.__r.__words[0] = 0;
      v88 = std::string::append(&v111, "createRequestDict");
      v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
      v113 = v88->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v89;
      v88->__r_.__value_.__l.__size_ = 0;
      v88->__r_.__value_.__r.__words[2] = 0;
      v88->__r_.__value_.__r.__words[0] = 0;
      sub_1000D42F0((uint64_t)v85, (uint64_t *)__p, 2u, (uint64_t)"Failed to find requestTag: ", (uint64_t)v40);
      goto LABEL_80;
    }
    v41 = CFDictionaryGetValue(v33, v40);
    CFDictionarySetValue(Mutable, v40, v41);
    ++v38;
  }
  v42 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, CFSTR("eUICC,Gold"));
  v43 = CFDictionaryGetValue(v42, CFSTR("Nonce"));
  if (!v43)
  {
    v90 = sub_1000D3C90();
    v96 = "%s::%s: failed to get goldNonce\n";
    goto LABEL_93;
  }
  v44 = sub_1000D3C90();
  sub_1000CB3F4(&v110, "VinylRestoreHost");
  v45 = std::string::append(&v110, "::");
  v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v45->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v46;
  v45->__r_.__value_.__l.__size_ = 0;
  v45->__r_.__value_.__r.__words[2] = 0;
  v45->__r_.__value_.__r.__words[0] = 0;
  v47 = std::string::append(&v111, "createRequestDict");
  v48 = *(_OWORD *)&v47->__r_.__value_.__l.__data_;
  v113 = v47->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v48;
  v47->__r_.__value_.__l.__size_ = 0;
  v47->__r_.__value_.__r.__words[2] = 0;
  v47->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v44, (uint64_t *)__p, 4u, (uint64_t)"goldNonce: ", (uint64_t)v43);
  if (SHIBYTE(v113) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v111.__r_.__value_.__l.__data_);
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v110.__r_.__value_.__l.__data_);
  v49 = (const __CFDictionary *)CFDictionaryGetValue(Mutable, CFSTR("eUICC,Main"));
  v50 = CFDictionaryGetValue(v49, CFSTR("Nonce"));
  if (!v50)
  {
    v90 = sub_1000D3C90();
    v96 = "%s::%s: failed to get mainNonce\n";
    goto LABEL_93;
  }
  v51 = sub_1000D3C90();
  sub_1000CB3F4(&v110, "VinylRestoreHost");
  v52 = std::string::append(&v110, "::");
  v53 = *(_OWORD *)&v52->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v52->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v53;
  v52->__r_.__value_.__l.__size_ = 0;
  v52->__r_.__value_.__r.__words[2] = 0;
  v52->__r_.__value_.__r.__words[0] = 0;
  v54 = std::string::append(&v111, "createRequestDict");
  v55 = *(_OWORD *)&v54->__r_.__value_.__l.__data_;
  v113 = v54->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v55;
  v54->__r_.__value_.__l.__size_ = 0;
  v54->__r_.__value_.__r.__words[2] = 0;
  v54->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v51, (uint64_t *)__p, 4u, (uint64_t)"mainNonce: ", (uint64_t)v50);
  if (SHIBYTE(v113) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v111.__r_.__value_.__l.__data_);
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v110.__r_.__value_.__l.__data_);
  if (v115)
    v56 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
  else
    v56 = 0;
  if (v56)
  {
    CFDictionarySetValue(v115, CFSTR("Digest"), v117);
    CFDictionarySetValue(v115, CFSTR("Nonce"), v43);
    v57 = sub_1000D3C90();
    sub_1000CB3F4(&v110, "VinylRestoreHost");
    v58 = std::string::append(&v110, "::");
    v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v111.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    v60 = std::string::append(&v111, "createRequestDict");
    v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    v113 = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v57, (uint64_t *)__p, 4u, (uint64_t)"goldDict: ", (uint64_t)v115);
    if (SHIBYTE(v113) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v111.__r_.__value_.__l.__data_);
    if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v110.__r_.__value_.__l.__data_);
    CFDictionaryReplaceValue(Mutable, CFSTR("eUICC,Gold"), v115);
  }
  if (theDict)
    v62 = ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get;
  else
    v62 = 0;
  if (v62)
  {
    CFDictionarySetValue(theDict, CFSTR("Digest"), v116);
    CFDictionarySetValue(theDict, CFSTR("Nonce"), v50);
    v63 = sub_1000D3C90();
    sub_1000CB3F4(&v110, "VinylRestoreHost");
    v64 = std::string::append(&v110, "::");
    v65 = *(_OWORD *)&v64->__r_.__value_.__l.__data_;
    v111.__r_.__value_.__r.__words[2] = v64->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v65;
    v64->__r_.__value_.__l.__size_ = 0;
    v64->__r_.__value_.__r.__words[2] = 0;
    v64->__r_.__value_.__r.__words[0] = 0;
    v66 = std::string::append(&v111, "createRequestDict");
    v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
    v113 = v66->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v67;
    v66->__r_.__value_.__l.__size_ = 0;
    v66->__r_.__value_.__r.__words[2] = 0;
    v66->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v63, (uint64_t *)__p, 4u, (uint64_t)"mainDict: ", (uint64_t)theDict);
    if (SHIBYTE(v113) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v111.__r_.__value_.__l.__data_);
    if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v110.__r_.__value_.__l.__data_);
    CFDictionaryReplaceValue(Mutable, CFSTR("eUICC,Main"), theDict);
  }
  v68 = sub_1000D3C90();
  sub_1000CB3F4(&v110, "VinylRestoreHost");
  v69 = std::string::append(&v110, "::");
  v70 = *(_OWORD *)&v69->__r_.__value_.__l.__data_;
  v111.__r_.__value_.__r.__words[2] = v69->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v111.__r_.__value_.__l.__data_ = v70;
  v69->__r_.__value_.__l.__size_ = 0;
  v69->__r_.__value_.__r.__words[2] = 0;
  v69->__r_.__value_.__r.__words[0] = 0;
  v71 = std::string::append(&v111, "createRequestDict");
  v72 = *(_OWORD *)&v71->__r_.__value_.__l.__data_;
  v113 = v71->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v72;
  v71->__r_.__value_.__l.__size_ = 0;
  v71->__r_.__value_.__r.__words[2] = 0;
  v71->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v68, (uint64_t *)__p, 4u, (uint64_t)"requestDict after digest: ", (uint64_t)Mutable);
  if (SHIBYTE(v113) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v111.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v111.__r_.__value_.__l.__data_);
  if (SHIBYTE(v110.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v110.__r_.__value_.__l.__data_);
  v73 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v73, 4u, "%s::%s: leaving: VinylRestoreHost: %s\n", v74, v75, v76, v77, v78, (char)"VinylRestoreHost");
LABEL_77:
  sub_1000F1A90((const void **)&theDict);
  sub_1000F1A90((const void **)&v115);
  sub_1000F1A90((const void **)&v116);
  sub_1000F1A90((const void **)&v117);
  return Mutable;
}

void sub_1000F0AC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30,uint64_t a31,const void *a32)
{
  uint64_t v32;

  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  sub_1000F1A90(&a32);
  sub_1000F1A90((const void **)(v32 - 104));
  sub_1000F1A90((const void **)(v32 - 96));
  sub_1000F1A90((const void **)(v32 - 88));
  _Unwind_Resume(a1);
}

void VinylRestoreHost::~VinylRestoreHost(VinylRestoreHost *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = off_100183B38;
  v2 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v2, 4u, "%s::%s: VinylRestoreHost: destructor\n", v3, v4, v5, v6, v7, (char)"VinylRestoreHost");
  sub_1000D2814((uint64_t)this);
}

{
  void *v1;

  VinylRestoreHost::~VinylRestoreHost(this);
  operator delete(v1);
}

void VinylRestoreHost::VinylRestoreHost(VinylRestoreHost *this)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)sub_1000D3018((uint64_t)this) = off_100183B38;
  v1 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v1, 4u, "%s::%s: VinylRestoreHost: constructor\n", v2, v3, v4, v5, v6, (char)"VinylRestoreHost");
}

void sub_1000F0C9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  sub_1000D2814(v1);
  _Unwind_Resume(a1);
}

uint64_t VinylRestoreHost::init(VinylRestoreHost *this, const __CFDictionary *a2, const __CFString *a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeID TypeID;
  CFTypeID v13;
  CFTypeID v14;
  CFTypeID v15;
  CFTypeID v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __int128 __src;
  __int128 v26;
  __int128 v27;
  _QWORD v28[4];
  unint64_t v29;

  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v7, v8, v9, v10, v11, (char)"VinylRestoreHost");
  __src = *(_OWORD *)&off_100183B68;
  *(_QWORD *)&v26 = CFSTR("eUICC,Main");
  sub_1000CB638((char *)this + 40, (char *)&__src, (uint64_t)&v26 + 8, 3uLL);
  __src = *(_OWORD *)&off_100183B80;
  v26 = *(_OWORD *)&off_100183B90;
  v27 = *(_OWORD *)&off_100183BA0;
  sub_1000CB638((char *)this + 64, (char *)&__src, (uint64_t)v28, 6uLL);
  *(_QWORD *)&__src = CFSTR("@eUICC,Ticket");
  sub_1000CB638((char *)this + 88, (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  *(_QWORD *)&__src = CFSTR("eUICC,Ticket");
  sub_1000CB638((char *)this + 112, (char *)&__src, (uint64_t)&__src + 8, 1uLL);
  TypeID = CFNumberGetTypeID();
  *(_QWORD *)&__src = CFSTR("eUICC,ChipID");
  *((_QWORD *)&__src + 1) = TypeID;
  v13 = CFDataGetTypeID();
  *(_QWORD *)&v26 = CFSTR("eUICC,EID");
  *((_QWORD *)&v26 + 1) = v13;
  v14 = CFDataGetTypeID();
  *(_QWORD *)&v27 = CFSTR("eUICC,GoldNonce");
  *((_QWORD *)&v27 + 1) = v14;
  v15 = CFDataGetTypeID();
  v28[0] = CFSTR("eUICC,MainNonce");
  v28[1] = v15;
  v16 = CFDataGetTypeID();
  v28[2] = CFSTR("eUICC,RootKeyIdentifier");
  v28[3] = v16;
  sub_1000CB94C((uint64_t **)this + 20, (unint64_t *)&__src, &v29);
  *(_QWORD *)&__src = CFSTR("eUICC,Gold");
  WORD4(__src) = 0;
  *(_QWORD *)&v26 = CFSTR("eUICC,Main");
  WORD4(v26) = 0;
  sub_1000CBE6C((uint64_t **)this + 25, (unint64_t *)&__src, (unint64_t *)&v27);
  __src = off_100183BB0;
  v26 = *(_OWORD *)&off_100183BC0;
  sub_1000CB7C8((char *)this + 136, (char *)&__src, (uint64_t)&v27, 2uLL);
  *((_QWORD *)this + 28) = CFSTR("Vinyl");
  v17 = sub_1000D28CC((uint64_t)this, (uint64_t)a2, a3);
  v18 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v18, 4u, "%s::%s: leaving: VinylRestoreHost: %s\n", v19, v20, v21, v22, v23, (char)"VinylRestoreHost");
  return v17;
}

uint64_t ctu::SharedRef<__CFDictionary,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFDictionary>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

const __CFData *VinylRestoreHost::copyFirmwareUpdater(uint64_t a1, const __CFDictionary *a2, int a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *Value;
  const __CFDictionary *v13;
  CFTypeID v14;
  void *v15;
  std::string *v16;
  __int128 v17;
  std::string *v18;
  __int128 v19;
  const __CFData *v20;
  const __CFData *v21;
  CFTypeID v22;
  void *v23;
  std::string *v24;
  __int128 v25;
  std::string *v26;
  __int128 v27;
  const __CFData *v28;
  const __CFData *v29;
  CFTypeID v30;
  void *v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  __int128 v35;
  const __CFData *v36;
  const __CFData *v37;
  CFTypeID v38;
  void *v39;
  std::string *v40;
  __int128 v41;
  std::string *v42;
  __int128 v43;
  const __CFData *v44;
  const __CFData *v45;
  CFTypeID v46;
  void *v47;
  std::string *v48;
  __int128 v49;
  std::string *v50;
  __int128 v51;
  void *v52;
  std::string *v53;
  __int128 v54;
  std::string *v55;
  __int128 v56;
  __CFString *v57;
  const __CFData *v58;
  void *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  std::string *v66;
  __int128 v67;
  std::string *v68;
  __int128 v69;
  VinylFirmware *v70;
  VinylFirmware *v71;
  VinylFirmware *v72;
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v74;
  const void *Im4p;
  const void *FwData;
  const void *RecoveryFwData;
  const void *InfoPlistData;
  const void *ProfileData;
  const void *v80;
  const void *v81;
  const void *v82;
  const void *v83;
  const void *v84;
  CFDataRef v85;
  void *v86;
  std::string *v87;
  __int128 v88;
  std::string *v89;
  __int128 v90;
  void *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  void *v98;
  void *v99;
  void *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  void *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  void *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  void *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  void *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  void *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  void *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  void *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  std::string *v149;
  __int128 v150;
  std::string *v151;
  __int128 v152;
  std::string v153;
  std::string v154;
  void *__p[2];
  std::string::size_type v156;
  CFErrorRef error;

  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 4u, "%s::%s: entering: VinylRestoreHost: %s\n", v7, v8, v9, v10, v11, (char)"VinylRestoreHost");
  error = 0;
  if (!a2)
  {
    v131 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v131, 2u, "%s::%s: firmwareFileDictionary is null\n", v132, v133, v134, v135, v136, (char)"VinylRestoreHost");
    return 0;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), CFSTR("DeviceInfo"));
  if (!Value || (v13 = Value, v14 = CFGetTypeID(Value), v14 != CFDictionaryGetTypeID()))
  {
    v101 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v101, 2u, "%s::%s: Deviceinfo is not a dictionary\n", v102, v103, v104, v105, v106, (char)"VinylRestoreHost");
    return 0;
  }
  v15 = sub_1000D3C90();
  sub_1000CB3F4(&v153, "VinylRestoreHost");
  v16 = std::string::append(&v153, "::");
  v17 = *(_OWORD *)&v16->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v16->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v17;
  v16->__r_.__value_.__l.__size_ = 0;
  v16->__r_.__value_.__r.__words[2] = 0;
  v16->__r_.__value_.__r.__words[0] = 0;
  v18 = std::string::append(&v154, "copyFirmwareUpdater");
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v156 = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v15, (uint64_t *)__p, 4u, (uint64_t)"VinylRestore::copyFirmwareUpdater kUpdaterDeviceInfo value : ", (uint64_t)v13);
  if (SHIBYTE(v156) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v153.__r_.__value_.__l.__data_);
  v20 = (const __CFData *)CFDictionaryGetValue(v13, CFSTR("eUICC,RootKeyIdentifier"));
  if (!v20 || (v21 = v20, v22 = CFGetTypeID(v20), v22 != CFDataGetTypeID()))
  {
    v107 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v107, 2u, "%s::%s: certIdentifier is not a CFData type\n", v108, v109, v110, v111, v112, (char)"VinylRestoreHost");
    return 0;
  }
  v23 = sub_1000D3C90();
  sub_1000CB3F4(&v153, "VinylRestoreHost");
  v24 = std::string::append(&v153, "::");
  v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  v26 = std::string::append(&v154, "copyFirmwareUpdater");
  v27 = *(_OWORD *)&v26->__r_.__value_.__l.__data_;
  v156 = v26->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v27;
  v26->__r_.__value_.__l.__size_ = 0;
  v26->__r_.__value_.__r.__words[2] = 0;
  v26->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v23, (uint64_t *)__p, 4u, (uint64_t)"VinylTransport::getTicket  certIdentifier: ", (uint64_t)v21);
  if (SHIBYTE(v156) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v153.__r_.__value_.__l.__data_);
  v28 = (const __CFData *)CFDictionaryGetValue(v13, CFSTR("eUICC,FirmwareLoaderVersion"));
  if (!v28 || (v29 = v28, v30 = CFGetTypeID(v28), v30 != CFDataGetTypeID()))
  {
    v113 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v113, 2u, "%s::%s: firmwareLoaderVersion is not a CFData type\n", v114, v115, v116, v117, v118, (char)"VinylRestoreHost");
    return 0;
  }
  v31 = sub_1000D3C90();
  sub_1000CB3F4(&v153, "VinylRestoreHost");
  v32 = std::string::append(&v153, "::");
  v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  v34 = std::string::append(&v154, "copyFirmwareUpdater");
  v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  v156 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v31, (uint64_t *)__p, 4u, (uint64_t)"VinylTransport::getTicket  firmwareLoaderVersion: ", (uint64_t)v29);
  if (SHIBYTE(v156) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v153.__r_.__value_.__l.__data_);
  v36 = (const __CFData *)CFDictionaryGetValue(v13, CFSTR("eUICC,MainFwMac"));
  if (!v36 || (v37 = v36, v38 = CFGetTypeID(v36), v38 != CFDataGetTypeID()))
  {
    v119 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v119, 2u, "%s::%s: mainFwMac is not a CFData type\n", v120, v121, v122, v123, v124, (char)"VinylRestoreHost");
    return 0;
  }
  v39 = sub_1000D3C90();
  sub_1000CB3F4(&v153, "VinylRestoreHost");
  v40 = std::string::append(&v153, "::");
  v41 = *(_OWORD *)&v40->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v40->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v41;
  v40->__r_.__value_.__l.__size_ = 0;
  v40->__r_.__value_.__r.__words[2] = 0;
  v40->__r_.__value_.__r.__words[0] = 0;
  v42 = std::string::append(&v154, "copyFirmwareUpdater");
  v43 = *(_OWORD *)&v42->__r_.__value_.__l.__data_;
  v156 = v42->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v43;
  v42->__r_.__value_.__l.__size_ = 0;
  v42->__r_.__value_.__r.__words[2] = 0;
  v42->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v39, (uint64_t *)__p, 4u, (uint64_t)"VinylTransport::getTicket  mainFwMac: ", (uint64_t)v37);
  if (SHIBYTE(v156) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v153.__r_.__value_.__l.__data_);
  v44 = (const __CFData *)CFDictionaryGetValue(v13, CFSTR("eUICC,GoldFwMac"));
  if (!v44 || (v45 = v44, v46 = CFGetTypeID(v44), v46 != CFDataGetTypeID()))
  {
    v125 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v125, 2u, "%s::%s: goldFwMac is not a CFData type\n", v126, v127, v128, v129, v130, (char)"VinylRestoreHost");
    return 0;
  }
  v47 = sub_1000D3C90();
  sub_1000CB3F4(&v153, "VinylRestoreHost");
  v48 = std::string::append(&v153, "::");
  v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v49;
  v48->__r_.__value_.__l.__size_ = 0;
  v48->__r_.__value_.__r.__words[2] = 0;
  v48->__r_.__value_.__r.__words[0] = 0;
  v50 = std::string::append(&v154, "copyFirmwareUpdater");
  v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
  v156 = v50->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v51;
  v50->__r_.__value_.__l.__size_ = 0;
  v50->__r_.__value_.__r.__words[2] = 0;
  v50->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v47, (uint64_t *)__p, 0, (uint64_t)"VinylTransport::getTicket  goldFwMac: ", (uint64_t)v45);
  if (SHIBYTE(v156) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v153.__r_.__value_.__l.__data_);
  v52 = sub_1000D3C90();
  sub_1000CB3F4(&v153, "VinylRestoreHost");
  v53 = std::string::append(&v153, "::");
  v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v54;
  v53->__r_.__value_.__l.__size_ = 0;
  v53->__r_.__value_.__r.__words[2] = 0;
  v53->__r_.__value_.__r.__words[0] = 0;
  v55 = std::string::append(&v154, "copyFirmwareUpdater");
  v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
  v156 = v55->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v56;
  v55->__r_.__value_.__l.__size_ = 0;
  v55->__r_.__value_.__r.__words[2] = 0;
  v55->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v52, (uint64_t *)__p, 4u, (uint64_t)"Firmware File Dictionary: ", (uint64_t)a2);
  if (SHIBYTE(v156) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v153.__r_.__value_.__l.__data_);
  if (CFDictionaryContainsKey(a2, *(const void **)(a1 + 8)))
    v57 = *(__CFString **)(a1 + 8);
  else
    v57 = CFSTR("eUICC,Gold");
  v58 = (const __CFData *)sub_1000D29F8(v57, a2, a3);
  v59 = sub_1000D3C90();
  v65 = (uint64_t)v59;
  if (!v58)
  {
    sub_1000D3D08((uint64_t)v59, 2u, "%s::%s: failed to get fwZipData\n", v60, v61, v62, v63, v64, (char)"VinylRestoreHost");
    return v58;
  }
  sub_1000CB3F4(&v153, "VinylRestoreHost");
  v66 = std::string::append(&v153, "::");
  v67 = *(_OWORD *)&v66->__r_.__value_.__l.__data_;
  v154.__r_.__value_.__r.__words[2] = v66->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v67;
  v66->__r_.__value_.__l.__size_ = 0;
  v66->__r_.__value_.__r.__words[2] = 0;
  v66->__r_.__value_.__r.__words[0] = 0;
  v68 = std::string::append(&v154, "copyFirmwareUpdater");
  v69 = *(_OWORD *)&v68->__r_.__value_.__l.__data_;
  v156 = v68->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v69;
  v68->__r_.__value_.__l.__size_ = 0;
  v68->__r_.__value_.__r.__words[2] = 0;
  v68->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0(v65, (uint64_t *)__p, 4u, (uint64_t)"fwData: ", (uint64_t)v58);
  if (SHIBYTE(v156) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v154.__r_.__value_.__l.__data_);
  if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v153.__r_.__value_.__l.__data_);
  v70 = VinylGoldFirmwareCreate(v58, v21, v29, v45);
  v71 = VinylMainFirmwareCreate(v58, v21, v29, v37);
  v72 = v71;
  if (v70 && v71)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v74 = Mutable;
      Im4p = (const void *)VinylFirmware::getIm4p(v70);
      CFDictionarySetValue(v74, CFSTR("eUICC,Im4pGold"), Im4p);
      FwData = (const void *)VinylFirmware::getFwData(v70);
      CFDictionarySetValue(v74, CFSTR("eUICC,Gold"), FwData);
      if (VinylFirmware::getRecoveryFwData(v70))
      {
        RecoveryFwData = (const void *)VinylFirmware::getRecoveryFwData(v70);
        CFDictionarySetValue(v74, CFSTR("eUICC,GoldRecoveryFw"), RecoveryFwData);
      }
      InfoPlistData = (const void *)VinylFirmware::getInfoPlistData(v70);
      CFDictionarySetValue(v74, CFSTR("eUICC,InfoPlistDataGold"), InfoPlistData);
      ProfileData = (const void *)VinylFirmware::getProfileData(v70);
      CFDictionarySetValue(v74, CFSTR("eUICC,ProfileDataGold"), ProfileData);
      v80 = (const void *)VinylFirmware::getIm4p(v72);
      CFDictionarySetValue(v74, CFSTR("eUICC,Im4pMain"), v80);
      v81 = (const void *)VinylFirmware::getFwData(v72);
      CFDictionarySetValue(v74, CFSTR("eUICC,Main"), v81);
      if (VinylFirmware::getRecoveryFwData(v72))
      {
        v82 = (const void *)VinylFirmware::getRecoveryFwData(v72);
        CFDictionarySetValue(v74, CFSTR("eUICC,MainRecoveryFw"), v82);
      }
      v83 = (const void *)VinylFirmware::getInfoPlistData(v72);
      CFDictionarySetValue(v74, CFSTR("eUICC,InfoPlistDataMain"), v83);
      v84 = (const void *)VinylFirmware::getProfileData(v72);
      CFDictionarySetValue(v74, CFSTR("eUICC,ProfileDataMain"), v84);
      v85 = CFPropertyListCreateData(kCFAllocatorDefault, v74, kCFPropertyListXMLFormat_v1_0, 0, &error);
      v86 = sub_1000D3C90();
      sub_1000CB3F4(&v153, "VinylRestoreHost");
      v87 = std::string::append(&v153, "::");
      v88 = *(_OWORD *)&v87->__r_.__value_.__l.__data_;
      v154.__r_.__value_.__r.__words[2] = v87->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v88;
      v87->__r_.__value_.__l.__size_ = 0;
      v87->__r_.__value_.__r.__words[2] = 0;
      v87->__r_.__value_.__r.__words[0] = 0;
      v89 = std::string::append(&v154, "copyFirmwareUpdater");
      v90 = *(_OWORD *)&v89->__r_.__value_.__l.__data_;
      v156 = v89->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v90;
      v89->__r_.__value_.__l.__size_ = 0;
      v89->__r_.__value_.__r.__words[2] = 0;
      v89->__r_.__value_.__r.__words[0] = 0;
      sub_1000D42F0((uint64_t)v86, (uint64_t *)__p, 0, (uint64_t)"firmwareInfoDict: ", (uint64_t)v74);
      if (SHIBYTE(v156) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v154.__r_.__value_.__l.__data_);
      if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v153.__r_.__value_.__l.__data_);
      v91 = sub_1000D3C90();
      v97 = (uint64_t)v91;
      if (v85)
      {
        sub_1000D3D08((uint64_t)v91, 0, "%s::%s: leaving: VinylRestoreHost: %s\n", v92, v93, v94, v95, v96, (char)"VinylRestoreHost");
      }
      else
      {
        sub_1000CB3F4(&v153, "VinylRestoreHost");
        v149 = std::string::append(&v153, "::");
        v150 = *(_OWORD *)&v149->__r_.__value_.__l.__data_;
        v154.__r_.__value_.__r.__words[2] = v149->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v154.__r_.__value_.__l.__data_ = v150;
        v149->__r_.__value_.__l.__size_ = 0;
        v149->__r_.__value_.__r.__words[2] = 0;
        v149->__r_.__value_.__r.__words[0] = 0;
        v151 = std::string::append(&v154, "copyFirmwareUpdater");
        v152 = *(_OWORD *)&v151->__r_.__value_.__l.__data_;
        v156 = v151->__r_.__value_.__r.__words[2];
        *(_OWORD *)__p = v152;
        v151->__r_.__value_.__l.__size_ = 0;
        v151->__r_.__value_.__r.__words[2] = 0;
        v151->__r_.__value_.__r.__words[0] = 0;
        sub_1000D42F0(v97, (uint64_t *)__p, 2u, (uint64_t)"Failed to serialize dictionary, error: ", (uint64_t)error);
        if (SHIBYTE(v156) < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v154.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v154.__r_.__value_.__l.__data_);
        if (SHIBYTE(v153.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v153.__r_.__value_.__l.__data_);
      }
      CFRelease(v74);
    }
    else
    {
      v143 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v143, 2u, "%s::%s: failed to get create firmwareInfoDict\n", v144, v145, v146, v147, v148, (char)"VinylRestoreHost");
      v85 = 0;
    }
    CFRelease(v58);
    goto LABEL_75;
  }
  v137 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v137, 2u, "%s::%s: failed to get firmware object\n", v138, v139, v140, v141, v142, (char)"VinylRestoreHost");
  CFRelease(v58);
  v85 = 0;
  v58 = 0;
  if (v70)
  {
LABEL_75:
    VinylFirmware::~VinylFirmware(v70);
    operator delete(v98);
    v58 = v85;
  }
  if (v72)
  {
    VinylFirmware::~VinylFirmware(v72);
    operator delete(v99);
  }
  return v58;
}

void sub_1000F19E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

const void **sub_1000F1A90(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

_QWORD *sub_1000F1AC0(_QWORD *a1, CFTypeRef cf)
{
  *a1 = cf;
  if (cf)
    CFRetain(cf);
  return a1;
}

_QWORD *sub_1000F1AF4(_QWORD *a1, CFTypeRef *a2)
{
  CFTypeRef v3;
  CFTypeID v4;
  const void *v5;

  v3 = *a2;
  if (*a2)
  {
    v4 = CFGetTypeID(*a2);
    if (v4 == CFDictionaryGetTypeID())
      v5 = v3;
    else
      v5 = 0;
  }
  else
  {
    v5 = 0;
  }
  return sub_1000F1AC0(a1, v5);
}

uint64_t vinyl_unzStringFileNameCompare(const char *a1, const char *a2, int a3)
{
  int v4;
  int v5;
  int v6;
  int v7;

  if (a3 == 1)
    return strcmp(a1, a2);
  while (1)
  {
    v5 = *(unsigned __int8 *)a1++;
    v4 = v5;
    v7 = *(unsigned __int8 *)a2++;
    v6 = v7;
    if ((v4 - 97) < 0x1A)
      LOBYTE(v4) = v4 - 32;
    if ((v6 - 97) < 0x1A)
      LOBYTE(v6) = v6 - 32;
    if (!(_BYTE)v4)
      break;
    if (!(_BYTE)v6)
      return 1;
    if ((char)v4 < (char)v6)
      return 0xFFFFFFFFLL;
    if ((char)v4 > (char)v6)
      return 1;
  }
  if ((_BYTE)v6)
    return 0xFFFFFFFFLL;
  else
    return 0;
}

_QWORD *vinyl_unzOpen2(uint64_t a1, _OWORD *a2, uint64_t a3)
{
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  _BYTE *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v21;
  unint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _OWORD __src[22];

  memset(__src, 0, 336);
  if (a2)
  {
    v5 = a2[1];
    __src[0] = *a2;
    __src[1] = v5;
    v6 = a2[3];
    __src[2] = a2[2];
    __src[3] = v6;
    v7 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))&__src[0])(*((_QWORD *)&v6 + 1), a1, 5, a3);
  }
  else
  {
    vinyl_fill_fopen_filefunc((FILE *(**)(int, void *, int, size_t))__src);
    v7 = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t))&__src[0])(*((_QWORD *)&__src[3] + 1), a1, 5, a3);
  }
  v8 = (_QWORD *)v7;
  *(_QWORD *)&__src[4] = v7;
  if (v7)
  {
    if (!(*(uint64_t (**)(_QWORD, uint64_t, _QWORD, uint64_t))&__src[2])(*((_QWORD *)&__src[3] + 1), v7, 0, 2))
    {
      v9 = (*((uint64_t (**)(_QWORD, _QWORD *))&__src[1] + 1))(*((_QWORD *)&__src[3] + 1), v8);
      v10 = v9;
      v11 = v9 >= 0xFFFF ? 0xFFFFLL : v9;
      v12 = (char *)malloc(0x404uLL);
      if (v12)
      {
        v13 = v12;
        if (v11 >= 5)
        {
          v14 = v12 + 1;
          v15 = 4;
          do
          {
            v16 = v15 + 1024;
            v17 = v15 + 1024 >= v11 ? v11 : v15 + 1024;
            v18 = v17 >= 0x404 ? 1028 : v17;
            if ((*(uint64_t (**)(_QWORD, _QWORD *, unint64_t, _QWORD))&__src[2])(*((_QWORD *)&__src[3] + 1), v8, v10 - v17, 0)|| (*((uint64_t (**)(_QWORD, _QWORD *, _BYTE *, unint64_t))&__src[0] + 1))(*((_QWORD *)&__src[3] + 1), v8, v13, v18) != v18)
            {
              break;
            }
            if (v18 >= 4)
            {
              v19 = (v18 - 4);
              while (v13[v19] != 80 || v14[v19] != 75 || v14[v19 + 1] != 5 || v14[v19 + 2] != 6)
              {
                if (v19-- <= 0)
                  goto LABEL_28;
              }
              if (v10 - v17 + v19)
              {
                free(v13);
                v21 = v15 + 1024;
                if (v10 < v15 + 1024)
                  v21 = v10;
                if (v21 >= 0xFFFF)
                  v21 = 0xFFFFLL;
                v22 = v10 - v21 + v19;
                v37 = 1;
                goto LABEL_38;
              }
            }
LABEL_28:
            v15 = v17;
          }
          while (v11 > v16);
        }
        free(v13);
      }
    }
    v22 = 0;
    v37 = 0;
LABEL_38:
    v39 = 0;
    v40 = 0;
    v38 = 0;
    v33 = (*(uint64_t (**)(_QWORD, _QWORD, unint64_t, _QWORD))&__src[2])(*((_QWORD *)&__src[3] + 1), *(_QWORD *)&__src[4], v22, 0);
    v34 = sub_1000F1F40((uint64_t)__src, *(uint64_t *)&__src[4], &v41);
    v35 = sub_1000F1FF8((uint64_t)__src, *(uint64_t *)&__src[4], &v40);
    v36 = sub_1000F1FF8((uint64_t)__src, *(uint64_t *)&__src[4], &v39);
    v23 = sub_1000F1FF8((uint64_t)__src, *(uint64_t *)&__src[4], (_QWORD *)&__src[4] + 1);
    v24 = sub_1000F1FF8((uint64_t)__src, *(uint64_t *)&__src[4], &v38);
    v26 = v38;
    v25 = v39;
    v27 = v40;
    v28 = *((_QWORD *)&__src[4] + 1);
    v29 = sub_1000F1F40((uint64_t)__src, *(uint64_t *)&__src[4], (uint64_t *)&__src[8]);
    v30 = sub_1000F1F40((uint64_t)__src, *(uint64_t *)&__src[4], (uint64_t *)&__src[8] + 1);
    v31 = sub_1000F1FF8((uint64_t)__src, *(uint64_t *)&__src[4], &__src[5]);
    if (v22 < *(_QWORD *)&__src[8] + *((_QWORD *)&__src[8] + 1)
      || v31
      || v30
      || v29
      || v26 != v28
      || v25
      || v27
      || !v37
      || v24
      || v23
      || v36
      || v35
      || v34
      || v33)
    {
      (*((void (**)(_QWORD, _QWORD))&__src[2] + 1))(*((_QWORD *)&__src[3] + 1), *(_QWORD *)&__src[4]);
      return 0;
    }
    else
    {
      *((_QWORD *)&__src[5] + 1) = v22 - (*(_QWORD *)&__src[8] + *((_QWORD *)&__src[8] + 1));
      *((_QWORD *)&__src[7] + 1) = v22;
      *(_QWORD *)&__src[18] = 0;
      DWORD2(__src[18]) = 0;
      v8 = malloc(0x150uLL);
      memcpy(v8, __src, 0x150uLL);
      vinyl_unzGoToFirstFile(v8);
    }
  }
  return v8;
}

uint64_t sub_1000F1F40(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t result;
  uint64_t v10;
  int v11;

  v11 = 0;
  if (sub_1000F3194(a1, a2, &v11)
    || (v6 = v11, sub_1000F3194(a1, a2, &v11))
    || (v7 = v11, sub_1000F3194(a1, a2, &v11)))
  {
    v8 = 0;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v10 = v6 + (v7 << 8) + ((uint64_t)v11 << 16);
    result = sub_1000F3194(a1, a2, &v11);
    v8 = v10 + ((uint64_t)v11 << 24);
    if ((_DWORD)result)
      v8 = 0;
  }
  *a3 = v8;
  return result;
}

uint64_t sub_1000F1FF8(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  int v9;

  v9 = 0;
  if (sub_1000F3194(a1, a2, &v9))
  {
    v6 = 0;
    result = 0xFFFFFFFFLL;
  }
  else
  {
    v8 = v9;
    result = sub_1000F3194(a1, a2, &v9);
    v6 = v8 + ((uint64_t)v9 << 8);
    if ((_DWORD)result)
      v6 = 0;
  }
  *a3 = v6;
  return result;
}

uint64_t vinyl_unzGoToFirstFile(_QWORD *a1)
{
  uint64_t v2;
  uint64_t result;

  if (!a1)
    return 4294967194;
  v2 = a1[17];
  a1[12] = 0;
  a1[13] = v2;
  result = sub_1000F2200((uint64_t)a1, (uint64_t)(a1 + 18), a1 + 35, 0, 0, 0, 0, 0, 0);
  a1[14] = (_DWORD)result == 0;
  return result;
}

_QWORD *vinyl_unzOpen(uint64_t a1, uint64_t a2)
{
  return vinyl_unzOpen2(a1, 0, a2);
}

uint64_t vinyl_unzClose(uint64_t a1)
{
  if (!a1)
    return 4294967194;
  if (*(_QWORD *)(a1 + 288))
    vinyl_unzCloseCurrentFile(a1);
  (*(void (**)(_QWORD, _QWORD))(a1 + 40))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
  free((void *)a1);
  return 0;
}

uint64_t vinyl_unzCloseCurrentFile(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  if (!a1)
    return 4294967194;
  v2 = *(_QWORD *)(a1 + 288);
  if (!v2)
    return 4294967194;
  if (*(_QWORD *)(v2 + 184) || *(_DWORD *)(v2 + 280))
  {
    v3 = 0;
  }
  else if (*(_QWORD *)(v2 + 160) == *(_QWORD *)(v2 + 168))
  {
    v3 = 0;
  }
  else
  {
    v3 = 4294967191;
  }
  if (*(_QWORD *)v2)
    free(*(void **)v2);
  *(_QWORD *)v2 = 0;
  if (*(_QWORD *)(v2 + 128))
    inflateEnd((z_streamp)(v2 + 8));
  free((void *)v2);
  *(_QWORD *)(a1 + 288) = 0;
  return v3;
}

uint64_t vinyl_unzGetCurrentFileInfo(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, uint64_t a7, unint64_t a8)
{
  return sub_1000F2200(a1, a2, 0, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_1000F2200(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, unint64_t a5, uint64_t a6, unint64_t a7, uint64_t a8, unint64_t a9)
{
  int v10;
  uint32x4_t v11;
  int8x16_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  int8x16_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  unsigned int v50;
  uint64_t v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  int8x16_t v63;
  uint64_t v64;

  if (!a1)
    return 4294967194;
  if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 104), 0)|| (v54 = 0, sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), &v54)))
  {
    v10 = -1;
  }
  else if (v54 == 33639248)
  {
    v10 = 0;
  }
  else
  {
    v10 = -103;
  }
  v50 = v10;
  v64 = 0;
  v62 = 0u;
  v63 = 0u;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v55 = 0;
  v49 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v56);
  v48 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), (_QWORD *)&v56 + 1);
  v47 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v57);
  v46 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), (_QWORD *)&v57 + 1);
  v45 = sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), (uint64_t *)&v58);
  LODWORD(v64) = ((v58 >> 21) & 0xF) - 1;
  HIDWORD(v64) = (v58 >> 25) + 1980;
  v11.i32[0] = v58;
  v12 = (int8x16_t)vshlq_u32((uint32x4_t)vdupq_n_s32(v58), (uint32x4_t)xmmword_100167120);
  v12.i32[0] = vshlq_u32(v11, (uint32x4_t)xmmword_100167110).u32[0];
  v63 = vandq_s8(v12, (int8x16_t)xmmword_100167130);
  v13 = sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), (uint64_t *)&v58 + 1);
  v14 = sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), (uint64_t *)&v59);
  v15 = sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), (uint64_t *)&v59 + 1);
  v16 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v60);
  v17 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), (_QWORD *)&v60 + 1);
  v18 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v61);
  v19 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), (_QWORD *)&v61 + 1);
  v20 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v62);
  v21 = sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), (uint64_t *)&v62 + 1);
  if (sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), &v55) | v21 | v20 | v19 | v18 | v17 | v16 | v15 | v14 | v13 | v45 | v46 | v47 | v48 | v49)
    v22 = 0xFFFFFFFFLL;
  else
    v22 = v50;
  v23 = v60;
  if (a4)
  {
    v25 = a7;
    v24 = a6;
    if ((_DWORD)v22)
    {
      v28 = a2;
      v27 = a3;
      v29 = a8;
    }
    else
    {
      v26 = a5;
      if ((unint64_t)v60 < a5)
      {
        *(_BYTE *)(a4 + v60) = 0;
        v26 = v23;
      }
      v22 = 0;
      if (a5)
      {
        v28 = a2;
        v27 = a3;
        v29 = a8;
        if (v23)
        {
          if ((*(uint64_t (**)(_QWORD, _QWORD))(a1 + 8))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64)) == v26)
            v22 = 0;
          else
            v22 = 0xFFFFFFFFLL;
        }
      }
      else
      {
        v28 = a2;
        v27 = a3;
        v29 = a8;
      }
      v23 -= v26;
    }
  }
  else
  {
    v28 = a2;
    v27 = a3;
    v29 = a8;
    v25 = a7;
    v24 = a6;
  }
  v30 = *((_QWORD *)&v60 + 1);
  if (!v24 || (_DWORD)v22)
  {
    v33 = *((_QWORD *)&v60 + 1) + v23;
    if (!v29)
      goto LABEL_60;
    goto LABEL_46;
  }
  if (*((_QWORD *)&v60 + 1) >= v25)
    v31 = v25;
  else
    v31 = *((_QWORD *)&v60 + 1);
  if (!v23)
  {
    v22 = 0;
    if (!v25)
      goto LABEL_45;
    goto LABEL_41;
  }
  v32 = (*(uint64_t (**)(_QWORD, _QWORD, unint64_t, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v23, 1);
  if (v32)
    v22 = 0xFFFFFFFFLL;
  else
    v22 = 0;
  if (!v32)
    v23 = 0;
  if (v25)
  {
LABEL_41:
    if (v30)
    {
      if ((*(uint64_t (**)(_QWORD, _QWORD, uint64_t, unint64_t))(a1 + 8))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v24, v31) == v31)v22 = v22;
      else
        v22 = 0xFFFFFFFFLL;
    }
  }
LABEL_45:
  v33 = v30 - v31 + v23;
  if (!v29)
    goto LABEL_60;
LABEL_46:
  if (!(_DWORD)v22)
  {
    v34 = v61;
    v35 = a9;
    if ((unint64_t)v61 < a9)
    {
      *(_BYTE *)(v29 + v61) = 0;
      v35 = v34;
    }
    if (v33)
    {
      if ((*(uint64_t (**)(_QWORD, _QWORD, unint64_t, uint64_t))(a1 + 32))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v33, 1))
      {
        v22 = 0xFFFFFFFFLL;
      }
      else
      {
        v22 = 0;
      }
      if (!a9)
        goto LABEL_60;
LABEL_56:
      if (v34)
      {
        if ((*(uint64_t (**)(_QWORD, _QWORD, uint64_t, unint64_t))(a1 + 8))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v29, v35) == v35)v22 = v22;
        else
          v22 = 0xFFFFFFFFLL;
      }
      goto LABEL_60;
    }
    v22 = 0;
    if (a9)
      goto LABEL_56;
  }
LABEL_60:
  if (v28 && !(_DWORD)v22)
  {
    v36 = v63;
    *(_OWORD *)(v28 + 96) = v62;
    *(int8x16_t *)(v28 + 112) = v36;
    *(_QWORD *)(v28 + 128) = v64;
    v37 = v59;
    *(_OWORD *)(v28 + 32) = v58;
    *(_OWORD *)(v28 + 48) = v37;
    v38 = v61;
    *(_OWORD *)(v28 + 64) = v60;
    *(_OWORD *)(v28 + 80) = v38;
    v39 = v57;
    *(_OWORD *)v28 = v56;
    *(_OWORD *)(v28 + 16) = v39;
  }
  if (v27 && !(_DWORD)v22)
    *v27 = v55;
  return v22;
}

uint64_t vinyl_unzGoToNextFile(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t result;

  if (!a1)
    return 4294967194;
  if (!a1[14])
    return 4294967196;
  v2 = a1[9];
  v3 = a1[12] + 1;
  if (v2 != 0xFFFF && v3 == v2)
    return 4294967196;
  v5 = a1[26] + a1[27] + a1[28] + a1[13] + 46;
  a1[12] = v3;
  a1[13] = v5;
  result = sub_1000F2200((uint64_t)a1, (uint64_t)(a1 + 18), a1 + 35, 0, 0, 0, 0, 0, 0);
  a1[14] = (_DWORD)result == 0;
  return result;
}

uint64_t vinyl_unzLocateFile(uint64_t a1, char *__s, int a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  char v20[257];

  if (!a1 || strlen(__s) > 0xFF)
    return 4294967194;
  if (!*(_QWORD *)(a1 + 112))
    return 4294967196;
  v7 = *(_QWORD *)(a1 + 96);
  v8 = *(_QWORD *)(a1 + 104);
  v17 = *(_OWORD *)(a1 + 240);
  v18 = *(_OWORD *)(a1 + 256);
  v9 = *(_QWORD *)(a1 + 280);
  v19 = *(_QWORD *)(a1 + 272);
  v13 = *(_OWORD *)(a1 + 176);
  v14 = *(_OWORD *)(a1 + 192);
  v15 = *(_OWORD *)(a1 + 208);
  v16 = *(_OWORD *)(a1 + 224);
  v11 = *(_OWORD *)(a1 + 144);
  v12 = *(_OWORD *)(a1 + 160);
  v10 = *(_QWORD *)(a1 + 136);
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = v10;
  result = sub_1000F2200(a1, a1 + 144, (_QWORD *)(a1 + 280), 0, 0, 0, 0, 0, 0);
  for (*(_QWORD *)(a1 + 112) = (_DWORD)result == 0; !(_DWORD)result; result = vinyl_unzGoToNextFile((_QWORD *)a1))
  {
    result = sub_1000F2200(a1, 0, 0, (uint64_t)v20, 0x100uLL, 0, 0, 0, 0);
    if ((_DWORD)result)
      break;
    result = vinyl_unzStringFileNameCompare(v20, __s, a3);
    if (!(_DWORD)result)
      return result;
  }
  *(_QWORD *)(a1 + 96) = v7;
  *(_QWORD *)(a1 + 104) = v8;
  *(_OWORD *)(a1 + 240) = v17;
  *(_OWORD *)(a1 + 256) = v18;
  *(_QWORD *)(a1 + 272) = v19;
  *(_OWORD *)(a1 + 176) = v13;
  *(_OWORD *)(a1 + 192) = v14;
  *(_OWORD *)(a1 + 208) = v15;
  *(_OWORD *)(a1 + 224) = v16;
  *(_OWORD *)(a1 + 144) = v11;
  *(_OWORD *)(a1 + 160) = v12;
  *(_QWORD *)(a1 + 280) = v9;
  return result;
}

uint64_t vinyl_unzOpenCurrentFile3(uint64_t a1, _DWORD *a2, int *a3, int a4, _BYTE *a5)
{
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v22;
  int v23;
  char *v24;
  char *v25;
  void *v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  unint64_t v34;
  const z_crc_t *crc_table;
  int v36;
  unsigned __int8 *v37;
  unint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  uint64_t v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51[2];

  if (!a1 || !*(_QWORD *)(a1 + 112))
    return 4294967194;
  if (*(_QWORD *)(a1 + 288))
    vinyl_unzCloseCurrentFile(a1);
  if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(a1 + 88) + *(_QWORD *)(a1 + 280), 0))
  {
    return 4294967193;
  }
  v50 = 0;
  v51[0] = 0;
  v49 = 0;
  v10 = sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), v51);
  v11 = v51[0];
  v12 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v50);
  v13 = sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v49);
  if (sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v50))
  {
    v14 = -1;
  }
  else
  {
    if (v11 == 67324752)
      v18 = 0;
    else
      v18 = -103;
    v19 = v13 | v12 | v10;
    if (v19)
      v14 = -1;
    else
      v14 = v18;
    if (!v19 && v11 == 67324752)
    {
      v14 = -103;
      if (v50 == *(_QWORD *)(a1 + 168))
      {
        if ((v50 & 0xFFFFFFFFFFFFFFF7) != 0)
          v14 = -103;
        else
          v14 = 0;
      }
    }
  }
  v15 = sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), &v50);
  if (sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), &v50))
  {
    v16 = -1;
  }
  else
  {
    if (v15)
      v16 = -1;
    else
      v16 = v14;
    if (!v16)
    {
      if (v50 == *(_QWORD *)(a1 + 184))
      {
        v16 = 0;
      }
      else if ((v49 & 8) != 0)
      {
        v16 = 0;
      }
      else
      {
        v16 = -103;
      }
    }
  }
  if (sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), &v50))
  {
    v16 = -1;
  }
  else if (!v16)
  {
    if (v50 == *(_QWORD *)(a1 + 192))
    {
      v16 = 0;
    }
    else if ((v49 & 8) != 0)
    {
      v16 = 0;
    }
    else
    {
      v16 = -103;
    }
  }
  if (sub_1000F1F40(a1, *(_QWORD *)(a1 + 64), &v50))
  {
    v16 = -1;
  }
  else if (!v16)
  {
    if (v50 == *(_QWORD *)(a1 + 200))
    {
      v16 = 0;
    }
    else if ((v49 & 8) != 0)
    {
      v16 = 0;
    }
    else
    {
      v16 = -103;
    }
  }
  v48 = 0;
  if (sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v48))
  {
    v16 = -1;
    v20 = v48;
  }
  else
  {
    v20 = v48;
    if (!v16)
    {
      if (v48 == *(_QWORD *)(a1 + 208))
        v16 = 0;
      else
        v16 = -103;
    }
  }
  v47 = 0;
  if (sub_1000F1FF8(a1, *(_QWORD *)(a1 + 64), &v47) || v16)
    return 4294967193;
  v22 = *(_QWORD *)(a1 + 280);
  v23 = v47;
  v24 = (char *)malloc(0x120uLL);
  if (!v24)
    return 4294967192;
  v25 = v24;
  v26 = malloc(0x4000uLL);
  *(_QWORD *)v25 = v26;
  *((_QWORD *)v25 + 17) = v20 + v22 + 30;
  *((_DWORD *)v25 + 36) = v23;
  *((_QWORD *)v25 + 19) = 0;
  *((_DWORD *)v25 + 70) = a4;
  if (!v26)
  {
    free(v25);
    return 4294967192;
  }
  *((_QWORD *)v25 + 16) = 0;
  if (a2)
    *a2 = *(_QWORD *)(a1 + 168);
  if (a3)
  {
    *a3 = 6;
    v27 = *(_QWORD *)(a1 + 160) & 6;
    switch(v27)
    {
      case 2:
        v28 = 9;
        break;
      case 6:
        v28 = 1;
        break;
      case 4:
        v28 = 2;
        break;
      default:
        goto LABEL_71;
    }
    *a3 = v28;
  }
LABEL_71:
  v29 = *(_QWORD *)(a1 + 184);
  *((_QWORD *)v25 + 20) = 0;
  *((_QWORD *)v25 + 21) = v29;
  v30 = *(_QWORD *)(a1 + 168);
  *((_QWORD *)v25 + 32) = *(_QWORD *)(a1 + 64);
  *((_QWORD *)v25 + 33) = v30;
  v31 = *(_OWORD *)(a1 + 16);
  *((_OWORD *)v25 + 12) = *(_OWORD *)a1;
  *((_OWORD *)v25 + 13) = v31;
  v32 = *(_OWORD *)(a1 + 48);
  *((_OWORD *)v25 + 14) = *(_OWORD *)(a1 + 32);
  *((_OWORD *)v25 + 15) = v32;
  *((_QWORD *)v25 + 34) = *(_QWORD *)(a1 + 88);
  *((_QWORD *)v25 + 6) = 0;
  if (!a4 && v30 == 8)
  {
    *((_QWORD *)v25 + 1) = 0;
    *((_DWORD *)v25 + 4) = 0;
    *((_QWORD *)v25 + 10) = 0;
    *((_QWORD *)v25 + 11) = 0;
    *((_QWORD *)v25 + 9) = 0;
    v33 = inflateInit2_((z_streamp)(v25 + 8), -15, "1.2.12", 112);
    if ((_DWORD)v33)
    {
      v17 = v33;
      free(v25);
      return v17;
    }
    *((_QWORD *)v25 + 16) = 1;
    v22 = *(_QWORD *)(a1 + 280);
  }
  *((_OWORD *)v25 + 11) = *(_OWORD *)(a1 + 192);
  *((_QWORD *)v25 + 15) = v22 + (v23 + v20) + 30;
  *((_DWORD *)v25 + 4) = 0;
  *(_QWORD *)(a1 + 288) = v25;
  if (!a5)
    return 0;
  v34 = 878082192;
  crc_table = get_crc_table();
  *(_OWORD *)(a1 + 304) = xmmword_100167140;
  *(_QWORD *)(a1 + 320) = 878082192;
  *(_QWORD *)(a1 + 328) = crc_table;
  v36 = *a5;
  if (*a5)
  {
    v37 = a5 + 1;
    v38 = 305419896;
    v39 = 591751049;
    do
    {
      v38 = crc_table[v36 ^ v38] ^ (v38 >> 8);
      v39 = 134775813 * (v39 + v38) + 1;
      *(_QWORD *)(a1 + 304) = v38;
      *(_QWORD *)(a1 + 312) = v39;
      v34 = crc_table[(v34 ^ BYTE3(v39))] ^ (v34 >> 8);
      *(_QWORD *)(a1 + 320) = v34;
      v40 = *v37++;
      v36 = v40;
    }
    while (v40);
  }
  if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), *(_QWORD *)(*(_QWORD *)(a1 + 288) + 272) + *(_QWORD *)(*(_QWORD *)(a1 + 288) + 120), 0)|| (unint64_t)(*(uint64_t (**)(_QWORD, _QWORD, uint64_t *, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64), v51, 12) < 0xC)
  {
    return 4294967192;
  }
  v41 = 0;
  v43 = *(_QWORD *)(a1 + 320);
  v42 = *(_QWORD *)(a1 + 328);
  v44 = *(_QWORD *)(a1 + 304);
  v45 = *(_QWORD *)(a1 + 312);
  do
  {
    v46 = *((_BYTE *)v51 + v41) ^ ((unsigned __int16)((v43 & 0xFFFD ^ 3) * (v43 | 2)) >> 8);
    *((_BYTE *)v51 + v41) = v46;
    v44 = *(_QWORD *)(v42 + 8 * (v46 ^ v44)) ^ (v44 >> 8);
    v45 = 134775813 * (v45 + v44) + 1;
    *(_QWORD *)(a1 + 304) = v44;
    *(_QWORD *)(a1 + 312) = v45;
    v43 = *(_QWORD *)(v42 + 8 * (v43 ^ BYTE3(v45))) ^ (v43 >> 8);
    *(_QWORD *)(a1 + 320) = v43;
    ++v41;
  }
  while (v41 != 12);
  v17 = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 288) + 120) += 12;
  *(_DWORD *)(a1 + 296) = 1;
  return v17;
}

uint64_t vinyl_unzOpenCurrentFile(uint64_t a1)
{
  return vinyl_unzOpenCurrentFile3(a1, 0, 0, 0, 0);
}

uint64_t vinyl_unzReadCurrentFile(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t i;
  uint64_t v19;
  int v20;
  uint64_t v21;
  const Bytef *v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;

  if (!a1)
    return 4294967194;
  v4 = *(_QWORD *)(a1 + 288);
  if (!v4)
    return 4294967194;
  if (!*(_QWORD *)v4)
    return 4294967196;
  if (!a3)
    return 0;
  *(_QWORD *)(v4 + 32) = a2;
  *(_DWORD *)(v4 + 40) = a3;
  v5 = a3;
  v6 = *(_QWORD *)(v4 + 184);
  if (v6 < a3 && !*(_DWORD *)(v4 + 280))
  {
    *(_DWORD *)(v4 + 40) = v6;
    a3 = v6;
  }
  v7 = *(_QWORD *)(v4 + 176);
  v8 = *(unsigned int *)(v4 + 16);
  if (v7 + v8 < v5 && *(_DWORD *)(v4 + 280))
  {
    a3 = v8 + v7;
    *(_DWORD *)(v4 + 40) = v8 + v7;
  }
  if (!a3)
    return 0;
  v9 = 0;
  while (1)
  {
    while (1)
    {
      LODWORD(v10) = *(_DWORD *)(v4 + 16);
      if (!(_DWORD)v10)
      {
        v11 = *(_QWORD *)(v4 + 176);
        if (v11)
        {
          if (v11 >= 0x4000)
            v10 = 0x4000;
          else
            v10 = *(_QWORD *)(v4 + 176);
          if ((*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(v4 + 224))(*(_QWORD *)(v4 + 248), *(_QWORD *)(v4 + 256), *(_QWORD *)(v4 + 272) + *(_QWORD *)(v4 + 120), 0)|| (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, uint64_t))(v4 + 200))(*(_QWORD *)(v4 + 248), *(_QWORD *)(v4 + 256), *(_QWORD *)v4, v10) != v10)
          {
            return 0xFFFFFFFFLL;
          }
          if (*(_DWORD *)(a1 + 296))
          {
            v12 = 0;
            do
            {
              v13 = *(_QWORD *)(a1 + 328);
              v14 = *(unsigned __int8 *)(*(_QWORD *)v4 + v12) ^ (((*(_DWORD *)(a1 + 320) & 0xFFFD ^ 3)
                                                                * (*(_DWORD *)(a1 + 320) | 2u)) >> 8);
              *(_BYTE *)(*(_QWORD *)v4 + v12) ^= (unsigned __int16)((*(_WORD *)(a1 + 320) & 0xFFFD ^ 3)
                                                                  * (*(_WORD *)(a1 + 320) | 2)) >> 8;
              v15 = *(_QWORD *)(v13 + 8 * (v14 ^ *(_QWORD *)(a1 + 304))) ^ (*(_QWORD *)(a1 + 304) >> 8);
              v16 = 134775813 * (*(_QWORD *)(a1 + 312) + v15) + 1;
              *(_QWORD *)(a1 + 304) = v15;
              *(_QWORD *)(a1 + 312) = v16;
              *(_QWORD *)(a1 + 320) = *(_QWORD *)(v13 + 8 * (*(_QWORD *)(a1 + 320) ^ BYTE3(v16))) ^ (*(_QWORD *)(a1 + 320) >> 8);
              *(_BYTE *)(*(_QWORD *)v4 + v12++) = v14;
            }
            while (v10 != v12);
          }
          *(_QWORD *)(v4 + 120) += v10;
          *(_QWORD *)(v4 + 176) -= v10;
          *(_QWORD *)(v4 + 8) = *(_QWORD *)v4;
          *(_DWORD *)(v4 + 16) = v10;
        }
        else
        {
          LODWORD(v10) = 0;
        }
      }
      if (*(_QWORD *)(v4 + 264) && !*(_DWORD *)(v4 + 280))
        break;
      if ((_DWORD)v10 || *(_QWORD *)(v4 + 176))
      {
        v17 = *(_DWORD *)(v4 + 40);
        v10 = v17 >= v10 ? v10 : v17;
        if ((_DWORD)v10)
        {
          for (i = 0; i != v10; ++i)
            *(_BYTE *)(*(_QWORD *)(v4 + 32) + i) = *(_BYTE *)(*(_QWORD *)(v4 + 8) + i);
          v19 = v10;
        }
        else
        {
          v19 = 0;
        }
        *(_QWORD *)(v4 + 160) = crc32(*(_QWORD *)(v4 + 160), *(const Bytef **)(v4 + 32), v10);
        *(_QWORD *)(v4 + 184) -= v19;
        *(_DWORD *)(v4 + 16) -= v10;
        v20 = *(_DWORD *)(v4 + 40) - v10;
        *(_DWORD *)(v4 + 40) = v20;
        *(_QWORD *)(v4 + 32) += v19;
        *(_QWORD *)(v4 + 8) += v19;
        v9 = (v10 + v9);
        *(_QWORD *)(v4 + 48) += v19;
        if (v20)
          continue;
      }
      return v9;
    }
    v21 = *(_QWORD *)(v4 + 48);
    v22 = *(const Bytef **)(v4 + 32);
    v23 = inflate((z_streamp)(v4 + 8), 2);
    if ((v23 & 0x80000000) == 0 && *(_QWORD *)(v4 + 56))
    {
      v26 = *(_QWORD *)(v4 + 48);
      v27 = v26 - v21;
      *(_QWORD *)(v4 + 160) = crc32(*(_QWORD *)(v4 + 160), v22, (int)v26 - (int)v21);
      *(_QWORD *)(v4 + 184) -= v27;
      return 4294967293;
    }
    v24 = *(_QWORD *)(v4 + 48) - v21;
    *(_QWORD *)(v4 + 160) = crc32(*(_QWORD *)(v4 + 160), v22, v24);
    *(_QWORD *)(v4 + 184) -= v24;
    v9 = (v9 + v24);
    if (v23)
      break;
    if (!*(_DWORD *)(v4 + 40))
      return v9;
  }
  if (v23 == 1)
    return v9;
  else
    return v23;
}

uint64_t sub_1000F3194(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t result;
  unsigned __int8 v7;

  v7 = 0;
  if ((*(unsigned int (**)(_QWORD, uint64_t, unsigned __int8 *, uint64_t))(a1 + 8))(*(_QWORD *)(a1 + 56), a2, &v7, 1) == 1)
  {
    result = 0;
    *a3 = v7;
  }
  else if ((*(unsigned int (**)(_QWORD, uint64_t))(a1 + 48))(*(_QWORD *)(a1 + 56), a2))
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return 0;
  }
  return result;
}

_QWORD *eUICCFwReaderOpen(const __CFData *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  _QWORD *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v2 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v2, 4u, "%s::%s: entering: %s\n", v3, v4, v5, v6, v7, (char)"eUICCFwReader");
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v10 = vinyl_unzOpen((uint64_t)BytePtr, Length);
  if (!v10)
  {
    v11 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v11, 2u, "%s::%s: failed to open bbfw archive for reading eUICCFwReaderOpen\n", v12, v13, v14, v15, v16, (char)"eUICCFwReader");
  }
  return v10;
}

uint64_t eUICCFwReaderClose(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v2, 4u, "%s::%s: entering: %s\n", v3, v4, v5, v6, v7, (char)"eUICCFwReader");
  if (a1)
    vinyl_unzClose(a1);
  return 0;
}

uint64_t eUICCFwReaderFindFile(uint64_t a1, CFStringRef theString)
{
  char buffer[1024];

  if (CFStringGetCString(theString, buffer, 1024, 0x8000100u))
    return 4 * (vinyl_unzLocateFile(a1, buffer, 0) != 0);
  else
    return 99;
}

uint64_t eUICCFwReaderFindAndCopyFileData(uint64_t a1, CFStringRef theString, CFTypeRef *a3)
{
  void *v6;
  std::string *v7;
  __int128 v8;
  std::string *v9;
  __int128 v10;
  uint64_t File;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFTypeRef v26;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  std::string v34;
  std::string v35;
  void *__p[2];
  std::string::size_type v37;
  CFTypeRef v38;

  v38 = 0;
  if (theString)
  {
    v6 = sub_1000D3C90();
    sub_1000CB3F4(&v34, "eUICCFwReader");
    v7 = std::string::append(&v34, "::");
    v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
    v35.__r_.__value_.__r.__words[2] = v7->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v8;
    v7->__r_.__value_.__l.__size_ = 0;
    v7->__r_.__value_.__r.__words[2] = 0;
    v7->__r_.__value_.__r.__words[0] = 0;
    v9 = std::string::append(&v35, "eUICCFwReaderFindAndCopyFileData");
    v10 = *(_OWORD *)&v9->__r_.__value_.__l.__data_;
    v37 = v9->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v10;
    v9->__r_.__value_.__l.__size_ = 0;
    v9->__r_.__value_.__r.__words[2] = 0;
    v9->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v6, (uint64_t *)__p, 4u, (uint64_t)"filename ", (uint64_t)theString);
    if (SHIBYTE(v37) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v35.__r_.__value_.__l.__data_);
    if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v34.__r_.__value_.__l.__data_);
  }
  File = eUICCFwReaderFindFile(a1, theString);
  if ((_DWORD)File)
  {
    v12 = File;
    v13 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: failed to find bbfw item status %d\n", v14, v15, v16, v17, v18, (char)"eUICCFwReader");
    return v12;
  }
  else
  {
    v19 = eUICCFwReaderCopyFileData(a1, &v38);
    if ((_DWORD)v19)
    {
      v20 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: failed to extract bbfw item status %d\n", v21, v22, v23, v24, v25, (char)"eUICCFwReader");
      v26 = v38;
      if (!v38)
        return v19;
    }
    else
    {
      v26 = v38;
      if (!v38)
      {
        v28 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v28, 2u, "%s::%s: failed to extract bbfw item fileData is NULL\n", v29, v30, v31, v32, v33, (char)"eUICCFwReader");
        return 0;
      }
      *a3 = CFRetain(v38);
    }
    CFRelease(v26);
  }
  return v19;
}

void sub_1000F3558(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t eUICCFwReaderCopyFileData(uint64_t a1, CFTypeRef *a2)
{
  const UInt8 *v4;
  const UInt8 *v5;
  int CurrentFile;
  CFDataRef v7;
  CFDataRef v8;
  uint64_t v10;
  size_t __size;
  _BYTE v12[1024];

  if (vinyl_unzGetCurrentFileInfo(a1, (uint64_t)&v10, (uint64_t)v12, 0x400uLL, 0, 0, 0, 0))
    return 15;
  v4 = (const UInt8 *)malloc(__size);
  if (!v4)
    return 2;
  v5 = v4;
  if (vinyl_unzOpenCurrentFile(a1))
    return 15;
  CurrentFile = vinyl_unzReadCurrentFile(a1, (uint64_t)v5, __size);
  if (__size != CurrentFile)
    return 4;
  if (vinyl_unzCloseCurrentFile(a1))
    return 15;
  v7 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v5, __size, kCFAllocatorMalloc);
  if (!v7)
    return 2;
  v8 = v7;
  *a2 = CFRetain(v7);
  CFRelease(v8);
  return 0;
}

uint64_t eUICCFwReaderStart(const __CFData *a1, uint64_t (*a2)(uint64_t, CFStringRef, _QWORD *), uint64_t a3)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  CFStringRef v13;
  CFStringRef v14;
  char v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BYTE v30[136];
  char cStr[1024];

  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 4u, "%s::%s: entering: %s\n", v7, v8, v9, v10, v11, (char)"eUICCFwReader");
  v12 = eUICCFwReaderOpen(a1);
  if (!v12)
  {
    v24 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v24, 2u, "%s::%s: failed to open bbfw archive for reading\n", v25, v26, v27, v28, v29, (char)"eUICCFwReader");
    v16 = 4;
    goto LABEL_8;
  }
  while (1)
  {
    if (vinyl_unzGetCurrentFileInfo((uint64_t)v12, (uint64_t)v30, (uint64_t)cStr, 0x400uLL, 0, 0, 0, 0))
    {
      v16 = 15;
      goto LABEL_8;
    }
    if (cStr[0])
      break;
LABEL_6:
    if (vinyl_unzGoToNextFile(v12))
    {
LABEL_7:
      v16 = 0;
      goto LABEL_8;
    }
  }
  v13 = CFStringCreateWithCString(kCFAllocatorDefault, cStr, 0x8000100u);
  if (v13)
  {
    v14 = v13;
    v15 = a2(a3, v13, v12);
    CFRelease(v14);
    if ((v15 & 1) == 0)
      goto LABEL_7;
    goto LABEL_6;
  }
  v16 = 3;
LABEL_8:
  eUICCFwReaderClose((uint64_t)v12);
  v17 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v17, 4u, "%s::%s: leaving: %s\n", v18, v19, v20, v21, v22, (char)"eUICCFwReader");
  return v16;
}

uint64_t VinylUpdaterGetTags(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  void *v8;
  int v9;
  int v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  VinylRestoreHost *v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CFErrorRef v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  VinylRestoreHost *v45;

  v8 = sub_1000D3C90();
  v9 = sub_1000D3ADC((uint64_t)v8, a1, a2, a3);
  if (a4)
  {
    v10 = v9;
    v11 = sub_1000D3C90();
    if (v10)
    {
      sub_1000D3D08((uint64_t)v11, 2u, "%s::%s: failed to init logging\n", v12, v13, v14, v15, v16, (char)"VinylRestoreHost");
      v32 = CFErrorCreate(kCFAllocatorDefault, CFSTR("VinylRestoreInfo"), v10, 0);
      v17 = 0;
    }
    else
    {
      sub_1000D3D08((uint64_t)v11, 4u, "%s::%s: entering: VinylRestoreInfo: %s\n", v12, v13, v14, v15, v16, (char)"VinylRestoreHost");
      VinylRestoreHost::create(a1, (const __CFDictionary *)CFSTR("VinylRestoreInfo"), &v45);
      v17 = v45;
      if (v45)
      {
        v18 = (**(uint64_t (***)(VinylRestoreHost *))v45)(v45);
        if (v18)
          goto LABEL_5;
        v39 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v39, 2u, "%s::%s: failed to get tags\n", v40, v41, v42, v43, v44, (char)"VinylRestoreHost");
        v32 = sub_1000D27D8((uint64_t)v17);
      }
      else
      {
        v33 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v33, 2u, "%s::%s: failed to create host object\n", v34, v35, v36, v37, v38, (char)"VinylRestoreHost");
        v32 = CFErrorCreate(kCFAllocatorDefault, CFSTR("VinylRestoreInfo"), 4000, 0);
      }
    }
    v18 = 0;
    *a4 = v32;
  }
  else
  {
    v26 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v26, 2u, "%s::%s: invalid error parameter passed\n", v27, v28, v29, v30, v31, (char)"VinylRestoreHost");
    v17 = 0;
    v18 = 0;
  }
LABEL_5:
  v19 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v19, 4u, "%s::%s: leaving: VinylRestoreInfo: %s\n", v20, v21, v22, v23, v24, (char)"VinylRestoreHost");
  if (v17)
    (*(void (**)(VinylRestoreHost *))(*(_QWORD *)v17 + 24))(v17);
  return v18;
}

void sub_1000F3A10(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

uint64_t VinylUpdaterCopyFirmware(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  int v15;
  VinylRestoreHost *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFAllocator *v32;
  CFIndex v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  VinylRestoreHost *v46;

  v8 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v8, 4u, "%s::%s: entering: VinylRestoreInfo: %s\n", v9, v10, v11, v12, v13, (char)"VinylRestoreHost");
  v14 = sub_1000D3C90();
  v15 = sub_1000D3ADC((uint64_t)v14, a1, a2, a3);
  if (v15)
  {
    v25 = v15;
    v26 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v26, 2u, "%s::%s: failed to init logging\n", v27, v28, v29, v30, v31, (char)"VinylRestoreHost");
    if (a4)
    {
      v32 = kCFAllocatorDefault;
      v33 = v25;
LABEL_11:
      v17 = 0;
      *a4 = CFErrorCreate(v32, CFSTR("VinylRestoreInfo"), v33, 0);
      return v17;
    }
    return 0;
  }
  VinylRestoreHost::create(a1, (const __CFDictionary *)CFSTR("VinylRestoreInfo"), &v46);
  v16 = v46;
  if (!v46)
  {
    v34 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v34, 2u, "%s::%s: failed to create host object\n", v35, v36, v37, v38, v39, (char)"VinylRestoreHost");
    if (a4)
    {
      v32 = kCFAllocatorDefault;
      v33 = 4000;
      goto LABEL_11;
    }
    return 0;
  }
  v17 = sub_1000CF334((uint64_t)v46);
  if (v17)
  {
    v18 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v18, 4u, "%s::%s: leaving: VinylRestoreInfo: %s\n", v19, v20, v21, v22, v23, (char)"VinylRestoreHost");
  }
  else
  {
    v40 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v40, 2u, "%s::%s: failed to copy firmware\n", v41, v42, v43, v44, v45, (char)"VinylRestoreHost");
    if (a4)
      *a4 = sub_1000D27D8((uint64_t)v16);
  }
  (*(void (**)(VinylRestoreHost *))(*(_QWORD *)v16 + 24))(v16);
  return v17;
}

void sub_1000F3BD0(_Unwind_Exception *a1)
{
  uint64_t v1;

  (*(void (**)(uint64_t))(*(_QWORD *)v1 + 24))(v1);
  _Unwind_Resume(a1);
}

CFMutableDictionaryRef VinylUpdaterCreateRequest(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFDictionaryRef *v22;
  const __CFData *Value;
  CFMutableDictionaryRef Request;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  CFIndex v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *__p[2];
  char v58;
  VinylRestoreHost *v59[3];
  __int16 v60;
  _BYTE v61[16];

  v8 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v8, 4u, "%s::%s: entering: VinylRestoreInfo: %s\n", v9, v10, v11, v12, v13, (char)"VinylRestoreHost");
  sub_1000D3354(v61, CFSTR("VinylRestoreInfo"));
  v60 = 0;
  v59[1] = (VinylRestoreHost *)CFSTR("eUICC,ApProductionMode");
  v59[2] = (VinylRestoreHost *)CFSTR("eUICC,ApSecMode");
  v14 = sub_1000D3C90();
  v15 = sub_1000D3ADC((uint64_t)v14, a1, a2, a3);
  v16 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v16, 4u, "%s::%s: VinylUpdaterCreateRequest  ACFUInitLog returning %d\n", v17, v18, v19, v20, v21, (char)"VinylRestoreHost");
  if (v15)
  {
    v32 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v32, 2u, "%s::%s: failed to init logging\n", v33, v34, v35, v36, v37, (char)"VinylRestoreHost");
    v38 = v15;
    goto LABEL_11;
  }
  VinylRestoreHost::create(a1, (const __CFDictionary *)CFSTR("VinylRestoreInfo"), v59);
  v22 = (CFDictionaryRef *)v59[0];
  if (!v59[0])
  {
    v39 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v39, 2u, "%s::%s: failed to create host object\n", v40, v41, v42, v43, v44, (char)"VinylRestoreHost");
    if (!a4)
    {
LABEL_12:
      Request = 0;
      goto LABEL_7;
    }
    v38 = 4000;
LABEL_11:
    *a4 = CFErrorCreate(kCFAllocatorDefault, CFSTR("VinylRestoreInfo"), v38, 0);
    goto LABEL_12;
  }
  Value = (const __CFData *)CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
  if (!Value)
  {
    v45 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v45, 0, "%s::%s: Invalid or no firmware file present in restore options\n", v46, v47, v48, v49, v50, (char)"VinylRestoreHost");
    goto LABEL_18;
  }
  Request = VinylRestoreHost::createRequest(v22, Value);
  if (!Request)
  {
    v51 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v51, 2u, "%s::%s: failed to create request dict\n", v52, v53, v54, v55, v56, (char)"VinylRestoreHost");
    sub_1000CB3F4(__p, "VinylUpdaterCreateRequest: failed to create request dict");
    sub_1000D3514((uint64_t)v61, (uint64_t)__p, 4001, 0);
    if (v58 < 0)
      operator delete(__p[0]);
    if (a4)
    {
      Request = 0;
      *a4 = sub_1000D27D8((uint64_t)v22);
      goto LABEL_6;
    }
LABEL_18:
    Request = 0;
    goto LABEL_6;
  }
  v25 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v25, 4u, "%s::%s: leaving: VinylRestoreInfo: %s\n", v26, v27, v28, v29, v30, (char)"VinylRestoreHost");
LABEL_6:
  (*((void (**)(CFDictionaryRef *))*v22 + 3))(v22);
LABEL_7:
  sub_1000D369C(v61);
  return Request;
}

void sub_1000F3E28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17)
{
  uint64_t v17;
  uint64_t v18;

  if (a17 < 0)
    operator delete(__p);
  (*(void (**)(uint64_t))(*(_QWORD *)v17 + 24))(v17);
  sub_1000D369C(v18 - 64);
  _Unwind_Resume(a1);
}

FILE *vinyl_fopen_file_func(int a1, void *__buf, int a3, size_t __size)
{
  if (__buf)
    return fmemopen(__buf, __size, "rb");
  else
    return 0;
}

size_t vinyl_fread_file_func(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fread(__ptr, 1uLL, __nitems, __stream);
}

size_t vinyl_fwrite_file_func(int a1, FILE *__stream, void *__ptr, size_t __nitems)
{
  return fwrite(__ptr, 1uLL, __nitems, __stream);
}

uint64_t vinyl_ftell_file_func(int a1, FILE *a2)
{
  return ftell(a2);
}

uint64_t vinyl_fseek_file_func(int a1, FILE *a2, uint64_t a3, unsigned int a4)
{
  if (a4 > 2)
    return -1;
  fseek(a2, a3, a4);
  return 0;
}

uint64_t vinyl_fclose_file_func(int a1, FILE *a2)
{
  return fclose(a2);
}

uint64_t vinyl_ferror_file_func(int a1, FILE *a2)
{
  return ferror(a2);
}

FILE *(**vinyl_fill_fopen_filefunc(FILE *(**result)(int a1, void *__buf, int a3, size_t __size)))(int a1, void *__buf, int a3, size_t __size)
{
  *result = vinyl_fopen_file_func;
  result[1] = (FILE *(*)(int, void *, int, size_t))vinyl_fread_file_func;
  result[2] = (FILE *(*)(int, void *, int, size_t))vinyl_fwrite_file_func;
  result[3] = (FILE *(*)(int, void *, int, size_t))vinyl_ftell_file_func;
  result[4] = (FILE *(*)(int, void *, int, size_t))vinyl_fseek_file_func;
  result[5] = (FILE *(*)(int, void *, int, size_t))vinyl_fclose_file_func;
  result[6] = (FILE *(*)(int, void *, int, size_t))vinyl_ferror_file_func;
  result[7] = 0;
  return result;
}

VinylFirmware *VinylGoldFirmwareCreate(const __CFData *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  std::string *v15;
  __int128 v16;
  std::string *v17;
  __int128 v18;
  VinylFirmware *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  std::string v34;
  std::string v35;
  void *__p[2];
  std::string::size_type v37;

  v8 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v8, 4u, "%s::%s: entering: %s\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
  v14 = sub_1000D3C90();
  sub_1000CB3F4(&v34, "VinylFirmware");
  v15 = std::string::append(&v34, "::");
  v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  v17 = std::string::append(&v35, "VinylGoldFirmwareCreate");
  v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v37 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v14, (uint64_t *)__p, 0, (uint64_t)"fwZipData: ", (uint64_t)a1);
  if (SHIBYTE(v37) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  v19 = (VinylFirmware *)operator new(0xC0uLL);
  VinylFirmware::VinylFirmware((uint64_t)v19, (uint64_t)CFSTR("/update/gold/firmware.der"), (uint64_t)CFSTR("/update/gold/info.plist"), (uint64_t)CFSTR("/update/gold/profile.bin"), off_100183C48);
  if (VinylFirmware::setFwInfo(v19, a1, a2, a3))
  {
    v20 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: setFwInfo failed delete vinylFirmware object\n", v21, v22, v23, v24, v25, (char)"VinylFirmware");
    VinylFirmware::~VinylFirmware(v19);
    operator delete(v26);
    v19 = 0;
  }
  VinylFirmware::setRecoveryFwInfo(v19, a1, a2, a3, 0, a4);
  v27 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v27, 4u, "%s::%s: leaving: %s\n", v28, v29, v30, v31, v32, (char)"VinylFirmware");
  return v19;
}

void sub_1000F412C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;

  operator delete(v30);
  _Unwind_Resume(a1);
}

uint64_t VinylFirmware::setFwInfo(VinylFirmware *this, const __CFData *a2, const __CFData *a3, const __CFData *a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  VinylFirmware *v14;
  __CFString *FWSrcPath;
  __CFString *v16;
  const void **v17;
  uint64_t (*v18)(uint64_t);
  const __CFData *FileDataFromZip;
  __CFError *v20;
  const void **v21;
  uint64_t (*v22)(uint64_t);
  VinylFirmware *v23;
  CFTypeRef v24;
  CFMutableDataRef MutableCopy;
  uint64_t Im4p;
  const __CFData *v27;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const char *v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CFErrorRef error[2];
  CFDataRef theData;
  __CFString *v44;
  const void *v45;

  v45 = 0;
  v8 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v8, 4u, "%s::%s: entering: %s\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
  theData = 0;
  v44 = 0;
  *((_QWORD *)this + 15) = 0;
  if (!a2 || !a3 || !a4)
  {
    v29 = sub_1000D3C90();
    v35 = "%s::%s: invalid params passed\n";
    goto LABEL_26;
  }
  FWSrcPath = (__CFString *)VinylFirmware::getFWSrcPath(v14, a3, a4);
  v16 = v44;
  v44 = FWSrcPath;
  error[0] = (CFErrorRef)v16;
  v17 = sub_1000F1A90((const void **)error);
  v18 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
  if (!v44)
    v18 = 0;
  if (!v18)
  {
    v29 = sub_1000D3C90();
    v35 = "%s::%s: Get FW source path failed\n";
    goto LABEL_26;
  }
  FileDataFromZip = (const __CFData *)VinylFirmware::getFileDataFromZip((VinylFirmware *)v17, a2, v44, *((const __CFString **)this + 12));
  v20 = theData;
  theData = FileDataFromZip;
  error[0] = v20;
  v21 = sub_1000F1A90((const void **)error);
  v22 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
  if (!theData)
    v22 = 0;
  if (!v22 || !theData)
  {
    v29 = sub_1000D3C90();
    v35 = "%s::%s: Get FW Data from Zip failed\n";
LABEL_26:
    sub_1000D3D08((uint64_t)v29, 2u, v35, v30, v31, v32, v33, v34, (char)"VinylFirmware");
    Im4p = 99;
    goto LABEL_17;
  }
  v23 = (VinylFirmware *)VinylFirmware::getFileDataFromZip((VinylFirmware *)v21, a2, v44, *((const __CFString **)this + 13));
  *((_QWORD *)this + 18) = v23;
  if (!v23)
  {
    v29 = sub_1000D3C90();
    v35 = "%s::%s: Get InfoPlist Data from Zip failed\n";
    goto LABEL_26;
  }
  v24 = VinylFirmware::getFileDataFromZip(v23, a2, v44, *((const __CFString **)this + 14));
  *((_QWORD *)this + 19) = v24;
  if (!v24)
  {
    v29 = sub_1000D3C90();
    v35 = "%s::%s: Get Profile Data from Zip failed\n";
    goto LABEL_26;
  }
  MutableCopy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, theData);
  *((_QWORD *)this + 15) = MutableCopy;
  if (!MutableCopy)
  {
    v29 = sub_1000D3C90();
    v35 = "%s::%s: Create FwData copy failed\n";
    goto LABEL_26;
  }
  Im4p = VinylFirmware::createIm4p((uint64_t)this, a2, (uint64_t *)this + 2, (uint64_t *)this + 17);
  if ((_DWORD)Im4p)
  {
    v36 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v36, 2u, "%s::%s: error getting properlylist\n", v37, v38, v39, v40, v41, (char)"VinylFirmware");
    goto LABEL_17;
  }
  v27 = (const __CFData *)*((_QWORD *)this + 18);
  error[0] = 0;
  error[1] = (CFErrorRef)&v45;
  *((_QWORD *)this + 21) = CFPropertyListCreateWithData(kCFAllocatorDefault, v27, 0, 0, error);
  sub_1000F7ADC((const void **)error);
  if (!*((_QWORD *)this + 21))
  {
    v29 = sub_1000D3C90();
    v35 = "%s::%s: error getting properlylist\n";
    goto LABEL_26;
  }
  Im4p = 0;
LABEL_17:
  sub_1000F1A90((const void **)&theData);
  sub_1000F1A90((const void **)&v44);
  sub_1000F1A90(&v45);
  return Im4p;
}

void sub_1000F43DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  const void *v5;
  va_list va;
  uint64_t v7;
  const void *v8;
  va_list va1;
  const void *v10;
  va_list va2;
  va_list va3;

  va_start(va3, a4);
  va_start(va2, a4);
  va_start(va1, a4);
  va_start(va, a4);
  v5 = va_arg(va1, const void *);
  v7 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v8 = va_arg(va2, const void *);
  va_copy(va3, va2);
  v10 = va_arg(va3, const void *);
  sub_1000F7ADC((const void **)va);
  sub_1000F1A90((const void **)va1);
  sub_1000F1A90((const void **)va2);
  sub_1000F1A90((const void **)va3);
  _Unwind_Resume(a1);
}

const void **VinylFirmware::setRecoveryFwInfo(VinylFirmware *this, const __CFData *a2, const __CFData *a3, const __CFData *a4, unsigned int a5, const __CFData *a6)
{
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  VinylFirmware *v15;
  const __CFData *FwMac;
  void *v17;
  std::string *v18;
  __int128 v19;
  std::string *v20;
  __int128 v21;
  void *v22;
  std::string *v23;
  __int128 v24;
  std::string *v25;
  __int128 v26;
  const UInt8 *BytePtr;
  const UInt8 *v28;
  CFIndex Length;
  const __CFData *v30;
  size_t v31;
  int v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  VinylFirmware *v39;
  uint64_t (*v40)(uint64_t);
  uint64_t (*v41)(uint64_t);
  const std::string::value_type *v42;
  char *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  const __CFAllocator *v47;
  const char *v48;
  const std::string::value_type *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  CFStringRef v56;
  const __CFString *v57;
  uint64_t (*v58)(uint64_t);
  void *v59;
  std::string *v60;
  __int128 v61;
  std::string *v62;
  __int128 v63;
  void *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  CFStringRef v70;
  const __CFString *v71;
  void *v73;
  std::string *v74;
  __int128 v75;
  std::string *v76;
  __int128 v77;
  VinylFirmware *v78;
  const __CFData *FileDataFromZip;
  CFDataRef v80;
  const void **v81;
  const __CFData *v82;
  CFDataRef v83;
  uint64_t (*v84)(uint64_t);
  uint64_t (*v85)(uint64_t);
  const std::string::value_type *v86;
  const std::string::value_type *v87;
  int v88;
  const char *v89;
  uint64_t (*v90)(uint64_t);
  const __CFAllocator *v91;
  const void **v92;
  const __CFData *v93;
  const UInt8 *v94;
  const UInt8 *v95;
  CFIndex v96;
  size_t v97;
  uint64_t v98;
  CFMutableDataRef MutableCopy;
  void *v100;
  std::string *v101;
  __int128 v102;
  std::string *v103;
  __int128 v104;
  void *v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  const char *v118;
  void *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  const char *v125;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  void *v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  char *v139;
  char *v140;
  __CFString *FWSrcPath;
  std::string v145;
  std::string v146;
  void *__p[2];
  std::string::size_type v148;
  CFDataRef data;
  CFDataRef v150;
  const __CFString *v151;
  const __CFString *v152;
  const void *v153;
  char v154[16];
  char v155[16];
  char v156[16];

  v152 = 0;
  v153 = 0;
  v151 = 0;
  data = 0;
  v150 = 0;
  *((_QWORD *)this + 16) = 0;
  v9 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v9, 0, "%s::%s: entering: %s\n", v10, v11, v12, v13, v14, (char)"VinylFirmware");
  if (!a2 || !a3 || !a4 || !a6)
  {
    v119 = sub_1000D3C90();
    v125 = "%s::%s: invalid params passed\n";
LABEL_89:
    sub_1000D3D08((uint64_t)v119, 2u, v125, v120, v121, v122, v123, v124, (char)"VinylFirmware");
    goto LABEL_81;
  }
  FwMac = (const __CFData *)VinylFirmware::getFwMac(v15, *((CFDictionaryRef *)this + 21));
  if (!FwMac)
  {
    v119 = sub_1000D3C90();
    v125 = "%s::%s: Failed getting FW MAC\n";
    goto LABEL_89;
  }
  v17 = sub_1000D3C90();
  sub_1000CB3F4(&v145, "VinylFirmware");
  v18 = std::string::append(&v145, "::");
  v19 = *(_OWORD *)&v18->__r_.__value_.__l.__data_;
  v146.__r_.__value_.__r.__words[2] = v18->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v19;
  v18->__r_.__value_.__l.__size_ = 0;
  v18->__r_.__value_.__r.__words[2] = 0;
  v18->__r_.__value_.__r.__words[0] = 0;
  v20 = std::string::append(&v146, "setRecoveryFwInfo");
  v21 = *(_OWORD *)&v20->__r_.__value_.__l.__data_;
  v148 = v20->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v21;
  v20->__r_.__value_.__l.__size_ = 0;
  v20->__r_.__value_.__r.__words[2] = 0;
  v20->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v17, (uint64_t *)__p, 0, (uint64_t)"fwMac : ", (uint64_t)FwMac);
  if (SHIBYTE(v148) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v146.__r_.__value_.__l.__data_);
  if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v145.__r_.__value_.__l.__data_);
  v22 = sub_1000D3C90();
  sub_1000CB3F4(&v145, "VinylFirmware");
  v23 = std::string::append(&v145, "::");
  v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v146.__r_.__value_.__r.__words[2] = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  v25 = std::string::append(&v146, "setRecoveryFwInfo");
  v26 = *(_OWORD *)&v25->__r_.__value_.__l.__data_;
  v148 = v25->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v26;
  v25->__r_.__value_.__l.__size_ = 0;
  v25->__r_.__value_.__r.__words[2] = 0;
  v25->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v22, (uint64_t *)__p, 0, (uint64_t)"mac : ", (uint64_t)a6);
  if (SHIBYTE(v148) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v146.__r_.__value_.__l.__data_);
  if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v145.__r_.__value_.__l.__data_);
  BytePtr = CFDataGetBytePtr(FwMac);
  v28 = CFDataGetBytePtr(a6);
  Length = CFDataGetLength(FwMac);
  if (Length >= CFDataGetLength(a6))
    v30 = a6;
  else
    v30 = FwMac;
  v31 = CFDataGetLength(v30);
  v32 = memcmp(BytePtr, v28, v31);
  v33 = sub_1000D3C90();
  v138 = a5;
  sub_1000D3D08((uint64_t)v33, 0, "%s::%s: SM::Recovery -- normal? %d macMatchRequired %d\n", v34, v35, v36, v37, v38, (char)"VinylFirmware");
  if (v32)
  {
    if ((a5 & 1) == 0)
    {
      strcpy(v156, "/recovery/gold-");
      strcpy(v155, "/firmware.der");
      strcpy(v154, "/info.plist");
      FWSrcPath = (__CFString *)VinylFirmware::getFWSrcPath(v39, a3, a4);
      v40 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
      if (FWSrcPath)
        v41 = ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get;
      else
        v41 = 0;
      v42 = "setRecoveryFwInfo";
      if (v41)
      {
        v43 = (char *)malloc(0x22uLL);
        v44 = (char *)malloc(0x20uLL);
        v45 = v44;
        if (v43 && v44)
        {
          v46 = 0;
          v47 = kCFAllocatorDefault;
          v48 = "%s%03d%s";
          v49 = "::";
          v139 = v44;
          v140 = v43;
          while (1)
          {
            snprintf(v43, 0x22uLL, v48, v156, v46, v155, v138);
            v43[33] = 0;
            v50 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v50, 0, "%s::%s: fwFileName %s\n", v51, v52, v53, v54, v55, (char)"VinylFirmware");
            v56 = CFStringCreateWithCString(v47, v43, 0x8000100u);
            v57 = v152;
            v152 = v56;
            __p[0] = (void *)v57;
            sub_1000F1A90((const void **)__p);
            if (v152)
              v58 = v40;
            else
              v58 = 0;
            if (!v58)
            {
              v112 = sub_1000D3C90();
              v118 = "%s::%s: Failed to alloc create fwFilePath CFString\n";
              goto LABEL_84;
            }
            v59 = sub_1000D3C90();
            sub_1000CB3F4(&v145, "VinylFirmware");
            v60 = std::string::append(&v145, v49);
            v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
            v146.__r_.__value_.__r.__words[2] = v60->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v61;
            v60->__r_.__value_.__l.__size_ = 0;
            v60->__r_.__value_.__r.__words[2] = 0;
            v60->__r_.__value_.__r.__words[0] = 0;
            v62 = std::string::append(&v146, v42);
            v63 = *(_OWORD *)&v62->__r_.__value_.__l.__data_;
            v148 = v62->__r_.__value_.__r.__words[2];
            *(_OWORD *)__p = v63;
            v62->__r_.__value_.__l.__size_ = 0;
            v62->__r_.__value_.__r.__words[2] = 0;
            v62->__r_.__value_.__r.__words[0] = 0;
            sub_1000D42F0((uint64_t)v59, (uint64_t *)__p, 0, (uint64_t)"fwFilePath : ", (uint64_t)v152);
            if (SHIBYTE(v148) < 0)
              operator delete(__p[0]);
            if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v146.__r_.__value_.__l.__data_);
            if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v145.__r_.__value_.__l.__data_);
            snprintf(v45, 0x20uLL, v48, v156, v46, v154);
            v45[31] = 0;
            v64 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v64, 0, "%s::%s: plistFileName %s\n", v65, v66, v67, v68, v69, (char)"VinylFirmware");
            v70 = CFStringCreateWithCString(v47, v45, 0x8000100u);
            v71 = v151;
            v151 = v70;
            __p[0] = (void *)v71;
            sub_1000F1A90((const void **)__p);
            if (!(v151 ? v40 : 0))
              break;
            v73 = sub_1000D3C90();
            sub_1000CB3F4(&v145, "VinylFirmware");
            v74 = std::string::append(&v145, v49);
            v75 = *(_OWORD *)&v74->__r_.__value_.__l.__data_;
            v146.__r_.__value_.__r.__words[2] = v74->__r_.__value_.__r.__words[2];
            *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v75;
            v74->__r_.__value_.__l.__size_ = 0;
            v74->__r_.__value_.__r.__words[2] = 0;
            v74->__r_.__value_.__r.__words[0] = 0;
            v76 = std::string::append(&v146, v42);
            v77 = *(_OWORD *)&v76->__r_.__value_.__l.__data_;
            v148 = v76->__r_.__value_.__r.__words[2];
            *(_OWORD *)__p = v77;
            v76->__r_.__value_.__l.__size_ = 0;
            v76->__r_.__value_.__r.__words[2] = 0;
            v76->__r_.__value_.__r.__words[0] = 0;
            sub_1000D42F0((uint64_t)v73, (uint64_t *)__p, 0, (uint64_t)"plistFilePath : ", (uint64_t)v151);
            if (SHIBYTE(v148) < 0)
              operator delete(__p[0]);
            if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v146.__r_.__value_.__l.__data_);
            if (SHIBYTE(v145.__r_.__value_.__r.__words[2]) < 0)
              operator delete(v145.__r_.__value_.__l.__data_);
            FileDataFromZip = (const __CFData *)VinylFirmware::getFileDataFromZip(v78, a2, FWSrcPath, v152);
            v80 = v150;
            v150 = FileDataFromZip;
            __p[0] = v80;
            v81 = sub_1000F1A90((const void **)__p);
            v82 = (const __CFData *)VinylFirmware::getFileDataFromZip((VinylFirmware *)v81, a2, FWSrcPath, v151);
            v83 = data;
            data = v82;
            __p[0] = v83;
            sub_1000F1A90((const void **)__p);
            v84 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
            if (!v150)
              v84 = 0;
            if (!v84)
              goto LABEL_67;
            v85 = ctu::SharedRef<__CFData const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFData const>::get;
            if (!data)
              v85 = 0;
            if (!v85 || !v150 || !data)
              goto LABEL_67;
            v86 = v42;
            v87 = v49;
            v88 = v46;
            v89 = v48;
            v90 = v40;
            __p[0] = 0;
            __p[1] = &v153;
            v91 = v47;
            v146.__r_.__value_.__r.__words[0] = (std::string::size_type)CFPropertyListCreateWithData(v47, data, 0, 0, (CFErrorRef *)__p);
            v92 = sub_1000F7ADC((const void **)__p);
            v93 = (const __CFData *)VinylFirmware::getFwMac((VinylFirmware *)v92, (CFDictionaryRef)v146.__r_.__value_.__l.__data_);
            v94 = CFDataGetBytePtr(v93);
            v95 = CFDataGetBytePtr(a6);
            v96 = CFDataGetLength(v93);
            if (v96 >= CFDataGetLength(a6))
              v97 = CFDataGetLength(a6);
            else
              v97 = CFDataGetLength(v93);
            v47 = v91;
            if (!memcmp(v94, v95, v97))
            {
              MutableCopy = CFDataCreateMutableCopy(v91, 0, v150);
              v45 = v139;
              *((_QWORD *)this + 16) = MutableCopy;
              sub_1000F1A90((const void **)&v146.__r_.__value_.__l.__data_);
              v43 = v140;
LABEL_67:
              sub_1000F1A90((const void **)&FWSrcPath);
              goto LABEL_68;
            }
            v40 = v90;
            v48 = v89;
            sub_1000F1A90((const void **)&v146.__r_.__value_.__l.__data_);
            v46 = (v88 + 1);
            v45 = v139;
            v43 = v140;
            v49 = v87;
            v42 = v86;
            if ((_DWORD)v46 == 1000)
              goto LABEL_67;
          }
          v112 = sub_1000D3C90();
          v118 = "%s::%s: Failed to alloc create plistFilePath CFString\n";
LABEL_84:
          sub_1000D3D08((uint64_t)v112, 2u, v118, v113, v114, v115, v116, v117, (char)"VinylFirmware");
        }
        else
        {
          v132 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v132, 2u, "%s::%s: Failed to alloc memory for filename\n", v133, v134, v135, v136, v137, (char)"VinylFirmware");
        }
      }
      else
      {
        v126 = sub_1000D3C90();
        sub_1000D3D08((uint64_t)v126, 2u, "%s::%s: Get FW source path failed\n", v127, v128, v129, v130, v131, (char)"VinylFirmware");
        v45 = 0;
        v43 = 0;
      }
      sub_1000F1A90((const void **)&FWSrcPath);
      if (!v43)
        goto LABEL_79;
      goto LABEL_78;
    }
  }
  else
  {
    v98 = *((_QWORD *)this + 15);
    *((_QWORD *)this + 16) = v98;
    AMSupportSafeRetain(v98);
  }
  v45 = 0;
  v43 = 0;
LABEL_68:
  if (!*((_QWORD *)this + 16))
  {
    v105 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v105, 0, "%s::%s: Recovery Fw is not available\n", v106, v107, v108, v109, v110, (char)"VinylFirmware");
    goto LABEL_77;
  }
  v100 = sub_1000D3C90();
  sub_1000CB3F4(&v145, "VinylFirmware");
  v101 = std::string::append(&v145, "::");
  v102 = *(_OWORD *)&v101->__r_.__value_.__l.__data_;
  v146.__r_.__value_.__r.__words[2] = v101->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v146.__r_.__value_.__l.__data_ = v102;
  v101->__r_.__value_.__l.__size_ = 0;
  v101->__r_.__value_.__r.__words[2] = 0;
  v101->__r_.__value_.__r.__words[0] = 0;
  v103 = std::string::append(&v146, "setRecoveryFwInfo");
  v104 = *(_OWORD *)&v103->__r_.__value_.__l.__data_;
  v148 = v103->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v104;
  v103->__r_.__value_.__l.__size_ = 0;
  v103->__r_.__value_.__r.__words[2] = 0;
  v103->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v100, (uint64_t *)__p, 0, (uint64_t)"recoveryFwData : ", *((_QWORD *)this + 16));
  if (SHIBYTE(v148) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v146.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v146.__r_.__value_.__l.__data_);
  if ((SHIBYTE(v145.__r_.__value_.__r.__words[2]) & 0x80000000) == 0)
  {
LABEL_77:
    if (!v43)
      goto LABEL_79;
    goto LABEL_78;
  }
  operator delete(v145.__r_.__value_.__l.__data_);
  if (v43)
LABEL_78:
    free(v43);
LABEL_79:
  if (v45)
    free(v45);
LABEL_81:
  sub_1000F1A90((const void **)&data);
  sub_1000F1A90((const void **)&v150);
  sub_1000F1A90((const void **)&v151);
  sub_1000F1A90((const void **)&v152);
  return sub_1000F1A90(&v153);
}

void sub_1000F4DA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, const void *a19, void *a20,uint64_t a21,int a22,__int16 a23,char a24,char a25,void *a26,uint64_t a27,int a28,__int16 a29,char a30,char a31,uint64_t a32,void *__p,uint64_t a34,int a35,__int16 a36,char a37,char a38,const void *a39,const void *a40)
{
  uint64_t v40;

  sub_1000F1A90(&a19);
  sub_1000F1A90(&a39);
  sub_1000F1A90(&a40);
  sub_1000F1A90((const void **)(v40 - 168));
  sub_1000F1A90((const void **)(v40 - 160));
  sub_1000F1A90((const void **)(v40 - 152));
  _Unwind_Resume(a1);
}

VinylFirmware *VinylMainFirmwareCreate(const __CFData *a1, const __CFData *a2, const __CFData *a3, const __CFData *a4)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  std::string *v15;
  __int128 v16;
  std::string *v17;
  __int128 v18;
  VinylFirmware *v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  std::string v34;
  std::string v35;
  void *__p[2];
  std::string::size_type v37;

  v8 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v8, 4u, "%s::%s: entering: %s\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
  v14 = sub_1000D3C90();
  sub_1000CB3F4(&v34, "VinylFirmware");
  v15 = std::string::append(&v34, "::");
  v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v35.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v35.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  v17 = std::string::append(&v35, "VinylMainFirmwareCreate");
  v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v37 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v14, (uint64_t *)__p, 0, (uint64_t)"fwZipData: ", (uint64_t)a1);
  if (SHIBYTE(v37) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v35.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v35.__r_.__value_.__l.__data_);
  if (SHIBYTE(v34.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v34.__r_.__value_.__l.__data_);
  v19 = (VinylFirmware *)operator new(0xC0uLL);
  VinylFirmware::VinylFirmware((uint64_t)v19, (uint64_t)CFSTR("/update/main/firmware.der"), (uint64_t)CFSTR("/update/main/info.plist"), (uint64_t)CFSTR("/update/main/profile.bin"), off_100183BE8);
  if (VinylFirmware::setFwInfo(v19, a1, a2, a3))
  {
    v20 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: setFwInfo failed delete vinylFirmware object\n", v21, v22, v23, v24, v25, (char)"VinylFirmware");
    VinylFirmware::~VinylFirmware(v19);
    operator delete(v26);
    v19 = 0;
  }
  VinylFirmware::setRecoveryFwInfo(v19, a1, a2, a3, 1u, a4);
  v27 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v27, 4u, "%s::%s: leaving: %s\n", v28, v29, v30, v31, v32, (char)"VinylFirmware");
  return v19;
}

void sub_1000F50C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  void *v30;

  operator delete(v30);
  _Unwind_Resume(a1);
}

uint64_t VinylFirmware::VinylFirmware(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v6 = a5[1];
  *(_OWORD *)a1 = *a5;
  *(_OWORD *)(a1 + 16) = v6;
  v7 = a5[2];
  v8 = a5[3];
  v9 = a5[5];
  *(_OWORD *)(a1 + 64) = a5[4];
  *(_OWORD *)(a1 + 80) = v9;
  *(_OWORD *)(a1 + 32) = v7;
  *(_OWORD *)(a1 + 48) = v8;
  *(_QWORD *)(a1 + 96) = a2;
  *(_QWORD *)(a1 + 104) = a3;
  *(_QWORD *)(a1 + 112) = a4;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = "/usr/lib/libauthinstall.dylib";
  *(_QWORD *)(a1 + 184) = 0;
  AMSupportSafeRetain(a2);
  AMSupportSafeRetain(*(_QWORD *)(a1 + 104));
  AMSupportSafeRetain(*(_QWORD *)(a1 + 112));
  *(_QWORD *)(a1 + 184) = dlopen(*(const char **)(a1 + 176), 1);
  return a1;
}

void VinylFirmware::~VinylFirmware(VinylFirmware *this)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void *v8;
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  const void *v14;
  const void *v15;
  const void *v16;
  void *v17;

  v2 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v2, 4u, "%s::%s: VinylFirmware destructor called\n", v3, v4, v5, v6, v7, (char)"VinylFirmware");
  v8 = (const void *)*((_QWORD *)this + 12);
  if (v8)
  {
    CFRelease(v8);
    *((_QWORD *)this + 12) = 0;
  }
  v9 = (const void *)*((_QWORD *)this + 13);
  if (v9)
  {
    CFRelease(v9);
    *((_QWORD *)this + 13) = 0;
  }
  v10 = (const void *)*((_QWORD *)this + 14);
  if (v10)
  {
    CFRelease(v10);
    *((_QWORD *)this + 14) = 0;
  }
  v11 = (const void *)*((_QWORD *)this + 15);
  if (v11)
  {
    CFRelease(v11);
    *((_QWORD *)this + 15) = 0;
  }
  v12 = (const void *)*((_QWORD *)this + 16);
  if (v12)
  {
    CFRelease(v12);
    *((_QWORD *)this + 16) = 0;
  }
  v13 = (const void *)*((_QWORD *)this + 17);
  if (v13)
  {
    CFRelease(v13);
    *((_QWORD *)this + 17) = 0;
  }
  v14 = (const void *)*((_QWORD *)this + 18);
  if (v14)
  {
    CFRelease(v14);
    *((_QWORD *)this + 18) = 0;
  }
  v15 = (const void *)*((_QWORD *)this + 19);
  if (v15)
  {
    CFRelease(v15);
    *((_QWORD *)this + 19) = 0;
  }
  v16 = (const void *)*((_QWORD *)this + 21);
  if (v16)
  {
    CFRelease(v16);
    *((_QWORD *)this + 21) = 0;
  }
  v17 = (void *)*((_QWORD *)this + 23);
  if (v17)
  {
    dlclose(v17);
    *((_QWORD *)this + 23) = 0;
  }
}

CFStringRef VinylFirmware::getFWSrcPath(VinylFirmware *this, const __CFData *a2, const __CFData *a3)
{
  char *v5;
  char *v6;
  __CFData *MutableCopy;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  std::string *v15;
  __int128 v16;
  std::string *v17;
  __int128 v18;
  const UInt8 *BytePtr;
  CFIndex Length;
  void *v21;
  std::string *v22;
  __int128 v23;
  std::string *v24;
  __int128 v25;
  const UInt8 *v26;
  CFIndex v27;
  CFDataRef v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  std::string *v36;
  __int128 v37;
  std::string *v38;
  __int128 v39;
  UInt8 *v40;
  size_t v41;
  char *v42;
  int v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  CFStringRef v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  std::string *v58;
  __int128 v59;
  std::string *v60;
  __int128 v61;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  std::string v81;
  std::string v82;
  void *__p[2];
  std::string::size_type v84;
  UInt8 bytes[32];

  v5 = (char *)malloc(0x41uLL);
  if (!v5)
  {
    v63 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v63, 2u, "%s::%s: srcPath memory alloc failed\n", v64, v65, v66, v67, v68, (char)"VinylFirmware");
    return 0;
  }
  v6 = v5;
  if (!a2 || !a3)
  {
    v69 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v69, 2u, "%s::%s: invalid params passed\n", v70, v71, v72, v73, v74, (char)"VinylFirmware");
LABEL_41:
    v50 = 0;
    goto LABEL_36;
  }
  MutableCopy = CFDataCreateMutableCopy(0, 0, a2);
  v8 = sub_1000D3C90();
  v14 = (uint64_t)v8;
  if (!MutableCopy)
  {
    sub_1000D3D08((uint64_t)v8, 2u, "%s::%s: certPlusLdrVer memory alloc failed\n", v9, v10, v11, v12, v13, (char)"VinylFirmware");
    goto LABEL_41;
  }
  sub_1000CB3F4(&v81, "VinylFirmware");
  v15 = std::string::append(&v81, "::");
  v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v82.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v82.__r_.__value_.__l.__data_ = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  v17 = std::string::append(&v82, "getFWSrcPath");
  v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
  v84 = v17->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v18;
  v17->__r_.__value_.__l.__size_ = 0;
  v17->__r_.__value_.__r.__words[2] = 0;
  v17->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0(v14, (uint64_t *)__p, 4u, (uint64_t)"vinylgetFwData certPlusLdrVer just certIdentifier: ", (uint64_t)MutableCopy);
  if (SHIBYTE(v84) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v82.__r_.__value_.__l.__data_);
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v81.__r_.__value_.__l.__data_);
  BytePtr = CFDataGetBytePtr(a3);
  Length = CFDataGetLength(a3);
  CFDataAppendBytes(MutableCopy, BytePtr, Length - 1);
  v21 = sub_1000D3C90();
  sub_1000CB3F4(&v81, "VinylFirmware");
  v22 = std::string::append(&v81, "::");
  v23 = *(_OWORD *)&v22->__r_.__value_.__l.__data_;
  v82.__r_.__value_.__r.__words[2] = v22->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v82.__r_.__value_.__l.__data_ = v23;
  v22->__r_.__value_.__l.__size_ = 0;
  v22->__r_.__value_.__r.__words[2] = 0;
  v22->__r_.__value_.__r.__words[0] = 0;
  v24 = std::string::append(&v82, "getFWSrcPath");
  v25 = *(_OWORD *)&v24->__r_.__value_.__l.__data_;
  v84 = v24->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v25;
  v24->__r_.__value_.__l.__size_ = 0;
  v24->__r_.__value_.__r.__words[2] = 0;
  v24->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v21, (uint64_t *)__p, 0, (uint64_t)"vinylgetFwData certPlusLdrVer: ", (uint64_t)MutableCopy);
  if (SHIBYTE(v84) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v82.__r_.__value_.__l.__data_);
  if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v81.__r_.__value_.__l.__data_);
  v26 = CFDataGetBytePtr(MutableCopy);
  v27 = CFDataGetLength(MutableCopy);
  if (AMSupportDigestSha256(v26, v27, bytes))
  {
    v75 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v75, 0, "%s::%s: AMSupportDigestSha256 failed:\n", v76, v77, v78, v79, v80, (char)"VinylFirmware");
  }
  else
  {
    v28 = CFDataCreate(0, bytes, 32);
    v29 = sub_1000D3C90();
    v35 = (uint64_t)v29;
    if (v28)
    {
      sub_1000CB3F4(&v81, "VinylFirmware");
      v36 = std::string::append(&v81, "::");
      v37 = *(_OWORD *)&v36->__r_.__value_.__l.__data_;
      v82.__r_.__value_.__r.__words[2] = v36->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v82.__r_.__value_.__l.__data_ = v37;
      v36->__r_.__value_.__l.__size_ = 0;
      v36->__r_.__value_.__r.__words[2] = 0;
      v36->__r_.__value_.__r.__words[0] = 0;
      v38 = std::string::append(&v82, "getFWSrcPath");
      v39 = *(_OWORD *)&v38->__r_.__value_.__l.__data_;
      v84 = v38->__r_.__value_.__r.__words[2];
      *(_OWORD *)__p = v39;
      v38->__r_.__value_.__l.__size_ = 0;
      v38->__r_.__value_.__r.__words[2] = 0;
      v38->__r_.__value_.__r.__words[0] = 0;
      sub_1000D42F0(v35, (uint64_t *)__p, 0, (uint64_t)"digestRef: ", (uint64_t)v28);
      if (SHIBYTE(v84) < 0)
        operator delete(__p[0]);
      if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v82.__r_.__value_.__l.__data_);
      if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v81.__r_.__value_.__l.__data_);
      v40 = bytes;
      v41 = 65;
      v42 = v6;
      do
      {
        v43 = *v40++;
        snprintf(v42, v41, "%02x", v43);
        v42 += 2;
        v41 -= 2;
      }
      while (v41 != 1);
      v6[64] = 0;
      v44 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v44, 4u, "%s::%s: vinylgetFwData srcPath %s:\n", v45, v46, v47, v48, v49, (char)"VinylFirmware");
      v50 = CFStringCreateWithCString(0, v6, 0x8000100u);
      v51 = sub_1000D3C90();
      v57 = (uint64_t)v51;
      if (v50)
      {
        sub_1000CB3F4(&v81, "VinylFirmware");
        v58 = std::string::append(&v81, "::");
        v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
        v82.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
        *(_OWORD *)&v82.__r_.__value_.__l.__data_ = v59;
        v58->__r_.__value_.__l.__size_ = 0;
        v58->__r_.__value_.__r.__words[2] = 0;
        v58->__r_.__value_.__r.__words[0] = 0;
        v60 = std::string::append(&v82, "getFWSrcPath");
        v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
        v84 = v60->__r_.__value_.__r.__words[2];
        *(_OWORD *)__p = v61;
        v60->__r_.__value_.__l.__size_ = 0;
        v60->__r_.__value_.__r.__words[2] = 0;
        v60->__r_.__value_.__r.__words[0] = 0;
        sub_1000D42F0(v57, (uint64_t *)__p, 0, (uint64_t)"vinylgetFwData fwSrcpath: ", (uint64_t)v50);
        if (SHIBYTE(v84) < 0)
          operator delete(__p[0]);
        if (SHIBYTE(v82.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v82.__r_.__value_.__l.__data_);
        if (SHIBYTE(v81.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v81.__r_.__value_.__l.__data_);
      }
      else
      {
        sub_1000D3D08((uint64_t)v51, 2u, "%s::%s: fwSrcPath memory alloc failed\n", v52, v53, v54, v55, v56, (char)"VinylFirmware");
      }
      CFRelease(v28);
      goto LABEL_35;
    }
    sub_1000D3D08((uint64_t)v29, 2u, "%s::%s: digestRef memory alloc failed\n", v30, v31, v32, v33, v34, (char)"VinylFirmware");
  }
  v50 = 0;
LABEL_35:
  CFRelease(MutableCopy);
LABEL_36:
  free(v6);
  return v50;
}

void sub_1000F57F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

CFTypeRef VinylFirmware::getFileDataFromZip(VinylFirmware *this, const __CFData *a2, const __CFString *a3, const __CFString *a4)
{
  void *v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  void *v12;
  std::string *v13;
  __int128 v14;
  std::string *v15;
  __int128 v16;
  const char *v17;
  __CFString *Mutable;
  __CFString *v19;
  void *v20;
  std::string *v21;
  __int128 v22;
  std::string *v23;
  __int128 v24;
  _QWORD *v25;
  uint64_t v26;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  std::string v41;
  std::string v42;
  void *__p[2];
  std::string::size_type v44;
  CFTypeRef v45;

  v45 = 0;
  v7 = sub_1000D3C90();
  sub_1000CB3F4(&v41, "VinylFirmware");
  v8 = std::string::append(&v41, "::");
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  v10 = std::string::append(&v42, "getFileDataFromZip");
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v44 = v10->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v7, (uint64_t *)__p, 4u, (uint64_t)"getFileDataFromZip fwSrcPath: ", (uint64_t)a3);
  if (SHIBYTE(v44) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  v12 = sub_1000D3C90();
  sub_1000CB3F4(&v41, "VinylFirmware");
  v13 = std::string::append(&v41, "::");
  v14 = *(_OWORD *)&v13->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v13->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v14;
  v13->__r_.__value_.__l.__size_ = 0;
  v13->__r_.__value_.__r.__words[2] = 0;
  v13->__r_.__value_.__r.__words[0] = 0;
  v15 = std::string::append(&v42, "getFileDataFromZip");
  v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
  v44 = v15->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v16;
  v15->__r_.__value_.__l.__size_ = 0;
  v15->__r_.__value_.__r.__words[2] = 0;
  v15->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v12, (uint64_t *)__p, 4u, (uint64_t)"getFileDataFromZip filePath: ", (uint64_t)a4);
  if (SHIBYTE(v44) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  v17 = "%s::%s: invalid params passed\n";
  if (!a2 || !a3 || !a4)
    goto LABEL_28;
  Mutable = CFStringCreateMutable(0, 0);
  if (!Mutable)
  {
    v17 = "%s::%s: Unable to allocate memory for fullPath:\n";
LABEL_28:
    v28 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v28, 2u, v17, v29, v30, v31, v32, v33, (char)"VinylFirmware");
    eUICCFwReaderClose(0);
    return 0;
  }
  v19 = Mutable;
  CFStringAppend(Mutable, a3);
  CFStringAppend(v19, a4);
  v20 = sub_1000D3C90();
  sub_1000CB3F4(&v41, "VinylFirmware");
  v21 = std::string::append(&v41, "::");
  v22 = *(_OWORD *)&v21->__r_.__value_.__l.__data_;
  v42.__r_.__value_.__r.__words[2] = v21->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v42.__r_.__value_.__l.__data_ = v22;
  v21->__r_.__value_.__l.__size_ = 0;
  v21->__r_.__value_.__r.__words[2] = 0;
  v21->__r_.__value_.__r.__words[0] = 0;
  v23 = std::string::append(&v42, "getFileDataFromZip");
  v24 = *(_OWORD *)&v23->__r_.__value_.__l.__data_;
  v44 = v23->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v24;
  v23->__r_.__value_.__l.__size_ = 0;
  v23->__r_.__value_.__r.__words[2] = 0;
  v23->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v20, (uint64_t *)__p, 4u, (uint64_t)"getFileDataFromZip fullPath: ", (uint64_t)v19);
  if (SHIBYTE(v44) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v42.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v42.__r_.__value_.__l.__data_);
  if (SHIBYTE(v41.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v41.__r_.__value_.__l.__data_);
  v25 = eUICCFwReaderOpen(a2);
  v26 = (uint64_t)v25;
  if (!v25)
  {
    v34 = "%s::%s: Unable to unzip the fwdata:\n";
LABEL_31:
    v35 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v35, 2u, v34, v36, v37, v38, v39, v40, (char)"VinylFirmware");
    goto LABEL_25;
  }
  if (eUICCFwReaderFindAndCopyFileData((uint64_t)v25, v19, &v45))
  {
    v34 = "%s::%s: Unable to copy the firmware:\n";
    goto LABEL_31;
  }
LABEL_25:
  eUICCFwReaderClose(v26);
  CFRelease(v19);
  return v45;
}

void sub_1000F5BA4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t ctu::SharedRef<__CFString const,ctu::cf::cfretain_functor,ctu::cf::cfrelease_functor,__CFString const>::get(uint64_t a1)
{
  return *(_QWORD *)a1;
}

uint64_t VinylFirmware::createIm4p(uint64_t a1, const __CFData *a2, uint64_t *a3, uint64_t *a4)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFMutableArrayRef v12;
  CFMutableArrayRef v13;
  const void **v14;
  uint64_t v15;
  CFDataRef v16;
  uint64_t v17;
  const void **v18;
  CFArrayRef v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  std::string *v27;
  __int128 v28;
  std::string *v29;
  __int128 v30;
  void *v31;
  std::string *v32;
  __int128 v33;
  std::string *v34;
  __int128 v35;
  void *v36;
  std::string *v37;
  __int128 v38;
  std::string *v39;
  const __CFArray *v40;
  __int128 v41;
  void *v42;
  std::string *v43;
  __int128 v44;
  std::string *v45;
  __int128 v46;
  void *v47;
  std::string *v48;
  __int128 v49;
  std::string *v50;
  __int128 v51;
  void *v52;
  std::string *v53;
  __int128 v54;
  std::string *v55;
  __int128 v56;
  void *v57;
  std::string *v58;
  __int128 v59;
  std::string *v60;
  __int128 v61;
  uint64_t Count;
  const void **v63;
  uint64_t v64;
  uint64_t i;
  CFDataRef *v66;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef *v69;
  const UInt8 *v70;
  CFIndex v71;
  void *v72;
  std::string *v73;
  __int128 v74;
  std::string *v75;
  __int128 v76;
  void *v77;
  void *v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  std::string *v86;
  __int128 v87;
  std::string *v88;
  __int128 v89;
  CFArrayRef v90;
  const void *v91;
  const void *v92;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  void *v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  void *v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  void *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  void *v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  void *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  void *v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  void *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  void *v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  void *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  const __CFArray *theArray;
  CFArrayRef Mutable;
  std::string v170;
  std::string v171;
  void *__p[2];
  std::string::size_type v173;
  _QWORD v174[2];
  char v175[5];
  char buffer[5];
  unsigned int v177;
  UInt8 *v178;
  void *values[2];
  CFRange v180;
  CFRange v181;

  v178 = 0;
  v177 = 0;
  v6 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v6, 4u, "%s::%s: entering: %s\n", v7, v8, v9, v10, v11, (char)"VinylFirmware");
  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v12 = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v13 = v12;
  v14 = 0;
  values[0] = Mutable;
  values[1] = v12;
  v15 = 1;
  if (!a2 || !a3)
    goto LABEL_107;
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if (!a4)
    goto LABEL_87;
  v14 = 0;
  v15 = 2;
  if (!Mutable)
  {
LABEL_107:
    v16 = 0;
    v17 = 0;
    v18 = 0;
    goto LABEL_87;
  }
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if (!v12)
    goto LABEL_87;
  theArray = v12;
  v19 = CFArrayCreate(0, (const void **)values, 2, &kCFTypeArrayCallBacks);
  a3[6] = (uint64_t)v19;
  if (!v19)
    goto LABEL_114;
  v174[0] = a1;
  v174[1] = a3;
  v15 = eUICCFwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, _QWORD *))sub_1000F6D98, (uint64_t)v174);
  if ((_DWORD)v15)
  {
    v112 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v112, 2u, "%s::%s: failed to read zip file\n", v113, v114, v115, v116, v117, (char)"VinylFirmware");
LABEL_114:
    v18 = 0;
    v17 = 0;
    v16 = 0;
    v14 = 0;
LABEL_115:
    v13 = theArray;
    v90 = Mutable;
    goto LABEL_88;
  }
  if (!a3[7])
  {
    v118 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v118, 2u, "%s::%s: Failed to build vinyl info.plist dictionary\n", v119, v120, v121, v122, v123, (char)"VinylFirmware");
LABEL_113:
    v15 = 0;
    goto LABEL_114;
  }
  v15 = eUICCFwReaderStart(a2, (uint64_t (*)(uint64_t, CFStringRef, _QWORD *))sub_1000F6DF8, (uint64_t)v174);
  v20 = sub_1000D3C90();
  v26 = (uint64_t)v20;
  if ((_DWORD)v15)
  {
    sub_1000D3D08((uint64_t)v20, 2u, "%s::%s: failed to read zip file\n", v21, v22, v23, v24, v25, (char)"VinylFirmware");
    goto LABEL_114;
  }
  sub_1000CB3F4(&v170, "VinylFirmware");
  v27 = std::string::append(&v170, "::");
  v28 = *(_OWORD *)&v27->__r_.__value_.__l.__data_;
  v171.__r_.__value_.__r.__words[2] = v27->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v28;
  v27->__r_.__value_.__l.__size_ = 0;
  v27->__r_.__value_.__r.__words[2] = 0;
  v27->__r_.__value_.__r.__words[0] = 0;
  v29 = std::string::append(&v171, "createIm4p");
  v30 = *(_OWORD *)&v29->__r_.__value_.__l.__data_;
  v173 = v29->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v30;
  v29->__r_.__value_.__l.__size_ = 0;
  v29->__r_.__value_.__r.__words[2] = 0;
  v29->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0(v26, (uint64_t *)__p, 0, (uint64_t)"tag4cc : ", *a3);
  if (SHIBYTE(v173) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v171.__r_.__value_.__l.__data_);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v170.__r_.__value_.__l.__data_);
  v31 = sub_1000D3C90();
  sub_1000CB3F4(&v170, "VinylFirmware");
  v32 = std::string::append(&v170, "::");
  v33 = *(_OWORD *)&v32->__r_.__value_.__l.__data_;
  v171.__r_.__value_.__r.__words[2] = v32->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v33;
  v32->__r_.__value_.__l.__size_ = 0;
  v32->__r_.__value_.__r.__words[2] = 0;
  v32->__r_.__value_.__r.__words[0] = 0;
  v34 = std::string::append(&v171, "createIm4p");
  v35 = *(_OWORD *)&v34->__r_.__value_.__l.__data_;
  v173 = v34->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v35;
  v34->__r_.__value_.__l.__size_ = 0;
  v34->__r_.__value_.__r.__words[2] = 0;
  v34->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v31, (uint64_t *)__p, 0, (uint64_t)"filename : ", a3[1]);
  if (SHIBYTE(v173) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v171.__r_.__value_.__l.__data_);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v170.__r_.__value_.__l.__data_);
  v36 = sub_1000D3C90();
  sub_1000CB3F4(&v170, "VinylFirmware");
  v37 = std::string::append(&v170, "::");
  v38 = *(_OWORD *)&v37->__r_.__value_.__l.__data_;
  v171.__r_.__value_.__r.__words[2] = v37->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v38;
  v37->__r_.__value_.__l.__size_ = 0;
  v37->__r_.__value_.__r.__words[2] = 0;
  v37->__r_.__value_.__r.__words[0] = 0;
  v39 = std::string::append(&v171, "createIm4p");
  v40 = Mutable;
  v41 = *(_OWORD *)&v39->__r_.__value_.__l.__data_;
  v173 = v39->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v41;
  v39->__r_.__value_.__l.__size_ = 0;
  v39->__r_.__value_.__r.__words[2] = 0;
  v39->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v36, (uint64_t *)__p, 0, (uint64_t)"plist_filename : ", a3[2]);
  if (SHIBYTE(v173) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v171.__r_.__value_.__l.__data_);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v170.__r_.__value_.__l.__data_);
  if (a3[3])
  {
    v42 = sub_1000D3C90();
    sub_1000CB3F4(&v170, "VinylFirmware");
    v43 = std::string::append(&v170, "::");
    v44 = *(_OWORD *)&v43->__r_.__value_.__l.__data_;
    v171.__r_.__value_.__r.__words[2] = v43->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v44;
    v43->__r_.__value_.__l.__size_ = 0;
    v43->__r_.__value_.__r.__words[2] = 0;
    v43->__r_.__value_.__r.__words[0] = 0;
    v45 = std::string::append(&v171, "createIm4p");
    v40 = Mutable;
    v46 = *(_OWORD *)&v45->__r_.__value_.__l.__data_;
    v173 = v45->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v46;
    v45->__r_.__value_.__l.__size_ = 0;
    v45->__r_.__value_.__r.__words[2] = 0;
    v45->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v42, (uint64_t *)__p, 0, (uint64_t)"data : ", a3[3]);
    if (SHIBYTE(v173) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v171.__r_.__value_.__l.__data_);
    if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v170.__r_.__value_.__l.__data_);
  }
  if (a3[4])
  {
    v47 = sub_1000D3C90();
    sub_1000CB3F4(&v170, "VinylFirmware");
    v48 = std::string::append(&v170, "::");
    v49 = *(_OWORD *)&v48->__r_.__value_.__l.__data_;
    v171.__r_.__value_.__r.__words[2] = v48->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v49;
    v48->__r_.__value_.__l.__size_ = 0;
    v48->__r_.__value_.__r.__words[2] = 0;
    v48->__r_.__value_.__r.__words[0] = 0;
    v50 = std::string::append(&v171, "createIm4p");
    v40 = Mutable;
    v51 = *(_OWORD *)&v50->__r_.__value_.__l.__data_;
    v173 = v50->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v51;
    v50->__r_.__value_.__l.__size_ = 0;
    v50->__r_.__value_.__r.__words[2] = 0;
    v50->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v47, (uint64_t *)__p, 0, (uint64_t)"certIdToFind : ", a3[4]);
    if (SHIBYTE(v173) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v171.__r_.__value_.__l.__data_);
    if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v170.__r_.__value_.__l.__data_);
  }
  if (a3[5])
  {
    v52 = sub_1000D3C90();
    sub_1000CB3F4(&v170, "VinylFirmware");
    v53 = std::string::append(&v170, "::");
    v54 = *(_OWORD *)&v53->__r_.__value_.__l.__data_;
    v171.__r_.__value_.__r.__words[2] = v53->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v54;
    v53->__r_.__value_.__l.__size_ = 0;
    v53->__r_.__value_.__r.__words[2] = 0;
    v53->__r_.__value_.__r.__words[0] = 0;
    v55 = std::string::append(&v171, "createIm4p");
    v40 = Mutable;
    v56 = *(_OWORD *)&v55->__r_.__value_.__l.__data_;
    v173 = v55->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v56;
    v55->__r_.__value_.__l.__size_ = 0;
    v55->__r_.__value_.__r.__words[2] = 0;
    v55->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v52, (uint64_t *)__p, 0, (uint64_t)"tafwLdrVerToFindg4cc : ", a3[5]);
    if (SHIBYTE(v173) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v171.__r_.__value_.__l.__data_);
    if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v170.__r_.__value_.__l.__data_);
  }
  if (a3[6])
  {
    v57 = sub_1000D3C90();
    sub_1000CB3F4(&v170, "VinylFirmware");
    v58 = std::string::append(&v170, "::");
    v59 = *(_OWORD *)&v58->__r_.__value_.__l.__data_;
    v171.__r_.__value_.__r.__words[2] = v58->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v59;
    v58->__r_.__value_.__l.__size_ = 0;
    v58->__r_.__value_.__r.__words[2] = 0;
    v58->__r_.__value_.__r.__words[0] = 0;
    v60 = std::string::append(&v171, "createIm4p");
    v40 = Mutable;
    v61 = *(_OWORD *)&v60->__r_.__value_.__l.__data_;
    v173 = v60->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v61;
    v60->__r_.__value_.__l.__size_ = 0;
    v60->__r_.__value_.__r.__words[2] = 0;
    v60->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v57, (uint64_t *)__p, 0, (uint64_t)"array : ", a3[6]);
    if (SHIBYTE(v173) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v171.__r_.__value_.__l.__data_);
    if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v170.__r_.__value_.__l.__data_);
  }
  Count = CFArrayGetCount(v40);
  if (Count <= 0)
  {
    v124 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v124, 2u, "%s::%s: No sources found \n", v125, v126, v127, v128, v129, (char)"VinylFirmware");
    goto LABEL_113;
  }
  if (Count != CFArrayGetCount(theArray))
  {
    v130 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v130, 2u, "%s::%s: Count of certID != hashVad \n", v131, v132, v133, v134, v135, (char)"VinylFirmware");
    goto LABEL_113;
  }
  v18 = (const void **)malloc(8 * Count);
  v63 = (const void **)malloc(8 * Count);
  v14 = v63;
  if (!v18 || !v63)
  {
    v136 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v136, 2u, "%s::%s: Memory alloc failed certIds/VadDigest\n", v137, v138, v139, v140, v141, (char)"VinylFirmware");
    v15 = 0;
    v17 = 0;
    v16 = 0;
    goto LABEL_115;
  }
  v180.location = 0;
  v180.length = Count;
  CFArrayGetValues(Mutable, v180, v18);
  v181.location = 0;
  v181.length = Count;
  CFArrayGetValues(theArray, v181, v14);
  v17 = DEREncoderCreate(1);
  v64 = DEREncoderCreate(1);
  for (i = 0; i != Count; ++i)
  {
    v16 = (CFDataRef)DEREncoderCreate(0);
    v66 = (CFDataRef *)&v18[i];
    BytePtr = CFDataGetBytePtr(*v66);
    Length = CFDataGetLength(*v66);
    if (DEREncoderAddData(v16, 0, 4, BytePtr, Length, 0))
    {
      v94 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v94, 2u, "%s::%s: failed to add certId\n", v95, v96, v97, v98, v99, (char)"VinylFirmware");
LABEL_105:
      v15 = 0;
LABEL_106:
      v13 = theArray;
      goto LABEL_87;
    }
    v69 = (CFDataRef *)&v14[i];
    v70 = CFDataGetBytePtr(*v69);
    v71 = CFDataGetLength(*v69);
    if (DEREncoderAddData(v16, 0, 4, v70, v71, 0))
    {
      v100 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v100, 2u, "%s::%s: failed to add VAD\n", v101, v102, v103, v104, v105, (char)"VinylFirmware");
      goto LABEL_105;
    }
    if (DEREncoderAddSequenceFromEncoder(v16, v64))
    {
      v106 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v106, 2u, "%s::%s: failed to add certId-VAD sequence\n", v107, v108, v109, v110, v111, (char)"VinylFirmware");
      goto LABEL_105;
    }
    DEREncoderDestroy(v16);
  }
  if (DEREncoderAddSequenceFromEncoder(v64, v17))
  {
    v142 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v142, 2u, "%s::%s: failed to add top-level sequence\n", v143, v144, v145, v146, v147, (char)"VinylFirmware");
LABEL_119:
    v16 = 0;
    v15 = 3;
    goto LABEL_106;
  }
  DEREncoderDestroy(v64);
  if (DEREncoderCreateEncodedBuffer(v17, &v178, &v177))
  {
    v148 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v148, 2u, "%s::%s: failed to encode DER buffer\n", v149, v150, v151, v152, v153, (char)"VinylFirmware");
    goto LABEL_119;
  }
  v16 = CFDataCreateWithBytesNoCopy(0, v178, v177, kCFAllocatorMalloc);
  if (!v16)
  {
    v15 = 2;
    goto LABEL_106;
  }
  if (!CFStringGetCString((CFStringRef)*a3, buffer, 5, 0x8000100u)
    || !CFStringGetCString(CFSTR("1.0"), v175, 5, 0x8000100u))
  {
    goto LABEL_119;
  }
  v72 = sub_1000D3C90();
  sub_1000CB3F4(&v170, "VinylFirmware");
  v73 = std::string::append(&v170, "::");
  v74 = *(_OWORD *)&v73->__r_.__value_.__l.__data_;
  v171.__r_.__value_.__r.__words[2] = v73->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v74;
  v73->__r_.__value_.__l.__size_ = 0;
  v73->__r_.__value_.__r.__words[2] = 0;
  v73->__r_.__value_.__r.__words[0] = 0;
  v75 = std::string::append(&v171, "createIm4p");
  v76 = *(_OWORD *)&v75->__r_.__value_.__l.__data_;
  v173 = v75->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v76;
  v75->__r_.__value_.__l.__size_ = 0;
  v75->__r_.__value_.__r.__words[2] = 0;
  v75->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v72, (uint64_t *)__p, 0, (uint64_t)"measurementSeq : ", (uint64_t)v16);
  if (SHIBYTE(v173) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v171.__r_.__value_.__l.__data_);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v170.__r_.__value_.__l.__data_);
  v77 = *(void **)(a1 + 184);
  if (!v77)
  {
    v154 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v154, 2u, "%s::%s: failed to open libauthinstall dylib\n", v155, v156, v157, v158, v159, (char)"VinylFirmware");
LABEL_123:
    v16 = 0;
    v15 = 99;
    goto LABEL_106;
  }
  v78 = dlsym(v77, "AMAuthInstallApImg4CreatePayload");
  if (dlerror() || !v78)
  {
    v160 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v160, 2u, "%s::%s: failed to initialize LAI lib create function\n", v161, v162, v163, v164, v165, (char)"VinylFirmware");
    goto LABEL_123;
  }
  v15 = ((uint64_t (*)(char *, char *, CFDataRef, _QWORD, _QWORD, uint64_t *))v78)(buffer, v175, v16, 0, 0, a4);
  v79 = sub_1000D3C90();
  v85 = (uint64_t)v79;
  if ((_DWORD)v15)
  {
    sub_1000D3D08((uint64_t)v79, 0, "%s::%s: failed to create im4p\n", v80, v81, v82, v83, v84, (char)"VinylFirmware");
    v16 = 0;
    goto LABEL_106;
  }
  sub_1000CB3F4(&v170, "VinylFirmware");
  v86 = std::string::append(&v170, "::");
  v87 = *(_OWORD *)&v86->__r_.__value_.__l.__data_;
  v171.__r_.__value_.__r.__words[2] = v86->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v171.__r_.__value_.__l.__data_ = v87;
  v86->__r_.__value_.__l.__size_ = 0;
  v86->__r_.__value_.__r.__words[2] = 0;
  v86->__r_.__value_.__r.__words[0] = 0;
  v88 = std::string::append(&v171, "createIm4p");
  v89 = *(_OWORD *)&v88->__r_.__value_.__l.__data_;
  v173 = v88->__r_.__value_.__r.__words[2];
  *(_OWORD *)__p = v89;
  v88->__r_.__value_.__l.__size_ = 0;
  v88->__r_.__value_.__r.__words[2] = 0;
  v88->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0(v85, (uint64_t *)__p, 0, (uint64_t)"outPayload : ", *a4);
  v13 = theArray;
  if (SHIBYTE(v173) < 0)
    operator delete(__p[0]);
  if (SHIBYTE(v171.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v171.__r_.__value_.__l.__data_);
  if (SHIBYTE(v170.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v170.__r_.__value_.__l.__data_);
  v16 = 0;
  v15 = 0;
LABEL_87:
  v90 = Mutable;
  if (Mutable)
LABEL_88:
    CFRelease(v90);
  if (v13)
    CFRelease(v13);
  if (v18)
    free(v18);
  if (v14)
    free(v14);
  DEREncoderDestroy(v16);
  DEREncoderDestroy(v17);
  v91 = (const void *)a3[6];
  if (v91)
  {
    CFRelease(v91);
    a3[6] = 0;
  }
  v92 = (const void *)a3[7];
  if (v92)
  {
    CFRelease(v92);
    a3[7] = 0;
  }
  if (v178)
    free(v178);
  return v15;
}

void sub_1000F6928(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, int a18, __int16 a19, char a20,char a21,void *a22,uint64_t a23,int a24,__int16 a25,char a26,char a27,uint64_t a28,void *__p,uint64_t a30,int a31,__int16 a32,char a33,char a34)
{
  if (a34 < 0)
    operator delete(__p);
  if (a27 < 0)
    operator delete(a22);
  if (a21 < 0)
    operator delete(a16);
  _Unwind_Resume(exception_object);
}

const void *VinylFirmware::getFwMac(VinylFirmware *this, CFDictionaryRef theDict)
{
  const void *Value;
  CFTypeID TypeID;
  void *v4;
  std::string *v5;
  __int128 v6;
  std::string *v7;
  __int128 v8;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::string v22;
  std::string v23;
  __int128 v24;
  std::string::size_type v25;

  Value = CFDictionaryGetValue(theDict, CFSTR("com.apple.EmbeddedSoftwareRestore.eUICC.firmwareMac"));
  if (Value)
  {
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(Value) && CFDataGetLength((CFDataRef)Value) == 8)
    {
      v4 = sub_1000D3C90();
      sub_1000CB3F4(&v22, "VinylFirmware");
      v5 = std::string::append(&v22, "::");
      v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
      v23.__r_.__value_.__r.__words[2] = v5->__r_.__value_.__r.__words[2];
      *(_OWORD *)&v23.__r_.__value_.__l.__data_ = v6;
      v5->__r_.__value_.__l.__size_ = 0;
      v5->__r_.__value_.__r.__words[2] = 0;
      v5->__r_.__value_.__r.__words[0] = 0;
      v7 = std::string::append(&v23, "getFwMac");
      v8 = *(_OWORD *)&v7->__r_.__value_.__l.__data_;
      v25 = v7->__r_.__value_.__r.__words[2];
      v24 = v8;
      v7->__r_.__value_.__l.__size_ = 0;
      v7->__r_.__value_.__r.__words[2] = 0;
      v7->__r_.__value_.__r.__words[0] = 0;
      sub_1000D42F0((uint64_t)v4, (uint64_t *)&v24, 0, (uint64_t)"fwMacData: ", (uint64_t)Value);
      if (SHIBYTE(v25) < 0)
        operator delete((void *)v24);
      if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v23.__r_.__value_.__l.__data_);
      if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v22.__r_.__value_.__l.__data_);
    }
    else
    {
      v10 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v10, 2u, "%s::%s: fwMacData is wrong type\n", v11, v12, v13, v14, v15, (char)"VinylFirmware");
    }
  }
  else
  {
    v16 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v16, 2u, "%s::%s: Missing firmwareMac in info.plist -- firmware too old\n", v17, v18, v19, v20, v21, (char)"VinylFirmware");
  }
  return Value;
}

void sub_1000F6B44(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  uint64_t v23;

  if (*(char *)(v23 - 25) < 0)
    operator delete(*(void **)(v23 - 48));
  if (a23 < 0)
    operator delete(__p);
  if (a17 < 0)
    operator delete(a12);
  _Unwind_Resume(exception_object);
}

uint64_t VinylFirmware::getIm4p(VinylFirmware *this)
{
  return *((_QWORD *)this + 17);
}

uint64_t VinylFirmware::getFwData(VinylFirmware *this)
{
  return *((_QWORD *)this + 15);
}

uint64_t VinylFirmware::getRecoveryFwData(VinylFirmware *this)
{
  void *v2;
  std::string *v3;
  __int128 v4;
  std::string *v5;
  __int128 v6;
  void *v7;
  std::string *v8;
  __int128 v9;
  std::string *v10;
  __int128 v11;
  std::string v13;
  std::string v14;
  __int128 v15;
  std::string::size_type v16;

  v2 = sub_1000D3C90();
  sub_1000CB3F4(&v13, "VinylFirmware");
  v3 = std::string::append(&v13, "::");
  v4 = *(_OWORD *)&v3->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v3->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v4;
  v3->__r_.__value_.__l.__size_ = 0;
  v3->__r_.__value_.__r.__words[2] = 0;
  v3->__r_.__value_.__r.__words[0] = 0;
  v5 = std::string::append(&v14, "getRecoveryFwData");
  v6 = *(_OWORD *)&v5->__r_.__value_.__l.__data_;
  v16 = v5->__r_.__value_.__r.__words[2];
  v15 = v6;
  v5->__r_.__value_.__l.__size_ = 0;
  v5->__r_.__value_.__r.__words[2] = 0;
  v5->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v2, (uint64_t *)&v15, 0, (uint64_t)"recoveryFwData : ", *((_QWORD *)this + 16));
  if (SHIBYTE(v16) < 0)
    operator delete((void *)v15);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v13.__r_.__value_.__l.__data_);
  v7 = sub_1000D3C90();
  sub_1000CB3F4(&v13, "VinylFirmware");
  v8 = std::string::append(&v13, "::");
  v9 = *(_OWORD *)&v8->__r_.__value_.__l.__data_;
  v14.__r_.__value_.__r.__words[2] = v8->__r_.__value_.__r.__words[2];
  *(_OWORD *)&v14.__r_.__value_.__l.__data_ = v9;
  v8->__r_.__value_.__l.__size_ = 0;
  v8->__r_.__value_.__r.__words[2] = 0;
  v8->__r_.__value_.__r.__words[0] = 0;
  v10 = std::string::append(&v14, "getRecoveryFwData");
  v11 = *(_OWORD *)&v10->__r_.__value_.__l.__data_;
  v16 = v10->__r_.__value_.__r.__words[2];
  v15 = v11;
  v10->__r_.__value_.__l.__size_ = 0;
  v10->__r_.__value_.__r.__words[2] = 0;
  v10->__r_.__value_.__r.__words[0] = 0;
  sub_1000D42F0((uint64_t)v7, (uint64_t *)&v15, 0, (uint64_t)"fwData : ", *((_QWORD *)this + 15));
  if (SHIBYTE(v16) < 0)
    operator delete((void *)v15);
  if (SHIBYTE(v14.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v14.__r_.__value_.__l.__data_);
  if (SHIBYTE(v13.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v13.__r_.__value_.__l.__data_);
  return *((_QWORD *)this + 16);
}

void sub_1000F6D30(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *__p, uint64_t a17, int a18, __int16 a19, char a20,char a21)
{
  uint64_t v21;

  if (*(char *)(v21 - 25) < 0)
    operator delete(*(void **)(v21 - 48));
  if (a21 < 0)
    operator delete(__p);
  if (a15 < 0)
    operator delete(a10);
  _Unwind_Resume(exception_object);
}

uint64_t VinylFirmware::getInfoPlistData(VinylFirmware *this)
{
  return *((_QWORD *)this + 18);
}

uint64_t VinylFirmware::getProfileData(VinylFirmware *this)
{
  return *((_QWORD *)this + 19);
}

BOOL sub_1000F6D98(VinylFirmware *a1, CFStringRef theString, uint64_t a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1)
    return VinylFirmware::fwReaderInfoPlistCallback(a1, *((_QWORD **)a1 + 1), theString, a3);
  v4 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v4, 2u, "%s::%s: context passed is null\n", v5, v6, v7, v8, v9, (char)"VinylFirmware");
  return 0;
}

uint64_t sub_1000F6DF8(uint64_t a1, CFStringRef theString, uint64_t a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (a1)
    return VinylFirmware::fwReaderCallback(*(VinylFirmware **)a1, *(void **)(a1 + 8), theString, a3);
  v4 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v4, 2u, "%s::%s: context passed is null\n", v5, v6, v7, v8, v9, (char)"VinylFirmware");
  return 0;
}

CFStringRef VinylFirmware::getPathComponent(VinylFirmware *this, const __CFString *a2)
{
  const __CFURL *v2;
  const __CFURL *v3;
  const __CFURL *PathComponent;
  const __CFURL *v5;
  const __CFString *v6;
  CFStringRef Copy;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  if (!a2)
  {
    v9 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v9, 2u, "%s::%s: fullPath is null\n", v10, v11, v12, v13, v14, (char)"VinylFirmware");
    return 0;
  }
  v2 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, a2, kCFURLPOSIXPathStyle, 0);
  if (!v2)
  {
    v15 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v15, 2u, "%s::%s: failed to create fullURL\n", v16, v17, v18, v19, v20, (char)"VinylFirmware");
    return 0;
  }
  v3 = v2;
  PathComponent = CFURLCreateCopyDeletingLastPathComponent(kCFAllocatorDefault, v2);
  if (!PathComponent)
  {
    v21 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v21, 2u, "%s::%s: failed to create dirURL\n", v22, v23, v24, v25, v26, (char)"VinylFirmware");
    CFRelease(v3);
    return 0;
  }
  v5 = PathComponent;
  v6 = CFURLGetString(PathComponent);
  Copy = CFStringCreateCopy(kCFAllocatorDefault, v6);
  if (!Copy)
  {
    v27 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v27, 2u, "%s::%s: failed to create dirPath\n", v28, v29, v30, v31, v32, (char)"VinylFirmware");
  }
  CFRelease(v3);
  CFRelease(v5);
  return Copy;
}

BOOL VinylFirmware::checkVinylFwLdrVerLegacy(VinylFirmware *this, CFArrayRef theArray)
{
  const __CFString *ValueAtIndex;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v5;
  const __CFString *v6;
  __int16 IntValue;
  const __CFString *v8;
  _BOOL8 v9;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;

  if (CFArrayGetCount(theArray) <= 0)
  {
    v11 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v11, 2u, "%s::%s: ldrVers count is zero\n", v12, v13, v14, v15, v16, (char)"VinylFirmware");
    return 1;
  }
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
  if (!ValueAtIndex)
  {
    v17 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v17, 2u, "%s::%s: failed to get ldrVer\n", v18, v19, v20, v21, v22, (char)"VinylFirmware");
    return 1;
  }
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, ValueAtIndex, CFSTR("."));
  if (!ArrayBySeparatingStrings)
  {
    v23 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v23, 2u, "%s::%s: ldrVerComponents count is not expected\n", v24, v25, v26, v27, v28, (char)"VinylFirmware");
    return 1;
  }
  v5 = ArrayBySeparatingStrings;
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
  {
    v6 = (const __CFString *)CFArrayGetValueAtIndex(v5, 0);
    IntValue = CFStringGetIntValue(v6);
    v8 = (const __CFString *)CFArrayGetValueAtIndex(v5, 1);
    v9 = (((unsigned __int16)CFStringGetIntValue(v8) | (unsigned __int16)(IntValue << 8)) & 0x7FFFu) < 0x301;
  }
  else
  {
    v29 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v29, 2u, "%s::%s: ldrVerComponents count is not expected\n", v30, v31, v32, v33, v34, (char)"VinylFirmware");
    v9 = 1;
  }
  CFRelease(v5);
  return v9;
}

const __CFData *VinylFirmware::fwLdrVerEqual(VinylFirmware *this, CFArrayRef theArray, const UInt8 *a3)
{
  const __CFString *ValueAtIndex;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *v7;
  const UInt8 *BytePtr;
  int v9;
  const __CFString *v10;
  int v11;
  const __CFString *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;

  if (!theArray || CFArrayGetCount(theArray) <= 0)
  {
    v13 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v13, 2u, "%s::%s: ldrVersStrArray count is zero\n", v14, v15, v16, v17, v18, (char)"VinylFirmware");
    return 0;
  }
  if (a3)
  {
    ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, 0);
    if (ValueAtIndex)
    {
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, ValueAtIndex, CFSTR("."));
      if (ArrayBySeparatingStrings)
      {
        v7 = ArrayBySeparatingStrings;
        if (CFArrayGetCount(ArrayBySeparatingStrings) == 2)
        {
          BytePtr = CFDataGetBytePtr((CFDataRef)a3);
          a3 = BytePtr;
          if (!BytePtr)
          {
            v44 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v44, 2u, "%s::%s: failed to get byte ptr of fwldrver\n", v45, v46, v47, v48, v49, (char)"VinylFirmware");
            goto LABEL_17;
          }
          v9 = *BytePtr;
          v10 = (const __CFString *)CFArrayGetValueAtIndex(v7, 0);
          if (CFStringGetIntValue(v10) == v9)
          {
            v11 = a3[1];
            v12 = (const __CFString *)CFArrayGetValueAtIndex(v7, 1);
            a3 = (const UInt8 *)(CFStringGetIntValue(v12) == v11);
LABEL_17:
            CFRelease(v7);
            return (const __CFData *)a3;
          }
        }
        else
        {
          v37 = sub_1000D3C90();
          sub_1000D3D08((uint64_t)v37, 2u, "%s::%s: ldrVerComponents count is not expected\n", v38, v39, v40, v41, v42, (char)"VinylFirmware");
        }
        a3 = 0;
        goto LABEL_17;
      }
      v31 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v31, 2u, "%s::%s: ldrVerComponents count is not expected\n", v32, v33, v34, v35, v36, (char)"VinylFirmware");
    }
    else
    {
      v25 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v25, 2u, "%s::%s: failed to get ldrVer\n", v26, v27, v28, v29, v30, (char)"VinylFirmware");
    }
    return 0;
  }
  v19 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v19, 2u, "%s::%s: fwldrver is null\n", v20, v21, v22, v23, v24, (char)"VinylFirmware");
  return (const __CFData *)a3;
}

BOOL VinylFirmware::fwReaderInfoPlistCallback(VinylFirmware *this, _QWORD *a2, CFStringRef theString, uint64_t a4)
{
  int v4;
  const __CFString *v8;
  VinylFirmware *HasSuffix;
  CFStringRef PathComponent;
  int v11;
  CFPropertyListRef v12;
  __CFDictionary *Mutable;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFErrorRef error;
  CFDataRef data;

  data = 0;
  v4 = 1;
  if (!a2 || !theString || !a4)
    return v4 == 0;
  v8 = (const __CFString *)a2[2];
  if (!v8 || (HasSuffix = (VinylFirmware *)CFStringHasSuffix(theString, v8), !(_DWORD)HasSuffix))
  {
    v4 = 0;
    return v4 == 0;
  }
  error = 0;
  PathComponent = VinylFirmware::getPathComponent(HasSuffix, theString);
  if (!PathComponent)
  {
    v12 = 0;
LABEL_21:
    v4 = 2;
    goto LABEL_12;
  }
  v11 = eUICCFwReaderFindAndCopyFileData(a4, theString, (CFTypeRef *)&data);
  if (v11)
  {
    v4 = v11;
    v15 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v15, 2u, "%s::%s: failed to find and/or copy data\n", v16, v17, v18, v19, v20, (char)"VinylFirmware");
    v12 = 0;
    goto LABEL_12;
  }
  v12 = CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, 0, &error);
  if (!v12)
    goto LABEL_21;
  Mutable = (__CFDictionary *)a2[7];
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    a2[7] = Mutable;
    if (!Mutable)
      goto LABEL_21;
  }
  CFDictionaryAddValue(Mutable, PathComponent, v12);
  v4 = 0;
LABEL_12:
  if (data)
  {
    CFRelease(data);
    data = 0;
  }
  if (PathComponent)
    CFRelease(PathComponent);
  if (v12)
    CFRelease(v12);
  return v4 == 0;
}

uint64_t VinylFirmware::fwReaderCallback(VinylFirmware *this, void *a2, CFStringRef theString, uint64_t a4)
{
  CFDataRef v4;
  uint64_t v5;
  const __CFArray *ArrayBySeparatingStrings;
  const __CFArray *MutableCopy;
  CFStringRef PathComponent;
  void *v13;
  uint64_t (*v14)(_QWORD, const void *, CFTypeRef *);
  const void *ValueAtIndex;
  int v16;
  const __CFString *v17;
  VinylFirmware *HasSuffix;
  const __CFDictionary *Value;
  VinylFirmware *v20;
  _BOOL8 v21;
  const void *v22;
  const UInt8 *v23;
  unsigned int v24;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v27;
  CFIndex v28;
  const __CFArray *v29;
  __CFArray *v30;
  __CFArray *v31;
  __CFArray *v32;
  const UInt8 *v33;
  CFIndex v34;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  void *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  CFTypeRef cf1;
  CFDataRef theData;
  UInt8 bytes[32];

  v4 = 0;
  v5 = 0;
  cf1 = 0;
  theData = 0;
  if (!a2 || !theString)
  {
    ArrayBySeparatingStrings = 0;
LABEL_57:
    MutableCopy = 0;
    PathComponent = 0;
    goto LABEL_39;
  }
  ArrayBySeparatingStrings = 0;
  MutableCopy = 0;
  PathComponent = 0;
  if (!a4)
    goto LABEL_39;
  ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(0, theString, CFSTR("/"));
  if (!ArrayBySeparatingStrings)
  {
LABEL_54:
    v5 = 0;
    v4 = 0;
    MutableCopy = 0;
    PathComponent = 0;
    goto LABEL_39;
  }
  v13 = (void *)*((_QWORD *)this + 23);
  if (!v13)
  {
    v36 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v36, 2u, "%s::%s: failed to open libauthinstall dylib\n", v37, v38, v39, v40, v41, (char)"VinylFirmware");
    goto LABEL_54;
  }
  v14 = (uint64_t (*)(_QWORD, const void *, CFTypeRef *))dlsym(v13, "AMAuthInstallSupportCopyDataFromHexString");
  if (dlerror() || !v14)
  {
    v42 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v42, 2u, "%s::%s: failed to initialize LAI lib create function\n", v43, v44, v45, v46, v47, (char)"VinylFirmware");
    goto LABEL_54;
  }
  ValueAtIndex = CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0);
  v16 = v14(0, ValueAtIndex, &cf1);
  v4 = 0;
  v5 = 0;
  if (!cf1 || v16)
    goto LABEL_57;
  v17 = (const __CFString *)*((_QWORD *)a2 + 1);
  if (!v17 || (HasSuffix = (VinylFirmware *)CFStringHasSuffix(theString, v17), !(_DWORD)HasSuffix))
  {
    v4 = 0;
    MutableCopy = 0;
    PathComponent = 0;
LABEL_38:
    v5 = 1;
    goto LABEL_39;
  }
  PathComponent = VinylFirmware::getPathComponent(HasSuffix, theString);
  if (!PathComponent
    || (Value = (const __CFDictionary *)CFDictionaryGetValue(*((CFDictionaryRef *)a2 + 7), PathComponent)) == 0)
  {
    v5 = 0;
    v4 = 0;
    MutableCopy = 0;
    goto LABEL_39;
  }
  v20 = (VinylFirmware *)CFDictionaryGetValue(Value, CFSTR("com.apple.EmbeddedSoftwareRestore.eUICC.bootloaderVersionsSupported"));
  MutableCopy = v20;
  if (!v20)
    goto LABEL_62;
  v21 = VinylFirmware::checkVinylFwLdrVerLegacy(v20, v20);
  v22 = (const void *)*((_QWORD *)a2 + 4);
  if (!v22)
  {
    v4 = 0;
    MutableCopy = 0;
    goto LABEL_28;
  }
  v23 = (const UInt8 *)*((_QWORD *)a2 + 5);
  if (!v23
    || v21
    && (v24 = VinylFirmware::fwLdrVerEqual((VinylFirmware *)v21, MutableCopy, v23),
        v22 = (const void *)*((_QWORD *)a2 + 4),
        v24))
  {
    v4 = 0;
    MutableCopy = 0;
    if (!CFEqual(cf1, v22))
      goto LABEL_28;
    goto LABEL_27;
  }
  MutableCopy = CFDataCreateMutableCopy(kCFAllocatorDefault, 0, (CFDataRef)v22);
  if (!MutableCopy)
  {
LABEL_62:
    v5 = 0;
    v4 = 0;
    goto LABEL_39;
  }
  BytePtr = CFDataGetBytePtr(*((CFDataRef *)a2 + 5));
  Length = CFDataGetLength(*((CFDataRef *)a2 + 5));
  CFDataAppendBytes(MutableCopy, BytePtr, Length - 1);
  v27 = CFDataGetBytePtr(MutableCopy);
  v28 = CFDataGetLength(MutableCopy);
  if (AMSupportDigestSha256(v27, v28, bytes))
  {
    v60 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v60, 2u, "%s::%s: failed to compute digest\n", v61, v62, v63, v64, v65, (char)"VinylFirmware");
    goto LABEL_62;
  }
  v4 = CFDataCreate(0, bytes, 32);
  if (!v4)
    goto LABEL_59;
  if (CFEqual(cf1, v4))
  {
LABEL_27:
    if (eUICCFwReaderFindAndCopyFileData(a4, theString, (CFTypeRef *)a2 + 3))
    {
LABEL_58:
      v48 = sub_1000D3C90();
      sub_1000D3D08((uint64_t)v48, 2u, "%s::%s: failed to find and/or copy data\n", v49, v50, v51, v52, v53, (char)"VinylFirmware");
      goto LABEL_59;
    }
  }
LABEL_28:
  v29 = (const __CFArray *)*((_QWORD *)a2 + 6);
  if (!v29)
    goto LABEL_38;
  v30 = (__CFArray *)CFArrayGetValueAtIndex(v29, 0);
  v31 = (__CFArray *)CFArrayGetValueAtIndex(*((CFArrayRef *)a2 + 6), 1);
  v5 = 0;
  if (v30)
  {
    v32 = v31;
    if (v31)
    {
      if (cf1)
      {
        CFArrayAppendValue(v30, cf1);
        if (!eUICCFwReaderFindAndCopyFileData(a4, theString, (CFTypeRef *)&theData))
        {
          v33 = CFDataGetBytePtr(theData);
          v34 = CFDataGetLength(theData);
          if (AMSupportDigestSha256(v33, v34, bytes))
          {
            v54 = sub_1000D3C90();
            sub_1000D3D08((uint64_t)v54, 2u, "%s::%s: failed to compute digest\n", v55, v56, v57, v58, v59, (char)"VinylFirmware");
            goto LABEL_38;
          }
          if (v4)
            CFRelease(v4);
          v4 = CFDataCreate(0, bytes, 32);
          if (v4)
          {
            CFArrayAppendValue(v32, v4);
            goto LABEL_38;
          }
          goto LABEL_59;
        }
        goto LABEL_58;
      }
LABEL_59:
      v5 = 0;
    }
  }
LABEL_39:
  if (theData)
  {
    CFRelease(theData);
    theData = 0;
  }
  if (cf1)
  {
    CFRelease(cf1);
    cf1 = 0;
  }
  if (v4)
    CFRelease(v4);
  if (ArrayBySeparatingStrings)
    CFRelease(ArrayBySeparatingStrings);
  if (MutableCopy)
    CFRelease(MutableCopy);
  if (PathComponent)
    CFRelease(PathComponent);
  return v5;
}

void VinylFirmware::generateMeasurement(VinylFirmware *this@<X0>, CFDataRef *a2@<X8>)
{
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef v13;
  void *v14;
  std::string *v15;
  __int128 v16;
  std::string *v17;
  __int128 v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  std::string v31;
  std::string v32;
  void *__p[2];
  std::string::size_type v34;
  UInt8 bytes[32];

  v5 = sub_1000D3C90();
  sub_1000D3D08((uint64_t)v5, 4u, "%s::%s: entering: %s\n", v6, v7, v8, v9, v10, (char)"VinylFirmware");
  *a2 = 0;
  BytePtr = CFDataGetBytePtr(this);
  Length = CFDataGetLength(this);
  if (AMSupportDigestSha256(BytePtr, Length, bytes))
  {
    v25 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v25, 2u, "%s::%s: failed to compute digest\n", v26, v27, v28, v29, v30, (char)"VinylFirmware");
  }
  else
  {
    v13 = CFDataCreate(0, bytes, 32);
    *a2 = v13;
    __p[0] = 0;
    sub_1000F1A90((const void **)__p);
    v14 = sub_1000D3C90();
    sub_1000CB3F4(&v31, "VinylFirmware");
    v15 = std::string::append(&v31, "::");
    v16 = *(_OWORD *)&v15->__r_.__value_.__l.__data_;
    v32.__r_.__value_.__r.__words[2] = v15->__r_.__value_.__r.__words[2];
    *(_OWORD *)&v32.__r_.__value_.__l.__data_ = v16;
    v15->__r_.__value_.__l.__size_ = 0;
    v15->__r_.__value_.__r.__words[2] = 0;
    v15->__r_.__value_.__r.__words[0] = 0;
    v17 = std::string::append(&v32, "generateMeasurement");
    v18 = *(_OWORD *)&v17->__r_.__value_.__l.__data_;
    v34 = v17->__r_.__value_.__r.__words[2];
    *(_OWORD *)__p = v18;
    v17->__r_.__value_.__l.__size_ = 0;
    v17->__r_.__value_.__r.__words[2] = 0;
    v17->__r_.__value_.__r.__words[0] = 0;
    sub_1000D42F0((uint64_t)v14, (uint64_t *)__p, 0, (uint64_t)"digestRef: ", (uint64_t)v13);
    if (SHIBYTE(v34) < 0)
      operator delete(__p[0]);
    if (SHIBYTE(v32.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v32.__r_.__value_.__l.__data_);
    if (SHIBYTE(v31.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v31.__r_.__value_.__l.__data_);
    v19 = sub_1000D3C90();
    sub_1000D3D08((uint64_t)v19, 4u, "%s::%s: leaving: %s\n", v20, v21, v22, v23, v24, (char)"VinylFirmware");
  }
}

void sub_1000F7A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23,uint64_t a24,void *__p,uint64_t a26,int a27,__int16 a28,char a29,char a30)
{
  const void **v30;

  if (a30 < 0)
    operator delete(__p);
  if (a23 < 0)
    operator delete(a18);
  if (a17 < 0)
    operator delete(a12);
  sub_1000F1A90(v30);
  _Unwind_Resume(a1);
}

const void **sub_1000F7ADC(const void **a1)
{
  const void **v2;
  const void *v3;
  const void *v4;
  const void *v6;

  v2 = (const void **)a1[1];
  if (*a1)
  {
    v3 = *v2;
    *v2 = *a1;
    v6 = v3;
  }
  else
  {
    v4 = *v2;
    *v2 = 0;
    v6 = v4;
  }
  sub_1000F1A90(&v6);
  return a1;
}

uint64_t check_some_ace3_in_bad_state(_BYTE *a1)
{
  uint64_t *v2;
  __CFArray *Mutable;
  __CFDictionary *v4;
  io_registry_entry_t v5;
  unsigned int v6;
  const __CFAllocator *v7;
  unsigned int v8;
  char v9;
  const __CFAllocator *v10;
  uint64_t v11;
  uint64_t *v12;
  const __CFDictionary *v13;
  CFNumberRef v14;
  const __CFDictionary *Value;
  __CFDictionary *MutableCopy;
  __CFDictionary *v17;
  _BOOL4 v18;
  io_object_t v19;
  io_service_t v20;
  const __CFUUID *v21;
  const __CFUUID *v22;
  IOCFPlugInInterface **v23;
  HRESULT (__cdecl *QueryInterface)(void *, REFIID, LPVOID *);
  const __CFUUID *v25;
  CFUUIDBytes v26;
  unint64_t v27;
  int v28;
  int v29;
  int v30;
  char v32;
  unsigned int v33;
  io_iterator_t existing;
  IOCFPlugInInterface **theInterface;
  SInt32 theScore;
  io_iterator_t iterator;
  char valuePtr;
  unint64_t v39;

  sub_1000F811C("Running Ace3 mode check\n");
  existing = 0;
  qword_1001A8F98 = 0;
  byte_1001A8FA0 = 0;
  v2 = &qword_1001A8000;
  byte_1001A8FA1 = 0;
  Mutable = CFArrayCreateMutable(0, 2, &kCFTypeArrayCallBacks);
  CFArrayAppendValue(Mutable, CFSTR("usbc,sn201202x,spmi"));
  CFArrayAppendValue(Mutable, CFSTR("usbc,sn201202x,iic"));
  v4 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(v4, CFSTR("IONameMatch"), Mutable);
  CFRelease(Mutable);
  if (!v4)
  {
    sub_1000F811C("could not create EDT property dict\n");
LABEL_62:
    v5 = 0;
    goto LABEL_54;
  }
  if (IOServiceGetMatchingServices(kIOMasterPortDefault, v4, &existing))
  {
    LOBYTE(v4) = 0;
    goto LABEL_62;
  }
  v5 = IOIteratorNext(existing);
  LOBYTE(v6) = byte_1001A8FA1;
  if (v5 && byte_1001A8FA1 <= 7u)
  {
    v32 = 0;
    v7 = kCFAllocatorDefault;
    while (1)
    {
      LODWORD(v39) = 0;
      if (sub_1000F81A8(v5, CFSTR("usbc-update-protocol"), (UInt8 *)&v39))
      {
        sub_1000F811C("Error when reading usbc-update-protocol\n");
        goto LABEL_44;
      }
      v8 = v39 - 1;
      if ((v39 - 1) >= 2)
        sub_1000F811C("Unexpected usbc-update-protocol value\n");
      else
        sub_1000F811C("Found updatable Ace based on usbc-update-protocol value\n");
      if (v8 > 1)
        goto LABEL_44;
      v33 = -1;
      if (sub_1000F81A8(v5, CFSTR("rid"), (UInt8 *)&v33) || (v9 = v33, v33 > 0xFF))
      {
        sub_1000F811C("Couldn't find RID for service!\n");
        goto LABEL_53;
      }
      v10 = v7;
      v11 = *((unsigned __int8 *)v2 + 4001);
      v12 = v2;
      *((_BYTE *)v2 + 4001) = v11 + 1;
      valuePtr = v9;
      v13 = IOServiceMatching("AppleHPMARM");
      v14 = CFNumberCreate(v7, kCFNumberSInt8Type, &valuePtr);
      if (CFDictionaryContainsKey(v13, CFSTR("IOPropertyMatch")))
      {
        Value = (const __CFDictionary *)CFDictionaryGetValue(v13, CFSTR("IOPropertyMatch"));
        MutableCopy = CFDictionaryCreateMutableCopy(v10, 2, Value);
      }
      else
      {
        MutableCopy = CFDictionaryCreateMutable(v10, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      v17 = MutableCopy;
      CFDictionaryAddValue(MutableCopy, CFSTR("RID"), v14);
      CFDictionaryAddValue(v13, CFSTR("IOPropertyMatch"), v17);
      CFRelease(v17);
      CFRelease(v14);
      v39 = 0;
      iterator = 0;
      if (IOServiceGetMatchingServices(kIOMasterPortDefault, v13, &iterator))
      {
        sub_1000F811C("Error finding IOKit service\n");
LABEL_19:
        sub_1000F811C("getAHPMLibInterfaceForRID failed for rid=0x%X\n", v33);
        LOBYTE(v18) = 1;
        goto LABEL_20;
      }
      if (!iterator)
      {
        sub_1000F811C("Found no matching services\n");
        goto LABEL_19;
      }
      v19 = IOIteratorNext(iterator);
      if (v19)
      {
        v20 = v19;
        do
        {
          theScore = 0;
          theInterface = 0;
          v21 = CFUUIDGetConstantUUIDWithBytes(0, 0x12u, 0xA1u, 0xDCu, 0xCFu, 0xCFu, 0x7Au, 0x47u, 0x75u, 0xBEu, 0xE5u, 0x9Cu, 0x43u, 0x19u, 0xF4u, 0xCDu, 0x2Bu);
          v22 = CFUUIDGetConstantUUIDWithBytes(0, 0xC2u, 0x44u, 0xE8u, 0x58u, 0x10u, 0x9Cu, 0x11u, 0xD4u, 0x91u, 0xD4u, 0, 0x50u, 0xE4u, 0xC6u, 0x42u, 0x6Fu);
          if (!IOCreatePlugInInterfaceForService(v20, v21, v22, &theInterface, &theScore))
          {
            v23 = theInterface;
            QueryInterface = (*theInterface)->QueryInterface;
            v25 = CFUUIDGetConstantUUIDWithBytes(0, 0xC1u, 0x3Au, 0xCDu, 0xD9u, 0x20u, 0x9Eu, 0x4Bu, 1u, 0xB7u, 0xBEu, 0xE0u, 0x5Cu, 0xD8u, 0x83u, 0xC7u, 0xB1u);
            v26 = CFUUIDGetUUIDBytes(v25);
            if (((unsigned int (*)(IOCFPlugInInterface **, _QWORD, _QWORD, unint64_t *))QueryInterface)(v23, *(_QWORD *)&v26.byte0, *(_QWORD *)&v26.byte8, &v39))
            {
              sub_1000F811C("QueryInterface failed\n");
            }
            ((void (*)(IOCFPlugInInterface **))(*theInterface)->Release)(theInterface);
          }
          IOObjectRelease(v20);
          v20 = IOIteratorNext(iterator);
        }
        while (v20);
        v27 = v39;
        if (v39)
          v28 = 0;
        else
          v28 = -536870208;
      }
      else
      {
        v27 = 0;
        v28 = -536870208;
      }
      if (iterator)
        IOObjectRelease(iterator);
      if (v28)
        goto LABEL_19;
      v39 = 0;
      v29 = (*(uint64_t (**)(unint64_t, _QWORD, uint64_t, IOCFPlugInInterface ***, uint64_t, _QWORD, unint64_t *))(*(_QWORD *)v27 + 40))(v27, 0, 3, &theInterface, 4, 0, &v39);
      if (v29)
        break;
      if (v39 <= 3)
      {
        v30 = -536870167;
        goto LABEL_49;
      }
      v30 = 0;
      v18 = (_DWORD)theInterface == 1430668353;
LABEL_40:
      (*(void (**)(unint64_t))(*(_QWORD *)v27 + 24))(v27);
      if (!v30)
      {
        v2 = v12;
        if (v18)
        {
          LOBYTE(v18) = 1;
          v32 = 1;
        }
        goto LABEL_43;
      }
      sub_1000F811C("check_in_adfu failed, rid=0x%X\n", v33);
LABEL_20:
      v2 = v12;
LABEL_43:
      *((_BYTE *)&qword_1001A8F98 + v11) = v18;
      v7 = kCFAllocatorDefault;
LABEL_44:
      IOObjectRelease(v5);
      v5 = IOIteratorNext(existing);
      v6 = *((unsigned __int8 *)v2 + 4001);
      if (!v5 || v6 >= 8)
        goto LABEL_52;
    }
    v30 = v29;
LABEL_49:
    sub_1000F811C("get_mode failed\n");
    v18 = 1;
    goto LABEL_40;
  }
  v32 = 0;
LABEL_52:
  *a1 = v6;
  byte_1001A8FA0 = 1;
LABEL_53:
  LOBYTE(v4) = v32;
LABEL_54:
  if (existing)
    IOObjectRelease(existing);
  if (v5)
    IOObjectRelease(v5);
  return v4;
}

const char *sub_1000F811C(const char *__format, ...)
{
  char __str[128];
  va_list va;

  va_start(va, __format);
  if (__format)
  {
    if (_log)
    {
      vsnprintf(__str, 0x80uLL, __format, va);
      return (const char *)_log(_context, __str);
    }
  }
  return __format;
}

uint64_t sub_1000F81A8(io_registry_entry_t a1, const __CFString *a2, UInt8 *a3)
{
  uint64_t v4;
  const __CFData *CFProperty;
  const __CFData *v6;
  CFRange v8;

  v4 = 3758097084;
  CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(a1, a2, kCFAllocatorDefault, 0);
  if (!CFProperty)
    return 3758097136;
  v6 = CFProperty;
  if (CFDataGetLength(CFProperty) >= 4)
  {
    v8.location = 0;
    v8.length = 4;
    CFDataGetBytes(v6, v8, a3);
    v4 = 0;
  }
  CFRelease(v6);
  return v4;
}

uint64_t queryNumUpdatableUSBCPortControllers(BOOL *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3)
{
  int v4;
  unsigned __int8 v6;

  _log = a2;
  _context = a3;
  v6 = 0;
  v4 = check_some_ace3_in_bad_state(&v6);
  if (a1)
    *a1 = v4 == 0;
  return v6;
}

const char *verifyUSBCPortControllerNonceHash(__CFData *a1, unsigned int a2, uint64_t (*a3)(_QWORD, _QWORD), uint64_t a4)
{
  const char *result;
  unsigned int v7;

  _log = a3;
  _context = a4;
  result = sub_1000F811C("Checking LUN=%u\n", a2);
  if ((byte_1001A8FA0 & 1) != 0)
  {
    v7 = byte_1001A8FA1;
  }
  else
  {
    result = (const char *)check_some_ace3_in_bad_state(&byte_1001A8FA1);
    if (!(_DWORD)result)
      return result;
    v7 = byte_1001A8FA1;
  }
  if (v7 >= a2 && *((_BYTE *)&qword_1001A8F98 + a2 - 1))
  {
    sub_1000F811C("Flipping nonce for LUN=%u\n", a2);
    result = (const char *)CFDataGetMutableBytePtr(a1);
    if (result)
      *result ^= 1u;
    else
      return sub_1000F811C("Could not get nonceHash!\n");
  }
  return result;
}

uint64_t lzvn_decode_buffer(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  if (a2)
  {
    if (a3 <= a3 + a4 - 8)
      __asm { BR              X17 }
    __asm { BTI             j }
    return 0;
  }
  else
  {
    __asm { BTI             j }
    return 0;
  }
}

int32x4_t **lz4_encode_2gb(int32x4_t **result, uint64_t a2, char **a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int32x4_t v7;
  int32x4_t *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  char *v13;
  unint64_t v14;
  int *v15;
  int v16;
  int v17;
  unint64_t v18;
  int *v19;
  int v20;
  int v21;
  uint64_t v22;
  _BYTE *v24;
  unint64_t v25;
  int *v26;
  int v27;
  int v28;
  _BYTE *v30;
  unint64_t v31;
  int *v32;
  int v33;
  int v34;
  _BYTE *v36;
  unint64_t v37;
  int *v38;
  int v39;
  int v40;
  _BYTE *v42;
  char *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  BOOL v51;
  int v52;
  int v53;
  int v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  __int8 v59;
  int32x4_t *v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  int32x4_t v64;
  _WORD *v65;
  int32x4_t *v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int32x4_t *v76;
  unsigned int v77;
  int64_t v78;
  uint64_t v79;
  int32x4_t v80;
  __int8 v81;

  v7 = vdupq_n_s32(0xFFFFFFFF);
  v8 = *result;
  v9 = *a3;
  v10 = (uint64_t)(*result)[-8].i64 + a2;
  if (v10 < (uint64_t)*result)
    goto LABEL_92;
  v11 = (uint64_t)&v9[a5 - 128];
  if (v11 >= (uint64_t)v9)
  {
    do
    {
      v12 = v9;
      v13 = &v9[-a4];
      while (1)
      {
        v14 = *v12;
        v15 = (int *)(a6 + 8 * ((-1640531535 * *v12) >> 20));
        v16 = *v15;
        v17 = v15[1];
        *v15 = (int)v13;
        v15[1] = v14;
        v18 = v14 >> 8;
        v19 = (int *)(a6 + 8 * ((-1640531535 * (v14 >> 8)) >> 20));
        v20 = *v19;
        v21 = v19[1];
        *v19 = (_DWORD)v13 + 1;
        v19[1] = v14 >> 8;
        if ((_DWORD)v14 == v17)
        {
          v22 = ((_DWORD)v13 - v16);
          if (v22 < 0x10000 && (_DWORD)v22 != 0)
            break;
        }
        v12 = (_QWORD *)((char *)v12 + 1);
        v24 = v13 + 1;
        v25 = v14 >> 16;
        v26 = (int *)(a6 + 8 * ((-1640531535 * v25) >> 20));
        v27 = *v26;
        v28 = v26[1];
        *v26 = (_DWORD)v24 + 1;
        v26[1] = v25;
        if ((_DWORD)v18 == v21)
        {
          v22 = ((_DWORD)v24 - v20);
          if (v22 < 0x10000 && (_DWORD)v24 != v20)
            break;
        }
        v12 = (_QWORD *)((char *)v12 + 1);
        v30 = v24 + 1;
        v31 = v25 >> 8;
        v32 = (int *)(a6 + 8 * ((-1640531535 * (v25 >> 8)) >> 20));
        v33 = *v32;
        v34 = v32[1];
        *v32 = (_DWORD)v30 + 1;
        v32[1] = v25 >> 8;
        if ((_DWORD)v25 == v28)
        {
          v22 = ((_DWORD)v30 - v27);
          if (v22 < 0x10000 && (_DWORD)v30 != v27)
            break;
        }
        v12 = (_QWORD *)((char *)v12 + 1);
        v36 = v30 + 1;
        v37 = v25 >> 16;
        v38 = (int *)(a6 + 8 * ((-1640531535 * v37) >> 20));
        v39 = *v38;
        v40 = v38[1];
        *v38 = (_DWORD)v36 + 1;
        v38[1] = v37;
        if ((_DWORD)v31 == v34)
        {
          v22 = ((_DWORD)v36 - v33);
          if (v22 < 0x10000 && (_DWORD)v36 != v33)
            break;
        }
        v12 = (_QWORD *)((char *)v12 + 1);
        v42 = v36 + 1;
        if ((_DWORD)v37 == v40)
        {
          v22 = ((_DWORD)v42 - v39);
          if (v22 < 0x10000 && (_DWORD)v42 != v39)
            break;
        }
        v12 = (_QWORD *)((char *)v12 + 1);
        v13 = v42 + 1;
        if ((unint64_t)v12 >= v11)
          goto LABEL_74;
      }
      v44 = (char *)v12 + 4;
      v45 = (_QWORD *)((char *)v12 - v22 + 4);
      while (1)
      {
        v47 = *(_QWORD *)v44;
        v44 += 8;
        v46 = v47;
        v49 = *v45++;
        v48 = v49;
        if (v46 != v49)
          break;
        if ((unint64_t)v44 >= v11)
          goto LABEL_38;
      }
      v44 = &v44[(__clz(__rbit64(v46 ^ v48)) >> 3) - 8];
LABEL_38:
      v50 = (char *)v12 - v22;
      while (1)
      {
        v51 = (uint64_t)v12 <= (uint64_t)v9 || (uint64_t)v50 <= a4;
        if (v51)
          break;
        v53 = *((unsigned __int8 *)v12 - 1);
        v12 = (_QWORD *)((char *)v12 - 1);
        v52 = v53;
        v54 = *--v50;
        if (v52 != v54)
        {
          v12 = (_QWORD *)((char *)v12 + 1);
          break;
        }
      }
      v55 = v44 - (char *)v12 - 4;
      v56 = (char *)v12 - v9;
      v57 = (char *)v12 - v9 + 3;
      v58 = v10 - (_QWORD)v8 - v57;
      if (v10 - (uint64_t)v8 < v57)
        goto LABEL_92;
      v59 = (v55 & 0xF) + 16 * v56;
      v60 = (int32x4_t *)&v8->i8[1];
      if ((unint64_t)v56 >= 0xF)
      {
        v59 |= 0xF0u;
        v61 = v56 - 15;
        v62 = v58-- != 0;
        if (!v62)
          goto LABEL_92;
        if (v61 >= 0xFF)
        {
          v63 = v61 / 0xFFuLL;
          v62 = v58 >= v63;
          v58 -= v63;
          if (!v62)
            goto LABEL_92;
          LOBYTE(v61) = v61 + v63;
          do
          {
            *v60++ = v7;
            v51 = v63 > 0x10;
            v63 -= 16;
          }
          while (v51);
          v60 = (int32x4_t *)((char *)v60 + v63);
        }
        v60->i8[0] = v61;
        v60 = (int32x4_t *)((char *)v60 + 1);
      }
      do
      {
        v64 = *(int32x4_t *)v9;
        v9 += 16;
        *v60++ = v64;
        v51 = v56 <= 16;
        v56 -= 16;
      }
      while (!v51);
      v65 = (__int16 *)((char *)v60->i16 + v56);
      *v65 = v22;
      v66 = (int32x4_t *)(v65 + 1);
      if (v55 >= 0xF)
      {
        v59 |= 0xFu;
        v67 = v44 - (char *)v12 - 19;
        v62 = v58 != 0;
        v68 = v58 - 1;
        if (!v62)
          goto LABEL_92;
        if (v67 >= 0xFF)
        {
          v69 = v67 / 0xFFuLL;
          if (v68 < v69)
            goto LABEL_92;
          LOBYTE(v67) = v67 + v69;
          do
          {
            *v66++ = v7;
            v51 = v69 > 0x10;
            v69 -= 16;
          }
          while (v51);
          v66 = (int32x4_t *)((char *)v66 + v69);
        }
        v66->i8[0] = v67;
        v66 = (int32x4_t *)((char *)v66 + 1);
      }
      v8->i8[0] = v59;
      v8 = v66;
      v9 = v44;
    }
    while ((uint64_t)v44 < v11 && (uint64_t)v66 < v10);
  }
LABEL_74:
  if (a7)
    goto LABEL_92;
  v71 = (char *)(v11 + 128);
  v72 = v71 - v9;
  if (v71 == v9)
    goto LABEL_92;
  v73 = v10 + 128 - (_QWORD)v8 - 1;
  v51 = v73 <= v72;
  v74 = v73 - v72;
  if (v51)
    goto LABEL_92;
  if (v72 < 15)
  {
    v8->i8[0] = 16 * v72;
    v8 = (int32x4_t *)((char *)v8 + 1);
    do
    {
LABEL_91:
      v81 = *v9++;
      v8->i8[0] = v81;
      v8 = (int32x4_t *)((char *)v8 + 1);
    }
    while (v9 < v71);
    goto LABEL_92;
  }
  v75 = v74 - 1;
  if (v75 >= 0)
  {
    v8->i8[0] = -16;
    v76 = (int32x4_t *)&v8->i8[1];
    v77 = v72 - 15;
    if ((unint64_t)(v72 - 15) >= 0xFF)
    {
      v78 = v77 / 0xFFuLL;
      if (v75 - v78 < 0)
      {
        v8 = (int32x4_t *)((char *)v76 - 1);
        goto LABEL_92;
      }
      LOBYTE(v77) = v77 + v78;
      do
      {
        *v76++ = v7;
        v51 = v78 <= 16;
        v78 -= 16;
      }
      while (!v51);
      v76 = (int32x4_t *)((char *)v76 + v78);
    }
    v76->i8[0] = v77;
    v8 = (int32x4_t *)&v76->i8[1];
    v79 = (unint64_t)v72 >> 4;
    if (!((unint64_t)v72 >> 4))
      goto LABEL_91;
    do
    {
      v80 = *(int32x4_t *)v9;
      v9 += 16;
      *v8++ = v80;
      v51 = v79-- <= 1;
    }
    while (!v51);
    if (v9 < v71)
      goto LABEL_91;
  }
LABEL_92:
  *result = v8;
  *a3 = v9;
  return result;
}

uint64_t lz4_decode_asm(int8x16_t **a1, unint64_t a2, unint64_t a3, unsigned __int8 **a4, unint64_t a5)
{
  unsigned __int8 *v5;
  int8x16_t *v6;
  int8x16_t *v7;
  unsigned __int8 *v8;
  _OWORD *v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;
  int8x16_t *v14;
  int8x16_t *v15;
  unsigned __int16 *v16;
  int8x16_t *v17;
  int8x16_t *v18;
  int8x16_t v19;
  int8x16_t v20;
  int8x16_t *v21;
  int8x16_t v22;
  int8x16_t v23;
  unint64_t v24;
  unsigned int v25;
  int8x16_t *v26;
  int8x16_t *v27;
  unsigned int v28;
  int8x16_t *v29;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t v32;
  int8x16_t *v33;
  int8x16_t *v34;
  int8x16_t *v35;
  int8x16_t v36;
  int8x16_t *v37;
  int8x16_t v38;
  int8x16_t v39;
  int8x16_t *v40;
  int8x16_t v41;
  int8x16_t *v42;
  int8x16_t *v43;
  int8x16_t v44;
  int8x16_t *v45;
  int8x16_t v46;
  uint64_t v47;

  v5 = *a4;
  v6 = *a1;
  while (1)
  {
    v7 = v6;
    v8 = v5;
    if ((unint64_t)v5 >= a5 || (unint64_t)v6 >= a3)
      break;
    v10 = *v5;
    v9 = v5 + 1;
    v11 = (unint64_t)v10 >> 4;
    v12 = (v10 & 0xF) + 4;
    if (v11 > 0xE)
    {
      while ((unint64_t)v9 < a5)
      {
        v13 = *(unsigned __int8 *)v9;
        v9 = (_OWORD *)((char *)v9 + 1);
        v11 += v13;
        if (v13 != 255)
        {
          v14 = (int8x16_t *)v9;
          v15 = v6;
          v16 = (unsigned __int16 *)((char *)v9 + v11);
          v17 = (int8x16_t *)((char *)v6 + v11);
          if ((unint64_t)v16 < a5 && (unint64_t)v17 < a3)
          {
            v19 = *v14;
            v20 = v14[1];
            v18 = v14 + 2;
            *v15 = v19;
            v15[1] = v20;
            v21 = v15 + 2;
            do
            {
              v22 = *v18;
              v23 = v18[1];
              v18 += 2;
              *v21 = v22;
              v21[1] = v23;
              v21 += 2;
            }
            while (v17 > v21);
            goto LABEL_13;
          }
          goto LABEL_36;
        }
      }
      break;
    }
    *v6 = *(int8x16_t *)v9;
    v16 = (unsigned __int16 *)((char *)v9 + v11);
    v17 = (int8x16_t *)((char *)v6 + v11);
LABEL_13:
    if ((unint64_t)v16 >= a5)
      break;
    v25 = *v16;
    v5 = (unsigned __int8 *)(v16 + 1);
    v24 = v25;
    if (!v25 || (v26 = (int8x16_t *)((char *)v17 - v24), (unint64_t)v17 - v24 < a2))
    {
      v47 = -1;
      goto LABEL_37;
    }
    v27 = v17;
    v6 = (int8x16_t *)((char *)v17 + v12);
    if (v12 == 19)
    {
      while ((unint64_t)v5 < a5)
      {
        v28 = *v5++;
        v6 = (int8x16_t *)((char *)v6 + v28);
        if (v28 != 255)
        {
          if ((unint64_t)v6 >= a3)
            goto LABEL_36;
          goto LABEL_24;
        }
      }
      break;
    }
    if (v12 > 0x10)
    {
LABEL_24:
      if (v24 > 0x1F)
      {
        v36 = *v26;
        v35 = v26 + 1;
        *v27 = v36;
        v37 = v27 + 1;
        do
        {
          v38 = *v35;
          v39 = v35[1];
          v35 += 2;
          *v37 = v38;
          v37[1] = v39;
          v37 += 2;
        }
        while (v6 > v37);
      }
      else if (v24 > 0xF)
      {
        v41 = *v26;
        v40 = v26 + 1;
        *v27 = v41;
        v42 = v27 + 1;
        do
        {
          v44 = *v40;
          v43 = v40 + 1;
          *v42 = v44;
          v45 = v42 + 1;
          v46 = *v43;
          v40 = v43 + 1;
          *v45 = v46;
          v42 = v45 + 1;
        }
        while (v6 > v42);
      }
      else
      {
        v29 = (int8x16_t *)&qword_1000F8EC0[4 * v24];
        v30 = vqtbl1q_s8(*v26, *v29);
        v31 = vqtbl1q_s8(*v26, v29[1]);
        v32 = *((unsigned __int8 *)qword_1000F90C0 + v24);
        *v27 = v30;
        v27[1] = v31;
        v33 = (int8x16_t *)((char *)v27 + v32);
        do
        {
          *v33 = v30;
          v33[1] = v31;
          v34 = (int8x16_t *)((char *)v33 + v32);
          *v34 = v30;
          v34[1] = v31;
          v33 = (int8x16_t *)((char *)v34 + v32);
        }
        while (v6 > v33);
      }
    }
    else if (v24 <= 0xF)
    {
      *v27 = vqtbl1q_s8(*v26, *(int8x16_t *)&qword_1000F8EC0[4 * v24]);
    }
    else
    {
      *v27 = *v26;
    }
  }
LABEL_36:
  v47 = 0;
LABEL_37:
  *a4 = v8;
  *a1 = v7;
  return v47;
}

uint64_t lzfse_decode_lmd(uint64_t a1)
{
  _QWORD *v1;
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  unsigned __int8 *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned __int8 *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned __int8 *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  int8x16_t *v32;
  int8x16_t *v33;
  uint64_t v34;
  uint64_t v35;
  int8x16_t *v36;
  unint64_t v37;
  int8x16_t v38;
  int8x16_t v39;
  uint64_t v40;
  BOOL v41;
  char v42;
  char *v43;
  char v44;

  v1 = *(_QWORD **)(a1 + 24);
  v2 = (uint64_t *)(*(_QWORD *)a1 + *(int *)(a1 + 120));
  v3 = *(_QWORD *)(a1 + 104);
  v4 = *(unsigned int *)(a1 + 112);
  v5 = *(unsigned int *)(a1 + 72);
  v6 = *(unsigned int *)(a1 + 88);
  v7 = *(unsigned int *)(a1 + 92);
  v8 = *(unsigned int *)(a1 + 96);
  v9 = *(unsigned __int16 *)(a1 + 124);
  v10 = *(unsigned __int16 *)(a1 + 126);
  v11 = *(unsigned __int16 *)(a1 + 128);
  v12 = *(_QWORD *)(a1 + 40) - (_QWORD)v1 - 32;
  v13 = *(char **)(a1 + 80);
  if (v6 | v7)
    goto LABEL_7;
  if (*(_DWORD *)(a1 + 72))
  {
    while (1)
    {
      v2 = (uint64_t *)((char *)v2 - ((unint64_t)(63 - v4) >> 3));
      if ((unint64_t)v2 < *(_QWORD *)(a1 + 8))
        return -3;
      v3 = *v2;
      v14 = (unsigned __int8 *)(a1 + 136 + 8 * v9);
      v15 = *v14;
      v16 = v4 + ((63 - v4) & 0xFFFFFFFFFFFFFFF8) - v15;
      v17 = (unint64_t)*v2 >> v16;
      v18 = v17 & ~(-1 << v15);
      LOBYTE(v15) = v14[1];
      v9 = (v18 >> v15) + *((unsigned __int16 *)v14 + 1);
      v6 = (v17 & ~(-1 << v15)) + *((unsigned int *)v14 + 1);
      v19 = (unsigned __int8 *)(a1 + 648 + 8 * v10);
      v20 = *v19;
      v21 = v16 - v20;
      v22 = (unint64_t)*v2 >> v21;
      v23 = v22 & ~(-1 << v20);
      LOBYTE(v20) = v19[1];
      v10 = (v23 >> v20) + *((unsigned __int16 *)v19 + 1);
      v7 = (v22 & ~(-1 << v20)) + *((unsigned int *)v19 + 1);
      v24 = (unsigned __int8 *)(a1 + 1160 + 8 * v11);
      v25 = *v24;
      v4 = v21 - v25;
      v26 = (unint64_t)*v2 >> v4;
      v27 = v26 & ~(-1 << v25);
      LOBYTE(v25) = v24[1];
      v11 = (v27 >> v25) + *((unsigned __int16 *)v24 + 1);
      v28 = (v26 & ~(-1 << v25)) + *((unsigned int *)v24 + 1);
      if (v28)
        v8 = v28;
      --v5;
LABEL_7:
      if (v8 > (unint64_t)v1 + v6 - *(_QWORD *)(a1 + 32)
        || a1 + *(unsigned int *)(a1 + 7304) + 7308 < (uint64_t)&v13[v6])
      {
        return -3;
      }
      v29 = v12 < (uint64_t)(v6 + v7);
      v12 -= v6 + v7;
      if (v29)
      {
        v40 = v12 + v6 + v7 + 32;
        if (v6)
        {
          do
          {
            v41 = v40-- != 0;
            if (!v41)
              goto LABEL_30;
            v42 = *v13++;
            *(_BYTE *)v1 = v42;
            v1 = (_QWORD *)((char *)v1 + 1);
          }
          while (--v6);
        }
        if (v7)
        {
          v43 = (char *)v1 - v8;
          while (1)
          {
            v41 = v40-- != 0;
            if (!v41)
              break;
            v44 = *v43++;
            *(_BYTE *)v1 = v44;
            v1 = (_QWORD *)((char *)v1 + 1);
            if (!--v7)
              goto LABEL_28;
          }
LABEL_30:
          *(_QWORD *)(a1 + 24) = v1;
          *(_QWORD *)(a1 + 120) = (char *)v2 - *(_QWORD *)a1;
          *(_QWORD *)(a1 + 104) = v3;
          *(_DWORD *)(a1 + 112) = v4;
          *(_DWORD *)(a1 + 72) = v5;
          *(_DWORD *)(a1 + 88) = v6;
          *(_DWORD *)(a1 + 92) = v7;
          *(_DWORD *)(a1 + 96) = v8;
          *(_WORD *)(a1 + 124) = v9;
          *(_WORD *)(a1 + 126) = v10;
          *(_WORD *)(a1 + 128) = v11;
          *(_QWORD *)(a1 + 80) = v13;
          return -2;
        }
LABEL_28:
        v12 = v40 - 32;
        if (!v5)
          goto LABEL_29;
      }
      else
      {
        do
        {
          v30 = *(_QWORD *)v13;
          v31 = *((_QWORD *)v13 + 1);
          v13 += 16;
          *v1 = v30;
          v1[1] = v31;
          v1 += 2;
          v29 = v6 > 0x10;
          v6 -= 16;
        }
        while (v29);
        v32 = (int8x16_t *)((char *)v1 + v6);
        v13 += v6;
        v33 = (int8x16_t *)((char *)v32 - v8);
        if (v8 < 0x10)
        {
          v36 = (int8x16_t *)((char *)&unk_100168260 + 32 * v8);
          v37 = byte_100168460[v8];
          v38 = vqtbl1q_s8(*v33, *v36);
          v39 = vqtbl1q_s8(*v33, v36[1]);
          do
          {
            *v32 = v38;
            v32[1] = v39;
            v32 = (int8x16_t *)((char *)v32 + v37);
            v29 = v7 > v37;
            v7 -= v37;
          }
          while (v29);
          v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5)
            goto LABEL_29;
        }
        else
        {
          do
          {
            v34 = v33->i64[0];
            v35 = v33->i64[1];
            ++v33;
            v32->i64[0] = v34;
            v32->i64[1] = v35;
            ++v32;
            v29 = v7 > 0x10;
            v7 -= 16;
          }
          while (v29);
          v1 = (uint64_t *)((char *)v32->i64 + v7);
          if (!v5)
            goto LABEL_29;
        }
      }
    }
  }
  else
  {
LABEL_29:
    *(_QWORD *)(a1 + 24) = v1;
    return 0;
  }
}

uint64_t lzfse_decode_literals(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD **a5, unint64_t a6, double a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v12;
  int v13;
  _QWORD *v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  BOOL v30;

  v7 = LOWORD(a7);
  v8 = WORD1(a7);
  v9 = WORD2(a7);
  v10 = HIWORD(a7);
  v12 = *(_QWORD *)a4;
  v13 = *(_DWORD *)(a4 + 8);
  v14 = *a5;
  while (1)
  {
    v15 = *(_DWORD *)(a2 + 4 * v7);
    v16 = *(_DWORD *)(a2 + 4 * v8);
    v17 = *(_DWORD *)(a2 + 4 * v9);
    v18 = *(_DWORD *)(a2 + 4 * v10);
    *a1++ = (v16 & 0xFF00)
          + ((unsigned __int16)(v15 & 0xFF00) >> 8)
          + (((v18 & 0xFF00) + ((unsigned __int16)(v17 & 0xFF00) >> 8)) << 16);
    v19 = (63 - v13) & 0xFFFFFFF8;
    if (((63 - v13) & 0xFFFFFFF8) != 0)
      break;
LABEL_5:
    v20 = v13 - v15;
    v21 = v20 - v16;
    v22 = v12 >> (v13 - v15);
    v23 = v12 & qword_1000F94A0[v20];
    v24 = v21 - v17;
    v7 = v22 + HIWORD(v15);
    v25 = v23 >> (v20 - v16);
    v26 = v23 & qword_1000F94A0[v21];
    v13 = v24 - v18;
    v8 = v25 + HIWORD(v16);
    v27 = v26 >> (v21 - v17);
    v28 = v26 & qword_1000F94A0[v24];
    v9 = v27 + HIWORD(v17);
    v29 = v28 >> (v24 - v18);
    v12 = v28 & qword_1000F94A0[v13];
    v10 = v29 + HIWORD(v18);
    v30 = a3 <= 4;
    a3 -= 4;
    if (v30)
    {
      *(_QWORD *)a4 = v12;
      *(_DWORD *)(a4 + 8) = v13;
      *a5 = v14;
      return 0;
    }
  }
  v14 = (_QWORD *)((char *)v14 - (v19 >> 3));
  if ((unint64_t)v14 >= a6)
  {
    v13 += v19;
    v12 = (v12 << v19) | *v14 & qword_1000F94A0[v19];
    goto LABEL_5;
  }
  return -3;
}

void sub_1000F96A8(uint64_t a1)
{
  int v1;
  uint64_t v2;

  v1 = 138412290;
  v2 = a1;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to copy the lockbot preferences for domain: %@", (uint8_t *)&v1, 0xCu);
}

void sub_1000F9724()
{
  _os_crash("Failed to create dispatch source.");
  __break(1u);
}

void sub_1000F973C()
{
  _os_crash("Failed to create queue.");
  __break(1u);
}

void sub_1000F9754(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  id v9;
  id v10;
  id v11;
  const char *v12;
  id v13;
  uint64_t v14;

  v9 = sub_100010628((uint64_t)"main", 116, -1, *a1, CFSTR("Failed to intialize local workers."), a6, a7, a8, v14);
  v10 = objc_msgSend((id)objc_claimAutoreleasedReturnValue(v9), "description");
  v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v10));
  v13 = sub_10000F9CC(v11, v12);
  _os_crash(v13);

  __break(1u);
}

void sub_1000F97A0()
{
  _os_crash("Failed to intialize notification handler.");
  __break(1u);
}

void sub_1000F97B8(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  id v9;
  id v10;
  id v11;
  const char *v12;
  id v13;
  uint64_t v14;

  v9 = sub_100010628((uint64_t)"main", 130, -1, *a1, CFSTR("Failed to intialize remote connection handler."), a6, a7, a8, v14);
  v10 = objc_msgSend((id)objc_claimAutoreleasedReturnValue(v9), "description");
  v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v10));
  v13 = sub_10000F9CC(v11, v12);
  _os_crash(v13);

  __break(1u);
}

void sub_1000F9804(void **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  id v9;
  id v10;
  id v11;
  const char *v12;
  id v13;
  uint64_t v14;

  v9 = sub_100010628((uint64_t)"main", 125, -1, *a1, CFSTR("Failed to intialize local connection handler."), a6, a7, a8, v14);
  v10 = objc_msgSend((id)objc_claimAutoreleasedReturnValue(v9), "description");
  v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v10));
  v13 = sub_10000F9CC(v11, v12);
  _os_crash(v13);

  __break(1u);
}

void sub_1000F9850()
{
  _os_crash("Failed to check in for application disk usage XPC activity.");
  __break(1u);
}

void sub_1000F9868(uint8_t *a1, uint64_t a2, _QWORD *a3)
{
  *(_DWORD *)a1 = 138412290;
  *a3 = a2;
  sub_100019AFC((void *)&_mh_execute_header, &_os_log_default, (uint64_t)a3, "Failed to remove record (%@).", a1);
}

void sub_1000F98A8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 136315138;
  v4 = a1;
  sub_100019AFC((void *)&_mh_execute_header, &_os_log_default, a3, "Failed to load pair record (%s) from filesystem.", (uint8_t *)&v3);
}

void sub_1000F991C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  v3 = 138412290;
  v4 = a1;
  sub_100019AFC((void *)&_mh_execute_header, &_os_log_default, a3, "Failed to delete RemotePairing pair records: %@", (uint8_t *)&v3);
}

void sub_1000F9990(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_10001A720((void *)&_mh_execute_header, &_os_log_default, a3, "Failed to register remote service '%@'.", a5, a6, a7, a8, 2u);
}

void sub_1000F9A00()
{
  _os_crash("Failed to create username string.");
  __break(1u);
}

void sub_1000F9A18()
{
  _os_crash("Failed to query mobile user name.");
  __break(1u);
}

void sub_1000F9A30()
{
  uint8_t v0[16];

  *(_WORD *)v0 = 0;
  _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to reset device.", v0, 2u);
}

void sub_1000F9A74(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  if (sub_10009A464())
    v6 = 3;
  else
    v6 = 2;
  v7 = sub_10009A44C(v6, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg(*a1, v7);
  __break(1u);
}

void sub_1000F9B18(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  if (sub_10009A464())
    v6 = 3;
  else
    v6 = 2;
  v7 = sub_10009A44C(v6, v3, v4, v5, (uint64_t)&_mh_execute_header);
  _os_crash_msg(*a1, v7);
  __break(1u);
}

void sub_1000F9BA8(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10009AA40(a1, a2);
  sub_10009A464();
  sub_10009AA24();
  v7 = sub_10009A44C(v3, v4, v5, v6, (uint64_t)&_mh_execute_header);
  _os_crash_msg(*a1, v7);
  __break(1u);
}

void sub_1000F9C38(_QWORD *a1, _OWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10009AA40(a1, a2);
  sub_10009A464();
  sub_10009AA24();
  v6 = sub_10009A44C(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  sub_10009AA58(v6);
  __break(1u);
}

void sub_1000F9CAC(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  sub_10009AA40(a1, a2);
  sub_10009A464();
  sub_10009AA24();
  v7 = sub_10009A44C(v3, v4, v5, v6, (uint64_t)&_mh_execute_header);
  _os_crash_msg(*a1, v7);
  __break(1u);
}

void sub_1000F9D3C(_QWORD *a1, _OWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  sub_10009AA40(a1, a2);
  sub_10009A464();
  sub_10009AA24();
  v6 = sub_10009A44C(v2, v3, v4, v5, (uint64_t)&_mh_execute_header);
  sub_10009AA58(v6);
  __break(1u);
}

void sub_1000F9DB0(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  sub_10009A464();
  sub_10009AA24();
  v7 = sub_10009A44C(v3, v4, v5, v6, (uint64_t)&_mh_execute_header);
  _os_crash_msg(*a1, v7);
  __break(1u);
}

void sub_1000F9E48(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  sub_10009A464();
  sub_10009AA24();
  v7 = sub_10009A44C(v3, v4, v5, v6, (uint64_t)&_mh_execute_header);
  _os_crash_msg(*a1, v7);
  __break(1u);
}

void sub_1000F9ECC(_QWORD *a1, _OWORD *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *a1 = 0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  sub_10009A464();
  sub_10009AA24();
  v7 = sub_10009A44C(v3, v4, v5, v6, (uint64_t)&_mh_execute_header);
  _os_crash_msg(*a1, v7);
  __break(1u);
}

void sub_1000F9F64()
{
  __assert_rtn("_AMAuthInstallFinalize", "AMAuthInstall.c", 686, "type != NULL");
}

void sub_1000F9F8C()
{
  __assert_rtn("_AMAuthInstallCopyFormattingDescription", "AMAuthInstall.c", 741, "type != NULL");
}

void sub_1000F9FB4()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000A4548();
  _os_log_fault_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_FAULT, "%{public}s", v1, 0xCu);
  sub_1000A4540();
}

void sub_1000FA020()
{
  os_log_t v0;
  uint8_t v1[24];

  sub_1000A4548();
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s", v1, 0xCu);
  sub_1000A4540();
}

void sub_1000FA08C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000A4548();
  sub_1000A4530((void *)&_mh_execute_header, v0, v1, "%{public}s", v2, v3, v4, v5, v6);
  sub_1000A4540();
}

void sub_1000FA0EC()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000A4548();
  sub_1000A4530((void *)&_mh_execute_header, v0, v1, "%s", v2, v3, v4, v5, v6);
  sub_1000A4540();
}

void sub_1000FA14C()
{
  __assert_rtn("_AMAuthInstallPlatformTempDirURLInitialize", "AMAuthInstallPlatform.c", 714, "_tempDirURL != NULL");
}

void sub_1000FA174()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 348, "decoder != NULL");
}

void sub_1000FA19C()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 349, "buffer != NULL");
}

void sub_1000FA1C4()
{
  __assert_rtn("DERDecoderInitialize", "DERDecoder.c", 350, "ioBufferLength != NULL");
}

void sub_1000FA1EC()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 62, "buffer != NULL");
}

void sub_1000FA214()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 63, "outTagClass != NULL");
}

void sub_1000FA23C()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 64, "outTag != NULL");
}

void sub_1000FA264()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 65, "outIsConstructed != NULL");
}

void sub_1000FA28C()
{
  __assert_rtn("_DERDecodeTag", "DERDecoder.c", 66, "outConsumed != NULL");
}

void sub_1000FA2B4()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 146, "buffer != NULL");
}

void sub_1000FA2DC()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 147, "outLength != NULL");
}

void sub_1000FA304()
{
  __assert_rtn("_DERDecodeLength", "DERDecoder.c", 148, "outConsumed != NULL");
}

void sub_1000FA32C()
{
  __assert_rtn("DERDecoderGetDataWithTag", "DERDecoder.c", 418, "decoder != NULL");
}

void sub_1000FA354()
{
  __assert_rtn("DERDecoderGetDataWithTag", "DERDecoder.c", 434, "callbackData.foundItem.data != NULL");
}

void sub_1000FA37C()
{
  __assert_rtn("_DERDecoderTraverseAllItems", "DERDecoder.c", 223, "decoder != NULL");
}

void sub_1000FA3A4()
{
  __assert_rtn("_DERDecoderTraverseAllItems", "DERDecoder.c", 251, "nconsumed > 0");
}

void sub_1000FA3CC()
{
  __assert_rtn("_DERDecoderTraverseAllItems", "DERDecoder.c", 268, "nconsumed > 0");
}

void sub_1000FA3F4()
{
  __assert_rtn("DERDecoderGetEncodingWithTag", "DERDecoder.c", 468, "decoder != NULL");
}

void sub_1000FA41C()
{
  __assert_rtn("DERDecoderGetEncodingWithTag", "DERDecoder.c", 484, "callbackData.foundItem.buffer != NULL");
}

void operator delete(void *__p)
{
  while (1)
    ;
}

void *__cdecl operator new(size_t __sz)
{
  while (1)
    ;
}

id objc_msgSend_Device(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "Device");
}

id objc_msgSend_IOMatchingPropertyTable(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "IOMatchingPropertyTable");
}

id objc_msgSend_KeybagLocked(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "KeybagLocked");
}

id objc_msgSend_URLByAppendingPathComponent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLByAppendingPathComponent:");
}

id objc_msgSend_URLByDeletingLastPathComponent(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLByDeletingLastPathComponent");
}

id objc_msgSend_URLWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "URLWithString:");
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UTF8String");
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UUID");
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "UUIDString");
}

id objc_msgSend__commitHeader_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_commitHeader:withError:");
}

id objc_msgSend__componentNameSuffix(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_componentNameSuffix");
}

id objc_msgSend__copyIBICFromPath_withOptions_intoArray_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_copyIBICFromPath:withOptions:intoArray:withError:");
}

id objc_msgSend__crossingRegionChangeBoundary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_crossingRegionChangeBoundary");
}

id objc_msgSend__encodeAndWriteFirmware_toWriter_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_encodeAndWriteFirmware:toWriter:withError:");
}

id objc_msgSend__encodeAndWriteIMG3Data_isLLB_isTicket_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_encodeAndWriteIMG3Data:isLLB:isTicket:withError:");
}

id objc_msgSend__encodeFirmware_withRestoreInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_encodeFirmware:withRestoreInfo:");
}

id objc_msgSend__findFirmwareInfoEntry(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_findFirmwareInfoEntry");
}

id objc_msgSend__getSFRManifestHashForPayload_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_getSFRManifestHashForPayload:");
}

id objc_msgSend__headerMatchesBootSFRManifestHash_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_headerMatchesBootSFRManifestHash:");
}

id objc_msgSend__loadRegionLayout_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_loadRegionLayout:");
}

id objc_msgSend__maxExtendedRegionSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_maxExtendedRegionSize");
}

id objc_msgSend__maxImageSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_maxImageSize");
}

id objc_msgSend__propertyNameSuffix(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_propertyNameSuffix");
}

id objc_msgSend__restoreInfoDictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_restoreInfoDictionary");
}

id objc_msgSend__setupFileDescriptor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_setupFileDescriptor");
}

id objc_msgSend__stitchFirmwareImage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_stitchFirmwareImage");
}

id objc_msgSend__updaterClasses(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_updaterClasses");
}

id objc_msgSend__usesExtendediBootRegion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_usesExtendediBootRegion");
}

id objc_msgSend__waitForDeviceNode_withTimeout_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_waitForDeviceNode:withTimeout:");
}

id objc_msgSend__writeBytes_atOffset_ofLength_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_writeBytes:atOffset:ofLength:withError:");
}

id objc_msgSend__writeFirmware_toHeader_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "_writeFirmware:toHeader:withError:");
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "absoluteString");
}

id objc_msgSend_activate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "activate");
}

id objc_msgSend_addEntriesFromDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addEntriesFromDictionary:");
}

id objc_msgSend_addObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addObject:");
}

id objc_msgSend_addObjectsFromArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addObjectsFromArray:");
}

id objc_msgSend_addSubfileWithTagName_subfileData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addSubfileWithTagName:subfileData:");
}

id objc_msgSend_addSubfiles_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "addSubfiles:");
}

id objc_msgSend_allKeysForObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allKeysForObject:");
}

id objc_msgSend_allObjects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allObjects");
}

id objc_msgSend_allValues(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "allValues");
}

id objc_msgSend_ans2Data(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ans2Data");
}

id objc_msgSend_apNonce(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "apNonce");
}

id objc_msgSend_apNonceSlotID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "apNonceSlotID");
}

id objc_msgSend_appendBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendBytes:length:");
}

id objc_msgSend_appendData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendData:");
}

id objc_msgSend_appendFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendFormat:");
}

id objc_msgSend_appendImage_snapID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendImage:snapID:");
}

id objc_msgSend_appendString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "appendString:");
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "array");
}

id objc_msgSend_arrayWithArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithArray:");
}

id objc_msgSend_arrayWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithCapacity:");
}

id objc_msgSend_arrayWithObjects_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "arrayWithObjects:count:");
}

id objc_msgSend_asDictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "asDictionary");
}

id objc_msgSend_base64EncodedDataWithOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "base64EncodedDataWithOptions:");
}

id objc_msgSend_boardID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "boardID");
}

id objc_msgSend_boardIDPropertyName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "boardIDPropertyName");
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "BOOLValue");
}

id objc_msgSend_bootBlockImages(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bootBlockImages");
}

id objc_msgSend_bootNonce(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bootNonce");
}

id objc_msgSend_buildVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "buildVersion");
}

id objc_msgSend_bumpGeneration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bumpGeneration");
}

id objc_msgSend_byteString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "byteString");
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "bytes");
}

id objc_msgSend_caseInsensitiveCompare_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "caseInsensitiveCompare:");
}

id objc_msgSend_char1(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "char1");
}

id objc_msgSend_char2(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "char2");
}

id objc_msgSend_char3(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "char3");
}

id objc_msgSend_char4(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "char4");
}

id objc_msgSend_checkpoint_closure_context(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "checkpoint_closure_context");
}

id objc_msgSend_chipID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "chipID");
}

id objc_msgSend_chipIDPropertyName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "chipIDPropertyName");
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "code");
}

id objc_msgSend_compare_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "compare:");
}

id objc_msgSend_compare_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "compare:options:");
}

id objc_msgSend_compareTo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "compareTo:");
}

id objc_msgSend_components_fromDate_toDate_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "components:fromDate:toDate:options:");
}

id objc_msgSend_componentsSeparatedByString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "componentsSeparatedByString:");
}

id objc_msgSend_composeTSSRequest_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "composeTSSRequest:");
}

id objc_msgSend_composeTSSRequest_asMeasurement_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "composeTSSRequest:asMeasurement:");
}

id objc_msgSend_computeHash(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "computeHash");
}

id objc_msgSend_configureDataWriteDestination(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "configureDataWriteDestination");
}

id objc_msgSend_configureFileHandleWriteDestinationForURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "configureFileHandleWriteDestinationForURL:");
}

id objc_msgSend_containsObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "containsObject:");
}

id objc_msgSend_containsValueForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "containsValueForKey:");
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copy");
}

id objc_msgSend_copyCarrierBundleLocation_completion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copyCarrierBundleLocation:completion:");
}

id objc_msgSend_copyFirmwareToDestinationBundleWithError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copyFirmwareToDestinationBundleWithError:");
}

id objc_msgSend_copyFirmwareWithRestoreInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copyFirmwareWithRestoreInfo:");
}

id objc_msgSend_copyItemAtPath_toPath_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copyItemAtPath:toPath:error:");
}

id objc_msgSend_copyItemAtURL_toURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "copyItemAtURL:toURL:error:");
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "count");
}

id objc_msgSend_countByEnumeratingWithState_objects_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "countByEnumeratingWithState:objects:count:");
}

id objc_msgSend_createDirectoryAtPath_withIntermediateDirectories_attributes_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:");
}

id objc_msgSend_createFileAtPath_contents_attributes_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createFileAtPath:contents:attributes:");
}

id objc_msgSend_createFileHandleForWritingToURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "createFileHandleForWritingToURL:");
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "data");
}

id objc_msgSend_dataLength(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataLength");
}

id objc_msgSend_dataPointer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataPointer");
}

id objc_msgSend_dataUsingEncoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataUsingEncoding:");
}

id objc_msgSend_dataWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithBytes:length:");
}

id objc_msgSend_dataWithBytesNoCopy_length_freeWhenDone_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithBytesNoCopy:length:freeWhenDone:");
}

id objc_msgSend_dataWithContentsOfFile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithContentsOfFile:");
}

id objc_msgSend_dataWithContentsOfFile_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithContentsOfFile:options:error:");
}

id objc_msgSend_dataWithContentsOfURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithContentsOfURL:");
}

id objc_msgSend_dataWithContentsOfURL_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithContentsOfURL:options:error:");
}

id objc_msgSend_dataWithData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithData:");
}

id objc_msgSend_dataWithLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithLength:");
}

id objc_msgSend_dataWithPropertyList_format_options_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dataWithPropertyList:format:options:error:");
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "date");
}

id objc_msgSend_decodeBytesForKey_returnedLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "decodeBytesForKey:returnedLength:");
}

id objc_msgSend_decodeCharForKey_key_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "decodeCharForKey:key:");
}

id objc_msgSend_decodeObjectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "decodeObjectForKey:");
}

id objc_msgSend_decodeObjectOfClass_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "decodeObjectOfClass:forKey:");
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "defaultManager");
}

id objc_msgSend_defaultWorkspace(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "defaultWorkspace");
}

id objc_msgSend_deriveKeyWithSaltPtr_saltLen_infoPtr_infoLen_keyLen_outputKeyPtr_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "deriveKeyWithSaltPtr:saltLen:infoPtr:infoLen:keyLen:outputKeyPtr:");
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "description");
}

id objc_msgSend_deviceLanguagesForChangingDeviceLanguage_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "deviceLanguagesForChangingDeviceLanguage:");
}

id objc_msgSend_devicePath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "devicePath");
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionary");
}

id objc_msgSend_dictionaryWithDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithDictionary:");
}

id objc_msgSend_dictionaryWithObjects_forKeys_count_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithObjects:forKeys:count:");
}

id objc_msgSend_dictionaryWithValuesForKeys_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dictionaryWithValuesForKeys:");
}

id objc_msgSend_digest(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "digest");
}

id objc_msgSend_diskUsage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "diskUsage");
}

id objc_msgSend_distantFuture(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "distantFuture");
}

id objc_msgSend_doesNotRecognizeSelector_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "doesNotRecognizeSelector:");
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "domain");
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "doubleValue");
}

id objc_msgSend_dumpString(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dumpString");
}

id objc_msgSend_dynamicUsage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "dynamicUsage");
}

id objc_msgSend_ecID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ecID");
}

id objc_msgSend_ecid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ecid");
}

id objc_msgSend_ecidPropertyName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ecidPropertyName");
}

id objc_msgSend_encodeBytes_length_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "encodeBytes:length:forKey:");
}

id objc_msgSend_encodeObject_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "encodeObject:forKey:");
}

id objc_msgSend_enumerateApplicationsOfType_block_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateApplicationsOfType:block:");
}

id objc_msgSend_enumerateKeysAndObjectsUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateKeysAndObjectsUsingBlock:");
}

id objc_msgSend_enumerateObjectsUsingBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "enumerateObjectsUsingBlock:");
}

id objc_msgSend_eraseBytes_ofLength_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "eraseBytes:ofLength:withError:");
}

id objc_msgSend_error(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "error");
}

id objc_msgSend_errorWithDomain_code_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "errorWithDomain:code:userInfo:");
}

id objc_msgSend_evaluatePolicy_options_reply_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "evaluatePolicy:options:reply:");
}

id objc_msgSend_eventBody(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "eventBody");
}

id objc_msgSend_exceptionWithName_reason_userInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "exceptionWithName:reason:userInfo:");
}

id objc_msgSend_expandMetaData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "expandMetaData:");
}

id objc_msgSend_expandSuperBinary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "expandSuperBinary");
}

id objc_msgSend_expandTLVs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "expandTLVs");
}

id objc_msgSend_fileExistsAtPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileExistsAtPath:");
}

id objc_msgSend_fileHandleForWritingToURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileHandleForWritingToURL:error:");
}

id objc_msgSend_fileSystemRepresentation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileSystemRepresentation");
}

id objc_msgSend_fileURLWithPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileURLWithPath:");
}

id objc_msgSend_fileURLWithPath_isDirectory_relativeToURL_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileURLWithPath:isDirectory:relativeToURL:");
}

id objc_msgSend_fileValidForOffset_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "fileValidForOffset:length:");
}

id objc_msgSend_findHeaders(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "findHeaders");
}

id objc_msgSend_findPreparedHeader(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "findPreparedHeader");
}

id objc_msgSend_finished(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "finished");
}

id objc_msgSend_firmwareImages(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "firmwareImages");
}

id objc_msgSend_firmwareKeyFromBuildIdentityDict_deviceInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "firmwareKeyFromBuildIdentityDict:deviceInfo:");
}

id objc_msgSend_firmwareWriter(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "firmwareWriter");
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "firstObject");
}

id objc_msgSend_flags(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "flags");
}

id objc_msgSend_generateHashForData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generateHashForData:");
}

id objc_msgSend_generateHashForSubfile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generateHashForSubfile:");
}

id objc_msgSend_generatePersonalizedSuperBinary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generatePersonalizedSuperBinary");
}

id objc_msgSend_generatePersonalizedSuperBinaryInternal_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generatePersonalizedSuperBinaryInternal:");
}

id objc_msgSend_generateRequestDictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generateRequestDictionary");
}

id objc_msgSend_generateTLV(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generateTLV");
}

id objc_msgSend_generateTatsuMeasurements_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generateTatsuMeasurements:");
}

id objc_msgSend_generateTatsuMeasurementsPerPayload_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generateTatsuMeasurementsPerPayload:");
}

id objc_msgSend_generation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generation");
}

id objc_msgSend_generator(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "generator");
}

id objc_msgSend_getBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getBytes:length:");
}

id objc_msgSend_getBytes_range_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getBytes:range:");
}

id objc_msgSend_getLockdownToken_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getLockdownToken:");
}

id objc_msgSend_getPairedPeersWithOptions_completion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getPairedPeersWithOptions:completion:");
}

id objc_msgSend_getSubscriptionInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "getSubscriptionInfo:");
}

id objc_msgSend_hardwareInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hardwareInfo");
}

id objc_msgSend_hasPrefix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hasPrefix:");
}

id objc_msgSend_headerGeneration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "headerGeneration");
}

id objc_msgSend_headerHash(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "headerHash");
}

id objc_msgSend_headerIsInvalid_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "headerIsInvalid:");
}

id objc_msgSend_headerSignature(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "headerSignature");
}

id objc_msgSend_headerVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "headerVersion");
}

id objc_msgSend_hostMayPairWithOptions_challenge_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hostMayPairWithOptions:challenge:");
}

id objc_msgSend_hour(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "hour");
}

id objc_msgSend_ibootData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ibootData");
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "identifier");
}

id objc_msgSend_imageAddress(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "imageAddress");
}

id objc_msgSend_increaseLengthBy_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "increaseLengthBy:");
}

id objc_msgSend_info(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "info");
}

id objc_msgSend_initFile(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initFile");
}

id objc_msgSend_initWithArray_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithArray:");
}

id objc_msgSend_initWithBase64EncodedData_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBase64EncodedData:options:");
}

id objc_msgSend_initWithBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytes:length:");
}

id objc_msgSend_initWithBytes_length_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithBytes:length:encoding:");
}

id objc_msgSend_initWithCString_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithCString:encoding:");
}

id objc_msgSend_initWithCalendarIdentifier_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithCalendarIdentifier:");
}

id objc_msgSend_initWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithCapacity:");
}

id objc_msgSend_initWithChar1_char2_char3_char4_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithChar1:char2:char3:char4:");
}

id objc_msgSend_initWithContentsOfFile_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithContentsOfFile:");
}

id objc_msgSend_initWithData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithData:");
}

id objc_msgSend_initWithData_delegate_delegateQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithData:delegate:delegateQueue:");
}

id objc_msgSend_initWithData_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithData:encoding:");
}

id objc_msgSend_initWithData_metaData_tag_version_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithData:metaData:tag:version:");
}

id objc_msgSend_initWithDictionary_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithDictionary:");
}

id objc_msgSend_initWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithFormat:");
}

id objc_msgSend_initWithFormat_arguments_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithFormat:arguments:");
}

id objc_msgSend_initWithHardwareInfo_componentName_objectName_nonce_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithHardwareInfo:componentName:objectName:nonce:");
}

id objc_msgSend_initWithIOMedia_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithIOMedia:");
}

id objc_msgSend_initWithIOService_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithIOService:");
}

id objc_msgSend_initWithIOServiceWriter_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithIOServiceWriter:");
}

id objc_msgSend_initWithLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithLength:");
}

id objc_msgSend_initWithMachServiceName_options_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithMachServiceName:options:");
}

id objc_msgSend_initWithMajorVersion_minorVersion_releaseVersion_buildVersion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithMajorVersion:minorVersion:releaseVersion:buildVersion:");
}

id objc_msgSend_initWithObjects_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithObjects:");
}

id objc_msgSend_initWithOptions_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithOptions:error:");
}

id objc_msgSend_initWithOptions_logFunction_logContext_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithOptions:logFunction:logContext:");
}

id objc_msgSend_initWithService_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithService:");
}

id objc_msgSend_initWithServiceNamed_parent_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithServiceNamed:parent:");
}

id objc_msgSend_initWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithString:");
}

id objc_msgSend_initWithTag_data_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithTag:data:");
}

id objc_msgSend_initWithTag_dataPointer_dataLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithTag:dataPointer:dataLength:");
}

id objc_msgSend_initWithTimeIntervalSinceReferenceDate_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithTimeIntervalSinceReferenceDate:");
}

id objc_msgSend_initWithType_length_value_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithType:length:value:");
}

id objc_msgSend_initWithUTF8String_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "initWithUTF8String:");
}

id objc_msgSend_insertObject_atIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "insertObject:atIndex:");
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "intValue");
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "integerValue");
}

id objc_msgSend_interfaceWithProtocol_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "interfaceWithProtocol:");
}

id objc_msgSend_invalidHeaders(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "invalidHeaders");
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "invalidate");
}

id objc_msgSend_isAppInstallationAllowed(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isAppInstallationAllowed");
}

id objc_msgSend_isAppRemovalAllowed(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isAppRemovalAllowed");
}

id objc_msgSend_isAvailable(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isAvailable");
}

id objc_msgSend_isDeviceNameModificationAllowed(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isDeviceNameModificationAllowed");
}

id objc_msgSend_isEqual_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqual:");
}

id objc_msgSend_isEqualToData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqualToData:");
}

id objc_msgSend_isEqualToString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqualToString:");
}

id objc_msgSend_isEqualToValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isEqualToValue:");
}

id objc_msgSend_isErase(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isErase");
}

id objc_msgSend_isFileExistsError(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isFileExistsError");
}

id objc_msgSend_isLoginSession(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isLoginSession");
}

id objc_msgSend_isMultiUser(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isMultiUser");
}

id objc_msgSend_isRequired(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isRequired");
}

id objc_msgSend_isSingleStageBoot(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isSingleStageBoot");
}

id objc_msgSend_isSupervised(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isSupervised");
}

id objc_msgSend_isUnpairedExternalBootToRecoveryAllowed(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isUnpairedExternalBootToRecoveryAllowed");
}

id objc_msgSend_isValid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "isValid");
}

id objc_msgSend_keyWithPrefix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "keyWithPrefix:");
}

id objc_msgSend_keysSortedByValueUsingComparator_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "keysSortedByValueUsingComparator:");
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastObject");
}

id objc_msgSend_lastPathComponent(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lastPathComponent");
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "length");
}

id objc_msgSend_life(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "life");
}

id objc_msgSend_llbData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "llbData");
}

id objc_msgSend_llbWriter(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "llbWriter");
}

id objc_msgSend_loadHeaderAtOffset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "loadHeaderAtOffset:");
}

id objc_msgSend_lockdownShouldDisableDevicePairing(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lockdownShouldDisableDevicePairing");
}

id objc_msgSend_lockdownShouldDisableDeviceRestore(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "lockdownShouldDisableDeviceRestore");
}

id objc_msgSend_log_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "log:");
}

id objc_msgSend_logInternal_arguments_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logInternal:arguments:");
}

id objc_msgSend_logoData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "logoData");
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "longLongValue");
}

id objc_msgSend_longname(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "longname");
}

id objc_msgSend_magic(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "magic");
}

id objc_msgSend_majorVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "majorVersion");
}

id objc_msgSend_makeValid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "makeValid");
}

id objc_msgSend_manifest(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "manifest");
}

id objc_msgSend_manifestEpoch(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "manifestEpoch");
}

id objc_msgSend_manifestSuffix(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "manifestSuffix");
}

id objc_msgSend_markHeaderAsInvalid_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "markHeaderAsInvalid:");
}

id objc_msgSend_matchedService(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "matchedService");
}

id objc_msgSend_measurements(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "measurements");
}

id objc_msgSend_metaDataTable(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "metaDataTable");
}

id objc_msgSend_metaDataTableEntry(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "metaDataTableEntry");
}

id objc_msgSend_minorVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "minorVersion");
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "mutableCopy");
}

id objc_msgSend_needsHostPersonalization(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "needsHostPersonalization");
}

id objc_msgSend_nodeDescriptor(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "nodeDescriptor");
}

id objc_msgSend_nonce(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "nonce");
}

id objc_msgSend_noncePropertyName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "noncePropertyName");
}

id objc_msgSend_null(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "null");
}

id objc_msgSend_numberOfBytesRemainingInBlock(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberOfBytesRemainingInBlock");
}

id objc_msgSend_numberWithBool_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithBool:");
}

id objc_msgSend_numberWithInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithInt:");
}

id objc_msgSend_numberWithLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithLong:");
}

id objc_msgSend_numberWithLongLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithLongLong:");
}

id objc_msgSend_numberWithUnsignedChar_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedChar:");
}

id objc_msgSend_numberWithUnsignedInt_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedInt:");
}

id objc_msgSend_numberWithUnsignedInteger_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedInteger:");
}

id objc_msgSend_numberWithUnsignedLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedLong:");
}

id objc_msgSend_numberWithUnsignedLongLong_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedLongLong:");
}

id objc_msgSend_numberWithUnsignedShort_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "numberWithUnsignedShort:");
}

id objc_msgSend_objectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectAtIndex:");
}

id objc_msgSend_objectAtIndexedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectAtIndexedSubscript:");
}

id objc_msgSend_objectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectForKey:");
}

id objc_msgSend_objectForKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectForKeyedSubscript:");
}

id objc_msgSend_objectName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "objectName");
}

id objc_msgSend_onDemandResourcesUsage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "onDemandResourcesUsage");
}

id objc_msgSend_openService(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "openService");
}

id objc_msgSend_packStructure(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "packStructure");
}

id objc_msgSend_pairedPeer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "pairedPeer");
}

id objc_msgSend_pairingSession(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "pairingSession");
}

id objc_msgSend_pairingSessionStarted(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "pairingSessionStarted");
}

id objc_msgSend_parseOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "parseOptions:");
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "path");
}

id objc_msgSend_pathExtension(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "pathExtension");
}

id objc_msgSend_payloadData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "payloadData");
}

id objc_msgSend_payloadWith4ccTag_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "payloadWith4ccTag:");
}

id objc_msgSend_personalizedData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "personalizedData");
}

id objc_msgSend_personalizedMetaData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "personalizedMetaData");
}

id objc_msgSend_preferredBlockSize(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "preferredBlockSize");
}

id objc_msgSend_prefixNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "prefixNeedsLogicalUnitNumber");
}

id objc_msgSend_preparePayload_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "preparePayload:");
}

id objc_msgSend_processInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "processInfo");
}

id objc_msgSend_processMeasurementsForTSSOptions_unitNumber_asMeasurement_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "processMeasurementsForTSSOptions:unitNumber:asMeasurement:");
}

id objc_msgSend_processTLVsForPersonalization(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "processTLVsForPersonalization");
}

id objc_msgSend_productionMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "productionMode");
}

id objc_msgSend_productionModePropertyName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "productionModePropertyName");
}

id objc_msgSend_productionStatus(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "productionStatus");
}

id objc_msgSend_propertyListWithData_options_format_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "propertyListWithData:options:format:error:");
}

id objc_msgSend_provisioning(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "provisioning");
}

id objc_msgSend_publisherWithOptions_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "publisherWithOptions:");
}

id objc_msgSend_queryTatsuSigningServer_ssoOnly_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "queryTatsuSigningServer:ssoOnly:error:");
}

id objc_msgSend_raise(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "raise");
}

id objc_msgSend_rangeOfComposedCharacterSequencesForRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "rangeOfComposedCharacterSequencesForRange:");
}

id objc_msgSend_readDataAtOffset_ofLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "readDataAtOffset:ofLength:");
}

id objc_msgSend_readDataAtOffset_ofLength_intoBuffer_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "readDataAtOffset:ofLength:intoBuffer:");
}

id objc_msgSend_readFirmwareFileDataWithError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "readFirmwareFileDataWithError:");
}

id objc_msgSend_receivedData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "receivedData:");
}

id objc_msgSend_releaseVersion(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "releaseVersion");
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeAllObjects");
}

id objc_msgSend_removeItemAtPath_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeItemAtPath:error:");
}

id objc_msgSend_removeItemAtURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeItemAtURL:error:");
}

id objc_msgSend_removeLastObject(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeLastObject");
}

id objc_msgSend_removeObject_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObject:");
}

id objc_msgSend_removeObjectAtIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObjectAtIndex:");
}

id objc_msgSend_removeObjectForKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObjectForKey:");
}

id objc_msgSend_removeObjectsForKeys_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObjectsForKeys:");
}

id objc_msgSend_removeObjectsInRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeObjectsInRange:");
}

id objc_msgSend_removeSubfileWithTag_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "removeSubfileWithTag:");
}

id objc_msgSend_requestDictionary(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "requestDictionary");
}

id objc_msgSend_requiredTSSOptions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "requiredTSSOptions");
}

id objc_msgSend_requiresSEPInFW(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "requiresSEPInFW");
}

id objc_msgSend_resetImages(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "resetImages");
}

id objc_msgSend_result(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "result");
}

id objc_msgSend_resume(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "resume");
}

id objc_msgSend_retval(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "retval");
}

id objc_msgSend_reversed(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "reversed");
}

id objc_msgSend_rtKitKeyFromBuildIdentityDict_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "rtKitKeyFromBuildIdentityDict:");
}

id objc_msgSend_savePairedPeer_options_completion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "savePairedPeer:options:completion:");
}

id objc_msgSend_secondaryPayloadOffset(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "secondaryPayloadOffset");
}

id objc_msgSend_securityDomain(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "securityDomain");
}

id objc_msgSend_securityDomainPropertyName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "securityDomainPropertyName");
}

id objc_msgSend_securityMode(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "securityMode");
}

id objc_msgSend_securityModePropertyName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "securityModePropertyName");
}

id objc_msgSend_sem(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sem");
}

id objc_msgSend_service(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "service");
}

id objc_msgSend_serviceConnect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "serviceConnect");
}

id objc_msgSend_serviceWriter(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "serviceWriter");
}

id objc_msgSend_setAcl_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAcl:");
}

id objc_msgSend_setAdditionalSelfInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAdditionalSelfInfo:");
}

id objc_msgSend_setAns2Data_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAns2Data:");
}

id objc_msgSend_setAsFirstGeneration(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAsFirstGeneration");
}

id objc_msgSend_setAssetID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setAssetID:");
}

id objc_msgSend_setBoardID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setBoardID:");
}

id objc_msgSend_setBoolValue_forSetting_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setBoolValue:forSetting:");
}

id objc_msgSend_setBootBlockImages_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setBootBlockImages:");
}

id objc_msgSend_setCheckpoint_closure_context_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCheckpoint_closure_context:");
}

id objc_msgSend_setChipEpoch_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setChipEpoch:");
}

id objc_msgSend_setChipID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setChipID:");
}

id objc_msgSend_setChipRevision_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setChipRevision:");
}

id objc_msgSend_setCompletionHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setCompletionHandler:");
}

id objc_msgSend_setContextUUID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setContextUUID:");
}

id objc_msgSend_setDaliData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDaliData:");
}

id objc_msgSend_setDemote_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDemote:");
}

id objc_msgSend_setDigest_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDigest:");
}

id objc_msgSend_setDispatchQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setDispatchQueue:");
}

id objc_msgSend_setEcID_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEcID:");
}

id objc_msgSend_setEnableMixMatch_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEnableMixMatch:");
}

id objc_msgSend_setEpro_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEpro:");
}

id objc_msgSend_setError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setError:");
}

id objc_msgSend_setEsec_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setEsec:");
}

id objc_msgSend_setFilename_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setFilename:");
}

id objc_msgSend_setFirmwareImages_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setFirmwareImages:");
}

id objc_msgSend_setFlags_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setFlags:");
}

id objc_msgSend_setHashAlgorithm_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHashAlgorithm:");
}

id objc_msgSend_setHeaderGeneration_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHeaderGeneration:");
}

id objc_msgSend_setHeaderHash_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHeaderHash:");
}

id objc_msgSend_setHeaderReserved_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHeaderReserved:");
}

id objc_msgSend_setHeaderSignature_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHeaderSignature:");
}

id objc_msgSend_setHeaderVersion_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setHeaderVersion:");
}

id objc_msgSend_setIbootData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIbootData:");
}

id objc_msgSend_setImageAddress_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setImageAddress:");
}

id objc_msgSend_setInfo_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setInfo:");
}

id objc_msgSend_setIsErase_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIsErase:");
}

id objc_msgSend_setIsRequired_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setIsRequired:");
}

id objc_msgSend_setLength_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLength:");
}

id objc_msgSend_setLife_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLife:");
}

id objc_msgSend_setLiveNonce_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLiveNonce:");
}

id objc_msgSend_setLlbData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLlbData:");
}

id objc_msgSend_setLockdownToken::(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLockdownToken::");
}

id objc_msgSend_setLogicalUnitNumber_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLogicalUnitNumber:");
}

id objc_msgSend_setLogoData_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLogoData:");
}

id objc_msgSend_setLongname_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setLongname:");
}

id objc_msgSend_setManifest_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setManifest:");
}

id objc_msgSend_setManifestEpoch_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setManifestEpoch:");
}

id objc_msgSend_setManifestSuffix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setManifestSuffix:");
}

id objc_msgSend_setNonce_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setNonce:");
}

id objc_msgSend_setNonceHash_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setNonceHash:");
}

id objc_msgSend_setObject_forKey_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setObject:forKey:");
}

id objc_msgSend_setObject_forKeyedSubscript_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setObject:forKeyedSubscript:");
}

id objc_msgSend_setPairingSession_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPairingSession:");
}

id objc_msgSend_setPairingSessionStarted_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPairingSessionStarted:");
}

id objc_msgSend_setPayloadIndex_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPayloadIndex:");
}

id objc_msgSend_setPrefixNeedsLogicalUnitNumber_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPrefixNeedsLogicalUnitNumber:");
}

id objc_msgSend_setProductionMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setProductionMode:");
}

id objc_msgSend_setPromptForPINHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setPromptForPINHandler:");
}

id objc_msgSend_setProvisioning_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setProvisioning:");
}

id objc_msgSend_setRemoteObjectInterface_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRemoteObjectInterface:");
}

id objc_msgSend_setResult_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setResult:");
}

id objc_msgSend_setRetval_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setRetval:");
}

id objc_msgSend_setSecondaryPayloadOffset_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSecondaryPayloadOffset:");
}

id objc_msgSend_setSecurityDomain_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSecurityDomain:");
}

id objc_msgSend_setSecurityMode_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSecurityMode:");
}

id objc_msgSend_setSendDataHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSendDataHandler:");
}

id objc_msgSend_setSessionType_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSessionType:");
}

id objc_msgSend_setShouldCommit_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setShouldCommit:");
}

id objc_msgSend_setStartLocation_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setStartLocation:");
}

id objc_msgSend_setSuffixNeedsLogicalUnitNumber_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setSuffixNeedsLogicalUnitNumber:");
}

id objc_msgSend_setTLVs_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTLVs:");
}

id objc_msgSend_setTag_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTag:");
}

id objc_msgSend_setTicketNeedsLogicalUnitNumber_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTicketNeedsLogicalUnitNumber:");
}

id objc_msgSend_setTicketPrefix_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTicketPrefix:");
}

id objc_msgSend_setTrusted_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTrusted:");
}

id objc_msgSend_setTrustedOverride_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTrustedOverride:");
}

id objc_msgSend_setTssOption_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setTssOption:");
}

id objc_msgSend_setValid_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setValid:");
}

id objc_msgSend_setWorkBlock_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWorkBlock:");
}

id objc_msgSend_setWorkQueue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "setWorkQueue:");
}

id objc_msgSend_sharedConnection(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sharedConnection");
}

id objc_msgSend_sharedInstance(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sharedInstance");
}

id objc_msgSend_sharedManager(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sharedManager");
}

id objc_msgSend_shouldCommit(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "shouldCommit");
}

id objc_msgSend_sinkWithCompletion_shouldContinue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "sinkWithCompletion:shouldContinue:");
}

id objc_msgSend_slotID(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "slotID");
}

id objc_msgSend_spiDriverConnect(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "spiDriverConnect");
}

id objc_msgSend_srpResponse(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "srpResponse");
}

id objc_msgSend_startLocation(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "startLocation");
}

id objc_msgSend_starting(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "starting");
}

id objc_msgSend_staticUsage(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "staticUsage");
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "string");
}

id objc_msgSend_stringByAppendingString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringByAppendingString:");
}

id objc_msgSend_stringByExpandingTildeInPath(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringByExpandingTildeInPath");
}

id objc_msgSend_stringWithCString_encoding_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithCString:encoding:");
}

id objc_msgSend_stringWithCapacity_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithCapacity:");
}

id objc_msgSend_stringWithFormat_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithFormat:");
}

id objc_msgSend_stringWithString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithString:");
}

id objc_msgSend_stringWithUTF8String_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithUTF8String:");
}

id objc_msgSend_stringWithValidatedFormat_validFormatSpecifiers_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "stringWithValidatedFormat:validFormatSpecifiers:error:");
}

id objc_msgSend_subdataWithRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "subdataWithRange:");
}

id objc_msgSend_subfileWithTag_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "subfileWithTag:");
}

id objc_msgSend_subfiles(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "subfiles");
}

id objc_msgSend_subscriptions(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "subscriptions");
}

id objc_msgSend_substringWithRange_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "substringWithRange:");
}

id objc_msgSend_suffixNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "suffixNeedsLogicalUnitNumber");
}

id objc_msgSend_superbinary_logString_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "superbinary:logString:");
}

id objc_msgSend_supportsAFUH(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "supportsAFUH");
}

id objc_msgSend_supportsDualiBoot(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "supportsDualiBoot");
}

id objc_msgSend_supportsPCIeNANDBoot(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "supportsPCIeNANDBoot");
}

id objc_msgSend_supportsSlotIDs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "supportsSlotIDs");
}

id objc_msgSend_synchronousRemoteObjectProxyWithErrorHandler_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "synchronousRemoteObjectProxyWithErrorHandler:");
}

id objc_msgSend_systemLanguages(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "systemLanguages");
}

id objc_msgSend_systemUptime(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "systemUptime");
}

id objc_msgSend_tag(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tag");
}

id objc_msgSend_tatsuMeasurements_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tatsuMeasurements:");
}

id objc_msgSend_ticketName(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ticketName");
}

id objc_msgSend_ticketNeedsLogicalUnitNumber(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ticketNeedsLogicalUnitNumber");
}

id objc_msgSend_ticketPrefix(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "ticketPrefix");
}

id objc_msgSend_timeIntervalSinceNow(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timeIntervalSinceNow");
}

id objc_msgSend_timestamp(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "timestamp");
}

id objc_msgSend_tlvFromPropertyListValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvFromPropertyListValue:");
}

id objc_msgSend_tlvFromType_length_value_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvFromType:length:value:");
}

id objc_msgSend_tlvType(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvType");
}

id objc_msgSend_tlvTypeName_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvTypeName:");
}

id objc_msgSend_tlvValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvValue");
}

id objc_msgSend_tlvValue_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvValue:");
}

id objc_msgSend_tlvWithLength_value_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvWithLength:value:");
}

id objc_msgSend_tlvs(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tlvs");
}

id objc_msgSend_trusted(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "trusted");
}

id objc_msgSend_tssKeyName_unitNumber_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tssKeyName:unitNumber:");
}

id objc_msgSend_tssOption(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tssOption");
}

id objc_msgSend_tssRequest(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "tssRequest");
}

id objc_msgSend_uarpWriteData_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "uarpWriteData:error:");
}

id objc_msgSend_unsignedCharValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedCharValue");
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedIntValue");
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedIntegerValue");
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedLongLongValue");
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedLongValue");
}

id objc_msgSend_unsignedShortValue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "unsignedShortValue");
}

id objc_msgSend_updater(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "updater");
}

id objc_msgSend_updaterWithIOService_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "updaterWithIOService:");
}

id objc_msgSend_url(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "url");
}

id objc_msgSend_userInfo(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "userInfo");
}

id objc_msgSend_usesAFUH(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "usesAFUH");
}

id objc_msgSend_valid(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "valid");
}

id objc_msgSend_validHash(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "validHash");
}

id objc_msgSend_validHeaderSignature(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "validHeaderSignature");
}

id objc_msgSend_valueForKeyPath_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "valueForKeyPath:");
}

id objc_msgSend_verboseLog_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "verboseLog:");
}

id objc_msgSend_version(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "version");
}

id objc_msgSend_workBlock(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workBlock");
}

id objc_msgSend_workQueue(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "workQueue");
}

id objc_msgSend_writeBytes_length_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeBytes:length:");
}

id objc_msgSend_writeBytes_ofLength_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeBytes:ofLength:withError:");
}

id objc_msgSend_writeData_withError_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeData:withError:");
}

id objc_msgSend_writeFirmware_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeFirmware:error:");
}

id objc_msgSend_writeToData(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToData");
}

id objc_msgSend_writeToDestination(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToDestination");
}

id objc_msgSend_writeToFile_atomically_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToFile:atomically:");
}

id objc_msgSend_writeToURL_atomically_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToURL:atomically:");
}

id objc_msgSend_writeToURL_error_(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writeToURL:error:");
}

id objc_msgSend_writer(void *a1, const char *a2, ...)
{
  return objc_msgSend(a1, "writer");
}

