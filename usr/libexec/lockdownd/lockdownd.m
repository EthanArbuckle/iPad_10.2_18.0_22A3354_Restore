void sub_1000041C0(const __CFData *a1, const __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a2)
  {
    if (sub_100004808((uint64_t)a1) <= 1)
      sub_10000422C(a2);
    if (sub_100004C98(a1, a2, v11, v12, v13, v14, v15, v16))
      sub_100004790((unint64_t)a1);
    CFRelease(a2);
  }
  else
  {
    sub_10001A7E4(0, "send_response", CFSTR("No response to send"), a4, a5, a6, a7, a8, a9);
  }
}

void sub_10000422C(const __CFDictionary *a1)
{
  const void *Value;
  const void *v3;
  const void *v4;
  CFTypeRef *v5;
  __CFString ***v6;
  CFTypeRef *v7;
  int v8;
  __CFString **v9;

  if (sub_100010B40(a1))
  {
    Value = CFDictionaryGetValue(a1, CFSTR("Error"));
    v3 = sub_100010BA8(Value);
    if (v3)
    {
      v4 = v3;
      v5 = (CFTypeRef *)off_1001A6AE0[0];
      if (!off_1001A6AE0[0])
        goto LABEL_9;
      v6 = off_1001A6AE8;
      while (!CFEqual(v4, *v5))
      {
        v7 = (CFTypeRef *)*v6++;
        v5 = v7;
        if (!v7)
          goto LABEL_9;
      }
      if (!*(v6 - 1))
      {
LABEL_9:
        v8 = CFEqual(v4, CFSTR("ServiceProhibited"));
        v9 = off_10017B868;
        if (v8)
          v9 = off_10017B910;
        if (*v9)
          CFDictionarySetValue(a1, CFSTR("Error"), *v9);
      }
    }
  }
}

__CFDictionary *sub_1000042FC(const void *a1)
{
  __CFDictionary *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *v8;
  char v10;

  v2 = sub_100025A4C();
  v8 = v2;
  if (v2)
    CFDictionarySetValue(v2, CFSTR("Request"), a1);
  else
    sub_10001A7E4(0, "create_response", CFSTR("Could not create response dict"), v3, v4, v5, v6, v7, v10);
  return v8;
}

void sub_100004354(int a1, uint64_t a2, CFMutableDictionaryRef theDict, void *value)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (a1)
  {
    if (a2)
      LOBYTE(v6) = a2;
    else
      v6 = " ";
    sub_100010BA8(value);
    sub_10001A7E4(0, "set_response_error", CFSTR("%s %@"), v7, v8, v9, v10, v11, (char)v6);
  }
  CFDictionarySetValue(theDict, CFSTR("Error"), value);
}

CFTypeRef sub_1000043DC(const void *a1)
{
  __CFWriteStream *v2;
  __CFWriteStream *v3;
  CFTypeRef v4;

  v2 = CFWriteStreamCreateWithAllocatedBuffers(kCFAllocatorDefault, kCFAllocatorDefault);
  if (!v2)
    return 0;
  v3 = v2;
  if (CFWriteStreamOpen(v2))
  {
    if (CFPropertyListWrite(a1, v3, kCFPropertyListBinaryFormat_v1_0, 0, 0) < 1)
      v4 = 0;
    else
      v4 = CFWriteStreamCopyProperty(v3, kCFStreamPropertyDataWritten);
    CFWriteStreamClose(v3);
  }
  else
  {
    v4 = 0;
  }
  CFRelease(v3);
  return v4;
}

BOOL sub_100004480()
{
  stat v1;

  memset(&v1, 0, sizeof(v1));
  return !stat("/System/Library/CoreServices/Carousel.app", &v1) || *__error() != 2;
}

BOOL sub_1000044E0()
{
  stat v1;

  memset(&v1, 0, sizeof(v1));
  return !stat("/System/Library/CoreServices/SurfBoard.app", &v1) || *__error() != 2;
}

id sub_100004540()
{
  void *v0;
  id v1;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[UMUserManager sharedManager](UMUserManager, "sharedManager"));
  v1 = objc_msgSend(v0, "isMultiUser");

  return v1;
}

id sub_10000457C()
{
  id result;
  void *v1;
  id v2;

  result = sub_100004540();
  if ((_DWORD)result)
  {
    v1 = (void *)objc_claimAutoreleasedReturnValue(+[UMUserManager sharedManager](UMUserManager, "sharedManager"));
    v2 = objc_msgSend(v1, "isLoginSession");

    return v2;
  }
  return result;
}

CFBooleanRef sub_1000045C0(const __CFString *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  const CFBooleanRef *v14;

  if (sub_100010BA8(a1))
  {
    if (CFEqual(CFSTR("ShouldSubmit"), a1))
    {
      v13 = DiagnosticLogSubmissionEnabled();
      v14 = &kCFBooleanTrue;
      if (!v13)
        v14 = &kCFBooleanFalse;
      return *v14;
    }
    else
    {
      return (CFBooleanRef)sub_10001AE30(a1, CFSTR("com.apple.MobileDeviceCrashCopy"), v7, v8, v9, v10, v11, v12);
    }
  }
  else
  {
    sub_10001A7E4(0, "copy_crashcopier_value", CFSTR("Invalid key for domain %@."), v2, v3, v4, v5, v6, (char)CFSTR("com.apple.MobileDeviceCrashCopy"));
    return 0;
  }
}

BOOL sub_100004670(const __CFString *a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  id v15;

  if (!sub_100010BA8(a1) || !sub_100010C10(a2))
  {
    sub_10001A7E4(0, "set_crashcopier_value", CFSTR("Invalid key '%@' or value '%@'."), v4, v5, v6, v7, v8, (char)a1);
    return 0;
  }
  if (!CFEqual(a1, CFSTR("ShouldSubmit")))
    return !sub_10001AD28(a1, a2, CFSTR("com.apple.MobileDeviceCrashCopy"), v9, v10, v11, v12, v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"));
  v15 = objc_msgSend(a2, "BOOLValue");
  objc_msgSend(v14, "setBoolValue:forSetting:", v15, MCFeatureDiagnosticsSubmissionAllowed);

  return 1;
}

void *sub_100004744()
{
  return malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040BB563593uLL);
}

void sub_100004760(void *a1)
{
  if (a1)
    free(a1);
}

double sub_10000476C(uint64_t a1, int a2, int a3)
{
  double result;

  if (a1)
  {
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_DWORD *)a1 = a2;
    *(_QWORD *)(a1 + 8) = 0;
    *(_DWORD *)(a1 + 16) = a3;
    *(_DWORD *)(a1 + 32) = 0;
  }
  return result;
}

unint64_t sub_100004790(unint64_t result)
{
  unsigned int *v1;
  NSObject *v2;

  if (result)
  {
    v1 = (unsigned int *)result;
    v2 = *(NSObject **)(result + 40);
    if (v2)
    {
      dispatch_source_cancel(v2);
      dispatch_release(*((dispatch_object_t *)v1 + 5));
      *((_QWORD *)v1 + 5) = 0;
    }
    result = *v1;
    if ((_DWORD)result != -1)
      result = close(result);
    *v1 = -1;
  }
  return result;
}

uint64_t sub_1000047E0(unsigned int *a1)
{
  if (a1)
    return *a1;
  else
    return 0xFFFFFFFFLL;
}

uint64_t sub_1000047F4(uint64_t a1)
{
  if (a1)
    return *(unsigned int *)(a1 + 16);
  else
    return 4;
}

uint64_t sub_100004808(uint64_t a1)
{
  unsigned int v1;

  if (!a1)
    return 1;
  v1 = *(_DWORD *)(a1 + 32);
  if (v1 <= 1)
    return 1;
  else
    return v1;
}

uint64_t sub_100004824(uint64_t a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, int a5)
{
  SSLContext *v6;
  uint64_t result;

  v6 = sub_10002822C(*(_DWORD *)a1, a2, a3, a4, a5);
  *(_QWORD *)(a1 + 24) = v6;
  if (!v6)
    return 0xFFFFFFFFLL;
  result = 0;
  *(_BYTE *)(a1 + 20) = 1;
  return result;
}

uint64_t sub_100004864(uint64_t a1)
{
  OSStatus v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  SSLContext *v8;

  if (*(_BYTE *)(a1 + 20))
  {
    v2 = SSLClose(*(SSLContextRef *)(a1 + 24));
    if (v2)
      sub_10001A7E4(0, "lockconn_disable_ssl", CFSTR("Could not shutdown SSL connection: %d\n"), v3, v4, v5, v6, v7, v2);
    *(_BYTE *)(a1 + 20) = 0;
  }
  v8 = *(SSLContext **)(a1 + 24);
  if (v8)
  {
    _SSLDisposeContext(v8);
    *(_QWORD *)(a1 + 24) = 0;
  }
  return 0;
}

uint64_t sub_1000048D0(uint64_t result)
{
  if (result)
    return *(unsigned __int8 *)(result + 20);
  return result;
}

ssize_t sub_1000048DC(uint64_t a1, const void *a2, size_t a3)
{
  OSStatus v3;
  OSStatus v4;
  int *v5;
  int v6;
  size_t processed;

  processed = -1;
  if (!*(_BYTE *)(a1 + 20))
    return send(*(_DWORD *)a1, a2, a3, 0);
  v3 = SSLWrite(*(SSLContextRef *)(a1 + 24), a2, a3, &processed);
  if (v3)
  {
    v4 = v3;
    *__error() = 5;
    if (!processed)
      processed = -1;
    if (v4 == -9806)
    {
      v5 = __error();
      v6 = 32;
      goto LABEL_10;
    }
    if (v4 == -9803)
    {
      v5 = __error();
      v6 = 35;
LABEL_10:
      *v5 = v6;
    }
  }
  return processed;
}

ssize_t sub_100004984(uint64_t a1, void *data, size_t dataLength, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  OSStatus v11;
  OSStatus v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int *v18;
  int v19;
  char v21;
  size_t processed;

  processed = -1;
  if (!*(_BYTE *)(a1 + 20))
  {
    if (!sub_100004A98(*(_DWORD *)a1, (uint64_t)data, dataLength, a4, a5, a6, a7, a8))
      return recv(*(_DWORD *)a1, data, dataLength, 0);
    *__error() = 54;
    sub_10001A7E4(0, "lockconn_recv", CFSTR("walk away"), v13, v14, v15, v16, v17, v21);
    return processed;
  }
  v11 = SSLRead(*(SSLContextRef *)(a1 + 24), data, dataLength, &processed);
  if (!v11)
    return processed;
  v12 = v11;
  *__error() = 5;
  if (!processed)
    processed = -1;
  switch(v12)
  {
    case -9806:
      v18 = __error();
      v19 = 54;
LABEL_14:
      *v18 = v19;
      return processed;
    case -9803:
      v18 = __error();
      v19 = 2;
      goto LABEL_14;
    case -9805:
      return 0;
  }
  return processed;
}

uint64_t sub_100004A98(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  uint64_t result;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFString *v18;
  const __CFString *v19;
  int *v20;
  char v21;
  char v22;
  timeval v23;
  fd_set v24;

  *(_QWORD *)&v23.tv_usec = 0;
  memset(&v24, 0, sizeof(v24));
  if (a1 >= 1024)
  {
    sub_10001A7E4(0, "_select_socket", CFSTR("Invalid socket (received %d, max is %d)."), a4, a5, a6, a7, a8, a1);
    return 0xFFFFFFFFLL;
  }
  if (a1 == -1)
  {
    v18 = CFSTR("Invalid socket");
LABEL_20:
    sub_10001A7E4(0, "_select_socket", v18, a4, a5, a6, a7, a8, v21);
    return 0xFFFFFFFFLL;
  }
  if (__darwin_check_fd_set_overflow(a1, &v24, 0))
    *(__int32_t *)((char *)v24.fds_bits + (((unint64_t)a1 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << a1;
  v23.tv_usec = 0;
  v23.tv_sec = 60;
  v9 = fcntl(a1, 3, 4);
  result = 0;
  if ((v9 & 4) == 0)
  {
    v11 = 0;
    while (1)
    {
      v12 = select(a1 + 1, &v24, 0, 0, &v23);
      memset(&v24, 0, sizeof(v24));
      if (__darwin_check_fd_set_overflow(a1, &v24, 0))
        v24.fds_bits[(unint64_t)a1 >> 5] |= 1 << a1;
      if (v12 != -1)
        break;
      if (*__error() != 4)
      {
        v20 = __error();
        v22 = strerror(*v20);
        v19 = CFSTR("select error receiving message: %s");
        goto LABEL_18;
      }
      if (++v11 == 20)
      {
        LOBYTE(v11) = 20;
LABEL_19:
        v21 = v11;
        v18 = CFSTR("Failed to select socket after %d attempts.");
        goto LABEL_20;
      }
    }
    if (!v12)
    {
      v19 = CFSTR("receive secure message timeout!");
LABEL_18:
      sub_10001A7E4(0, "_select_socket", v19, v13, v14, v15, v16, v17, v22);
      goto LABEL_19;
    }
    return 0;
  }
  return result;
}

uint64_t sub_100004C98(const __CFData *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_100004CA0(a1, a2, kCFPropertyListXMLFormat_v1_0, a4, a5, a6, a7, a8);
}

uint64_t sub_100004CA0(CFDataRef Data, const void *a2, CFPropertyListFormat a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t result;
  const __CFString *v10;
  CFDataRef v11;
  CFIndex Length;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  const UInt8 *BytePtr;
  uint64_t v20;
  ssize_t v21;
  unint64_t v22;
  ssize_t v23;
  int *v24;
  char v25;
  unsigned int v26;

  if (!Data)
  {
    v10 = CFSTR("no connection");
LABEL_22:
    sub_10001A7E4((int)Data, "_send_message", v10, a4, a5, a6, a7, a8, v25);
    return 0xFFFFFFFFLL;
  }
  v8 = (uint64_t)Data;
  if (*(_DWORD *)Data == -1)
  {
    v10 = CFSTR("no socket");
LABEL_9:
    LODWORD(Data) = 0;
    goto LABEL_22;
  }
  if (!*((_BYTE *)Data + 20))
  {
    if (!a2)
      return 0xFFFFFFFFLL;
    goto LABEL_11;
  }
  result = 0xFFFFFFFFLL;
  if (a2 && *(_QWORD *)(v8 + 24))
  {
LABEL_11:
    Data = CFPropertyListCreateData(kCFAllocatorDefault, a2, a3, 0, 0);
    if (!Data)
    {
      v10 = CFSTR("Could not encode message as XML");
      goto LABEL_22;
    }
    v11 = Data;
    Length = CFDataGetLength(Data);
    if (Length < 0)
    {
      sub_10001A7E4(0, "_send_message", CFSTR("message length too small"), v13, v14, v15, v16, v17, v25);
      CFRelease(v11);
      return 0xFFFFFFFFLL;
    }
    v18 = Length;
    BytePtr = CFDataGetBytePtr(v11);
    v20 = 0;
    v26 = bswap32(v18);
    do
    {
      v21 = sub_1000048DC(v8, (char *)&v26 + v20, 4 - v20);
      if (v21 == -1)
      {
        CFRelease(v11);
        v24 = __error();
        strerror(*v24);
        v25 = v18;
        v10 = CFSTR("Could not send message size %ld: %s\n");
        goto LABEL_9;
      }
      v20 += v21;
    }
    while (v20 != 4);
    if (!v18)
    {
LABEL_20:
      CFRelease(v11);
      return 0;
    }
    v22 = 0;
    while (1)
    {
      v23 = sub_1000048DC(v8, BytePtr, v18 - v22);
      if (v23 == -1)
        break;
      v22 += v23;
      BytePtr += v23;
      if (v22 >= v18)
        goto LABEL_20;
    }
    CFRelease(v11);
    v10 = CFSTR("Could not send secure message.\n");
    goto LABEL_9;
  }
  return result;
}

const __CFDictionary *sub_100004E6C(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFDictionary *v16;
  const __CFDictionary *v18;
  CFTypeID v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *Value;
  const __CFString *v26;
  CFTypeID v27;
  SInt32 IntValue;
  char v29;

  if (!a1 || sub_100004A98(*a1, a2, a3, a4, a5, a6, a7, a8))
    return 0;
  v18 = (const __CFDictionary *)sub_100004F50((uint64_t)a1, v9, v10, v11, v12, v13, v14, v15);
  v16 = v18;
  if (!v18)
  {
LABEL_8:
    sub_1000051EC(v16);
    return v16;
  }
  v19 = CFGetTypeID(v18);
  if (v19 == CFDictionaryGetTypeID())
  {
    if (!a1[8])
    {
      Value = (const __CFString *)CFDictionaryGetValue(v16, CFSTR("ProtocolVersion"));
      if (Value)
      {
        v26 = Value;
        v27 = CFGetTypeID(Value);
        if (v27 == CFStringGetTypeID())
        {
          IntValue = CFStringGetIntValue(v26);
          if (IntValue >= 1)
            a1[8] = IntValue;
        }
      }
    }
    goto LABEL_8;
  }
  sub_10001A7E4(0, "lockconn_receive_message", CFSTR("Ignoring message that is not the right type.\n"), v20, v21, v22, v23, v24, v29);
  CFRelease(v16);
  return 0;
}

CFPropertyListRef sub_100004F50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  SSLContext *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  size_t v24;
  size_t v25;
  int *v26;
  CFPropertyListRef v27;
  char *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  size_t v36;
  char *v37;
  ssize_t v38;
  const __CFData *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const __CFData *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  char v52;
  size_t processed;
  CFErrorRef error;
  unsigned int data;

  data = 0;
  error = 0;
  v9 = *(_DWORD *)a1;
  if (v9 == -1)
    return 0;
  processed = 0;
  if (!*(_BYTE *)(a1 + 20))
  {
    if (sub_100004A98(v9, a2, a3, a4, a5, a6, a7, a8))
    {
      v23 = CFSTR("walk away - non-SSL 2");
      goto LABEL_16;
    }
    goto LABEL_9;
  }
  v10 = *(SSLContext **)(a1 + 24);
  if (!v10)
    return 0;
  if (SSLRead(v10, &data, 4uLL, &processed) == -9805)
  {
    *(_BYTE *)(a1 + 20) = 0;
    sub_100004864(a1);
    if (sub_100004A98(*(_DWORD *)a1, v16, v17, v18, v19, v20, v21, v22))
    {
      v23 = CFSTR("walk away - non-SSL 1");
LABEL_16:
      sub_10001A7E4(0, "_receive_message", v23, v11, v12, v13, v14, v15, v52);
      return 0;
    }
LABEL_9:
    v24 = recv(*(_DWORD *)a1, &data, 4uLL, 0);
    processed = v24;
    if (!v24)
      return 0;
    goto LABEL_12;
  }
  v24 = processed;
  if (!processed)
    return 0;
LABEL_12:
  if (v24 != 4)
  {
    __error();
    v26 = __error();
    strerror(*v26);
    v52 = 4;
    v23 = CFSTR("Could not receive size of message, expected %d bytes, got %ld bytes: (%d, %s)");
    goto LABEL_16;
  }
  v25 = bswap32(data);
  if (v25 > 0x300000)
  {
    v52 = data;
    v23 = CFSTR("swapped %d message size %d exceeds %d limit");
    goto LABEL_16;
  }
  if (!data)
  {
    v23 = CFSTR("msize is zero");
    goto LABEL_16;
  }
  v29 = (char *)malloc_type_malloc(v25, 0x3C0CF081uLL);
  if (!v29)
  {
    sub_10001A7E4(0, "_receive_message", CFSTR("can't alloc message size %d"), v30, v31, v32, v33, v34, v25);
    return 0;
  }
  v35 = v29;
  v36 = 0;
  v37 = v29;
  do
  {
    v38 = sub_100004984(a1, v37, v25 - v36, v30, v31, v32, v33, v34);
    processed = v38;
    if (v38 <= 0)
    {
      sub_10001A7E4(0, "_receive_message", CFSTR("Could not receive message: %ld.\n"), v30, v31, v32, v33, v34, v38);
LABEL_36:
      free(v35);
      return 0;
    }
    v36 += v38;
    v37 += v38;
  }
  while (v36 < v25);
  v39 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v35, v25, kCFAllocatorMalloc);
  if (!v39)
  {
    sub_10001A7E4(0, "_receive_message", CFSTR("Could not create CFData for message.\n"), v40, v41, v42, v43, v44, v52);
    goto LABEL_36;
  }
  v45 = v39;
  v27 = CFPropertyListCreateWithData(0, v39, 0, 0, &error);
  if (v27)
    v51 = error == 0;
  else
    v51 = 0;
  if (!v51)
  {
    sub_10001A7E4(0, "_receive_message", CFSTR("there was an err."), v46, v47, v48, v49, v50, v52);
    if (error)
      CFRelease(error);
  }
  CFRelease(v45);
  return v27;
}

void sub_1000051EC(const __CFDictionary *a1)
{
  const __CFString *Value;
  const __CFString *v2;
  _BOOL4 v3;
  const char *v4;
  int v5;
  char *v6;
  char __dst[1024];

  if (a1)
  {
    Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("Warning"));
    if (Value)
    {
      v2 = Value;
      memcpy(__dst, "Error creating CFString", sizeof(__dst));
      LODWORD(v2) = CFStringGetCString(v2, __dst, 1024, 0x8000100u);
      v3 = os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT);
      if (!(_DWORD)v2)
      {
        if (!v3)
          return;
        LOWORD(v5) = 0;
        v4 = "CFStringGetCString failure in lockdown_warning_break";
        goto LABEL_10;
      }
      if (v3)
      {
        v5 = 136315138;
        v6 = __dst;
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s", (uint8_t *)&v5, 0xCu);
      }
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v5) = 0;
        v4 = "*** this is a CLIENT bug, NOT a lockdown bug; set a breakpoint in lockdown_warning_break to debug";
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v5, 2u);
      }
    }
  }
}

void sub_100005338()
{
  const __CFDictionary *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFNumber *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const __CFString *v19;
  uint64_t *v20;
  const void *v21;
  char v22;
  _QWORD v23[6];
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[3];
  char v29;
  uint64_t valuePtr;

  valuePtr = 0;
  v28[0] = 0;
  v28[1] = v28;
  v28[2] = 0x2020000000;
  v29 = 0;
  v24 = 0;
  v25 = &v24;
  v26 = 0x2020000000;
  v27 = 0;
  v0 = sub_1000054B0();
  if (sub_100010B40(v0))
  {
    if (CFDictionaryGetCount(v0))
      goto LABEL_10;
    v6 = sub_10000898C();
    v25[3] = (uint64_t)v6;
    if (v6)
    {
      if (CFNumberGetValue(v6, kCFNumberDoubleType, &valuePtr))
      {
        v23[0] = _NSConcreteStackBlock;
        v23[1] = 3221225472;
        v23[2] = sub_10000553C;
        v23[3] = &unk_100179D28;
        v23[4] = v28;
        v23[5] = &v24;
        sub_100014DC0(v23);
        goto LABEL_10;
      }
      v19 = CFSTR("Failed to query number.");
    }
    else
    {
      v19 = CFSTR("Failed to query time.");
    }
    sub_10001A7E4(0, "initialize_pairing_expirations", v19, v7, v8, v9, v10, v11, v22);
  }
  else
  {
    sub_10001A7E4(0, "initialize_pairing_expirations", CFSTR("hinky input from the dictionary"), v1, v2, v3, v4, v5, v22);
    sub_10001AF84(CFSTR("com.apple.mobile.ldpair"), v12, v13, v14, v15, v16, v17, v18);
  }
LABEL_10:
  v20 = v25;
  v21 = (const void *)v25[3];
  if (v21)
  {
    CFRelease(v21);
    v20 = v25;
  }
  v20[3] = 0;
  if (v0)
    CFRelease(v0);
  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(v28, 8);
}

void sub_10000548C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  uint64_t v8;
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v8 - 56), 8);
  _Unwind_Resume(a1);
}

CFDictionaryRef sub_1000054B0()
{
  const __CFDictionary *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v7;

  v0 = sub_10001B0C4(CFSTR("com.apple.mobile.ldpair"));
  if (sub_100010B40(v0))
  {
    CFDictionaryApplyFunction(v0, (CFDictionaryApplierFunction)sub_100005AE0, 0);
    if (v0)
      CFRelease(v0);
    return sub_10001B0C4(CFSTR("com.apple.mobile.ldpair"));
  }
  else
  {
    sub_10001A7E4(0, "copy_paired_hosts_and_dates", CFSTR("Invalid paired hosts records."), v1, v2, v3, v4, v5, v7);
    if (v0)
      CFRelease(v0);
    return 0;
  }
}

uint64_t sub_10000553C(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v25;

  v3 = a2;
  v9 = v3;
  if (v3)
  {
    v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKey:", CFSTR("HostID")));
    v11 = sub_10001B244(v10);
    v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

    if (v12)
    {
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_100005628(v10, *(const void **)(*(_QWORD *)(*(_QWORD *)(a1 + 40)+ 8)+ 24), v13, v14, v15, v16, v17, v18);
      if (!*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
        sub_10001A7E4(0, "initialize_pairing_expirations_block_invoke", CFSTR("Failed to set last paired date for %@."), v19, v20, v21, v22, v23, (char)v10);
    }
    else
    {
      sub_10001A7E4(0, "initialize_pairing_expirations_block_invoke", CFSTR("Pair record doesn't contain host id."), v14, v15, v16, v17, v18, v25);
    }
  }
  else
  {
    sub_10001A7E4(0, "initialize_pairing_expirations_block_invoke", CFSTR("Invalid pair record."), v4, v5, v6, v7, v8, v25);
    v10 = 0;
  }

  return 1;
}

uint64_t sub_100005628(const void *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFDictionaryRef v10;
  const __CFDictionary *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  char *v18;
  char *v19;
  char *i;
  void *v21;
  id v22;
  void *v23;
  __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __CFString *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  void *v46;
  id v47;
  uint64_t v48;
  const __CFString *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v61;
  uint8_t buf[4];
  const __CFString *v63;
  __int16 v64;
  void *v65;

  if (a1)
  {
    v10 = sub_10001B0C4(CFSTR("com.apple.mobile.ldpair"));
    if (sub_100010B40(v10))
    {
      v11 = v10;
      if ((unint64_t)-[__CFDictionary count](v11, "count") < 0x201)
      {
        v17 = 0;
      }
      else
      {
        sub_10001A7E4(0, "set_last_paired_date", CFSTR("Detected greater than %d hosts in domain '%@', trimming list."), v12, v13, v14, v15, v16, 0);
        v17 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary keysSortedByValueUsingComparator:](v11, "keysSortedByValueUsingComparator:", &stru_100179D68));
        v18 = (char *)objc_msgSend(v17, "count");
        v19 = v18 - 256;
        if (v18 != (char *)256)
        {
          for (i = 0; v19 != i; ++i)
          {
            v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectAtIndexedSubscript:", i));
            v22 = sub_10001B244(v21);
            v23 = (void *)objc_claimAutoreleasedReturnValue(v22);

            if (v23)
            {
              v24 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectAtIndexedSubscript:", i));
              sub_100005A48(v24, v25, v26, v27, v28, v29, v30, v31, v61);
            }
            else
            {
              if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
              {
                v45 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectAtIndexedSubscript:", i));
                v46 = (void *)objc_opt_class(v45);
                *(_DWORD *)buf = 138412546;
                v63 = CFSTR("com.apple.mobile.ldpair");
                v64 = 2112;
                v65 = v46;
                v47 = v46;
                _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Unexpected format in preferences for domain %@: %@", buf, 0x16u);

              }
              v32 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectAtIndexedSubscript:", i));
              v39 = sub_10001AEC8(v32, CFSTR("com.apple.mobile.ldpair"), v33, v34, v35, v36, v37, v38);

              if (!v39)
                continue;
              v24 = (__CFString *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectAtIndexedSubscript:", i));
              sub_10001A7E4(0, "set_last_paired_date", CFSTR("Failed to remove pairing pairing info for %@."), v40, v41, v42, v43, v44, (char)v24);
            }

          }
        }
      }
      v49 = (const __CFString *)sub_100010BA8(a1);
      if (!sub_10001AD28(v49, a2, CFSTR("com.apple.mobile.ldpair"), v50, v51, v52, v53, v54))
      {
        v48 = 1;
        if (!v10)
          goto LABEL_24;
        goto LABEL_23;
      }
      sub_10001A7E4(0, "set_last_paired_date", CFSTR("Failed to set pairing date."), v55, v56, v57, v58, v59, v61);
    }
    else
    {
      if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
        sub_1000F96A8((uint64_t)CFSTR("com.apple.mobile.ldpair"));
      v17 = 0;
      v11 = 0;
    }
    v48 = 0;
    if (v10)
LABEL_23:
      CFRelease(v10);
  }
  else
  {
    sub_10001A7E4(0, "set_last_paired_date", CFSTR("Invalid input"), a4, a5, a6, a7, a8, v61);
    v48 = 0;
    v11 = 0;
    v17 = 0;
  }
LABEL_24:

  return v48;
}

uint64_t sub_100005908(const __CFString *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFNumber *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  char v18;

  if (a1 && a2)
  {
    v9 = (const __CFNumber *)sub_10001AE30(a1, CFSTR("com.apple.mobile.ldpair"), a3, a4, a5, a6, a7, a8);
    if (sub_100010B0C(v9))
    {
      if (CFNumberGetValue(v9, kCFNumberDoubleType, a2))
      {
        v15 = 1;
        if (!v9)
          return v15;
        goto LABEL_11;
      }
      v16 = CFSTR("Failed to retrieve number.");
    }
    else
    {
      v16 = CFSTR("No last paired date for this host.");
    }
    sub_10001A7E4(0, "get_last_paired_date", v16, v10, v11, v12, v13, v14, v18);
    v15 = 0;
    if (v9)
LABEL_11:
      CFRelease(v9);
  }
  else
  {
    sub_10001A7E4(0, "get_last_paired_date", CFSTR("Invalid input"), a4, a5, a6, a7, a8, v18);
    return 0;
  }
  return v15;
}

int64_t sub_1000059C0(id a1, id a2, id a3)
{
  id v4;
  id v5;
  double v6;
  double v7;
  double v8;
  int64_t v9;
  double v10;
  double v11;
  double v12;

  v4 = a2;
  v5 = a3;
  objc_msgSend(v4, "doubleValue");
  v7 = v6;
  objc_msgSend(v5, "doubleValue");
  if (v7 <= v8)
  {
    objc_msgSend(v4, "doubleValue");
    v11 = v10;
    objc_msgSend(v5, "doubleValue");
    if (v11 >= v12)
      v9 = 0;
    else
      v9 = -1;
  }
  else
  {
    v9 = 1;
  }

  return v9;
}

void sub_100005A48(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (a1)
  {
    sub_100015CA8((uint64_t)a1, 0);
    sub_100028850(a1);
    sub_100015104((uint64_t)a1, 0, v10, v11, v12, v13, v14, v15);
    if (sub_10001AEC8(a1, CFSTR("com.apple.mobile.ldpair"), v16, v17, v18, v19, v20, v21))
      sub_10001A7E4(0, "remove_pairing_info_for_host", CFSTR("Failed to remove pairing pairing info for %@."), v22, v23, v24, v25, v26, (char)a1);
  }
  else
  {
    sub_10001A7E4(0, "remove_pairing_info_for_host", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100005AE0(const __CFString *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFNumber *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFNumber *v15;
  const __CFString *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double valuePtr;

  v24 = 0.0;
  valuePtr = 0.0;
  if (!sub_100010BA8(a1) || !sub_100010B0C(a2))
  {
    sub_10001A7E4(0, "expire_old_hosts", CFSTR("Invalid input."), v4, v5, v6, v7, v8, SLOBYTE(v24));
    v15 = 0;
    goto LABEL_13;
  }
  v9 = sub_10000898C();
  v15 = v9;
  if (!v9)
  {
    v16 = CFSTR("Failed to query time.");
LABEL_12:
    sub_10001A7E4((int)v9, "expire_old_hosts", v16, v10, v11, v12, v13, v14, SLOBYTE(v24));
    goto LABEL_13;
  }
  LODWORD(v9) = CFNumberGetValue(v9, kCFNumberDoubleType, &v24);
  if (!(_DWORD)v9)
  {
    v16 = CFSTR("Failed to query number.");
    goto LABEL_12;
  }
  LODWORD(v9) = CFNumberGetValue((CFNumberRef)a2, kCFNumberDoubleType, &valuePtr);
  if (!(_DWORD)v9)
  {
    v16 = CFSTR("Failed to get double value.");
    goto LABEL_12;
  }
  if (v24 <= valuePtr + 2592000.0)
  {
    sub_100010BA8(a1);
LABEL_16:
    CFRelease(v15);
    return;
  }
LABEL_13:
  if (sub_100010BA8(a1))
    sub_100005A48(a1, v17, v18, v19, v20, v21, v22, v23, SLOBYTE(v24));
  if (v15)
    goto LABEL_16;
}

uint64_t sub_100005C00()
{
  return 2592000;
}

uint64_t sub_100005C0C(unsigned int *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;
  const __CFString *v13;
  int v14;
  int *v15;
  int v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  socklen_t v24;
  sockaddr *v25;
  char *sa_data;
  char v27;
  int v28;
  socklen_t v29;
  uint64_t v30;
  in6_addr v31;
  int v32;
  int v33;
  sockaddr v34;

  v32 = 0;
  v33 = 1;
  *(_QWORD *)&v34.sa_len = 0;
  *(_QWORD *)&v34.sa_data[6] = 0;
  v30 = 0;
  v31 = (in6_addr)0;
  v29 = 0;
  if (!a1)
  {
    v13 = CFSTR("Invalid input.");
LABEL_7:
    sub_10001A7E4((int)a1, "create_inet_sock", v13, a4, a5, a6, a7, a8, v27);
    return 0xFFFFFFFFLL;
  }
  v9 = a1;
  v10 = socket(a2, 1, 0);
  if ((_DWORD)v10 == -1)
  {
    v14 = *__error();
    v15 = __error();
    strerror(*v15);
    v27 = v14;
    v13 = CFSTR("Failed to create socket: %d (%s)");
    LODWORD(a1) = 0;
    goto LABEL_7;
  }
  v11 = v10;
  if (setsockopt(v10, 0xFFFF, 4354, &v33, 4u))
  {
    v12 = CFSTR("Failed to set socket option (SO_OPPORTUNISTIC): %d (%s)");
LABEL_10:
    v16 = *__error();
    v17 = __error();
    strerror(*v17);
    sub_10001A7E4(0, "create_inet_sock", v12, v18, v19, v20, v21, v22, v16);
    close(v11);
    return 0xFFFFFFFFLL;
  }
  v28 = 4;
  if (setsockopt(v11, 0xFFFF, 4225, &v28, 4u))
  {
    v12 = CFSTR("Failed to set socket option (SO_RESTRICTIONS): %d (%s)");
    goto LABEL_10;
  }
  if (*v9)
  {
    if (setsockopt(v11, 0xFFFF, 4, &v33, 4u))
    {
      v12 = CFSTR("Failed to set socket option (SO_REUSEADDR): %d (%s)");
      goto LABEL_10;
    }
    if (setsockopt(v11, 0xFFFF, 512, &v33, 4u))
    {
      v12 = CFSTR("Failed to set socket option (SO_REUSEPORT): %d (%s)");
      goto LABEL_10;
    }
  }
  if (a2 == 30)
  {
    LOWORD(v30) = 7708;
    v31 = in6addr_any;
    WORD1(v30) = bswap32(*(unsigned __int16 *)v9) >> 16;
    v24 = 28;
    v29 = 28;
    if (setsockopt(v11, 41, 27, &v33, 4u))
    {
      v12 = CFSTR("Failed to set socket option (IPV6_V6ONLY): %d (%s)");
      goto LABEL_10;
    }
    v25 = (sockaddr *)&v30;
  }
  else
  {
    *(_WORD *)&v34.sa_len = 528;
    *(_DWORD *)&v34.sa_data[2] = 0;
    *(_WORD *)v34.sa_data = bswap32(*(unsigned __int16 *)v9) >> 16;
    v24 = 16;
    v29 = 16;
    v25 = &v34;
  }
  if (bind(v11, v25, v24) == -1)
  {
    v12 = CFSTR("Failed to bind socket: %d (%s)");
    goto LABEL_10;
  }
  if (getsockname(v11, v25, &v29) == -1)
  {
    v12 = CFSTR("Failed to get socket name: %d (%s)");
    goto LABEL_10;
  }
  if (listen(v11, 128) == -1)
  {
    v12 = CFSTR("Failed to listen on socket: %d (%s)");
    goto LABEL_10;
  }
  sa_data = v34.sa_data;
  if (a2 == 30)
    sa_data = (char *)&v30 + 2;
  *v9 = bswap32(*(unsigned __int16 *)sa_data) >> 16;
  return v11;
}

BOOL sub_100005EF8(_QWORD *a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  NSObject *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _BOOL8 v17;
  _QWORD v19[7];
  char v20;
  char v21;
  char v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;

  v9 = a4;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2020000000;
  v26 = 0;
  if (a1 && *a1 && (v12 = a1[2]) != 0)
  {
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_100006024;
    v19[3] = &unk_100179D90;
    v20 = a4;
    v21 = a3;
    v19[5] = a1;
    v19[6] = a2;
    v22 = a5;
    v19[4] = &v23;
    dispatch_sync(v12, v19);
  }
  else
  {
    sub_10001A7E4(0, "dns_register", CFSTR("Invalid input."), a4, a5, a6, a7, a8, v19[0]);
  }
  if (*((_BYTE *)v24 + 24))
  {
    v17 = 1;
  }
  else
  {
    sub_100006DB8(a1, a3, v9, a5, v13, v14, v15, v16, v19[0]);
    v17 = *((_BYTE *)v24 + 24) != 0;
  }
  _Block_object_dispose(&v23, 8);
  return v17;
}

void sub_10000600C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100006024(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFString *v33;
  xpc_object_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  CFRunLoopSourceRef RunLoopSource;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __CFRunLoopSource *v48;
  __CFRunLoop *Current;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const __CFString *v55;
  char v56;
  char buffer[16];
  __int128 v58;
  __int128 v59;
  __int128 v60;

  v59 = 0u;
  v60 = 0u;
  *(_OWORD *)buffer = 0u;
  v58 = 0u;
  if (!*(_BYTE *)(a1 + 56) && !*(_BYTE *)(a1 + 57))
  {
    sub_10001A7E4(0, "dns_register_block_invoke", CFSTR("Invalid input. No DNS registration requested."), a4, a5, a6, a7, a8, v56);
    v34 = 0;
    v24 = 0;
    goto LABEL_26;
  }
  v9 = (const __CFString *)sub_10000ED98(**(_QWORD **)(a1 + 40), (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("InstanceName"));
  v10 = sub_100010BA8(v9);
  if (!v10)
  {
    v33 = CFSTR("Invalid wireless instance name.");
LABEL_22:
    sub_10001A7E4((int)v10, "dns_register_block_invoke", v33, v11, v12, v13, v14, v15, v56);
    v24 = 0;
LABEL_23:
    v34 = 0;
    goto LABEL_24;
  }
  LODWORD(v10) = CFStringGetCString(v9, buffer, 64, 0x8000100u);
  if (!(_DWORD)v10)
  {
    v33 = CFSTR("Failed to create string.");
    goto LABEL_22;
  }
  if (!*(_BYTE *)(a1 + 57))
  {
LABEL_16:
    v24 = 0;
    goto LABEL_17;
  }
  v16 = *(const char **)(a1 + 48);
  if (!v16)
  {
    v33 = CFSTR("Invalid service string name.");
    LODWORD(v10) = 0;
    goto LABEL_22;
  }
  v17 = *(_QWORD *)(a1 + 40);
  if (*(_BYTE *)(v17 + 32))
  {
    v18 = *(const char **)(v17 + 24);
    if (!v18 || !strcmp(v18, v16))
      goto LABEL_16;
  }
  xpc_set_event("com.apple.bonjour.registration", "LOCKDOWN.BONJOUR", 0);
  v24 = strdup(*(const char **)(a1 + 48));
  if (!v24)
  {
    sub_10001A7E4(0, "dns_register_block_invoke", CFSTR("Failed to copy service string."), v19, v20, v21, v22, v23, v56);
    goto LABEL_23;
  }
  v25 = *(_QWORD *)(a1 + 40);
  v26 = *(void **)(v25 + 24);
  if (v26)
  {
    free(v26);
    v25 = *(_QWORD *)(a1 + 40);
  }
  *(_QWORD *)(v25 + 24) = 0;
  *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) = v24;
  v24 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_int64(v24, "Flags", 0);
  xpc_dictionary_set_string(v24, "Name", buffer);
  xpc_dictionary_set_string(v24, "RegistrationType", *(const char **)(*(_QWORD *)(a1 + 40) + 24));
  xpc_dictionary_set_int64(v24, "InterfaceIndex", 0);
  xpc_dictionary_set_int64(v24, "Port", 32498);
  xpc_set_event("com.apple.bonjour.registration", "LOCKDOWN.BONJOUR", v24);
  v27 = *(_QWORD *)(a1 + 40);
  *(_BYTE *)(v27 + 32) = 1;
  sub_10001A7E4(0, "dns_register_block_invoke", CFSTR("Registered DNS (syncing): %s"), v28, v29, v30, v31, v32, *(_QWORD *)(v27 + 24));
LABEL_17:
  if (*(_BYTE *)(a1 + 56) && !*(_BYTE *)(*(_QWORD *)(a1 + 40) + 33))
  {
    xpc_set_event("com.apple.bonjour.registration", "LOCKDOWN.PAIRING.BONJOUR", 0);
    v34 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_int64(v34, "Flags", 0);
    xpc_dictionary_set_string(v34, "Name", buffer);
    xpc_dictionary_set_string(v34, "RegistrationType", "_apple-pairable._tcp");
    xpc_dictionary_set_int64(v34, "InterfaceIndex", 0);
    xpc_dictionary_set_int64(v34, "Port", 32498);
    xpc_set_event("com.apple.bonjour.registration", "LOCKDOWN.PAIRING.BONJOUR", v34);
    *(_BYTE *)(*(_QWORD *)(a1 + 40) + 33) = 1;
    sub_10001A7E4(0, "dns_register_block_invoke", CFSTR("Registered DNS (pairing): %s "), v35, v36, v37, v38, v39, (char)"_apple-pairable._tcp");
  }
  else
  {
    v34 = 0;
  }
  if (!*(_BYTE *)(a1 + 58))
    goto LABEL_41;
  v40 = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(v40 + 40))
  {
    if (*(_DWORD *)(v40 + 52) && *(_QWORD *)(v40 + 56))
      goto LABEL_41;
    IONotificationPortDestroy(*(IONotificationPortRef *)(v40 + 40));
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 40) = 0;
    v40 = *(_QWORD *)(a1 + 40);
  }
  if (*(_DWORD *)(v40 + 52))
  {
    IOServiceClose(*(_DWORD *)(v40 + 52));
    v40 = *(_QWORD *)(a1 + 40);
    *(_DWORD *)(v40 + 52) = 0;
  }
  if (*(_QWORD *)(v40 + 56))
  {
    CFRelease(*(CFTypeRef *)(v40 + 56));
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 56) = 0;
    v40 = *(_QWORD *)(a1 + 40);
  }
  LODWORD(RunLoopSource) = IORegisterForSystemPower((void *)v40, (IONotificationPortRef *)(v40 + 40), (IOServiceInterestCallback)sub_100006504, (io_object_t *)(v40 + 48));
  v47 = *(_QWORD *)(a1 + 40);
  *(_DWORD *)(v47 + 52) = (_DWORD)RunLoopSource;
  if ((_DWORD)RunLoopSource)
  {
    RunLoopSource = IONotificationPortGetRunLoopSource(*(IONotificationPortRef *)(v47 + 40));
    if (RunLoopSource)
    {
      v48 = RunLoopSource;
      Current = CFRunLoopGetCurrent();
      CFRunLoopAddSource(Current, v48, kCFRunLoopDefaultMode);
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 56) = WiFiManagerClientCreate(kCFAllocatorDefault, 1);
      RunLoopSource = *(CFRunLoopSourceRef *)(*(_QWORD *)(a1 + 40) + 56);
      if (RunLoopSource)
      {
        WiFiManagerClientSetWoWState(RunLoopSource, 1);
        sub_10001A7E4(0, "dns_register_block_invoke", CFSTR("Registered WOL."), v50, v51, v52, v53, v54, v56);
LABEL_41:
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
        goto LABEL_24;
      }
      v55 = CFSTR("WiFiManagerClientCreate failed.");
    }
    else
    {
      v55 = CFSTR("IONotificationPortGetRunLoopSource failed for power notifications.");
    }
  }
  else
  {
    v55 = CFSTR("IORegisterForSystemPower failed.");
  }
  sub_10001A7E4((int)RunLoopSource, "dns_register_block_invoke", v55, v42, v43, v44, v45, v46, v56);
LABEL_24:
  if (v9)
    CFRelease(v9);
LABEL_26:

}

void sub_100006504(uint64_t a1, int a2, int a3, intptr_t notificationID, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unint64_t v9;
  IOReturn v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BOOL8 v28;
  unsigned int v29;
  mach_port_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFString *v36;
  uint64_t v37;
  const __CFDictionary *v38;
  io_service_t MatchingService;
  io_object_t v40;
  const __CFDictionary *CFProperty;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const __CFDictionary *v47;
  const __CFData *Value;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const __CFData *v54;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unsigned int v62;
  const UInt8 *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  const void *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  const __CFString *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  IOReturn v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  dispatch_time_t v100;
  const UInt8 *v101;
  char v102;
  size_t v103;
  clock_serv_t clock_serv;
  mach_timespec_t cur_time;
  uint64_t v106;
  uint64_t (*v107)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v108;
  uint64_t *v109;
  uint64_t valuePtr;
  uint64_t *p_valuePtr;
  uint64_t v112;
  int v113;
  _OWORD v114[8];

  memset(v114, 0, sizeof(v114));
  v103 = 128;
  HIDWORD(v9) = a3;
  LODWORD(v9) = a3 + 536870288;
  switch((v9 >> 4))
  {
    case 0u:
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "_sleep_wake_notification_callback", CFSTR("Power notification: kIOMessageCanSystemSleep"), notificationID, a5, a6, a7, a8, v102);
      goto LABEL_8;
    case 1u:
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "_sleep_wake_notification_callback", CFSTR("Power notification: kIOMessageSystemWillSleep"), notificationID, a5, a6, a7, a8, v102);
      sub_100006DB8((_QWORD *)a1, 1, 1, 0, a5, a6, a7, a8, v102);
LABEL_8:
      v12 = IOAllowPowerChange(*(_DWORD *)(a1 + 52), notificationID);
      if (v12)
        sub_10001A7E4(0, "_sleep_wake_notification_callback", CFSTR("IOAllowPowerChange failed: 0x%08x"), v13, v14, v15, v16, v17, v12);
      return;
    case 2u:
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "_sleep_wake_notification_callback", CFSTR("Power notification: kIOMessageCanSystemSleep"), notificationID, a5, a6, a7, a8, a9);
      return;
    case 9u:
      sysctlbyname("kern.wakereason", v114, &v103, 0, 0);
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "_sleep_wake_notification_callback", CFSTR("Power notification: kIOMessageSystemHasPoweredOn (Wake Reason - %s)"), v18, v19, v20, v21, v22, (char)v114);
      v28 = (sub_10000F404(*(_QWORD *)a1, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiDebugging"), v18, v19, v20, v21, v22)|| sub_10000F404(*(_QWORD *)a1, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiConnections"), v23, v24, v25, v26, v27))&& *(_QWORD *)(a1 + 24) != 0;
      v29 = sub_10000F404(*(_QWORD *)a1, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiPairing"), v23, v24, v25, v26, v27);
      if (v29 != 0 || !~v28)
        sub_100005EF8(a1, *(_QWORD *)(a1 + 24), v28, v29 != 0, 0);
      clock_serv = 0;
      cur_time = 0;
      valuePtr = 0;
      v30 = mach_host_self();
      if (host_get_clock_service(v30, 0, &clock_serv))
      {
        v36 = CFSTR("Failed to query clock service.");
LABEL_24:
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", v36, v31, v32, v33, v34, v35, v102);
        return;
      }
      if (clock_get_time(clock_serv, &cur_time))
      {
        v36 = CFSTR("Failed to get clock time.");
        goto LABEL_24;
      }
      v37 = 1000 * cur_time.tv_sec;
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Current time since boot: %lld."), v31, v32, v33, v34, v35, -24 * LOBYTE(cur_time.tv_sec));
      v38 = IOServiceMatching("AppleBCMWLANCore");
      if (!v38)
      {
        v36 = CFSTR("Failed to query AppleBCMWLANCore service.");
        goto LABEL_24;
      }
      MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v38);
      v40 = MatchingService;
      if (!MatchingService)
      {
        v36 = CFSTR("Failed to get matching service.");
        goto LABEL_24;
      }
      CFProperty = (const __CFDictionary *)IORegistryEntryCreateCFProperty(MatchingService, CFSTR("IO80211InterfaceWoWWakeUpParams"), kCFAllocatorDefault, 0);
      v47 = CFProperty;
      if (!CFProperty)
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("IORegistryEntryCreateCFProperty failed for %s."), v42, v43, v44, v45, v46, (char)"IO80211InterfaceWoWWakeUpParams");
        IOObjectRelease(v40);
        return;
      }
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("APPLE80211_REGKEY_WOW_WAKEUP_PARAMS: %@"), v42, v43, v44, v45, v46, (char)CFProperty);
      Value = (const __CFData *)CFDictionaryGetValue(v47, CFSTR("IO80211InterfaceWoWWakeUpData"));
      v54 = Value;
      if (!Value)
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Failed to query %s."), v49, v50, v51, v52, v53, (char)"IO80211InterfaceWoWWakeUpData");
        goto LABEL_41;
      }
      BytePtr = CFDataGetBytePtr(Value);
      Length = CFDataGetLength(v54);
      if (Length <= 115)
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Packet is too short."), v57, v58, v59, v60, v61, v102);
LABEL_41:
        CFRelease(v47);
        IOObjectRelease(v40);
        return;
      }
      v62 = __rev16(*((unsigned __int16 *)BytePtr + 6));
      switch(v62)
      {
        case 0x86DDu:
          if (BytePtr[20] != 17)
          {
            sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Unrecognized IPv6 protocol 0x%02X"), v57, v58, v59, v60, v61, BytePtr[20]);
            goto LABEL_41;
          }
          v63 = BytePtr + 68;
          break;
        case 0x842u:
          v63 = BytePtr + 20;
          break;
        case 0x800u:
          if (BytePtr[23] != 17)
          {
            sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Unrecognized IPv4 protocol 0x%02X"), v57, v58, v59, v60, v61, BytePtr[23]);
            goto LABEL_41;
          }
          v63 = &BytePtr[4 * (BytePtr[14] & 0xF) + 28];
          break;
        default:
          sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Unrecognized etherType 0x%04X"), v57, v58, v59, v60, v61, v62);
          goto LABEL_41;
      }
      if (v63 + 96 > &BytePtr[Length])
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Payload underrun."), v57, v58, v59, v60, v61, v102);
        goto LABEL_41;
      }
      if (qword_1001A7FC0 != -1)
      {
        v101 = v63;
        dispatch_once(&qword_1001A7FC0, &stru_10017A208);
        v63 = v101;
      }
      if (memcmp(v63, (const void *)qword_1001A7FB8, 0x60uLL))
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Not a WOL packet."), v64, v65, v66, v67, v68, v102);
        goto LABEL_41;
      }
      v69 = CFDictionaryGetValue(v47, CFSTR("IO80211InterfaceWoWWakeUpTimeStamp"));
      if (!sub_100010B0C(v69))
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Failed to query %s."), v70, v71, v72, v73, v74, (char)"IO80211InterfaceWoWWakeUpTimeStamp");
        goto LABEL_41;
      }
      if (!CFNumberGetValue((CFNumberRef)v69, kCFNumberLongLongType, &valuePtr))
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Failed to convert to integer."), v75, v76, v77, v78, v79, v102);
        goto LABEL_41;
      }
      if (qword_1001A7FB0)
      {
        if (valuePtr == qword_1001A7FB0)
        {
          sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Wake time did not change: %lld"), v75, v76, v77, v78, v79, qword_1001A7FB0);
          goto LABEL_41;
        }
        v80 = CFSTR("New Wake time: %lld");
      }
      else
      {
        v80 = CFSTR("note the time for future reference: %lld");
      }
      sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", v80, v75, v76, v77, v78, v79, valuePtr);
      v86 = valuePtr;
      qword_1001A7FB0 = valuePtr;
      if (dword_1001A6AD0)
      {
        sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Wake time since boot: %lld."), v81, v82, v83, v84, v85, valuePtr);
        v86 = valuePtr;
      }
      v87 = v86 - v37;
      if (v87 >= 0)
        v88 = v87;
      else
        v88 = -v87;
      sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("Wake time difference: %lld."), v81, v82, v83, v84, v85, v88);
      if (v88 > 0x7CF)
        goto LABEL_41;
      sub_10001A7E4(0, "_did_wake_for_wifi_wake_packet", CFSTR("waker was: %02x:%02x:%02x:%02x:%02x:%02x"), v89, v90, v91, v92, v93, BytePtr[6]);
      CFRelease(v47);
      IOObjectRelease(v40);
      valuePtr = 0;
      p_valuePtr = &valuePtr;
      v112 = 0x2020000000;
      v113 = 0;
      if (qword_1001A7FD0 != -1)
        dispatch_once(&qword_1001A7FD0, &stru_10017A228);
      v94 = IOPMAssertionCreateWithDescription(CFSTR("PreventUserIdleSystemSleep"), CFSTR("com.apple.mobile.lockdownd.wake-on-wlan"), CFSTR("The 411 on sync."), 0, 0, 0.0, 0, (IOPMAssertionID *)p_valuePtr + 6);
      if (v94)
      {
        sub_10001A7E4(0, "_takePowerAssertionForInterval", CFSTR("IOPMAssertionCreateWithDescription failed with %d"), v95, v96, v97, v98, v99, v94);
      }
      else
      {
        if (dword_1001A6AD0)
          sub_10001A7E4(0, "_takePowerAssertionForInterval", CFSTR("Aquired %ld second power assertion."), v95, v96, v97, v98, v99, 30);
        v100 = dispatch_time(0, 30000000000);
        cur_time = (mach_timespec_t)_NSConcreteStackBlock;
        v106 = 3221225472;
        v107 = sub_10000DDF0;
        v108 = &unk_10017A178;
        v109 = &valuePtr;
        dispatch_after(v100, (dispatch_queue_t)qword_1001A7FC8, &cur_time);
      }
      _Block_object_dispose(&valuePtr, 8);
      return;
    case 0xBu:
      return;
    default:
      sub_10001A7E4(0, "_sleep_wake_notification_callback", CFSTR("Unknown power notification: %d"), notificationID, a5, a6, a7, a8, a3);
      return;
  }
}

void sub_100006D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100006DB8(_QWORD *a1, char a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  NSObject *v9;
  _QWORD v10[5];
  char v11;
  char v12;
  char v13;

  if (a1 && *a1 && (v9 = a1[2]) != 0)
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100006E4C;
    v10[3] = &unk_100179DB0;
    v11 = a2;
    v12 = a3;
    v10[4] = a1;
    v13 = a4;
    dispatch_sync(v9, v10);
  }
  else
  {
    sub_10001A7E4(0, "dns_unregister", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100006E4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  IOReturn v23;
  IONotificationPort *v24;
  io_connect_t v25;
  const void *v26;
  char v27;

  if (*(_BYTE *)(a1 + 40))
  {
    v10 = *(_QWORD *)(a1 + 32);
    if (*(_BYTE *)(v10 + 32))
    {
      *(_BYTE *)(v10 + 32) = 0;
      xpc_set_event("com.apple.bonjour.registration", "LOCKDOWN.BONJOUR", 0);
      sub_10001A7E4(0, "dns_unregister_block_invoke", CFSTR("Unregistered DNS (syncing)."), v11, v12, v13, v14, v15, v27);
    }
  }
  else if (!*(_BYTE *)(a1 + 41))
  {
    goto LABEL_8;
  }
  if (*(_BYTE *)(a1 + 41))
  {
    v16 = *(_QWORD *)(a1 + 32);
    if (*(_BYTE *)(v16 + 33))
    {
      *(_BYTE *)(v16 + 33) = 0;
      xpc_set_event("com.apple.bonjour.registration", "LOCKDOWN.PAIRING.BONJOUR", 0);
      sub_10001A7E4(0, "dns_unregister_block_invoke", CFSTR("Unregistered DNS (pairing)."), v17, v18, v19, v20, v21, v27);
    }
  }
LABEL_8:
  if (*(_BYTE *)(a1 + 42))
  {
    v22 = *(_QWORD *)(a1 + 32);
    if (*(_DWORD *)(v22 + 48))
    {
      v23 = IODeregisterForSystemPower((io_object_t *)(v22 + 48));
      if (v23)
        sub_10001A7E4(0, "dns_unregister_block_invoke", CFSTR("IODeregisterForSystemPower failed: %d"), a4, a5, a6, a7, a8, v23);
      v22 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)(v22 + 48) = 0;
    }
    v24 = *(IONotificationPort **)(v22 + 40);
    if (v24)
    {
      IONotificationPortDestroy(v24);
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 40) = 0;
      v22 = *(_QWORD *)(a1 + 32);
    }
    v25 = *(_DWORD *)(v22 + 52);
    if (v25)
    {
      IOServiceClose(v25);
      v22 = *(_QWORD *)(a1 + 32);
      *(_DWORD *)(v22 + 52) = 0;
    }
    v26 = *(const void **)(v22 + 56);
    if (v26)
    {
      CFRelease(v26);
      v22 = *(_QWORD *)(a1 + 32);
    }
    *(_QWORD *)(v22 + 56) = 0;
    sub_10001A7E4(0, "dns_unregister_block_invoke", CFSTR("Unregistered WOL."), a4, a5, a6, a7, a8, a9);
  }
}

uint64_t sub_100006FB4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  CFPropertyListRef v6;
  const void *v7;
  const void *v8;
  _BOOL8 v9;

  if (!MGGetBoolAnswer(CFSTR("IsUIBuild")))
    return 1;
  v6 = sub_10001AE30(CFSTR("LastSystemVersion"), CFSTR("com.apple.migration"), v0, v1, v2, v3, v4, v5);
  if (!v6)
    return 0;
  v7 = v6;
  v8 = (const void *)MGCopyAnswer(CFSTR("BuildVersion"), 0);
  if (!sub_100010BA8(v8))
  {
    v9 = 0;
    if (!v8)
      goto LABEL_6;
    goto LABEL_5;
  }
  v9 = CFEqual(v7, v8) != 0;
  if (v8)
LABEL_5:
    CFRelease(v8);
LABEL_6:
  CFRelease(v7);
  return v9;
}

uint64_t sub_10000706C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  const __CFString *v10;
  char v12;
  _QWORD block[5];

  if (!a1 || !a2)
  {
    v10 = CFSTR("Invalid input(s).");
    v9 = 0;
LABEL_9:
    sub_10001A7E4(v9, "notify_configd", v10, a4, a5, a6, a7, a8, v12);
    return byte_1001A7F60;
  }
  if (qword_1001A7F68 != -1)
    dispatch_once(&qword_1001A7F68, &stru_100179DF0);
  v9 = qword_1001A7F58;
  if (!qword_1001A7F58)
  {
    v10 = CFSTR("Failed to create queue.");
    goto LABEL_9;
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100007168;
  block[3] = &unk_100179E10;
  block[4] = a2;
  dispatch_sync((dispatch_queue_t)qword_1001A7F58, block);
  return byte_1001A7F60;
}

void sub_10000713C(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.lockdownd.configd", 0);
  v2 = (void *)qword_1001A7F58;
  qword_1001A7F58 = (uint64_t)v1;

}

void sub_100007168(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  int out_token;
  CFTypeRef cf;

  out_token = -1;
  if (*(_QWORD *)(a1 + 32))
  {
    if ((byte_1001A7F60 & 1) == 0)
    {
      if (notify_register_check("com.apple.mobile.lockdown", &out_token))
      {
        sub_10001A7E4(0, "notify_configd_block_invoke_2", CFSTR("Failed to register notification (%s): %d"), v9, v10, v11, v12, v13, (char)"com.apple.mobile.lockdown");
      }
      else
      {
        notify_set_state(out_token, 1uLL);
        notify_post("com.apple.mobile.lockdown");
        cf = 0;
        IOUSBDeviceControllerCreate(0, &cf);
        if (cf)
        {
          v14 = IOUSBDeviceControllerForceOffBus(cf, 0);
          if (v14)
            sub_10001A7E4(0, "allow_usb_on_bus", CFSTR("IOUSBDeviceControllerForceOffBus returned: %d"), v15, v16, v17, v18, v19, v14);
          CFRelease(cf);
        }
        else
        {
          NSLog(CFSTR("we failed to create an IOUSBDeviceController"));
        }
        sub_10001A7E4(0, "notify_configd_block_invoke_2", CFSTR("Pinged configd, USB is now enabled."), v20, v21, v22, v23, v24, v25);
        byte_1001A7F60 = 1;
      }
    }
  }
  else
  {
    sub_10001A7E4(0, "notify_configd_block_invoke_2", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100007290(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char vars0;

  if (a1)
  {
    sub_1000072E4(CFSTR("DiagnosticsAllowed"), a1, CFSTR("com.apple.iqagent"), a4, a5, a6, a7, a8, vars0);
    sub_1000110EC(CFSTR("com.apple.iqagent.IQAllowedChangeNotification"));
  }
  else
  {
    sub_10001A7E4(0, "set_iqagent", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_1000072E4(const void *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFString *v11;
  const __CFString *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFString *v18;

  v11 = (const __CFString *)sub_100010BA8(a1);
  v12 = (const __CFString *)sub_100010BA8(a3);
  v18 = CFSTR("bogus request");
  if (v11 && v12)
  {
    if (!sub_10001AD28(v11, a2, v12, v13, v14, v15, v16, v17))
      return;
    v18 = CFSTR("Could not set preference via lockbot");
  }
  sub_10001A7E4(0, "_set_mobile_preference", v18, v13, v14, v15, v16, v17, a9);
}

uint64_t sub_100007368()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const __CFString *v5;
  uint64_t v6;
  io_registry_entry_t v7;
  io_registry_entry_t v8;
  CFDataRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFDataRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v22;
  mach_port_t mainPort;

  mainPort = 0;
  if (IOMasterPort(bootstrap_port, &mainPort))
  {
    v5 = CFSTR("Could not get master port");
LABEL_3:
    sub_10001A7E4(0, "disable_auto_boot", v5, v0, v1, v2, v3, v4, v22);
    return 0xFFFFFFFFLL;
  }
  v7 = IORegistryEntryFromPath(mainPort, "IODeviceTree:/options");
  if (!v7)
  {
    v5 = CFSTR("Could not get options entry from the device tree");
    goto LABEL_3;
  }
  v8 = v7;
  v9 = CFDataCreate(0, (const UInt8 *)"false", 5);
  if (v9)
  {
    v15 = v9;
    if (IORegistryEntrySetCFProperty(v8, CFSTR("auto-boot"), v9))
    {
      sub_10001A7E4(0, "disable_auto_boot", CFSTR("Could not set auto-boot setting"), v16, v17, v18, v19, v20, v22);
      v6 = 0xFFFFFFFFLL;
    }
    else
    {
      v6 = 0;
    }
    CFRelease(v15);
  }
  else
  {
    sub_10001A7E4(0, "disable_auto_boot", CFSTR("Could not create CFData"), v10, v11, v12, v13, v14, v22);
    v6 = 0xFFFFFFFFLL;
  }
  IOObjectRelease(v8);
  return v6;
}

__CFDictionary *sub_100007480(uint64_t a1, const void *a2, const void *a3)
{
  _QWORD *v6;
  char v7;
  _QWORD *v8;
  char v9;
  _QWORD *v10;
  char v11;
  _QWORD *v12;
  char v13;
  _QWORD *v14;
  char v15;
  _QWORD *v16;
  char v17;
  _QWORD *v18;
  char v19;
  char v20;
  uint64_t *v21;
  const void *v22;
  __CFDictionary *v23;
  _QWORD v25[4];
  _QWORD *v26;
  _QWORD v27[4];
  id v28;
  _QWORD v29[4];
  id v30;
  _QWORD v31[4];
  id v32;
  _QWORD v33[4];
  id v34;
  _QWORD v35[4];
  id v36;
  _QWORD v37[4];
  id v38;
  _QWORD v39[4];
  id v40;
  _QWORD v41[5];
  _QWORD v42[5];
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  __CFDictionary *v47;
  void **v48;
  uint64_t v49;
  CFNumberRef (*v50)(uint64_t);
  void *v51;
  const char *v52;

  v46 = 0;
  v47 = 0;
  v43 = 0;
  v44 = &v43;
  v45 = 0x2020000000;
  if ((sub_1000079D8(a3, CFSTR("NANDInfo"), &v47, &stru_100179E50) & 1) == 0)
  {
    v42[0] = _NSConcreteStackBlock;
    v42[1] = 3221225472;
    v42[2] = sub_100007B80;
    v42[3] = &unk_100179E70;
    v42[4] = a1;
    if ((sub_1000079D8(a3, CFSTR("CalculateDiskUsage"), &v47, v42) & 1) == 0)
    {
      v41[0] = _NSConcreteStackBlock;
      v41[1] = 3221225472;
      v41[2] = sub_100007D84;
      v41[3] = &unk_100179E98;
      v41[4] = &v43;
      v39[0] = _NSConcreteStackBlock;
      v39[1] = 3221225472;
      v39[2] = sub_100007E04;
      v39[3] = &unk_100179EC0;
      v6 = objc_retainBlock(v41);
      v40 = v6;
      v7 = sub_1000079D8(a3, CFSTR("TotalSystemCapacity"), &v47, v39);

      if ((v7 & 1) == 0)
      {
        v37[0] = _NSConcreteStackBlock;
        v37[1] = 3221225472;
        v37[2] = sub_100007E1C;
        v37[3] = &unk_100179EC0;
        v8 = v6;
        v38 = v8;
        v9 = sub_1000079D8(a3, CFSTR("TotalSystemAvailable"), &v47, v37);

        if ((v9 & 1) == 0)
        {
          v35[0] = _NSConcreteStackBlock;
          v35[1] = 3221225472;
          v35[2] = sub_100007E34;
          v35[3] = &unk_100179EC0;
          v10 = v8;
          v36 = v10;
          v11 = sub_1000079D8(a3, CFSTR("TotalDataCapacity"), &v47, v35);

          if ((v11 & 1) == 0)
          {
            v33[0] = _NSConcreteStackBlock;
            v33[1] = 3221225472;
            v33[2] = sub_100007E4C;
            v33[3] = &unk_100179EC0;
            v12 = v10;
            v34 = v12;
            v13 = sub_1000079D8(a3, CFSTR("TotalDataAvailable"), &v47, v33);

            if ((v13 & 1) == 0)
            {
              v31[0] = _NSConcreteStackBlock;
              v31[1] = 3221225472;
              v31[2] = sub_100007E64;
              v31[3] = &unk_100179EC0;
              v14 = v12;
              v32 = v14;
              v15 = sub_1000079D8(a3, CFSTR("TotalDiskCapacity"), &v47, v31);

              if ((v15 & 1) == 0)
              {
                v29[0] = _NSConcreteStackBlock;
                v29[1] = 3221225472;
                v29[2] = sub_100007E7C;
                v29[3] = &unk_100179EC0;
                v16 = v14;
                v30 = v16;
                v17 = sub_1000079D8(a3, CFSTR("AmountDataReserved"), &v47, v29);

                if ((v17 & 1) == 0)
                {
                  v27[0] = _NSConcreteStackBlock;
                  v27[1] = 3221225472;
                  v27[2] = sub_100007E94;
                  v27[3] = &unk_100179EC0;
                  v18 = v16;
                  v28 = v18;
                  v19 = sub_1000079D8(a3, CFSTR("AmountDataAvailable"), &v47, v27);

                  if ((v19 & 1) == 0)
                  {
                    v25[0] = _NSConcreteStackBlock;
                    v25[1] = 3221225472;
                    v25[2] = sub_100007EAC;
                    v25[3] = &unk_100179EC0;
                    v26 = v18;
                    v20 = sub_1000079D8(a3, CFSTR("AmountRestoreAvailable"), &v47, v25);

                    if ((v20 & 1) == 0)
                    {
                      if (CFEqual(a2, CFSTR("com.apple.disk_usage.factory")))
                      {
                        if ((sub_1000079D8(a3, CFSTR("PhotoUsage"), &v47, &stru_100179EE0) & 1) == 0
                          && (sub_1000079D8(a3, CFSTR("CameraUsage"), &v47, &stru_100179F00) & 1) == 0)
                        {
                          v48 = _NSConcreteStackBlock;
                          v49 = 3221225472;
                          v50 = sub_10000D8C4;
                          v51 = &unk_100179E70;
                          v52 = "/var/mobile/Library/Calendar";
                          if ((sub_1000079D8(a3, CFSTR("CalendarUsage"), &v47, &v48) & 1) == 0)
                          {
                            v48 = _NSConcreteStackBlock;
                            v49 = 3221225472;
                            v50 = sub_10000D8C4;
                            v51 = &unk_100179E70;
                            v52 = "/var/mobile/Library/Voicemail";
                            if ((sub_1000079D8(a3, CFSTR("VoicemailUsage"), &v47, &v48) & 1) == 0)
                            {
                              v48 = _NSConcreteStackBlock;
                              v49 = 3221225472;
                              v50 = sub_10000D8C4;
                              v51 = &unk_100179E70;
                              v52 = "/var/mobile/Library/Notes";
                              if ((sub_1000079D8(a3, CFSTR("NotesUsage"), &v47, &v48) & 1) == 0)
                              {
                                v48 = _NSConcreteStackBlock;
                                v49 = 3221225472;
                                v50 = sub_10000D8C4;
                                v51 = &unk_100179E70;
                                v52 = "/var/mobile/tmp/com.apple.mediaplaybackd/MediaCache";
                                if ((sub_1000079D8(a3, CFSTR("MediaCacheUsage"), &v47, &v48) & 1) == 0)
                                {
                                  v48 = _NSConcreteStackBlock;
                                  v49 = 3221225472;
                                  v50 = sub_10000D8C4;
                                  v51 = &unk_100179E70;
                                  v52 = "/var/mobile/Library/Caches/com.apple.WebAppCache";
                                  sub_1000079D8(a3, CFSTR("WebAppCacheUsage"), &v47, &v48);
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }

    }
  }
  v21 = v44;
  v22 = (const void *)v44[3];
  if (v22)
  {
    CFRelease(v22);
    v21 = v44;
  }
  v21[3] = 0;
  v23 = v47;
  _Block_object_dispose(&v43, 8);
  return v23;
}

void sub_1000079BC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000079D8(const void *a1, const void *a2, __CFDictionary **a3, void *a4)
{
  uint64_t (**v7)(_QWORD);
  uint64_t (**v8)(_QWORD);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  __CFDictionary *v23;

  v7 = a4;
  v8 = v7;
  if (!a1)
  {
    v16 = v7[2](v7);
    if (v16)
    {
      v22 = (const void *)v16;
      v23 = *a3;
      if (*a3 || (v23 = sub_100025A4C(), (*a3 = v23) != 0))
        CFDictionarySetValue(v23, a2, v22);
      CFRelease(v22);
    }
    else
    {
      sub_10001A7E4(0, "set_stat_if_wanted", CFSTR("Could not get value for %@"), v17, v18, v19, v20, v21, (char)a2);
    }
    goto LABEL_12;
  }
  if (!CFEqual(a1, a2))
  {
LABEL_12:
    v15 = 0;
    goto LABEL_13;
  }
  v14 = v8[2](v8);
  if (!v14)
    sub_10001A7E4(0, "set_stat_if_wanted", CFSTR("Could not get value for %@"), v9, v10, v11, v12, v13, (char)a2);
  *a3 = (__CFDictionary *)v14;
  v15 = 1;
LABEL_13:

  return v15;
}

void *__cdecl sub_100007AC4(id a1)
{
  void *v1;
  _QWORD block[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2020000000;
  v7 = 0;
  if (qword_1001A7F98 != -1)
    dispatch_once(&qword_1001A7F98, &stru_10017A150);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10000D898;
  block[3] = &unk_10017A178;
  block[4] = &v4;
  dispatch_sync((dispatch_queue_t)qword_1001A7F90, block);
  v1 = (void *)v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

CFTypeRef sub_100007B80(uint64_t a1)
{
  xpc_object_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  CFTypeRef v9;
  const __CFString *v10;
  char v12;

  v2 = xpc_dictionary_create(0, 0, 0);
  v8 = v2;
  if (!v2)
  {
    v10 = CFSTR("Failed to create dictionary.");
LABEL_6:
    sub_10001A7E4((int)v2, "copy_disk_usage_block_invoke_2", v10, v3, v4, v5, v6, v7, v12);
    v9 = 0;
    goto LABEL_7;
  }
  xpc_dictionary_set_string(v2, XPC_ACTIVITY_PRIORITY, XPC_ACTIVITY_PRIORITY_UTILITY);
  xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_REPEATING, 0);
  xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_ALLOW_BATTERY, 1);
  xpc_dictionary_set_BOOL(v8, XPC_ACTIVITY_REQUIRES_CLASS_C, 0);
  xpc_dictionary_set_int64(v8, XPC_ACTIVITY_DELAY, 0);
  xpc_dictionary_set_int64(v8, XPC_ACTIVITY_GRACE_PERIOD, 10);
  if ((sub_100007CAC(*(_QWORD *)(a1 + 32), v8, 0) & 1) == 0)
  {
    v10 = CFSTR("Failed to schedule application disk usage XPC activity.");
    LODWORD(v2) = 0;
    goto LABEL_6;
  }
  v9 = CFRetain(CFSTR("OkilyDokily"));
LABEL_7:

  return v9;
}

uint64_t sub_100007CAC(uint64_t a1, void *a2, char a3)
{
  id v5;
  id v6;
  NSObject *v7;
  id v8;
  uint64_t v9;
  _QWORD v11[4];
  id v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  char v19;

  v5 = a2;
  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 0;
  v6 = sub_100007F18();
  v7 = objc_claimAutoreleasedReturnValue(v6);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_100007F64;
  v11[3] = &unk_100179F88;
  v13 = &v16;
  v14 = a1;
  v12 = v5;
  v15 = a3;
  v8 = v5;
  dispatch_sync(v7, v11);

  v9 = *((unsigned __int8 *)v17 + 24);
  _Block_object_dispose(&v16, 8);
  return v9;
}

const void *sub_100007D84(uint64_t a1, void *key)
{
  const __CFDictionary *v4;
  const void *Value;
  const void *v6;

  v4 = *(const __CFDictionary **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  if (!v4)
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = MGCopyAnswer(CFSTR("DiskUsage"), 0);
    v4 = *(const __CFDictionary **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    if (!v4)
      return 0;
  }
  Value = CFDictionaryGetValue(v4, key);
  v6 = Value;
  if (Value)
    CFRetain(Value);
  return v6;
}

uint64_t sub_100007E04(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100007E1C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100007E34(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100007E4C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100007E64(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100007E7C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100007E94(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

uint64_t sub_100007EAC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void *__cdecl sub_100007EC4(id a1)
{
  return sub_10002CEC4(CFSTR("PhotoUsage"));
}

void *__cdecl sub_100007ED4(id a1)
{
  return sub_10002CEC4(CFSTR("CameraUsage"));
}

void sub_100007EE4()
{
  id v0;
  NSObject *v1;

  v0 = sub_100007F18();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  dispatch_async(v1, &stru_100179F20);

}

id sub_100007F18()
{
  if (qword_1001A7FA8 != -1)
    dispatch_once(&qword_1001A7FA8, &stru_10017A198);
  return (id)qword_1001A7FA0;
}

void sub_100007F58(id a1)
{
  byte_1001A7F70 = 0;
}

void sub_100007F64(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 48);
  if (byte_1001A7F70 == 1)
  {
    v3 = sub_10000F4E0(v2, CFSTR("com.apple.disk_usage"), CFSTR("MobileApplicationUsage"));
    sub_100007FF8(*(_QWORD *)(a1 + 48), v3);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  }
  else
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = sub_100023078(v2, "com.apple.lockdownd.usage", *(void **)(a1 + 32), *(_BYTE *)(a1 + 56), &stru_100179F60);
  }
}

void sub_100007FF8(uint64_t a1, uint64_t a2)
{
  id v4;
  NSObject *v5;

  v4 = sub_100007F18();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  dispatch_assert_queue_V2(v5);

  sub_10000EAAC(a1, (uint64_t)CFSTR("com.apple.disk_usage"), (uint64_t)CFSTR("MobileApplicationUsage"), a2);
  sub_10000EAAC(a1, (uint64_t)CFSTR("com.apple.disk_usage.factory"), (uint64_t)CFSTR("MobileApplicationUsage"), a2);
  byte_1001A7F70 = 1;
}

void sub_100008084(id a1, _data_ark *a2)
{
  uint64_t v3;
  void *v4;
  id v5;
  NSObject *v6;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t (*v11)(uint64_t, uint64_t);
  void (*v12)(uint64_t);
  id v13;

  v8 = 0;
  v9 = &v8;
  v10 = 0x3032000000;
  v11 = sub_10000CBFC;
  v12 = sub_10000CC0C;
  v13 = 0;
  v3 = os_transaction_create("com.apple.lockdownd.usage");
  v4 = (void *)v9[5];
  v9[5] = v3;

  v5 = sub_100007F18();
  v6 = objc_claimAutoreleasedReturnValue(v5);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_10000DAB0;
  v7[3] = &unk_10017A1E8;
  v7[4] = &v8;
  v7[5] = a2;
  dispatch_async(v6, v7);

  _Block_object_dispose(&v8, 8);
}

void sub_100008154(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

char *sub_10000816C(char *result)
{
  strcpy(result, "/private/var/root");
  return result;
}

const __CFString *sub_100008188(const __CFString *a1)
{
  const __CFString *MutableCopy;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFString *v8;
  uint64_t Length;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFStringTokenizerRef v15;
  __CFStringTokenizer *v16;
  CFMutableStringRef Mutable;
  const __CFString *v18;
  const __CFString *v19;
  const __CFString *v20;
  uint64_t v22;
  CFRange v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  CFRange range;
  CFRange v31;
  CFRange v32;
  CFRange v33;
  CFRange v34;

  if (sub_100010BA8(a1) && CFStringGetLength(a1) <= 63 && CFStringGetLength(a1) >= 1)
  {
    MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, a1);
    if (MutableCopy)
    {
      v8 = (__CFString *)MutableCopy;
      v32.length = CFStringGetLength(MutableCopy);
      v32.location = 0;
      CFStringFindAndReplace(v8, CFSTR(" "), CFSTR("-"), v32, 0);
      v33.length = CFStringGetLength(v8);
      v33.location = 0;
      CFStringFindAndReplace(v8, CFSTR("_"), CFSTR("-"), v33, 0);
      v34.length = CFStringGetLength(v8);
      v34.location = 0;
      CFStringFindAndReplace(v8, CFSTR("--"), CFSTR("-"), v34, 0);
      CFStringTrim(v8, CFSTR("-"));
      Length = CFStringGetLength(v8);
      if (Length < 1)
        goto LABEL_24;
      v31.length = Length;
      v31.location = 0;
      v15 = CFStringTokenizerCreate(0, v8, v31, 0x10004uLL, 0);
      if (v15)
      {
        v16 = v15;
        Mutable = CFStringCreateMutable(0, 0);
        while (CFStringTokenizerAdvanceToNextToken(v16))
        {
          v18 = (const __CFString *)CFStringTokenizerCopyCurrentTokenAttribute(v16, 0x10000uLL);
          if (v18)
          {
            v19 = v18;
            CFStringAppend(Mutable, v18);
            CFRelease(v19);
          }
        }
        CFRelease(v16);
        if (!Mutable)
          goto LABEL_24;
      }
      else
      {
        Mutable = CFStringCreateMutableCopy(0, 0, v8);
        if (!Mutable)
          goto LABEL_24;
      }
      range.location = 0;
      range.length = CFStringGetLength(Mutable);
      CFStringTransform(Mutable, &range, CFSTR("Latin; NFD; [^-_a-zA-Z0-9] Remove"), 0);
      v22 = CFStringGetLength(Mutable);
      if (v22 >= 255)
        v23.length = 255;
      else
        v23.length = v22;
      range.location = 0;
      range.length = v23.length;
      v23.location = 0;
      v20 = CFStringCreateWithSubstring(0, Mutable, v23);
      CFRelease(Mutable);
      if (v20)
      {
        if (CFStringGetLength(v20) && CFStringGetLength(v20) < 64)
        {
LABEL_26:
          CFRelease(v8);
          return v20;
        }
        CFRelease(v20);
      }
LABEL_24:
      sub_10001A7E4(0, "sanitize_device_name", CFSTR("Failed to create posix name, using default."), v10, v11, v12, v13, v14, v29);
      v20 = (const __CFString *)MGCopyAnswer(CFSTR("MarketingDeviceFamilyName"), 0);
      if (!v20)
        sub_10001A7E4(0, "sanitize_device_name", CFSTR("Failed to query %@."), v24, v25, v26, v27, v28, (char)CFSTR("MarketingDeviceFamilyName"));
      goto LABEL_26;
    }
    sub_10001A7E4(0, "sanitize_device_name", CFSTR("Failed to copy string."), v3, v4, v5, v6, v7, v29);
  }
  return 0;
}

CFStringRef sub_10000841C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFStringRef result;
  int v9;
  char v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (qword_1001A7F80 != -1)
    dispatch_once(&qword_1001A7F80, &stru_100179FA8);
  if (qword_1001A7F78)
  {
    result = SCDynamicStoreCopyComputerName((SCDynamicStoreRef)qword_1001A7F78, 0);
    if (result)
      return result;
    v9 = SCError();
    v10 = SCErrorString(v9);
    sub_10001A7E4(0, "copy_device_name", CFSTR("SCDynamicStoreCopyComputerName failed: %s"), v11, v12, v13, v14, v15, v10);
  }
  else
  {
    sub_10001A7E4(0, "copy_device_name", CFSTR("Failed to create dynamic store."), a4, a5, a6, a7, a8, v16);
  }
  return 0;
}

void sub_1000084B0(id a1)
{
  qword_1001A7F78 = (uint64_t)SCDynamicStoreCreate(0, CFSTR("lockdownd"), 0, 0);
}

uint64_t sub_1000084E0(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v8;
  const __SCPreferences *v9;
  const __SCPreferences *v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *v37;
  int v38;
  int v39;
  char v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const __CFString *v46;
  int v47;
  char v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char v55;

  if (a1)
  {
    v8 = a1;
    v9 = SCPreferencesCreate(0, CFSTR("com.apple.mobile.lockdown"), 0);
    if (v9)
    {
      v10 = v9;
      if (SCPreferencesLock(v9, 1u))
      {
        if (!SCPreferencesSetComputerName(v10, v8, 0x8000100u))
        {
          v11 = SCError();
          SCErrorString(v11);
          sub_10001A7E4(0, "set_device_name", CFSTR("SCPreferencesSetComputerName failed (%@): %s"), v12, v13, v14, v15, v16, (char)v8);
        }
        v17 = sub_100008188(v8);
        if (v17)
        {
          v23 = v17;
          if (!SCPreferencesSetHostName(v10, v17))
          {
            v24 = SCError();
            SCErrorString(v24);
            sub_10001A7E4(0, "set_device_name", CFSTR("SCPreferencesSetHostName failed (%@): %s"), v25, v26, v27, v28, v29, (char)v23);
          }
          if (!SCPreferencesSetLocalHostName(v10, v23))
          {
            v30 = SCError();
            SCErrorString(v30);
            sub_10001A7E4(0, "set_device_name", CFSTR("SCPreferencesSetLocalHostName failed (%@): %s"), v31, v32, v33, v34, v35, (char)v23);
          }
          if (SCPreferencesCommitChanges(v10))
          {
            if (SCPreferencesApplyChanges(v10))
            {
              v36 = 1;
LABEL_23:
              SCPreferencesUnlock(v10);
              CFRelease(v23);
              goto LABEL_24;
            }
            v46 = CFSTR("SCPreferencesApplyChanges failed: %s");
          }
          else
          {
            v46 = CFSTR("SCPreferencesCommitChanges failed: %s");
          }
          v47 = SCError();
          v48 = SCErrorString(v47);
          sub_10001A7E4(0, "set_device_name", v46, v49, v50, v51, v52, v53, v48);
          v36 = 0;
          goto LABEL_23;
        }
        sub_10001A7E4(0, "set_device_name", CFSTR("Failed to sanitize device name."), v18, v19, v20, v21, v22, v55);
        SCPreferencesUnlock(v10);
      }
      else
      {
        v39 = SCError();
        v40 = SCErrorString(v39);
        sub_10001A7E4(0, "set_device_name", CFSTR("SCPreferencesLock failed: %s"), v41, v42, v43, v44, v45, v40);
      }
      v36 = 0;
LABEL_24:
      CFRelease(v10);
      return v36;
    }
    v38 = SCError();
    v55 = SCErrorString(v38);
    v37 = CFSTR("SCPreferencesCreate failed: %s");
    LODWORD(a1) = 0;
  }
  else
  {
    v37 = CFSTR("Invalid input.");
  }
  sub_10001A7E4((int)a1, "set_device_name", v37, a4, a5, a6, a7, a8, v55);
  return 0;
}

CFDataRef sub_1000086EC(NSObject **a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFDataRef v12;
  char v14;
  _QWORD v15[6];
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int v19;
  UInt8 bytes[4096];

  v16 = 0;
  v17 = &v16;
  v18 = 0x2020000000;
  v19 = 4096;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_100008970;
  v15[3] = &unk_100179FD0;
  v15[4] = &v16;
  v15[5] = bytes;
  v1 = sub_100008834(a1, v15);
  if (v1)
  {
    sub_10001A7E4(0, "extract_cesm_certificate", CFSTR("Could not get certificate chain from vault: %ld"), v2, v3, v4, v5, v6, v1);
    goto LABEL_4;
  }
  v12 = CFDataCreate(0, bytes, *((unsigned int *)v17 + 6));
  if (!v12)
  {
    sub_10001A7E4(0, "extract_cesm_certificate", CFSTR("Could not create CFData from cert chain"), v7, v8, v9, v10, v11, v14);
LABEL_4:
    v12 = 0;
  }
  _Block_object_dispose(&v16, 8);
  return v12;
}

void sub_100008818(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_list va;

  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100008834(NSObject **a1, void *a2)
{
  uint64_t (**v3)(id, _QWORD);
  const __CFString *v4;
  char v5;
  char v6;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v28;
  char v29;
  unsigned int valuePtr;

  v3 = a2;
  valuePtr = 0;
  v4 = CFSTR("Could not find context in ark");
  v5 = 1;
  while (1)
  {
    v6 = v5;
    v7 = (const void *)sub_10000ED98((uint64_t)a1, (uint64_t)CFSTR("com.apple.fairplay"), (uint64_t)CFSTR("FairPlayContextID"));
    if (!sub_100010B0C(v7))
      goto LABEL_10;
    if (!CFNumberGetValue((CFNumberRef)v7, kCFNumberIntType, &valuePtr))
    {
      v4 = CFSTR("Could not convert context");
LABEL_10:
      sub_10001A7E4(0, "retryFairplay", v4, v8, v9, v10, v11, v12, v28);
      if (v7)
        CFRelease(v7);
LABEL_6:
      v26 = 4294925264;
      goto LABEL_8;
    }
    CFRelease(v7);
    v13 = v3[2](v3, valuePtr);
    if ((_DWORD)v13 != -42032)
      break;
    sub_10001A7E4(0, "retryFairplay", CFSTR("Context died"), v14, v15, v16, v17, v18, v28);
    sub_100012A4C(a1, v19, v20, v21, v22, v23, v24, v25, v29);
    v5 = 0;
    if ((v6 & 1) == 0)
      goto LABEL_6;
  }
  v26 = v13;
LABEL_8:

  return v26;
}

void sub_100008970(uint64_t a1, uint64_t a2)
{
  sub_10003D7F0(a2, 16777221, *(_QWORD *)(a1 + 40), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
}

CFNumberRef sub_10000898C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  const __CFString *v5;
  CFNumberRef result;
  char v7;
  double valuePtr;
  timeval v9;

  v9.tv_sec = 0;
  *(_QWORD *)&v9.tv_usec = 0;
  if (gettimeofday(&v9, 0))
  {
    v5 = CFSTR("Could not get current time");
    LODWORD(result) = 0;
LABEL_3:
    sub_10001A7E4((int)result, "copy_time_since_bowie", v5, v0, v1, v2, v3, v4, v7);
    return 0;
  }
  valuePtr = (double)v9.tv_usec / 1000000.0 + (double)v9.tv_sec;
  result = CFNumberCreate(0, kCFNumberDoubleType, &valuePtr);
  if (!result)
  {
    v5 = CFSTR("Could not create CFNumber");
    goto LABEL_3;
  }
  return result;
}

uint64_t sub_100008A24(int a1, CFNumberRef number, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;
  double valuePtr;

  valuePtr = 0.0;
  if (number && CFNumberGetValue(number, kCFNumberDoubleType, &valuePtr))
  {
    TMSetSourceTime(type metadata for __ObjC, valuePtr - kCFAbsoluteTimeIntervalSince1970, 60.0);
    sub_1000110EC(CFSTR("SignificantTimeChangeNotification"));
    return 0;
  }
  else
  {
    sub_10001A7E4(0, "set_time_since_bowie", CFSTR("Failed to get number."), a4, a5, a6, a7, a8, v9);
    return 0xFFFFFFFFLL;
  }
}

CFStringRef sub_100008AB4()
{
  const __CFTimeZone *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFTimeZone *v6;
  CFStringRef Name;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFStringRef v13;
  char v15;

  CFTimeZoneResetSystem();
  v0 = CFTimeZoneCopySystem();
  if (v0)
  {
    v6 = v0;
    Name = CFTimeZoneGetName(v0);
    v13 = Name;
    if (Name)
      CFRetain(Name);
    else
      sub_10001A7E4(0, "copy_timezone", CFSTR("Could not get time zone name"), v8, v9, v10, v11, v12, v15);
    CFRelease(v6);
  }
  else
  {
    sub_10001A7E4(0, "copy_timezone", CFSTR("Could not copy system time zone"), v1, v2, v3, v4, v5, v15);
    return 0;
  }
  return v13;
}

uint64_t sub_100008B30(int a1, CFStringRef theString, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  char v11;

  if (!theString)
  {
    v9 = CFSTR("Invalid input.");
    goto LABEL_5;
  }
  if (CFStringFind(theString, CFSTR("."), 0).location != -1)
  {
    v9 = CFSTR("Timezone shenanigans.");
LABEL_5:
    sub_10001A7E4(0, "set_timezone", v9, a4, a5, a6, a7, a8, v11);
    return 0xFFFFFFFFLL;
  }
  TMSetSourceTimeZone(type metadata for __ObjC, theString);
  return 0;
}

CFBooleanRef sub_100008BB8()
{
  CFPropertyListRef v0;

  v0 = sub_100008C08(CFSTR("AppleICUForce24HourTime"), 0);
  if (!sub_100010C10(v0))
  {
    if (v0)
      CFRelease(v0);
    return kCFBooleanFalse;
  }
  return (CFBooleanRef)v0;
}

CFPropertyListRef sub_100008C08(const void *a1, const void *a2)
{
  const __CFString *v3;
  const __CFString *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;

  v3 = (const __CFString *)sub_100010BA8(a1);
  v4 = (const __CFString *)sub_100010BA8(a2);
  if (v3)
    return sub_10001AE30(v3, v4, v5, v6, v7, v8, v9, v10);
  sub_10001A7E4(0, "_copy_mobile_preference", CFSTR("bogus request"), v6, v7, v8, v9, v10, v12);
  return 0;
}

uint64_t sub_100008C68(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (a1)
  {
    sub_1000072E4(CFSTR("AppleICUForce24HourTime"), a1, kCFPreferencesAnyApplication, a4, a5, a6, a7, a8, vars0);
    sub_1000110EC(CFSTR("AppleTimePreferencesChangedNotification"));
    sub_1000110EC(CFSTR("SignificantTimeChangeNotification"));
    return 0;
  }
  else
  {
    sub_10001A7E4(0, "set_military_time", CFSTR("Invalid input."), a4, a5, a6, a7, a8, vars0);
    return 0xFFFFFFFFLL;
  }
}

CFPropertyListRef sub_100008CD0()
{
  return sub_100008C08(CFSTR("EnableTetheredDisplayPortMode"), 0);
}

CFBooleanRef sub_100008CE4()
{
  int v0;
  BOOL v1;
  const CFBooleanRef *v2;

  v0 = MKBGetDeviceLockState(0);
  v1 = (v0 - 1) < 2 || v0 == -1;
  v2 = &kCFBooleanFalse;
  if (v1)
    v2 = &kCFBooleanTrue;
  return *v2;
}

void sub_100008D24(const __CFBoolean *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFBooleanRef v7;
  char v8;

  if (sub_100010C10(a1))
  {
    if (CFEqual(a1, kCFBooleanTrue))
      v7 = a1;
    else
      v7 = kCFBooleanFalse;
    sub_1000072E4(CFSTR("EnableTetheredDisplayPortMode"), v7, kCFPreferencesAnyApplication, v2, v3, v4, v5, v6, v8);
    sub_1000110EC(CFSTR("com.apple.mobile.demo_mode_changed"));
  }
}

CFNumberRef sub_100008DA4()
{
  CFTimeZoneRef v0;
  const __CFTimeZone *v1;
  CFAbsoluteTime Current;
  CFTimeInterval valuePtr;

  valuePtr = 0.0;
  CFTimeZoneResetSystem();
  v0 = CFTimeZoneCopySystem();
  if (v0)
  {
    v1 = v0;
    Current = CFAbsoluteTimeGetCurrent();
    valuePtr = CFTimeZoneGetSecondsFromGMT(v1, Current);
    CFRelease(v1);
  }
  return CFNumberCreate(kCFAllocatorDefault, kCFNumberDoubleType, &valuePtr);
}

void sub_100008E08(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFArray *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFArray *Mutable;
  const __CFString *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;
  char v29;
  char v30;

  if (!a2)
  {
    sub_10001A7E4(0, "set_language", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
    return;
  }
  v10 = (const __CFArray *)sub_100008C08(CFSTR("AppleLanguages"), 0);
  if (sub_100010B74(v10))
  {
    sub_10001A7E4(0, "set_language", CFSTR("Pre-pending the language list with %@."), v11, v12, v13, v14, v15, (char)a2);
    Mutable = sub_100008FA4(v10, a2);
    if (!Mutable)
    {
      v22 = CFSTR("Failed to create languages list.");
      goto LABEL_14;
    }
LABEL_8:
    sub_1000072E4(CFSTR("LockdownSetLanguage"), kCFBooleanTrue, CFSTR("com.apple.purplebuddy"), v16, v17, v18, v19, v20, v29);
    sub_1000072E4(CFSTR("AppleLanguages"), Mutable, kCFPreferencesAnyApplication, v23, v24, v25, v26, v27, v30);
    sub_1000110EC(CFSTR("com.apple.language.changed"));
    sub_1000110EC(CFSTR("AppleLanguagePreferencesChangedNotification"));
    if (!v10)
      goto LABEL_10;
    goto LABEL_9;
  }
  sub_10001A7E4(0, "set_language", CFSTR("Failed to copy language list, creating new one."), v11, v12, v13, v14, v15, v28);
  Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  if (Mutable)
  {
    sub_10001A7E4(0, "set_language", CFSTR("Creating a language with with %@"), v16, v17, v18, v19, v20, (char)a2);
    CFArrayAppendValue(Mutable, a2);
    goto LABEL_8;
  }
  v22 = CFSTR("Failed to create array.");
LABEL_14:
  sub_10001A7E4(0, "set_language", v22, v16, v17, v18, v19, v20, v29);
  if (v10)
LABEL_9:
    CFRelease(v10);
LABEL_10:
  if (Mutable)
    CFRelease(Mutable);
}

const __CFArray *sub_100008FA4(const __CFArray *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFArray *MutableCopy;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFArray *v15;
  CFIndex Count;
  CFIndex v17;
  CFIndex v18;
  CFIndex v19;
  const void *ValueAtIndex;
  int v21;
  CFIndex v22;
  char v24;

  if (sub_100010B74(a1))
  {
    MutableCopy = CFArrayCreateMutableCopy(0, 0, a1);
    v15 = MutableCopy;
    if (MutableCopy)
    {
      Count = CFArrayGetCount(MutableCopy);
      if (Count >= 1)
      {
        v17 = Count;
        v18 = 0;
        v19 = Count;
        do
        {
          ValueAtIndex = CFArrayGetValueAtIndex(v15, v18);
          v21 = CFEqual(ValueAtIndex, a2);
          if (v21)
            v22 = v17;
          else
            v22 = v18;
          if (v21)
            v19 = v18;
          v18 = v22 + 1;
        }
        while (v22 + 1 < v17);
        if (v19 != v17)
          CFArrayRemoveValueAtIndex(v15, v19);
      }
      CFArrayInsertValueAtIndex(v15, 0, a2);
    }
    else
    {
      sub_10001A7E4(0, "_move_to_front", CFSTR("Could not copy array"), v10, v11, v12, v13, v14, v24);
    }
  }
  else
  {
    sub_10001A7E4(0, "_move_to_front", CFSTR("bad input"), v4, v5, v6, v7, v8, v24);
    return 0;
  }
  return v15;
}

void sub_100009098(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFNumberRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFNumberRef v15;
  char v16;
  int valuePtr;

  valuePtr = 0;
  if (a1)
  {
    if (CFEqual(a1, CFSTR("th")))
    {
      v9 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
      if (v9)
      {
        v15 = v9;
        sub_1000072E4(CFSTR("contactsSortOrder"), v9, CFSTR("com.apple.PeoplePicker"), v10, v11, v12, v13, v14, v16);
        sub_1000110EC(CFSTR("com.apple.AddressBook.PreferenceChanged"));
        CFRelease(v15);
      }
      else
      {
        sub_10001A7E4(0, "set_contact_sort_order", CFSTR("Failed to create number."), v10, v11, v12, v13, v14, v16);
      }
    }
  }
  else
  {
    sub_10001A7E4(0, "set_contact_sort_order", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100009154(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;

  if (sub_100010BA8(a1))
  {
    if (CFEqual(a1, CFSTR("ja"))
      || CFEqual(a1, CFSTR("zh-Hans"))
      || CFEqual(a1, CFSTR("zh-Hant"))
      || CFEqual(a1, CFSTR("ko")))
    {
      sub_1000072E4(CFSTR("personNameOrdering"), &__kCFBooleanTrue, CFSTR("com.apple.PeoplePicker"), v15, v16, v17, v18, v19, v20);
      sub_1000110EC(CFSTR("com.apple.AddressBook.PreferenceChanged"));
    }
  }
  else
  {
    sub_10001A7E4(0, "set_name_order", CFSTR("Invalid input."), v10, v11, v12, v13, v14, a9);
  }
}

CFTypeRef sub_100009214()
{
  const __CFArray *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFArray *v6;
  const void *ValueAtIndex;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeRef v13;
  char v15;

  v0 = (const __CFArray *)sub_100008C08(CFSTR("AppleLanguages"), 0);
  if (v0)
  {
    v6 = v0;
    ValueAtIndex = CFArrayGetValueAtIndex(v0, 0);
    if (sub_100010BA8(ValueAtIndex))
    {
      v13 = CFRetain(ValueAtIndex);
    }
    else
    {
      sub_10001A7E4(0, "copy_language", CFSTR("Failed to retrieve first language in list."), v8, v9, v10, v11, v12, v15);
      v13 = 0;
    }
    CFRelease(v6);
  }
  else
  {
    sub_10001A7E4(0, "copy_language", CFSTR("Failed to lookup %@."), v1, v2, v3, v4, v5, (char)CFSTR("AppleLanguages"));
    return 0;
  }
  return v13;
}

const __CFString *sub_1000092B8(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10;

  if (a1)
  {
    if (CFStringHasPrefix(a1, CFSTR("th_TH@")))
      return CFSTR("th_TH");
    else
      return a1;
  }
  else
  {
    sub_10001A7E4(0, "transform_locale", CFSTR("Invalid input"), a4, a5, a6, a7, a8, v10);
    return 0;
  }
}

void sub_100009310(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char vars0;
  char vars0a;

  if (a2)
  {
    sub_1000072E4(CFSTR("AppleLocale"), a2, kCFPreferencesAnyApplication, a4, a5, a6, a7, a8, vars0);
    sub_1000072E4(CFSTR("LockdownSetLocale"), kCFBooleanTrue, CFSTR("com.apple.purplebuddy"), v9, v10, v11, v12, v13, vars0a);
    sub_1000110EC(CFSTR("com.apple.mobile.lockdown.phone_number_changed"));
    sub_1000110EC(CFSTR("AppleDatePreferencesChangedNotification"));
    sub_1000110EC(CFSTR("AppleTimePreferencesChangedNotification"));
  }
  else
  {
    sub_10001A7E4(0, "set_locale", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

CFTypeRef sub_10000939C()
{
  CFPropertyListRef v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const void *v6;

  v0 = sub_100008C08(CFSTR("AppleLocale"), 0);
  v6 = v0;
  if (v0)
  {
    if (!sub_100010BA8(v0))
    {
      CFRelease(v6);
      return CFRetain(CFSTR("en_US"));
    }
  }
  else
  {
    sub_10001A7E4(0, "copy_locale", CFSTR("Failed to copy %@."), v1, v2, v3, v4, v5, (char)CFSTR("AppleLocale"));
  }
  return v6;
}

const __CFString *sub_100009420(const __CFString *a1)
{
  const __CFString *v1;

  v1 = a1;
  if (sub_100010BA8(a1) && CFStringHasPrefix(v1, CFSTR("th_TH@")))
    return CFSTR("th_TH");
  return v1;
}

void sub_100009468(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFArray *v15;
  const __CFArray *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFArray *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const __CFString *v28;
  CFMutableArrayRef Mutable;
  const __CFArray *v30;
  char v31;

  if (a2)
  {
    v15 = (const __CFArray *)sub_100008C08(CFSTR("AppleKeyboards"), 0);
    if (v15)
    {
      sub_10001A7E4(0, "set_keyboard", CFSTR("Prepending the keyboard list with %@."), v10, v11, v12, v13, v14, (char)a2);
      v16 = sub_100008FA4(v15, a2);
      if (!v16)
      {
        sub_10001A7E4(0, "set_keyboard", CFSTR("Failed to re-arrange keyboard list."), v17, v18, v19, v20, v21, v31);
        v30 = v15;
        goto LABEL_13;
      }
      v22 = v16;
      if (CFEqual(v16, v15))
        goto LABEL_10;
      goto LABEL_9;
    }
    sub_10001A7E4(0, "set_keyboard", CFSTR("Failed to copy %@."), v10, v11, v12, v13, v14, (char)CFSTR("AppleKeyboards"));
    Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    if (Mutable)
    {
      v22 = Mutable;
      sub_10001A7E4(0, "set_keyboard", CFSTR("Creating the keyboard list with %@."), a4, a5, a6, a7, a8, (char)a2);
      CFArrayAppendValue(v22, a2);
LABEL_9:
      sub_1000072E4(CFSTR("AppleKeyboards"), v22, kCFPreferencesAnyApplication, v23, v24, v25, v26, v27, v31);
      sub_1000110EC(CFSTR("AppleKeyboardsPreferencesChangedNotification"));
      if (!v15)
      {
LABEL_11:
        v30 = v22;
LABEL_13:
        CFRelease(v30);
        return;
      }
LABEL_10:
      CFRelease(v15);
      goto LABEL_11;
    }
    v28 = CFSTR("Failed to create array.");
  }
  else
  {
    v28 = CFSTR("Invalid input.");
    LODWORD(Mutable) = 0;
  }
  sub_10001A7E4((int)Mutable, "set_keyboard", v28, a4, a5, a6, a7, a8, a9);
}

const void *sub_1000095D8()
{
  const __CFArray *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFArray *v6;
  const void *ValueAtIndex;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  char v15;

  v0 = (const __CFArray *)sub_100008C08(CFSTR("AppleKeyboards"), 0);
  if (v0)
  {
    v6 = v0;
    ValueAtIndex = CFArrayGetValueAtIndex(v0, 0);
    v13 = ValueAtIndex;
    if (ValueAtIndex)
      CFRetain(ValueAtIndex);
    else
      sub_10001A7E4(0, "copy_keyboard", CFSTR("Failed to get first keyboard in the list."), v8, v9, v10, v11, v12, v15);
    CFRelease(v6);
  }
  else
  {
    sub_10001A7E4(0, "copy_keyboard", CFSTR("Failed to copy %@."), v1, v2, v3, v4, v5, (char)CFSTR("AppleKeyboards"));
    return 0;
  }
  return v13;
}

uint64_t sub_100009670()
{
  const __CFURL *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFURL *v6;
  CFBundleRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFBundle *v13;
  CFPropertyListRef v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  const __CFArray *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFArray *v27;
  const __CFArray *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFArray *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const __CFString *ValueAtIndex;
  const __CFString *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const __CFURL *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const __CFURL *v53;
  __CFReadStream *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  __CFReadStream *v60;
  CFPropertyListRef v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  CFTypeID v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char v74;

  v0 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/System/Library/PrivateFrameworks/MusicLibrary.framework"), kCFURLPOSIXPathStyle, 0);
  if (!v0)
  {
    sub_10001A7E4(0, "copy_sort_sections", CFSTR("Failed to create bundle URL for %s."), v1, v2, v3, v4, v5, (char)"/System/Library/PrivateFrameworks/MusicLibrary.framework");
    return 0;
  }
  v6 = v0;
  v7 = CFBundleCreate(kCFAllocatorDefault, v0);
  if (!v7)
  {
    sub_10001A7E4(0, "copy_sort_sections", CFSTR("Failed to create bundle for %s."), v8, v9, v10, v11, v12, (char)"/System/Library/PrivateFrameworks/MusicLibrary.framework");
    v41 = (const __CFString *)v6;
LABEL_26:
    CFRelease(v41);
    return 0;
  }
  v13 = v7;
  v14 = sub_100008C08(CFSTR("AppleLanguages"), 0);
  if (!v14)
  {
    sub_10001A7E4(0, "_copy_localization_name", CFSTR("Could not load languages list or bundle was NULL"), v15, v16, v17, v18, v19, v74);
LABEL_21:
    sub_10001A7E4(0, "copy_sort_sections", CFSTR("Failed to get localization for %s."), v42, v43, v44, v45, v46, (char)"/System/Library/PrivateFrameworks/MusicLibrary.framework");
    ValueAtIndex = 0;
    v53 = 0;
    goto LABEL_22;
  }
  v20 = v14;
  v21 = CFBundleCopyBundleLocalizations(v13);
  if (!v21)
  {
    sub_10001A7E4(0, "_copy_localization_name", CFSTR("Could not load localizations from bundle"), v22, v23, v24, v25, v26, v74);
    CFRelease(v20);
    goto LABEL_21;
  }
  v27 = v21;
  v28 = CFBundleCopyLocalizationsForPreferences(v21, (CFArrayRef)v20);
  if (v28)
  {
    v34 = v28;
    if (CFArrayGetCount(v28) <= 0)
    {
      sub_10001A7E4(0, "_copy_localization_name", CFSTR("No preferred localizations found"), v35, v36, v37, v38, v39, v74);
      ValueAtIndex = 0;
    }
    else
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v34, 0);
      CFRetain(ValueAtIndex);
    }
    CFRelease(v34);
  }
  else
  {
    sub_10001A7E4(0, "_copy_localization_name", CFSTR("Could not load preferred localizations from bundle"), v29, v30, v31, v32, v33, v74);
    ValueAtIndex = 0;
  }
  CFRelease(v27);
  CFRelease(v20);
  if (!ValueAtIndex)
    goto LABEL_21;
  v47 = CFBundleCopyResourceURLForLocalization(v13, CFSTR("MLSections"), CFSTR("plist"), 0, ValueAtIndex);
  v53 = v47;
  if (!v47)
  {
    sub_10001A7E4(0, "copy_sort_sections", CFSTR("Failed to copy bundle resource URL (%s / %s)."), v48, v49, v50, v51, v52, (char)"MLSections");
    goto LABEL_22;
  }
  v54 = CFReadStreamCreateWithFile(kCFAllocatorDefault, v47);
  if (!v54)
  {
    sub_10001A7E4(0, "copy_sort_sections", CFSTR("Failed to create read stream (%s / %s)."), v55, v56, v57, v58, v59, (char)"MLSections");
LABEL_22:
    CFRelease(v6);
    CFRelease(v13);
    if (!v53)
      goto LABEL_24;
    goto LABEL_23;
  }
  v60 = v54;
  CFReadStreamOpen(v54);
  v61 = CFPropertyListCreateWithStream(kCFAllocatorDefault, v60, 0, 0, 0, 0);
  CFReadStreamClose(v60);
  if (v61)
  {
    v67 = CFGetTypeID(v61);
    if (v67 == CFDictionaryGetTypeID())
    {
      CFRelease(v6);
      v6 = (const __CFURL *)v61;
    }
    else
    {
      sub_10001A7E4(0, "copy_sort_sections", CFSTR("Invalid property list (%s / %s)."), v68, v69, v70, v71, v72, (char)"MLSections");
      CFRelease(v61);
    }
  }
  else
  {
    sub_10001A7E4(0, "copy_sort_sections", CFSTR("Failed to load property list (%s / %s)."), v62, v63, v64, v65, v66, (char)"MLSections");
  }
  CFRelease(v6);
  CFRelease(v60);
  CFRelease(v13);
LABEL_23:
  CFRelease(v53);
LABEL_24:
  if (ValueAtIndex)
  {
    v41 = ValueAtIndex;
    goto LABEL_26;
  }
  return 0;
}

__CFDictionary *sub_1000099DC(NSObject **a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  CFDataRef v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  __CFArray *v24;
  unint64_t v25;
  _OWORD *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CFNumberRef v32;
  uint64_t *v33;
  void *v34;
  char v36;
  _QWORD v37[8];
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  _OWORD valuePtr[5];

  v46 = 0;
  v47 = &v46;
  v48 = 0x2020000000;
  v49 = 0;
  v42 = 0;
  v43 = &v42;
  v44 = 0x2020000000;
  v45 = 0;
  memset(valuePtr, 0, sizeof(valuePtr));
  v38 = 0;
  v39 = &v38;
  v40 = 0x2020000000;
  v41 = 20;
  v37[0] = _NSConcreteStackBlock;
  v37[1] = 3221225472;
  v37[2] = sub_100009CC8;
  v37[3] = &unk_100179FF8;
  v37[4] = &v46;
  v37[5] = &v42;
  v37[6] = &v38;
  v37[7] = valuePtr;
  v1 = sub_100008834(a1, v37);
  if (v1)
  {
    sub_10001A7E4(0, "load_rental_bag_request", CFSTR("Could not generate rental bag request: %ld"), v2, v3, v4, v5, v6, v1);
    goto LABEL_13;
  }
  v12 = sub_100025A4C();
  if (!v12)
  {
    sub_10001A7E4(0, "load_rental_bag_request", CFSTR("Failed to create dictionary."), v7, v8, v9, v10, v11, v36);
LABEL_13:
    v12 = 0;
    goto LABEL_18;
  }
  v18 = CFDataCreate(0, (const UInt8 *)v47[3], *((unsigned int *)v43 + 6));
  if (v18)
  {
    CFDictionarySetValue(v12, CFSTR("Message"), v18);
    v24 = sub_100025AA0();
    if (v24)
    {
      if (*((_DWORD *)v39 + 6))
      {
        v25 = 0;
        v26 = valuePtr;
        do
        {
          v32 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, v26);
          if (v32)
          {
            CFArrayAppendValue(v24, v32);
            CFRelease(v32);
          }
          else
          {
            sub_10001A7E4(0, "load_rental_bag_request", CFSTR("Failed to create number."), v27, v28, v29, v30, v31, v36);
          }
          ++v25;
          v26 = (_OWORD *)((char *)v26 + 4);
        }
        while (v25 < *((unsigned int *)v39 + 6));
      }
      CFDictionarySetValue(v12, CFSTR("DiversityElements"), v24);
    }
    else
    {
      sub_10001A7E4(0, "load_rental_bag_request", CFSTR("Failed to create array."), v19, v20, v21, v22, v23, v36);
    }
    CFRelease(v18);
    if (v24)
      CFRelease(v24);
  }
  else
  {
    sub_10001A7E4(0, "load_rental_bag_request", CFSTR("Failed to create data."), v13, v14, v15, v16, v17, v36);
  }
LABEL_18:
  v33 = v47;
  v34 = (void *)v47[3];
  if (v34)
  {
    free(v34);
    v33 = v47;
  }
  v33[3] = 0;
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
  _Block_object_dispose(&v46, 8);
  return v12;
}

void sub_100009C90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_100009CC8(_QWORD *a1, uint64_t a2)
{
  sub_10004FD30(a2, 0, 0, 0, *(_QWORD *)(a1[4] + 8) + 24, *(_QWORD *)(a1[5] + 8) + 24, a1[7], *(_QWORD *)(a1[6] + 8) + 24);
}

void sub_100009CFC(NSObject **a1)
{
  CFNumberRef v1;

  v1 = sub_100009D1C(a1);
  if (v1)
    CFRelease(v1);
}

CFNumberRef sub_100009D1C(NSObject **a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const char *v7;
  int v8;
  int v9;
  passwd *v10;
  gid_t pw_gid;
  uid_t pw_uid;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int valuePtr;

  v1 = sub_100008834(a1, &stru_10017A060);
  valuePtr = v1;
  if (v1)
  {
    sub_10001A7E4(0, "copy_rental_bag_verification", CFSTR("Response processing failed: %ld\n"), v2, v3, v4, v5, v6, v1);
    return CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  }
  v7 = "/var/mobile/Media/iTunes_Control/iTunes/IC-Info.sidr";
  v8 = sub_10002616C("/var/mobile/Media/iTunes_Control/iTunes/IC-Info.sidr", 256, 0x8000, v2, v3, v4, v5, v6);
  if (v8 == -1)
    goto LABEL_12;
  v9 = v8;
  v10 = getpwnam("mobile");
  if (v10)
  {
    pw_uid = v10->pw_uid;
    pw_gid = v10->pw_gid;
  }
  else
  {
    pw_gid = 501;
    pw_uid = 501;
  }
  if (fchown(v9, pw_uid, pw_gid) == -1)
    goto LABEL_9;
  close(v9);
  v7 = "/var/mobile/Library/FairPlay/vdpf";
  v18 = sub_10002616C("/var/mobile/Library/FairPlay/vdpf", 256, 0x8000, v13, v14, v15, v16, v17);
  if (v18 == -1)
  {
LABEL_12:
    v26 = __error();
    strerror(*v26);
    sub_10001A7E4(0, "copy_rental_bag_verification", CFSTR("hmm, symlink - that isn't right, path: %s, %s"), v27, v28, v29, v30, v31, (char)v7);
    return CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  }
  v9 = v18;
  if (fchown(v18, pw_uid, pw_gid) == -1)
  {
LABEL_9:
    v19 = __error();
    strerror(*v19);
    sub_10001A7E4(0, "copy_rental_bag_verification", CFSTR("Could not chown %s: %s"), v20, v21, v22, v23, v24, (char)v7);
  }
  close(v9);
  return CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
}

CFNumberRef sub_100009E84()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFNumberRef v5;
  char v7;
  int valuePtr;

  valuePtr = 3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (!v5)
    sub_10001A7E4(0, "copy_rental_request_version", CFSTR("Could not create number"), v0, v1, v2, v3, v4, v7);
  return v5;
}

void sub_100009EE4(NSObject **a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  size_t Length;
  void *v10;
  const UInt8 *BytePtr;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const UInt8 *v18;
  CFIndex v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFDataRef v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const __CFString *v30;
  char v31;
  _QWORD v32[8];
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;

  v37 = 0;
  v38 = &v37;
  v39 = 0x2020000000;
  v40 = 0;
  v33 = 0;
  v34 = &v33;
  v35 = 0x2020000000;
  v36 = 0;
  if (!sub_100010BDC(a2))
  {
    v30 = CFSTR("value is not CFData");
LABEL_14:
    sub_10001A7E4(0, "trigger_rental_checkin_request", v30, v4, v5, v6, v7, v8, v31);
    goto LABEL_10;
  }
  Length = CFDataGetLength((CFDataRef)a2);
  v10 = malloc_type_malloc(Length, 0xFDEC5366uLL);
  if (!v10)
  {
    v30 = CFSTR("Could not allocate a buffer for the a copy of the original message");
    goto LABEL_14;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)a2);
  memcpy(v10, BytePtr, Length);
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 3221225472;
  v32[2] = sub_10000A11C;
  v32[3] = &unk_10017A020;
  v32[6] = v10;
  v32[7] = Length;
  v32[4] = &v37;
  v32[5] = &v33;
  v12 = sub_100008834(a1, v32);
  if (v12)
  {
    sub_10001A7E4(0, "trigger_rental_checkin_request", CFSTR("Could not get response ack: %ld"), v13, v14, v15, v16, v17, v12);
  }
  else
  {
    v18 = (const UInt8 *)v38[3];
    if (v18 && (v19 = *((unsigned int *)v34 + 6), (_DWORD)v19))
    {
      v25 = CFDataCreate(kCFAllocatorDefault, v18, v19);
      if (v25)
      {
        sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.fairplay"), (uint64_t)CFSTR("RentalCheckinAckResponse"), 1, v21, v22, v23, v24);
        sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.fairplay"), (uint64_t)CFSTR("RentalCheckinAckResponse"), (uint64_t)v25, v26, v27, v28, v29);
        CFRelease(v25);
      }
      else
      {
        sub_10001A7E4(0, "trigger_rental_checkin_request", CFSTR("Could not create data from ack."), v20, v21, v22, v23, v24, v31);
      }
    }
    else
    {
      sub_10001A7E4(0, "trigger_rental_checkin_request", CFSTR("Invalid ack! Ack. Ack. Ack."), v13, v14, v15, v16, v17, v31);
    }
  }
  free(v10);
LABEL_10:
  _Block_object_dispose(&v33, 8);
  _Block_object_dispose(&v37, 8);
}

void sub_10000A0F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_10000A11C(uint64_t a1, uint64_t a2)
{
  sub_10004840C(a2, *(_QWORD *)(a1 + 48), *(unsigned int *)(a1 + 56), *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
}

int sub_10000A144(id a1, unsigned int a2)
{
  int result;

  sub_100049D90();
  return result;
}

CFNumberRef sub_10000A14C()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFString *v6;
  CFNumberRef result;
  char v8;
  int valuePtr;

  valuePtr = 0;
  sub_10004B188((uint64_t)&valuePtr);
  if (v0)
  {
    v8 = v0;
    v6 = CFSTR("Could not get necessary rental clock bias: %ld");
    LODWORD(result) = 0;
LABEL_3:
    sub_10001A7E4((int)result, "copy_rental_clock_bias", v6, v1, v2, v3, v4, v5, v8);
    return 0;
  }
  result = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (!result)
  {
    v6 = CFSTR("Could not create bias number");
    goto LABEL_3;
  }
  return result;
}

id sub_10000A1CC()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  void *v6;
  id v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *i;
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BYTE v24[128];

  v5 = objc_alloc_init((Class)NSMutableArray);
  if (v5)
  {
    v6 = (void *)MobileStorageCopyDevicesWithError(0, 0);
    v7 = v6;
    if (v6 && objc_msgSend(v6, "count"))
    {
      v22 = 0u;
      v23 = 0u;
      v20 = 0u;
      v21 = 0u;
      v7 = v7;
      v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
      if (v8)
      {
        v9 = v8;
        v10 = *(_QWORD *)v21;
        v11 = kMobileStorageDeviceTypeKey;
        v12 = kMobileStorageDeviceTypeDiskImage;
        v13 = kMobileStorageMountPathKey;
        do
        {
          for (i = 0; i != v9; i = (char *)i + 1)
          {
            if (*(_QWORD *)v21 != v10)
              objc_enumerationMutation(v7);
            v15 = *(void **)(*((_QWORD *)&v20 + 1) + 8 * (_QWORD)i);
            v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v11, (_QWORD)v20));
            if (objc_msgSend(v16, "isEqualToString:", v12))
            {
              v17 = objc_claimAutoreleasedReturnValue(objc_msgSend(v15, "objectForKeyedSubscript:", v13));
              if (v17)
              {
                v18 = (void *)v17;
                objc_msgSend(v5, "addObject:", v17);

              }
            }

          }
          v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v20, v24, 16);
        }
        while (v9);
      }

    }
  }
  else
  {
    sub_10001A7E4(0, "copy_disk_image_mount_points", CFSTR("Failed to allocate array."), v0, v1, v2, v3, v4, v20);
    v7 = 0;
  }

  return v5;
}

void sub_10000A384(uint64_t a1, dispatch_queue_t *a2, void *a3, _BYTE *a4)
{
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  id v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  FTS *v25;
  FTS *v26;
  void *v27;
  void *v28;
  void *v29;
  FTSENT *v30;
  FTSENT *v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t fixed;
  const __CFString *v45;
  id v46;
  int *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  stat v61;
  char __str[1024];
  char *v63;
  uint64_t v64;

  memset(&v61, 0, sizeof(v61));
  v64 = 0;
  v63 = 0;
  v7 = a3;
  bzero(__str, 0x400uLL);
  v60 = 0;
  sub_10001A7E4(0, "load_agents_for_mount", CFSTR("Loading images for mount %@."), v8, v9, v10, v11, v12, (char)v7);
  if (a4)
    *a4 = 0;
  v13 = objc_retainAutorelease(v7);
  if (snprintf(__str, 0x400uLL, "%s%s", (const char *)objc_msgSend(v13, "UTF8String"), "/Library/Lockdown/ServiceAgents") >= 0x400)
  {
    v14 = objc_msgSend(objc_retainAutorelease(v13), "UTF8String");
    sub_10001A7E4(0, "load_agents_for_mount", CFSTR("Path too long: %s%s"), v15, v16, v17, v18, v19, v14);
LABEL_30:
    v29 = 0;
    v28 = 0;
    v27 = 0;
    goto LABEL_31;
  }
  if (lstat(__str, &v61) == -1)
  {
    if (*__error() != 2)
    {
      __error();
      v47 = __error();
      strerror(*v47);
      sub_10001A7E4(0, "load_agents_for_mount", CFSTR("Failed to stat %s: %d (%s)"), v48, v49, v50, v51, v52, (char)__str);
    }
    goto LABEL_30;
  }
  if ((v61.st_mode & 0xF000) != 0x4000)
  {
    sub_10001A7E4(0, "load_agents_for_mount", CFSTR("%s is not a directory, ignoring"), v20, v21, v22, v23, v24, (char)__str);
    goto LABEL_30;
  }
  v63 = __str;
  v64 = 0;
  v25 = fts_open(&v63, 21, 0);
  if (!v25)
  {
    v53 = *__error();
    v54 = __error();
    strerror(*v54);
    sub_10001A7E4(0, "load_agents_for_mount", CFSTR("fts_open failed: %d (%s)"), v55, v56, v57, v58, v59, v53);
    goto LABEL_30;
  }
  v26 = v25;
  v27 = 0;
  v28 = 0;
  v29 = 0;
  while (1)
  {
    v30 = fts_read(v26);
    if (!v30)
      break;
    v31 = v30;
    if (v30->fts_info == 8 && !strncmp(&v30->fts_name[v30->fts_namelen - 6], ".plist", 6uLL))
    {
      v32 = (void *)sub_100025818(v31->fts_path);

      if (v32)
      {
        v38 = objc_claimAutoreleasedReturnValue(objc_msgSend(v32, "objectForKeyedSubscript:", CFSTR("Label")));

        v29 = (void *)v38;
        if (v38)
        {
          fixed = MobileStorageCopyAndFixPlist(v32, v13);
          v27 = (void *)objc_claimAutoreleasedReturnValue(fixed);

          if (!v27)
          {
            v32 = 0;
            v45 = CFSTR("Failed to copy/fix %s.");
            goto LABEL_18;
          }
          v46 = objc_msgSend(v27, "mutableCopy");

          if ((objc_msgSend(v13, "isEqualToString:", CFSTR("/Developer")) & 1) != 0
            || objc_msgSend(v13, "isEqualToString:", CFSTR("/System/Developer")))
          {
            objc_msgSend(v46, "setObject:forKeyedSubscript:", &__kCFBooleanTrue, CFSTR("DeveloperModeRequired"));
          }
          sub_10001A4C4(a2, a1, v29, (uint64_t)v46, &v60);
          v28 = v46;
          if (a4)
          {
            v28 = v46;
            if (v60)
            {
              *a4 = 1;
              v28 = v46;
            }
          }
        }
        else
        {
          v45 = CFSTR("%s did not contain a label.");
LABEL_18:
          sub_10001A7E4(0, "load_agents_for_mount", v45, v39, v40, v41, v42, v43, (char)v31->fts_path);
          v27 = v32;
        }
      }
      else
      {
        sub_10001A7E4(0, "load_agents_for_mount", CFSTR("Failed to load %s."), v33, v34, v35, v36, v37, (char)v31->fts_path);
        v27 = 0;
      }
    }
  }
  fts_close(v26);
LABEL_31:

}

const __CFString *sub_10000A74C(const __CFString *a1)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  ether_addr *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFStringRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  CFStringRef v19;
  CFTypeRef v20;
  int *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v28;
  char v29;
  u_char v30;
  u_char v31;
  __int16 v32;
  u_char v33;
  u_char v34;
  u_char v35;
  char cStr[16];
  _WORD v37[15];
  char buffer[20];

  v1 = (char)a1;
  v28 = 0;
  *(_OWORD *)cStr = 0u;
  memset(v37, 0, sizeof(v37));
  if (!CFStringGetCString(a1, buffer, 20, 0x8000100u))
  {
    sub_10001A7E4(0, "createV6Address", CFSTR("Failed to query C string for %@."), v2, v3, v4, v5, v6, v1);
    return CFSTR("0.0.0.0");
  }
  v7 = ether_aton(buffer);
  if (!v7)
  {
    sub_10001A7E4(0, "createV6Address", CFSTR("ether_aton failed for %@."), v8, v9, v10, v11, v12, v1);
    return CFSTR("0.0.0.0");
  }
  LOWORD(v28) = -32514;
  v29 = v7->octet[0] ^ 2;
  v30 = v7->octet[1];
  v31 = v7->octet[2];
  v32 = -257;
  v33 = v7->octet[3];
  v34 = v7->octet[4];
  v35 = v7->octet[5];
  if (!inet_ntop(30, &v28, cStr, 0x2Eu))
  {
    __error();
    v21 = __error();
    strerror(*v21);
    sub_10001A7E4(0, "createV6Address", CFSTR("inet_ntop failed for %@: %d (%s)"), v22, v23, v24, v25, v26, v1);
    return CFSTR("0.0.0.0");
  }
  v13 = CFStringCreateWithCString(0, cStr, 0x8000100u);
  if (!v13)
  {
    sub_10001A7E4(0, "createV6Address", CFSTR("Failed to create string for %s."), v14, v15, v16, v17, v18, (char)cStr);
    return CFSTR("0.0.0.0");
  }
  v19 = v13;
  v20 = CFRetain(v13);
  CFRelease(v19);
  return (const __CFString *)v20;
}

void sub_10000A8E8(NSObject **a1)
{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *v11;
  const void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t CurrentWireProtocolVersion;
  uint64_t v19;
  const __CFString *v20;
  const __CFString *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFString *v27;
  __CFString *v28;
  const __CFString *v29;
  const __CFString *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFString *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const __CFString *MutableCopy;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  char v68;
  char v69;
  uint64_t v70;
  uint64_t v71;
  char domain[16];
  uint64_t v73;
  char regtype[23];
  char buffer[64];
  char fullName[1009];
  CFRange v77;

  strcpy(regtype, "_apple-mobdev2._tcp");
  *(_OWORD *)domain = *(_OWORD *)"local";
  LODWORD(v73) = 0;
  v2 = (const void *)sub_10000ED98((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("SupportsWifi"));
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("SupportsWifiSyncing"), 1, v3, v4, v5, v6);
  if (!sub_100010C10(v2) || !CFEqual(v2, kCFBooleanTrue))
  {
    sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("SupportsWifiSyncing"), (uint64_t)kCFBooleanFalse, v7, v8, v9, v10);
    v11 = 0;
LABEL_11:
    v28 = 0;
    v29 = 0;
    v30 = 0;
    goto LABEL_12;
  }
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("SupportsWifiSyncing"), (uint64_t)kCFBooleanTrue, v7, v8, v9, v10);
  v11 = (const __CFString *)sub_10000ED98((uint64_t)a1, 0, (uint64_t)CFSTR("WiFiAddress"));
  v12 = sub_100010BA8(v11);
  if (!v12)
  {
    v27 = CFSTR("Missing Wifi MAC Address.");
LABEL_10:
    sub_10001A7E4((int)v12, "intialize_wifi_syncing", v27, v13, v14, v15, v16, v17, v68);
    goto LABEL_11;
  }
  CurrentWireProtocolVersion = RemotePairingGetCurrentWireProtocolVersion();
  if (CurrentWireProtocolVersion < 0)
  {
    v27 = CFSTR("Failed to read RemotePairing protocol version.");
    LODWORD(v12) = 0;
    goto LABEL_10;
  }
  v19 = CurrentWireProtocolVersion;
  v20 = sub_10000A74C(v11);
  if (remotePairingIsEnabled())
    v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@@%@-%@-%ld"), v11, v20, CFSTR("supportsRP"), v19, *(_QWORD *)domain, *(_QWORD *)&domain[8], v73);
  else
    v21 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@@%@"), v11, v20, v70, v71, *(_QWORD *)domain, *(_QWORD *)&domain[8], v73);
  v30 = v21;
  if (!v21)
  {
    v39 = CFSTR("Failed to create v6 address string.");
    goto LABEL_30;
  }
  if (!CFStringGetCString(v21, buffer, 64, 0x8000100u))
  {
    v39 = CFSTR("Failed to create v6 address C string.");
    goto LABEL_30;
  }
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("InstanceName"), 1, v23, v24, v25, v26);
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("InstanceName"), 2, v31, v32, v33, v34);
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("InstanceName"), (uint64_t)v30, v35, v36, v37, v38);
  if (DNSServiceConstructFullName(fullName, buffer, regtype, domain))
  {
    v39 = CFSTR("Failed to construct DNS full service name.");
LABEL_30:
    sub_10001A7E4(0, "intialize_wifi_syncing", v39, v22, v23, v24, v25, v26, v69);
    v29 = 0;
    goto LABEL_31;
  }
  v29 = CFStringCreateWithCString(kCFAllocatorDefault, fullName, 0x8000100u);
  if (v29)
  {
    MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, v29);
    v28 = (__CFString *)MutableCopy;
    if (MutableCopy)
    {
      v77.length = CFStringGetLength(MutableCopy);
      v77.location = 0;
      CFStringFindAndReplace(v28, CFSTR("\\"), &stru_1001856C8, v77, 0);
      sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("BonjourFullServiceName"), 1, v51, v52, v53, v54);
      sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("BonjourFullServiceName"), 0, v55, v56, v57, v58);
      sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("BonjourFullServiceName"), (uint64_t)v28, v59, v60, v61, v62);
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "intialize_wifi_syncing", CFSTR("Full service name is '%@'."), v63, v64, v65, v66, v67, (char)v28);
    }
    else
    {
      sub_10001A7E4(0, "intialize_wifi_syncing", CFSTR("Failed to copy DNS full service name string."), v46, v47, v48, v49, v50, v69);
    }
    goto LABEL_32;
  }
  sub_10001A7E4(0, "intialize_wifi_syncing", CFSTR("Failed to create DNS full service name string."), v40, v41, v42, v43, v44, v69);
LABEL_31:
  v28 = 0;
LABEL_32:
  if (v20)
    CFRelease(v20);
LABEL_12:
  if (v2)
    CFRelease(v2);
  if (v11)
    CFRelease(v11);
  if (v30)
    CFRelease(v30);
  if (v29)
    CFRelease(v29);
  if (v28)
    CFRelease(v28);
}

CFBooleanRef sub_10000AD04()
{
  CFBooleanRef v0;
  const __SCPreferences *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __SCPreferences *v7;
  const __CFDictionary *Value;
  const __CFNumber *v9;
  char v11;
  int valuePtr;

  v0 = kCFBooleanFalse;
  v1 = SCPreferencesCreate(0, CFSTR("racoon"), CFSTR("com.apple.ipsec.plist"));
  if (v1)
  {
    v7 = v1;
    valuePtr = 0;
    Value = (const __CFDictionary *)SCPreferencesGetValue(v1, CFSTR("Global"));
    if (sub_100010B40(Value))
    {
      v9 = (const __CFNumber *)CFDictionaryGetValue(Value, CFSTR("DebugLevel"));
      if (sub_100010B0C(v9))
      {
        CFNumberGetValue(v9, kCFNumberIntType, &valuePtr);
        if (valuePtr)
          v0 = kCFBooleanTrue;
      }
    }
    CFRelease(v7);
  }
  else
  {
    sub_10001A7E4(0, "copy_vpn_logging", CFSTR("Could not create configd prefs"), v2, v3, v4, v5, v6, v11);
  }
  return v0;
}

void sub_10000ADDC(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __SCPreferences *v15;
  const __SCPreferences *v16;
  CFPropertyListRef Value;
  const __CFDictionary *v18;
  CFMutableDictionaryRef MutableCopy;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  CFNumberRef v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  CFNumberRef v31;
  const __CFString *v32;
  const __CFString *v33;
  int v34;
  char v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  int valuePtr;

  valuePtr = 0;
  if (!sub_100010C10(a1))
  {
    v33 = CFSTR("Invalid input");
LABEL_12:
    sub_10001A7E4(0, "enable_vpn_logging", v33, v10, v11, v12, v13, v14, a9);
    return;
  }
  v15 = SCPreferencesCreate(0, CFSTR("racoon"), CFSTR("com.apple.ipsec.plist"));
  if (!v15)
  {
    v33 = CFSTR("SCPreferencesCreate failed.");
    goto LABEL_12;
  }
  v16 = v15;
  Value = SCPreferencesGetValue(v15, CFSTR("Global"));
  v18 = (const __CFDictionary *)sub_100010B40(Value);
  if (v18 && (MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v18)) != 0
    || (MutableCopy = sub_100025A4C()) != 0)
  {
    valuePtr = 2 * (CFEqual(a1, kCFBooleanTrue) != 0);
    v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (!v25)
    {
      sub_10001A7E4(0, "enable_vpn_logging", CFSTR("Could not create debug level number"), v26, v27, v28, v29, v30, v41);
LABEL_18:
      CFRelease(MutableCopy);
      goto LABEL_19;
    }
    v31 = v25;
    CFDictionarySetValue(MutableCopy, CFSTR("DebugLevel"), v25);
    CFDictionarySetValue(MutableCopy, CFSTR("DebugLogfile"), CFSTR("/var/log/racoon.log"));
    SCPreferencesSetValue(v16, CFSTR("Global"), MutableCopy);
    if (SCPreferencesCommitChanges(v16))
    {
      if (SCPreferencesApplyChanges(v16))
      {
LABEL_17:
        CFRelease(v31);
        goto LABEL_18;
      }
      v32 = CFSTR("SCPreferencesApplyChanges: %s");
    }
    else
    {
      v32 = CFSTR("SCPreferencesCommitChanges: %s");
    }
    v34 = SCError();
    v35 = SCErrorString(v34);
    sub_10001A7E4(0, "enable_vpn_logging", v32, v36, v37, v38, v39, v40, v35);
    goto LABEL_17;
  }
  sub_10001A7E4(0, "enable_vpn_logging", CFSTR("Failed to create dictionary."), v20, v21, v22, v23, v24, v41);
LABEL_19:
  CFRelease(v16);
}

void sub_10000AFBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remove_vpn_logs", CFSTR("Removing %s"), a4, a5, a6, a7, a8, (char)"/var/log/racoon.log");
  if (unlink("/var/log/racoon.log") == -1)
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "remove_vpn_logs", CFSTR("Could not unlink %s: %s"), v9, v10, v11, v12, v13, (char)"/var/log/racoon.log");
  }
}

CFBooleanRef sub_10000B050()
{
  CFBooleanRef v0;
  const __SCPreferences *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __SCPreferences *v7;
  CFPropertyListRef Value;
  char v10;

  v0 = kCFBooleanFalse;
  v1 = SCPreferencesCreate(0, CFSTR("eapolclient"), CFSTR("com.apple.eapolclient.plist"));
  if (v1)
  {
    v7 = v1;
    Value = SCPreferencesGetValue(v1, CFSTR("LogFlags"));
    if (sub_100010B0C(Value))
      v0 = kCFBooleanTrue;
    CFRelease(v7);
  }
  else
  {
    sub_10001A7E4(0, "copy_8021X_logging", CFSTR("Could not create configd prefs"), v2, v3, v4, v5, v6, v10);
  }
  return v0;
}

void sub_10000B0DC(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  SCPreferencesRef v15;
  const __SCPreferences *v16;
  CFNumberRef v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFNumberRef v23;
  const __CFString *v24;
  int v25;
  char v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  char v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char v39;
  int valuePtr;

  if (!sub_100010C10(a1))
  {
    v24 = CFSTR("tried to enable logging without a BOOLean");
LABEL_8:
    sub_10001A7E4(0, "enable_8021X_logging", v24, v10, v11, v12, v13, v14, a9);
    return;
  }
  v15 = SCPreferencesCreate(0, CFSTR("eapolclient"), CFSTR("com.apple.eapolclient.plist"));
  if (!v15)
  {
    v24 = CFSTR("Could not create configd prefs");
    goto LABEL_8;
  }
  v16 = v15;
  valuePtr = 0;
  if (CFEqual(a1, kCFBooleanTrue))
  {
    valuePtr = -1;
    v17 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (v17)
    {
      v23 = v17;
      SCPreferencesSetValue(v16, CFSTR("LogFlags"), v17);
      CFRelease(v23);
    }
    else
    {
      sub_10001A7E4(0, "enable_8021X_logging", CFSTR("Could not create dflags number"), v18, v19, v20, v21, v22, v39);
    }
  }
  else
  {
    SCPreferencesRemoveValue(v16, CFSTR("LogFlags"));
  }
  if (!SCPreferencesCommitChanges(v16))
  {
    v25 = SCError();
    v26 = SCErrorString(v25);
    sub_10001A7E4(0, "enable_8021X_logging", CFSTR("SCPreferencesCommitChanges: %s"), v27, v28, v29, v30, v31, v26);
  }
  if (!SCPreferencesApplyChanges(v16))
  {
    v32 = SCError();
    v33 = SCErrorString(v32);
    sub_10001A7E4(0, "enable_8021X_logging", CFSTR("SCPreferencesApplyChanges: %s"), v34, v35, v36, v37, v38, v33);
  }
  CFRelease(v16);
}

void sub_10000B250(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remove_8021X_logs", CFSTR("Removing %s"), a4, a5, a6, a7, a8, (char)"/var/log/eapolclient.en0.log");
  if (unlink("/var/log/eapolclient.en0.log") == -1)
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "remove_8021X_logs", CFSTR("Could not unlink %s: %s"), v9, v10, v11, v12, v13, (char)"/var/log/eapolclient.en0.log");
  }
}

CFTypeRef sub_10000B2E4()
{
  CFBooleanRef v0;
  const __SCPreferences *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __SCPreferences *v7;
  const __CFBoolean *Value;
  char v10;

  v0 = kCFBooleanFalse;
  v1 = SCPreferencesCreate(0, CFSTR("OSThermalStatus"), CFSTR("OSThermalStatus.plist"));
  if (v1)
  {
    v7 = v1;
    Value = (const __CFBoolean *)SCPreferencesGetValue(v1, CFSTR("OSThermalNotificationLoggingEnabled"));
    if (Value)
      v0 = Value;
    CFRelease(v7);
  }
  else
  {
    sub_10001A7E4(0, "copy_CLTM_logging", CFSTR("Could not create configd prefs"), v2, v3, v4, v5, v6, v10);
  }
  return CFRetain(v0);
}

void sub_10000B360(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __SCPreferences *v15;
  const __SCPreferences *v16;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFString *v31;

  if (!sub_100010C10(a1))
  {
    v31 = CFSTR("Bad value");
LABEL_10:
    sub_10001A7E4(0, "enable_CLTM_logging", v31, v10, v11, v12, v13, v14, a9);
    return;
  }
  v15 = SCPreferencesCreate(0, CFSTR("OSThermalStatus"), CFSTR("OSThermalStatus.plist"));
  if (!v15)
  {
    v31 = CFSTR("Could not create configd prefs");
    goto LABEL_10;
  }
  v16 = v15;
  SCPreferencesSetValue(v15, CFSTR("logFile"), CFSTR("/var/logs/cltm.log"));
  SCPreferencesSetValue(v16, CFSTR("OSThermalNotificationLoggingEnabled"), a1);
  if (!SCPreferencesCommitChanges(v16))
  {
    v17 = SCError();
    v18 = SCErrorString(v17);
    sub_10001A7E4(0, "enable_CLTM_logging", CFSTR("SCPreferencesCommitChanges: %s"), v19, v20, v21, v22, v23, v18);
  }
  if (!SCPreferencesApplyChanges(v16))
  {
    v24 = SCError();
    v25 = SCErrorString(v24);
    sub_10001A7E4(0, "enable_CLTM_logging", CFSTR("SCPreferencesApplyChanges: %s"), v26, v27, v28, v29, v30, v25);
  }
  CFRelease(v16);
}

void sub_10000B46C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remove_CLTM_logs", CFSTR("Removing %s"), a4, a5, a6, a7, a8, (char)"/var/logs/cltm.log");
  if (unlink("/var/logs/cltm.log") == -1)
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "remove_CLTM_logs", CFSTR("Could not unlink %s: %s"), v9, v10, v11, v12, v13, (char)"/var/logs/cltm.log");
  }
}

void sub_10000B500(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __SCPreferences *v15;
  const __SCPreferences *v16;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFString *v31;

  if (!sub_100010C10(a1))
  {
    v31 = CFSTR("Bad value");
LABEL_10:
    sub_10001A7E4(0, "enable_CLTM_TGraph_logging", v31, v10, v11, v12, v13, v14, a9);
    return;
  }
  v15 = SCPreferencesCreate(0, CFSTR("OSThermalStatus"), CFSTR("OSThermalStatus.plist"));
  if (!v15)
  {
    v31 = CFSTR("Could not create configd prefs");
    goto LABEL_10;
  }
  v16 = v15;
  SCPreferencesSetValue(v15, CFSTR("tGraphLogFile"), CFSTR("/var/logs/tGraph.csv"));
  SCPreferencesSetValue(v16, CFSTR("OSThermalNotificationLoggingEnabled"), a1);
  if (!SCPreferencesCommitChanges(v16))
  {
    v17 = SCError();
    v18 = SCErrorString(v17);
    sub_10001A7E4(0, "enable_CLTM_TGraph_logging", CFSTR("SCPreferencesCommitChanges: %s"), v19, v20, v21, v22, v23, v18);
  }
  if (!SCPreferencesApplyChanges(v16))
  {
    v24 = SCError();
    v25 = SCErrorString(v24);
    sub_10001A7E4(0, "enable_CLTM_TGraph_logging", CFSTR("SCPreferencesApplyChanges: %s"), v26, v27, v28, v29, v30, v25);
  }
  CFRelease(v16);
}

void sub_10000B60C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remove_CLTM_TGraph_logs", CFSTR("Removing %s"), a4, a5, a6, a7, a8, (char)"/var/logs/tGraph.csv");
  if (unlink("/var/logs/tGraph.csv") == -1)
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "remove_CLTM_TGraph_logs", CFSTR("Could not unlink %s: %s"), v9, v10, v11, v12, v13, (char)"/var/logs/tGraph.csv");
  }
}

void sub_10000B6A0(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __SCPreferences *v15;
  const __SCPreferences *v16;
  int v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFString *v31;

  if (!sub_100010C10(a1))
  {
    v31 = CFSTR("Bad value");
LABEL_10:
    sub_10001A7E4(0, "enable_CLTM_Thermstat_logging", v31, v10, v11, v12, v13, v14, a9);
    return;
  }
  v15 = SCPreferencesCreate(0, CFSTR("OSThermalStatus"), CFSTR("OSThermalStatus.plist"));
  if (!v15)
  {
    v31 = CFSTR("Could not create configd prefs");
    goto LABEL_10;
  }
  v16 = v15;
  SCPreferencesSetValue(v15, CFSTR("ThermStatsEnabled"), a1);
  if (!SCPreferencesCommitChanges(v16))
  {
    v17 = SCError();
    v18 = SCErrorString(v17);
    sub_10001A7E4(0, "enable_CLTM_Thermstat_logging", CFSTR("SCPreferencesCommitChanges: %s"), v19, v20, v21, v22, v23, v18);
  }
  if (!SCPreferencesApplyChanges(v16))
  {
    v24 = SCError();
    v25 = SCErrorString(v24);
    sub_10001A7E4(0, "enable_CLTM_Thermstat_logging", CFSTR("SCPreferencesApplyChanges: %s"), v26, v27, v28, v29, v30, v25);
  }
  CFRelease(v16);
}

void sub_10000B794(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remove_CLTM_Thermstat_logs", CFSTR("Removing %s"), a4, a5, a6, a7, a8, (char)"/Library/Logs/CrashReporter/*.thermstats");
  if (unlink("/Library/Logs/CrashReporter/*.thermstats") == -1)
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "remove_CLTM_Thermstat_logs", CFSTR("Could not unlink %s: %s"), v9, v10, v11, v12, v13, (char)"/Library/Logs/CrashReporter/*.thermstats");
  }
}

void sub_10000B828(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  uint64_t v16;
  const void *v17;

  if (sub_100010C10(a1))
  {
    v15 = CFSTR("Value is not a CFBoolean");
    LODWORD(v16) = 0;
LABEL_3:
    sub_10001A7E4(v16, "enable_wifimanager_logging", v15, v10, v11, v12, v13, v14, a9);
    return;
  }
  v16 = WiFiManagerClientCreate(kCFAllocatorDefault, 0);
  if (!v16)
  {
    v15 = CFSTR("Couldn't create WiFiManager client");
    goto LABEL_3;
  }
  v17 = (const void *)v16;
  WiFiManagerClientSetProperty(v16, kWiFiLoggingFileKey, CFSTR("/var/log/wifimanager.log"));
  WiFiManagerClientSetProperty(v17, kWiFiLoggingFileEnabledKey, a1);
  CFRelease(v17);
}

void sub_10000B8D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remove_wifimanager_logs", CFSTR("Removing %s"), a4, a5, a6, a7, a8, (char)"/var/log/wifimanager.log");
  if (unlink("/var/log/wifimanager.log") == -1)
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "remove_wifimanager_logs", CFSTR("Could not unlink %s: %s"), v9, v10, v11, v12, v13, (char)"/var/log/wifimanager.log");
  }
}

void sub_10000B964(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;

  if (sub_100010C10(a1))
  {
    v15 = CFSTR("Value is not a CFBoolean");
LABEL_3:
    sub_10001A7E4(0, "enable_lockdown_disk_logging", v15, v10, v11, v12, v13, v14, a9);
    return;
  }
  if (CFEqual(a1, kCFBooleanTrue))
  {
    dword_1001A6AD8 = 1;
    sub_10001A7E4(0, "enable_lockdown_disk_logging", CFSTR("Enabling the log to disk preference"), v16, v17, v18, v19, v20, v26);
  }
  else if (CFEqual(a1, kCFBooleanFalse))
  {
    sub_10001A7E4(0, "enable_lockdown_disk_logging", CFSTR("Disabling the log to disk preference"), v21, v22, v23, v24, v25, v26);
    dword_1001A6AD8 = 0;
  }
  CFPreferencesSetValue(CFSTR("LogToDisk"), a1, CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  if (!CFPreferencesSynchronize(CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost))
  {
    v15 = CFSTR("Could not synchronize preferences");
    goto LABEL_3;
  }
}

CFPropertyListRef sub_10000BA98()
{
  return CFPreferencesCopyValue(CFSTR("LogToDisk"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
}

void sub_10000BACC(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFTypeID v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  const __CFString *v22;
  const __CFString *v23;
  char v24;

  v10 = CFGetTypeID(a1);
  if (v10 != CFBooleanGetTypeID())
  {
    v23 = CFSTR("Value is not a CFBoolean");
    goto LABEL_10;
  }
  if (CFEqual(a1, kCFBooleanTrue))
  {
    v21 = 1;
    v22 = CFSTR("Enabling the extended logging preference");
LABEL_7:
    sub_10001A7E4(0, "enable_lockdown_extended_logging", v22, v16, v17, v18, v19, v20, v24);
    dword_1001A6AD0 = v21;
    goto LABEL_8;
  }
  if (CFEqual(a1, kCFBooleanFalse))
  {
    v21 = 0;
    v22 = CFSTR("Disabling the extended logging preference");
    goto LABEL_7;
  }
LABEL_8:
  CFPreferencesSetValue(CFSTR("ExtendedLogging"), a1, CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  if (CFPreferencesSynchronize(CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost))
  {
    return;
  }
  v23 = CFSTR("Could not synchronize preferences");
LABEL_10:
  sub_10001A7E4(0, "enable_lockdown_extended_logging", v23, v11, v12, v13, v14, v15, a9);
}

void sub_10000BBF4(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFTypeID v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFString *v26;
  const __CFString *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  char v32;

  v11 = CFGetTypeID(a1);
  if (v11 != CFBooleanGetTypeID())
  {
    v27 = CFSTR("Value is not a CFBoolean");
    goto LABEL_10;
  }
  if (CFEqual(a1, kCFBooleanTrue))
  {
    dword_1001A6AD4 = 1;
    sub_10000E484(a2, 0, (uint64_t)CFSTR("UseRaptorCerts"), (uint64_t)a1, v17, v18, v19, v20);
    v26 = CFSTR("Enabling the raptor certs");
LABEL_7:
    sub_10001A7E4(0, "enable_raptor_certs", v26, v21, v22, v23, v24, v25, v32);
    goto LABEL_8;
  }
  if (CFEqual(a1, kCFBooleanFalse))
  {
    sub_10000E484(a2, 0, (uint64_t)CFSTR("UseRaptorCerts"), (uint64_t)a1, v28, v29, v30, v31);
    dword_1001A6AD4 = 0;
    v26 = CFSTR("Disabling the raptor certs");
    goto LABEL_7;
  }
LABEL_8:
  CFPreferencesSetValue(CFSTR("RaptorCertsPref"), a1, CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  if (CFPreferencesSynchronize(CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost))
  {
    return;
  }
  v27 = CFSTR("Could not synchronize preferences");
LABEL_10:
  sub_10001A7E4(0, "enable_raptor_certs", v27, v12, v13, v14, v15, v16, a9);
}

CFPropertyListRef sub_10000BD60()
{
  return CFPreferencesCopyValue(CFSTR("ExtendedLogging"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
}

CFPropertyListRef sub_10000BD94()
{
  return CFPreferencesCopyValue(CFSTR("RaptorCertsPref"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
}

void *sub_10000BDC8()
{
  void *v0;
  CFPropertyListRef v1;
  const void *v2;
  CFTypeID v3;
  CFTypeID v4;
  int valuePtr;

  v0 = kCFBooleanFalse;
  v1 = sub_100008C08(CFSTR("stream_trace"), CFSTR("com.apple.coremedia"));
  if (v1)
  {
    v2 = v1;
    v3 = CFGetTypeID(v1);
    if (v3 == CFBooleanGetTypeID())
    {
      v0 = (void *)CFRetain(v2);
    }
    else
    {
      v4 = CFGetTypeID(v2);
      if (v4 == CFNumberGetTypeID())
      {
        valuePtr = 0;
        if (CFNumberGetValue((CFNumberRef)v2, kCFNumberIntType, &valuePtr))
          v0 = kCFBooleanTrue;
      }
    }
    CFRelease(v2);
  }
  return v0;
}

CFDataRef sub_10000BE88()
{
  __CFDictionary *Mutable;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __CFDictionary *v6;
  char v7;
  char v8;
  OSStatus v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  OSStatus v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  CFDataRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v30;
  char v31;
  CFTypeRef result;

  result = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v6 = Mutable;
    CFDictionaryAddValue(Mutable, kSecClass, kSecClassKey);
    CFDictionaryAddValue(v6, kSecReturnRef, kCFBooleanTrue);
    CFDictionaryAddValue(v6, kSecAttrAccessGroup, CFSTR("lockdown-identities"));
    CFDictionaryAddValue(v6, kSecAttrLabel, CFSTR("com.apple.lockdown.pairingkeypair"));
    CFDictionaryAddValue(v6, kSecUseSystemKeychain, kCFBooleanTrue);
    v7 = 1;
    while (1)
    {
      v8 = v7;
      v9 = SecItemCopyMatching(v6, &result);
      if (!v9)
        break;
      v15 = v9;
      sub_10001A7E4(0, "copy_pairing_private_key", CFSTR("Failed to retrieve private key from keychain: %d"), v10, v11, v12, v13, v14, v9);
      if (v15 != -25291)
      {
        sub_100012D98(1, v16, v17, v18, v19, v20, v21, v22, v31);
        v7 = 0;
        if ((v8 & 1) != 0)
          continue;
      }
      v23 = 0;
      goto LABEL_10;
    }
    v23 = sub_10000F9D4((uint64_t)result, "RSA PRIVATE KEY");
    if (!v23)
      sub_10001A7E4(0, "copy_pairing_private_key", CFSTR("Failed to create PEM from private key data."), v24, v25, v26, v27, v28, v30);
LABEL_10:
    CFRelease(v6);
    if (result)
      CFRelease(result);
  }
  else
  {
    sub_10001A7E4(0, "copy_pairing_private_key", CFSTR("Failed to create dictionary."), v1, v2, v3, v4, v5, v30);
    return 0;
  }
  return v23;
}

CFDataRef sub_10000C03C()
{
  __CFDictionary *Mutable;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  __CFDictionary *v6;
  char v7;
  char v8;
  OSStatus v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  OSStatus v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  SecKeyRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  SecKeyRef v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  CFDataRef v35;
  char v37;
  char v38;
  CFTypeRef result;

  result = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v6 = Mutable;
    CFDictionaryAddValue(Mutable, kSecClass, kSecClassKey);
    CFDictionaryAddValue(v6, kSecReturnRef, kCFBooleanTrue);
    CFDictionaryAddValue(v6, kSecAttrAccessGroup, CFSTR("lockdown-identities"));
    CFDictionaryAddValue(v6, kSecAttrLabel, CFSTR("com.apple.lockdown.pairingkeypair"));
    CFDictionaryAddValue(v6, kSecUseSystemKeychain, kCFBooleanTrue);
    v7 = 1;
    while (1)
    {
      v8 = v7;
      v9 = SecItemCopyMatching(v6, &result);
      if (!v9)
        break;
      v15 = v9;
      sub_10001A7E4(0, "copy_pairing_public_key", CFSTR("Failed to retrieve private key from keychain: %d"), v10, v11, v12, v13, v14, v9);
      if (v15 != -25291)
      {
        sub_100012D98(1, v16, v17, v18, v19, v20, v21, v22, v38);
        v7 = 0;
        if ((v8 & 1) != 0)
          continue;
      }
      goto LABEL_13;
    }
    v23 = SecKeyCopyPublicKey((SecKeyRef)result);
    if (!v23)
    {
      sub_10001A7E4(0, "copy_pairing_public_key", CFSTR("Failed to retrieve public key."), v24, v25, v26, v27, v28, v37);
LABEL_13:
      CFRelease(v6);
      goto LABEL_14;
    }
    v29 = v23;
    v35 = sub_10000F9D4((uint64_t)v23, "RSA PUBLIC KEY");
    if (!v35)
      sub_10001A7E4(0, "copy_pairing_public_key", CFSTR("Failed to create PEM from public key data."), v30, v31, v32, v33, v34, v37);
    CFRelease(v6);
    CFRelease(v29);
  }
  else
  {
    sub_10001A7E4(0, "copy_pairing_public_key", CFSTR("Failed to create dictionary."), v1, v2, v3, v4, v5, v37);
LABEL_14:
    v35 = 0;
  }
  if (result)
    CFRelease(result);
  return v35;
}

uint64_t sub_10000C220(_QWORD *a1, unint64_t a2, CFDataRef *a3)
{
  __SecIdentity *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFDataRef v24;
  const __CFString *v25;
  CFDataRef v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CFDataRef v32;
  CFDataRef v33;
  void *v34;
  SecKeyRef v35;
  uint64_t v36;
  SecKeyRef v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  CFDataRef v48;
  char v50;
  CFDataRef v51;
  id v52;
  SecCertificateRef certificateRef;
  SecKeyRef privateKeyRef;
  SecCertificateRef v55;

  certificateRef = 0;
  privateKeyRef = 0;
  v52 = 0;
  v6 = (__SecIdentity *)MAECopyLegacyDeviceIdentityWithError(&v52);
  v7 = v52;
  v13 = v7;
  if (!v6)
  {
    sub_10001A7E4(0, "copy_keys_and_certs", CFSTR("Failed to load legacy device identity: %@"), v8, v9, v10, v11, v12, (char)v7);
LABEL_26:
    v32 = 0;
    v24 = 0;
LABEL_35:
    v33 = 0;
    v48 = 0;
    v34 = 0;
    v35 = 0;
    v36 = 0xFFFFFFFFLL;
    goto LABEL_40;
  }
  if (!a1)
  {
    v24 = 0;
    goto LABEL_8;
  }
  SecIdentityCopyPrivateKey(v6, &privateKeyRef);
  if (!privateKeyRef)
  {
    sub_10001A7E4(0, "copy_keys_and_certs", CFSTR("Failed to copy private key."), v14, v15, v16, v17, v18, v50);
    goto LABEL_26;
  }
  v24 = sub_10000F9D4((uint64_t)privateKeyRef, "RSA PRIVATE KEY");
  if (!v24)
  {
    v25 = CFSTR("Failed to create pem data for private key.");
LABEL_34:
    sub_10001A7E4(0, "copy_keys_and_certs", v25, v19, v20, v21, v22, v23, v50);
    v32 = 0;
    goto LABEL_35;
  }
LABEL_8:
  if (!(a2 | (unint64_t)a3))
  {
    v32 = 0;
    v33 = 0;
    v51 = 0;
    goto LABEL_15;
  }
  SecIdentityCopyCertificate(v6, &certificateRef);
  if (!certificateRef)
  {
    v25 = CFSTR("Failed to copy certificate from device identity.");
    goto LABEL_34;
  }
  if (!a3)
  {
    v32 = 0;
    v51 = 0;
LABEL_29:
    if (a2)
    {
      v55 = certificateRef;
      v34 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v55, 1));
      v37 = sub_100010050(v34);
      v35 = v37;
      if (!v37)
      {
        sub_10001A7E4(0, "copy_keys_and_certs", CFSTR("Failed to extract public key from certificate chain."), v38, v39, v40, v41, v42, v50);
        v33 = 0;
        goto LABEL_38;
      }
      v33 = sub_10000F9D4((uint64_t)v37, "RSA PUBLIC KEY");
      if (!v33)
      {
        sub_10001A7E4(0, "copy_keys_and_certs", CFSTR("Failed to create pem data for public key."), v43, v44, v45, v46, v47, v50);
        goto LABEL_38;
      }
LABEL_16:
      if (a1 && v24)
        *a1 = v24;
      if (a2 && v33)
        *(_QWORD *)a2 = v33;
      v36 = 0;
      if (a3 && v32)
      {
        v32 = v32;
        v36 = 0;
        *a3 = v32;
      }
      goto LABEL_39;
    }
    v33 = 0;
LABEL_15:
    v34 = 0;
    v35 = 0;
    goto LABEL_16;
  }
  v26 = SecCertificateCopyData(certificateRef);
  if (!v26)
  {
    v25 = CFSTR("Failed to copy certificate data.");
    goto LABEL_34;
  }
  v51 = v26;
  v32 = sub_10000FA38(v26, "CERTIFICATE");
  if (v32)
    goto LABEL_29;
  sub_10001A7E4(0, "copy_keys_and_certs", CFSTR("Failed to create pem data for certificate."), v27, v28, v29, v30, v31, v50);
  v33 = 0;
  v34 = 0;
  v35 = 0;
LABEL_38:
  v36 = 0xFFFFFFFFLL;
LABEL_39:
  v48 = v51;
LABEL_40:
  if (certificateRef)
    CFRelease(certificateRef);
  certificateRef = 0;
  if (privateKeyRef)
    CFRelease(privateKeyRef);
  privateKeyRef = 0;
  if (v35)
    CFRelease(v35);
  if (v6)
    CFRelease(v6);

  return v36;
}

uint64_t sub_10000C520()
{
  uint64_t result;
  uint64_t v1;

  v1 = 0;
  sub_10000C220(0, (unint64_t)&v1, 0);
  result = v1;
  if (!v1)
  {
    sub_1000110EC(CFSTR("com.apple.mobile.lockdown.requestreactivation"));
    return v1;
  }
  return result;
}

uint64_t sub_10000C568()
{
  uint64_t result;
  uint64_t v1;

  v1 = 0;
  sub_10000C220(&v1, 0, 0);
  result = v1;
  if (!v1)
  {
    sub_1000110EC(CFSTR("com.apple.mobile.lockdown.requestreactivation"));
    return v1;
  }
  return result;
}

CFDataRef sub_10000C5B0()
{
  CFDataRef result;
  CFDataRef v1;

  v1 = 0;
  sub_10000C220(0, 0, &v1);
  result = v1;
  if (!v1)
  {
    sub_1000110EC(CFSTR("com.apple.mobile.lockdown.requestreactivation"));
    return v1;
  }
  return result;
}

void sub_10000C5F8(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFTypeID v10;
  int v11;
  int *v12;
  int *v13;
  CFNumberRef v14;
  CFNumberRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFNumberRef v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  char v73;
  char v74;
  char v75;
  char v76;
  char v77;
  char v78;
  char v79;
  char v80;
  char v81;
  char v82;
  char v83;
  int v84;
  int v85;
  int v86;

  if (!a1 || (v10 = CFGetTypeID(a1), v10 != CFBooleanGetTypeID()))
  {
    sub_10001A7E4(0, "enable_media_stream_logging", CFSTR("Value is not a CFBoolean"), a4, a5, a6, a7, a8, a9);
    return;
  }
  v85 = 0;
  v86 = 1;
  v84 = 2;
  v11 = CFEqual(a1, kCFBooleanTrue);
  if (v11)
    v12 = &v86;
  else
    v12 = &v85;
  if (v11)
    v13 = &v84;
  else
    v13 = &v85;
  v14 = CFNumberCreate(0, kCFNumberIntType, v12);
  v15 = CFNumberCreate(0, kCFNumberIntType, v13);
  v21 = v15;
  if (v14)
    v22 = v15 == 0;
  else
    v22 = 1;
  if (v22)
  {
    sub_10001A7E4(0, "enable_media_stream_logging", CFSTR("Weird- couldn't create a number"), v16, v17, v18, v19, v20, v73);
    if (!v14)
    {
      if (!v21)
        return;
      goto LABEL_16;
    }
  }
  else
  {
    sub_1000072E4(CFSTR("stream_trace"), v14, CFSTR("com.apple.coremedia"), v16, v17, v18, v19, v20, v73);
    sub_1000072E4(CFSTR("fhttpchunk_alt_trace"), v14, CFSTR("com.apple.coremedia"), v23, v24, v25, v26, v27, v74);
    sub_1000072E4(CFSTR("fhttpchunk_trace"), v14, CFSTR("com.apple.coremedia"), v28, v29, v30, v31, v32, v75);
    sub_1000072E4(CFSTR("fp_trace"), v14, CFSTR("com.apple.coremedia"), v33, v34, v35, v36, v37, v76);
    sub_1000072E4(CFSTR("crabs_trace"), v14, CFSTR("com.apple.coremedia"), v38, v39, v40, v41, v42, v77);
    sub_1000072E4(CFSTR("playmon_trace"), v21, CFSTR("com.apple.coremedia"), v43, v44, v45, v46, v47, v78);
    sub_1000072E4(CFSTR("FormatReaderLoaderTrace"), v14, CFSTR("com.apple.coremedia"), v48, v49, v50, v51, v52, v79);
    sub_1000072E4(CFSTR("DiskCacheRepository"), v14, CFSTR("com.apple.coremedia"), v53, v54, v55, v56, v57, v80);
    sub_1000072E4(CFSTR("faq_trace"), v14, CFSTR("com.apple.coremedia"), v58, v59, v60, v61, v62, v81);
    sub_1000072E4(CFSTR("boss_trace"), v14, CFSTR("com.apple.coremedia"), v63, v64, v65, v66, v67, v82);
    sub_1000072E4(CFSTR("videomentor_trace"), v14, CFSTR("com.apple.coremedia"), v68, v69, v70, v71, v72, v83);
  }
  CFRelease(v14);
  if (!v21)
    return;
LABEL_16:
  CFRelease(v21);
}

void sub_10000C7EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remove_lockdown_logs", CFSTR("Removing %s"), a4, a5, a6, a7, a8, (char)"/private/var/logs/lockdownd.log");
  if (unlink("/private/var/logs/lockdownd.log") == -1)
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "remove_lockdown_logs", CFSTR("Could not unlink %s: %s"), v9, v10, v11, v12, v13, (char)"/private/var/logs/lockdownd.log");
  }
}

CFMutableDictionaryRef sub_10000C880()
{
  kern_return_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  const __CFString *v6;
  io_registry_entry_t v8;
  io_object_t v9;
  kern_return_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  char v17;
  mach_port_t mainPort;
  CFMutableDictionaryRef properties;

  properties = 0;
  mainPort = 0;
  v0 = IOMasterPort(bootstrap_port, &mainPort);
  if (v0)
  {
    v17 = v0;
    v6 = CFSTR("Could not get master port %d");
LABEL_3:
    sub_10001A7E4(0, "copy_nvram_info", v6, v1, v2, v3, v4, v5, v17);
    return 0;
  }
  v8 = IORegistryEntryFromPath(mainPort, "IODeviceTree:/options");
  if (!v8)
  {
    v6 = CFSTR("Could not find NVRAM via IOKit");
    goto LABEL_3;
  }
  v9 = v8;
  v10 = IORegistryEntryCreateCFProperties(v8, &properties, kCFAllocatorDefault, 0);
  if (v10)
    v16 = properties == 0;
  else
    v16 = 0;
  if (v16)
    sub_10001A7E4(0, "copy_nvram_info", CFSTR("Could not load NVRAM info (%d)"), v11, v12, v13, v14, v15, v10);
  IOObjectRelease(v9);
  return properties;
}

uint64_t sub_10000C960()
{
  id v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  dispatch_semaphore_t v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  char v27;
  _QWORD v28[7];
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t (*v32)(uint64_t, uint64_t);
  void (*v33)(uint64_t);
  id v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t (*v38)(uint64_t, uint64_t);
  void (*v39)(uint64_t);
  id v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t (*v44)(uint64_t, uint64_t);
  void (*v45)(uint64_t);
  id v46;
  char v47;

  v41 = 0;
  v42 = &v41;
  v43 = 0x3032000000;
  v44 = sub_10000CBFC;
  v45 = sub_10000CC0C;
  v46 = 0;
  v35 = 0;
  v36 = &v35;
  v37 = 0x3032000000;
  v38 = sub_10000CBFC;
  v39 = sub_10000CC0C;
  v40 = 0;
  v29 = 0;
  v30 = &v29;
  v31 = 0x3032000000;
  v32 = sub_10000CBFC;
  v33 = sub_10000CC0C;
  v34 = 0;
  v0 = objc_alloc_init((Class)CoreTelephonyClient);
  v1 = (void *)v36[5];
  v36[5] = (uint64_t)v0;

  if (!v36[5])
  {
    v25 = CFSTR("Failed to create a CoreTelephonyClient");
LABEL_10:
    sub_10001A7E4(0, "copy_carrier_bundle_info", v25, v2, v3, v4, v5, v6, v27);
    goto LABEL_11;
  }
  v7 = dispatch_semaphore_create(0);
  v8 = (void *)v30[5];
  v30[5] = (uint64_t)v7;

  if (!v30[5])
  {
    v25 = CFSTR("Failed to create a semaphore");
    goto LABEL_10;
  }
  v9 = (void *)v36[5];
  v28[0] = _NSConcreteStackBlock;
  v28[1] = 3221225472;
  v28[2] = sub_10000CC14;
  v28[3] = &unk_10017A0B0;
  v28[4] = &v35;
  v28[5] = &v41;
  v28[6] = &v29;
  objc_msgSend(v9, "getSubscriptionInfo:", v28);
  dispatch_semaphore_wait((dispatch_semaphore_t)v30[5], 0xFFFFFFFFFFFFFFFFLL);
  v10 = (void *)v42[5];
  if (!v10)
  {
    v25 = CFSTR("Failed to query bundle location");
    goto LABEL_10;
  }
  v11 = objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "stringByAppendingString:", CFSTR("/Info.plist")));
  v12 = (void *)v42[5];
  v42[5] = v11;

  v18 = (void *)v42[5];
  if (!v18)
  {
    sub_10001A7E4(0, "copy_carrier_bundle_info", CFSTR("Failed to append /Info.plist to %@"), v13, v14, v15, v16, v17, 0);
    v24 = 0;
    goto LABEL_12;
  }
  v24 = sub_100025818(objc_msgSend(objc_retainAutorelease(v18), "UTF8String"));
  if (!v24)
  {
    sub_10001A7E4(0, "copy_carrier_bundle_info", CFSTR("Could not load %s"), v19, v20, v21, v22, v23, (char)&v47);
LABEL_11:
    v24 = 0;
  }
LABEL_12:
  _Block_object_dispose(&v29, 8);

  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(&v41, 8);

  return v24;
}

void sub_10000CBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10000CBFC(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10000CC0C(uint64_t a1)
{

}

void sub_10000CC14(_QWORD *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  dispatch_semaphore_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  void *v26;
  char v27;
  _QWORD v28[6];
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t (*v36)(uint64_t, uint64_t);
  void (*v37)(uint64_t);
  id v38;
  _BYTE v39[128];

  v5 = a2;
  v6 = a3;
  v12 = v6;
  v33 = 0;
  v34 = &v33;
  v35 = 0x3032000000;
  v36 = sub_10000CBFC;
  v37 = sub_10000CC0C;
  v38 = 0;
  if (!v5 || v6)
  {
    sub_10001A7E4(0, "copy_carrier_bundle_info_block_invoke", CFSTR("Error while getting subscription information for carrier bundle: %@"), v7, v8, v9, v10, v11, (char)v6);
  }
  else
  {
    v13 = dispatch_semaphore_create(0);
    v14 = (void *)v34[5];
    v34[5] = (uint64_t)v13;

    if (v34[5])
    {
      v31 = 0u;
      v32 = 0u;
      v29 = 0u;
      v30 = 0u;
      v20 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "subscriptions"));
      v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v29, v39, 16);
      if (v21)
      {
        v22 = *(_QWORD *)v30;
LABEL_6:
        v23 = 0;
        while (1)
        {
          if (*(_QWORD *)v30 != v22)
            objc_enumerationMutation(v20);
          v24 = *(void **)(*((_QWORD *)&v29 + 1) + 8 * v23);
          if (objc_msgSend(v24, "slotID"))
          {
            v25 = a1[5];
            v26 = *(void **)(*(_QWORD *)(a1[4] + 8) + 40);
            v28[0] = _NSConcreteStackBlock;
            v28[1] = 3221225472;
            v28[2] = sub_10000CEA0;
            v28[3] = &unk_10017A088;
            v28[4] = v25;
            v28[5] = &v33;
            objc_msgSend(v26, "copyCarrierBundleLocation:completion:", v24, v28);
            dispatch_semaphore_wait((dispatch_semaphore_t)v34[5], 0xFFFFFFFFFFFFFFFFLL);
            if (*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 40))
              break;
          }
          if (v21 == (id)++v23)
          {
            v21 = objc_msgSend(v20, "countByEnumeratingWithState:objects:count:", &v29, v39, 16);
            if (v21)
              goto LABEL_6;
            break;
          }
        }
      }

      v12 = 0;
    }
    else
    {
      sub_10001A7E4(0, "copy_carrier_bundle_info_block_invoke", CFSTR("Failed to create semaphore"), v15, v16, v17, v18, v19, v27);
    }
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(a1[6] + 8) + 40));
  _Block_object_dispose(&v33, 8);

}

void sub_10000CE74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_10000CEA0(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;
  uint64_t v11;
  void *v12;
  id v13;

  v13 = a2;
  if (!v13 || a3)
    sub_10001A7E4(0, "copy_carrier_bundle_info_block_invoke_2", CFSTR("Could not get the carrier bundle info file path: %@"), v5, v6, v7, v8, v9, a3);
  v10 = objc_msgSend(v13, "copy");
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v12 = *(void **)(v11 + 40);
  *(_QWORD *)(v11 + 40) = v10;

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));
}

uint64_t sub_10000CF24(int a1)
{
  const __CFString *v1;

  if (!a1)
  {
    v1 = CFSTR("IntegratedCircuitCardIdentifier");
    return MGCopyAnswer(v1, 0);
  }
  if (a1 == 1)
  {
    v1 = CFSTR("lHMDJnC58naUz2rOCJyVIw");
    return MGCopyAnswer(v1, 0);
  }
  return 0;
}

__CFString *sub_10000CF54()
{
  __CFString **v0;
  int *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  statfs v9;

  if (sub_10002606C("/Developer"))
  {
    v0 = off_10017B790;
    return *v0;
  }
  memset(&v9, 0, 512);
  if (!statfs("/Developer", &v9))
  {
    if (*(_QWORD *)v9.f_mntonname == 0x706F6C657665442FLL && *(_QWORD *)&v9.f_mntonname[3] == 0x7265706F6C6576)
      v0 = off_10017B788;
    else
      v0 = off_10017B798;
    return *v0;
  }
  v2 = __error();
  strerror(*v2);
  sub_10001A7E4(0, "check_dev_tools_available", CFSTR("Can't stat %s: %s"), v3, v4, v5, v6, v7, (char)"/Developer");
  return 0;
}

const __CFString *sub_10000D094(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v8;
  const __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  const __CFString *v16;
  const __CFLocale *v17;
  const __CFLocale *v18;
  const __CFString *Value;
  __CFString *MutableCopy;
  __CFString *v21;
  uint64_t v22;
  const __CFString *v23;
  CFIndex Length;
  const __CFString *v25;
  char v27;

  if (a1)
  {
    if (a1 != 1)
    {
      sub_10001A7E4(0, "copy_phonenumber", CFSTR("Invalid slotID: %d"), a4, a5, a6, a7, a8, a1);
      return 0;
    }
    v8 = CFSTR("SZy8T5ma/+a0wJc0ntiaaA");
  }
  else
  {
    v8 = CFSTR("PhoneNumber");
  }
  v9 = (const __CFString *)MGCopyAnswer(v8, 0);
  if (!sub_100010BA8(v9))
  {
    if (!v9)
    {
      sub_10001A7E4(0, "copy_phonenumber", CFSTR("CTSettingCopyMyPhoneNumber() returned NULL"), v10, v11, v12, v13, v14, v27);
      return v9;
    }
    v27 = (char)v9;
    v25 = CFSTR("CTSettingCopyMyPhoneNumber() returned non-string: %@, but we're returning NULL anyway");
    LODWORD(Length) = 0;
    goto LABEL_20;
  }
  v15 = (const __CFString *)sub_10000939C();
  if (v15)
  {
    v16 = v15;
    v17 = CFLocaleCreate(0, v15);
    if (v17)
    {
      v18 = v17;
      Value = (const __CFString *)CFLocaleGetValue(v17, kCFLocaleCountryCode);
      if (Value)
      {
        MutableCopy = CFStringCreateMutableCopy(0, 0, Value);
        if (MutableCopy)
        {
          v21 = MutableCopy;
          CFStringLowercase(MutableCopy, v18);
          v22 = PNCreateFormattedStringWithCountry(v9, v21, 1, 0);
          if (v22)
          {
            v23 = (const __CFString *)v22;
            CFRelease(v9);
            v9 = v23;
          }
          CFRelease(v21);
        }
      }
      CFRelease(v18);
    }
    CFRelease(v16);
  }
  Length = CFStringGetLength(v9);
  if (!Length)
  {
    v25 = CFSTR("CTSettingCopyMyPhoneNumber() returned an empty phone number - returning NULL");
LABEL_20:
    sub_10001A7E4(Length, "copy_phonenumber", v25, v10, v11, v12, v13, v14, v27);
    CFRelease(v9);
    return 0;
  }
  return v9;
}

uint64_t sub_10000D210()
{
  return MGCopyAnswer(CFSTR("SIMStatus"), 0);
}

void sub_10000D220(const __CFBoolean *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  CFBooleanRef v9;

  if (a1)
  {
    if (kCFBooleanTrue == a1)
      v9 = kCFBooleanTrue;
    else
      v9 = kCFBooleanFalse;
    sub_1000072E4(CFSTR("FileSharingEnabled"), v9, kCFPreferencesAnyApplication, a4, a5, a6, a7, a8, a9);
  }
  else
  {
    sub_10001A7E4(0, "set_file_sharing", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

CFBooleanRef sub_10000D278()
{
  CFBooleanRef result;

  result = (CFBooleanRef)sub_100008C08(CFSTR("FileSharingEnabled"), 0);
  if (!result)
    return kCFBooleanTrue;
  return result;
}

CFBooleanRef sub_10000D2B0()
{
  CFPropertyListRef v0;

  v0 = sub_100008C08(CFSTR("HDHealthInUse"), CFSTR("com.apple.healthd"));
  if (!sub_100010C10(v0))
  {
    if (v0)
      CFRelease(v0);
    return kCFBooleanFalse;
  }
  return (CFBooleanRef)v0;
}

CFBooleanRef sub_10000D304()
{
  CFBooleanRef v0;
  const __CFDictionary *v1;

  v0 = kCFBooleanFalse;
  v1 = IOServiceMatching("AppleUSBDeviceAudioDevice");
  if (v1 && IOServiceGetMatchingService(kIOMasterPortDefault, v1))
    return kCFBooleanTrue;
  return v0;
}

CFBooleanRef sub_10000D364()
{
  unsigned int v0;
  const CFBooleanRef *v1;

  v0 = sub_100004540();
  v1 = &kCFBooleanTrue;
  if (!v0)
    v1 = &kCFBooleanFalse;
  return *v1;
}

CFBooleanRef sub_10000D394()
{
  unsigned int v0;
  const CFBooleanRef *v1;

  v0 = sub_10000457C();
  v1 = &kCFBooleanTrue;
  if (!v0)
    v1 = &kCFBooleanFalse;
  return *v1;
}

__CFDictionary *sub_10000D3C4()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __CFDictionary *updated;
  CFTypeRef cf;

  cf = 0;
  updated = ramrod_update_copy_deviceinfo(0, (CFErrorRef *)&cf);
  if (!updated)
    sub_10001A7E4(0, "copy_ramrod_preflight_info", CFSTR("Failed to get the preflight info: %@"), v0, v1, v2, v3, v4, (char)cf);
  if (cf)
    CFRelease(cf);
  return updated;
}

CFDictionaryRef sub_10000D428()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFDictionaryRef updated;

  updated = ramrod_update_copy_ap_parameters_generating_nonces(0);
  if (!updated)
    sub_10001A7E4(0, "copy_ramrod_ap_parameters", CFSTR("Failed to get ap parameters: %@"), v0, v1, v2, v3, v4, 0);
  return updated;
}

uint64_t sub_10000D48C(unint64_t a1)
{
  unsigned int v2;
  uint64_t v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (qword_1001A7F88 && sub_10000D5BC((void *)qword_1001A7F88, a1))
    return 1;
  v2 = MKBGetDeviceLockState(0);
  if (v2 <= 3 && v2 != 1)
    return 1;
  v4 = BiomeLibrary();
  v5 = (void *)objc_claimAutoreleasedReturnValue(v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "Device"));
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "KeybagLocked"));
  v8 = (void *)objc_claimAutoreleasedReturnValue(+[BMPublisherOptions reversed](BMPublisherOptions, "reversed"));
  v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "publisherWithOptions:", v8));
  v10 = objc_msgSend(v9, "sinkWithCompletion:shouldContinue:", &stru_10017A0F0, &stru_10017A130);

  if (qword_1001A7F88)
  {
    if (sub_10000D5BC((void *)qword_1001A7F88, a1))
      return 1;
    v16 = qword_1001A7F88;
  }
  else
  {
    v16 = 0;
  }
  sub_10001A7E4(0, "hasDeviceBeenUnlockedWithinNumberOfHours", CFSTR("Device last unlocked at %@, which is not within the last %llu hours."), v11, v12, v13, v14, v15, v16);
  return 0;
}

BOOL sub_10000D5BC(void *a1, unint64_t a2)
{
  id v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  void *v8;
  _BOOL8 v9;

  v3 = a1;
  v4 = (void *)objc_claimAutoreleasedReturnValue(+[NSDate date](NSDate, "date"));
  if (v4)
  {
    v5 = objc_msgSend(objc_alloc((Class)NSCalendar), "initWithCalendarIdentifier:", NSCalendarIdentifierGregorian);
    v6 = v5;
    if (v5
      && (v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "components:fromDate:toDate:options:", 32, v3, v4, 0))) != 0)
    {
      v8 = v7;
      v9 = (unint64_t)objc_msgSend(v7, "hour") < a2;

    }
    else
    {
      v9 = 0;
    }
  }
  else
  {
    v9 = 0;
    v6 = 0;
  }

  return v9;
}

void sub_10000D684(id a1, BPSCompletion *a2)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BPSCompletion *v9;

  v9 = a2;
  v2 = (void *)objc_claimAutoreleasedReturnValue(-[BPSCompletion error](v9, "error"));

  if (v2)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(-[BPSCompletion error](v9, "error"));
    sub_10001A7E4(0, "hasDeviceBeenUnlockedWithinNumberOfHours_block_invoke", CFSTR("Failed to subscribe for \"KeybagLocked\" events: %@"), v4, v5, v6, v7, v8, (char)v3);

  }
}

BOOL sub_10000D6F4(id a1, BMStoreEvent *a2)
{
  BMStoreEvent *v2;
  void *v3;
  unsigned __int8 v4;
  id v5;
  id v6;
  void *v7;

  v2 = a2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(-[BMStoreEvent eventBody](v2, "eventBody"));
  v4 = objc_msgSend(v3, "starting");

  if ((v4 & 1) == 0)
  {
    v5 = objc_alloc((Class)NSDate);
    -[BMStoreEvent timestamp](v2, "timestamp");
    v6 = objc_msgSend(v5, "initWithTimeIntervalSinceReferenceDate:");
    v7 = (void *)qword_1001A7F88;
    qword_1001A7F88 = (uint64_t)v6;

  }
  return v4;
}

uint64_t sub_10000D770()
{
  return sub_10000D48C(0x18uLL);
}

id sub_10000D778(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v8;
  char v10;

  if (a1)
  {
    v8 = objc_retainAutorelease(objc_msgSend(objc_alloc((Class)NSMutableData), "initWithLength:", a1));
    arc4random_buf(objc_msgSend(v8, "bytes"), (size_t)objc_msgSend(v8, "length"));
  }
  else
  {
    sub_10001A7E4(0, "createRandomData", CFSTR("Invalid input."), a4, a5, a6, a7, a8, v10);
    return 0;
  }
  return v8;
}

BOOL sub_10000D7F0()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  size_t v7;
  uint64_t v8;

  v8 = 0;
  v7 = 8;
  if (!sysctlbyname("security.mac.amfi.developer_mode_status", &v8, &v7, 0, 0))
    return v8 == 1;
  v0 = __error();
  sub_10001A7E4(0, "isDeveloperModeEnabled", CFSTR("Failed to read developer mode status: %{darwin.errno}d"), v1, v2, v3, v4, v5, *v0);
  return 0;
}

void sub_10000D86C(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.lockdownd.nandinfo", 0);
  v2 = (void *)qword_1001A7F90;
  qword_1001A7F90 = (uint64_t)v1;

}

CFDataRef sub_10000D898(uint64_t a1)
{
  CFDataRef result;

  result = gather_nand_info();
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

CFNumberRef sub_10000D8C4(uint64_t a1)
{
  uint64_t valuePtr;

  valuePtr = sub_10000D8F8(*(const char **)(a1 + 32));
  return CFNumberCreate(0, kCFNumberSInt64Type, &valuePtr);
}

uint64_t sub_10000D8F8(const char *a1)
{
  DIR *v2;
  DIR *v3;
  dirent *v4;
  uint64_t i;
  const char *d_name;
  size_t v7;
  uint64_t v8;
  size_t v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v2 = opendir(a1);
  if (!v2)
    return 0;
  v3 = v2;
  v4 = readdir(v2);
  for (i = 0; v4; v4 = readdir(v3))
  {
    d_name = v4->d_name;
    if (strcmp(v4->d_name, ".") && strcmp(d_name, ".."))
    {
      v16 = 0;
      v17 = 0;
      v18 = 0;
      v14 = 0;
      v15 = 0;
      v7 = strlen(a1);
      v8 = 0;
      v9 = v7 + strlen(d_name) + 2;
      if (v9 <= 0x400)
      {
        v10 = (char *)malloc_type_malloc(v9, 0xDB498916uLL);
        if (v10)
        {
          v11 = v10;
          v12 = &strcpy(v10, a1)[v7];
          *v12 = 47;
          strcpy(v12 + 1, d_name);
          v17 = 0;
          v15 = 0;
          v14 = 0;
          v16 = 0x800000005;
          v18 = 4;
          v8 = 0;
          if (!getattrlist(v11, &v16, &v14, 0x10uLL, 1u))
          {
            if (HIDWORD(v14) == 2)
              v8 = sub_10000D8F8(v11);
            else
              v8 = v15;
          }
          free(v11);
        }
        else
        {
          v8 = 0;
        }
      }
      i += v8;
    }
  }
  closedir(v3);
  return i;
}

void sub_10000DA84(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.lockdownd.usage", 0);
  v2 = (void *)qword_1001A7FA0;
  qword_1001A7FA0 = (uint64_t)v1;

}

void sub_10000DAB0(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFMutableDictionaryRef v13;
  void *v14;
  uint64_t v15;
  void *v16;
  _QWORD v17[6];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;

  v7 = objc_autoreleasePoolPush();
  v22 = 0;
  v23 = &v22;
  v24 = 0x2020000000;
  v25 = 0;
  v18 = 0;
  v19 = &v18;
  v20 = 0x2020000000;
  v21 = 0;
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "calculate_application_usage_block_invoke", CFSTR("Calculating application disk usage."), v2, v3, v4, v5, v6, v17[0]);
  if (byte_1001A7F70 == 1)
  {
    v13 = sub_10000F4E0(*(_QWORD *)(a1 + 40), CFSTR("com.apple.disk_usage"), CFSTR("MobileApplicationUsage"), v2, v3, v4, v5, v6);
  }
  else
  {
    v14 = (void *)objc_claimAutoreleasedReturnValue(+[LSApplicationWorkspace defaultWorkspace](LSApplicationWorkspace, "defaultWorkspace"));
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10000DC60;
    v17[3] = &unk_10017A1C0;
    v17[4] = &v18;
    v17[5] = &v22;
    objc_msgSend(v14, "enumerateApplicationsOfType:block:", 0, v17);

    v13 = (CFMutableDictionaryRef)(v19[3] + v23[3]);
  }
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "calculate_application_usage_block_invoke", CFSTR("Completed calculating application usage."), v8, v9, v10, v11, v12, v17[0]);
  sub_100007FF8(*(_QWORD *)(a1 + 40), (uint64_t)v13);
  v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v16 = *(void **)(v15 + 40);
  *(_QWORD *)(v15 + 40) = 0;

  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  objc_autoreleasePoolPop(v7);
}

void sub_10000DC3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  uint64_t v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_10000DC60(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v8 = a2;
  if (v8)
  {
    v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v8, "diskUsage"));
    if (v3)
    {
      v4 = v3;
      v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "dynamicUsage"));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += objc_msgSend(v5, "longLongValue");

      v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "onDemandResourcesUsage"));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) += objc_msgSend(v6, "longLongValue");

      v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v4, "staticUsage"));
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += objc_msgSend(v7, "longLongValue");

    }
  }

}

void sub_10000DD40(id a1)
{
  const __CFData *v1;
  const __CFData *v2;
  const UInt8 *BytePtr;
  char *v4;
  uint64_t v5;
  char *v6;
  int v7;

  v1 = (const __CFData *)MGCopyAnswer(CFSTR("WifiAddressData"), 0);
  if (v1)
  {
    v2 = v1;
    BytePtr = CFDataGetBytePtr(v1);
    v4 = (char *)malloc_type_malloc(0x60uLL, 0x469C542FuLL);
    v5 = 0;
    qword_1001A7FB8 = (uint64_t)v4;
    do
    {
      v6 = &v4[v5];
      v7 = *(_DWORD *)BytePtr;
      *((_WORD *)v6 + 2) = *((_WORD *)BytePtr + 2);
      *(_DWORD *)v6 = v7;
      v5 += 6;
    }
    while (v5 != 96);
    CFRelease(v2);
  }
}

void sub_10000DDC4(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.lockdown.power.assertion", 0);
  v2 = (void *)qword_1001A7FC8;
  qword_1001A7FC8 = (uint64_t)v1;

}

uint64_t sub_10000DDF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "_takePowerAssertionForInterval_block_invoke_2", CFSTR("Releasing power assertion."), a4, a5, a6, a7, a8, v10);
  return IOPMAssertionRelease(*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
}

void *sub_10000DE40()
{
  void *v0;
  void *Mutable;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString *v13;
  const void *v14;
  char v16;
  char __str[1024];
  char v18[1024];

  bzero(v18, 0x400uLL);
  bzero(__str, 0x400uLL);
  v0 = malloc_type_calloc(1uLL, 0xA8uLL, 0x10A0040973172F9uLL);
  if (v0)
  {
    Mutable = dispatch_queue_create("com.apple.mobile.lockdown.dark", 0);
    *(_QWORD *)v0 = Mutable;
    if (Mutable
      && (Mutable = dispatch_queue_create("com.apple.mobile.lockdown.dark.block", 0),
          (*((_QWORD *)v0 + 1) = Mutable) != 0))
    {
      sub_10000816C(v18);
      snprintf(__str, 0x400uLL, "%s%s", v18, "/Library/Lockdown/data_ark.plist");
      v7 = sub_100025818(__str);
      *((_QWORD *)v0 + 3) = v7;
      if (v7)
        return v0;
      sub_10001A7E4(0, "data_ark_load", CFSTR("Failed to load %s."), v8, v9, v10, v11, v12, (char)__str);
      Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      *((_QWORD *)v0 + 3) = Mutable;
      if (Mutable)
        return v0;
      v13 = CFSTR("Failed to allocacte dictionary.");
    }
    else
    {
      v13 = CFSTR("Failed to create queue.");
    }
    sub_10001A7E4((int)Mutable, "data_ark_load", v13, v2, v3, v4, v5, v6, v16);
    v14 = (const void *)*((_QWORD *)v0 + 3);
    if (v14)
      CFRelease(v14);
    *((_QWORD *)v0 + 3) = 0;

    free(v0);
    return 0;
  }
  return v0;
}

uint64_t sub_10000DFD4(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  NSObject *v5;
  uint64_t v6;
  _QWORD v8[9];
  int v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;

  v10 = 0;
  v11 = &v10;
  v12 = 0x2020000000;
  v13 = -1;
  v5 = *a1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10000E074;
  v8[3] = &unk_10017A250;
  v9 = a5;
  v8[4] = &v10;
  v8[5] = a1;
  v8[6] = a2;
  v8[7] = a3;
  v8[8] = a4;
  dispatch_sync(v5, v8);
  v6 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t sub_10000E074(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int v9;

  v8 = result;
  v9 = *(_DWORD *)(result + 72);
  if ((v9 & 4) != 0)
  {
    result = sub_10000E11C((CFMutableDictionaryRef *)(*(_QWORD *)(result + 40) + 128), *(_QWORD *)(result + 48), *(_QWORD *)(result + 56), *(const void **)(result + 64), a5, a6, a7, a8);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = result;
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24))
      return result;
    v9 = *(_DWORD *)(v8 + 72);
  }
  if ((v9 & 1) != 0)
  {
    result = sub_10000E11C((CFMutableDictionaryRef *)(*(_QWORD *)(v8 + 40) + 120), *(_QWORD *)(v8 + 48), *(_QWORD *)(v8 + 56), *(const void **)(v8 + 64), a5, a6, a7, a8);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = result;
    if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24))
      return result;
    v9 = *(_DWORD *)(v8 + 72);
  }
  if ((v9 & 2) != 0)
  {
    result = sub_10000E11C((CFMutableDictionaryRef *)(*(_QWORD *)(v8 + 40) + 136), *(_QWORD *)(v8 + 48), *(_QWORD *)(v8 + 56), *(const void **)(v8 + 64), a5, a6, a7, a8);
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = result;
  }
  return result;
}

uint64_t sub_10000E11C(CFMutableDictionaryRef *a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef Mutable;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v16;
  char v17;

  if (!a1)
  {
    v16 = CFSTR("Invalid input.");
LABEL_8:
    sub_10001A7E4(0, "_register_notification", v16, (uint64_t)a4, a5, a6, a7, a8, v17);
    return 0xFFFFFFFFLL;
  }
  if (!*a1)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *a1 = Mutable;
    if (!Mutable)
    {
      v16 = CFSTR("Failed to allocate dictionary.");
      goto LABEL_8;
    }
  }
  v13 = sub_10000E83C(a2, a3);
  if (v13)
  {
    v14 = v13;
    CFDictionarySetValue(*a1, v13, a4);
    CFRelease(v14);
    return 0;
  }
  return 0xFFFFFFFFLL;
}

void sub_10000E1DC(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  NSObject *v10;
  _QWORD block[5];

  if (a1 && (v10 = *a1) != 0)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000E25C;
    block[3] = &unk_100179E10;
    block[4] = a1;
    dispatch_sync(v10, block);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_store", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_10000E25C(uint64_t a1)
{
  uint64_t v2;
  CFMutableDictionaryRef Mutable;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFMutableDictionaryRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  std::error_code *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  char v41;
  char v42;
  _QWORD context[3];
  std::__fs::filesystem::path __from;
  std::__fs::filesystem::path __str[42];
  char v46[1024];

  bzero(v46, 0x400uLL);
  bzero(__str, 0x400uLL);
  bzero(&__from, 0x400uLL);
  v2 = *(_QWORD *)(a1 + 32);
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v9 = Mutable;
  if (Mutable)
  {
    v10 = *(_QWORD *)(v2 + 88);
    context[0] = *(_QWORD *)(v2 + 40);
    context[1] = v10;
    context[2] = Mutable;
    CFDictionaryApplyFunction(*(CFDictionaryRef *)(v2 + 24), (CFDictionaryApplierFunction)sub_10000F59C, context);
  }
  else
  {
    sub_10001A7E4(0, "_filter_store", CFSTR("Failed to create dictionary."), v4, v5, v6, v7, v8, v40);
  }
  sub_10000816C(v46);
  snprintf((char *)__str, 0x400uLL, "%s%s", v46, "/Library/Lockdown/data_ark.plist");
  if (v9 && CFDictionaryGetCount(v9))
  {
    snprintf((char *)&__from, 0x400uLL, "%s.XXXXXX", (const char *)__str);
    if (sub_1000255E4((uint64_t)&__from, (uint64_t)v9, v16, v17, v18, v19, v20, v21))
    {
      sub_10001A7E4(0, "data_ark_store_block_invoke", CFSTR("Failed to store %s."), v23, v24, v25, v26, v27, (char)&__from);
    }
    else
    {
      rename(&__from, __str, v22);
      if (v33)
      {
        __error();
        v34 = __error();
        strerror(*v34);
        sub_10001A7E4(0, "data_ark_store_block_invoke", CFSTR("Failed to rename %s: %d (%s)"), v35, v36, v37, v38, v39, (char)&__from);
      }
      else if (dword_1001A6AD0)
      {
        sub_10001A7E4(0, "data_ark_store_block_invoke", CFSTR("Saved."), v28, v29, v30, v31, v32, v42);
      }
    }
    *(_BYTE *)(*(_QWORD *)(a1 + 32) + 16) = 0;
LABEL_17:
    CFRelease(v9);
    return;
  }
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "data_ark_store_block_invoke", CFSTR("Nothing mutable changed."), v11, v12, v13, v14, v15, v41);
  unlink((const char *)__str);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 16) = 0;
  if (v9)
    goto LABEL_17;
}

uint64_t sub_10000E484(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v8;
  uint64_t v9;
  char v11;
  _QWORD block[9];
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  int v16;

  v13 = 0;
  v14 = &v13;
  v15 = 0x2020000000;
  v16 = -1;
  if (a1 && (v8 = *(NSObject **)a1) != 0 && a4 && *(_QWORD *)(a1 + 24))
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000E570;
    block[3] = &unk_10017A278;
    block[6] = a3;
    block[7] = a1;
    block[8] = a4;
    block[4] = &v13;
    block[5] = a2;
    dispatch_sync(v8, block);
    v9 = *((unsigned int *)v14 + 6);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_set", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v11);
    v9 = 0xFFFFFFFFLL;
  }
  _Block_object_dispose(&v13, 8);
  return v9;
}

void sub_10000E558(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_10000E570(uint64_t a1)
{
  const __CFString *v2;
  const __CFString *v3;
  const __CFString *v4;
  const __CFString *v5;
  const void *Value;
  const void *v7;
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  const __CFDictionary *v16;
  const __CFString *v17;
  const __CFString *v18;
  const __CFDictionary *v19;
  const void *v20;
  void *v21;
  const void *v22;
  void *v23;
  const __CFDictionary *v24;
  const __CFString *v25;
  const __CFString *v26;
  const __CFDictionary *v27;
  const void *v28;
  void *v29;
  const void *v30;
  void *v31;
  _QWORD *v32;
  const __CFSet *v33;
  const __CFSet *v34;
  const __CFSet *v35;

  v2 = sub_10000E83C(*(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48));
  if (v2)
  {
    v3 = v2;
    v4 = sub_10000E83C(*(_QWORD *)(a1 + 40), 0);
    if (v4)
    {
      v5 = v4;
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 56) + 24), v3);
      v7 = Value;
      v8 = !Value || !CFEqual(Value, *(CFTypeRef *)(a1 + 64));
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 56) + 24), v3, *(const void **)(a1 + 64));
      if (!v7 && *(_QWORD *)(a1 + 48))
      {
        v14 = 0;
        do
        {
          if (sub_10000E8BC(*(NSObject ***)(a1 + 56), *(_QWORD *)(a1 + 40), 0, v14, v10, v11, v12, v13))
            sub_10000E964(*(NSObject ***)(a1 + 56), *(_QWORD *)(a1 + 40), *(_QWORD *)(a1 + 48), v14, v10, v11, v12, v13);
          v14 = (v14 + 1);
        }
        while ((_DWORD)v14 != 11);
      }
      v15 = *(_QWORD **)(a1 + 56);
      if (v8)
      {
        v16 = (const __CFDictionary *)v15[16];
        if (v16)
        {
          v17 = (const __CFString *)CFDictionaryGetValue(v16, v3);
          if (v17)
            sub_1000110EC(v17);
          v18 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 56) + 128), v5);
          if (v18)
            sub_1000110EC(v18);
        }
        v15 = *(_QWORD **)(a1 + 56);
        v19 = (const __CFDictionary *)v15[19];
        if (v19)
        {
          v20 = CFDictionaryGetValue(v19, v3);
          v21 = (void *)objc_claimAutoreleasedReturnValue(v20);
          if (v21)
            dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 56) + 8), v21);
          v22 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 56) + 152), v5);
          v23 = (void *)objc_claimAutoreleasedReturnValue(v22);

          if (v23)
            dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 56) + 8), v23);

          v15 = *(_QWORD **)(a1 + 56);
        }
      }
      v24 = (const __CFDictionary *)v15[15];
      if (v24)
      {
        v25 = (const __CFString *)CFDictionaryGetValue(v24, v3);
        if (v25)
          sub_1000110EC(v25);
        v26 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 56) + 120), v5);
        if (v26)
          sub_1000110EC(v26);
      }
      v27 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 56) + 144);
      if (v27)
      {
        v28 = CFDictionaryGetValue(v27, v3);
        v29 = (void *)objc_claimAutoreleasedReturnValue(v28);
        if (v29)
          dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 56) + 8), v29);
        v30 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 56) + 144), v5);
        v31 = (void *)objc_claimAutoreleasedReturnValue(v30);

        if (v31)
          dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 56) + 8), v31);

      }
      if (v8)
      {
        v32 = *(_QWORD **)(a1 + 56);
        v33 = (const __CFSet *)v32[5];
        if (!v33 || !CFSetContainsValue(v33, v3))
        {
          v34 = (const __CFSet *)v32[9];
          if (!v34 || !CFSetContainsValue(v34, v3))
          {
            v35 = (const __CFSet *)v32[11];
            if (!v35 || !CFSetContainsValue(v35, v3))
            {
              if (dword_1001A6AD0)
                sub_10001A7E4(0, "data_ark_set_block_invoke", CFSTR("dirtied by changing %@"), v9, v10, v11, v12, v13, (char)v3);
              *(_BYTE *)(*(_QWORD *)(a1 + 56) + 16) = 1;
            }
          }
        }
      }
      *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      CFRelease(v3);
    }
    else
    {
      v5 = v3;
    }
    CFRelease(v5);
  }
}

const __CFString *sub_10000E83C(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
    return CFStringCreateWithFormat(0, 0, CFSTR("%@-%@"), a1, a2);
  if (a1)
    return CFStringCreateWithFormat(0, 0, CFSTR("%@-"), a1);
  if (a2)
    return CFStringCreateWithFormat(0, 0, CFSTR("-%@"), a2);
  CFRetain(CFSTR("-"));
  return CFSTR("-");
}

BOOL sub_10000E8BC(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v9;
  unsigned int v10;
  NSObject **v13;
  CFSetRef *v14;
  NSObject *v15;
  const __CFString *v16;
  const __CFString *v17;
  _BOOL8 v18;
  char v20;

  if (!a1 || (v9 = *a1) == 0)
  {
    sub_10001A7E4(0, "_data_ark_has_attr_nolock", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v20);
    return 0;
  }
  v10 = a4;
  dispatch_assert_queue_V2(v9);
  if (v10 > 0xA)
    return 0;
  v13 = &a1[v10];
  v15 = v13[4];
  v14 = (CFSetRef *)(v13 + 4);
  if (!v15)
    return 0;
  v16 = sub_10000E83C(a2, a3);
  if (!v16)
    return 0;
  v17 = v16;
  v18 = CFSetGetValue(*v14, v16) != 0;
  CFRelease(v17);
  return v18;
}

uint64_t sub_10000E964(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v9;
  unsigned int v10;
  NSObject **v13;
  CFMutableSetRef *v14;
  NSObject *v15;
  CFMutableSetRef Mutable;
  const __CFString *v17;
  const __CFString *v18;
  char v20;

  if (a1 && (v9 = *a1) != 0)
  {
    v10 = a4;
    dispatch_assert_queue_V2(v9);
    if (v10 <= 0xA)
    {
      v13 = &a1[v10];
      v15 = v13[4];
      v14 = (CFMutableSetRef *)(v13 + 4);
      if (v15 || (Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks), (*v14 = Mutable) != 0))
      {
        v17 = sub_10000E83C(a2, a3);
        if (v17)
        {
          v18 = v17;
          CFSetAddValue(*v14, v17);
          CFRelease(v18);
          return 0;
        }
      }
    }
  }
  else
  {
    sub_10001A7E4(0, "_data_ark_set_attr_nolock", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v20);
  }
  return 0xFFFFFFFFLL;
}

void sub_10000EA20(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  CFNumberRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFNumberRef v13;
  char v14;
  int valuePtr;

  valuePtr = a4;
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v7)
  {
    v13 = v7;
    sub_10000E484(a1, a2, a3, (uint64_t)v7, v9, v10, v11, v12);
    CFRelease(v13);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_set_int", CFSTR("Failed to allocate number."), v8, v9, v10, v11, v12, v14);
  }
}

void sub_10000EAAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFNumberRef v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFNumberRef v13;
  char v14;
  uint64_t valuePtr;

  valuePtr = a4;
  v7 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  if (v7)
  {
    v13 = v7;
    sub_10000E484(a1, a2, a3, (uint64_t)v7, v9, v10, v11, v12);
    CFRelease(v13);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_set_int64", CFSTR("Failed to allocate number."), v8, v9, v10, v11, v12, v14);
  }
}

CFMutableDictionaryRef sub_10000EB38(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFString *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef v11;
  NSObject *v12;
  _QWORD v14[8];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;

  v15 = 0;
  v16 = &v15;
  v17 = 0x2020000000;
  v18 = 0;
  if (a2 && *(_QWORD *)a2 && *(_QWORD *)(a2 + 24))
  {
    v11 = sub_100020104(a1, (NSObject **)a2, a3, a4);
    v16[3] = (uint64_t)v11;
    if (!v11)
    {
      v12 = *(NSObject **)a2;
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      v14[2] = sub_10000EC44;
      v14[3] = &unk_10017A2A0;
      v14[4] = &v15;
      v14[5] = a4;
      v14[6] = a3;
      v14[7] = a2;
      dispatch_sync(v12, v14);
      v11 = (CFMutableDictionaryRef)v16[3];
    }
  }
  else
  {
    sub_10001A7E4(0, "data_ark_copy_with_conn_state", CFSTR("Invalid inputs."), (uint64_t)a4, a5, a6, a7, a8, v14[0]);
    v11 = 0;
  }
  _Block_object_dispose(&v15, 8);
  return v11;
}

void sub_10000EC2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10000EC44(_QWORD *a1)
{
  uint64_t v2;
  const __CFString *v3;
  const __CFString *v4;
  const void *v5;
  uint64_t v6;
  const __CFDictionary *v7;
  CFStringRef v8;
  const __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFMutableDictionaryRef Mutable;
  char v16;
  const __CFString *context;
  CFIndex Length;
  CFMutableDictionaryRef v19;

  v2 = a1[5];
  if (!v2)
  {
    v6 = a1[6];
    v7 = *(const __CFDictionary **)(a1[7] + 24);
    context = 0;
    Length = 0;
    v19 = 0;
    if (v6)
    {
      v16 = v6;
      v8 = CFStringCreateWithFormat(0, 0, CFSTR("%@-"));
    }
    else
    {
      v8 = CFStringCreateWithCString(0, "-", 0x8000100u);
    }
    v9 = v8;
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      context = v9;
      Length = CFStringGetLength(v9);
      v19 = Mutable;
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)sub_10000F60C, &context);
      if (!v9)
      {
LABEL_12:
        *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = Mutable;
        return;
      }
    }
    else
    {
      sub_10001A7E4(0, "_copy_domain", CFSTR("Failed to create dictionary."), v10, v11, v12, v13, v14, v16);
      if (!v9)
        goto LABEL_12;
    }
    CFRelease(v9);
    goto LABEL_12;
  }
  v3 = sub_10000E83C(a1[6], v2);
  if (v3)
  {
    v4 = v3;
    *(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) = CFDictionaryGetValue(*(CFDictionaryRef *)(a1[7] + 24), v3);
    v5 = *(const void **)(*(_QWORD *)(a1[4] + 8) + 24);
    if (v5)
      CFRetain(v5);
    CFRelease(v4);
  }
}

uint64_t sub_10000ED98(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return sub_10000EB38(0, a1, a2, a3);
}

uint64_t sub_10000EDAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v9;
  _QWORD v11[7];
  char v12;

  if (a1 && (v9 = *(NSObject **)a1) != 0 && *(_QWORD *)(a1 + 24))
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10000EE40;
    v11[3] = &unk_10017A2C0;
    v11[4] = a2;
    v11[5] = a3;
    v11[6] = a1;
    v12 = a4;
    dispatch_sync(v9, v11);
    return 0;
  }
  else
  {
    sub_10001A7E4(0, "data_ark_remove_extended", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v11[0]);
    return 0xFFFFFFFFLL;
  }
}

void sub_10000EE40(uint64_t a1)
{
  const __CFString *v2;
  const __CFString *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t i;
  const __CFSet *v11;
  const __CFDictionary *v12;
  const __CFString *Value;
  const __CFDictionary *v14;
  const void *v15;
  void *v16;

  v2 = sub_10000E83C(*(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));
  if (v2)
  {
    v3 = v2;
    if (CFDictionaryContainsKey(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 48) + 24), v2))
    {
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 48) + 24), v3);
      v9 = 1;
      for (i = 4; i != 15; ++i)
      {
        v11 = *(const __CFSet **)(*(_QWORD *)(a1 + 48) + 8 * i);
        if (v11)
        {
          if (((_DWORD)i == 11 || (_DWORD)i == 5) && CFSetContainsValue(v11, v3))
            v9 = 0;
          if (*(_BYTE *)(a1 + 56))
            CFSetRemoveValue(*(CFMutableSetRef *)(*(_QWORD *)(a1 + 48) + 8 * i), v3);
        }
      }
      v12 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 48) + 136);
      if (v12)
      {
        Value = (const __CFString *)CFDictionaryGetValue(v12, v3);
        if (Value)
          sub_1000110EC(Value);
      }
      v14 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 48) + 160);
      if (v14)
      {
        v15 = CFDictionaryGetValue(v14, v3);
        v16 = (void *)objc_claimAutoreleasedReturnValue(v15);
        if (v16)
          dispatch_async(*(dispatch_queue_t *)(*(_QWORD *)(a1 + 48) + 8), v16);

      }
      if (((dword_1001A6AD0 != 0) & v9) == 1)
        sub_10001A7E4(0, "data_ark_remove_extended_block_invoke", CFSTR("dirtied by removing %@"), v4, v5, v6, v7, v8, (char)v3);
      if ((v9 & 1) != 0)
        *(_BYTE *)(*(_QWORD *)(a1 + 48) + 16) = 1;
    }
    CFRelease(v3);
  }
}

uint64_t sub_10000EFB4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return sub_10000EDAC(a1, a2, a3, 1, a5, a6, a7, a8);
}

uint64_t sub_10000EFBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v8;
  uint64_t v9;
  _QWORD v11[8];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  if (a1 && (v8 = *(NSObject **)a1) != 0 && *(_QWORD *)(a1 + 24))
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10000F098;
    v11[3] = &unk_10017A2A0;
    v11[4] = &v12;
    v11[5] = a2;
    v11[6] = a3;
    v11[7] = a1;
    dispatch_sync(v8, v11);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_exists", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v11[0]);
  }
  v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_10000F080(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_10000F098(_QWORD *a1)
{
  const __CFString *v2;
  const __CFString *v3;

  v2 = sub_10000E83C(a1[5], a1[6]);
  if (v2)
  {
    v3 = v2;
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = CFDictionaryContainsKey(*(CFDictionaryRef *)(a1[7] + 24), v2) != 0;
    CFRelease(v3);
  }
}

uint64_t sub_10000F0FC(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v8;
  uint64_t v9;
  char v11;
  _QWORD block[8];
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = -1;
  if (a1 && (v8 = *a1) != 0)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000F1D8;
    block[3] = &unk_10017A2E8;
    block[4] = &v14;
    block[5] = a1;
    block[6] = a2;
    block[7] = a3;
    v13 = a4;
    dispatch_sync(v8, block);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_set_attr", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v11);
  }
  v9 = *((unsigned int *)v15 + 6);
  _Block_object_dispose(&v14, 8);
  return v9;
}

void sub_10000F1C0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10000F1D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = sub_10000E964(*(NSObject ***)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(unsigned int *)(a1 + 64), a5, a6, a7, a8);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10000F210(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v8;
  uint64_t v9;
  char v11;
  _QWORD block[8];
  int v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  char v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  if (a1 && (v8 = *a1) != 0)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10000F2E8;
    block[3] = &unk_10017A2E8;
    block[4] = &v14;
    block[5] = a1;
    block[6] = a2;
    block[7] = a3;
    v13 = a4;
    dispatch_sync(v8, block);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_has_attr", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v11);
  }
  v9 = *((unsigned __int8 *)v15 + 24);
  _Block_object_dispose(&v14, 8);
  return v9;
}

void sub_10000F2D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

BOOL sub_10000F2E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL8 result;

  result = sub_10000E8BC(*(NSObject ***)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), *(unsigned int *)(a1 + 64), a5, a6, a7, a8);
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10000F320(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject *v8;
  uint64_t v9;
  _QWORD v11[6];
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  char v15;

  v12 = 0;
  v13 = &v12;
  v14 = 0x2020000000;
  v15 = 0;
  if (a1 && (v8 = *a1) != 0)
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10000F3F0;
    v11[3] = &unk_10017A1E8;
    v11[4] = &v12;
    v11[5] = a1;
    dispatch_sync(v8, v11);
  }
  else
  {
    sub_10001A7E4(0, "data_ark_dirty", CFSTR("Invalid inputs."), a4, a5, a6, a7, a8, v11[0]);
  }
  v9 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v9;
}

void sub_10000F3D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10000F3F0(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = *(_BYTE *)(*(_QWORD *)(result + 40) + 16);
  return result;
}

CFMutableDictionaryRef sub_10000F404(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef result;
  const __CFString *v9;
  CFTypeID v10;
  char v11;
  unsigned int valuePtr;

  valuePtr = 0;
  if (a1)
  {
    result = sub_10000EB38(0, a1, a2, a3, a5, a6, a7, a8);
    if (result)
    {
      v9 = (const __CFString *)result;
      v10 = CFGetTypeID(result);
      if (v10 == CFBooleanGetTypeID())
      {
        valuePtr = CFEqual(v9, kCFBooleanTrue) != 0;
      }
      else if (v10 == CFNumberGetTypeID())
      {
        CFNumberGetValue((CFNumberRef)v9, kCFNumberIntType, &valuePtr);
      }
      else if (v10 == CFStringGetTypeID())
      {
        valuePtr = CFStringGetIntValue(v9);
      }
      CFRelease(v9);
      return (CFMutableDictionaryRef)valuePtr;
    }
  }
  else
  {
    sub_10001A7E4(0, "data_ark_get_int", CFSTR("Invalid input."), a4, a5, a6, a7, a8, v11);
    return 0;
  }
  return result;
}

CFMutableDictionaryRef sub_10000F4E0(uint64_t a1, const __CFString *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef result;
  const __CFString *v9;
  CFTypeID v10;
  uint64_t IntValue;
  uint64_t valuePtr;

  valuePtr = 0;
  result = sub_10000EB38(0, a1, a2, a3, a5, a6, a7, a8);
  if (result)
  {
    v9 = (const __CFString *)result;
    v10 = CFGetTypeID(result);
    if (v10 == CFBooleanGetTypeID())
    {
      if (CFEqual(v9, kCFBooleanTrue))
      {
        IntValue = 1;
LABEL_9:
        valuePtr = IntValue;
      }
    }
    else if (v10 == CFNumberGetTypeID())
    {
      CFNumberGetValue((CFNumberRef)v9, kCFNumberSInt64Type, &valuePtr);
    }
    else if (v10 == CFStringGetTypeID())
    {
      IntValue = CFStringGetIntValue(v9);
      goto LABEL_9;
    }
    CFRelease(v9);
    return (CFMutableDictionaryRef)valuePtr;
  }
  return result;
}

void sub_10000F59C(void *value, void *a2, CFSetRef *a3)
{
  __CFDictionary *v5;
  const __CFSet *v6;

  v6 = a3[1];
  v5 = a3[2];
  if ((!*a3 || !CFSetGetValue(*a3, value)) && (!v6 || !CFSetGetValue(v6, value)))
    CFDictionarySetValue(v5, value, a2);
}

void sub_10000F60C(const __CFString *a1, const void *a2, uint64_t a3)
{
  uint64_t v5;
  __CFDictionary *v6;
  CFStringRef v7;
  CFRange v8;

  v5 = *(_QWORD *)(a3 + 8);
  v6 = *(__CFDictionary **)(a3 + 16);
  if (CFStringHasPrefix(a1, *(CFStringRef *)a3))
  {
    v8.length = CFStringGetLength(a1) - v5;
    v8.location = v5;
    v7 = CFStringCreateWithSubstring(0, a1, v8);
    CFDictionarySetValue(v6, v7, a2);
    if (v7)
      CFRelease(v7);
  }
}

uint64_t start()
{
  void *v0;
  dispatch_queue_global_t global_queue;
  NSObject *v2;
  NSObject *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  NSObject **v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char v47;
  void *v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;

  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v48 = 0;
  v0 = objc_autoreleasePoolPush();
  openlog("lockdownd", 1, 24);
  global_queue = dispatch_get_global_queue(0, 0);
  v2 = objc_claimAutoreleasedReturnValue(global_queue);
  xpc_set_event_stream_handler("com.apple.notifyd.matching", v2, &stru_10017A328);

  xpc_set_event_stream_handler("com.apple.iokit.matching", v2, &stru_10017A348);
  xpc_set_event_stream_handler("com.apple.bonjour.registration", v2, &stru_10017A368);

  signal(15, (void (__cdecl *)(int))1);
  v3 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, 0);
  if (!v3)
    sub_1000F9724();
  v4 = v3;
  dispatch_source_set_event_handler(v3, &stru_10017A388);
  dispatch_resume(v4);
  sub_10001A7E4(0, "main", CFSTR("Starting Up"), v5, v6, v7, v8, v9, v47);
  MGSetLogHandler(sub_10000F988);
  v10 = (void *)os_transaction_create("com.apple.mobile.lockdownd");
  *(_QWORD *)&v50 = dispatch_queue_create("com.apple.mobile.lockdown.dns", 0);
  if (!(_QWORD)v50)
    sub_1000F973C();
  sub_100005338();
  sub_10001095C(0, v11, v12, v13, v14, v15, v16, v17);
  v18 = sub_1000115A8((uint64_t)&v49, &v48);
  *(_QWORD *)&v49 = v18;
  if (!v18)
    sub_1000F9754(&v48, v19, v20, v21, v22, v23, v24, v25);
  if ((sub_100007CAC((uint64_t)v18, 0, 0) & 1) == 0)
    sub_1000F9850();
  if ((sub_1000238D8((uint64_t)&v49, &v48, v26, v27, v28, v29, v30, v31) & 1) == 0)
    sub_1000F9804(&v48, v32, v33, v34, v35, v36, v37, v38);
  if ((sub_100023EEC((uint64_t)&v49, &v48, v33, v34, v35, v36, v37, v38) & 1) == 0)
    sub_1000F97B8(&v48, v39, v40, v41, v42, v43, v44, v45);
  if ((sub_10002424C(&v49) & 1) == 0)
    sub_1000F97A0();

  objc_autoreleasePoolPop(v0);
  CFRunLoopRun();

  return 1;
}

void sub_10000F870(id a1, OS_xpc_object *a2)
{
  OS_xpc_object *v2;
  id v3;
  const char *string;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  id v10;

  v2 = a2;
  v3 = objc_alloc((Class)NSString);
  string = xpc_dictionary_get_string(v2, _xpc_event_key_name);

  v10 = objc_msgSend(v3, "initWithUTF8String:", string);
  sub_10001A7E4(0, "main_block_invoke", CFSTR("Received notification: %@"), v5, v6, v7, v8, v9, (char)v10);

}

void sub_10000F8FC(id a1, OS_xpc_object *a2)
{
  const char *string;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;

  string = xpc_dictionary_get_string(a2, _xpc_event_key_name);
  if (string)
  {
    if (dword_1001A6AD0)
      sub_10001A7E4(0, "main_block_invoke_2", CFSTR("com.apple.iokit.matching event: %s"), v3, v4, v5, v6, v7, (char)string);
  }
  else
  {
    sub_10001A7E4(0, "main_block_invoke_2", CFSTR("Failed to get event name."), v3, v4, v5, v6, v7, v8);
  }
}

void sub_10000F978(id a1)
{
  exit(0);
}

void sub_10000F988(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "mglog", CFSTR("%s"), a4, a5, a6, a7, a8, a1);
}

id sub_10000F9CC(void *a1, const char *a2)
{
  return objc_msgSend(a1, "UTF8String");
}

CFDataRef sub_10000F9D4(uint64_t a1, const char *a2)
{
  const __CFDictionary *v3;
  const __CFDictionary *v4;
  void *Value;
  CFDataRef v6;

  v3 = (const __CFDictionary *)SecKeyCopyAttributeDictionary();
  if (!v3)
    return 0;
  v4 = v3;
  Value = (void *)CFDictionaryGetValue(v3, kSecValueData);
  if (Value)
    v6 = sub_10000FA38(Value, a2);
  else
    v6 = 0;
  CFRelease(v4);
  return v6;
}

CFDataRef sub_10000FA38(void *a1, const char *a2)
{
  void *v4;
  void *v5;
  CFDataRef v6;
  int v7;
  CFIndex v8;
  char *v9;
  const UInt8 *v10;
  UInt8 *v11;
  char __src[80];
  char __str[80];
  CFRange v15;

  v4 = objc_autoreleasePoolPush();
  v5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(a1, "base64EncodedDataWithOptions:", 1));
  v6 = (CFDataRef)objc_msgSend(v5, "length");
  if (v6)
  {
    v7 = snprintf(__str, 0x50uLL, "-----BEGIN %s-----\n", a2);
    v8 = (CFIndex)v6 + v7 + snprintf(__src, 0x50uLL, "\n-----END %s-----\n", a2);
    v9 = (char *)malloc_type_malloc(v8 + 1, 0x3C9BA930uLL);
    if (v9)
    {
      v10 = (const UInt8 *)v9;
      v11 = (UInt8 *)&strcpy(v9, __str)[v7];
      v15.location = 0;
      v15.length = (CFIndex)v6;
      CFDataGetBytes((CFDataRef)v5, v15, v11);
      strcpy((char *)v6 + (_QWORD)v11, __src);
      v6 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v10, v8, kCFAllocatorMalloc);
    }
    else
    {
      v6 = 0;
    }
  }

  objc_autoreleasePoolPop(v4);
  return v6;
}

uint64_t sub_10000FB88(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  CFNumberRef v6;
  __CFDictionary *Mutable;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFDictionary *v13;
  OSStatus v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  OSStatus v20;
  const __CFString *v21;
  SecKeyRef v22;
  __SecKey *v23;
  __SecKey *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v37;
  int valuePtr;
  CFErrorRef error;

  error = 0;
  valuePtr = a1;
  v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v6)
  {
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v13 = Mutable;
    if (!Mutable)
    {
      v21 = CFSTR("Failed to create dictionary.");
      goto LABEL_12;
    }
    CFDictionaryAddValue(Mutable, kSecAttrAccessGroup, CFSTR("lockdown-identities"));
    CFDictionaryAddValue(v13, kSecAttrLabel, CFSTR("com.apple.lockdown.pairingkeypair"));
    CFDictionaryAddValue(v13, kSecUseSystemKeychain, kCFBooleanTrue);
    CFDictionaryAddValue(v13, kSecClass, kSecClassKey);
    v14 = SecItemDelete(v13);
    if (v14 != -25300)
    {
      v20 = v14;
      if (v14)
      {
        sub_10001A7E4(0, "lockcrypto_genenerate_keypair", CFSTR("Failed to delete keychain item (%@/%@): %d"), v15, v16, v17, v18, v19, (char)CFSTR("lockdown-identities"));
        if (v20 == -25291)
        {
          v21 = CFSTR("Keychain not available, no key generation attempted.");
          LODWORD(Mutable) = 0;
LABEL_12:
          sub_10001A7E4((int)Mutable, "lockcrypto_genenerate_keypair", v21, v8, v9, v10, v11, v12, v37);
          v22 = 0;
          v23 = 0;
          goto LABEL_15;
        }
      }
    }
    CFDictionaryAddValue(v13, kSecAttrKeyType, kSecAttrKeyTypeRSA);
    CFDictionaryAddValue(v13, kSecAttrAccessible, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate);
    CFDictionaryAddValue(v13, kSecAttrKeySizeInBits, v6);
    v24 = SecKeyCreateRandomKey(v13, &error);
    v23 = v24;
    if (v24)
    {
      v22 = SecKeyCopyPublicKey(v24);
      if (v22)
      {
        sub_10000FE38(v23);
        sub_1000110EC(CFSTR("com.apple.mobile.lockdown.BonjourServiceChanged"));
        v35 = 0;
        goto LABEL_16;
      }
      sub_10001A7E4(0, "lockcrypto_genenerate_keypair", CFSTR("Failed to copy public key."), v30, v31, v32, v33, v34, v37);
    }
    else
    {
      sub_10001A7E4(0, "lockcrypto_genenerate_keypair", CFSTR("Failed to create private key."), v25, v26, v27, v28, v29, v37);
      v22 = 0;
    }
  }
  else
  {
    sub_10001A7E4(0, "lockcrypto_genenerate_keypair", CFSTR("Failed to create number."), v1, v2, v3, v4, v5, v37);
    v22 = 0;
    v23 = 0;
    v13 = 0;
  }
LABEL_15:
  v35 = 0xFFFFFFFFLL;
LABEL_16:
  if (error)
    CFRelease(error);
  error = 0;
  if (v13)
    CFRelease(v13);
  if (v6)
    CFRelease(v6);
  if (v23)
    CFRelease(v23);
  if (v22)
    CFRelease(v22);
  return v35;
}

uint64_t sub_10000FE38(const void *a1)
{
  __CFDictionary *Mutable;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *v8;
  const void *v9;
  OSStatus v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  OSStatus v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v25;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    v8 = Mutable;
    CFDictionaryAddValue(Mutable, kSecAttrAccessGroup, CFSTR("lockdown-identities"));
    CFDictionaryAddValue(v8, kSecAttrLabel, CFSTR("com.apple.lockdown.pairingkeypair"));
    v9 = (const void *)kSecUseSystemKeychain;
    CFDictionaryAddValue(v8, kSecUseSystemKeychain, kCFBooleanTrue);
    CFDictionaryAddValue(v8, kSecClass, kSecClassKey);
    v10 = SecItemDelete(v8);
    if (v10 != -25300 && v10 != 0)
    {
      sub_10001A7E4(0, "store_keypair", CFSTR("SecItemDelete failed: %d"), v11, v12, v13, v14, v15, v10);
      goto LABEL_11;
    }
    CFRelease(v8);
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v8 = Mutable;
      CFDictionaryAddValue(Mutable, kSecValueRef, a1);
      CFDictionaryAddValue(v8, kSecAttrAccessible, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate);
      CFDictionaryAddValue(v8, kSecAttrAccessGroup, CFSTR("lockdown-identities"));
      CFDictionaryAddValue(v8, kSecAttrLabel, CFSTR("com.apple.lockdown.pairingkeypair"));
      CFDictionaryAddValue(v8, v9, kCFBooleanTrue);
      v17 = SecItemAdd(v8, 0);
      if (!v17)
      {
        v23 = 1;
        goto LABEL_12;
      }
      sub_10001A7E4(0, "store_keypair", CFSTR("SecItemAdd failed: %d"), v18, v19, v20, v21, v22, v17);
LABEL_11:
      v23 = 0;
LABEL_12:
      CFRelease(v8);
      return v23;
    }
  }
  sub_10001A7E4((int)Mutable, "store_keypair", CFSTR("Failed to create dictionary."), v3, v4, v5, v6, v7, v25);
  return 0;
}

SecKeyRef sub_100010050(const void *a1)
{
  SecPolicyRef BasicX509;
  SecPolicyRef v3;
  OSStatus v4;
  SecTrustRef v5;
  SecKeyRef v6;
  SecTrustRef trust;

  trust = 0;
  BasicX509 = SecPolicyCreateBasicX509();
  if (!BasicX509)
    return 0;
  v3 = BasicX509;
  v4 = SecTrustCreateWithCertificates(a1, BasicX509, &trust);
  v5 = trust;
  if (!v4)
  {
    v6 = SecTrustCopyKey(trust);
    v5 = trust;
    if (!trust)
      goto LABEL_5;
    goto LABEL_4;
  }
  v6 = 0;
  if (trust)
LABEL_4:
    CFRelease(v5);
LABEL_5:
  CFRelease(v3);
  return v6;
}

id sub_1000100D4(const __CFData *a1, const char *a2)
{
  const char *BytePtr;
  CFIndex Length;
  size_t v6;
  int v7;
  char *v8;
  char *v9;
  id v10;
  char *v11;
  char *v12;
  void *v13;
  void *v14;
  char __little[80];
  char __str[80];

  if (!a1)
    return 0;
  BytePtr = (const char *)CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (Length < 0)
    return 0;
  v6 = Length;
  v7 = snprintf(__str, 0x50uLL, "-----BEGIN %s-----\n", a2);
  snprintf(__little, 0x50uLL, "\n-----END %s-----\n", a2);
  v8 = strnstr(BytePtr, __str, v6);
  v9 = strnstr(BytePtr, __little, v6);
  v10 = 0;
  if (v8)
  {
    v11 = v9;
    if (v9)
    {
      v12 = &v8[v7];
      v13 = objc_autoreleasePoolPush();
      v14 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytesNoCopy:length:freeWhenDone:](NSData, "dataWithBytesNoCopy:length:freeWhenDone:", v12, v11 - v12, 0));
      v10 = objc_msgSend(objc_alloc((Class)NSData), "initWithBase64EncodedData:options:", v14, 1);

      objc_autoreleasePoolPop(v13);
    }
  }
  return v10;
}

const __CFData *sub_100010210(const __CFData *a1)
{
  const __CFData *result;
  const __CFData *v2;
  SecCertificateRef v3;

  result = (const __CFData *)sub_1000100D4(a1, "CERTIFICATE");
  if (result)
  {
    v2 = result;
    v3 = SecCertificateCreateWithData(kCFAllocatorDefault, result);
    CFRelease(v2);
    return v3;
  }
  return result;
}

uint64_t sub_100010260(const __CFData *a1)
{
  const __CFData *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFData *v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t RSAPrivateKey;
  char v17;

  v1 = (const __CFData *)sub_1000100D4(a1, "RSA PRIVATE KEY");
  if (v1)
  {
    v7 = v1;
    BytePtr = CFDataGetBytePtr(v1);
    Length = CFDataGetLength(v7);
    RSAPrivateKey = SecKeyCreateRSAPrivateKey(kCFAllocatorDefault, BytePtr, Length, 1);
    if (!RSAPrivateKey)
      sub_10001A7E4(0, "lockcrypto_private_key_from_pem_data", CFSTR("SecKeyCreateRSAPrivateKey failed"), v10, v11, v12, v13, v14, v17);
    CFRelease(v7);
  }
  else
  {
    sub_10001A7E4(0, "lockcrypto_private_key_from_pem_data", CFSTR("lockcrypto_decode_pem failed"), v2, v3, v4, v5, v6, v17);
    return 0;
  }
  return RSAPrivateKey;
}

uint64_t sub_100010308(_QWORD *a1, uint64_t a2, CFDataRef theData, const __CFString **a4)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFTypeRef v30;
  char v31[41];
  uint64_t v32;
  uint64_t v33;
  int v34;

  v30 = 0;
  if (a4)
    *a4 = 0;
  v32 = 0;
  v33 = 0;
  v34 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  CCDigest(8, BytePtr, Length, &v32);
  __sprintf_chk(v31, 0, 0x29uLL, "%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x", v32, BYTE1(v32), BYTE2(v32), BYTE3(v32), BYTE4(v32), BYTE5(v32), BYTE6(v32), HIBYTE(v32), v33, BYTE1(v33), BYTE2(v33), BYTE3(v33), BYTE4(v33), BYTE5(v33), BYTE6(v33),
    HIBYTE(v33),
    v34,
    BYTE1(v34),
    BYTE2(v34),
    HIBYTE(v34));
  CFDataGetLength(theData);
  sub_10001A7E4(0, "unlock_with_escrow", CFSTR("Starting service with bag=%s, %ld"), v10, v11, v12, v13, v14, (char)v31);
  v15 = MKBKeyBagCreateWithData(theData, &v30);
  if (v15)
  {
    sub_10001A7E4(0, "unlock_with_escrow", CFSTR("Can't instantiate escrow bag: %d"), v16, v17, v18, v19, v20, v15);
    if (a4)
    {
      v21 = CFSTR("Failure");
LABEL_9:
      v28 = 0;
      *a4 = v21;
      goto LABEL_11;
    }
LABEL_10:
    v28 = 0;
    goto LABEL_11;
  }
  v22 = MKBKeyBagUnlock(v30, a2);
  if (v22)
  {
    sub_10001A7E4(0, "unlock_with_escrow", CFSTR("Can't unlock escrow bag: %d"), v23, v24, v25, v26, v27, v22);
    if (a4)
    {
      v21 = CFSTR("EscrowFailure");
      goto LABEL_9;
    }
    goto LABEL_10;
  }
  if (a1)
  {
    *a1 = v30;
    return 1;
  }
  v28 = 1;
LABEL_11:
  if (v30)
    CFRelease(v30);
  return v28;
}

id sub_100010520(uint64_t a1, uint64_t a2, int a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v13;
  id v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  void *v20;
  NSString *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v29;

  v13 = a4;
  v14 = a5;
  v15 = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithFormat:arguments:", v14, &a9);

  v19 = sub_100010628(a1, a2, a3, v13, CFSTR("%@"), v16, v17, v18, (uint64_t)v15);
  v20 = (void *)objc_claimAutoreleasedReturnValue(v19);
  if (v13)
    v21 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: %@ // %@"), a1, v15, v13);
  else
    v21 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: %@"), a1, v15, v29);
  v22 = (void *)objc_claimAutoreleasedReturnValue(v21);

  sub_10001A7E4(0, "createAndLogError", CFSTR("%@"), v23, v24, v25, v26, v27, (char)v22);
  return v20;
}

id sub_100010628(uint64_t a1, uint64_t a2, int a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v13;
  id v14;
  id v15;
  id v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  v13 = a4;
  v14 = a5;
  v15 = objc_msgSend(objc_alloc((Class)NSMutableString), "initWithFormat:arguments:", v14, &a9);

  v16 = objc_alloc_init((Class)NSMutableDictionary);
  v17 = v16;
  if (v15)
    objc_msgSend(v16, "setObject:forKeyedSubscript:", v15, NSLocalizedDescriptionKey);
  if (v13)
    objc_msgSend(v17, "setObject:forKeyedSubscript:", v13, NSUnderlyingErrorKey);
  if (os_variant_allows_internal_security_policies(0))
  {
    if (a1)
    {
      v18 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", a1));
      objc_msgSend(v17, "setObject:forKeyedSubscript:", v18, CFSTR("FunctionName"));

    }
    if ((_DWORD)a2)
    {
      v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithInt:](NSNumber, "numberWithInt:", a2));
      objc_msgSend(v17, "setObject:forKeyedSubscript:", v19, CFSTR("SourceLine"));

    }
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("com.apple.MobileLockdown.ErrorDomain"), a3, v17));

  return v20;
}

uint64_t sub_10001079C(void *a1, void *a2, id a3)
{
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  id v10;
  void *v11;
  uint64_t v12;

  v5 = a1;
  v6 = a2;
  v7 = v6;
  v8 = 0;
  if (v5 && v6)
  {
    do
    {
      v9 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "domain"));
      if (objc_msgSend(v9, "isEqualToString:", v7))
      {
        v10 = objc_msgSend(v5, "code");

        if (v10 == a3)
        {
          v8 = 1;
          goto LABEL_9;
        }
      }
      else
      {

      }
      v11 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "userInfo"));
      v12 = objc_claimAutoreleasedReturnValue(objc_msgSend(v11, "objectForKeyedSubscript:", NSUnderlyingErrorKey));

      v5 = (id)v12;
    }
    while (v12);
    v8 = 0;
  }
LABEL_9:

  return v8;
}

__CFString *sub_100010878(void *a1)
{
  id v1;
  __CFString **v2;
  int v3;
  __CFString *v4;

  v1 = a1;
  if ((sub_10001079C(v1, CFSTR("com.apple.MobileLockdown.ErrorDomain"), (id)0xFFFFFFFFFFFFFFFDLL) & 1) != 0)
  {
    v2 = off_10017B860;
  }
  else if ((sub_10001079C(v1, CFSTR("com.apple.MobileLockdown.ErrorDomain"), (id)0xFFFFFFFFFFFFFFFCLL) & 1) != 0)
  {
    v2 = off_10017B968;
  }
  else if ((sub_10001079C(v1, CFSTR("com.apple.MobileLockdown.ErrorDomain"), (id)0xFFFFFFFFFFFFFFFBLL) & 1) != 0)
  {
    v2 = off_10017B940;
  }
  else if ((sub_10001079C(v1, CFSTR("com.apple.MobileLockdown.ErrorDomain"), (id)0xFFFFFFFFFFFFFFFALL) & 1) != 0)
  {
    v2 = off_10017B8D8;
  }
  else
  {
    v3 = sub_10001079C(v1, CFSTR("com.apple.MobileLockdown.ErrorDomain"), (id)0xFFFFFFFFFFFFFFF9);
    v2 = off_10017B998;
    if (v3)
      v2 = off_10017B8E0;
  }
  v4 = *v2;

  return v4;
}

uint64_t sub_10001095C(char *key, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _launch_data *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _launch_data *index;
  const __CFString *v17;
  char v18;

  if (qword_1001A7FE0 == -1)
  {
    if (key)
      goto LABEL_3;
  }
  else
  {
    dispatch_once(&qword_1001A7FE0, &stru_10017A478);
    if (key)
    {
LABEL_3:
      if (qword_1001A7FD8)
      {
        v9 = launch_data_dict_lookup((const launch_data_t)qword_1001A7FD8, key);
        if (!v9)
        {
          sub_10001A7E4(0, "checkin_with_launchd", CFSTR("No info about socket %s."), v10, v11, v12, v13, v14, (char)key);
          return 0xFFFFFFFFLL;
        }
        index = launch_data_array_get_index(v9, 0);
        if (index)
          return launch_data_get_fd(index);
        v17 = CFSTR("No file descriptor available.");
      }
      else
      {
        v17 = CFSTR("launchd not initialized yet.");
      }
      sub_10001A7E4(0, "checkin_with_launchd", v17, a4, a5, a6, a7, a8, v18);
      return 0xFFFFFFFFLL;
    }
  }
  return 0;
}

void sub_100010A2C(id a1)
{
  _launch_data *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _launch_data *v7;
  int errno;
  char v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _launch_data *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  char v22;

  v1 = (_launch_data *)launch_socket_service_check_in(a1);
  if (v1)
  {
    v7 = v1;
    if (launch_data_get_type(v1) == LAUNCH_DATA_ERRNO)
    {
      errno = launch_data_get_errno(v7);
      v9 = launch_data_get_errno(v7);
      strerror(errno);
      sub_10001A7E4(0, "checkin_with_launchd_block_invoke", CFSTR("launch_socket_service_check_in failed: %d (%s)"), v10, v11, v12, v13, v14, v9);
    }
    else
    {
      v15 = launch_data_dict_lookup(v7, "Sockets");
      qword_1001A7FD8 = (uint64_t)v15;
      if (v15)
        qword_1001A7FD8 = (uint64_t)launch_data_copy(v15);
      else
        sub_10001A7E4(0, "checkin_with_launchd_block_invoke", CFSTR("No sockets in checkin response."), v16, v17, v18, v19, v20, v21);
    }
    launch_data_free(v7);
  }
  else
  {
    sub_10001A7E4(0, "checkin_with_launchd_block_invoke", CFSTR("launch_socket_service_check_in failed."), v2, v3, v4, v5, v6, v22);
  }
}

const void *sub_100010B0C(const void *result)
{
  const void *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFNumberGetTypeID())
      return v1;
    else
      return 0;
  }
  return result;
}

const void *sub_100010B40(const void *result)
{
  const void *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFDictionaryGetTypeID())
      return v1;
    else
      return 0;
  }
  return result;
}

const void *sub_100010B74(const void *result)
{
  const void *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFArrayGetTypeID())
      return v1;
    else
      return 0;
  }
  return result;
}

const void *sub_100010BA8(const void *result)
{
  const void *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFStringGetTypeID())
      return v1;
    else
      return 0;
  }
  return result;
}

const void *sub_100010BDC(const void *result)
{
  const void *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFDataGetTypeID())
      return v1;
    else
      return 0;
  }
  return result;
}

const void *sub_100010C10(const void *result)
{
  const void *v1;
  CFTypeID v2;

  if (result)
  {
    v1 = result;
    v2 = CFGetTypeID(result);
    if (v2 == CFBooleanGetTypeID())
      return v1;
    else
      return 0;
  }
  return result;
}

BOOL sub_100010C44(int a1)
{
  int v1;
  int *v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v10;

  v10 = 1;
  v1 = setsockopt(a1, 0xFFFF, 4130, &v10, 4u);
  if (v1 == -1)
  {
    v2 = __error();
    v3 = strerror(*v2);
    sub_10001A7E4(0, "_disable_sigpipe", CFSTR("setsockopt(SO_NOSIGPIPE) failed: %s"), v4, v5, v6, v7, v8, v3);
  }
  return v1 != -1;
}

BOOL sub_100010CBC(int a1)
{
  int v1;
  int *v2;
  char v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v10;

  v10 = 1;
  v1 = setsockopt(a1, 0xFFFF, 0x10000, &v10, 4u);
  if (v1 == -1)
  {
    v2 = __error();
    v3 = strerror(*v2);
    sub_10001A7E4(0, "_disable_wake_from_sleep", CFSTR("setsockopt(SO_NOWAKEFROMSLEEP) failed: %s"), v4, v5, v6, v7, v8, v3);
  }
  return v1 != -1;
}

uint64_t sub_100010D34(int a1)
{
  int v2;
  const __CFString *v4;
  int *v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = fcntl(a1, 3, 0);
  if (v2 < 0)
  {
    v4 = CFSTR("Couldn't read socket status flags: %s");
  }
  else
  {
    if ((fcntl(a1, 4, v2 & 0xFFFFFFFB) & 0x80000000) == 0)
      return 1;
    v4 = CFSTR("Couldn't write socket status flags: %s");
  }
  v5 = __error();
  v6 = strerror(*v5);
  sub_10001A7E4(0, "set_socket_option_blocking", v4, v7, v8, v9, v10, v11, v6);
  return 0;
}

uint64_t sub_100010DC4(int a1)
{
  const __CFString *v3;
  int *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;

  v14 = 1;
  v12 = 2;
  v13 = 10;
  v11 = 5;
  if (setsockopt(a1, 0xFFFF, 8, &v14, 4u) == -1)
  {
    v3 = CFSTR("setsockopt(SO_KEEPALIVE) failed: %s");
  }
  else if (setsockopt(a1, 6, 16, &v13, 4u) == -1)
  {
    v3 = CFSTR("setsockopt(TCP_KEEPALIVE) failed: %s");
  }
  else if (setsockopt(a1, 6, 257, &v12, 4u) == -1)
  {
    v3 = CFSTR("setsockopt(TCP_KEEPINTVL) failed: %s");
  }
  else
  {
    if (setsockopt(a1, 6, 258, &v11, 4u) != -1)
      return 1;
    v3 = CFSTR("setsockopt(TCP_KEEPCNT) failed: %s");
  }
  v4 = __error();
  v5 = strerror(*v4);
  sub_10001A7E4(0, "set_socket_option_keepalive", v3, v6, v7, v8, v9, v10, v5);
  return 0;
}

CFStringRef sub_100010EDC(int a1, char *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  int *v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int *v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  socklen_t v31;
  char cStr[128];
  sockaddr v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;

  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = (sockaddr)0;
  v34 = 0u;
  v31 = 128;
  if (getpeername(a1, &v33, &v31))
  {
    v10 = __error();
    v11 = strerror(*v10);
    sub_10001A7E4(0, "createIPString", CFSTR("Can't get socket address: %s"), v12, v13, v14, v15, v16, v11);
  }
  else if (v33.sa_family == 30)
  {
    if (inet_ntop(30, &v33.sa_data[6], cStr, 0x80u))
    {
      v8 = 1;
      goto LABEL_8;
    }
    v24 = __error();
    v25 = strerror(*v24);
    sub_10001A7E4(0, "createIPString", CFSTR("Can't convert to ipv6 string: %s"), v26, v27, v28, v29, v30, v25);
  }
  else if (v33.sa_family == 2)
  {
    if (inet_ntop(2, &v33.sa_data[2], cStr, 0x80u))
    {
      v8 = 0;
LABEL_8:
      *a2 = v8;
      return CFStringCreateWithCString(0, cStr, 0x8000100u);
    }
    v17 = __error();
    v18 = strerror(*v17);
    sub_10001A7E4(0, "createIPString", CFSTR("Can't convert to ipv4 string: %s"), v19, v20, v21, v22, v23, v18);
  }
  else
  {
    sub_10001A7E4(0, "createIPString", CFSTR("Unknown socket family %d"), v3, v4, v5, v6, v7, v33.sa_family);
  }
  return 0;
}

xpc_object_t sub_10001105C(const void *a1)
{
  CFTypeID v2;
  const __CFData *Data;
  const __CFData *v4;
  const UInt8 *BytePtr;
  size_t Length;
  xpc_object_t v7;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (v2 != CFDictionaryGetTypeID())
    return 0;
  Data = CFPropertyListCreateData(kCFAllocatorDefault, a1, kCFPropertyListBinaryFormat_v1_0, 0, 0);
  if (!Data)
    return 0;
  v4 = Data;
  BytePtr = CFDataGetBytePtr(Data);
  Length = CFDataGetLength(v4);
  v7 = xpc_data_create(BytePtr, Length);
  CFRelease(v4);
  return v7;
}

void sub_1000110EC(const __CFString *a1)
{
  __CFNotificationCenter *DarwinNotifyCenter;

  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterPostNotification(DarwinNotifyCenter, a1, a1, 0, 1u);
}

CFStringRef sub_10001111C()
{
  _BYTE v1[37];
  uuid_t out;

  memset(out, 0, sizeof(out));
  memset(v1, 0, sizeof(v1));
  uuid_generate(out);
  uuid_unparse(out, v1);
  return CFStringCreateWithCString(0, v1, 0x8000100u);
}

uint64_t sub_100011198(uint64_t a1, uint64_t a2, int a3, char a4)
{
  uint64_t v8;
  _QWORD v10[7];
  char v11;
  _QWORD v12[7];
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = 0;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_100011358;
  v12[3] = &unk_10017A4A0;
  v12[5] = a1;
  v12[6] = a2;
  v12[4] = &v14;
  v13 = a4;
  sub_1000112C4((uint64_t)&unk_1001A5420, 0x8Eu, (uint64_t)v12);
  v8 = v15[3];
  if (!v8 && a3)
  {
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_1000113F8;
    v10[3] = &unk_10017A4A0;
    v10[5] = a1;
    v10[6] = a2;
    v10[4] = &v14;
    v11 = a4;
    sub_1000112C4((uint64_t)&unk_1001A6A50, 3u, (uint64_t)v10);
    v8 = v15[3];
  }
  _Block_object_dispose(&v14, 8);
  return v8;
}

void sub_1000112AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000112C4(uint64_t result, unsigned int a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v10 = 0;
  if (a2)
  {
    v4 = result;
    v5 = a2 - 1;
    do
    {
      v6 = v5;
      if (*(_QWORD *)v4)
        v7 = **(_QWORD **)v4;
      else
        v7 = 0;
      v8 = *(uint64_t **)(v4 + 8);
      if (v8)
        v9 = *v8;
      else
        v9 = 0;
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, char *))(a3 + 16))(a3, v7, v9, v4, &v10);
      if (v10)
        break;
      v5 = v6 - 1;
      v4 += 40;
    }
    while (v6);
  }
  return result;
}

uint64_t sub_100011358(uint64_t result, unint64_t cf1, unint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v8 = result;
  v9 = *(_QWORD *)(result + 40);
  if (!(cf1 | v9) || cf1 && v9 && (result = CFEqual((CFTypeRef)cf1, (CFTypeRef)v9), (_DWORD)result))
  {
    v10 = *(_QWORD *)(v8 + 48);
    if (!(a3 | v10) || a3 && v10 && (result = CFEqual((CFTypeRef)a3, (CFTypeRef)v10), (_DWORD)result))
    {
      v11 = 24;
      if (!*(_BYTE *)(v8 + 56))
        v11 = 16;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *(_QWORD *)(a4 + v11);
      *a5 = 1;
    }
  }
  return result;
}

uint64_t sub_1000113F8(uint64_t result, unint64_t cf1, unint64_t a3, uint64_t a4, _BYTE *a5)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;

  v8 = result;
  v9 = *(_QWORD *)(result + 40);
  if (!(cf1 | v9) || cf1 && v9 && (result = CFEqual((CFTypeRef)cf1, (CFTypeRef)v9), (_DWORD)result))
  {
    v10 = *(_QWORD *)(v8 + 48);
    if (!(a3 | v10) || a3 && v10 && (result = CFEqual((CFTypeRef)a3, (CFTypeRef)v10), (_DWORD)result))
    {
      v11 = 24;
      if (!*(_BYTE *)(v8 + 56))
        v11 = 16;
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v8 + 32) + 8) + 24) = *(_QWORD *)(a4 + v11);
      *a5 = 1;
    }
  }
  return result;
}

void sub_100011498(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  _QWORD v3[6];

  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100011520;
  v3[3] = &unk_10017A4C0;
  v3[4] = a1;
  v3[5] = a2;
  v2 = objc_retainBlock(v3);
  sub_1000112C4((uint64_t)&unk_1001A5420, 0x8Eu, (uint64_t)v2);
  sub_1000112C4((uint64_t)&unk_1001A6A50, 3u, (uint64_t)v2);

}

void sub_100011520(uint64_t a1, unint64_t cf1, const void *a3, uint64_t a4)
{
  unint64_t v7;
  const void *v8;
  const void *v9;

  v7 = *(_QWORD *)(a1 + 32);
  if (!(cf1 | v7) || cf1 && v7 && CFEqual((CFTypeRef)cf1, (CFTypeRef)v7))
  {
    v8 = (const void *)MGCopyAnswer(*(_QWORD *)(a4 + 16), 0);
    if (v8)
    {
      v9 = v8;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), a3, v8);
      CFRelease(v9);
    }
  }
}

NSObject **sub_1000115A8(uint64_t a1, _QWORD *a2)
{
  size_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  id v38;
  id v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  id v50;
  NSObject **v51;
  int *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  id v56;
  int v57;
  int v58;
  passwd *v59;
  uid_t pw_uid;
  gid_t pw_gid;
  int *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  NSObject **v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  uint64_t v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  const __CFString *v336;
  uint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  char v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  uint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  uint64_t v370;
  uint64_t v371;
  uint64_t v372;
  uint64_t v373;
  CFPropertyListRef v374;
  const void *v375;
  CFTypeID v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  const __CFString *v382;
  id v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  CFPropertyListRef v389;
  const void *v390;
  CFTypeID v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  CFPropertyListRef v402;
  const void *v403;
  CFTypeID v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  uint64_t v410;
  uint64_t v411;
  uint64_t v412;
  uint64_t v413;
  uint64_t v414;
  CFPropertyListRef v415;
  const void *v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  CFPropertyListRef v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  const void *v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  void *v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  int v455;
  uint64_t v456;
  uint64_t v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  const char *v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  _BOOL4 v474;
  const __CFString *v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  const __CFString *v481;
  uint64_t *v483;
  uint64_t v484;
  uint64_t v485;
  uint64_t v486;
  uint64_t v487;
  uint64_t v488;
  uint64_t v489;
  uint64_t v490;
  CFDataRef v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  CFDataRef v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  id v505;
  void *v506;
  id v507;
  uint64_t v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  void *v514;
  unsigned __int8 v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  uint64_t v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  id v546;
  id v547;
  uint64_t v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  id v553;
  uint64_t v554;
  uint64_t v555;
  char v556;
  char v557;
  char v558;
  uint64_t v559;
  char v560;
  char v561;
  _QWORD v562[5];
  _QWORD v563[5];
  char __s[1024];

  bzero(__s, 0x400uLL);
  sub_10000816C(__s);
  v3 = strlen(__s);
  __strncat_chk(__s, "/Library/Lockdown", 1023 - v3, 1024);
  if (mkdir(__s, 0x1C0u) && *__error() != 17)
  {
    __error();
    v34 = __error();
    strerror(*v34);
    v38 = sub_100010520((uint64_t)"lockstart_local", 481, -1, 0, CFSTR("Failed to mkdir %s: %d (%s)"), v35, v36, v37, (uint64_t)__s);
    v39 = (id)objc_claimAutoreleasedReturnValue(v38);
    v40 = __error();
    strerror(*v40);
    sub_10001A7E4(0, "lockstart_local", CFSTR("Could not mkdir %s : %s"), v41, v42, v43, v44, v45, (char)__s);
    sub_100025DA4(__s);
  }
  else
  {
    v9 = sub_10002616C(__s, 256, 0x4000, v4, v5, v6, v7, v8);
    if (v9 != -1)
    {
      v10 = v9;
      if (fchmod(v9, 0x1C0u) == -1)
      {
        __error();
        v52 = __error();
        strerror(*v52);
        v56 = sub_100010520((uint64_t)"lockstart_local", 494, -1, 0, CFSTR("Failed to chmod %s: %d (%s)"), v53, v54, v55, (uint64_t)__s);
LABEL_78:
        v39 = (id)objc_claimAutoreleasedReturnValue(v56);
        goto LABEL_79;
      }
      v16 = sub_10002616C("/private/var/db/timezone", 256, 0x4000, v11, v12, v13, v14, v15);
      if (v16 == -1)
      {
        sub_10001A7E4(0, "repair_permissions", CFSTR("no fixing up the TZ dir"), v17, v18, v19, v20, v21, v555);
      }
      else
      {
        v22 = v16;
        if (fchmod(v16, 0x16Du) == -1)
        {
          v23 = __error();
          strerror(*v23);
          sub_10001A7E4(0, "repair_permissions", CFSTR("Could not chmod %s: %s"), v24, v25, v26, v27, v28, (char)"/private/var/db/timezone");
        }
        close(v22);
      }
      v57 = sub_10002616C("/private/var/mobile/Media/ApplicationArchives", 256, 0x4000, v29, v30, v31, v32, v33);
      if (v57 == -1)
      {
        if (*__error() != 2)
        {
          v62 = __error();
          strerror(*v62);
          sub_10001A7E4(0, "repair_permissions", CFSTR("sym link: %s, error: %s"), v63, v64, v65, v66, v67, (char)"/private/var/mobile/Media/ApplicationArchives");
        }
      }
      else
      {
        v58 = v57;
        v59 = getpwnam("mobile");
        if (v59)
        {
          pw_uid = v59->pw_uid;
          pw_gid = v59->pw_gid;
        }
        else
        {
          pw_gid = 501;
          pw_uid = 501;
        }
        if (fchown(v58, pw_uid, pw_gid) == -1 && *__error() != 2)
        {
          v68 = __error();
          strerror(*v68);
          sub_10001A7E4(0, "repair_permissions", CFSTR("Could not chown %s: %s"), v69, v70, v71, v72, v73, (char)"/private/var/mobile/Media/ApplicationArchives");
        }
        close(v58);
      }
      v74 = (NSObject **)sub_10000DE40();
      if (!v74)
      {
        v383 = sub_100010520((uint64_t)"lockstart_local", 504, -1, 0, CFSTR("Failed to load data ark."), v75, v76, v77, v555);
        v39 = (id)objc_claimAutoreleasedReturnValue(v383);
        sub_10001A7E4(0, "lockstart_local", CFSTR("Failed to load data ark."), v384, v385, v386, v387, v388, v556);
LABEL_79:
        v51 = 0;
        goto LABEL_80;
      }
      v51 = v74;
      v563[0] = _NSConcreteStackBlock;
      v563[1] = 3221225472;
      v563[2] = sub_1000134F0;
      v563[3] = &unk_10017A4E0;
      v563[4] = v74;
      sub_1000112C4((uint64_t)&unk_1001A6A50, 3u, (uint64_t)v563);
      v562[0] = _NSConcreteStackBlock;
      v562[1] = 3221225472;
      v562[2] = sub_1000135F8;
      v562[3] = &unk_10017A4E0;
      v562[4] = v51;
      sub_1000112C4((uint64_t)&unk_1001A5420, 0x8Eu, (uint64_t)v562);
      if ((sub_10000EFBC((uint64_t)v51, 0, (uint64_t)CFSTR("ActivationState"), v78, v79, v80, v81, v82) & 1) == 0)
      {
        sub_10000F0FC(v51, 0, (uint64_t)CFSTR("ActivationState"), 1, v84, v85, v86, v87);
        sub_10000E484((uint64_t)v51, 0, (uint64_t)CFSTR("ActivationState"), (uint64_t)CFSTR("Unactivated"), v88, v89, v90, v91);
      }
      if (sub_10000EFBC((uint64_t)v51, 0, (uint64_t)CFSTR("WeHaveATicket"), v83, v84, v85, v86, v87))
        sub_10000EFB4((uint64_t)v51, 0, (uint64_t)CFSTR("WeHaveATicket"), v92, v93, v94, v95, v96);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("StoredIdentity"), 2, v93, v94, v95, v96);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("StoredIDBuild"), 2, v97, v98, v99, v100);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("TrustedHostAttached"), 1, v101, v102, v103, v104);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("HostAttached"), 1, v105, v106, v107, v108);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("WeHaveATicket"), 1, v109, v110, v111, v112);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("WeHaveATicket"), 2, v113, v114, v115, v116);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("LastActivated"), 2, v117, v118, v119, v120);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("InProgress"), 1, v121, v122, v123, v124);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("InProgress"), 2, v125, v126, v127, v128);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.internal"), (uint64_t)CFSTR("VoidWarranty"), 2, v129, v130, v131, v132);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("HasSiDP"), 0, v133, v134, v135, v136);
      sub_10000E484((uint64_t)v51, 0, (uint64_t)CFSTR("HasSiDP"), (uint64_t)kCFBooleanTrue, v137, v138, v139, v140);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.restriction"), (uint64_t)CFSTR("ProhibitAppInstall"), 2, v141, v142, v143, v144);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.restriction"), (uint64_t)CFSTR("ProhibitAppInstall"), 3, v145, v146, v147, v148);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.restriction"), (uint64_t)CFSTR("ProhibitAppDelete"), 2, v149, v150, v151, v152);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.restriction"), (uint64_t)CFSTR("ProhibitAppDelete"), 3, v153, v154, v155, v156);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.purplebuddy"), (uint64_t)CFSTR("SetupDone"), 3, v157, v158, v159, v160);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.purplebuddy"), (uint64_t)CFSTR("SetupFinishedAllSteps"), 3, v161, v162, v163, v164);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.fmip"), (uint64_t)CFSTR("ActivationRecord"), 2, v165, v166, v167, v168);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("IntegratedCircuitCardIdentity"), 1, v169, v170, v171, v172);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("IntegratedCircuitCardIdentity2"), 1, v173, v174, v175, v176);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("InternationalMobileSubscriberIdentity"), 1, v177, v178, v179, v180);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.lockdown.paired_hosts"), 0, 1, v181, v182, v183, v184);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("InverseDeviceID"), 2, v185, v186, v187, v188);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("SIMStatus"), 1, v189, v190, v191, v192);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("PreviousSIMStatus"), 2, v193, v194, v195, v196);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.backup"), (uint64_t)CFSTR("Version"), 1, v197, v198, v199, v200);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("PhoneNumber"), 1, v201, v202, v203, v204);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.disk_usage"), (uint64_t)CFSTR("MobileApplicationUsage"), 1, v205, v206, v207, v208);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.disk_usage.factory"), (uint64_t)CFSTR("MobileApplicationUsage"), 1, v209, v210, v211, v212);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("FirstPurpleBuddyCompletion"), 2, v213, v214, v215, v216);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.iTunes"), (uint64_t)CFSTR("iTunesSetupComplete"), 0, v217, v218, v219, v220);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.iTunes"), (uint64_t)CFSTR("FamilyID"), 0, v221, v222, v223, v224);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.iTunes"), (uint64_t)CFSTR("MinITunesVersion"), 0, v225, v226, v227, v228);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.iTunes"), (uint64_t)CFSTR("MinMacOSVersion"), 0, v229, v230, v231, v232);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("UntrustedHostBUID"), 0, v233, v234, v235, v236);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("UntrustedHostBUID"), 8, v237, v238, v239, v240);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("UntrustedHostBUID"), 7, v241, v242, v243, v244);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.smf"), (uint64_t)CFSTR("ScienceReportComplete"), 0, v245, v246, v247, v248);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.smf"), (uint64_t)CFSTR("IDLastSeenAtBoot"), 0, v249, v250, v251, v252);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.smf"), (uint64_t)CFSTR("IDLastSeenAtBootBuild"), 0, v253, v254, v255, v256);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("IDAMConfig"), 0, v257, v258, v259, v260);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("DevicePublicKey"), 1, v261, v262, v263, v264);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("DevicePublicKey"), 0, v265, v266, v267, v268);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("DevicePrivateKey"), 1, v269, v270, v271, v272);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("DevicePrivateKey"), 2, v273, v274, v275, v276);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiPairing"), 0, v277, v278, v279, v280);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiPairing"), 9, v281, v282, v283, v284);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiDebugging"), 0, v285, v286, v287, v288);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiDebugging"), 9, v289, v290, v291, v292);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiConnections"), 0, v293, v294, v295, v296);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("PreflightInfo"), 0, v297, v298, v299, v300);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("ApParameters"), 0, v301, v302, v303, v304);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.lockdown.datamigrator"), (uint64_t)CFSTR("MigrationDone"), 0, v305, v306, v307, v308);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.lockdown.datamigrator"), (uint64_t)CFSTR("MigrationDone"), 6, v309, v310, v311, v312);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("DeviceName"), 0, v313, v314, v315, v316);
      v321 = sub_10000F0FC(v51, 0, (uint64_t)CFSTR("DeviceName"), 6, v317, v318, v319, v320);
      v336 = sub_10000841C(v321, v322, v323, v324, v325, v326, v327, v328);
      if (v336 || (v336 = (const __CFString *)MGCopyAnswer(CFSTR("MarketingDeviceFamilyName"), 0)) != 0)
      {
        sub_1000084E0(v336, v329, v330, v331, v332, v333, v334, v335);
        sub_10000E484((uint64_t)v51, 0, (uint64_t)CFSTR("DeviceName"), (uint64_t)v336, v337, v338, v339, v340);
        v341 = 0;
      }
      else
      {
        v341 = 1;
      }
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("DarkProductVersion"), 2, v332, v333, v334, v335);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("ProductName"), 6, v342, v343, v344, v345);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("HardwareModel"), 6, v346, v347, v348, v349);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("ProductVersion"), 6, v350, v351, v352, v353);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("HumanReadableProductVersionString"), 6, v354, v355, v356, v357);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("ProductType"), 6, v358, v359, v360, v361);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("CPUArchitecture"), 6, v362, v363, v364, v365);
      sub_10000F0FC(v51, 0, (uint64_t)CFSTR("SupportedDeviceFamilies"), 6, v366, v367, v368, v369);
      sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.lockdown.paired_host_info"), 0, 10, v370, v371, v372, v373);
      if ((v341 & 1) == 0)
        CFRelease(v336);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.mobile.backup"), 0, (uint64_t)CFSTR("com.apple.mobile.backup.domain_changed"), 4);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.mobile.data_sync"), 0, (uint64_t)CFSTR("com.apple.mobile.data_sync.domain_changed"), 1);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiDebugging"), (uint64_t)CFSTR("com.apple.mobile.lockdown.BonjourServiceChanged"), 6);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiConnections"), (uint64_t)CFSTR("com.apple.mobile.lockdown.BonjourServiceChanged"), 6);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiPairing"), (uint64_t)CFSTR("com.apple.mobile.lockdown.BonjourPairingServiceChanged"), 6);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.disk_usage"), (uint64_t)CFSTR("MobileApplicationUsage"), (uint64_t)CFSTR("com.apple.mobile.lockdown.disk_usage_changed"), 1);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.xcode.developerdomain"), (uint64_t)CFSTR("DeveloperStatus"), (uint64_t)CFSTR("com.apple.mobile.lockdown.developer_status_changed"), 6);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.purplebuddy"), (uint64_t)CFSTR("com.apple.purplebuddy.backup_state"), (uint64_t)CFSTR("com.apple.purplebuddy.backup_state"), 6);
      sub_10000DFD4(v51, (uint64_t)CFSTR("com.apple.purplebuddy"), (uint64_t)CFSTR("SetupState"), (uint64_t)CFSTR("com.apple.purplebuddy.SetupStateChanged"), 6);
      sub_10000DFD4(v51, 0, (uint64_t)CFSTR("DeviceName"), (uint64_t)CFSTR("com.apple.mobile.lockdown.device_name_changed"), 6);
      v374 = CFPreferencesCopyValue(CFSTR("LogToDisk"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
      if (!v374)
      {
LABEL_43:
        v389 = CFPreferencesCopyValue(CFSTR("ExtendedLogging"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
        if (v389)
        {
          v390 = v389;
          v391 = CFGetTypeID(v389);
          if (v391 == CFBooleanGetTypeID())
          {
            if (CFEqual(v390, kCFBooleanTrue))
            {
              sub_10001A7E4(0, "load_preferences", CFSTR("Enabling the extended logging preference"), v397, v398, v399, v400, v401, v555);
              dword_1001A6AD0 = 1;
            }
            else
            {
              sub_10001A7E4(0, "load_preferences", CFSTR("Disabling the extended logging preference"), v397, v398, v399, v400, v401, v555);
              dword_1001A6AD0 = 0;
            }
          }
          else
          {
            sub_10001A7E4(0, "load_preferences", CFSTR("Value for extended logging is not a BOOLean"), v392, v393, v394, v395, v396, v555);
          }
          CFRelease(v390);
        }
        v402 = CFPreferencesCopyValue(CFSTR("RaptorCertsPref"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
        if (v402)
        {
          v403 = v402;
          v404 = CFGetTypeID(v402);
          if (v404 == CFBooleanGetTypeID())
          {
            if (CFEqual(v403, kCFBooleanTrue))
            {
              sub_10001A7E4(0, "load_preferences", CFSTR("Enabling the raptor certs"), v410, v411, v412, v413, v414, v555);
              dword_1001A6AD4 = 1;
            }
            else
            {
              sub_10001A7E4(0, "load_preferences", CFSTR("Disabling the raptor certs"), v410, v411, v412, v413, v414, v555);
              dword_1001A6AD4 = 0;
            }
          }
          else
          {
            sub_10001A7E4(0, "load_preferences", CFSTR("Value for raptor is not a BOOLean"), v405, v406, v407, v408, v409, v555);
          }
          CFRelease(v403);
        }
        v415 = CFPreferencesCopyValue(CFSTR("DebugKDB"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
        if (v415)
        {
          v416 = v415;
          if (CFEqual(v415, kCFBooleanTrue))
          {
            sub_10001A7E4(0, "load_preferences", CFSTR("Enabling debug with kdb"), v417, v418, v419, v420, v421, v555);
            dword_1001A8FA8 = 1;
          }
          CFRelease(v416);
        }
        v422 = CFPreferencesCopyValue(CFSTR("SecureCopyValue"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
        if (v422)
        {
          v428 = v422;
          sub_10001A7E4(0, "load_preferences", CFSTR("enable lockdown paranoia"), v423, v424, v425, v426, v427, v555);
          sub_10000F0FC(v51, 0, (uint64_t)CFSTR("SecureCopyValue"), 1, v429, v430, v431, v432);
          sub_10000E484((uint64_t)v51, 0, (uint64_t)CFSTR("SecureCopyValue"), (uint64_t)CFSTR("SCVEnabled"), v433, v434, v435, v436);
          CFRelease(v428);
        }
        sub_10000E484((uint64_t)v51, 0, (uint64_t)CFSTR("ProtocolVersion"), (uint64_t)CFSTR("2"), v424, v425, v426, v427);
        sub_10000F0FC(v51, 0, (uint64_t)CFSTR("ProtocolVersion"), 0, v437, v438, v439, v440);
        if ((sub_100014BC0(v51) & 1) != 0)
        {
          if (MKBDeviceUnlockedSinceBoot() && (sub_10001497C((uint64_t)v51) & 1) == 0)
            sub_10001A7E4(0, "lockstart_local", CFSTR("Failed to upgrade pair records' protection class."), v444, v445, v446, v447, v448, v555);
          v449 = (void *)sub_10000ED98((uint64_t)v51, 0, (uint64_t)CFSTR("BuildVersion"));
          sub_10001A7E4(0, "lockstart_local", CFSTR("Build version: %@"), v450, v451, v452, v453, v454, (char)v449);
          v455 = sub_100006FB4();
          v461 = "false";
          if (v455)
            v461 = "true";
          sub_10001A7E4(0, "lockstart_local", CFSTR("Data Migration Completed: %s"), v456, v457, v458, v459, v460, (char)v461);
          sub_100029284((uint64_t)v51, v462, v463, v464, v465, v466, v467, v468);
          v474 = sub_10002939C();
          if (v474)
            v475 = CFSTR("using Raptor Certs");
          else
            v475 = CFSTR("old school Certs");
          sub_10001A7E4(0, "_load_product_type", v475, v469, v470, v471, v472, v473, v557);
          if (dword_1001A6AD4 == 1)
          {
            v481 = CFSTR("use raptor certs by overriding old school - this is almost never correct");
          }
          else
          {
            if (dword_1001A6AD4)
            {
              v483 = (uint64_t *)&kCFBooleanFalse;
              if (v474)
                v483 = (uint64_t *)&kCFBooleanTrue;
              goto LABEL_88;
            }
            v481 = CFSTR("use old school certs with raptor override");
          }
          sub_10001A7E4(0, "_load_product_type", v481, v476, v477, v478, v479, v480, v558);
          v483 = (uint64_t *)&kCFBooleanFalse;
LABEL_88:
          sub_10000E484((uint64_t)v51, 0, (uint64_t)CFSTR("UseRaptorCerts"), *v483, v477, v478, v479, v480);
          sub_100012A4C(v51, v484, v485, v486, v487, v488, v489, v490, v558);
          v491 = sub_1000086EC(v51);
          if (v491)
          {
            v497 = v491;
            sub_10000F0FC(v51, (uint64_t)CFSTR("com.apple.mobile.iTunes"), (uint64_t)CFSTR("FairPlayCertificate"), 1, v493, v494, v495, v496);
            sub_10000E484((uint64_t)v51, (uint64_t)CFSTR("com.apple.mobile.iTunes"), (uint64_t)CFSTR("FairPlayCertificate"), (uint64_t)v497, v498, v499, v500, v501);
            CFRelease(v497);
          }
          else
          {
            sub_10001A7E4(0, "_load_cesm_certificate", CFSTR("Could not extract necessary certificate"), v492, v493, v494, v495, v496, v559);
          }
          v505 = sub_100026844();
          if (v505)
          {
            v506 = (void *)sub_10000ED98((uint64_t)v51, 0, (uint64_t)CFSTR("BootSessionID"));
            v507 = sub_10001B244(v506);
            v508 = objc_claimAutoreleasedReturnValue(v507);
            if (!v508
              || (v514 = (void *)v508,
                  v515 = objc_msgSend(v506, "isEqualToString:", v505),
                  v514,
                  (v515 & 1) == 0))
            {
              sub_10001A7E4(0, "performBootSessionIntialization", CFSTR("Boot session changed (reboot detected)."), v509, v510, v511, v512, v513, v559);
              if ((sub_100027234((uint64_t)v51, v516, v517, v518, v519, v520, v521, v522) & 1) == 0)
              {
                sub_10001A7E4(0, "performBootSessionIntialization", CFSTR("Device is in buddy upon new boot session, deleting all existing pair records."), v523, v524, v525, v526, v527, v560);
                sub_100014F6C(1);
                sub_100028980();
                sub_100012D98(1, v528, v529, v530, v531, v532, v533, v534, v561);
              }
              sub_100026060((uint64_t)"/private/var/mobile/Media/PublicStaging");
              sub_10000E484((uint64_t)v51, 0, (uint64_t)CFSTR("BootSessionID"), (uint64_t)v505, v535, v536, v537, v538);
              sub_10000E1DC(v51, v539, v540, v541, v542, v543, v544, v545, v560);
            }
            v546 = 0;
          }
          else
          {
            v547 = sub_100010628((uint64_t)"performBootSessionIntialization", 392, -1, 0, CFSTR("Failed to copy boot session UUID."), v502, v503, v504, v559);
            v546 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(v547));

            v506 = 0;
          }

          v39 = v546;
          if (v505)
          {
            sub_10000EFB4((uint64_t)v51, 0, (uint64_t)CFSTR("ActivationState"), v548, v549, v550, v551, v552);
            sub_100013DFC(v51);
            sub_10002712C(v51);

          }
          else
          {
            v553 = sub_100010520((uint64_t)"lockstart_local", 563, -1, v39, CFSTR("Failed to initialize boot session."), v550, v551, v552, v559);
            v554 = objc_claimAutoreleasedReturnValue(v553);

            v51 = 0;
            v39 = (id)v554;
          }
LABEL_80:
          close(v10);
          if (!a2)
            goto LABEL_83;
          goto LABEL_81;
        }
        v56 = sub_100010520((uint64_t)"lockstart_local", 539, -1, 0, CFSTR("Failed to perform migration tasks."), v441, v442, v443, v555);
        goto LABEL_78;
      }
      v375 = v374;
      v376 = CFGetTypeID(v374);
      if (v376 == CFBooleanGetTypeID())
      {
        if (!CFEqual(v375, kCFBooleanTrue))
        {
          sub_10001A7E4(0, "load_preferences", CFSTR("Disabling the log to disk preference"), v377, v378, v379, v380, v381, v555);
          dword_1001A6AD8 = 0;
          goto LABEL_42;
        }
        dword_1001A6AD8 = 1;
        v382 = CFSTR("Enabling the log to disk preference");
      }
      else
      {
        v382 = CFSTR("Value for disk logging is not a BOOLean");
      }
      sub_10001A7E4(0, "load_preferences", v382, v377, v378, v379, v380, v381, v555);
LABEL_42:
      CFRelease(v375);
      goto LABEL_43;
    }
    __error();
    v46 = __error();
    strerror(*v46);
    v50 = sub_100010520((uint64_t)"lockstart_local", 489, -1, 0, CFSTR("Failed to open %s: %d (%s)"), v47, v48, v49, (uint64_t)__s);
    v39 = (id)objc_claimAutoreleasedReturnValue(v50);
  }
  v51 = 0;
  if (!a2)
    goto LABEL_83;
LABEL_81:
  if (!v51)
    *a2 = v39;
LABEL_83:

  return v51;
}

void sub_100012A4C(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  int v22;
  CFNumberRef v23;
  CFNumberRef v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v33;
  int valuePtr;
  _QWORD v35[3];

  memset(v35, 0, sizeof(v35));
  valuePtr = 0;
  if (sub_100029244())
  {
    sub_10001A7E4(0, "bringup_stuff_ok", CFSTR("FPGA workaround enabled, no stuff"), v10, v11, v12, v13, v14, a9);
    return;
  }
  sub_10005843C(0, 0, (uint64_t)v35);
  if (v15)
  {
    v33 = v15;
    v21 = CFSTR("FairPlayGetHWInfo failed: %ld");
LABEL_7:
    LODWORD(v23) = 0;
    goto LABEL_8;
  }
  v22 = sub_100074F04(0, (uint64_t)v35, (uint64_t)"/private/var/mobile/Media/iTunes_Control/iTunes", (uint64_t)&valuePtr);
  if (v22)
  {
    v33 = v22;
    v21 = CFSTR("FairPlayInitContext failed: %ld");
    goto LABEL_7;
  }
  v23 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (v23)
  {
    v24 = v23;
    sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.fairplay"), (uint64_t)CFSTR("FairPlayContextID"), 1, v17, v18, v19, v20);
    sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.fairplay"), (uint64_t)CFSTR("FairPlayContextID"), 2, v25, v26, v27, v28);
    sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.fairplay"), (uint64_t)CFSTR("FairPlayContextID"), (uint64_t)v24, v29, v30, v31, v32);
    CFRelease(v24);
    return;
  }
  v21 = CFSTR("Failed to create number.");
LABEL_8:
  sub_10001A7E4((int)v23, "create_cesm_context", v21, v16, v17, v18, v19, v20, v33);
}

_QWORD *sub_100012BF8(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  char v68;
  char v69;
  char v70;
  char v71;
  char v72;
  char v73;

  sub_100012D98(0, a2, a3, a4, a5, a6, a7, a8, v68);
  v9 = sub_100019B08((uint64_t)a1);
  sub_100013B6C(a1, (uint64_t)CFSTR("Bookmarks"), 0, v10, v11, v12, v13, v14, v69);
  sub_100013B6C(a1, (uint64_t)CFSTR("Calendars"), 0, v15, v16, v17, v18, v19, v70);
  sub_100013B6C(a1, (uint64_t)CFSTR("Contacts"), 0, v20, v21, v22, v23, v24, v71);
  sub_100013B6C(a1, (uint64_t)CFSTR("Mail Accounts"), 1, v25, v26, v27, v28, v29, v72);
  sub_100013B6C(a1, (uint64_t)CFSTR("Notes"), 0, v30, v31, v32, v33, v34, v73);
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("DeviceHandlesDefaultCalendar"), 1, v35, v36, v37, v38);
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("SyncSupportsCalDAV"), 1, v39, v40, v41, v42);
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("SupportsEncryptedBackups"), 1, v43, v44, v45, v46);
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("DeviceSupportsClearingData"), 1, v47, v48, v49, v50);
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("DeviceHandlesDefaultCalendar"), (uint64_t)kCFBooleanTrue, v51, v52, v53, v54);
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("SyncSupportsCalDAV"), (uint64_t)kCFBooleanTrue, v55, v56, v57, v58);
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("SupportsEncryptedBackups"), (uint64_t)kCFBooleanTrue, v59, v60, v61, v62);
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), (uint64_t)CFSTR("DeviceSupportsClearingData"), (uint64_t)kCFBooleanTrue, v63, v64, v65, v66);
  sub_10000A8E8(a1);
  return v9;
}

void sub_100012D98(char a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _QWORD block[4];
  char v11;

  if (qword_1001A7FF0 != -1)
    dispatch_once(&qword_1001A7FF0, &stru_10017A500);
  if (qword_1001A7FE8)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000137B0;
    block[3] = &unk_10017A520;
    v11 = a1;
    dispatch_sync((dispatch_queue_t)qword_1001A7FE8, block);
  }
  else
  {
    sub_10001A7E4(0, "_pairing_keypair_worker", CFSTR("Invalid queue."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100012E48(NSObject **a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  id v13;
  uint64_t v14;
  void *i;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  id v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  const __CFArray *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __CFArray *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  __CFArray *v47;
  const __CFArray *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const __CFArray *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  CFMutableDictionaryRef v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  CFIndex Count;
  CFIndex v67;
  uint64_t v68;
  CFIndex v69;
  const __CFDictionary *v70;
  CFIndex v71;
  const __CFDictionary *v72;
  const void *Value;
  const void *v74;
  const void *v75;
  const void *v76;
  int v77;
  BOOL v78;
  CFLocaleIdentifier CanonicalLocaleIdentifierFromString;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  CFLocaleIdentifier v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  __CFArray *v92;
  const __CFString *v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  const __CFArray *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  const __CFArray *v115;
  const void *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  CFPropertyListRef v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  CFTypeRef v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  const __CFArray *v140;
  char v141;
  const __CFArray *v142;
  NSObject **v143;
  const __CFArray *v144;
  __CFArray *theArray;
  CFIndex v146;
  __CFDictionary *v147;
  const __CFString *ValueAtIndex;
  __int128 v149;
  __int128 v150;
  __int128 v151;
  __int128 v152;
  _BYTE v153[128];

  v2 = objc_alloc_init((Class)NSMutableArray);
  v8 = v2;
  if (!v2)
  {
    v93 = CFSTR("Failed to create array.");
LABEL_44:
    sub_10001A7E4((int)v2, "load_supported_languages", v93, v3, v4, v5, v6, v7, v141);
LABEL_48:

    goto LABEL_49;
  }
  v9 = (void *)objc_claimAutoreleasedReturnValue(+[IPLanguageListGenerator generator](IPLanguageListGenerator, "generator"));
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "deviceLanguagesForChangingDeviceLanguage:", 1));

  if (!v10)
  {
    v93 = CFSTR("Failed to query IntlPreferences languages.");
    LODWORD(v2) = 0;
    goto LABEL_44;
  }
  v151 = 0u;
  v152 = 0u;
  v149 = 0u;
  v150 = 0u;
  v11 = v10;
  v12 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v149, v153, 16);
  if (v12)
  {
    v13 = v12;
    v14 = *(_QWORD *)v150;
    do
    {
      for (i = 0; i != v13; i = (char *)i + 1)
      {
        if (*(_QWORD *)v150 != v14)
          objc_enumerationMutation(v11);
        v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v149 + 1) + 8 * (_QWORD)i), "identifier"));
        objc_msgSend(v8, "addObject:", v16);

      }
      v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v149, v153, 16);
    }
    while (v13);
  }

  v17 = objc_claimAutoreleasedReturnValue(+[NSLocale systemLanguages](NSLocale, "systemLanguages"));
  if (!v17)
  {
    sub_10001A7E4(0, "load_supported_languages", CFSTR("Failed to query system languages."), v18, v19, v20, v21, v22, v141);
LABEL_47:

    goto LABEL_48;
  }
  v23 = (void *)v17;
  v24 = objc_msgSend(objc_alloc((Class)NSMutableSet), "initWithArray:", v8);
  if (!v24)
  {
    sub_10001A7E4(0, "load_supported_languages", CFSTR("Failed to create set."), v25, v26, v27, v28, v29, v141);

    goto LABEL_47;
  }
  v30 = v24;
  objc_msgSend(v24, "addObjectsFromArray:", v23);
  v31 = (const __CFArray *)objc_claimAutoreleasedReturnValue(objc_msgSend(v30, "allObjects"));

  if (!v31)
  {
LABEL_49:
    sub_10001A7E4(0, "load_international_filters", CFSTR("Failed to load supported languages."), v32, v33, v34, v35, v36, v141);
    return;
  }
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("SupportedLanguages"), 1, v33, v34, v35, v36);
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("SupportedLanguages"), (uint64_t)v31, v37, v38, v39, v40);
  v41 = sub_100013670(v31);
  if (!v41)
  {
    sub_10001A7E4(0, "load_supported_locales", CFSTR("Failed to create locale maps for supported languages."), v42, v43, v44, v45, v46, v141);
LABEL_63:
    sub_10001A7E4(0, "load_international_filters", CFSTR("Failed to load supported locales."), v94, v95, v96, v97, v98, v141);
    v140 = v31;
LABEL_64:
    CFRelease(v140);
    return;
  }
  v47 = v41;
  v48 = CFLocaleCopyAvailableLocaleIdentifiers();
  if (!v48)
  {
    sub_10001A7E4(0, "load_supported_locales", CFSTR("Failed to copy available locale identifiers."), v49, v50, v51, v52, v53, v141);
    CFRelease(v47);
    goto LABEL_63;
  }
  v54 = v48;
  theArray = sub_100013670(v48);
  if (theArray)
  {
    v60 = sub_100025A4C();
    if (v60)
    {
      v147 = v60;
      v143 = a1;
      Count = CFArrayGetCount(v54);
      v142 = v31;
      v67 = CFArrayGetCount(v31);
      if (Count >= 1)
      {
        v68 = v67;
        v69 = 0;
        v144 = v54;
        while (1)
        {
          ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v54, v69);
          v146 = v69;
          v70 = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v69);
          if (CFDictionaryContainsKey(v70, kCFLocaleCountryCode))
          {
            if (v68 >= 1)
              break;
          }
LABEL_38:
          v69 = v146 + 1;
          v54 = v144;
          if (v146 + 1 == Count)
            goto LABEL_39;
        }
        v71 = 0;
        while (1)
        {
          v72 = (const __CFDictionary *)CFArrayGetValueAtIndex(v47, v71);
          Value = CFDictionaryGetValue(v70, kCFLocaleLanguageCode);
          v74 = CFDictionaryGetValue(v72, kCFLocaleLanguageCode);
          v75 = CFDictionaryGetValue(v70, kCFLocaleScriptCode);
          v76 = CFDictionaryGetValue(v72, kCFLocaleScriptCode);
          if (Value && v74)
          {
            v77 = CFEqual(Value, v74);
            v78 = v77 != 0;
            if (v75)
              goto LABEL_29;
            if (v77)
              goto LABEL_34;
          }
          else if (v75)
          {
            v78 = 0;
LABEL_29:
            if (!v76)
              goto LABEL_37;
            if (!CFEqual(v75, v76) || !v78)
              goto LABEL_37;
LABEL_34:
            CanonicalLocaleIdentifierFromString = CFLocaleCreateCanonicalLocaleIdentifierFromString(kCFAllocatorDefault, ValueAtIndex);
            if (CanonicalLocaleIdentifierFromString)
            {
              v86 = CanonicalLocaleIdentifierFromString;
              CFDictionarySetValue(v147, CanonicalLocaleIdentifierFromString, kCFBooleanTrue);
              CFRelease(v86);
            }
            else
            {
              sub_10001A7E4(0, "load_supported_locales", CFSTR("Could not create canonical locale identifier"), v81, v82, v83, v84, v85, v141);
            }
          }
LABEL_37:
          if (v68 == ++v71)
            goto LABEL_38;
        }
      }
LABEL_39:
      v92 = sub_100025AEC(v147);
      if (!v92)
        sub_10001A7E4(0, "load_supported_locales", CFSTR("Failed to copy supported locales."), v87, v88, v89, v90, v91, v141);
      CFRelease(v147);
      v31 = v142;
      a1 = v143;
    }
    else
    {
      sub_10001A7E4(0, "load_supported_locales", CFSTR("Failed to create dictionary."), v61, v62, v63, v64, v65, v141);
      v92 = 0;
    }
    CFRelease(theArray);
  }
  else
  {
    sub_10001A7E4(0, "load_supported_locales", CFSTR("Failed to create locale maps for available locales."), v55, v56, v57, v58, v59, v141);
    v92 = 0;
  }
  CFRelease(v54);
  CFRelease(v47);
  if (!v92)
    goto LABEL_63;
  sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("SupportedLocales"), 1, v95, v96, v97, v98);
  sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("SupportedLocales"), (uint64_t)v92, v99, v100, v101, v102);
  v109 = (const __CFArray *)sub_10001AE30(CFSTR("AppleLanguages"), 0, v103, v104, v105, v106, v107, v108);
  v115 = v109;
  if (!v109)
  {
    sub_10001A7E4(0, "load_international_filters", CFSTR("Failed to copy %@."), v110, v111, v112, v113, v114, (char)CFSTR("AppleLanguages"));
LABEL_67:
    v130 = 0;
    goto LABEL_68;
  }
  v116 = CFArrayGetValueAtIndex(v109, 0);
  if (!v116)
  {
    sub_10001A7E4(0, "load_international_filters", CFSTR("Failed to query the first language in the list."), v118, v119, v120, v121, v122, v141);
    goto LABEL_67;
  }
  v123 = (uint64_t)v116;
  v124 = sub_10001AE30(CFSTR("AppleLocale"), 0, v117, v118, v119, v120, v121, v122);
  v130 = v124;
  if (v124)
  {
    if (!sub_100010BA8(v124))
    {
      sub_10001A7E4(0, "load_international_filters", CFSTR("Using default locale en_US."), v131, v132, v133, v134, v135, v141);
      CFRelease(v130);
      v130 = CFRetain(CFSTR("en_US"));
    }
    sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("Language"), v123, v132, v133, v134, v135);
    sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("Locale"), (uint64_t)v130, v136, v137, v138, v139);
  }
  else
  {
    sub_10001A7E4(0, "load_international_filters", CFSTR("Failed to copy %@."), v125, v126, v127, v128, v129, (char)CFSTR("AppleLocale"));
  }
LABEL_68:
  CFRelease(v92);
  CFRelease(v31);
  if (v115)
    CFRelease(v115);
  if (v130)
  {
    v140 = (const __CFArray *)v130;
    goto LABEL_64;
  }
}

void sub_1000134F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  NSObject **v9;
  uint64_t v10;

  v8 = *(unsigned __int8 *)(a4 + 32);
  v9 = *(NSObject ***)(a1 + 32);
  v10 = *(_QWORD *)(a4 + 16);
  if (v8)
    sub_100013538(v9, a2, a3, v10, 2, a6, a7, a8, 1);
  else
    sub_100013538(v9, a2, a3, v10, 1, a6, a7, a8, 1);
}

void sub_100013538(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  int v13;
  unsigned int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  uint64_t *v21;

  v21 = &a9;
  if ((int)a5 >= 1)
  {
    v13 = a5;
    do
    {
      v14 = (unsigned int *)v21++;
      sub_10000F0FC(a1, a2, a3, *v14, a5, a6, a7, a8);
      --v13;
    }
    while (v13);
  }
  sub_10000F0FC(a1, a2, a3, 4, a5, a6, a7, a8);
  v15 = MGCopyAnswer(a4, 0);
  if (v15)
  {
    v20 = (const void *)v15;
    sub_10000E484((uint64_t)a1, a2, a3, v15, v16, v17, v18, v19);
    CFRelease(v20);
  }
}

uint64_t sub_1000135F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  sub_10000F0FC(*(NSObject ***)(a1 + 32), a2, a3, 1, a5, a6, a7, a8);
  result = sub_10000F0FC(*(NSObject ***)(a1 + 32), a2, a3, 4, v12, v13, v14, v15);
  if (*(_BYTE *)(a4 + 32))
    return sub_10000F0FC(*(NSObject ***)(a1 + 32), a2, a3, 0, v17, v18, v19, v20);
  return result;
}

__CFArray *sub_100013670(const __CFArray *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __CFArray *v7;
  CFIndex Count;
  CFIndex v9;
  CFIndex i;
  const __CFString *ValueAtIndex;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  CFDictionaryRef ComponentsFromLocaleIdentifier;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFDictionaryRef v24;
  char v26;

  v7 = sub_100025AA0();
  if (v7)
  {
    Count = CFArrayGetCount(a1);
    if (Count >= 1)
    {
      v9 = Count;
      for (i = 0; i != v9; ++i)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(a1, i);
        if (ValueAtIndex)
        {
          v17 = (char)ValueAtIndex;
          ComponentsFromLocaleIdentifier = CFLocaleCreateComponentsFromLocaleIdentifier(kCFAllocatorDefault, ValueAtIndex);
          if (ComponentsFromLocaleIdentifier)
          {
            v24 = ComponentsFromLocaleIdentifier;
            CFArrayAppendValue(v7, ComponentsFromLocaleIdentifier);
            CFRelease(v24);
          }
          else
          {
            sub_10001A7E4(0, "build_locale_maps", CFSTR("Failed to create dictionary of locale components for %@."), v19, v20, v21, v22, v23, v17);
          }
        }
        else
        {
          sub_10001A7E4(0, "build_locale_maps", CFSTR("Failed to extract locale identifier %ld of %ld."), v12, v13, v14, v15, v16, i);
        }
      }
    }
  }
  else
  {
    sub_10001A7E4(0, "build_locale_maps", CFSTR("Failed to create array."), v2, v3, v4, v5, v6, v26);
  }
  return v7;
}

void sub_100013784(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.mobile.lockdown.pair", 0);
  v2 = (void *)qword_1001A7FE8;
  qword_1001A7FE8 = (uint64_t)v1;

}

void sub_1000137B0(uint64_t a1)
{
  __CFDictionary *Mutable;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __CFDictionary *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  UInt8 *v21;
  const __CFData *v22;
  int v23;
  off_t st_size;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  UInt8 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFData *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const __CFString *v42;
  int v43;
  int *v44;
  const __CFString *v45;
  char v46;
  CFTypeRef result;
  stat v48;
  char __str[1024];
  char v50[1024];

  bzero(v50, 0x400uLL);
  bzero(__str, 0x400uLL);
  memset(&v48, 0, sizeof(v48));
  result = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    sub_10001A7E4(0, "_check_keypair", CFSTR("Failed to allocate dictionary."), v3, v4, v5, v6, v7, v46);
    goto LABEL_24;
  }
  v8 = Mutable;
  CFDictionarySetValue(Mutable, kSecClass, kSecClassKey);
  CFDictionarySetValue(v8, kSecAttrAccessGroup, CFSTR("lockdown-identities"));
  CFDictionarySetValue(v8, kSecAttrLabel, CFSTR("com.apple.lockdown.pairingkeypair"));
  CFDictionaryAddValue(v8, kSecUseSystemKeychain, kCFBooleanTrue);
  if (SecItemCopyMatching(v8, &result) != -25300)
  {
    v21 = 0;
    v22 = 0;
    v23 = 1;
    v15 = -1;
    goto LABEL_13;
  }
  sub_1000155C4();
  sub_10000816C(v50);
  snprintf(__str, 0x400uLL, "%s%s", v50, "/Library/Lockdown/device_private_key.pem");
  v14 = sub_10002616C(__str, 256, 0x8000, v9, v10, v11, v12, v13);
  v15 = v14;
  if (v14 == -1)
    goto LABEL_10;
  if (fstat(v14, &v48))
  {
    sub_10001A7E4(0, "_check_keypair", CFSTR("Failed to fstat %s"), v16, v17, v18, v19, v20, (char)__str);
LABEL_10:
    v21 = 0;
LABEL_11:
    v22 = 0;
LABEL_12:
    v23 = 0;
    goto LABEL_13;
  }
  st_size = v48.st_size;
  if (v48.st_size >= (uint64_t)&_mh_execute_header)
  {
    sub_10001A7E4(0, "_check_keypair", CFSTR("Invalid file size."), v16, v17, v18, v19, v20, v46);
    goto LABEL_10;
  }
  v30 = (UInt8 *)malloc_type_malloc(v48.st_size, 0xCAC4A62uLL);
  v21 = v30;
  if (!v30)
  {
    v42 = CFSTR("Failed to allocate memory.");
LABEL_36:
    sub_10001A7E4((int)v30, "_check_keypair", v42, v31, v32, v33, v34, v35, v46);
    goto LABEL_11;
  }
  if (read(v15, v30, st_size) <= 0)
  {
    v43 = *__error();
    v44 = __error();
    strerror(*v44);
    v46 = v43;
    v42 = CFSTR("Failed to read bytes: %d (%s)");
    LODWORD(v30) = 0;
    goto LABEL_36;
  }
  v36 = CFDataCreate(0, v21, st_size);
  v22 = v36;
  if (!v36)
  {
    v45 = CFSTR("Failed to create data.");
LABEL_40:
    sub_10001A7E4((int)v36, "_check_keypair", v45, v37, v38, v39, v40, v41, v46);
    goto LABEL_12;
  }
  v36 = (const __CFData *)sub_100010260(v36);
  result = v36;
  if (!v36)
  {
    v45 = CFSTR("Failed to create key.");
    goto LABEL_40;
  }
  if ((sub_10000FE38(v36) & 1) == 0)
  {
    v45 = CFSTR("Failed to store key pair.");
    LODWORD(v36) = 0;
    goto LABEL_40;
  }
  sub_1000110EC(CFSTR("com.apple.mobile.lockdown.BonjourServiceChanged"));
  v23 = 1;
LABEL_13:
  CFRelease(v8);
  if (result)
    CFRelease(result);
  result = 0;
  if (v22)
    CFRelease(v22);
  if (v21)
    free(v21);
  if (v15 == -1)
  {
    if (!v23)
      goto LABEL_24;
LABEL_23:
    if (!*(_BYTE *)(a1 + 32))
      return;
    goto LABEL_24;
  }
  close(v15);
  if ((v23 & 1) != 0)
    goto LABEL_23;
LABEL_24:
  if (sub_10000FB88(2048))
  {
    sub_10001A7E4(0, "_pairing_keypair_worker_block_invoke_2", CFSTR("Failed to generate keypair."), v25, v26, v27, v28, v29, v46);
  }
  else
  {
    sub_10001A7E4(0, "_pairing_keypair_worker_block_invoke_2", CFSTR("Destroying old pair records."), v25, v26, v27, v28, v29, v46);
    sub_100014F6C(0);
  }
}

void sub_100013B6C(NSObject **a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFDictionary *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v12 = sub_100025A4C();
  if (v12)
  {
    v18 = v12;
    if (a3)
      CFDictionarySetValue(v12, CFSTR("ReadOnly"), kCFBooleanTrue);
    sub_10000F0FC(a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), a2, 1, v14, v15, v16, v17);
    sub_10000E484((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.sync_data_class"), a2, (uint64_t)v18, v19, v20, v21, v22);
    CFRelease(v18);
  }
  else
  {
    sub_10001A7E4(0, "_insert_data_class", CFSTR("Failed to create dictionary."), v13, v14, v15, v16, v17, a9);
  }
}

uint64_t sub_100013C1C(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char vars0;

  if (result)
  {
    result = CFEqual((CFTypeRef)result, CFSTR("com.apple.mobile.user_preferences"));
    if ((_DWORD)result)
    {
      if (dword_1001A6AD0)
        sub_10001A7E4(0, "is_userprefs_domain", CFSTR("kLockdownUserPreferencesDomainKey is the domain"), v1, v2, v3, v4, v5, vars0);
      return 1;
    }
  }
  return result;
}

CFPropertyListRef sub_100013C70(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  if (a2)
  {
    if (sub_100013C1C((uint64_t)a1))
    {
      sub_10001A7E4(0, "copy_userprefs_value", CFSTR("copying %@ domain: %@ key"), v10, v11, v12, v13, v14, (char)a1);
      return sub_10001AE30(a2, a1, v15, v16, v17, v18, v19, v20);
    }
  }
  else
  {
    sub_10001A7E4(0, "copy_userprefs_value", CFSTR("getting NULL for %@ domain is unsupported"), a4, a5, a6, a7, a8, (char)a1);
  }
  return 0;
}

uint64_t sub_100013CFC(const __CFString *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFString *v22;
  char v24;

  if (!a2)
  {
    sub_10001A7E4(0, "set_userprefs_value", CFSTR("setting NULL for %@ domain is unsupported"), a4, a5, a6, a7, a8, (char)a1);
    return 0;
  }
  if (!sub_100013C1C((uint64_t)a1))
  {
    v22 = CFSTR("unsupported domain");
    goto LABEL_10;
  }
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "set_userprefs_value", CFSTR("setting %@ domain: %@ key: %@ value"), v11, v12, v13, v14, v15, (char)a1);
  v16 = (const __CFString *)sub_100010BA8(a2);
  if (sub_10001AD28(v16, a3, a1, v17, v18, v19, v20, v21))
  {
    if (dword_1001A6AD0)
    {
      v22 = CFSTR("not set");
LABEL_10:
      sub_10001A7E4(0, "set_userprefs_value", v22, v11, v12, v13, v14, v15, v24);
    }
    return 0;
  }
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "set_userprefs_value", CFSTR("set"), v11, v12, v13, v14, v15, v24);
  return 1;
}

void sub_100013DFC(NSObject **a1)
{
  const __CFDictionary *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;
  char v22;
  char v23;
  _QWORD v24[7];
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  char v28;

  v25 = 0;
  v26 = &v25;
  v27 = 0x2000000000;
  v28 = 0;
  v2 = (const __CFDictionary *)sub_10000ED98((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.user_preferences"), 0);
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000;
  v24[2] = sub_100013EF0;
  v24[3] = &unk_10017A548;
  v24[5] = CFSTR("com.apple.mobile.user_preferences");
  v24[6] = a1;
  v24[4] = &v25;
  sub_1000258E8(v2, v24);
  CFRelease(v2);
  v3 = *((unsigned __int8 *)v26 + 24);
  _Block_object_dispose(&v25, 8);
  if (v3)
  {
    sub_10001A7E4(0, "migrate_userprefs_values", CFSTR("kLockdownUserPreferencesDomainKey migrated"), v4, v5, v6, v7, v8, v21);
    sub_10001A7E4(0, "migrate_userprefs_values", CFSTR("flushing changes to the data ark"), v9, v10, v11, v12, v13, v22);
    sub_10000E1DC(a1, v14, v15, v16, v17, v18, v19, v20, v23);
  }
}

void sub_100013EF0(_QWORD *a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (sub_100013CFC((const __CFString *)a1[5], a2, a3, a4, a5, a6, a7, a8))
  {
    sub_10000EFB4(a1[6], a1[5], (uint64_t)a2, v10, v11, v12, v13, v14);
    *(_BYTE *)(*(_QWORD *)(a1[4] + 8) + 24) = 1;
  }
  else
  {
    sub_10001A7E4(0, "migrate_userprefs_domain_block_invoke", CFSTR("failed to migrate %@/%@"), v10, v11, v12, v13, v14, a1[5]);
  }
}

uint64_t sub_100013F60(uint64_t a1, char a2, char a3, uint64_t a4)
{
  id v8;
  NSObject *v9;
  id v10;
  NSObject *v11;
  uint64_t v12;
  _QWORD block[8];
  char v15;
  char v16;
  _QWORD v17[5];
  id v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  char v22;

  v19 = 0;
  v20 = &v19;
  v21 = 0x2020000000;
  v22 = 0;
  v17[0] = 0;
  v17[1] = v17;
  v17[2] = 0x3032000000;
  v17[3] = sub_1000140A4;
  v17[4] = sub_1000140B4;
  v18 = 0;
  v8 = sub_1000140BC();
  v9 = objc_claimAutoreleasedReturnValue(v8);
  dispatch_assert_queue_not_V2(v9);

  v10 = sub_1000140BC();
  v11 = objc_claimAutoreleasedReturnValue(v10);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000140FC;
  block[3] = &unk_10017A598;
  block[6] = a1;
  block[7] = a4;
  v15 = a3;
  v16 = a2;
  block[4] = v17;
  block[5] = &v19;
  dispatch_sync(v11, block);

  v12 = *((unsigned __int8 *)v20 + 24);
  _Block_object_dispose(v17, 8);

  _Block_object_dispose(&v19, 8);
  return v12;
}

void sub_100014080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000140A4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_1000140B4(uint64_t a1)
{

}

id sub_1000140BC()
{
  if (qword_1001A8050 != -1)
    dispatch_once(&qword_1001A8050, &stru_10017A888);
  return (id)qword_1001A8048;
}

void sub_1000140FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  id v17;
  uint64_t v18;
  void *v19;
  id v20;
  id v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  id v29;
  uint64_t v30;
  char v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  id v37;
  id v38;
  id v39;
  uint64_t v40;
  void *v41;
  id v42;
  const char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const __CFString *v51;
  char v52;
  id v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  _QWORD v58[4];
  id v59;
  id v60;
  uint64_t v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t v64;
  char v65;
  char v66;
  uint8_t v67[4];
  uint64_t v68;
  _BYTE v69[128];

  v10 = sub_1000267A0();
  if (!*(_QWORD *)(a1 + 48))
  {
    v51 = CFSTR("Invalid argument.");
LABEL_21:
    sub_10001A7E4(0, "cleanup_old_records_with_buid_block_invoke", v51, v11, v12, v13, v14, v15, a9);
    return;
  }
  v16 = v10;
  v17 = objc_alloc_init((Class)NSMutableSet);
  v18 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v19 = *(void **)(v18 + 40);
  *(_QWORD *)(v18 + 40) = v17;

  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40))
  {
    v51 = CFSTR("Failed to allocate set.");
    goto LABEL_21;
  }
  v20 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", "-----BEGIN CERTIFICATE-----\nMIIDPTCCAiWgAwIBAgIBATANBgkqhkiG9w0BAQsFADBOMSkwJwYDVQQDDCBUZXN0\nIEF1dG9tYXRpb24gTG9ja2Rvd24gUm9vdCBDQTEUMBIGA1UECgwLQXBwbGUsIElu\nYy4xCzAJBgNVBAYTAlVTMB4XDTE3MDkyMTAxNDIyN1oXDTE3MDkyMjAxNDIyN1ow\nTjEpMCcGA1UEAwwgVGVzdCBBdXRvbWF0aW9uIExvY2tkb3duIFJvb3QgQ0ExFDAS\nBgNVBAoMC0FwcGxlLCBJbmMuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEB\nBQADggEPADCCAQoCggEBALb4vJZBLlbrG9NE7BvAGf0WgNmgeHWKXEwM+HHTHM7x\n0gJunt5R6z+lb8lSH1/lz1VMwPV4mAoShObmLHhiYKfmdbeMzDmeOkGV6bJKNHxU\n854NJPd9e7yQkUlVXrkewsnmhRE1WytgGVpTns1JcKT7bFGiUGIFfX/l8ciLtGXA\nZ8rgeXzl2EUq62rOaNzLkHm1WAiUhWW3MU70MQXKFa3JbhLysa4XHxPqIzdmBe+N\nKHiMT3cLENYMQ/OSiIr1Ssa622+zTTaRHXT+ysc7smrgr2ZKaMY+a+oqJ00AMUJI\nXbEtMjLr5BPQqWPZSTThK2crxUwoTZuLg+PLYbApjrECAwEAAaMmMCQwEgYDVR0T\nAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAqQwDQYJKoZIhvcNAQELBQADggEB\nAD/1Hy7Sf6xE8nWiBy+ioOc7jXwWXNaRQb9lF8yAAFBtzRvkFKyN8LX+1QielIMx\n41Z8XTwv9ibhZF0ETlxZch9wduwL3wwKirBLbvqUJJ5XKW7hlUUXR7MC8trQFWIk\nntGLrtmcKSDWyWHu2eVPjJmQh+v6xetufq0u3TokqE/X+/fpPcu596mYRrovJY8g\np9gFmpAN8E4gqEfQUj9ak8aIces12cnOapL7ZHo0XHltLBBQd+4sLDO7JUlKAi2A\n"
          "SQxevep+SlLsUQYoAvr1CPxGkWuEBj/3oXhmk7EesJjDsnSnloMGoHVxxkRIipvr\n"
          "6TK70j9afDnOjNWRNmXMHLM=\n"
          "-----END CERTIFICATE-----\n",
          1184);
  if (!v20)
  {
    v51 = CFSTR("Failed to load automation root cert.");
    goto LABEL_21;
  }
  v53 = v20;
  v21 = sub_100026844();
  if (v21)
  {
    v58[0] = _NSConcreteStackBlock;
    v58[1] = 3221225472;
    v58[2] = sub_10001460C;
    v58[3] = &unk_10017A570;
    v27 = *(_QWORD *)(a1 + 56);
    v61 = *(_QWORD *)(a1 + 32);
    v62 = v27;
    v65 = *(_BYTE *)(a1 + 64);
    v28 = v21;
    v59 = v28;
    v63 = v16;
    v66 = *(_BYTE *)(a1 + 65);
    v29 = v53;
    v30 = *(_QWORD *)(a1 + 48);
    v60 = v29;
    v64 = v30;
    sub_10001448C(v58);

    if (objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "count"))
    {
      v31 = objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "count");
      sub_10001A7E4(0, "cleanup_old_records_with_buid_block_invoke_2", CFSTR("Cleaning up %lu old pairing record(s) for BUID %@."), v32, v33, v34, v35, v36, v31);
      v56 = 0u;
      v57 = 0u;
      v54 = 0u;
      v55 = 0u;
      v37 = *(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
      v38 = objc_msgSend(v37, "countByEnumeratingWithState:objects:count:", &v54, v69, 16);
      if (v38)
      {
        v39 = v38;
        v40 = *(_QWORD *)v55;
        do
        {
          v41 = 0;
          do
          {
            if (*(_QWORD *)v55 != v40)
              objc_enumerationMutation(v37);
            v42 = objc_retainAutorelease(*(id *)(*((_QWORD *)&v54 + 1) + 8 * (_QWORD)v41));
            v43 = (const char *)objc_msgSend(v42, "UTF8String");
            if ((sub_100014880(v43, v44, v45, v46, v47, v48, v49, v50) & 1) == 0
              && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
            {
              sub_1000F9868(v67, (uint64_t)v42, &v68);
            }
            v41 = (char *)v41 + 1;
          }
          while (v39 != v41);
          v39 = objc_msgSend(v37, "countByEnumeratingWithState:objects:count:", &v54, v69, 16);
        }
        while (v39);
      }

    }
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;

  }
  else
  {
    sub_10001A7E4(0, "cleanup_old_records_with_buid_block_invoke", CFSTR("Failed to read boot session UUID."), v22, v23, v24, v25, v26, v52);

  }
}

uint64_t sub_10001448C(void *a1)
{
  unsigned int (**v1)(id, char *);
  uint64_t v2;
  DIR *v3;
  DIR *v4;
  dirent *v5;
  char *v6;
  size_t v7;
  const char *d_name;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v17[1024];

  v1 = a1;
  bzero(v17, 0x400uLL);
  sub_10000816C(v17);
  v2 = __strlcat_chk(v17, "/Library/Lockdown/pair_records/", 1024, 1024);
  v3 = opendir(v17);
  if (v3)
  {
    v4 = v3;
    v5 = readdir(v3);
    if (v5)
    {
      v6 = &v17[v2];
      v7 = 1024 - v2;
      while (1)
      {
        d_name = v5->d_name;
        if (strcmp(v5->d_name, "."))
        {
          if (strcmp(d_name, ".."))
          {
            strncpy(v6, d_name, v7);
            if (!v1[2](v1, v17))
              break;
          }
        }
        v5 = readdir(v4);
        if (!v5)
          goto LABEL_8;
      }
      v9 = 0;
    }
    else
    {
LABEL_8:
      v9 = 1;
    }
    closedir(v4);
  }
  else
  {
    __error();
    v10 = __error();
    strerror(*v10);
    sub_10001A7E4(0, "enumerate_pair_record_paths", CFSTR("Failed to open %s: %d (%s)"), v11, v12, v13, v14, v15, (char)v17);
    v9 = 1;
  }

  return v9;
}

uint64_t sub_10001460C(uint64_t a1, char *__s1)
{
  const char *v4;
  const __CFDictionary *v5;
  const __CFDictionary *v6;
  const void *Value;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  void *v20;
  const void *v21;
  id v22;
  unsigned int v23;
  const void *v24;
  id v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v45;

  v4 = *(const char **)(a1 + 56);
  if (!v4 || strncmp(__s1, v4, 0x400uLL))
  {
    v5 = (const __CFDictionary *)sub_100025818(__s1);
    if (v5)
    {
      v6 = v5;
      Value = CFDictionaryGetValue(v5, CFSTR("SystemBUID"));
      if (sub_100010BA8(Value))
      {
        if (*(_BYTE *)(a1 + 80))
        {
          v13 = 0;
          goto LABEL_7;
        }
        v21 = CFDictionaryGetValue(v6, CFSTR("BootSessionWhenCreated"));
        v13 = (void *)objc_claimAutoreleasedReturnValue(v21);
        v22 = sub_10001B244(v13);
        v14 = (void *)objc_claimAutoreleasedReturnValue(v22);
        if (!v14)
          goto LABEL_8;
        v23 = objc_msgSend(v13, "isEqual:", *(_QWORD *)(a1 + 32));

        if (!v23)
        {
LABEL_7:
          v14 = 0;
          if (*(_BYTE *)(a1 + 81))
            goto LABEL_28;
LABEL_8:
          v33 = CFDictionaryGetValue(v6, CFSTR("RootCertificate"));
          if (!sub_100010BDC(v33))
            sub_10001A7E4(0, "cleanup_old_records_with_buid_block_invoke", CFSTR("Pair record doesn't contain root certificate."), v34, v35, v36, v37, v38, v45);
          if (sub_100010BDC(v33) && CFEqual(*(CFTypeRef *)(a1 + 40), v33))
          {
            sub_10001A7E4(0, "cleanup_old_records_with_buid_block_invoke", CFSTR("Preserving pair record (%s) because it is an automation record."), v39, v40, v41, v42, v43, (char)__s1);
          }
          else
          {
LABEL_28:
            if (CFEqual(*(CFTypeRef *)(a1 + 72), Value))
            {
              v15 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
              v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", __s1));
              objc_msgSend(v15, "addObject:", v16);

            }
          }
          goto LABEL_24;
        }
        v24 = CFDictionaryGetValue(v6, CFSTR("TimeWhenCreated"));
        v14 = (void *)objc_claimAutoreleasedReturnValue(v24);
        v25 = sub_10001B298(v14);
        v26 = (void *)objc_claimAutoreleasedReturnValue(v25);

        if (!v26)
          goto LABEL_8;
        v27 = *(_QWORD *)(a1 + 64);
        if (v27 - (uint64_t)objc_msgSend(v14, "unsignedLongLongValue") > 4)
          goto LABEL_8;
        sub_10001A7E4(0, "cleanup_old_records_with_buid_block_invoke", CFSTR("Preserving pair record (%s) which was created less than %d seconds ago."), v28, v29, v30, v31, v32, (char)__s1);
      }
      else
      {
        sub_10001A7E4(0, "cleanup_old_records_with_buid_block_invoke", CFSTR("Failed to read BUID from pair record (%s). Marking for deletion."), v8, v9, v10, v11, v12, (char)__s1);
        v19 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
        v20 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", __s1));
        objc_msgSend(v19, "addObject:", v20);

        v13 = 0;
        v14 = 0;
      }
LABEL_24:
      CFRelease(v6);

      return 1;
    }
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
      sub_1000F98A8((uint64_t)__s1, v17, v18);
  }
  return 1;
}

uint64_t sub_100014880(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  const __CFString *v10;
  int *v11;
  char v12;

  if (a1)
  {
    v8 = (char)a1;
    if (!unlink(a1) || *__error() == 2)
      return 1;
    __error();
    v11 = __error();
    strerror(*v11);
    v12 = v8;
    v10 = CFSTR("Failed to delete %s: %d (%s)");
    LODWORD(a1) = 0;
  }
  else
  {
    v10 = CFSTR("Invalid argument.");
  }
  sub_10001A7E4((int)a1, "delete_file_at_path", v10, a4, a5, a6, a7, a8, v12);
  return 0;
}

BOOL sub_100014914()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v8;

  v8 = 1;
  v0 = ACMKernelControl(34, &v8, 4uLL, 0);
  v6 = v0;
  if (v0)
    sub_10001A7E4(0, "resetUSBRMPolicy", CFSTR("ACMDRMNotifyTrustedDeviceAttached failed: %d"), v1, v2, v3, v4, v5, v0);
  return v6 == 0;
}

uint64_t sub_10001497C(uint64_t a1)
{
  id v2;
  NSObject *v3;
  id v4;
  NSObject *v5;
  uint64_t v6;
  _QWORD v8[6];
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0;
  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  dispatch_assert_queue_not_V2(v3);

  v4 = sub_1000140BC();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100014A4C;
  v8[3] = &unk_10017A1E8;
  v8[4] = &v9;
  v8[5] = a1;
  dispatch_sync(v5, v8);

  v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_100014A34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100014A4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;

  if (sub_10000F404(*(_QWORD *)(a1 + 40), 0, CFSTR("PairRecordProtectionClass"), a4, a5, a6, a7, a8) != 4)
  {
    if (!MKBDeviceUnlockedSinceBoot())
      return;
    sub_10001448C(&stru_10017A5D8);
    sub_10000EA20(*(_QWORD *)(a1 + 40), 0, (uint64_t)CFSTR("PairRecordProtectionClass"), 4);
    sub_10000E1DC(*(NSObject ***)(a1 + 40), v9, v10, v11, v12, v13, v14, v15, v16);
  }
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
}

BOOL sub_100014ACC(id a1, const char *a2)
{
  char v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v2 = (char)a2;
  v3 = open(a2, 0);
  if (v3 == -1)
  {
    __error();
    v10 = __error();
    strerror(*v10);
    sub_10001A7E4(0, "upgradePairRecordProtectionClass_block_invoke_2", CFSTR("Failed to load %s while upgrading protection class: %d (%s)."), v11, v12, v13, v14, v15, v2);
  }
  else
  {
    v4 = v3;
    if (fcntl(v3, 64, 4) == -1)
    {
      __error();
      v16 = __error();
      strerror(*v16);
      sub_10001A7E4(0, "upgradePairRecordProtectionClass_block_invoke_2", CFSTR("Failed to upgrade %s to protection class %d: %d (%s)"), v17, v18, v19, v20, v21, v2);
    }
    else
    {
      sub_10001A7E4(0, "upgradePairRecordProtectionClass_block_invoke_2", CFSTR("Upgraded pairing record %s to protection class %d."), v5, v6, v7, v8, v9, v2);
    }
    close(v4);
  }
  return 1;
}

uint64_t sub_100014BC0(NSObject **a1)
{
  void *v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v42;
  _QWORD v43[4];
  id v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  char v49;

  v46 = 0;
  v47 = &v46;
  v48 = 0x2020000000;
  v49 = 0;
  v2 = (void *)sub_10000ED98((uint64_t)a1, 0, (uint64_t)CFSTR("ProductVersion"));
  v3 = (void *)sub_10000ED98((uint64_t)a1, 0, (uint64_t)CFSTR("DarkProductVersion"));
  v9 = v3;
  if (v3 && (objc_msgSend(v3, "isEqualToString:", v2) & 1) != 0)
  {
    v10 = 0;
  }
  else
  {
    sub_10001A7E4(0, "perform_migration", CFSTR("Detected upgrade from %@ to %@."), v4, v5, v6, v7, v8, (char)v9);
    if (!v9 || objc_msgSend(v9, "compare:options:", CFSTR("17.0"), 64) == (id)-1)
    {
      v15 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", "-----BEGIN CERTIFICATE-----\nMIIDPTCCAiWgAwIBAgIBATANBgkqhkiG9w0BAQsFADBOMSkwJwYDVQQDDCBUZXN0\nIEF1dG9tYXRpb24gTG9ja2Rvd24gUm9vdCBDQTEUMBIGA1UECgwLQXBwbGUsIElu\nYy4xCzAJBgNVBAYTAlVTMB4XDTE3MDkyMTAxNDIyN1oXDTE3MDkyMjAxNDIyN1ow\nTjEpMCcGA1UEAwwgVGVzdCBBdXRvbWF0aW9uIExvY2tkb3duIFJvb3QgQ0ExFDAS\nBgNVBAoMC0FwcGxlLCBJbmMuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEB\nBQADggEPADCCAQoCggEBALb4vJZBLlbrG9NE7BvAGf0WgNmgeHWKXEwM+HHTHM7x\n0gJunt5R6z+lb8lSH1/lz1VMwPV4mAoShObmLHhiYKfmdbeMzDmeOkGV6bJKNHxU\n854NJPd9e7yQkUlVXrkewsnmhRE1WytgGVpTns1JcKT7bFGiUGIFfX/l8ciLtGXA\nZ8rgeXzl2EUq62rOaNzLkHm1WAiUhWW3MU70MQXKFa3JbhLysa4XHxPqIzdmBe+N\nKHiMT3cLENYMQ/OSiIr1Ssa622+zTTaRHXT+ysc7smrgr2ZKaMY+a+oqJ00AMUJI\nXbEtMjLr5BPQqWPZSTThK2crxUwoTZuLg+PLYbApjrECAwEAAaMmMCQwEgYDVR0T\nAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAqQwDQYJKoZIhvcNAQELBQADggEB\nAD/1Hy7Sf6xE8nWiBy+ioOc7jXwWXNaRQb9lF8yAAFBtzRvkFKyN8LX+1QielIMx\n41Z8XTwv9ibhZF0ETlxZch9wduwL3wwKirBLbvqUJJ5XKW7hlUUXR7MC8trQFWIk\nntGLrtmcKSDWyWHu2eVPjJmQh+v6xetufq0u3TokqE/X+/fpPcu596mYRrovJY8g\np9gFmpAN8E4gqEfQUj9ak8aIces12cnOapL7ZHo0XHltLBBQd+4sLDO7JUlKAi2A\n"
              "SQxevep+SlLsUQYoAvr1CPxGkWuEBj/3oXhmk7EesJjDsnSnloMGoHVxxkRIipvr\n"
              "6TK70j9afDnOjNWRNmXMHLM=\n"
              "-----END CERTIFICATE-----\n",
              1184);
      if (!v15)
      {
        sub_10001A7E4(0, "perform_migration", CFSTR("Failed to load automation root cert."), v16, v17, v18, v19, v20, v42);
        v40 = 0;
        v10 = 0;
        goto LABEL_14;
      }
      v43[0] = _NSConcreteStackBlock;
      v43[1] = 3221225472;
      v43[2] = sub_100014E38;
      v43[3] = &unk_10017A600;
      v10 = v15;
      v44 = v10;
      v45 = &v46;
      sub_100014DC0(v43);

      if (!*((_BYTE *)v47 + 24))
      {
        sub_100014F6C(1);
        sub_100028980();
        sub_100012D98(1, v26, v27, v28, v29, v30, v31, v32, v42);
      }
      sub_10001A7E4(0, "perform_migration", CFSTR("Successfully performed upgrade key rolling."), v21, v22, v23, v24, v25, v42);
    }
    else
    {
      v10 = 0;
    }
    if (v2)
    {
      sub_10000E484((uint64_t)a1, 0, (uint64_t)CFSTR("DarkProductVersion"), (uint64_t)v2, v11, v12, v13, v14);
      sub_10000E1DC(a1, v33, v34, v35, v36, v37, v38, v39, v42);
    }
  }
  v40 = 1;
LABEL_14:
  _Block_object_dispose(&v46, 8);

  return v40;
}

void sub_100014DA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100014DC0(void *a1)
{
  id v1;
  uint64_t v2;
  _QWORD v4[4];
  id v5;

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1000156EC;
  v4[3] = &unk_10017A628;
  v5 = a1;
  v1 = v5;
  v2 = sub_10001448C(v4);

  return v2;
}

uint64_t sub_100014E38(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  char v27;

  v3 = a2;
  v9 = v3;
  if (!v3)
  {
    sub_10001A7E4(0, "perform_migration_block_invoke", CFSTR("Invalid pair record."), v4, v5, v6, v7, v8, v27);
    v10 = 0;
    v12 = 0;
    goto LABEL_10;
  }
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKey:", CFSTR("RootCertificate")));
  v11 = sub_10001B1F0(v10);
  v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

  if (!v12)
  {
    v25 = CFSTR("Pair record doesn't contain root certificate.");
LABEL_9:
    sub_10001A7E4(0, "perform_migration_block_invoke", v25, v13, v14, v15, v16, v17, v27);
    goto LABEL_10;
  }
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKey:", CFSTR("HostID")));
  v18 = sub_10001B244(v12);
  v19 = (void *)objc_claimAutoreleasedReturnValue(v18);

  if (!v19)
  {
    v25 = CFSTR("Pair record doesn't contain host id.");
    goto LABEL_9;
  }
  if (objc_msgSend(*(id *)(a1 + 32), "isEqualToData:", v10))
  {
    sub_10001A7E4(0, "perform_migration_block_invoke", CFSTR("Skipping deletion of automation cert/keys (%@)."), v20, v21, v22, v23, v24, (char)v12);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 1;
  }
LABEL_10:

  return 1;
}

void sub_100014F6C(char a1)
{
  id v2;
  NSObject *v3;
  id v4;
  NSObject *v5;
  _QWORD block[4];
  char v7;

  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  dispatch_assert_queue_not_V2(v3);

  v4 = sub_1000140BC();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100014FEC;
  block[3] = &unk_10017A520;
  v7 = a1;
  dispatch_sync(v5, block);

}

void sub_100014FEC(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  char __str[1024];
  char v14[1024];

  bzero(v14, 0x400uLL);
  bzero(__str, 0x400uLL);
  sub_10000816C(v14);
  snprintf(__str, 0x400uLL, "%s%s", v14, "/Library/Lockdown/pair_records");
  sub_100026060((uint64_t)__str);
  if (*(_BYTE *)(a1 + 32))
    unlink((const char *)objc_msgSend(CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"), "fileSystemRepresentation"));
  sub_100015104(0, 1, v2, v3, v4, v5, v6, v7);
  v12 = 0;
  v8 = remotepairing_delete_pair_records(&v12);
  v9 = v12;
  if ((v8 & 1) == 0 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
    sub_1000F991C((uint64_t)v9, v10, v11);
  sub_100015588();
  sub_100026BA4();

}

uint64_t sub_100015104(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  id v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  id v22;
  uint64_t v23;
  void *i;
  void *v25;
  void *v26;
  void *v27;
  unsigned int v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  NSObject *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  void *v40;
  char v42;
  dispatch_queue_t v43;
  id obj;
  void *v46;
  NSObject *dsema;
  _QWORD v48[4];
  NSObject *v49;
  uint64_t *v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  _QWORD v55[4];
  NSObject *v56;
  uint64_t *v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t (*v61)(uint64_t, uint64_t);
  void (*v62)(uint64_t);
  id v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t (*v67)(uint64_t, uint64_t);
  void (*v68)(uint64_t);
  id v69;
  const __CFString *v70;
  void *v71;
  const __CFString *v72;
  void *v73;
  _BYTE v74[128];

  v64 = 0;
  v65 = &v64;
  v66 = 0x3032000000;
  v67 = sub_1000140A4;
  v68 = sub_1000140B4;
  v69 = 0;
  v58 = 0;
  v59 = &v58;
  v60 = 0x3032000000;
  v61 = sub_1000140A4;
  v62 = sub_1000140B4;
  v63 = 0;
  if (!a1 && (a2 & 1) == 0)
  {
    v9 = CFSTR("Invalid input.");
LABEL_21:
    sub_10001A7E4(0, "deleteSRPPairingRecord", v9, a4, a5, a6, a7, a8, v42);
    v39 = 0;
    dsema = 0;
    v43 = 0;
LABEL_22:
    v40 = 0;
    goto LABEL_23;
  }
  v43 = dispatch_queue_create("com.apple.mobilelockdown-srp", 0);
  if (!v43)
  {
    v9 = CFSTR("Failed to create dispatch queue.");
    goto LABEL_21;
  }
  dsema = dispatch_semaphore_create(0);
  if (!dsema)
  {
    sub_10001A7E4(0, "deleteSRPPairingRecord", CFSTR("Failed to create semaphore."), v10, v11, v12, v13, v14, v42);
    v39 = 0;
    dsema = 0;
    goto LABEL_22;
  }
  v15 = objc_alloc_init((Class)CUPairingManager);
  v21 = v15;
  if (!v15)
  {
    sub_10001A7E4(0, "deleteSRPPairingRecord", CFSTR("Failed to create pairing manager."), v16, v17, v18, v19, v20, v42);
    v39 = 0;
    goto LABEL_22;
  }
  objc_msgSend(v15, "setDispatchQueue:", v43);
  v55[0] = _NSConcreteStackBlock;
  v55[1] = 3221225472;
  v55[2] = sub_1000161BC;
  v55[3] = &unk_10017A6C0;
  v57 = &v64;
  dsema = dsema;
  v56 = dsema;
  objc_msgSend(v21, "getPairedPeersWithOptions:completion:", 4, v55);
  v46 = v21;

  dispatch_semaphore_wait(dsema, 0xFFFFFFFFFFFFFFFFLL);
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  obj = (id)v65[5];
  v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v51, v74, 16);
  if (v22)
  {
    v23 = *(_QWORD *)v52;
    do
    {
      for (i = 0; i != v22; i = (char *)i + 1)
      {
        if (*(_QWORD *)v52 != v23)
          objc_enumerationMutation(obj);
        v25 = *(void **)(*((_QWORD *)&v51 + 1) + 8 * (_QWORD)i);
        if ((a2 & 1) == 0)
        {
          v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(*(id *)(*((_QWORD *)&v51 + 1) + 8 * (_QWORD)i), "info"));
          v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v26, "objectForKeyedSubscript:", CFSTR("HostID")));
          v28 = objc_msgSend(v27, "isEqualToString:", a1);

          if (!v28)
            continue;
        }
        v72 = CFSTR("HostID");
        v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
        v73 = v29;
        v30 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v73, &v72, 1));
        objc_msgSend(v25, "setInfo:", v30);

        v70 = CFSTR("com.apple.developer");
        v31 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
        v71 = v31;
        v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v71, &v70, 1));
        objc_msgSend(v25, "setAcl:", v32);

        v48[0] = _NSConcreteStackBlock;
        v48[1] = 3221225472;
        v48[2] = sub_1000161F8;
        v48[3] = &unk_10017A698;
        v50 = &v58;
        v33 = dsema;
        v49 = v33;
        objc_msgSend(v46, "savePairedPeer:options:completion:", v25, 4, v48);
        dispatch_semaphore_wait(v33, 0xFFFFFFFFFFFFFFFFLL);

      }
      v22 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v51, v74, 16);
    }
    while (v22);
  }

  if (v59[5])
  {
    sub_10001A7E4(0, "deleteSRPPairingRecord", CFSTR("Failed to remove SRP pairing record: %@"), v34, v35, v36, v37, v38, v59[5]);
    v39 = 0;
  }
  else
  {
    v39 = 1;
  }
  v40 = v46;
LABEL_23:
  objc_msgSend(v40, "invalidate");
  _Block_object_dispose(&v58, 8);

  _Block_object_dispose(&v64, 8);
  return v39;
}

void sub_100015554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a41, 8);
  _Unwind_Resume(a1);
}

void sub_100015588()
{
  id v0;
  NSObject *v1;

  v0 = sub_1000140BC();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  dispatch_assert_queue_V2(v1);

  qword_1001A8040 = 0;
  qword_1001A8038 = 0;
}

void sub_1000155C4()
{
  int *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char __str[1024];
  char v13[1024];

  bzero(v13, 0x400uLL);
  bzero(__str, 0x400uLL);
  sub_10000816C(v13);
  snprintf(__str, 0x400uLL, "%s%s", v13, "/Library/Lockdown/device_private_key.pem");
  if (unlink(__str))
  {
    v0 = __error();
    strerror(*v0);
    sub_10001A7E4(0, "destroy_pairing_keypair_pems", CFSTR("Failed to delete %s: %s"), v1, v2, v3, v4, v5, (char)__str);
  }
  snprintf(__str, 0x400uLL, "%s%s", v13, "/Library/Lockdown/device_public_key.pem");
  if (unlink(__str))
  {
    v6 = __error();
    strerror(*v6);
    sub_10001A7E4(0, "destroy_pairing_keypair_pems", CFSTR("Failed to delete %s: %s"), v7, v8, v9, v10, v11, (char)__str);
  }
}

uint64_t sub_1000156EC(uint64_t a1, uint64_t a2)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  uint64_t v18;
  char v20;

  v3 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithCString:encoding:](NSString, "stringWithCString:encoding:", a2, 4));
  v9 = v3;
  if (!v3)
  {
    sub_10001A7E4(0, "enumerate_pair_records_block_invoke", CFSTR("Failed to create string."), v4, v5, v6, v7, v8, v20);
    goto LABEL_6;
  }
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "pathExtension"));
  v11 = objc_msgSend(v10, "isEqualToString:", CFSTR("plist"));

  if (!v11)
  {
LABEL_6:
    v17 = 0;
    goto LABEL_7;
  }
  v17 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithContentsOfFile:", v9);
  if (!v17)
    sub_10001A7E4(0, "enumerate_pair_records_block_invoke", CFSTR("Failed to load %@."), v12, v13, v14, v15, v16, (char)v9);
LABEL_7:
  v18 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();

  return v18;
}

id sub_1000157D0(const void *a1)
{
  id v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  id v9;
  id v10;
  id v11;
  char v13;
  _QWORD v14[4];
  id v15;

  v2 = objc_alloc_init((Class)NSMutableDictionary);
  v8 = v2;
  if (v2)
  {
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_1000158A4;
    v14[3] = &unk_10017A650;
    v9 = v2;
    v15 = v9;
    sub_100014DC0(v14);

    if (sub_100010BA8(a1))
      v10 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "objectForKeyedSubscript:", a1));
    else
      v10 = v9;
    v11 = v10;
  }
  else
  {
    sub_10001A7E4(0, "copy_paired_host_info", CFSTR("Failed to create array."), v3, v4, v5, v6, v7, v13);
    v11 = 0;
  }

  return v11;
}

uint64_t sub_1000158A4(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  id v14;
  void *v15;
  void *v16;
  id v17;
  const __CFString *v18;
  char v20;
  _QWORD v21[6];

  v3 = a2;
  v9 = v3;
  if (!v3)
  {
    v18 = CFSTR("Invalid pair record.");
LABEL_6:
    sub_10001A7E4(0, "copy_paired_host_info_block_invoke", v18, v4, v5, v6, v7, v8, v20);
    goto LABEL_7;
  }
  v10 = objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("HostID")));
  if (!v10)
  {
    v18 = CFSTR("Failed to read host ID from pair record.");
    goto LABEL_6;
  }
  v11 = (void *)v10;
  v21[0] = CFSTR("SystemBUID");
  v21[1] = CFSTR("HostName");
  v21[2] = CFSTR("SerialNumber");
  v21[3] = CFSTR("MarketingName");
  v21[4] = CFSTR("TimeWhenCreated");
  v21[5] = CFSTR("WallTimeWhenCreated");
  v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v21, 6));
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "dictionaryWithValuesForKeys:", v12));
  v14 = objc_msgSend(v13, "mutableCopy");

  v15 = (void *)objc_claimAutoreleasedReturnValue(+[NSNull null](NSNull, "null"));
  v16 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "allKeysForObject:", v15));
  objc_msgSend(v14, "removeObjectsForKeys:", v16);

  v17 = objc_msgSend(v14, "copy");
  objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", v17, v11);

LABEL_7:
  return 1;
}

CFBooleanRef sub_100015A40(const __CFString *a1)
{
  CFBooleanRef v2;
  const void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFString *v9;
  char v11;
  stat v12;
  char __str[1024];
  char v14[1024];
  char buffer[1024];

  v2 = kCFBooleanFalse;
  v3 = sub_100010BA8(a1);
  if (!v3)
  {
    v9 = CFSTR("Invalid input.");
LABEL_8:
    sub_10001A7E4((int)v3, "copy_pair_record_exists", v9, v4, v5, v6, v7, v8, v11);
    return v2;
  }
  memset(&v12, 0, sizeof(v12));
  LODWORD(v3) = CFStringGetCString(a1, buffer, 1024, 0x8000100u);
  if (!(_DWORD)v3)
  {
    v9 = CFSTR("Failed to create C string.");
    goto LABEL_8;
  }
  sub_10000816C(v14);
  snprintf(__str, 0x400uLL, "%s%s/%s.plist", v14, "/Library/Lockdown/pair_records", buffer);
  if (!stat(__str, &v12))
    return kCFBooleanTrue;
  return v2;
}

uint64_t sub_100015B64(const __CFString *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString *v13;
  char v14;
  char __str[1024];
  char v16[1024];
  char buffer[2];
  unsigned __int8 v18;

  bzero(buffer, 0x400uLL);
  bzero(v16, 0x400uLL);
  bzero(__str, 0x400uLL);
  if (!CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    v13 = CFSTR("Failed to create C string.");
LABEL_7:
    sub_10001A7E4(0, "load_pair_record", v13, v2, v3, v4, v5, v6, v14);
    return 0;
  }
  sub_100025C54(buffer);
  if (!(*(unsigned __int16 *)buffer ^ 0x2E2E | v18))
  {
    v13 = CFSTR("Invalid host ID.");
    goto LABEL_7;
  }
  sub_10000816C(v16);
  snprintf(__str, 0x400uLL, "%s%s/%s.plist", v16, "/Library/Lockdown/pair_records", buffer);
  result = sub_100025818(__str);
  if (result)
    return result;
  sub_10001A7E4(0, "load_pair_record", CFSTR("Failed to load %s."), v8, v9, v10, v11, v12, (char)__str);
  return 0;
}

void sub_100015CA8(uint64_t a1, char a2)
{
  id v4;
  NSObject *v5;
  id v6;
  NSObject *v7;
  _QWORD block[5];
  char v9;

  v4 = sub_1000140BC();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  dispatch_assert_queue_not_V2(v5);

  v6 = sub_1000140BC();
  v7 = objc_claimAutoreleasedReturnValue(v6);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100015D38;
  block[3] = &unk_10017A670;
  block[4] = a1;
  v9 = a2;
  dispatch_sync(v7, block);

}

void sub_100015D38(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  char *v15;
  char __str[1024];
  char v17[1024];
  char buffer[2];
  unsigned __int8 v19;

  bzero(buffer, 0x400uLL);
  bzero(v17, 0x400uLL);
  bzero(__str, 0x400uLL);
  if (!CFStringGetCString(*(CFStringRef *)(a1 + 32), buffer, 1024, 0x8000100u))
  {
    v14 = CFSTR("Failed to create C string.");
LABEL_11:
    sub_10001A7E4(0, "destroy_pair_record_block_invoke", v14, v2, v3, v4, v5, v6, (char)v15);
    return;
  }
  sub_100025C54(buffer);
  if (!(*(unsigned __int16 *)buffer ^ 0x2E2E | v19))
  {
    v14 = CFSTR("Invalid host ID.");
    goto LABEL_11;
  }
  sub_10000816C(v17);
  snprintf(__str, 0x400uLL, "%s%s/%s.plist", v17, "/Library/Lockdown/pair_records", buffer);
  if ((sub_100014880(__str, v7, v8, v9, v10, v11, v12, v13) & 1) == 0)
  {
    v15 = __str;
    v14 = CFSTR("Failed to remove record (%s)");
    goto LABEL_11;
  }
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "destroy_pair_record_block_invoke", CFSTR("Deleted pair record (%s)."), v2, v3, v4, v5, v6, (char)__str);
  sub_100026BA4();
  if (*(_BYTE *)(a1 + 40))
    sub_100015588();
}

uint64_t sub_100015EBC(void *a1, void *a2)
{
  id v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  const __CFString *v11;
  dispatch_queue_t v12;
  dispatch_queue_t v13;
  dispatch_semaphore_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  NSObject *v20;
  id v21;
  void *v22;
  void *v23;
  id v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  id v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v46;
  _QWORD v47[4];
  NSObject *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  void (*v54)(uint64_t);
  id v55;

  v3 = a1;
  v4 = a2;
  v10 = v4;
  v50 = 0;
  v51 = &v50;
  v52 = 0x3032000000;
  v53 = sub_1000140A4;
  v54 = sub_1000140B4;
  v55 = 0;
  v11 = CFSTR("Invalid input.");
  if (!v3 || !v4)
    goto LABEL_10;
  v12 = dispatch_queue_create("com.apple.mobilelockdown-srp", 0);
  if (!v12)
  {
    v11 = CFSTR("Failed to create dispatch queue.");
LABEL_10:
    sub_10001A7E4(0, "updateSRPPairingRecord", v11, v5, v6, v7, v8, v9, v46);
    v13 = 0;
LABEL_11:
    v20 = 0;
LABEL_12:
    v44 = 0;
    v24 = 0;
LABEL_13:
    v37 = 0;
    goto LABEL_14;
  }
  v13 = v12;
  v14 = dispatch_semaphore_create(0);
  if (!v14)
  {
    sub_10001A7E4(0, "updateSRPPairingRecord", CFSTR("Failed to create semaphore."), v15, v16, v17, v18, v19, v46);
    goto LABEL_11;
  }
  v20 = v14;
  v21 = objc_alloc((Class)NSMutableDictionary);
  v22 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "pairedPeer"));
  v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "info"));
  v24 = objc_msgSend(v21, "initWithDictionary:", v23);

  if (!v24)
  {
    sub_10001A7E4(0, "updateSRPPairingRecord", CFSTR("Failed to copy peer info."), v25, v26, v27, v28, v29, v46);
    goto LABEL_12;
  }
  objc_msgSend(v24, "addEntriesFromDictionary:", v10);
  v30 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "pairedPeer"));
  objc_msgSend(v30, "setInfo:", v24);

  v31 = objc_alloc_init((Class)CUPairingManager);
  v37 = v31;
  if (!v31)
  {
    sub_10001A7E4(0, "updateSRPPairingRecord", CFSTR("Failed to create pairing manager."), v32, v33, v34, v35, v36, v46);
    v44 = 0;
    goto LABEL_13;
  }
  objc_msgSend(v31, "setDispatchQueue:", v13);
  v38 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "pairedPeer"));
  v47[0] = _NSConcreteStackBlock;
  v47[1] = 3221225472;
  v47[2] = sub_100016180;
  v47[3] = &unk_10017A698;
  v49 = &v50;
  v20 = v20;
  v48 = v20;
  objc_msgSend(v37, "savePairedPeer:options:completion:", v38, 4, v47);

  dispatch_semaphore_wait(v20, 0xFFFFFFFFFFFFFFFFLL);
  if (v51[5])
  {
    sub_10001A7E4(0, "updateSRPPairingRecord", CFSTR("Failed to update SRP pairing record: %@"), v39, v40, v41, v42, v43, v51[5]);
    v44 = 0;
  }
  else
  {
    v44 = 1;
  }
LABEL_14:
  objc_msgSend(v37, "invalidate");
  _Block_object_dispose(&v50, 8);

  return v44;
}

void sub_100016168(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_100016180(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;

  v3 = objc_msgSend(a2, "copy");
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

intptr_t sub_1000161BC(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;

  v3 = objc_msgSend(a2, "copy");
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

intptr_t sub_1000161F8(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  void *v5;

  v3 = objc_msgSend(a2, "copy");
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = v3;

  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_100016234(uint64_t a1, const __CFDictionary *a2, void *a3, void *a4, void *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  id v14;
  const void *Value;
  const __CFString *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  id v22;
  uint64_t v23;
  int *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  id v30;
  uint64_t v31;
  id v33;
  uint64_t v34;
  id v35;
  uint64_t v36;
  id v37;
  uint64_t v38;
  id v39;
  uint64_t v40;
  id v41;
  uint64_t v42;
  NSNumber *v43;
  void *v44;
  NSNumber *v45;
  void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  id v57;
  NSObject *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  CFNumberRef v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  const void *v71;
  const __CFString *v72;
  char v73;
  char v74;
  _QWORD block[4];
  id v76;
  uint64_t *v77;
  char *v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  int v82;
  char buffer[2];
  unsigned __int8 v84;
  char v85[1024];
  char v86[1024];

  v79 = 0;
  v80 = &v79;
  v81 = 0x2020000000;
  v82 = -1;
  sub_10000816C(v86);
  __snprintf_chk(v85, 0x400uLL, 0, 0x400uLL, "%s%s", v86, "/Library/Lockdown/pair_records");
  if (mkdir(v85, 0x1EDu) && *__error() != 17)
  {
    __error();
    v24 = __error();
    strerror(*v24);
    sub_10001A7E4(0, "store_pair_record", CFSTR("Failed to create %s : %d (%s)"), v25, v26, v27, v28, v29, (char)v85);
LABEL_10:
    v30 = 0;
    a3 = 0;
    v14 = 0;
LABEL_12:
    a5 = 0;
    a4 = 0;
LABEL_13:
    v31 = 0xFFFFFFFFLL;
    goto LABEL_14;
  }
  v14 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithDictionary:", a2);
  if (!v14)
  {
    sub_10001A7E4(0, "store_pair_record", CFSTR("Failed to create dictionary."), v9, v10, v11, v12, v13, v73);
    goto LABEL_10;
  }
  Value = CFDictionaryGetValue(a2, CFSTR("HostID"));
  v16 = (const __CFString *)sub_100010BA8(Value);
  if (!CFStringGetCString(v16, buffer, 1024, 0x8000100u))
  {
    sub_10001A7E4(0, "store_pair_record", CFSTR("Failed to create C string."), v17, v18, v19, v20, v21, v73);
    v30 = 0;
    a3 = 0;
    goto LABEL_12;
  }
  if (a3)
  {
    v22 = a3;
    if ((unint64_t)objc_msgSend(v22, "length") > 0x3E)
      v23 = 63;
    else
      v23 = (uint64_t)objc_msgSend(v22, "length");
    v33 = objc_msgSend(v22, "rangeOfComposedCharacterSequencesForRange:", 0, v23);
    a3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v22, "substringWithRange:", v33, v34));

    objc_msgSend(v14, "setObject:forKeyedSubscript:", a3, CFSTR("HostName"));
  }
  if (a4)
  {
    v35 = a4;
    if ((unint64_t)objc_msgSend(v35, "length") > 0x3E)
      v36 = 63;
    else
      v36 = (uint64_t)objc_msgSend(v35, "length");
    v37 = objc_msgSend(v35, "rangeOfComposedCharacterSequencesForRange:", 0, v36);
    a4 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v35, "substringWithRange:", v37, v38));

    objc_msgSend(v14, "setObject:forKeyedSubscript:", a4, CFSTR("SerialNumber"));
  }
  if (a5)
  {
    v39 = a5;
    if ((unint64_t)objc_msgSend(v39, "length") > 0x3E)
      v40 = 63;
    else
      v40 = (uint64_t)objc_msgSend(v39, "length");
    v41 = objc_msgSend(v39, "rangeOfComposedCharacterSequencesForRange:", 0, v40);
    a5 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v39, "substringWithRange:", v41, v42));

    objc_msgSend(v14, "setObject:forKeyedSubscript:", a5, CFSTR("MarketingName"));
  }
  v43 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:", sub_1000267A0());
  v44 = (void *)objc_claimAutoreleasedReturnValue(v43);
  objc_msgSend(v14, "setObject:forKeyedSubscript:", v44, CFSTR("TimeWhenCreated"));

  v45 = +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", sub_100026818());
  v46 = (void *)objc_claimAutoreleasedReturnValue(v45);
  objc_msgSend(v14, "setObject:forKeyedSubscript:", v46, CFSTR("WallTimeWhenCreated"));

  v30 = sub_100026844();
  if (!v30)
  {
    sub_10001A7E4(0, "store_pair_record", CFSTR("Failed to read boot session UUID."), v47, v48, v49, v50, v51, v73);
    v30 = 0;
    goto LABEL_13;
  }
  objc_msgSend(v14, "setObject:forKeyedSubscript:", v30, CFSTR("BootSessionWhenCreated"));
  sub_100025C54(buffer);
  if (!(*(unsigned __int16 *)buffer ^ 0x2E2E | v84))
  {
    sub_10001A7E4(0, "store_pair_record", CFSTR("Invalid host ID."), v52, v53, v54, v55, v56, v73);
    goto LABEL_13;
  }
  __snprintf_chk(v85, 0x400uLL, 0, 0x400uLL, "%s%s/%s.plist", v86, "/Library/Lockdown/pair_records", buffer);
  v57 = sub_1000140BC();
  v58 = objc_claimAutoreleasedReturnValue(v57);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000167D8;
  block[3] = &unk_10017A6E8;
  v77 = &v79;
  v78 = v85;
  v14 = v14;
  v76 = v14;
  dispatch_sync(v58, block);

  if (*((_DWORD *)v80 + 6) == -1)
  {
    sub_10001A7E4(0, "store_pair_record", CFSTR("Failed to store %s."), v59, v60, v61, v62, v63, (char)v85);
    goto LABEL_13;
  }
  v64 = sub_10000898C();
  if (sub_100010B0C(v64))
  {
    if ((sub_100005628(v16, v64, v65, v66, v67, v68, v69, v70) & 1) != 0)
    {
      v71 = CFDictionaryGetValue(a2, CFSTR("SystemBUID"));
      if (sub_100010BA8(v71))
      {
        sub_10001680C((uint64_t)v71);
        sub_100013F60((uint64_t)v71, 0, 0, (uint64_t)v85);
      }
      sub_100026BA4();
      v31 = 0;
      goto LABEL_41;
    }
    v72 = CFSTR("Failed to store pair record initial expiration.");
  }
  else
  {
    v72 = CFSTR("Failed to create bowie.");
  }
  sub_10001A7E4(0, "store_pair_record", v72, v66, v67, v68, v69, v70, v74);
  sub_100015CA8((uint64_t)v16, 0);
  v31 = 0xFFFFFFFFLL;
LABEL_41:
  if (v64)
    CFRelease(v64);
LABEL_14:

  _Block_object_dispose(&v79, 8);
  return v31;
}

void sub_1000167AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_list va;

  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000167D8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = sub_1000255E4(a1[6], a1[4], a3, a4, a5, a6, a7, a8);
  *(_DWORD *)(*(_QWORD *)(a1[5] + 8) + 24) = result;
  return result;
}

void sub_10001680C(uint64_t a1)
{
  id v2;
  NSObject *v3;
  id v4;
  NSObject *v5;
  _QWORD v6[6];
  _QWORD v7[5];
  id v8;

  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x3032000000;
  v7[3] = sub_1000140A4;
  v7[4] = sub_1000140B4;
  v8 = 0;
  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  dispatch_assert_queue_not_V2(v3);

  if (a1)
  {
    v4 = sub_1000140BC();
    v5 = objc_claimAutoreleasedReturnValue(v4);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_10001942C;
    v6[3] = &unk_10017A1E8;
    v6[4] = v7;
    v6[5] = a1;
    dispatch_sync(v5, v6);

  }
  _Block_object_dispose(v7, 8);

}

void sub_1000168D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000168EC(const __CFDictionary *a1)
{
  const __CFString *Value;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFUUID *v7;
  const __CFUUID *v8;
  CFStringRef v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFStringRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFString *v22;
  CFIndex Length;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const __CFString *v36;
  char *v37;
  int v38;
  unsigned int v39;
  char v42;
  char v43;

  Value = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("HostID"));
  if (sub_100010BA8(Value))
  {
    v7 = CFUUIDCreateFromString(kCFAllocatorDefault, Value);
    if (v7)
    {
      v8 = v7;
      v9 = CFUUIDCreateString(kCFAllocatorDefault, v7);
      if (!v9)
      {
        sub_10001A7E4(0, "verify_pair_record", CFSTR("Failed to create string host ID from UUID."), v10, v11, v12, v13, v14, v42);
        v21 = 0xFFFFFFFFLL;
LABEL_26:
        CFRelease(v8);
        return v21;
      }
      v15 = v9;
      if (CFEqual(v9, Value))
      {
        v21 = 0;
LABEL_25:
        CFRelease(v15);
        goto LABEL_26;
      }
      sub_10001A7E4(0, "verify_pair_record", CFSTR("The strings don't match. Is this really a UUID?"), v16, v17, v18, v19, v20, v42);
      Length = CFStringGetLength(Value);
      v24 = (char *)malloc_type_malloc(Length + 1, 0x3927245DuLL);
      if (!v24)
      {
        sub_10001A7E4(0, "verify_pair_record", CFSTR("Failed to allocate buffer."), v25, v26, v27, v28, v29, v43);
        v21 = 0xFFFFFFFFLL;
        goto LABEL_25;
      }
      v30 = v24;
      if (CFStringGetCString(Value, v24, Length + 1, 0x8000100u))
      {
        if (Length < 1)
        {
LABEL_20:
          v21 = 0;
LABEL_24:
          free(v30);
          goto LABEL_25;
        }
        v36 = CFSTR("This host ID is not valid.");
        v37 = v30;
        while (1)
        {
          v38 = *v37++;
          v39 = v38 - 58;
          if (v38 != 45 && v39 <= 0xFFFFFFF5)
            break;
          if (!--Length)
            goto LABEL_20;
        }
      }
      else
      {
        v36 = CFSTR("Failed to convert host ID to C string.");
      }
      sub_10001A7E4(0, "verify_pair_record", v36, v31, v32, v33, v34, v35, v43);
      v21 = 0xFFFFFFFFLL;
      goto LABEL_24;
    }
    v22 = CFSTR("Failed to create UUID from host ID.");
  }
  else
  {
    v22 = CFSTR("Pair record is missing the host ID.");
  }
  sub_10001A7E4(0, "verify_pair_record", v22, v2, v3, v4, v5, v6, v42);
  return 0xFFFFFFFFLL;
}

void sub_100016AA4()
{
  id v0;
  NSObject *v1;
  id v2;
  NSObject *v3;

  v0 = sub_1000140BC();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  dispatch_assert_queue_not_V2(v1);

  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  dispatch_sync(v3, &stru_10017A708);

}

void sub_100016AF4(id a1)
{
  objc_msgSend((id)qword_1001A7FF8, "invalidate");
  if (qword_1001A8008)
  {
    CFUserNotificationCancel((CFUserNotificationRef)qword_1001A8008);
    if (qword_1001A8008)
      CFRelease((CFTypeRef)qword_1001A8008);
    qword_1001A8008 = 0;
  }
  if (qword_1001A8010)
  {
    CFUserNotificationCancel((CFUserNotificationRef)qword_1001A8010);
    if (qword_1001A8010)
      CFRelease((CFTypeRef)qword_1001A8010);
    qword_1001A8010 = 0;
  }
}

void sub_100016B58(char a1)
{
  id v2;
  NSObject *v3;

  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  dispatch_assert_queue_V2(v3);

  byte_1001A8018 = a1;
}

uint64_t sub_100016B90()
{
  id v0;
  NSObject *v1;

  v0 = sub_1000140BC();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  dispatch_assert_queue_V2(v1);

  return byte_1001A8018;
}

void sub_100016BC4()
{
  id v0;
  NSObject *v1;

  v0 = sub_1000140BC();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  dispatch_async(v1, &stru_10017A728);

}

void sub_100016BF8(id a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char vars0;

  if (sub_100016B90())
  {
    sub_10001A7E4(0, "trigger_host_pair", CFSTR("Notifying host to pair."), v1, v2, v3, v4, v5, vars0);
    notify_post("com.apple.mobile.lockdown.request_pair");
    sub_100016B58(0);
  }
}

uint64_t sub_100016C40()
{
  id v0;
  NSObject *v1;
  id v2;
  NSObject *v3;
  uint64_t v4;
  _QWORD block[5];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  char v10;

  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  v0 = sub_1000140BC();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  dispatch_assert_queue_not_V2(v1);

  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100016D04;
  block[3] = &unk_10017A178;
  block[4] = &v7;
  dispatch_sync(v3, block);

  v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_100016CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100016D04(uint64_t result)
{
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(result + 32) + 8) + 24) = byte_1001A8019;
  return result;
}

void sub_100016D1C(char a1)
{
  id v2;
  NSObject *v3;
  id v4;
  NSObject *v5;
  _QWORD block[4];
  char v7;

  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  dispatch_assert_queue_not_V2(v3);

  v4 = sub_1000140BC();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100016D9C;
  block[3] = &unk_10017A520;
  v7 = a1;
  dispatch_sync(v5, block);

}

void sub_100016D9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;
  unsigned int v10;
  NSObject *v11;
  uint64_t v13;
  void *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;

  if (dword_1001A6AD0)
  {
    if (*(_BYTE *)(a1 + 32))
      v9 = "mux";
    else
      v9 = "non-mux";
    sub_10001A7E4(0, "usb_host_connected_block_invoke", CFSTR("%s connection"), a4, a5, a6, a7, a8, (char)v9);
  }
  byte_1001A8019 = 1;
  byte_1001A801A = 0;
  byte_1001A8018 = 0;
  if (objc_msgSend((id)qword_1001A8000, "count") && objc_msgSend((id)qword_1001A8000, "count"))
  {
    v10 = 1;
    do
    {
      v11 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001A8000, "lastObject"));
      dispatch_group_leave(v11);

      objc_msgSend((id)qword_1001A8000, "removeLastObject");
    }
    while ((unint64_t)objc_msgSend((id)qword_1001A8000, "count") > v10++);
  }
  if (*(_BYTE *)(a1 + 32))
  {
    if ((byte_1001A801B & 1) == 0)
      byte_1001A801B = 1;
    if (!qword_1001A8020)
    {
      v13 = os_transaction_create("com.apple.mobile.lockdownd");
      v14 = (void *)qword_1001A8020;
      qword_1001A8020 = v13;

    }
  }
  v15 = MKBGetDeviceLockState(0);
  if ((v15 == 3 || !v15) && !sub_100014914())
    sub_10001A7E4(0, "usb_host_connected_block_invoke", CFSTR("Failed to reset USB RM policy."), v16, v17, v18, v19, v20, v21);
  sub_100016EF4();
}

void sub_100016EF4()
{
  id v0;
  NSObject *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v0 = sub_1000140BC();
  v1 = objc_claimAutoreleasedReturnValue(v0);
  dispatch_assert_queue_V2(v1);

  v7 = qword_1001A6AC8 + 1;
  if (qword_1001A6AC8 == -1)
    v7 = 2;
  qword_1001A6AC8 = v7;
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "bump_connection_count", CFSTR("Connection count is now %llu."), v2, v3, v4, v5, v6, v7);
}

void sub_100016F6C(uint64_t a1, char a2)
{
  id v4;
  NSObject *v5;
  id v6;
  NSObject *v7;
  _QWORD block[5];
  char v9;

  v4 = sub_1000140BC();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  dispatch_assert_queue_not_V2(v5);

  v6 = sub_1000140BC();
  v7 = objc_claimAutoreleasedReturnValue(v6);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100016FFC;
  block[3] = &unk_10017A670;
  v9 = a2;
  block[4] = a1;
  dispatch_sync(v7, block);

}

void sub_100016FFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  unsigned int v15;
  NSObject *v16;
  void *v18;

  if (dword_1001A6AD0)
  {
    if (*(_BYTE *)(a1 + 40))
      v9 = "mux";
    else
      v9 = "non-mux";
    sub_10001A7E4(0, "usb_host_disconnected_block_invoke", CFSTR("%s"), a4, a5, a6, a7, a8, (char)v9);
  }
  objc_msgSend((id)qword_1001A7FF8, "invalidate");
  if (qword_1001A8008)
  {
    CFUserNotificationCancel((CFUserNotificationRef)qword_1001A8008);
    if (qword_1001A8008)
      CFRelease((CFTypeRef)qword_1001A8008);
    qword_1001A8008 = 0;
  }
  if (qword_1001A8010)
  {
    CFUserNotificationCancel((CFUserNotificationRef)qword_1001A8010);
    if (qword_1001A8010)
      CFRelease((CFTypeRef)qword_1001A8010);
    qword_1001A8010 = 0;
  }
  sub_10000EDAC(*(_QWORD *)(a1 + 32), 0, (uint64_t)CFSTR("UntrustedHostBUID"), 0, v10, v11, v12, v13);
  v14 = (void *)qword_1001A8028;
  qword_1001A8028 = 0;

  byte_1001A8019 = 0;
  byte_1001A801A = 0;
  byte_1001A8018 = 0;
  if (objc_msgSend((id)qword_1001A8000, "count") && objc_msgSend((id)qword_1001A8000, "count"))
  {
    v15 = 1;
    do
    {
      v16 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001A8000, "lastObject"));
      dispatch_group_leave(v16);

      objc_msgSend((id)qword_1001A8000, "removeLastObject");
    }
    while ((unint64_t)objc_msgSend((id)qword_1001A8000, "count") > v15++);
  }
  if (*(_BYTE *)(a1 + 40))
  {
    if (byte_1001A801B == 1)
      byte_1001A801B = 0;
    v18 = (void *)qword_1001A8020;
    if (qword_1001A8020)
    {
      qword_1001A8020 = 0;

    }
  }
  sub_100016EF4();
}

void sub_100017184(uint64_t a1)
{
  id v2;
  NSObject *v3;
  id v4;
  NSObject *v5;
  _QWORD block[5];

  v2 = sub_1000140BC();
  v3 = objc_claimAutoreleasedReturnValue(v2);
  dispatch_assert_queue_not_V2(v3);

  v4 = sub_1000140BC();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100017204;
  block[3] = &unk_100179E10;
  block[4] = a1;
  dispatch_sync(v5, block);

}

id sub_100017204(uint64_t a1)
{
  id result;
  id v2;
  void *v3;
  unsigned int v4;
  NSObject *v5;

  result = *(id *)(a1 + 32);
  if (result)
  {
    v2 = objc_msgSend(result, "copy");
    v3 = (void *)qword_1001A8028;
    qword_1001A8028 = (uint64_t)v2;

    result = objc_msgSend((id)qword_1001A8000, "count");
    if (result)
    {
      result = objc_msgSend((id)qword_1001A8000, "count");
      if (result)
      {
        v4 = 1;
        do
        {
          v5 = objc_claimAutoreleasedReturnValue(objc_msgSend((id)qword_1001A8000, "lastObject"));
          dispatch_group_leave(v5);

          objc_msgSend((id)qword_1001A8000, "removeLastObject");
          result = objc_msgSend((id)qword_1001A8000, "count");
        }
        while ((unint64_t)result > v4++);
      }
    }
  }
  return result;
}

void sub_100017294(const __CFDictionary *a1)
{
  const void *Value;

  if (a1)
  {
    Value = CFDictionaryGetValue(a1, CFSTR("SystemBUID"));
    sub_100017184((uint64_t)Value);
  }
}

uint64_t sub_1000172B8(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  id v8;
  NSObject *v9;
  uint64_t v10;
  _QWORD block[8];
  char v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  const __CFString *v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = CFSTR("UserDeniedPairing");
  v8 = sub_1000140BC();
  v9 = objc_claimAutoreleasedReturnValue(v8);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100017384;
  block[3] = &unk_10017A818;
  block[4] = &v14;
  block[5] = a1;
  block[6] = a2;
  block[7] = a3;
  v13 = a4;
  dispatch_sync(v9, block);

  v10 = v15[3];
  _Block_object_dispose(&v14, 8);
  return v10;
}

void sub_100017384(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  const void *v12;
  _BOOL4 v13;
  dispatch_semaphore_t v14;
  const void *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFDictionary *Mutable;
  __CFString **v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  id v36;
  uint64_t v37;
  void *v38;
  id v39;
  uint64_t v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  dispatch_semaphore_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  CFUserNotificationRef v65;
  uint64_t v66;
  uint64_t v67;
  void *v68;
  dispatch_queue_global_t global_queue;
  NSObject *v70;
  uint64_t v71;
  char v72;
  char v73;
  void *v74;
  void *value;
  _QWORD block[4];
  dispatch_semaphore_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t *v80;
  CFUserNotificationRef v81;
  uint64_t v82;
  uint64_t v83;
  char v84;
  uint64_t v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  uint64_t (*v92)(uint64_t, uint64_t);
  void (*v93)(uint64_t);
  id v94;

  v89 = 0;
  v90 = &v89;
  v91 = 0x3032000000;
  v92 = sub_1000140A4;
  v93 = sub_1000140B4;
  v94 = 0;
  v85 = 0;
  v86 = &v85;
  v87 = 0x2020000000;
  v88 = 0;
  v9 = *(_QWORD *)(a1 + 40);
  if (!v9)
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("NULL connection state."), a4, a5, a6, a7, a8, v72);
    v14 = 0;
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFSTR("InvalidConnection");
    goto LABEL_21;
  }
  v10 = *(_QWORD *)v9;
  v11 = *(_DWORD *)(v9 + 16);
  v12 = *(const void **)(a1 + 48);
  if (v12)
    v13 = CFEqual(v12, CFSTR("com.apple.SystemConfiguration.InterfaceNamer")) != 0;
  else
    v13 = 0;
  v15 = (const void *)sub_10000ED98(v10, 0, (uint64_t)CFSTR("ActivationState"));
  v16 = v15;
  if (v15 && CFEqual(v15, CFSTR("FactoryActivated")))
    goto LABEL_10;
  if (MKBUserSessionIsLoginWindow(0, 0))
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("At LOGIN window. Defaulting to allow pair."), v17, v18, v19, v20, v21, v72);
    goto LABEL_10;
  }
  if ((byte_1001A8019 & 1) == 0 && v11 != 2)
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("USB or proxy host no longer connected."), v17, v18, v19, v20, v21, v72);
    Mutable = 0;
    v14 = 0;
    v23 = off_10017B8E0;
LABEL_25:
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = *v23;
    goto LABEL_17;
  }
  if (qword_1001A8030 && qword_1001A8030 == qword_1001A6AC8)
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Denying pair from connection %llu since we're still on that connection."), v17, v18, v19, v20, v21, qword_1001A8030);
    goto LABEL_15;
  }
  if (qword_1001A8038)
  {
    v24 = sub_1000267A0();
    v86[3] = v24;
    if (qword_1001A8038 == qword_1001A6AC8)
    {
      sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Allowing pairing from connection %llu since we're still on that connection."), v25, v26, v27, v28, v29, qword_1001A8038);
      goto LABEL_10;
    }
    if (v24 - qword_1001A8040 <= 9)
    {
      sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Allowing pairing from connnection %llu since only %llu seconds have elapsed since the user said trust from connection %llu."), v25, v26, v27, v28, v29, v24 - qword_1001A8040);
LABEL_10:
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      if (*(_BYTE *)(a1 + 64) && v11 != 2)
        sub_100016B58(1);
      if (!v13)
        sub_1000110EC(CFSTR("com.apple.mobile.lockdown.trusted_ptp_attached"));
      goto LABEL_15;
    }
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Ignoring user-allowed pairing from connection %llu since %llu seconds have elapsed since the user said trust from connection %llu."), v25, v26, v27, v28, v29, v24 - qword_1001A8040);
    sub_100015588();
  }
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = CFSTR("PairingDialogResponsePending");
  if (!qword_1001A8008)
  {
    if (v13)
    {
      Mutable = 0;
      v14 = 0;
      v23 = off_10017B8B0;
      goto LABEL_25;
    }
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      value = (void *)sub_1000268F4(CFSTR("TRUST_DIALOG_HEADER"), (uint64_t)CFSTR("Pairing"));
      v35 = *(void **)(a1 + 56);
      if (v35)
      {
        v36 = v35;
        if ((unint64_t)objc_msgSend(v36, "length") > 0x3E)
          v37 = 63;
        else
          v37 = (uint64_t)objc_msgSend(v36, "length");
        v39 = objc_msgSend(v36, "rangeOfComposedCharacterSequencesForRange:", 0, v37);
        v74 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v36, "substringWithRange:", v39, v40));

        v41 = (void *)sub_1000268F4(CFSTR("TRUST_DIALOG_MESSAGE_DETAILED"), (uint64_t)CFSTR("Pairing"));
        v72 = (char)v74;
        v38 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v41, CFSTR("%@"), 0));

        if (!v38)
        {
          sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Failed to validate format string."), v42, v43, v44, v45, v46, (char)v74);

          goto LABEL_16;
        }
      }
      else
      {
        v38 = (void *)sub_1000268F4(CFSTR("TRUST_DIALOG_MESSAGE"), (uint64_t)CFSTR("Pairing"));
        v74 = 0;
      }
      v47 = (void *)sub_1000268F4(CFSTR("TRUST_DIALOG_DENY_TRUST"), (uint64_t)CFSTR("Pairing"));
      v48 = (void *)sub_1000268F4(CFSTR("TRUST_DIALOG_ALLOW_TRUST"), (uint64_t)CFSTR("Pairing"));
      CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, value);
      CFDictionarySetValue(Mutable, kCFUserNotificationAlertMessageKey, v38);
      CFDictionarySetValue(Mutable, kCFUserNotificationDefaultButtonTitleKey, v47);
      CFDictionarySetValue(Mutable, kCFUserNotificationAlternateButtonTitleKey, v48);
      CFDictionarySetValue(Mutable, SBUserNotificationAlternateButtonPresentationStyleKey, &off_10019BE58);
      CFDictionarySetValue(Mutable, SBUserNotificationDefaultButtonPresentationStyleKey, &off_10019BE70);
      CFDictionarySetValue(Mutable, SBUserNotificationAllowInSetupKey, kCFBooleanTrue);
      CFDictionarySetValue(Mutable, SBUserNotificationPendWhileKeyBagLockedKey, kCFBooleanTrue);

      sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Asking the user if they want to pair."), v49, v50, v51, v52, v53, v72);
      v54 = dispatch_semaphore_create(0);
      if (v54)
      {
        v14 = v54;
        v65 = CFUserNotificationCreate(0, 0.0, 3uLL, 0, Mutable);
        if (v65)
        {
          sub_1000110EC(CFSTR("com.apple.mobile.lockdown.open_trust_dialog"));
          qword_1001A8008 = (uint64_t)v65;
          CFRetain(v65);
          v66 = qword_1001A6AC8;
          v67 = os_transaction_create("com.apple.mobile.lockdownd");
          v68 = (void *)v90[5];
          v90[5] = v67;

          global_queue = dispatch_get_global_queue(0, 0);
          v70 = objc_claimAutoreleasedReturnValue(global_queue);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_100017A94;
          block[3] = &unk_10017A7F0;
          v81 = v65;
          v82 = v66;
          v78 = &v85;
          v84 = 0;
          v14 = v14;
          v71 = *(_QWORD *)(a1 + 32);
          v77 = v14;
          v83 = v10;
          v79 = v71;
          v80 = &v89;
          dispatch_async(v70, block);

        }
        else
        {
          sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Failed to create user notification."), v60, v61, v62, v63, v64, v73);
        }
        goto LABEL_17;
      }
      sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Failed to create semaphore."), v55, v56, v57, v58, v59, v73);
      goto LABEL_16;
    }
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke", CFSTR("Failed to create dictionary."), v30, v31, v32, v33, v34, v72);
  }
LABEL_15:
  Mutable = 0;
LABEL_16:
  v14 = 0;
LABEL_17:
  if (v16)
    CFRelease(v16);
  if (Mutable)
    CFRelease(Mutable);
LABEL_21:
  _Block_object_dispose(&v85, 8);
  _Block_object_dispose(&v89, 8);

}

void sub_100017A64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_100017A94(uint64_t a1)
{
  SInt32 v2;
  id v3;
  NSObject *v4;
  id v5;
  id v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;
  _QWORD v11[5];
  __int128 v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  _QWORD block[4];
  __int128 v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  CFOptionFlags v24;
  SInt32 v25;
  char v26;
  _QWORD v27[3];
  char v28;
  _QWORD v29[3];
  char v30;
  CFOptionFlags responseFlags;

  responseFlags = 0;
  v2 = CFUserNotificationReceiveResponse(*(CFUserNotificationRef *)(a1 + 64), 0.0, &responseFlags);
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = sub_1000267A0();
  v29[0] = 0;
  v29[1] = v29;
  v29[2] = 0x2020000000;
  v30 = 0;
  v27[0] = 0;
  v27[1] = v27;
  v27[2] = 0x2020000000;
  v28 = 0;
  v3 = sub_1000140BC();
  v4 = objc_claimAutoreleasedReturnValue(v3);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100017C30;
  block[3] = &unk_10017A7A0;
  v25 = v2;
  v23 = *(_QWORD *)(a1 + 72);
  v24 = responseFlags;
  v21 = v27;
  v10 = *(_OWORD *)(a1 + 32);
  v26 = *(_BYTE *)(a1 + 88);
  v5 = (id)v10;
  v20 = v10;
  v22 = v29;
  dispatch_sync(v4, block);

  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  v6 = sub_1000140BC();
  v7 = objc_claimAutoreleasedReturnValue(v6);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_100018194;
  v11[3] = &unk_10017A7C8;
  v11[4] = v29;
  v12 = *(_OWORD *)(a1 + 40);
  v18 = *(_BYTE *)(a1 + 88);
  v8 = *(_QWORD *)(a1 + 80);
  v15 = *(_QWORD *)(a1 + 72);
  v16 = v8;
  v9 = *(_QWORD *)(a1 + 56);
  v17 = *(_QWORD *)(a1 + 64);
  v13 = v27;
  v14 = v9;
  dispatch_sync(v7, v11);

  _Block_object_dispose(v27, 8);
  _Block_object_dispose(v29, 8);
}

void sub_100017C30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  dispatch_queue_global_t global_queue;
  NSObject *v14;
  dispatch_queue_global_t v15;
  NSObject *v16;
  uint64_t v17;
  id v18;
  __int128 v19;
  _QWORD v20[4];
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  char v26;
  _QWORD block[5];
  uint64_t v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t (*v31)(uint64_t, uint64_t);
  void (*v32)(uint64_t);
  id v33;

  v9 = *(_DWORD *)(a1 + 80);
  if (v9)
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke_3", CFSTR("CFUserNotificationReceiveResponse returned %ld at time %llu connection %llu."), a4, a5, a6, a7, a8, v9);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 72) & 3;
    if (v10 == 1 && MKBGetDeviceLockState(0) - 1 <= 1)
    {
      v28 = 0;
      v29 = &v28;
      v30 = 0x3032000000;
      v31 = sub_1000140A4;
      v32 = sub_1000140B4;
      v33 = 0;
      v11 = os_transaction_create("com.apple.mobile.lockdownd");
      v12 = (void *)v29[5];
      v29[5] = v11;

      global_queue = dispatch_get_global_queue(0, 0);
      v14 = objc_claimAutoreleasedReturnValue(global_queue);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100017E18;
      block[3] = &unk_10017A178;
      block[4] = &v28;
      dispatch_async(v14, block);

      _Block_object_dispose(&v28, 8);
      LODWORD(v10) = 3;
    }
    v15 = dispatch_get_global_queue(0, 0);
    v16 = objc_claimAutoreleasedReturnValue(v15);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    v20[2] = sub_100017EB8;
    v20[3] = &unk_10017A778;
    v25 = v10;
    v17 = *(_QWORD *)(a1 + 48);
    v24 = *(_QWORD *)(a1 + 64);
    v22 = v17;
    v19 = *(_OWORD *)(a1 + 32);
    v26 = *(_BYTE *)(a1 + 84);
    v18 = (id)v19;
    v21 = v19;
    v23 = *(_QWORD *)(a1 + 56);
    dispatch_async(v16, v20);

  }
}

void sub_100017E00(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_100017E18(uint64_t a1)
{
  const __CFString *v2;
  const __CFString *v3;
  uint64_t v4;
  void *v5;

  v2 = (const __CFString *)sub_1000268F4(CFSTR("TRUST_FAILED_HEADER"), (uint64_t)CFSTR("Pairing"));
  v3 = (const __CFString *)sub_1000268F4(CFSTR("TRUST_FAILED_TEXT"), (uint64_t)CFSTR("Pairing"));
  CFUserNotificationDisplayNotice(0.0, 2uLL, 0, 0, 0, v2, v3, 0);
  if (v2)
    CFRelease(v2);
  if (v3)
    CFRelease(v3);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = 0;

}

void sub_100017EB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  __CFString **v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD *v16;
  id v17;
  NSObject *v18;
  id v19;
  NSObject *v20;
  char v21;
  _QWORD v22[4];
  id v23;
  uint64_t v24;
  char v25;
  _QWORD block[4];
  id v27;

  v9 = *(_DWORD *)(a1 + 72);
  if (v9 == 3)
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke_5", CFSTR("The notification was cancelled at time %llu connection %llu."), a4, a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
    goto LABEL_11;
  }
  if (v9 != 1)
  {
    if (!v9)
    {
      sub_10001A7E4(0, "ask_user_to_trust_block_invoke_5", CFSTR("User said don't trust at time %llu connection %llu."), a4, a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24) = 1;
      if (!*(_BYTE *)(a1 + 76))
      {
        v10 = &off_10017A3F8;
LABEL_13:
        sub_1000110EC(*v10);
        goto LABEL_14;
      }
      goto LABEL_14;
    }
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke_5", CFSTR("Unknown button %d at time %llu connection %llu."), a4, a5, a6, a7, a8, v9);
LABEL_11:
    if (!*(_BYTE *)(a1 + 76))
    {
      v10 = &off_10017A408;
      goto LABEL_13;
    }
    goto LABEL_14;
  }
  sub_10001A7E4(0, "ask_user_to_trust_block_invoke_5", CFSTR("User said trust at time %llu connection %llu."), a4, a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
  if (MKBGetDeviceLockState(0) == 3)
  {
    if (!*(_BYTE *)(a1 + 76))
    {
      v10 = &off_10017A3F0;
      goto LABEL_13;
    }
LABEL_14:
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
    return;
  }
  sub_10001A7E4(0, "ask_user_to_trust_block_invoke_5", CFSTR("Prompting user for passcode."), v11, v12, v13, v14, v15, v21);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 3221225472;
  v22[2] = sub_100018108;
  v22[3] = &unk_10017A750;
  v24 = *(_QWORD *)(a1 + 56);
  v25 = *(_BYTE *)(a1 + 76);
  v23 = *(id *)(a1 + 32);
  v16 = v22;
  v17 = sub_1000140BC();
  v18 = objc_claimAutoreleasedReturnValue(v17);
  dispatch_assert_queue_not_V2(v18);

  v19 = sub_1000140BC();
  v20 = objc_claimAutoreleasedReturnValue(v19);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100019544;
  block[3] = &unk_10017A900;
  v27 = v16;
  dispatch_sync(v20, block);

}

intptr_t sub_100018108(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFString **v9;
  char v11;

  if ((a2 & 1) != 0)
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke_6", CFSTR("Passcode authentication succeeded."), a4, a5, a6, a7, a8, v11);
    if (!*(_BYTE *)(a1 + 48))
    {
      v9 = &off_10017A3F0;
LABEL_6:
      sub_1000110EC(*v9);
    }
  }
  else
  {
    sub_10001A7E4(0, "ask_user_to_trust_block_invoke_6", CFSTR("Passcode authentication failed."), a4, a5, a6, a7, a8, v11);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    if (!*(_BYTE *)(a1 + 48))
    {
      v9 = &off_10017A3F8;
      goto LABEL_6;
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100018194(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  id v12;
  NSObject *v13;
  time_t v14;
  id v15;
  void *v16;
  id v17;
  id v18;
  id v19;
  void *v20;
  id v21;
  uint64_t v22;
  void *i;
  void *v24;
  void *v25;
  uint64_t v26;
  id v27;
  id v28;
  id v29;
  id v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const void *v36;
  uint64_t v37;
  void *v38;
  char v39;
  uint64_t v40;
  id v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _BYTE v46[128];

  v8 = a1;
  v9 = *(_QWORD *)(a1 + 72);
  if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    if (qword_1001A8038 < v9)
    {
      qword_1001A8038 = *(_QWORD *)(a1 + 72);
      v10 = *(_QWORD *)(a1 + 48);
      qword_1001A8040 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      *(_QWORD *)(*(_QWORD *)(v10 + 8) + 24) = 0;
      if (!*(_BYTE *)(a1 + 96))
        sub_1000110EC(CFSTR("com.apple.mobile.lockdown.trusted_ptp_attached"));
    }
    if (byte_1001A801B == 1 && qword_1001A8028 != 0)
    {
      sub_10001A7E4(0, "trigger_host_pair", CFSTR("Notifying host to pair."), a4, a5, a6, a7, a8, v39);
      notify_post("com.apple.mobile.lockdown.request_pair");
    }
  }
  else
  {
    if (qword_1001A8030 < v9)
      qword_1001A8030 = *(_QWORD *)(a1 + 72);
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
    {
      v12 = sub_1000140BC();
      v13 = objc_claimAutoreleasedReturnValue(v12);
      dispatch_assert_queue_V2(v13);

      if (qword_1001A8028)
      {
        v40 = v8;
        v14 = time(0);
        v15 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"));
        if (!v15)
          v15 = objc_alloc_init((Class)NSMutableDictionary);
        v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSNumber numberWithLong:](NSNumber, "numberWithLong:", v14));
        objc_msgSend(v15, "setObject:forKey:", v16, qword_1001A8028);

        if ((unint64_t)objc_msgSend(v15, "count") >= 0x65)
        {
          v41 = v15;
          do
          {
            v44 = 0u;
            v45 = 0u;
            v42 = 0u;
            v43 = 0u;
            v17 = v15;
            v18 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v42, v46, 16);
            if (v18)
            {
              v19 = v18;
              v20 = 0;
              v21 = 0;
              v22 = *(_QWORD *)v43;
              while (2)
              {
                for (i = 0; i != v19; i = (char *)i + 1)
                {
                  if (*(_QWORD *)v43 != v22)
                    objc_enumerationMutation(v17);
                  v24 = *(void **)(*((_QWORD *)&v42 + 1) + 8 * (_QWORD)i);
                  v25 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v17, "objectForKey:", v24));
                  if (v21)
                  {
                    v26 = objc_opt_class(NSNumber);
                    if ((objc_opt_isKindOfClass(v25, v26) & 1) == 0)
                    {
                      v30 = v24;

                      v20 = v30;
                      goto LABEL_32;
                    }
                    if (objc_msgSend(v21, "compare:", v25) == (id)1)
                    {
                      v27 = v24;

                      v28 = v25;
                      v20 = v27;
                      v21 = v28;
                    }
                  }
                  else
                  {
                    v29 = v24;

                    v21 = v25;
                    v20 = v29;
                  }

                }
                v19 = objc_msgSend(v17, "countByEnumeratingWithState:objects:count:", &v42, v46, 16);
                if (v19)
                  continue;
                break;
              }
LABEL_32:

              if (v20)
                objc_msgSend(v17, "removeObjectForKey:", v20);
              v15 = v41;
            }
            else
            {

              v21 = 0;
              v20 = 0;
            }

          }
          while ((unint64_t)objc_msgSend(v17, "count") > 0x64);
        }
        if ((objc_msgSend(v15, "writeToFile:atomically:", CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"), 0) & 1) == 0)sub_10001A7E4(0, "add_untrusted_host", CFSTR("Failed to write %@."), v31, v32, v33, v34, v35, (char)CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"));
        v8 = v40;
      }
      else
      {
        v15 = 0;
      }

    }
  }
  v36 = *(const void **)(v8 + 88);
  if ((const void *)qword_1001A8008 == v36)
  {
    if (qword_1001A8008)
    {
      CFRelease((CFTypeRef)qword_1001A8008);
      v36 = *(const void **)(v8 + 88);
    }
    else
    {
      v36 = 0;
    }
    qword_1001A8008 = 0;
  }
  CFRelease(v36);
  v37 = *(_QWORD *)(*(_QWORD *)(v8 + 64) + 8);
  v38 = *(void **)(v37 + 40);
  *(_QWORD *)(v37 + 40) = 0;

}

uint64_t sub_100018558(uint64_t a1, uint64_t a2)
{
  id v3;
  NSObject *v4;
  uint64_t v5;
  _QWORD v7[6];
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  const __CFString *v11;

  v8 = 0;
  v9 = &v8;
  v10 = 0x2020000000;
  v11 = CFSTR("UserDeniedPTP");
  v3 = sub_1000140BC();
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100018608;
  v7[3] = &unk_10017A1E8;
  v7[4] = &v8;
  v7[5] = a2;
  dispatch_sync(v4, v7);

  v5 = v9[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_100018608(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  BOOL v10;
  uint64_t *v11;
  __CFString **v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __CFDictionary *Mutable;
  CFTypeRef v27;
  uint64_t v28;
  const __CFString *v29;
  const void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CFTypeRef v36;
  CFTypeRef v37;
  CFTypeRef v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  CFUserNotificationRef v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  CFUserNotificationRef v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  dispatch_queue_global_t global_queue;
  NSObject *v55;
  uint64_t v56;
  char v57;
  char v58;
  char v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD block[9];
  char v63;
  uint64_t v64;
  uint64_t *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t (*v71)(uint64_t, uint64_t);
  void (*v72)(uint64_t);
  id v73;

  v68 = 0;
  v69 = &v68;
  v70 = 0x3032000000;
  v71 = sub_1000140A4;
  v72 = sub_1000140B4;
  v73 = 0;
  v64 = 0;
  v65 = &v64;
  v66 = 0x2020000000;
  v67 = 0;
  if ((byte_1001A8019 & 1) == 0)
  {
    v11 = (uint64_t *)(a1 + 32);
    v12 = off_10017B960;
LABEL_5:
    *(_QWORD *)(*(_QWORD *)(*v11 + 8) + 24) = *v12;
    goto LABEL_10;
  }
  v9 = *(const void **)(a1 + 40);
  if (v9)
    v10 = CFEqual(v9, CFSTR("com.apple.SystemConfiguration.InterfaceNamer")) != 0;
  else
    v10 = 0;
  if (qword_1001A8030 && qword_1001A8030 == qword_1001A6AC8)
  {
    sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Denied ptp access from connection %llu since we're still on that connection."), a4, a5, a6, a7, a8, qword_1001A8030);
    goto LABEL_10;
  }
  if (qword_1001A8038)
  {
    v13 = sub_1000267A0();
    v65[3] = v13;
    if (qword_1001A8038 == qword_1001A6AC8)
    {
      sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Allowing ptp from connection %llu since we're still on that connection."), v14, v15, v16, v17, v18, qword_1001A8038);
      goto LABEL_16;
    }
    if (v13 - qword_1001A8040 <= 9)
    {
      sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Allowing ptp from connnection %llu since only %llu seconds have elapsed since the user said trust from connection %llu."), v14, v15, v16, v17, v18, v13 - qword_1001A8040);
LABEL_16:
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
      if (!v10)
        sub_1000110EC(CFSTR("com.apple.mobile.lockdown.trusted_ptp_attached"));
      goto LABEL_10;
    }
    v60 = qword_1001A6AC8;
    v61 = qword_1001A8038;
    sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Ignoring user-allowed ptp from connection %llu since %llu seconds have elapsed since the user said trust from connection %llu."), v14, v15, v16, v17, v18, v13 - qword_1001A8040);
    sub_100015588();
  }
  v19 = *(const void **)(a1 + 40);
  if (!v19 || !CFEqual(v19, CFSTR("com.apple.SystemConfiguration.InterfaceNamer")))
  {
    v20 = *(_QWORD *)(a1 + 32);
    v11 = (uint64_t *)(a1 + 32);
    *(_QWORD *)(*(_QWORD *)(v20 + 8) + 24) = CFSTR("PTPDialogResponsePending");
    if (!qword_1001A8010)
    {
      if (v10)
      {
        v12 = off_10017B8B0;
        goto LABEL_5;
      }
      Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        v27 = sub_1000268F4(CFSTR("PTP_DIALOG_MESSAGE"), (uint64_t)CFSTR("PTP"));
        v28 = MGCopyAnswer(CFSTR("device-name-localized"), 0);
        if (v28)
          v29 = (const __CFString *)v28;
        else
          v29 = CFSTR("iOS device");
        v30 = (const void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", v27, CFSTR("%@"), 0, v29, v60, v61));
        CFRelease(v29);
        if (v27)
          CFRelease(v27);
        if (v30)
        {
          v36 = sub_1000268F4(CFSTR("PTP_DIALOG_HEADER"), (uint64_t)CFSTR("PTP"));
          v37 = sub_1000268F4(CFSTR("PTP_DIALOG_DENY_TRUST"), (uint64_t)CFSTR("PTP"));
          v38 = sub_1000268F4(CFSTR("PTP_DIALOG_ALLOW_TRUST"), (uint64_t)CFSTR("PTP"));
          CFDictionarySetValue(Mutable, kCFUserNotificationAlertHeaderKey, v36);
          CFDictionarySetValue(Mutable, kCFUserNotificationAlertMessageKey, v30);
          CFDictionarySetValue(Mutable, kCFUserNotificationDefaultButtonTitleKey, v37);
          CFDictionarySetValue(Mutable, kCFUserNotificationAlternateButtonTitleKey, v38);
          CFDictionarySetValue(Mutable, SBUserNotificationAllowInSetupKey, kCFBooleanTrue);
          CFDictionarySetValue(Mutable, SBUserNotificationPendWhileKeyBagLockedKey, kCFBooleanTrue);
          if (v36)
            CFRelease(v36);
          CFRelease(v30);
          if (v37)
            CFRelease(v37);
          if (v38)
            CFRelease(v38);
          sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Asking the user if they want to allow ptp."), v39, v40, v41, v42, v43, v58);
          v44 = CFUserNotificationCreate(0, 0.0, 3uLL, 0, Mutable);
          v50 = v44;
          if (v44)
          {
            qword_1001A8010 = (uint64_t)v44;
            CFRetain(v44);
            v51 = qword_1001A6AC8;
            v52 = os_transaction_create("com.apple.mobile.lockdown");
            v53 = (void *)v69[5];
            v69[5] = v52;

            global_queue = dispatch_get_global_queue(0, 0);
            v55 = objc_claimAutoreleasedReturnValue(global_queue);
            block[0] = _NSConcreteStackBlock;
            block[1] = 3221225472;
            block[2] = sub_100018B60;
            block[3] = &unk_10017A868;
            block[7] = v50;
            block[8] = v51;
            v56 = *v11;
            block[4] = &v64;
            block[5] = v56;
            v63 = 0;
            block[6] = &v68;
            dispatch_async(v55, block);

          }
          else
          {
            sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Failed to create user notification."), v45, v46, v47, v48, v49, v59);
          }
        }
        else
        {
          sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Failed to validate format string."), v31, v32, v33, v34, v35, v58);
        }
        CFRelease(Mutable);
      }
      else
      {
        sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke", CFSTR("Failed to create dictionary."), v21, v22, v23, v24, v25, v57);
      }
    }
  }
LABEL_10:
  _Block_object_dispose(&v64, 8);
  _Block_object_dispose(&v68, 8);

}

void sub_100018B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  uint64_t v15;
  va_list va;

  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_100018B60(uint64_t a1)
{
  SInt32 v2;
  id v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v8[4];
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  CFOptionFlags v12;
  uint64_t v13;
  SInt32 v14;
  char v15;
  CFOptionFlags responseFlags;

  responseFlags = 0;
  v2 = CFUserNotificationReceiveResponse(*(CFUserNotificationRef *)(a1 + 56), 0.0, &responseFlags);
  v3 = sub_1000140BC();
  v4 = objc_claimAutoreleasedReturnValue(v3);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_100018C10;
  v8[3] = &unk_10017A840;
  v14 = v2;
  v9 = *(_OWORD *)(a1 + 32);
  v15 = *(_BYTE *)(a1 + 72);
  v6 = *(_QWORD *)(a1 + 56);
  v5 = *(_QWORD *)(a1 + 64);
  v7 = *(_QWORD *)(a1 + 48);
  v12 = responseFlags;
  v13 = v6;
  v10 = v7;
  v11 = v5;
  dispatch_sync(v4, v8);

}

void sub_100018C10(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  dispatch_queue_global_t global_queue;
  NSObject *v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  void *v16;
  _QWORD block[5];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t (*v21)(uint64_t, uint64_t);
  void (*v22)(uint64_t);
  id v23;

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_1000267A0();
  v7 = *(_DWORD *)(a1 + 80);
  if (v7)
  {
    sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke_3", CFSTR("CFUserNotificationReceiveResponse returned %ld at time %llu connection %llu."), v2, v3, v4, v5, v6, v7);
    goto LABEL_15;
  }
  v8 = *(_QWORD *)(a1 + 64);
  if ((v8 & 3) == 1 && MKBGetDeviceLockState(0) - 1 <= 1)
  {
    v18 = 0;
    v19 = &v18;
    v20 = 0x3032000000;
    v21 = sub_1000140A4;
    v22 = sub_1000140B4;
    v23 = 0;
    v9 = os_transaction_create("com.apple.mobile.lockdownd");
    v10 = (void *)v19[5];
    v19[5] = v9;

    global_queue = dispatch_get_global_queue(0, 0);
    v12 = objc_claimAutoreleasedReturnValue(global_queue);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100018EE0;
    block[3] = &unk_10017A178;
    block[4] = &v18;
    dispatch_async(v12, block);

    _Block_object_dispose(&v18, 8);
LABEL_10:
    sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke_3", CFSTR("The notification was cancelled at time %llu connection %llu."), v2, v3, v4, v5, v6, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    goto LABEL_15;
  }
  if ((v8 & 3) == 3)
    goto LABEL_10;
  if ((v8 & 3) != 1)
  {
    if ((v8 & 3) != 0)
      sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke_3", CFSTR("Unknown button %d at time %llu connection %llu."), v2, v3, v4, v5, v6, v8 & 3);
    else
      sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke_3", CFSTR("User said don't trust ptp at time %llu connection %llu."), v2, v3, v4, v5, v6, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
LABEL_15:
    if ((unint64_t)qword_1001A8030 < *(_QWORD *)(a1 + 56))
      qword_1001A8030 = *(_QWORD *)(a1 + 56);
    goto LABEL_17;
  }
  sub_10001A7E4(0, "ask_user_to_trust_ptp_block_invoke_3", CFSTR("User said trust at time ptp %llu connection %llu."), v2, v3, v4, v5, v6, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
  if ((unint64_t)qword_1001A8038 < *(_QWORD *)(a1 + 56))
  {
    qword_1001A8038 = *(_QWORD *)(a1 + 56);
    v13 = *(_QWORD *)(a1 + 40);
    qword_1001A8040 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    *(_QWORD *)(*(_QWORD *)(v13 + 8) + 24) = 0;
    if (!*(_BYTE *)(a1 + 84))
      sub_1000110EC(CFSTR("com.apple.mobile.lockdown.trusted_ptp_attached"));
  }
LABEL_17:
  v14 = *(const void **)(a1 + 72);
  if ((const void *)qword_1001A8010 == v14)
  {
    if (qword_1001A8010)
    {
      CFRelease((CFTypeRef)qword_1001A8010);
      v14 = *(const void **)(a1 + 72);
    }
    else
    {
      v14 = 0;
    }
    qword_1001A8010 = 0;
  }
  CFRelease(v14);
  v15 = *(_QWORD *)(*(_QWORD *)(a1 + 48) + 8);
  v16 = *(void **)(v15 + 40);
  *(_QWORD *)(v15 + 40) = 0;

}

void sub_100018EC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100018EE0(uint64_t a1)
{
  const __CFString *v2;
  const __CFString *v3;
  uint64_t v4;
  void *v5;

  v2 = (const __CFString *)sub_1000268F4(CFSTR("PTP_FAILED_HEADER"), (uint64_t)CFSTR("PTP"));
  v3 = (const __CFString *)sub_1000268F4(CFSTR("PTP_FAILED_TEXT"), (uint64_t)CFSTR("PTP"));
  CFUserNotificationDisplayNotice(0.0, 2uLL, 0, 0, 0, v2, v3, 0);
  if (v2)
    CFRelease(v2);
  if (v3)
    CFRelease(v3);
  v4 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v5 = *(void **)(v4 + 40);
  *(_QWORD *)(v4 + 40) = 0;

}

BOOL sub_100018F80(uint64_t *a1, const void *a2, CFDictionaryRef theDict, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v12;
  BOOL v13;
  id v14;
  id v15;
  __CFString **v16;
  uint64_t v17;
  unsigned int v18;
  id v19;
  NSObject *v20;
  id v21;
  NSObject *v22;
  NSObject *v23;
  dispatch_time_t v24;
  id v25;
  NSObject *v26;
  id v27;
  NSObject *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  char v34;
  void *v35;
  _BOOL8 v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  CFMutableDictionaryRef v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char v61;
  char v62;
  __int16 v63;
  _QWORD v64[5];
  _QWORD v65[5];
  _QWORD block[5];
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  uint64_t (*v70)(uint64_t, uint64_t);
  void (*v71)(uint64_t);
  id v72;
  uint64_t v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t (*v76)(uint64_t, uint64_t);
  void (*v77)(uint64_t);
  id v78;

  v63 = 0;
  if (!a1)
  {
    sub_10001A7E4(0, "is_host_trusted", CFSTR("NULL connection state."), (uint64_t)a4, a5, a6, a7, a8, v61);
    v14 = 0;
    v15 = 0;
    v16 = off_10017B990;
    goto LABEL_5;
  }
  v9 = a5;
  v12 = *a1;
  if (theDict)
    v13 = CFDictionaryGetValue(theDict, CFSTR("IgnoreUntrustedList")) == kCFBooleanTrue;
  else
    v13 = 0;
  v18 = sub_10000F404(v12, 0, CFSTR("TrustedHostAttached"), (uint64_t)a4, a5, a6, a7, a8);
  v17 = 0;
  v15 = 0;
  v14 = 0;
  if (!v18)
  {
    v62 = v9;
    v73 = 0;
    v74 = &v73;
    v75 = 0x3032000000;
    v76 = sub_1000140A4;
    v77 = sub_1000140B4;
    v78 = 0;
    v67 = 0;
    v68 = &v67;
    v69 = 0x3032000000;
    v70 = sub_1000140A4;
    v71 = sub_1000140B4;
    v72 = 0;
    v19 = sub_1000140BC();
    v20 = objc_claimAutoreleasedReturnValue(v19);
    dispatch_assert_queue_not_V2(v20);

    v21 = sub_1000140BC();
    v22 = objc_claimAutoreleasedReturnValue(v21);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100019970;
    block[3] = &unk_10017A178;
    block[4] = &v67;
    dispatch_sync(v22, block);

    v23 = v68[5];
    if (v23)
    {
      v24 = dispatch_time(0, 10000000000);
      if (dispatch_group_wait(v23, v24))
      {
        v25 = sub_1000140BC();
        v26 = objc_claimAutoreleasedReturnValue(v25);
        v65[0] = _NSConcreteStackBlock;
        v65[1] = 3221225472;
        v65[2] = sub_100019A80;
        v65[3] = &unk_10017A178;
        v65[4] = &v67;
        dispatch_async(v26, v65);

      }
    }
    v27 = sub_1000140BC();
    v28 = objc_claimAutoreleasedReturnValue(v27);
    v64[0] = _NSConcreteStackBlock;
    v64[1] = 3221225472;
    v64[2] = sub_100019AE4;
    v64[3] = &unk_10017A178;
    v64[4] = &v73;
    dispatch_sync(v28, v64);

    v15 = (id)v74[5];
    _Block_object_dispose(&v67, 8);

    _Block_object_dispose(&v73, 8);
    if (v15)
      v34 = v13;
    else
      v34 = 1;
    if ((v34 & 1) != 0)
    {
      v14 = 0;
      goto LABEL_21;
    }
    v14 = objc_msgSend(objc_alloc((Class)NSDictionary), "initWithContentsOfFile:", CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"));
    v35 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v14, "objectForKey:", v15));

    if (!v35)
    {
LABEL_21:
      if (sub_10000F404(v12, 0, CFSTR("TrustedHostAttached"), v29, v30, v31, v32, v33))
      {
LABEL_22:
        v17 = 0;
        goto LABEL_23;
      }
      if ((sub_100026EA4(0, 0, 0, (_BYTE *)&v63 + 1, &v63) & 1) == 0)
      {
        sub_10001A7E4(0, "is_host_trusted", CFSTR("MC disallowed pairing."), v38, v39, v40, v41, v42, v9);
        v16 = off_10017B890;
        goto LABEL_5;
      }
      if (a2)
      {
        if (CFEqual(a2, CFSTR("com.apple.ptp")) || CFEqual(a2, CFSTR("com.apple.SystemConfiguration.InterfaceNamer")))
        {
          if (CFEqual(a2, CFSTR("com.apple.SystemConfiguration.InterfaceNamer")))
            v9 = (uint64_t)a2;
          if ((sub_100027234(v12, v43, v44, v45, v46, v47, v48, v49) & 1) == 0)
          {
            sub_10001A7E4(0, "is_host_trusted", CFSTR("Buddy has not completed. Implicitly trusting host."), v50, v51, v52, v53, v54, v62);
            goto LABEL_22;
          }
          v55 = sub_10000F404(v12, CFSTR("com.apple.mobile.debug"), CFSTR("DisableUnpairedPTP"), v50, v51, v52, v53, v54);
          if ((_DWORD)v55)
          {
            sub_10001A7E4(0, "is_host_trusted", CFSTR("Not allowing PTP access since DisableUnpairedPTP is set."), v56, v57, v58, v59, v60, v62);
LABEL_33:
            v16 = off_10017B8D8;
            goto LABEL_5;
          }
          if ((byte_1001A801B & 1) == 0)
          {
            v17 = sub_100018558((uint64_t)v55, v9);
            goto LABEL_6;
          }
        }
        else if (CFEqual(a2, CFSTR("com.apple.InternetTethering")) && (byte_1001A801B & 1) == 0)
        {
          goto LABEL_33;
        }
      }
      v17 = sub_1000172B8((uint64_t)a1, v9, 0, 0);
      goto LABEL_6;
    }
    v16 = off_10017B8B0;
LABEL_5:
    v17 = (uint64_t)*v16;
LABEL_6:
    if (a4 && v17)
      *a4 = v17;
  }
LABEL_23:
  v36 = v17 == 0;

  return v36;
}

void sub_1000193C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  uint64_t v26;

  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 152), 8);
  _Unwind_Resume(a1);
}

void sub_1000193E8(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.mobile.lockdownd.pairing", 0);
  v2 = (void *)qword_1001A8048;
  qword_1001A8048 = (uint64_t)v1;

  if (!qword_1001A8048)
    sub_1000F973C();
}

void sub_10001942C(uint64_t a1)
{
  id v2;
  uint64_t v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v2 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"));
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

  v5 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  if (v5)
  {
    v6 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v5, "objectForKey:", *(_QWORD *)(a1 + 40)));

    if (v6)
    {
      objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "removeObjectForKey:", *(_QWORD *)(a1 + 40));
      if (objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "count"))
      {
        if ((objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "writeToFile:atomically:", CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"), 0) & 1) == 0)sub_10001A7E4(0, "remove_untrusted_host_block_invoke", CFSTR("Failed to write %@."), v7, v8, v9, v10, v11, (char)CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"));
      }
      else if (unlink((const char *)objc_msgSend(CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"), "fileSystemRepresentation")))
      {
        v12 = __error();
        strerror(*v12);
        sub_10001A7E4(0, "remove_untrusted_host_block_invoke", CFSTR("Failed to unlink %@: %s"), v13, v14, v15, v16, v17, (char)CFSTR("/private/var/root/Library/Lockdown/untrusted_hosts.plist"));
      }
    }
  }
}

void sub_100019544(uint64_t a1)
{
  id v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  NSMutableDictionary *v9;
  void *v10;
  void *v11;
  dispatch_semaphore_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  dispatch_queue_global_t global_queue;
  NSObject *v21;
  const __CFString *v22;
  char v23;
  _QWORD block[4];
  id v25;
  uint64_t *v26;
  uint64_t *v27;
  _QWORD *v28;
  uint64_t *v29;
  uint64_t v30;
  uint64_t *v31;
  uint64_t v32;
  uint64_t (*v33)(uint64_t, uint64_t);
  void (*v34)(uint64_t);
  id v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t (*v43)(uint64_t, uint64_t);
  void (*v44)(uint64_t);
  id v45;
  _QWORD v46[3];
  char v47;

  v46[0] = 0;
  v46[1] = v46;
  v46[2] = 0x2020000000;
  v47 = 0;
  v40 = 0;
  v41 = &v40;
  v42 = 0x3032000000;
  v43 = sub_1000140A4;
  v44 = sub_1000140B4;
  v45 = 0;
  v36 = 0;
  v37 = &v36;
  v38 = 0x2020000000;
  v39 = 0;
  v30 = 0;
  v31 = &v30;
  v32 = 0x3032000000;
  v33 = sub_1000140A4;
  v34 = sub_1000140B4;
  v35 = 0;
  v2 = objc_alloc_init((Class)LAContext);
  v3 = (void *)qword_1001A7FF8;
  qword_1001A7FF8 = (uint64_t)v2;

  if (!qword_1001A7FF8)
  {
    v22 = CFSTR("Failed to allocate LAContext.");
LABEL_11:
    sub_10001A7E4(0, "askUserForPasscode_block_invoke", v22, v4, v5, v6, v7, v8, v23);
    v11 = 0;
LABEL_12:
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
    goto LABEL_13;
  }
  v9 = objc_opt_new(NSMutableDictionary);
  v10 = (void *)v31[5];
  v31[5] = (uint64_t)v9;

  if (!v31[5])
  {
    v22 = CFSTR("Failed to allocate dictionary.");
    goto LABEL_11;
  }
  v11 = (void *)sub_1000268F4(CFSTR("TRUST_DIALOG_MESSAGE_SIMPLE"), (uint64_t)CFSTR("Pairing"));
  if (v11)
    objc_msgSend((id)v31[5], "setObject:forKey:", v11, &off_10019BE70);
  v12 = dispatch_semaphore_create(0);
  v13 = (void *)v41[5];
  v41[5] = (uint64_t)v12;

  if (!v41[5])
  {
    sub_10001A7E4(0, "askUserForPasscode_block_invoke", CFSTR("Failed to allocate wait semaphore."), v14, v15, v16, v17, v18, v23);
    goto LABEL_12;
  }
  v37[3] = 1013;
  v19 = (void *)sub_1000268F4(CFSTR("ENTER_PASSCODE_TITLE"), (uint64_t)CFSTR("Pairing"));
  if (v19)
    objc_msgSend((id)v31[5], "setObject:forKey:", v19, &off_10019BE88);

  global_queue = dispatch_get_global_queue(0, 0);
  v21 = objc_claimAutoreleasedReturnValue(global_queue);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100019818;
  block[3] = &unk_10017A8D8;
  v26 = &v36;
  v27 = &v30;
  v28 = v46;
  v29 = &v40;
  v25 = *(id *)(a1 + 32);
  dispatch_async(v21, block);

LABEL_13:
  _Block_object_dispose(&v30, 8);

  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);

  _Block_object_dispose(v46, 8);
}

void sub_1000197D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  uint64_t v13;
  va_list va;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  va_list va1;

  va_start(va1, a11);
  va_start(va, a11);
  v13 = va_arg(va1, _QWORD);
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v18 = va_arg(va1, _QWORD);
  v19 = va_arg(va1, _QWORD);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Block_object_dispose((const void *)(v11 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100019818(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  NSObject *v4;
  dispatch_time_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD v12[4];
  __int128 v13;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_10001990C;
  v12[3] = &unk_10017A8B0;
  v13 = *(_OWORD *)(a1 + 56);
  objc_msgSend((id)qword_1001A7FF8, "evaluatePolicy:options:reply:", v2, v3, v12);
  v4 = *(NSObject **)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 40);
  v5 = dispatch_time(0, 120000000000);
  if (dispatch_semaphore_wait(v4, v5))
  {
    sub_10001A7E4(0, "askUserForPasscode_block_invoke", CFSTR("Timed out waiting %d minutes for passcode."), v6, v7, v8, v9, v10, 2);
    objc_msgSend((id)qword_1001A7FF8, "invalidate");
  }
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

intptr_t sub_10001990C(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  else
    sub_10001A7E4(0, "askUserForPasscode_block_invoke_2", CFSTR("Passcode policy evaluation FAILED: %@"), a4, a5, a6, a7, a8, a3);
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 40));
}

void sub_100019970(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  BOOL v9;
  dispatch_group_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  id v21;
  void *v22;
  const __CFString *v23;

  v9 = byte_1001A801B == 1 && qword_1001A8028 == 0;
  if (v9 && (byte_1001A801A != 1 || objc_msgSend((id)qword_1001A8000, "count")))
  {
    v11 = dispatch_group_create();
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v13 = *(void **)(v12 + 40);
    *(_QWORD *)(v12 + 40) = v11;

    v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
    if (v19)
    {
      v20 = (void *)qword_1001A8000;
      if (qword_1001A8000)
      {
LABEL_12:
        objc_msgSend(v20, "addObject:", v19);
        dispatch_group_enter(*(dispatch_group_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
        byte_1001A801A = 1;
        return;
      }
      v21 = objc_alloc_init((Class)NSMutableArray);
      v22 = (void *)qword_1001A8000;
      qword_1001A8000 = (uint64_t)v21;

      v20 = (void *)qword_1001A8000;
      if (qword_1001A8000)
      {
        v19 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
        goto LABEL_12;
      }
      v23 = CFSTR("Failed to create array.");
    }
    else
    {
      v23 = CFSTR("Failed to create group.");
      LODWORD(v20) = 0;
    }
    sub_10001A7E4((int)v20, "get_untrusted_host_buid_block_invoke", v23, v14, v15, v16, v17, v18, a9);
  }
}

void sub_100019A80(uint64_t a1)
{
  if (objc_msgSend((id)qword_1001A8000, "containsObject:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40)))
  {
    objc_msgSend((id)qword_1001A8000, "removeObject:", *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
    dispatch_group_leave(*(dispatch_group_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40));
  }
}

void sub_100019AE4(uint64_t a1)
{
  objc_storeStrong((id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), (id)qword_1001A8028);
}

void sub_100019AFC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0xCu);
}

_QWORD *sub_100019B08(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  dispatch_queue_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFData *v20;
  CFPropertyListRef v21;
  const __CFArray *v22;
  const __CFArray *v23;
  CFIndex Count;
  CFIndex i;
  void *ValueAtIndex;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  char v34;
  char v35;
  _QWORD v36[7];
  unint64_t size;
  uint64_t v38;
  uint64_t *v39;
  uint64_t v40;
  char v41;

  v38 = 0;
  v39 = &v38;
  v40 = 0x2020000000;
  v41 = 0;
  v7 = malloc_type_calloc(1uLL, 0x20uLL, 0xE004003B0627DuLL);
  if (!v7)
  {
    sub_10001A7E4(0, "service_ark_load", CFSTR("Could not allocate service ark"), v2, v3, v4, v5, v6, v34);
LABEL_10:
    v7 = 0;
    goto LABEL_27;
  }
  v8 = dispatch_queue_create("com.apple.mobile.lockdownd.dark", 0);
  *v7 = v8;
  if (!v8)
  {
    sub_10001A7E4(0, "service_ark_load", CFSTR("Failed to initialize queue."), v9, v10, v11, v12, v13, v34);
    free(v7);
    goto LABEL_10;
  }
  size = 0;
  v14 = getsectiondata(&_mh_execute_header, "__TEXT", "__services", &size);
  if (v14)
  {
    if (size)
    {
      v20 = CFDataCreate(0, v14, size);
      if (v20)
      {
        v21 = CFPropertyListCreateWithData(0, v20, 0, 0, 0);
        CFRelease(v20);
        if (sub_100010B40(v21))
        {
          v7[1] = v21;
        }
        else
        {
          sub_10001A7E4(0, "service_ark_load", CFSTR("Bogus Service Map supplied"), v15, v16, v17, v18, v19, v34);
          if (v21)
            CFRelease(v21);
        }
      }
    }
  }
  if (!v7[1])
    sub_10001A7E4(0, "service_ark_load", CFSTR("Could not load service map"), v15, v16, v17, v18, v19, v34);
  v36[0] = _NSConcreteStackBlock;
  v36[1] = 3221225472;
  v36[2] = sub_100019F44;
  v36[3] = &unk_10017A928;
  v36[5] = a1;
  v36[6] = v7;
  v36[4] = &v38;
  sub_100019DB8((uint64_t)v7, v36);
  v22 = (const __CFArray *)sub_10000A1CC();
  v23 = v22;
  if (v22)
  {
    Count = CFArrayGetCount(v22);
    if (Count >= 1)
    {
      for (i = 0; i != Count; ++i)
      {
        v35 = 0;
        ValueAtIndex = (void *)CFArrayGetValueAtIndex(v23, i);
        sub_10000A384(a1, (dispatch_queue_t *)v7, ValueAtIndex, &v35);
        if (v35)
          *((_BYTE *)v39 + 24) = 1;
      }
    }
    CFRelease(v23);
  }
  if (*((_BYTE *)v39 + 24))
  {
    if (sub_100029F1C())
      v32 = CFSTR("Refreshed remote services.");
    else
      v32 = CFSTR("Failed to refresh remote services.");
    sub_10001A7E4(0, "service_ark_load", v32, v27, v28, v29, v30, v31, v34);
  }
LABEL_27:
  _Block_object_dispose(&v38, 8);
  return v7;
}

void sub_100019D88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100019DB8(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  NSObject *v9;
  void *v10;
  uint64_t v11;
  _QWORD v13[4];
  id v14;
  uint64_t *v15;
  _QWORD block[6];
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t, uint64_t);
  void (*v21)(uint64_t);
  id v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  char v26;

  v8 = a2;
  v23 = 0;
  v24 = &v23;
  v25 = 0x2020000000;
  v26 = 1;
  v17 = 0;
  v18 = &v17;
  v19 = 0x3032000000;
  v20 = sub_10001A690;
  v21 = sub_10001A6A0;
  v22 = 0;
  if (a1 && *(_QWORD *)(a1 + 8) && (v9 = *(NSObject **)a1) != 0)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10001A6A8;
    block[3] = &unk_10017A1E8;
    block[4] = &v17;
    block[5] = a1;
    dispatch_sync(v9, block);
    v10 = (void *)v18[5];
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 3221225472;
    v13[2] = sub_10001A6E0;
    v13[3] = &unk_10017A998;
    v15 = &v23;
    v14 = v8;
    objc_msgSend(v10, "enumerateKeysAndObjectsUsingBlock:", v13);

  }
  else
  {
    sub_10001A7E4(0, "service_ark_enumerate", CFSTR("Invalid argument."), v3, v4, v5, v6, v7, v13[0]);
  }
  v11 = *((unsigned __int8 *)v24 + 24);
  _Block_object_dispose(&v17, 8);

  _Block_object_dispose(&v23, 8);
  return v11;
}

void sub_100019F20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  uint64_t v13;
  va_list va;

  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100019F44(uint64_t a1, void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v12;

  v12 = 0;
  if ((sub_100029910(a2, *(_QWORD *)(a1 + 40), *(dispatch_queue_t **)(a1 + 48), &v12) & 1) == 0
    && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
  {
    sub_1000F9990((uint64_t)a2, v4, v5, v6, v7, v8, v9, v10);
  }
  if (v12)
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  return 1;
}

NSObject **sub_100019FC0(dispatch_queue_t *a1, uint64_t a2)
{
  NSObject **v2;
  NSObject *v4;
  _QWORD block[7];
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v2 = a1;
  v7 = 0;
  v8 = &v7;
  v9 = 0x2020000000;
  v10 = 0;
  if (a1)
  {
    dispatch_assert_queue_not_V2(*a1);
    v4 = *v2;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10001A080;
    block[3] = &unk_10017A950;
    block[5] = v2;
    block[6] = a2;
    block[4] = &v7;
    dispatch_sync(v4, block);
    v2 = (NSObject **)v8[3];
  }
  _Block_object_dispose(&v7, 8);
  return v2;
}

void sub_10001A068(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

const void **sub_10001A080(const void **result)
{
  const void **v1;

  if (*((_QWORD *)result[5] + 1))
  {
    v1 = result;
    if (sub_100010BA8(result[6]))
      *(_QWORD *)(*((_QWORD *)v1[4] + 1) + 24) = CFDictionaryGetValue(*((CFDictionaryRef *)v1[5] + 1), v1[6]);
    result = *(const void ***)(*((_QWORD *)v1[4] + 1) + 24);
    if (result)
      return (const void **)CFRetain(result);
  }
  return result;
}

BOOL sub_10001A0E8(NSObject **a1, uint64_t a2, int a3, uint64_t a4)
{
  NSObject *v4;
  _BOOL8 v5;
  _QWORD block[8];
  int v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  char v12;

  v9 = 0;
  v10 = &v9;
  v11 = 0x2020000000;
  v12 = 0;
  if (a1)
  {
    v4 = *a1;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10001A194;
    block[3] = &unk_10017A2E8;
    v8 = a3;
    block[6] = a2;
    block[7] = a4;
    block[4] = &v9;
    block[5] = a1;
    dispatch_sync(v4, block);
    v5 = *((_BYTE *)v10 + 24) != 0;
  }
  else
  {
    v5 = 0;
  }
  _Block_object_dispose(&v9, 8);
  return v5;
}

void sub_10001A194(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFDictionary *v16;
  const __CFNumber *Value;
  unsigned int v18;
  int v19;
  CFNumberRef v20;
  CFNumberRef v21;
  int valuePtr;

  v10 = *(_QWORD *)(a1 + 40);
  if (!*(_QWORD *)(v10 + 16))
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) = sub_100025A4C();
    v10 = *(_QWORD *)(a1 + 40);
    if (!*(_QWORD *)(v10 + 16))
    {
      LODWORD(v16) = 0;
LABEL_13:
      sub_10001A7E4((int)v16, "service_ark_increment_block_invoke", CFSTR("Failed to create dictionary."), v11, v12, v13, v14, v15, a9);
      return;
    }
  }
  v16 = *(const __CFDictionary **)(v10 + 24);
  if (!v16)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24) = sub_100025A4C();
    v16 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 40) + 24);
    if (!v16)
      goto LABEL_13;
  }
  valuePtr = 0;
  Value = (const __CFNumber *)CFDictionaryGetValue(v16, *(const void **)(a1 + 48));
  if (sub_100010B0C(Value))
    CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
  else
    valuePtr = 0;
  v18 = *(_DWORD *)(a1 + 64);
  if (!v18 || valuePtr + 1 <= v18)
  {
    v19 = dword_1001A8058++;
    **(_DWORD **)(a1 + 56) = v19;
    ++valuePtr;
    v20 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 40) + 24), *(const void **)(a1 + 48), v20);
    CFRelease(v20);
    v21 = CFNumberCreate(0, kCFNumberIntType, *(const void **)(a1 + 56));
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 40) + 16), v21, *(const void **)(a1 + 48));
    CFRelease(v21);
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
}

void sub_10001A308(NSObject **a1, int a2)
{
  NSObject *v2;
  _QWORD v3[5];
  int v4;

  if (a1)
  {
    v2 = *a1;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10001A368;
    v3[3] = &unk_10017A970;
    v4 = a2;
    v3[4] = a1;
    dispatch_sync(v2, v3);
  }
}

void sub_10001A368(uint64_t a1)
{
  CFNumberRef v2;
  const __CFDictionary *v3;
  const void *v4;
  const void *v5;
  const __CFNumber *Value;
  CFNumberRef v7;
  int valuePtr;

  v2 = CFNumberCreate(0, kCFNumberIntType, (const void *)(a1 + 40));
  v3 = *(const __CFDictionary **)(*(_QWORD *)(a1 + 32) + 16);
  if (v3 && (v4 = CFDictionaryGetValue(v3, v2)) != 0)
  {
    v5 = v4;
    CFRetain(v4);
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 32) + 16), v2);
    CFRelease(v2);
    if (!CFDictionaryGetCount(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 16)))
    {
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 16));
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 16) = 0;
    }
    valuePtr = 0;
    Value = (const __CFNumber *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 24), v5);
    if (Value)
    {
      CFNumberGetValue(Value, kCFNumberIntType, &valuePtr);
      if (--valuePtr)
      {
        v7 = CFNumberCreate(0, kCFNumberIntType, &valuePtr);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 32) + 24), v5, v7);
        CFRelease(v7);
      }
      else
      {
        CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(_QWORD *)(a1 + 32) + 24), v5);
        if (!CFDictionaryGetCount(*(CFDictionaryRef *)(*(_QWORD *)(a1 + 32) + 24)))
        {
          CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 32) + 24));
          *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = 0;
        }
      }
    }
    CFRelease(v5);
  }
  else if (v2)
  {
    CFRelease(v2);
  }
}

void sub_10001A4C4(dispatch_queue_t *a1, uint64_t a2, void *a3, uint64_t a4, char *a5)
{
  NSObject *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[8];
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char v21;

  v18 = 0;
  v19 = &v18;
  v20 = 0x2020000000;
  v21 = 0;
  if (a1)
  {
    v9 = *a1;
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    v17[2] = sub_10001A5C0;
    v17[3] = &unk_10017A2A0;
    v17[6] = a3;
    v17[7] = a4;
    v17[4] = &v18;
    v17[5] = a1;
    dispatch_sync(v9, v17);
    if (!*((_BYTE *)v19 + 24)
      && (sub_100029910(a3, a2, a1, a5) & 1) == 0
      && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
    {
      sub_1000F9990((uint64_t)a3, v10, v11, v12, v13, v14, v15, v16);
    }
  }
  _Block_object_dispose(&v18, 8);
}

void sub_10001A5A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10001A5C0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFDictionary *MutableCopy;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFDictionary *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, *(CFDictionaryRef *)(*(_QWORD *)(a1 + 40) + 8));
  if (MutableCopy)
  {
    v16 = MutableCopy;
    if (CFDictionaryContainsKey(MutableCopy, *(const void **)(a1 + 48)))
    {
      CFRelease(v16);
      sub_10001A7E4(0, "service_ark_add_entry_block_invoke", CFSTR("Overwriting service: %@ not allowed"), v17, v18, v19, v20, v21, *(_QWORD *)(a1 + 48));
      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
    }
    else
    {
      CFDictionarySetValue(v16, *(const void **)(a1 + 48), *(const void **)(a1 + 56));
      CFRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 40) + 8));
      *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) = v16;
    }
  }
  else
  {
    sub_10001A7E4(0, "service_ark_add_entry_block_invoke", CFSTR("Could not make copy of service map"), v11, v12, v13, v14, v15, a9);
  }
}

uint64_t sub_10001A690(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10001A6A0(uint64_t a1)
{

}

void sub_10001A6A8(uint64_t a1)
{
  id v2;
  uint64_t v3;
  void *v4;

  v2 = objc_msgSend(*(id *)(*(_QWORD *)(a1 + 40) + 8), "copy");
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v4 = *(void **)(v3 + 40);
  *(_QWORD *)(v3 + 40) = v2;

}

uint64_t sub_10001A6E0(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  char v4;

  result = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
  if (*(_BYTE *)(v3 + 24))
    v4 = result;
  else
    v4 = 0;
  *(_BYTE *)(v3 + 24) = v4;
  return result;
}

void sub_10001A720(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, &a9, 0xCu);
}

BOOL sub_10001A730(const std::__fs::filesystem::path *a1, uint64_t a2)
{
  std::error_code *v4;
  std::__fs::filesystem::path __to;
  char __str[1024];

  if (a2 >= 0x80000)
  {
    snprintf(__str, 0x400uLL, "%s.%d", (const char *)a1, 1);
    unlink(__str);
    snprintf((char *)&__to, 0x400uLL, "%s.1", (const char *)a1);
    rename(a1, &__to, v4);
  }
  return a2 >= 0x80000;
}

void sub_10001A7E4(int a1, const char *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFString *v12;
  const __CFString *v13;
  tm *v14;
  __darwin_suseconds_t tv_usec;
  pid_t v16;
  timeval v17;
  char *v18;
  _QWORD block[5];
  char v20[8];
  uint64_t v21;
  __int16 v22;
  uint8_t buf[4];
  const char *v24;
  __int16 v25;
  char *v26;
  char buffer[2048];

  v18 = 0;
  bzero(buffer, 0x800uLL);
  if (!a2)
    a2 = "";
  v18 = &a9;
  v12 = CFStringCreateWithFormatAndArguments(0, 0, a3, &a9);
  v13 = v12;
  if (v12 && !CFStringGetCString(v12, buffer, 2048, 0x8000100u))
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Failed to retrieve C string.", buf, 2u);
    }
    goto LABEL_14;
  }
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136315394;
    v24 = a2;
    v25 = 2080;
    v26 = buffer;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "%s: %s", buf, 0x16u);
  }
  if (!a1 && dword_1001A6AD8)
  {
    bzero(buf, 0x800uLL);
    v17.tv_sec = 0;
    *(_QWORD *)&v17.tv_usec = 0;
    *(_QWORD *)v20 = 0;
    v21 = 0;
    v22 = 0;
    gettimeofday(&v17, 0);
    v14 = localtime(&v17.tv_sec);
    strftime(v20, 0x12uLL, "%D %H:%M:%S", v14);
    tv_usec = v17.tv_usec;
    v16 = getpid();
    snprintf((char *)buf, 0x800uLL, "%s.%06d pid=%d %s: %s\n", v20, tv_usec, v16, a2, buffer);
    if (qword_1001A8070 != -1)
      dispatch_once(&qword_1001A8070, &stru_10017A9D8);
    if (qword_1001A8060)
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = sub_10001AA8C;
      block[3] = &unk_10017A9F8;
      block[4] = buf;
      dispatch_sync((dispatch_queue_t)qword_1001A8060, block);
    }
  }
  if (v13)
LABEL_14:
    CFRelease(v13);
}

void sub_10001AA64(id a1)
{
  qword_1001A8060 = (uint64_t)dispatch_queue_create("com.apple.mobile.lockdownd.log", 0);
}

uint64_t sub_10001AA8C(uint64_t a1)
{
  size_t v2;
  uint64_t result;
  int v4;
  int v5;
  int v6;
  const __CFString *v10;
  int *v11;
  int *v12;
  int v13;
  off_t st_size;
  int *v15;
  stat v16;
  stat v17;
  _QWORD v18[128];

  memset(&v16, 0, sizeof(v16));
  if ((dword_1001A6ADC & 0x80000000) == 0)
  {
LABEL_2:
    v2 = strlen(*(const char **)(a1 + 32));
    write(dword_1001A6ADC, *(const void **)(a1 + 32), v2);
    qword_1001A8068 += v2;
    result = sub_10001A730((const std::__fs::filesystem::path *)"/private/var/logs/lockdownd.log", qword_1001A8068);
    if (!(_DWORD)result)
      return result;
    v4 = dword_1001A6ADC;
    goto LABEL_20;
  }
  bzero(v18, 0x400uLL);
  memset(&v17, 0, sizeof(v17));
  v5 = open("/private/var/logs/lockdownd.log", 777, 420);
  if (v5 != -1)
  {
    v6 = v5;
    if (fcntl(v5, 50, v18) == -1)
    {
      v12 = __error();
      strerror(*v12);
      v10 = CFSTR("F_GETPATH(%s) failed: %s");
    }
    else if (v18[0] == 0x657461766972702FLL
           && v18[1] == 0x676F6C2F7261762FLL
           && v18[2] == 0x6F646B636F6C2F73
           && v18[3] == 0x676F6C2E646E77)
    {
      if (fstat(v6, &v17) == -1)
      {
        v15 = __error();
        strerror(*v15);
        v10 = CFSTR("fstat(%s) failed: %s");
      }
      else
      {
        if ((v17.st_mode & 0xF000) == 0x8000)
        {
          dword_1001A6ADC = v6;
          v13 = fstat(v6, &v16);
          st_size = v16.st_size;
          if (v13)
            st_size = 0;
          qword_1001A8068 = st_size;
          goto LABEL_2;
        }
        v10 = CFSTR("%s type is %d, not %d");
      }
    }
    else
    {
      v10 = CFSTR("path %s was actually %s, something fishy is going on");
    }
    sub_10001A7E4(1, "log_safe_create", v10);
    v4 = v6;
LABEL_20:
    result = close(v4);
    goto LABEL_21;
  }
  v11 = __error();
  strerror(*v11);
  result = sub_10001A7E4(1, "log_safe_create", CFSTR("open(%s) failed: %s"));
LABEL_21:
  dword_1001A6ADC = -1;
  return result;
}

uint64_t sub_10001AD28(const __CFString *a1, const void *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v14;
  char v15;

  if (a1 && a2)
  {
    if (a3)
      v10 = a3;
    else
      v10 = kCFPreferencesAnyApplication;
    v11 = (const __CFString *)sub_10001ADF0();
    CFPreferencesSetValue(a1, a2, v10, v11, kCFPreferencesAnyHost);
    v12 = (const __CFString *)sub_10001ADF0();
    if (CFPreferencesSynchronize(v10, v12, kCFPreferencesAnyHost))
      return 0;
    v15 = (char)v10;
    v14 = CFSTR("Failed to synchronize preferences (%@).");
  }
  else
  {
    v14 = CFSTR("Invalid input(s).");
  }
  sub_10001A7E4(0, "lockbot_set_preference", v14, a4, a5, a6, a7, a8, v15);
  return 0xFFFFFFFFLL;
}

id sub_10001ADF0()
{
  if (qword_1001A8080 != -1)
    dispatch_once(&qword_1001A8080, &stru_10017AA38);
  return (id)qword_1001A8078;
}

CFPropertyListRef sub_10001AE30(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  char v13;

  if (a1)
  {
    if (a2)
      v9 = a2;
    else
      v9 = kCFPreferencesAnyApplication;
    v10 = (const __CFString *)sub_10001ADF0();
    CFPreferencesSynchronize(v9, v10, kCFPreferencesAnyHost);
    v11 = (const __CFString *)sub_10001ADF0();
    return CFPreferencesCopyValue(a1, v9, v11, kCFPreferencesAnyHost);
  }
  else
  {
    sub_10001A7E4(0, "lockbot_copy_preference", CFSTR("Invalid input."), a4, a5, a6, a7, a8, v13);
    return 0;
  }
}

uint64_t sub_10001AEC8(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  const __CFString *v13;
  char v14;

  if (a1)
  {
    v8 = a1;
    if (a2)
      v9 = a2;
    else
      v9 = kCFPreferencesAnyApplication;
    v10 = (const __CFString *)sub_10001ADF0();
    CFPreferencesSetValue(v8, 0, v9, v10, kCFPreferencesAnyHost);
    v11 = (const __CFString *)sub_10001ADF0();
    LODWORD(a1) = CFPreferencesSynchronize(v9, v11, kCFPreferencesAnyHost);
    if ((_DWORD)a1)
      return 0;
    v14 = (char)v9;
    v13 = CFSTR("Failed to synchronize preferences (%@).");
  }
  else
  {
    v13 = CFSTR("Invalid input.");
  }
  sub_10001A7E4((int)a1, "lockbot_remove_preference", v13, a4, a5, a6, a7, a8, v14);
  return 0xFFFFFFFFLL;
}

uint64_t sub_10001AF84(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  CFDictionaryRef v10;
  id v11;
  void *v12;
  uint64_t v13;
  char v15;
  _QWORD v16[5];

  if (a1)
  {
    v9 = (const __CFString *)sub_10001ADF0();
    v10 = CFPreferencesCopyMultiple(0, a1, v9, kCFPreferencesAnyHost);
    v11 = sub_10001B2EC(v10);
    v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

    if (v12)
    {
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_10001B054;
      v16[3] = &unk_10017AA18;
      v16[4] = a1;
      -[__CFDictionary enumerateKeysAndObjectsUsingBlock:](v10, "enumerateKeysAndObjectsUsingBlock:", v16);
    }
    v13 = 0;
  }
  else
  {
    sub_10001A7E4(0, "lockbot_remove_preference_domain", CFSTR("Invalid input (cannot remove global domain)."), a4, a5, a6, a7, a8, v15);
    v10 = 0;
    v13 = 0xFFFFFFFFLL;
  }

  return v13;
}

uint64_t sub_10001B054(uint64_t a1, void *a2)
{
  const __CFString *v3;
  __CFString *v4;
  const __CFString *v5;
  const __CFString *v6;
  const __CFString *v7;

  v3 = *(const __CFString **)(a1 + 32);
  v4 = a2;
  v5 = (const __CFString *)sub_10001ADF0();
  CFPreferencesSetValue(v4, 0, v3, v5, kCFPreferencesAnyHost);

  v6 = *(const __CFString **)(a1 + 32);
  v7 = (const __CFString *)sub_10001ADF0();
  return CFPreferencesSynchronize(v6, v7, kCFPreferencesAnyHost);
}

CFDictionaryRef sub_10001B0C4(const __CFString *a1)
{
  const __CFString *v1;
  const __CFString *v2;
  const __CFString *v3;

  if (a1)
    v1 = a1;
  else
    v1 = kCFPreferencesAnyApplication;
  v2 = (const __CFString *)sub_10001ADF0();
  CFPreferencesSynchronize(v1, v2, kCFPreferencesAnyHost);
  v3 = (const __CFString *)sub_10001ADF0();
  return CFPreferencesCopyMultiple(0, v1, v3, kCFPreferencesAnyHost);
}

void sub_10001B124(id a1)
{
  id v1;
  id v2;
  void *v3;
  passwd *v4;
  passwd v5;
  char v6[1024];

  memset(&v5, 0, sizeof(v5));
  v4 = 0;
  bzero(v6, 0x400uLL);
  if (getpwnam_r("mobile", &v5, v6, 0x400uLL, &v4) || !v4)
    sub_1000F9A18();
  v1 = objc_alloc((Class)NSString);
  v2 = objc_msgSend(v1, "initWithUTF8String:", v4->pw_name);
  v3 = (void *)qword_1001A8078;
  qword_1001A8078 = (uint64_t)v2;

  if (!qword_1001A8078)
    sub_1000F9A00();
}

id sub_10001B1F0(void *a1)
{
  id v1;
  uint64_t v2;
  id v3;

  v1 = a1;
  v2 = objc_opt_class(NSData);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    v3 = v1;
  else
    v3 = 0;

  return v3;
}

id sub_10001B244(void *a1)
{
  id v1;
  uint64_t v2;
  id v3;

  v1 = a1;
  v2 = objc_opt_class(NSString);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    v3 = v1;
  else
    v3 = 0;

  return v3;
}

id sub_10001B298(void *a1)
{
  id v1;
  uint64_t v2;
  id v3;

  v1 = a1;
  v2 = objc_opt_class(NSNumber);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    v3 = v1;
  else
    v3 = 0;

  return v3;
}

id sub_10001B2EC(void *a1)
{
  id v1;
  uint64_t v2;
  id v3;

  v1 = a1;
  v2 = objc_opt_class(NSDictionary);
  if ((objc_opt_isKindOfClass(v1, v2) & 1) != 0)
    v3 = v1;
  else
    v3 = 0;

  return v3;
}

id sub_10001B340(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  void *v10;
  __CFString *v11;
  uint64_t v12;
  void *v13;
  id v14;
  void *v15;
  CFTypeRef cf;
  CFTypeRef v18;

  cf = 0;
  v18 = 0;
  if (&_CRGenerateRepairReport)
  {
    CRGenerateRepairReport(0, &cf, &v18);
    v9 = (void *)cf;
    if (cf)
    {
      v10 = 0;
      goto LABEL_11;
    }
    v13 = (void *)v18;
    v11 = CFSTR("Failed to query repair report.");
    v12 = 39;
  }
  else
  {
    v11 = CFSTR("CoreRepair not supported on this platform.");
    v12 = 32;
    v13 = 0;
  }
  v14 = sub_100010520((uint64_t)"copyRepairReport", v12, -1, v13, v11, a6, a7, a8, (uint64_t)cf);
  v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
  v10 = v15;
  if (a1)
    *a1 = objc_retainAutorelease(v15);
  if (cf)
    CFRelease(cf);
  v9 = 0;
LABEL_11:
  cf = 0;
  if (v18)
    CFRelease(v18);

  return v9;
}

uint64_t sub_10001B41C(uint64_t a1, const void *a2, const void *a3)
{
  int v5;
  const void *Value;
  const void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFString *v22;

  v5 = sub_1000047F4(*(_QWORD *)(a1 + 24));
  if (!sub_100010B40(a2))
    return 0;
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Request"));
  v7 = sub_100010BA8(Value);
  v8 = (uint64_t)v7;
  if (!v7)
    goto LABEL_47;
  if (CFEqual(v7, CFSTR("QueryType")))
  {
    v8 = 2;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("StartSession")))
  {
    v8 = 13;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("StopSession")))
  {
    v8 = 14;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("StartService")))
  {
    v8 = 15;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("Pair")))
  {
    v8 = 9;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("Unpair")))
  {
    v8 = 11;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("ResetPairing")))
  {
    v8 = 12;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("GetValue")))
  {
    v8 = 3;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("GetValueCU")))
  {
    v8 = 4;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("GetMultipleValues")))
  {
    v8 = 5;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("GetMultipleValuesCU")))
  {
    v8 = 6;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("SetValue")))
  {
    v8 = 7;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("RemoveValue")))
  {
    v8 = 8;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("EnterRecovery")))
  {
    v8 = 16;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("SaveValue")))
  {
    v8 = 17;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("IsHostTrusted")))
  {
    v8 = 18;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("Goodbye")))
  {
    v8 = 1;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("EnableWirelessPairing")))
  {
    v8 = 19;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("CUPairingCreate")))
  {
    v8 = 20;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("CUPairingVerify")))
  {
    v8 = 21;
    goto LABEL_47;
  }
  if (CFEqual((CFTypeRef)v8, CFSTR("PairCU")))
  {
    v8 = 10;
    goto LABEL_47;
  }
  if (!CFEqual((CFTypeRef)v8, CFSTR("ValidateAutomationRecord")))
  {
    sub_10001A7E4(0, "parse_message", CFSTR("Unsupported request: %@"), v9, v10, v11, v12, v13, v8);
    return 0;
  }
  v8 = 23;
LABEL_47:
  if (v5 == 4 && v8 <= 0x10 && ((1 << v8) & 0x1E604) != 0)
  {
    v16 = sub_100010BA8(a3);
    v22 = CFSTR("unknown");
    if (v16)
      LOBYTE(v22) = (_BYTE)a3;
    sub_10001A7E4(0, "parse_message", CFSTR("Client '%@' made improper request type %d, setting to unknown."), v17, v18, v19, v20, v21, (char)v22);
    return 0;
  }
  return v8;
}

void sub_10001B75C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFDictionary *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v10 = sub_1000042FC(CFSTR("Goodbye"));
  sub_1000041C0(*(const __CFData **)(a1 + 24), v10, v11, v12, v13, v14, v15, v16, a9);
}

void sub_10001B78C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFDictionary *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v10 = sub_1000042FC(CFSTR("QueryType"));
  CFDictionarySetValue(v10, CFSTR("Type"), CFSTR("com.apple.mobile.lockdown"));
  sub_1000041C0(*(const __CFData **)(a1 + 24), v10, v11, v12, v13, v14, v15, v16, a9);
}

void sub_10001B7D4(uint64_t a1, void *a2, uint64_t a3, const void *a4, uint64_t *a5, void *a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  const __CFString *v19;
  __CFDictionary *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __CFDictionary *v26;
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  CFMutableDictionaryRef v33;
  int v34;
  const __CFString *v35;
  __CFString **v36;
  __CFDictionary *v37;
  __CFDictionary *v38;
  void *v39;
  char *v40;
  id v41;
  const void *v42;
  const __CFDictionary *v43;
  const __CFDictionary *v44;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v46;
  CFMutableDictionaryRef v47;
  __CFDictionary *v48;
  CFIndex v49;
  const void *v50;
  const __CFString *ValueAtIndex;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const void *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  CFIndex v63;
  const __CFString *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const __CFString *v70;
  uint64_t v71;
  const __CFString *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  const __CFString *v97;
  __CFString *v98;
  void *v99;
  const __CFDictionary *v100;
  CFMutableDictionaryRef v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  CFMutableDictionaryRef v107;
  CFMutableDictionaryRef v108;
  __CFDictionary *v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  const __CFDictionary *v120;
  CFMutableDictionaryRef v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  CFMutableDictionaryRef v127;
  CFMutableDictionaryRef v128;
  void *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  CFIndex v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  __CFDictionary *v141;
  uint64_t v142;
  char v143;
  id v144;
  char v145;
  CFIndex Count;
  uint64_t v147;
  const __CFDictionary *theDict;
  uint64_t v149;
  uint64_t *v150;
  __CFDictionary *v151;
  CFTypeRef value;
  void *valuea;
  __CFString *valueb;
  const void *v155;
  CFIndex v156;
  CFIndex v157;
  const __CFString *v158;
  CFIndex v159;
  uint64_t v160;
  const void *v161;
  CFMutableDictionaryRef v162;
  CFMutableDictionaryRef v163;
  const void *v164;
  CFTypeRef v165;
  __CFString *v166;

  v18 = a6;
  v165 = 0;
  v166 = 0;
  if (!a1)
  {
    sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("Invalid connection."), v13, v14, v15, v16, v17, v145);
    v39 = 0;
    goto LABEL_106;
  }
  if ((_DWORD)a7)
    v19 = CFSTR("GetMultipleValuesCU");
  else
    v19 = CFSTR("GetMultipleValues");
  v20 = sub_1000042FC(v19);
  if (v20)
  {
    v26 = v20;
    v161 = a4;
    v27 = sub_100010B40(a2);
    v33 = 0;
    v34 = 1;
    v35 = CFSTR("Invalid input(s).");
    if (!a5)
    {
      v36 = off_10017B870;
      v37 = 0;
      v164 = 0;
      v38 = 0;
      goto LABEL_90;
    }
    v160 = a3;
    v36 = off_10017B870;
    v37 = 0;
    v164 = 0;
    v38 = 0;
    if (!v27)
    {
LABEL_90:
      v162 = v37;
      v163 = v38;
      sub_10001A7E4(0, "handle_get_multiple_values", v35, v28, v29, v30, v31, v32, v145);
      sub_100004354(v34, (uint64_t)"handle_get_multiple_values", v26, *v36);
      v141 = 0;
      v39 = 0;
      v40 = 0;
LABEL_91:
      sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("Failed to get values for every single key-domain in the request"), v136, v137, v138, v139, v140, v145);
      sub_100004354(1, (uint64_t)"handle_get_multiple_values", v26, CFSTR("GetProhibited"));
LABEL_92:
      sub_1000041C0(*(const __CFData **)(a1 + 24), v26, v142, v136, v137, v138, v139, v140, v145);
      if (v33)
        CFRelease(v33);
      if (v163)
        CFRelease(v163);
      if (v141)
        CFRelease(v141);
      if (v164)
        CFRelease(v164);
      if (v162)
        CFRelease(v162);
      goto LABEL_102;
    }
    if (!v18 && (a7 & 1) != 0)
    {
      v33 = 0;
      v37 = 0;
      v164 = 0;
      v38 = 0;
      v36 = off_10017B870;
      v35 = CFSTR("Invalid pairing session.");
      goto LABEL_90;
    }
    if ((_DWORD)a7)
    {
      v41 = sub_10002B834(v18, a2);
      if (!v41)
      {
        v34 = 0;
        v33 = 0;
        v37 = 0;
        v164 = 0;
        v38 = 0;
        v36 = off_10017B998;
        v35 = CFSTR("Failed to decrypt message.");
        goto LABEL_90;
      }
      a2 = v41;
      v33 = sub_100025A4C();
      if (!v33)
      {
        v34 = 0;
        v37 = 0;
        v164 = 0;
        v38 = 0;
        v36 = off_10017B858;
        v35 = CFSTR("Failed to create result.");
        goto LABEL_90;
      }
    }
    else
    {
      v33 = 0;
    }
    v42 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("MultipleKeys"));
    v43 = (const __CFDictionary *)sub_100010B40(v42);
    v36 = off_10017B870;
    if (!v43)
    {
      v37 = 0;
      v164 = 0;
      v38 = 0;
      v35 = CFSTR("Invalid message.");
      goto LABEL_90;
    }
    v44 = v43;
    v164 = (const void *)CFDictionaryCopyKeys(v43, 0);
    if (!v164)
    {
      v37 = 0;
      v164 = 0;
      v38 = 0;
      v34 = 1;
      v36 = off_10017B998;
      v35 = CFSTR("Failed to get key retrieve dictionary keys.");
      goto LABEL_90;
    }
    Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!Mutable)
    {
      v37 = 0;
      v38 = 0;
      v34 = 1;
      v36 = off_10017B998;
      v35 = CFSTR("Failed to create dictionary.");
      goto LABEL_90;
    }
    v162 = Mutable;
    v46 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!v46)
    {
      v38 = 0;
      v34 = 1;
      v36 = off_10017B998;
      v35 = CFSTR("Failed to create dictionary.");
      v37 = v162;
      goto LABEL_90;
    }
    theDict = v44;
    v163 = v46;
    v47 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (!v47)
    {
      v34 = 1;
      v35 = CFSTR("Failed to create dictionary.");
      v36 = off_10017B998;
      v37 = v162;
      v38 = v163;
      goto LABEL_90;
    }
    v48 = v47;
    CFDictionarySetValue(v162, CFSTR("SuccessValueKey"), v163);
    v151 = v48;
    CFDictionarySetValue(v162, CFSTR("FailureValueKey"), v48);
    Count = CFArrayGetCount((CFArrayRef)v164);
    if (Count < 1)
    {
      v143 = 0;
      v40 = 0;
    }
    else
    {
      v49 = 0;
      v40 = 0;
      v149 = 0;
      v147 = 0;
      v50 = (const void *)v160;
      v150 = a5;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v164, v49);
        if (!sub_100010BA8(ValueAtIndex))
        {
          sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("Invalid domain, expected string: %@"), v52, v53, v54, v55, v56, (char)ValueAtIndex);
          goto LABEL_118;
        }
        v158 = ValueAtIndex;
        v57 = CFDictionaryGetValue(theDict, ValueAtIndex);
        if (!sub_100010B74(v57))
          break;
        v157 = CFArrayGetCount((CFArrayRef)v57);
        if (v157 >= 1)
        {
          v63 = 0;
          v155 = v57;
          v156 = v49;
          while (1)
          {
            v159 = v63;
            v64 = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)v57, v63);
            if (!sub_100010BA8(v64))
            {
              sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("Invalid key, expected string: %@"), v65, v66, v67, v68, v69, (char)v64);
              v98 = CFSTR("GetProhibited");
              goto LABEL_80;
            }
            if (dword_1001A6AD0)
              sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("%@ attempting to get [%@]:[%@]"), v65, v66, v67, v68, v69, (char)v50);
            v70 = v158;
            if (CFStringCompare(v158, CFSTR("NULL"), 0) == kCFCompareEqualTo)
              v70 = 0;
            if (CFStringCompare(v64, CFSTR("NULL"), 0))
              v72 = v64;
            else
              v72 = 0;
            if ((sub_10001C288(v72, v70, v50, v161, a1, 0, a7, v71) & 1) == 0)
            {
              v57 = v155;
              v166 = CFSTR("GetProhibited");
              v50 = (const void *)v160;
              v97 = v158;
              goto LABEL_60;
            }
            if (!v70
              || !v72
              || !CFEqual(v70, CFSTR("com.apple.mobile.wireless_lockdown"))
              || !CFEqual(v72, CFSTR("reset_adverts")))
            {
              v50 = (const void *)v160;
              v99 = sub_10001C364(v72, v70, v160, (uint64_t *)a1, (uint64_t)v161, &v166, v76, v77);
              v97 = v158;
              v57 = v155;
              goto LABEL_52;
            }
            value = CFRetain(kCFBooleanTrue);
            sub_100006DB8(v150, 1, 1, 0, v78, v79, v80, v81, v145);
            if (sub_10000F404(*v150, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiDebugging"), v82, v83, v84, v85, v86)|| sub_10000F404(*v150, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiConnections"), v87, v88, v89, v90, v91))
            {
              v40 = sub_100026BC8();
              BYTE4(v149) |= v40 != 0;
            }
            v50 = (const void *)v160;
            v97 = v158;
            v57 = v155;
            LOBYTE(v149) = (sub_10000F404(*v150, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiPairing"), v92, v93, v94, v95, v96) != 0) | v149;
            if ((v149 & 1) == 0 && (v149 & 0x100000000) == 0)
              break;
            if (sub_100005EF8(v150, (uint64_t)v40, BYTE4(v149) & 1, v149 & 1, 1, v75, v76, v77))
              goto LABEL_72;
            v99 = (void *)CFRetain(kCFBooleanFalse);
LABEL_52:
            if (v99)
            {
              valuea = v99;
              if (v97 && v64)
              {
                v100 = v163;
                if (CFDictionaryContainsKey(v163, v97))
                  goto LABEL_58;
                v101 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                if (v101)
                {
                  v107 = v101;
                  v100 = v163;
                  CFDictionarySetValue(v163, v158, v101);
                  v108 = v107;
                  v97 = v158;
                  v57 = v155;
                  CFRelease(v108);
LABEL_58:
                  v109 = (__CFDictionary *)CFDictionaryGetValue(v100, v97);
                  if (sub_100010B40(v109))
                  {
                    CFDictionarySetValue(v109, v64, valuea);
                    v98 = 0;
                    LOBYTE(v147) = 1;
                    goto LABEL_78;
                  }
                  sub_10001A7E4(0, "populate_success_value", CFSTR("Invalid keyValueDict, expected dictionary: %@"), v110, v111, v112, v113, v114, (char)v109);
                }
                else
                {
                  sub_10001A7E4(0, "populate_success_value", CFSTR("Failed to create dictionary."), v102, v103, v104, v105, v106, v145);
                }
                v98 = CFSTR("InternalError");
LABEL_78:
                v50 = (const void *)v160;
              }
              else
              {
                sub_10001A7E4(0, "populate_success_value", CFSTR("Invalid input(s)."), v73, v74, v75, v76, v77, v145);
                v98 = CFSTR("InternalError");
              }
              CFRelease(valuea);
              goto LABEL_80;
            }
LABEL_60:
            sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("%@ failed to get [%@]:[%@]: %@"), v73, v74, v75, v76, v77, (char)v50);
            if (!v97 || !v64)
            {
              sub_10001A7E4(0, "populate_failed_value", CFSTR("Invalid input(s)."), v115, v116, v117, v118, v119, v145);
              v98 = CFSTR("InternalError");
              goto LABEL_80;
            }
            valueb = v166;
            v120 = v151;
            if (!CFDictionaryContainsKey(v151, v97))
            {
              v121 = CFDictionaryCreateMutable(0, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (!v121)
              {
                sub_10001A7E4(0, "populate_failed_value", CFSTR("Failed to create dictionary."), v122, v123, v124, v125, v126, v145);
LABEL_74:
                v98 = CFSTR("InternalError");
                v50 = (const void *)v160;
LABEL_80:
                v135 = v159;
                if (v98)
                  goto LABEL_119;
                goto LABEL_81;
              }
              v127 = v121;
              v120 = v151;
              CFDictionarySetValue(v151, v158, v121);
              v128 = v127;
              v97 = v158;
              v57 = v155;
              CFRelease(v128);
            }
            v129 = (void *)CFDictionaryGetValue(v120, v97);
            if (!sub_100010B40(v129))
            {
              sub_10001A7E4(0, "populate_failed_value", CFSTR("Invalid value, expected dictionary: %@"), v130, v131, v132, v133, v134, (char)v129);
              goto LABEL_74;
            }
            CFDictionarySetValue((CFMutableDictionaryRef)v129, v64, valueb);
            BYTE4(v147) = 1;
            v135 = v159;
            v50 = (const void *)v160;
LABEL_81:
            v63 = v135 + 1;
            v49 = v156;
            if (v157 == v63)
              goto LABEL_82;
          }
          v149 = 0;
LABEL_72:
          v99 = (void *)value;
          goto LABEL_52;
        }
LABEL_82:
        if (++v49 == Count)
          goto LABEL_122;
      }
      sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("Invalid request keys, expected array: %@"), v58, v59, v60, v61, v62, (char)v57);
LABEL_118:
      v98 = CFSTR("GetProhibited");
      if (CFSTR("GetProhibited"))
      {
LABEL_119:
        sub_100004354(1, (uint64_t)"handle_get_multiple_values", v26, v98);
        v39 = 0;
        v141 = v151;
        v143 = v147;
        goto LABEL_120;
      }
LABEL_122:
      v143 = v147;
      if ((v147 & 0x100000000) != 0)
      {
LABEL_109:
        if ((_DWORD)a7)
        {
          CFDictionarySetValue(v33, CFSTR("Value"), v162);
          v144 = sub_10002BB14(v18, v33, &v165);
          v39 = (void *)objc_claimAutoreleasedReturnValue(v144);
          if (v39 && v165)
          {
            CFDictionarySetValue(v26, CFSTR("Payload"), v39);
            CFDictionarySetValue(v26, CFSTR("Nonce"), v165);
          }
          else
          {
            sub_100004354(0, (uint64_t)"handle_get_multiple_values", v26, CFSTR("InvalidResponse"));
          }
        }
        else
        {
          CFDictionarySetValue(v26, CFSTR("Value"), v162);
          v39 = 0;
        }
        v141 = v151;
LABEL_120:
        if ((v143 & 1) != 0)
          goto LABEL_92;
        goto LABEL_91;
      }
    }
    CFDictionaryRemoveValue(v162, CFSTR("FailureValueKey"));
    goto LABEL_109;
  }
  sub_10001A7E4(0, "handle_get_multiple_values", CFSTR("Failed to create response message."), v21, v22, v23, v24, v25, v145);
  v40 = 0;
  v39 = 0;
LABEL_102:
  if (v165)
    CFRelease(v165);
  v165 = 0;
  if (v40)
    free(v40);
LABEL_106:

}

uint64_t sub_10001C288(const __CFString *a1, const __CFString *a2, const void *a3, const void *a4, uint64_t a5, CFTypeRef *a6, uint64_t a7, uint64_t a8)
{
  char v8;
  const __CFString *v15;
  const void *v16;
  int v18;

  v8 = a7;
  if (a1 || (sub_10000F210(*(NSObject ***)a5, (uint64_t)a2, 0, 10, a5, (uint64_t)a6, a7, a8) & 1) != 0)
  {
    v15 = (const __CFString *)sub_100010BA8(a3);
    v16 = sub_100010B40(a4);
    return sub_100021DB8((NSObject ***)a5, a2, a1, v15, v16, a6, v8);
  }
  else
  {
    v18 = sub_1000047F4(*(_QWORD *)(a5 + 24));
    if (a6 && !a2 && v18 == 4)
      *a6 = CFRetain(CFSTR("Attempting to get NULL/NULL. Please fetch explicit values!!!"));
    return 1;
  }
}

const __CFDictionary *sub_10001C364(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t *a4, uint64_t a5, __CFString **a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef v14;
  const __CFDictionary *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFDictionary *MutableCopy;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFMutableDictionaryRef v26;
  CFMutableDictionaryRef v27;
  __CFString **v28;
  __CFString *v29;
  const __CFString *v31;
  char v32;
  _QWORD v33[9];

  v14 = sub_10000EB38((uint64_t)a4, *a4, a2, a1, a5, (uint64_t)a6, a7, a8);
  if (!v14)
  {
    MutableCopy = 0;
    v28 = off_10017B868;
    if (!a6)
      goto LABEL_11;
LABEL_9:
    v29 = *v28;
    if (v29)
      *a6 = v29;
    goto LABEL_11;
  }
  v15 = v14;
  if (a1
    || !sub_100010B40(v14)
    || (sub_10000F210((NSObject **)*a4, (uint64_t)a2, 0, 10, v16, v17, v18, v19) & 1) != 0)
  {
    return v15;
  }
  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, v15);
  CFRelease(v15);
  if (MutableCopy)
  {
    sub_1000210C4((NSObject ***)a4, a2, MutableCopy);
    v26 = sub_100025A4C();
    if (v26)
    {
      v27 = v26;
      v33[0] = _NSConcreteStackBlock;
      v33[1] = 3221225472;
      v33[2] = sub_100022220;
      v33[3] = &unk_10017AA78;
      v33[4] = a4;
      v33[5] = a2;
      v33[6] = a3;
      v33[7] = a5;
      v33[8] = v26;
      sub_1000258E8(MutableCopy, v33);
      v15 = (const __CFDictionary *)CFRetain(v27);
      CFRelease(MutableCopy);
      CFRelease(v27);
      return v15;
    }
    v31 = CFSTR("Failed to create dictionary.");
  }
  else
  {
    v31 = CFSTR("Failed to copy dictionary.");
  }
  sub_10001A7E4(0, "copy_value_for_domain_and_key", v31, v21, v22, v23, v24, v25, v32);
  v28 = off_10017B998;
  if (a6)
    goto LABEL_9;
LABEL_11:
  if (MutableCopy)
    CFRelease(MutableCopy);
  return 0;
}

void sub_10001C4FC(uint64_t a1, void *a2, const void *a3, const void *a4, uint64_t *a5, void *a6, uint64_t a7)
{
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  const __CFString *v19;
  __CFDictionary *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __CFDictionary *v26;
  const void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFString *v33;
  void *v34;
  const void *v35;
  char *v36;
  __CFString *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  __CFDictionary *v45;
  const __CFString *v46;
  id v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  CFMutableDictionaryRef v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  __CFDictionary *v59;
  const void *v60;
  const __CFString *v61;
  const void *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const __CFString *v68;
  __CFString **v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  char v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  id v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  __CFString *v102;
  char v103;
  __CFDictionary *theDict;
  CFTypeRef cf;
  __CFString *v106;
  void *value;

  v18 = a6;
  v106 = 0;
  value = 0;
  cf = 0;
  if (!a1)
  {
    sub_10001A7E4(0, "handle_get_value", CFSTR("Invalid connection."), v13, v14, v15, v16, v17, v103);
    v34 = 0;
    cf = 0;
    goto LABEL_28;
  }
  if ((_DWORD)a7)
    v19 = CFSTR("GetValueCU");
  else
    v19 = CFSTR("GetValue");
  v20 = sub_1000042FC(v19);
  if (v20)
  {
    v26 = v20;
    v27 = sub_100010B40(a2);
    if (!a5 || !v27)
    {
      v33 = CFSTR("Invalid input(s).");
      goto LABEL_14;
    }
    if (!v18 && (_DWORD)a7)
    {
      v33 = CFSTR("Invalid pairing session.");
LABEL_14:
      sub_10001A7E4(0, "handle_get_value", v33, v28, v29, v30, v31, v32, v103);
      v37 = CFSTR("GetProhibited");
      v38 = 1;
LABEL_15:
      sub_100004354(v38, (uint64_t)"handle_get_value", v26, v37);
      v45 = 0;
      v35 = 0;
      v34 = 0;
      v36 = 0;
      goto LABEL_16;
    }
    if ((_DWORD)a7)
    {
      v47 = sub_10002B834(v18, a2);
      if (v47)
      {
        a2 = v47;
        v53 = sub_100025A4C();
        if (v53)
        {
          v59 = v53;
          theDict = v53;
          goto LABEL_36;
        }
        sub_10001A7E4(0, "handle_get_value", CFSTR("Failed to create result."), v54, v55, v56, v57, v58, v103);
        v69 = off_10017B858;
      }
      else
      {
        sub_10001A7E4(0, "handle_get_value", CFSTR("Failed to decrypt message."), v48, v49, v50, v51, v52, v103);
        v69 = off_10017B998;
      }
      v37 = *v69;
      v38 = 0;
      goto LABEL_15;
    }
    theDict = 0;
    v59 = v26;
LABEL_36:
    v60 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Domain"));
    v61 = (const __CFString *)sub_100010BA8(v60);
    v62 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Key"));
    v68 = (const __CFString *)sub_100010BA8(v62);
    if (v61)
      CFDictionarySetValue(v59, CFSTR("Domain"), v61);
    if (v68)
      CFDictionarySetValue(v59, CFSTR("Key"), v68);
    if (dword_1001A6AD0)
    {
      if (v61)
        sub_10001A7E4(0, "handle_get_value", CFSTR("%@ attempting to get [%@]:[%@]"), v63, v64, v65, v66, v67, (char)a3);
      else
        sub_10001A7E4(0, "handle_get_value", CFSTR("%@ attempting to get [%@]"), v63, v64, v65, v66, v67, (char)a3);
    }
    if ((sub_10001C288(v68, v61, a3, a4, a1, (CFTypeRef *)&value, a7, v67) & 1) != 0)
    {
      if (v61
        && v68
        && CFEqual(v61, CFSTR("com.apple.mobile.wireless_lockdown"))
        && CFEqual(v68, CFSTR("reset_adverts")))
      {
        v35 = CFRetain(kCFBooleanTrue);
        sub_100006DB8(a5, 1, 1, 0, v72, v73, v74, v75, v103);
        if (sub_10000F404(*a5, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiDebugging"), v76, v77, v78, v79, v80)|| sub_10000F404(*a5, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiConnections"), v81, v82, v83, v84, v85))
        {
          v36 = sub_100026BC8();
          v91 = v36 != 0;
        }
        else
        {
          v91 = 0;
          v36 = 0;
        }
        v92 = sub_10000F404(*a5, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiPairing"), v86, v87, v88, v89, v90);
        if (((v91 & 1) != 0 || v92) && !sub_100005EF8(a5, (uint64_t)v36, v91, v92 != 0, 1, v93, v94, v95))
          v35 = CFRetain(kCFBooleanFalse);
      }
      else
      {
        v35 = sub_10001C364(v68, v61, (uint64_t)a3, (uint64_t *)a1, (uint64_t)a4, &v106, v70, v71);
        v36 = 0;
      }
      v45 = theDict;
      if (v35)
      {
        if ((_DWORD)a7)
        {
          CFDictionarySetValue(theDict, CFSTR("Value"), v35);
          v96 = sub_10002BB14(v18, theDict, &cf);
          v34 = (void *)objc_claimAutoreleasedReturnValue(v96);
          if (v34 && cf)
          {
            CFDictionarySetValue(v26, CFSTR("Payload"), v34);
            CFDictionarySetValue(v26, CFSTR("Nonce"), cf);
          }
          else
          {
            sub_10001A7E4(0, "handle_get_value", CFSTR("Failed to encrypt message."), v97, v98, v99, v100, v101, v103);
            sub_100004354(0, (uint64_t)"handle_get_value", v26, CFSTR("InvalidResponse"));
          }
          goto LABEL_16;
        }
        CFDictionarySetValue(v26, CFSTR("Value"), v35);
      }
      else
      {
        if (v106)
          v102 = v106;
        else
          v102 = CFSTR("InternalError");
        sub_100004354(1, (uint64_t)"handle_get_value", v26, v102);
      }
      v34 = 0;
    }
    else
    {
      sub_100004354(1, (uint64_t)"handle_get_value", v26, CFSTR("GetProhibited"));
      v35 = 0;
      v34 = 0;
      v36 = 0;
      v45 = theDict;
    }
LABEL_16:
    if (value)
    {
      v46 = CFSTR("unknown");
      if (a3)
        LOBYTE(v46) = (_BYTE)a3;
      sub_10001A7E4(0, "handle_get_value", CFSTR("Warning (%@): %@"), v40, v41, v42, v43, v44, (char)v46);
      CFDictionarySetValue(v26, CFSTR("Warning"), value);
    }
    sub_1000041C0(*(const __CFData **)(a1 + 24), v26, v39, v40, v41, v42, v43, v44, v103);
    if (v45)
      CFRelease(v45);
    goto LABEL_22;
  }
  sub_10001A7E4(0, "handle_get_value", CFSTR("Failed to create response message."), v21, v22, v23, v24, v25, v103);
  v35 = 0;
  v34 = 0;
  v36 = 0;
LABEL_22:
  if (cf)
    CFRelease(cf);
  cf = 0;
  if (v36)
    free(v36);
  if (v35)
    CFRelease(v35);
LABEL_28:
  if (value)
    CFRelease(value);
  value = 0;

}

void sub_10001CAA0(uint64_t a1, const void *a2, const __CFString *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFDictionary *v13;
  __CFDictionary *v14;
  const void *Value;
  const __CFString *v16;
  __CFString *v17;
  CFTypeID v18;
  CFTypeID v19;
  const void *v20;
  const __CFString *v21;
  const void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  const __CFString *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  __CFString **v37;
  const __CFString *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const void *v56;
  const __CFDictionary *v57;
  CFStringRef v58;
  int v59;
  _BOOL4 v60;
  _BOOL4 v61;
  const __CFString *v62;
  const __CFString *v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  __CFString **v71;
  const __CFString *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const void *v79;
  const void *v80;
  const void *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  void *v87;
  const void *v88;
  const __CFString *v89;
  const void *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  CFIndex Length;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  char v112;
  uint64_t v113;
  uint64_t v114;
  const __CFString *v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  const __CFString *v121;
  const void *v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  const void *v133;
  const __CFString *v134;
  const void *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  const __CFString *v146;
  const __CFString *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  char v152;
  char v153;
  CFTypeID v154;
  const void *v155;
  CFTypeRef cf;
  CFRange v157;
  CFRange v158;
  CFRange v159;

  if (!a1)
  {
    v38 = CFSTR("Invalid connection.");
LABEL_16:
    sub_10001A7E4(0, "handle_set_value", v38, (uint64_t)a4, a5, a6, a7, a8, a9);
    return;
  }
  v13 = sub_1000042FC(CFSTR("SetValue"));
  if (!v13)
  {
    v38 = CFSTR("Failed to create response message.");
    goto LABEL_16;
  }
  v14 = v13;
  if (!sub_100010B40(a2))
  {
    sub_100004354(1, (uint64_t)"handle_set_value", v14, CFSTR("SetProhibited"));
    CFDictionarySetValue(v14, CFSTR("Warning"), CFSTR("Invalid message."));
LABEL_20:
    sub_1000041C0(*(const __CFData **)(a1 + 24), v14, v39, v40, v41, v42, v43, v44, a9);
    return;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Key"));
  v16 = (const __CFString *)sub_100010BA8(Value);
  v17 = (__CFString *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Value"));
  v18 = CFGetTypeID(v17);
  if (!v16 || !v17)
  {
    v37 = off_10017B860;
    goto LABEL_19;
  }
  v19 = v18;
  v20 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Domain"));
  v21 = (const __CFString *)sub_100010BA8(v20);
  if (dword_1001A6AD0)
  {
    v22 = sub_100010BA8(a3);
    v28 = CFSTR("unknown");
    if (v22)
      LOBYTE(v28) = (_BYTE)a3;
    v154 = v19;
    sub_10001A7E4(0, "handle_set_value", CFSTR("%@ attempting to set [%@]:[%@] to [%@] of type %ld"), v23, v24, v25, v26, v27, (char)v28);
  }
  CFDictionarySetValue(v14, CFSTR("Key"), v16);
  CFDictionarySetValue(v14, CFSTR("Value"), v17);
  if (v21)
    CFDictionarySetValue(v14, CFSTR("Domain"), v21);
  if (sub_10000F210(*(NSObject ***)a1, (uint64_t)v21, (uint64_t)v16, 1, v29, v30, v31, v32))
  {
    v37 = off_10017B878;
LABEL_19:
    sub_100004354(1, (uint64_t)"handle_set_value", v14, *v37);
    goto LABEL_20;
  }
  if (sub_10000F210(*(NSObject ***)a1, (uint64_t)v21, (uint64_t)v16, 9, v33, v34, v35, v36)
    && sub_100027234(*(_QWORD *)a1, v45, v46, v47, v48, v49, v50, v51)
    && MKBGetDeviceLockState(0) == 3)
  {
    v37 = off_10017B988;
    goto LABEL_19;
  }
  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 4)
  {
    v56 = sub_100010BA8(a3);
    v57 = (const __CFDictionary *)sub_100010B40(a4);
    if ((sub_1000265EC(a1, v56, v57, (uint64_t)v21, (uint64_t)v16, 7) & 1) != 0)
    {
      v58 = 0;
      v59 = 1;
    }
    else
    {
      v60 = sub_10001D380((uint64_t *)a1);
      v61 = v60;
      v62 = CFSTR("NULL");
      if (a3)
        v63 = a3;
      else
        v63 = CFSTR("NULL");
      if (v21)
        v62 = v21;
      v64 = " (non-fatal for now)";
      if (v60)
        v64 = "";
      v58 = CFStringCreateWithFormat(0, 0, CFSTR("client %@'s entitlement plist must have a com.apple.private.lockdown.finegrained-set key whose value is an array containing the string %@/%@%s"), v63, v62, v16, v64, v154);
      v59 = !v61;
    }
  }
  else
  {
    v59 = 0;
    v58 = 0;
  }
  if ((sub_10000F210(*(NSObject ***)a1, (uint64_t)v21, (uint64_t)v16, 2, v52, v53, v54, v55) & 1) != 0)
    v69 = 1;
  else
    v69 = sub_10000F210(*(NSObject ***)a1, (uint64_t)v21, (uint64_t)v16, 3, v65, v66, v67, v68);
  if (*(_QWORD *)(a1 + 48))
    v70 = v69 ^ 1;
  else
    v70 = 0;
  if ((sub_10000F210(*(NSObject ***)a1, (uint64_t)v21, (uint64_t)v16, 8, v65, v66, v67, v68) & 1) == 0 && !(v59 | v70))
    goto LABEL_45;
  if (!v21)
  {
    if (CFEqual(v16, CFSTR("DeviceName")))
    {
      if (!a4
        || sub_1000047F4(*(_QWORD *)(a1 + 24)) != 4
        || (v81 = CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("com.apple.private.lockdown.ignore-mc-name-restriction")), !sub_100010C10(v81))|| !CFEqual(v81, kCFBooleanTrue))
      {
        if ((sub_100026E2C() & 1) == 0)
        {
          v89 = CFSTR("MC is preventing name change.");
          LODWORD(v87) = 0;
          goto LABEL_88;
        }
      }
      v87 = (void *)sub_100010BA8(v17);
      if (!v87)
      {
        v89 = CFSTR("Invalid value type.");
        goto LABEL_88;
      }
      v87 = (void *)sub_100008188(v17);
      v88 = v87;
      if (!v87)
      {
        v89 = CFSTR("Failed to sanitize device name.");
        goto LABEL_88;
      }
    }
    else
    {
      v88 = 0;
    }
    if (CFEqual(v16, CFSTR("UntrustedHostBUID")))
    {
      if (!sub_100010BA8(v17))
      {
        sub_10001A7E4(0, "verify_set", CFSTR("Invalid value type."), v101, v102, v103, v104, v105, v152);
        goto LABEL_90;
      }
      Length = CFStringGetLength(v17);
      if (Length >= 51)
      {
        sub_10001A7E4(0, "verify_set", CFSTR("Invalid string length: %lld"), v107, v108, v109, v110, v111, Length);
LABEL_90:
        v112 = 0;
        goto LABEL_91;
      }
    }
    v112 = 1;
LABEL_91:
    if (!v88)
      goto LABEL_120;
    v133 = v88;
    goto LABEL_119;
  }
  if (CFEqual(v21, CFSTR("com.apple.mobile.internal"))
    && (sub_10002935C() & 1) == 0
    && CFEqual(v16, CFSTR("VoidWarranty")))
  {
    goto LABEL_45;
  }
  if (CFEqual(v21, CFSTR("com.apple.mobile.iTunes")))
  {
    v79 = sub_100010BA8(v16);
    v80 = (const void *)MCCopyCheckpointValue(v79);
    if (v80)
    {
      CFRelease(v80);
LABEL_45:
      v71 = off_10017B878;
      goto LABEL_46;
    }
  }
  if (CFEqual(v21, CFSTR("com.apple.international")))
  {
    sub_100012E48(*(NSObject ***)a1);
    if (!CFEqual(v16, CFSTR("Language")))
    {
      v90 = 0;
      goto LABEL_80;
    }
    v87 = (void *)sub_100010BA8(v17);
    if (v87)
    {
      v90 = (const void *)sub_10000ED98(*(_QWORD *)a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("SupportedLanguages"));
      if (!sub_100010B74(v90))
      {
        v146 = CFSTR("Failed to lookup supported languages.");
        goto LABEL_101;
      }
      v157.length = CFArrayGetCount((CFArrayRef)v90);
      v157.location = 0;
      if (!CFArrayContainsValue((CFArrayRef)v90, v157, v17))
      {
        sub_10001A7E4(0, "verify_set", CFSTR("Unsupported language: %@"), v96, v97, v98, v99, v100, (char)v17);
LABEL_102:
        v112 = 0;
        v135 = 0;
        cf = 0;
LABEL_113:
        if (v90)
          CFRelease(v90);
        if (cf)
          CFRelease(cf);
        if (!v135)
        {
LABEL_120:
          if ((v112 & 1) == 0)
            goto LABEL_45;
          goto LABEL_121;
        }
        v133 = v135;
LABEL_119:
        CFRelease(v133);
        goto LABEL_120;
      }
LABEL_80:
      if (!CFEqual(v16, CFSTR("Locale")))
      {
        v155 = v90;
        cf = 0;
        v121 = v17;
        goto LABEL_94;
      }
      if (sub_100010BA8(v17))
      {
        v155 = v90;
        v115 = sub_1000092B8(v17, v113, v114, v91, v92, v93, v94, v95);
        if (!v115)
        {
          sub_10001A7E4(0, "verify_set", CFSTR("Failed to transform locale."), v116, v117, v118, v119, v120, v152);
          v112 = 0;
          v135 = 0;
          cf = 0;
          goto LABEL_112;
        }
        v121 = v115;
        v122 = (const void *)sub_10000ED98(*(_QWORD *)a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("SupportedLocales"));
        cf = v122;
        if (!sub_100010B74(v122))
        {
          v147 = CFSTR("Failed to lookup supported languages.");
          goto LABEL_108;
        }
        v158.length = CFArrayGetCount((CFArrayRef)v122);
        v158.location = 0;
        if (!CFArrayContainsValue((CFArrayRef)v122, v158, v121))
        {
          sub_10001A7E4(0, "verify_set", CFSTR("Unsupported locale: %@"), v128, v129, v130, v131, v132, (char)v121);
LABEL_109:
          v112 = 0;
          v135 = 0;
          goto LABEL_112;
        }
LABEL_94:
        if (!CFEqual(v16, CFSTR("Keyboard")))
        {
          v135 = 0;
LABEL_104:
          v112 = 1;
LABEL_112:
          v90 = v155;
          goto LABEL_113;
        }
        if (sub_100010BA8(v121))
        {
          v134 = sub_100009420(v121);
          v135 = (const void *)sub_10000ED98(*(_QWORD *)a1, (uint64_t)CFSTR("com.apple.international"), (uint64_t)CFSTR("SupportedKeyboards"));
          if (!sub_100010B74(v135))
          {
            sub_10001A7E4(0, "verify_set", CFSTR("Failed to lookup supported keyboards."), v136, v137, v138, v139, v140, v152);
            goto LABEL_111;
          }
          v159.length = CFArrayGetCount((CFArrayRef)v135);
          v159.location = 0;
          if (!CFArrayContainsValue((CFArrayRef)v135, v159, v134))
          {
            sub_10001A7E4(0, "verify_set", CFSTR("Unsupported keyboard: %@"), v141, v142, v143, v144, v145, (char)v134);
LABEL_111:
            v112 = 0;
            goto LABEL_112;
          }
          goto LABEL_104;
        }
        v147 = CFSTR("Invalid keyboard type..");
LABEL_108:
        sub_10001A7E4(0, "verify_set", v147, v123, v124, v125, v126, v127, v152);
        goto LABEL_109;
      }
      v146 = CFSTR("Invalid locale type.");
LABEL_101:
      sub_10001A7E4(0, "verify_set", v146, v91, v92, v93, v94, v95, v152);
      goto LABEL_102;
    }
    v89 = CFSTR("Invalid language type.");
LABEL_88:
    sub_10001A7E4((int)v87, "verify_set", v89, v82, v83, v84, v85, v86, v152);
    goto LABEL_45;
  }
LABEL_121:
  if (!sub_10001D44C(a1, v21, v16, v17))
  {
    sub_10000E484(*(_QWORD *)a1, (uint64_t)v21, (uint64_t)v16, (uint64_t)v17, v148, v149, v150, v151);
    if (!v58)
      goto LABEL_20;
    goto LABEL_47;
  }
  v71 = off_10017B998;
LABEL_46:
  sub_100004354(1, (uint64_t)"handle_set_value", v14, *v71);
  if (!v58)
    goto LABEL_20;
LABEL_47:
  v72 = CFSTR("unknown");
  if (a3)
    LOBYTE(v72) = (_BYTE)a3;
  sub_10001A7E4(0, "handle_set_value", CFSTR("Warning (%@): %@"), v40, v41, v42, v43, v44, (char)v72);
  CFDictionarySetValue(v14, CFSTR("Warning"), v58);
  sub_1000041C0(*(const __CFData **)(a1 + 24), v14, v73, v74, v75, v76, v77, v78, v153);
  CFRelease(v58);
}

BOOL sub_10001D380(uint64_t *a1)
{
  const void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL8 v13;
  const __CFString *v14;
  char v16;
  char v17;

  v1 = (const void *)sub_10000ED98(*a1, 0, (uint64_t)CFSTR("SecureCopyValue"));
  if (!sub_100010BA8(v1))
    goto LABEL_9;
  sub_10001A7E4(0, "enforce_fine_grained_entitlements", CFSTR("we got a value for SCV"), v2, v3, v4, v5, v6, v16);
  v7 = CFEqual(v1, CFSTR("SCVEnabled"));
  v13 = v7 != 0;
  if (v7)
  {
    v14 = CFSTR("and it was true! So entitlements are now being tested");
    goto LABEL_6;
  }
  if (!CFEqual(v1, CFSTR("SCVDisabled")))
  {
LABEL_9:
    v13 = 0;
    if (!v1)
      return v13;
    goto LABEL_7;
  }
  v14 = CFSTR("and it was false! So entitlements are now NOT being tested");
LABEL_6:
  sub_10001A7E4(0, "enforce_fine_grained_entitlements", v14, v8, v9, v10, v11, v12, v17);
  if (v1)
LABEL_7:
    CFRelease(v1);
  return v13;
}

uint64_t sub_10001D44C(uint64_t a1, const __CFString *cf1, const __CFString *a3, __CFString *a4)
{
  NSObject **v6;
  const void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const __CFString *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const __CFString *v47;
  const __CFString *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const void *v55;
  const void *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const void *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  const void *v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const void *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  const void *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  const void *v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  const void *v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  const void *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  const void *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  const void *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  const __CFBoolean *v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  const void *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  const __CFString *v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  const void *v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  const __CFString *v222;
  const void *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  const __CFString *v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  const void *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  const __CFString *v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  const void *v247;
  uint64_t v248;
  uint64_t v249;
  uint64_t v250;
  uint64_t v251;
  uint64_t v252;
  const __CFBoolean *v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  uint64_t v267;
  const __CFNumber *v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  const __CFString *v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  const void *v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  uint64_t v289;
  const void *v290;
  uint64_t v291;
  uint64_t v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  const void *v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  uint64_t v304;
  uint64_t v305;
  uint64_t v306;
  uint64_t v307;
  uint64_t v308;
  uint64_t v309;
  uint64_t v310;
  uint64_t v311;
  uint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  char v320;
  char v321;
  char v322;

  v6 = *(NSObject ***)a1;
  if (cf1)
  {
    if (CFEqual(cf1, CFSTR("com.apple.international")))
    {
      if (CFEqual(a3, CFSTR("Language")))
      {
        v9 = sub_100010BA8(a4);
        sub_100008E08((uint64_t)v6, v9, v10, v11, v12, v13, v14, v15, v320);
        v16 = sub_100010BA8(a4);
        sub_100009154(v16, v17, v18, v19, v20, v21, v22, v23, v321);
        v24 = sub_100010BA8(a4);
        sub_100009098(v24, v25, v26, v27, v28, v29, v30, v31, v322);
      }
      if (CFEqual(a3, CFSTR("Locale")))
      {
        v32 = (const __CFString *)sub_100010BA8(a4);
        v40 = sub_1000092B8(v32, v33, v34, v35, v36, v37, v38, v39);
        sub_100009310((uint64_t)v6, v40, v41, v42, v43, v44, v45, v46, v320);
      }
      if (CFEqual(a3, CFSTR("Keyboard")))
      {
        v47 = (const __CFString *)sub_100010BA8(a4);
        v48 = sub_100009420(v47);
        sub_100009468((uint64_t)v6, v48, v49, v50, v51, v52, v53, v54, v320);
      }
    }
    if (CFEqual(cf1, CFSTR("com.apple.fairplay")))
    {
      if (CFEqual(a3, CFSTR("RentalBagResponse")))
        sub_100009CFC(v6);
      if (CFEqual(a3, CFSTR("RentalCheckinAckRequest")))
      {
        v55 = sub_100010BDC(a4);
        sub_100009EE4(v6, v55);
      }
    }
    if (CFEqual(cf1, CFSTR("com.apple.mobile.debug")))
    {
      if (CFEqual(a3, CFSTR("EnableVPNLogs")))
      {
        v56 = sub_100010C10(a4);
        sub_10000ADDC(v56, v57, v58, v59, v60, v61, v62, v63, v320);
      }
      v64 = CFEqual(a3, CFSTR("RemoveVPNLogs"));
      if ((_DWORD)v64)
        sub_10000AFBC(v64, v65, v66, v67, v68, v69, v70, v71);
      if (CFEqual(a3, CFSTR("EnableCLTMLogs")))
      {
        v72 = sub_100010C10(a4);
        sub_10000B360(v72, v73, v74, v75, v76, v77, v78, v79, v320);
      }
      v80 = CFEqual(a3, CFSTR("RemoveCLTMLogs"));
      if ((_DWORD)v80)
        sub_10000B46C(v80, v81, v82, v83, v84, v85, v86, v87);
      if (CFEqual(a3, CFSTR("EnableCLTMTGraphLogs")))
      {
        v88 = sub_100010C10(a4);
        sub_10000B500(v88, v89, v90, v91, v92, v93, v94, v95, v320);
      }
      v96 = CFEqual(a3, CFSTR("RemoveCLTMTGraphLogs"));
      if ((_DWORD)v96)
        sub_10000B60C(v96, v97, v98, v99, v100, v101, v102, v103);
      if (CFEqual(a3, CFSTR("EnableCLTMThermstatLogs")))
      {
        v104 = sub_100010C10(a4);
        sub_10000B6A0(v104, v105, v106, v107, v108, v109, v110, v111, v320);
      }
      v112 = CFEqual(a3, CFSTR("RemoveCLTMThermstatLogs"));
      if ((_DWORD)v112)
        sub_10000B794(v112, v113, v114, v115, v116, v117, v118, v119);
      if (CFEqual(a3, CFSTR("EnableMediaStreamLogs")))
      {
        v120 = sub_100010C10(a4);
        sub_10000C5F8(v120, v121, v122, v123, v124, v125, v126, v127, v320);
      }
      if (CFEqual(a3, CFSTR("EnableWiFiManagerLogs")))
      {
        v128 = sub_100010C10(a4);
        sub_10000B828(v128, v129, v130, v131, v132, v133, v134, v135, v320);
      }
      v136 = CFEqual(a3, CFSTR("RemoveWiFiManagerLogs"));
      if ((_DWORD)v136)
        sub_10000B8D0(v136, v137, v138, v139, v140, v141, v142, v143);
      if (CFEqual(a3, CFSTR("Enable8021XLogs")))
      {
        v144 = sub_100010C10(a4);
        sub_10000B0DC(v144, v145, v146, v147, v148, v149, v150, v151, v320);
      }
      v152 = CFEqual(a3, CFSTR("Remove8021XLogs"));
      if ((_DWORD)v152)
        sub_10000B250(v152, v153, v154, v155, v156, v157, v158, v159);
      if (CFEqual(a3, CFSTR("EnableLockdownLogToDisk")))
      {
        v160 = sub_100010C10(a4);
        sub_10000B964(v160, v161, v162, v163, v164, v165, v166, v167, v320);
      }
      if (CFEqual(a3, CFSTR("EnableLockdownExtendedLogging")))
      {
        v168 = sub_100010C10(a4);
        sub_10000BACC(v168, v169, v170, v171, v172, v173, v174, v175, v320);
      }
      v176 = CFEqual(a3, CFSTR("RemoveLockdownLog"));
      if ((_DWORD)v176)
        sub_10000C7EC(v176, v177, v178, v179, v180, v181, v182, v183);
      if (CFEqual(a3, CFSTR("EnableRaptorCerts")))
      {
        v184 = sub_100010C10(a4);
        sub_10000BBF4(v184, (uint64_t)v6, v185, v186, v187, v188, v189, v190, v320);
      }
    }
    if (CFEqual(cf1, CFSTR("com.apple.mobile.demo")) && CFEqual(a3, CFSTR("EnableTetheredDisplayPortMode")))
    {
      v191 = (const __CFBoolean *)sub_100010C10(a4);
      sub_100008D24(v191);
    }
    if (CFEqual(cf1, CFSTR("com.apple.MobileSystemServices")))
    {
      sub_10002CCD8(a3, a4);
      sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)a3, v192, v193, v194, v195, v196);
    }
    if (CFEqual(cf1, CFSTR("com.apple.purplebuddy"))
      && sub_1000047F4(*(_QWORD *)(a1 + 24)) == 4
      && CFEqual(a3, CFSTR("SetupState")))
    {
      sub_100023258(v6, v197, v198, v199, v200, v201, v202, v203);
    }
    if (CFEqual(cf1, CFSTR("com.apple.Accessibility")))
    {
      _AXSAccessibilitySetiTunesPreference(a3, a4);
      v204 = sub_100010BA8(a3);
      sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)v204, v205, v206, v207, v208, v209);
    }
    if (CFEqual(cf1, CFSTR("com.apple.AssetCacheTetherator")))
    {
      v210 = (const __CFString *)sub_100010BA8(a3);
      sub_10001AD28(v210, a4, CFSTR("com.apple.AssetCacheTetherator"), v211, v212, v213, v214, v215);
      v216 = sub_100010BA8(a3);
      sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)v216, v217, v218, v219, v220, v221);
    }
    if (CFEqual(cf1, CFSTR("com.apple.MobileDeviceCrashCopy")))
    {
      v222 = (const __CFString *)sub_100010BA8(a3);
      sub_100004670(v222, a4);
      v223 = sub_100010BA8(a3);
      sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)v223, v224, v225, v226, v227, v228);
    }
    if (CFEqual(cf1, CFSTR("com.apple.purplebuddy")))
    {
      v229 = (const __CFString *)sub_100010BA8(a3);
      sub_10001AD28(v229, a4, CFSTR("com.apple.purplebuddy"), v230, v231, v232, v233, v234);
      v235 = sub_100010BA8(a3);
      sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)v235, v236, v237, v238, v239, v240);
    }
    if (CFEqual(cf1, CFSTR("com.apple.mobileipod")))
    {
      v241 = (const __CFString *)sub_100010BA8(a3);
      sub_10001AD28(v241, a4, CFSTR("com.apple.mobileipod.mobile-preferences-proxy"), v242, v243, v244, v245, v246);
      v247 = sub_100010BA8(a3);
      sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)v247, v248, v249, v250, v251, v252);
    }
    if (CFEqual(cf1, CFSTR("com.apple.mobile.user_preferences")))
    {
      if (CFEqual(a3, CFSTR("FileSharingEnabled")))
      {
        v253 = (const __CFBoolean *)sub_100010C10(a4);
        sub_10000D220(v253, v254, v255, v256, v257, v258, v259, v260, v320);
      }
      else if (CFEqual(CFSTR("DiagnosticsAllowed"), a3))
      {
        v296 = sub_100010C10(a4);
        sub_100007290(v296, v297, v298, v299, v300, v301, v302, v303, v320);
        sub_1000110EC(CFSTR("com.apple.iqagent.IQAllowedChangeNotification"));
      }
      else
      {
        if (!sub_100013CFC(cf1, a3, a4, v291, v292, v293, v294, v295))
          return 0xFFFFFFFFLL;
        sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)a3, v304, v305, v306, v307, v308);
      }
    }
    if (CFEqual(cf1, CFSTR("com.apple.mobile.backup")))
    {
      sub_10001AD28(a3, a4, CFSTR("com.apple.mobile.ldbackup"), v309, v310, v311, v312, v313);
      sub_10000EFB4((uint64_t)v6, (uint64_t)cf1, (uint64_t)a3, v314, v315, v316, v317, v318);
      sub_1000110EC(CFSTR("com.apple.mobile.backup.domain_changed"));
    }
    if (!CFEqual(cf1, CFSTR("com.apple.securityd.ae"))
      || !CFEqual(a3, CFSTR("AEToken"))
      || !sub_100010BA8(a4)
      || sub_10002362C(a4))
    {
      return 0;
    }
  }
  else
  {
    if (CFEqual(a3, CFSTR("DeviceName")))
      sub_1000084E0(a4, v261, v262, v263, v264, v265, v266, v267);
    if (!CFEqual(a3, CFSTR("TimeIntervalSince1970"))
      || (v268 = (const __CFNumber *)sub_100010B0C(a4),
          !sub_100008A24((int)v6, v268, v269, v270, v271, v272, v273, v274)))
    {
      if (!CFEqual(a3, CFSTR("TimeZone"))
        || (v275 = (const __CFString *)sub_100010BA8(a4),
            !sub_100008B30((int)v6, v275, v276, v277, v278, v279, v280, v281)))
      {
        if (!CFEqual(a3, CFSTR("Uses24HourClock"))
          || (v282 = sub_100010C10(a4), !sub_100008C68(v282, v283, v284, v285, v286, v287, v288, v289)))
        {
          if (CFEqual(a3, CFSTR("UntrustedHostBUID")))
          {
            v290 = sub_100010BA8(a4);
            sub_100017184((uint64_t)v290);
          }
          return 0;
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

void sub_10001DC0C(uint64_t a1, const void *a2, const __CFString *a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFDictionary *v13;
  const void *Value;
  const void *v15;
  const void *v16;
  const void *v17;
  const __CFString *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  CFStringRef v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  const void *v46;
  const __CFDictionary *v47;
  _BOOL4 v48;
  const __CFString *v49;
  const __CFString *v50;
  const char *v51;
  int v52;
  const __CFString *v53;

  v13 = sub_1000042FC(CFSTR("RemoveValue"));
  if (!sub_100010B40(a2))
  {
    sub_100004354(1, (uint64_t)"handle_remove_value", v13, CFSTR("RemoveProhibited"));
    CFDictionarySetValue(v13, CFSTR("Warning"), CFSTR("hinky message passed in"));
    goto LABEL_41;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Key"));
  v15 = sub_100010BA8(Value);
  if (!v15)
  {
    sub_100004354(1, (uint64_t)"handle_remove_value", v13, CFSTR("MissingValue"));
    goto LABEL_41;
  }
  v16 = v15;
  v17 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Domain"));
  v18 = (const __CFString *)sub_100010BA8(v17);
  if (dword_1001A6AD0)
  {
    if (sub_100010BA8(a3))
      LOBYTE(v24) = (_BYTE)a3;
    else
      v24 = CFSTR("unknown");
    sub_10001A7E4(0, "handle_remove_value", CFSTR("%@ attempting to remove [%@]:[%@]"), v19, v20, v21, v22, v23, (char)v24);
  }
  CFDictionarySetValue(v13, CFSTR("Key"), v16);
  if (v18)
    CFDictionarySetValue(v13, CFSTR("Domain"), v18);
  if ((sub_10000F210(*(NSObject ***)a1, (uint64_t)v18, (uint64_t)v16, 2, v25, v26, v27, v28) & 1) != 0)
    v33 = 1;
  else
    v33 = sub_10000F210(*(NSObject ***)a1, (uint64_t)v18, (uint64_t)v16, 3, v29, v30, v31, v32);
  if ((sub_10000F210(*(NSObject ***)a1, (uint64_t)v18, (uint64_t)v16, 1, v29, v30, v31, v32) & 1) == 0)
  {
    if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 4)
    {
      v46 = sub_100010BA8(a3);
      v47 = (const __CFDictionary *)sub_100010B40(a4);
      if ((sub_1000265EC(a1, v46, v47, (uint64_t)v18, (uint64_t)v16, 8) & 1) != 0)
      {
        v40 = 0;
        goto LABEL_34;
      }
      v48 = sub_10001D380((uint64_t *)a1);
      if (sub_100010BA8(a3))
        v49 = a3;
      else
        v49 = CFSTR("unknown");
      v50 = CFSTR("NULL");
      if (v18)
        v50 = v18;
      v51 = " (non-fatal for now)";
      if (v48)
        v51 = "";
      v40 = CFStringCreateWithFormat(0, 0, CFSTR("client %@'s entitlement plist must have a com.apple.private.lockdown.finegrained-remove key whose value is an array containing the string %@/%@%s"), v49, v50, v16, v51);
    }
    else
    {
      v40 = 0;
      LOBYTE(v48) = 1;
    }
    if (*(_QWORD *)(a1 + 48))
      v52 = v33;
    else
      v52 = 1;
    if (v52 == 1 && v48)
      goto LABEL_35;
LABEL_34:
    if (!sub_10000EFB4(*(_QWORD *)a1, (uint64_t)v18, (uint64_t)v16, v41, v42, v43, v44, v45))
      goto LABEL_36;
    goto LABEL_35;
  }
  sub_100004354(1, (uint64_t)"handle_remove_value", v13, CFSTR("ImmutableValue"));
  v40 = 0;
LABEL_35:
  sub_100004354(1, (uint64_t)"handle_remove_value", v13, CFSTR("RemoveProhibited"));
LABEL_36:
  if (v40)
  {
    if (a3)
      LOBYTE(v53) = (_BYTE)a3;
    else
      v53 = CFSTR("unknown");
    sub_10001A7E4(0, "handle_remove_value", CFSTR("Warning (%@): %@"), v35, v36, v37, v38, v39, (char)v53);
    CFDictionarySetValue(v13, CFSTR("Warning"), v40);
    CFRelease(v40);
  }
LABEL_41:
  sub_1000041C0(*(const __CFData **)(a1 + 24), v13, v34, v35, v36, v37, v38, v39, a9);
}

void sub_10001DF5C(uint64_t a1, const void *a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v11;
  __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFString *v18;
  __CFString **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFDictionary *v26;
  const void *Value;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFString *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFBoolean *v44;
  char v45;
  char v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const void *v52;
  char v53;

  if (dword_1001A6AD0)
  {
    v11 = CFSTR("unknown");
    if (a4)
      LOBYTE(v11) = a4;
    sub_10001A7E4(0, "handle_unpair", CFSTR("Preparing to unpair for %@."), a4, a5, a6, a7, a8, (char)v11);
  }
  v12 = sub_1000042FC(CFSTR("Unpair"));
  if (!sub_100010B40(a2))
  {
    sub_10001A7E4(0, "handle_unpair", CFSTR("Invalid message."), v13, v14, v15, v16, v17, v53);
    v19 = off_10017B868;
LABEL_16:
    v18 = *v19;
    goto LABEL_17;
  }
  if (!a1)
  {
    sub_10001A7E4(0, "handle_unpair", CFSTR("Invalid input."), v13, v14, v15, v16, v17, v53);
    sub_100004354(1, (uint64_t)"handle_unpair", v12, CFSTR("MissingValue"));
    v26 = 0;
    goto LABEL_22;
  }
  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) != 1
    && sub_1000047F4(*(_QWORD *)(a1 + 24)) != 3
    && sub_1000047F4(*(_QWORD *)(a1 + 24)) != 2
    && sub_1000047F4(*(_QWORD *)(a1 + 24)) != 4)
  {
    v46 = sub_1000047F4(*(_QWORD *)(a1 + 24));
    sub_10001A7E4(0, "handle_unpair", CFSTR("Invalid connection type for unpairing: %d"), v47, v48, v49, v50, v51, v46);
    v19 = off_10017B990;
    goto LABEL_16;
  }
  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 4
    && (!sub_100010B40(a3)
     || CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("com.apple.private.lockdown.unpair")) != kCFBooleanTrue))
  {
    v18 = CFSTR("RemoveProhibited");
LABEL_17:
    sub_100004354(1, (uint64_t)"handle_unpair", v12, v18);
    v26 = 0;
    goto LABEL_18;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("PairRecord"));
  if (!sub_100010B40(Value))
  {
    sub_10001A7E4(0, "handle_unpair", CFSTR("Request missing pair record."), v28, v29, v30, v31, v32, v53);
    v19 = off_10017B938;
    goto LABEL_16;
  }
  v33 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)Value, CFSTR("HostID"));
  if (!sub_100010BA8(v33))
  {
    sub_10001A7E4(0, "handle_unpair", CFSTR("Request missing host id."), v34, v35, v36, v37, v38, v53);
    v19 = off_10017B8D8;
    goto LABEL_16;
  }
  v26 = (const __CFDictionary *)sub_100015B64(v33);
  if (v26)
  {
    v44 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ResetTrustPrompt"));
    if (sub_100010C10(v44))
      v45 = CFBooleanGetValue(v44) != 0;
    else
      v45 = 0;
    sub_100015CA8((uint64_t)v33, v45);
    sub_100028850(v33);
    sub_10001E2CC(*(NSObject ***)a1, 0);
    v52 = CFDictionaryGetValue(v26, CFSTR("SystemBUID"));
    if (sub_100010BA8(v52))
      sub_100013F60((uint64_t)v52, 1, 1, 0);
  }
  else
  {
    sub_10001A7E4(0, "handle_unpair", CFSTR("Failed to load pair record for %@."), v39, v40, v41, v42, v43, (char)v33);
    sub_100004354(1, (uint64_t)"handle_unpair", v12, CFSTR("InvalidHostID"));
  }
LABEL_18:
  if (a1 && v12)
  {
    sub_1000041C0(*(const __CFData **)(a1 + 24), v12, v20, v21, v22, v23, v24, v25, v53);
    goto LABEL_24;
  }
LABEL_22:
  if (v12)
    CFRelease(v12);
LABEL_24:
  if (v26)
    CFRelease(v26);
}

void sub_10001E2CC(NSObject **a1, int a2)
{
  const void *v4;
  const void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef *v10;
  CFTypeRef v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char v21;

  v4 = (const void *)sub_10000ED98((uint64_t)a1, 0, (uint64_t)CFSTR("TrustedHostAttached"));
  v5 = sub_100010C10(v4);
  v10 = (CFTypeRef *)&kCFBooleanTrue;
  if (!a2)
    v10 = (CFTypeRef *)&kCFBooleanFalse;
  v11 = *v10;
  if (!v5 || !CFEqual(v4, *v10))
  {
    sub_10000F0FC(a1, 0, (uint64_t)CFSTR("TrustedHostAttached"), 1, v6, v7, v8, v9);
    sub_10000E484((uint64_t)a1, 0, (uint64_t)CFSTR("TrustedHostAttached"), (uint64_t)v11, v12, v13, v14, v15);
    sub_1000110EC(CFSTR("com.apple.mobile.lockdown.trusted_host_attached"));
    sub_1000110EC(CFSTR("com.apple.mobile.lockdown.trusted_ptp_attached"));
    if (a2)
    {
      if (!sub_100014914())
        sub_10001A7E4(0, "set_trusted_host", CFSTR("Failed to reset USB RM policy."), v16, v17, v18, v19, v20, v21);
    }
  }
  if (v4)
    CFRelease(v4);
}

void sub_10001E3D4(uint64_t a1, const __CFDictionary *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFString *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFDictionary *v18;
  __CFString **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const void *Value;
  const __CFBoolean *v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  char v36;

  if (dword_1001A6AD0)
  {
    v12 = CFSTR("unknown");
    if (a3)
      LOBYTE(v12) = a3;
    sub_10001A7E4(0, "handle_reset_pair", CFSTR("Preparing to reset pairing for %@."), (uint64_t)a4, a5, a6, a7, a8, (char)v12);
  }
  v18 = sub_1000042FC(CFSTR("ResetPairing"));
  if (!a1)
  {
    sub_10001A7E4(0, "handle_reset_pair", CFSTR("Invalid input."), v13, v14, v15, v16, v17, v36);
    sub_100004354(1, (uint64_t)"handle_reset_pair", v18, CFSTR("MissingValue"));
    if (v18)
      CFRelease(v18);
    return;
  }
  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 4
    && sub_100010B40(a4)
    && CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("com.apple.private.lockdown.reset-pairing")) == kCFBooleanTrue)
  {
    Value = CFDictionaryGetValue(a2, CFSTR("FullReset"));
    v27 = (const __CFBoolean *)sub_100010C10(Value);
    if (sub_100010C10(v27))
    {
      v28 = CFBooleanGetValue(v27) != 0;
      sub_100014F6C(v28);
      sub_100028980();
      sub_100012D98(1, v29, v30, v31, v32, v33, v34, v35, v36);
      if (v18)
        goto LABEL_11;
      return;
    }
    v19 = off_10017B868;
  }
  else
  {
    v19 = off_10017B880;
  }
  sub_100004354(1, (uint64_t)"handle_reset_pair", v18, *v19);
  if (v18)
LABEL_11:
    sub_1000041C0(*(const __CFData **)(a1 + 24), v18, v20, v21, v22, v23, v24, v25, a9);
}

void sub_10001E57C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFDictionary *v11;
  __CFDictionary *v12;
  __CFString **v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const __CFString *v21;
  const __CFNumber *v22;
  const __CFNumber *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFDictionary *v34;
  __CFString **v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const __CFDictionary *v42;
  const void *Value;
  const __CFString *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const __CFString *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  double v58;
  double v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  CFStringRef v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  CFStringRef v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  const void *v85;
  const __CFData *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  const __CFData *v92;
  const void *v93;
  const void *v94;
  const __CFData *v95;
  const __CFData *v96;
  uint64_t v97;
  const __CFData *v98;
  uint64_t v99;
  const __CFString *v100;
  char v101;
  char v102;
  char v103;
  char v104;
  double valuePtr;
  double v106;

  valuePtr = 0.0;
  v106 = 0.0;
  if (!a1 || !a2)
  {
    v21 = CFSTR("Invalid input.");
    LODWORD(v11) = 0;
LABEL_9:
    sub_10001A7E4((int)v11, "handle_start_session", v21, a4, a5, a6, a7, a8, a9);
    return;
  }
  v11 = sub_1000042FC(CFSTR("StartSession"));
  if (!v11)
  {
    v21 = CFSTR("Failed to create response");
    goto LABEL_9;
  }
  v12 = v11;
  if (*(_QWORD *)(a1 + 32))
  {
    v13 = off_10017B990;
    v14 = CFSTR("Lockdown sessions not supported over remote service interface.");
LABEL_6:
    sub_10001A7E4(0, "handle_start_session", v14, a4, a5, a6, a7, a8, v101);
    sub_100004354(1, (uint64_t)"handle_start_session", v12, *v13);
    sub_1000041C0(*(const __CFData **)(a1 + 24), v12, v15, v16, v17, v18, v19, v20, a9);
    return;
  }
  v22 = sub_10000898C();
  if (!v22)
  {
    v13 = off_10017B858;
    v14 = CFSTR("Failed to retrieve current time.");
    goto LABEL_6;
  }
  v23 = v22;
  if (!CFNumberGetValue(v22, kCFNumberDoubleType, &valuePtr))
  {
    sub_10001A7E4(0, "handle_start_session", CFSTR("Failed to convert current time."), v24, v25, v26, v27, v28, v101);
    v34 = 0;
    goto LABEL_17;
  }
  if (!sub_100010B40(a2))
  {
    sub_10001A7E4(0, "handle_start_session", CFSTR("Invalid message."), v29, v30, v31, v32, v33, v101);
    v34 = 0;
LABEL_19:
    v35 = off_10017B8E0;
    goto LABEL_20;
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("HostID"));
    v44 = (const __CFString *)sub_100010BA8(Value);
    if (!v44)
    {
      sub_10001A7E4(0, "handle_start_session", CFSTR("Invalid host id."), v45, v46, v47, v48, v49, v101);
      v34 = 0;
      v35 = off_10017B8D8;
      goto LABEL_20;
    }
    v50 = v44;
    v34 = (const __CFDictionary *)sub_100015B64(v44);
    if (!v34)
    {
      sub_10001A7E4(0, "handle_start_session", CFSTR("No pairing record for %@."), v52, v53, v54, v55, v56, (char)v50);
      goto LABEL_19;
    }
    v57 = sub_100005908(v50, &v106, v51, v52, v53, v54, v55, v56);
    if (v57)
    {
      v58 = valuePtr;
      v59 = v106;
      if (v58 > v59 + (double)sub_100005C00())
      {
        sub_10001A7E4(0, "handle_start_session", CFSTR("Expired pairing record for %@."), v60, v61, v62, v63, v64, (char)v50);
        sub_100005A48(v50, v65, v66, v67, v68, v69, v70, v71, v103);
        goto LABEL_19;
      }
    }
    v72 = sub_10001111C();
    if (v72)
    {
      v78 = v72;
      CFDictionarySetValue(v12, CFSTR("SessionID"), v72);
      CFDictionarySetValue(v12, CFSTR("EnableSessionSSL"), kCFBooleanTrue);
      sub_1000041C0(*(const __CFData **)(a1 + 24), v12, v79, v80, v81, v82, v83, v84, v101);
      v85 = CFDictionaryGetValue(v34, CFSTR("DeviceCertificate"));
      v86 = (const __CFData *)sub_100010BDC(v85);
      if (!v86)
      {
        v93 = 0;
        v100 = CFSTR("Invalid certificate.");
        goto LABEL_41;
      }
      v92 = v86;
      v93 = (const void *)sub_10000ED98(*(_QWORD *)a1, 0, (uint64_t)CFSTR("DevicePrivateKey"));
      if (!v93)
      {
        v100 = CFSTR("Invalid private key.");
        goto LABEL_41;
      }
      v94 = CFDictionaryGetValue(v34, CFSTR("RootCertificate"));
      v95 = (const __CFData *)sub_100010BDC(v94);
      if (!v95)
      {
        v100 = CFSTR("Invalid root certificate.");
        goto LABEL_41;
      }
      v96 = v95;
      v97 = *(_QWORD *)(a1 + 24);
      v98 = (const __CFData *)sub_100010BDC(v93);
      if (sub_100004824(v97, v92, v98, v96, 0))
      {
        v100 = CFSTR("Failed to enable SSL.");
LABEL_41:
        sub_10001A7E4(0, "handle_start_session", v100, v87, v88, v89, v90, v91, v104);
        sub_100004790(*(_QWORD *)(a1 + 24));
LABEL_42:
        CFRelease(v23);
        CFRelease(v34);
        if (v93)
          CFRelease(v93);
        v42 = (const __CFDictionary *)v78;
        goto LABEL_22;
      }
      if (v57)
      {
        if (valuePtr > v106 + 86400.0 && (sub_100005628(v50, v23, v99, v87, v88, v89, v90, v91) & 1) == 0)
          goto LABEL_48;
      }
      else if (!sub_100005628(v50, v23, v99, v87, v88, v89, v90, v91))
      {
LABEL_48:
        v100 = CFSTR("Failed to update pair record timestamp.");
        goto LABEL_41;
      }
      *(_QWORD *)(a1 + 40) = CFRetain(v34);
      *(_QWORD *)(a1 + 48) = CFRetain(v78);
      if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 1
        || sub_1000047F4(*(_QWORD *)(a1 + 24)) == 2)
      {
        sub_10001E2CC(*(NSObject ***)a1, 1);
        sub_100017294(*(const __CFDictionary **)(a1 + 40));
      }
      goto LABEL_42;
    }
    sub_10001A7E4(0, "handle_start_session", CFSTR("Failed to generated uuid."), v73, v74, v75, v76, v77, v101);
LABEL_17:
    v35 = off_10017B858;
    goto LABEL_20;
  }
  sub_10001A7E4(0, "handle_start_session", CFSTR("Session already active."), v29, v30, v31, v32, v33, v101);
  v34 = 0;
  v35 = off_10017B8E8;
LABEL_20:
  sub_100004354(1, (uint64_t)"handle_start_session", v12, *v35);
  sub_1000041C0(*(const __CFData **)(a1 + 24), v12, v36, v37, v38, v39, v40, v41, v102);
  CFRelease(v23);
  if (!v34)
    return;
  v42 = v34;
LABEL_22:
  CFRelease(v42);
}

void sub_10001EA2C(uint64_t a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFDictionary *v16;
  __CFString **v17;
  __CFString *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *Value;
  const void *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  __CFString **v32;
  char v33;

  v16 = sub_1000042FC(CFSTR("StopSession"));
  if (!a1 || !a2)
  {
    sub_10001A7E4(0, "handle_stop_session", CFSTR("Invalid input."), v11, v12, v13, v14, v15, v33);
    v17 = off_10017B998;
    goto LABEL_6;
  }
  if (*(_QWORD *)(a1 + 32))
  {
    sub_10001A7E4(0, "handle_stop_session", CFSTR("Lockdown sessions not supported over remote service interface."), v11, v12, v13, v14, v15, v33);
    v17 = off_10017B990;
LABEL_6:
    v18 = *v17;
LABEL_7:
    sub_100004354(1, (uint64_t)"handle_stop_session", v16, v18);
    goto LABEL_8;
  }
  if (!sub_100010B40(a2))
  {
    sub_100004354(1, (uint64_t)"handle_stop_session", v16, CFSTR("SessionInactive"));
    sub_10001A7E4(0, "handle_stop_session", CFSTR("hinky message"), v27, v28, v29, v30, v31, v33);
    goto LABEL_8;
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    v32 = off_10017B8F0;
LABEL_24:
    v18 = *v32;
    goto LABEL_7;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("SessionID"));
  if (!sub_100010BA8(Value))
  {
    v32 = off_10017B8F8;
    goto LABEL_24;
  }
  if (!CFEqual(Value, *(CFTypeRef *)(a1 + 48)))
  {
    v32 = off_10017B900;
    goto LABEL_24;
  }
  CFRelease(*(CFTypeRef *)(a1 + 48));
  *(_QWORD *)(a1 + 48) = 0;
  v26 = *(const void **)(a1 + 40);
  if (v26)
  {
    CFRelease(v26);
    *(_QWORD *)(a1 + 40) = 0;
  }
LABEL_8:
  if (a1 && v16)
  {
    sub_1000041C0(*(const __CFData **)(a1 + 24), v16, v19, v20, v21, v22, v23, v24, a9);
  }
  else if (v16)
  {
    CFRelease(v16);
  }
}

const __CFString *sub_10001EBDC(uint64_t a1, const void *a2, const void *a3, const void *a4, const void *a5, const void *a6, const void *a7, const void *a8, const void *a9, int a10, CFNumberRef *a11)
{
  CFMutableDictionaryRef v19;
  __CFDictionary *v20;
  const __CFDictionary *v21;
  const void *Value;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  NSNumber *v28;
  CFStringRef v29;
  const __CFString *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  CFBooleanRef v38;
  const void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  dispatch_queue_t *v46;
  const void *v47;
  const void *v48;
  NSObject **v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const __CFDictionary *v55;
  const void *v56;
  const void *v57;
  const __CFBoolean *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  CFBooleanRef v64;
  CFBooleanRef v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  const __CFString *v71;
  __CFDictionary *v72;
  const void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const __CFString *v79;
  const void *v80;
  const void *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  const __CFString *v87;
  const void *v88;
  const __CFNumber *v89;
  NSObject **v90;
  int v91;
  const void *v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  _QWORD *v98;
  const void *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  const __CFString *v105;
  const __CFString *v106;
  const void *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  const void *v114;
  const __CFString *v115;
  char v116;
  __CFString **v117;
  int v118;
  const __CFString *v120;
  const void *v121;
  const __CFString *v122;
  int v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  const __CFString *v134;
  const void *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  const __CFString *v141;
  char v142;
  _BOOL4 v143;
  const void *v144;
  CFBooleanRef cf;
  const void *v146;
  unsigned __int8 v147;
  const __CFString *v148;
  _QWORD v149[5];
  int v150;
  uint64_t valuePtr;
  unsigned int v152;

  v148 = 0;
  v147 = 0;
  if (!a1 || !a11)
  {
    v30 = CFSTR("Invalid input.");
    LODWORD(v19) = 0;
LABEL_11:
    sub_10001A7E4((int)v19, "spawn_and_handle_checkin", v30, (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, (uint64_t)a8, v142);
    return v148;
  }
  v19 = sub_100025A4C();
  if (!v19)
  {
    v30 = CFSTR("Failed to allocate dictionary.");
    goto LABEL_11;
  }
  v20 = v19;
  v146 = a2;
  v21 = *(const __CFDictionary **)(a1 + 40);
  if (v21)
  {
    Value = CFDictionaryGetValue(v21, CFSTR("HostID"));
    if (!sub_100010BA8(Value))
    {
      sub_10001A7E4(0, "spawn_and_handle_checkin", CFSTR("Invalid or missing host ID."), v23, v24, v25, v26, v27, v142);
      v72 = v20;
LABEL_88:
      CFRelease(v72);
      return v148;
    }
    CFDictionarySetValue(v20, CFSTR("HostID"), Value);
  }
  v28 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", sub_1000047F4(*(_QWORD *)(a1 + 24)));
  CFDictionarySetValue(v20, CFSTR("HostConnectionType"), v28);
  if (*(_QWORD *)(a1 + 32))
  {
    v29 = 0;
  }
  else
  {
    v31 = sub_1000047E0(*(unsigned int **)(a1 + 24));
    v29 = sub_100010EDC(v31, (char *)&v147);
    if (v29)
      CFDictionarySetValue(v20, CFSTR("HostIP"), v29);
  }
  if (a3)
    CFDictionarySetValue(v20, CFSTR("HostSideClientName"), a3);
  if (a4)
    CFDictionarySetValue(v20, CFSTR("HostSideHostName"), a4);
  if (a7 && a8 && a9)
  {
    CFDictionarySetValue(v20, CFSTR("DevicePrivateKey"), a7);
    CFDictionarySetValue(v20, CFSTR("DeviceCertificate"), a8);
    CFDictionarySetValue(v20, CFSTR("HostRootCertificate"), a9);
  }
  if (a5)
  {
    if (a6)
    {
      CFDictionarySetValue(v20, CFSTR("EscrowSecret"), a6);
      CFDictionarySetValue(v20, CFSTR("EscrowBag"), a5);
      if ((sub_100010308(0, (uint64_t)a5, (CFDataRef)a6, &v148) & 1) == 0)
      {
        sub_10001A7E4(0, "spawn_and_handle_checkin", CFSTR("Failed to unlock escrow bag."), v32, v33, v34, v35, v36, v142);
        v37 = 0;
        goto LABEL_84;
      }
    }
  }
  v37 = (void *)sub_10000ED98(*(_QWORD *)a1, (uint64_t)CFSTR("com.apple.mobile.debug"), (uint64_t)CFSTR("ForceHeartbeat"));
  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 3)
  {
    v38 = kCFBooleanTrue;
LABEL_29:
    CFDictionaryAddValue(v20, CFSTR("UseHostTracker"), v38);
    goto LABEL_30;
  }
  if (sub_100010C10(v37))
  {
    v38 = kCFBooleanTrue;
    if (CFEqual(v37, kCFBooleanTrue))
      goto LABEL_29;
  }
LABEL_30:
  v39 = sub_100010BA8(v146);
  v45 = v147;
  v152 = 0;
  if (!v39 || (v46 = *(dispatch_queue_t **)(a1 + 8)) == 0)
  {
    sub_10001A7E4(0, "spawn_service_agent", CFSTR("Invalid input."), v40, v41, v42, v43, v44, v142);
LABEL_38:
    LOBYTE(v71) = (_BYTE)v146;
    if (!v146)
      v71 = CFSTR("unknown");
    sub_10001A7E4(0, "spawn_and_handle_checkin", CFSTR("Failed to spawn '%@' service agent: %@"), v66, v67, v68, v69, v70, (char)v71);
    goto LABEL_84;
  }
  v47 = v39;
  v48 = sub_100010BA8(v39);
  v49 = sub_100019FC0(v46, (uint64_t)v48);
  if (!v49)
  {
    sub_10001A7E4(0, "spawn_service_agent", CFSTR("Failed to look up service in the map."), v50, v51, v52, v53, v54, v142);
    v148 = CFSTR("InvalidService");
    goto LABEL_38;
  }
  v55 = (const __CFDictionary *)v49;
  v56 = CFDictionaryGetValue((CFDictionaryRef)v49, CFSTR("AllowUnactivatedService"));
  v57 = sub_100010C10(v56);
  if (v57 && !CFEqual(v57, kCFBooleanFalse))
  {
    cf = 0;
  }
  else
  {
    v58 = (const __CFBoolean *)sub_10000ED98(*(_QWORD *)a1, 0, (uint64_t)CFSTR("BrickState"));
    if (sub_100010C10(v58))
    {
      v64 = kCFBooleanTrue;
      v65 = v58;
    }
    else
    {
      sub_10001A7E4(0, "spawn_service_agent", CFSTR("Failed to look up brick state, assuming unactivated."), v59, v60, v61, v62, v63, v142);
      if (v58)
        CFRelease(v58);
      v64 = kCFBooleanTrue;
      v65 = kCFBooleanTrue;
    }
    cf = v65;
    if (CFEqual(v65, v64))
    {
      v73 = sub_100010BA8(v47);
      v79 = CFSTR("unknown");
      if (v73)
        LOBYTE(v79) = (_BYTE)v47;
      sub_10001A7E4(0, "spawn_service_agent", CFSTR("Service '%@' is currently prohibited from running (device is not activated)."), v74, v75, v76, v77, v78, (char)v79);
      goto LABEL_75;
    }
  }
  v80 = CFDictionaryGetValue(v55, CFSTR("DeveloperModeRequired"));
  v81 = sub_100010C10(v80);
  if (v81 && CFEqual(v81, kCFBooleanTrue) && !sub_10000D7F0())
  {
    v99 = sub_100010BA8(v47);
    v105 = CFSTR("unknown");
    if (v99)
      LOBYTE(v105) = (_BYTE)v47;
    sub_10001A7E4(0, "spawn_service_agent", CFSTR("Service '%@' is currently prohibited from running (developer mode not enabled)."), v100, v101, v102, v103, v104, (char)v105);
    goto LABEL_75;
  }
  if (*(_DWORD *)(a1 + 16) == 4)
  {
    v87 = CFSTR("Internal clients are prohibited from starting services.");
LABEL_74:
    sub_10001A7E4(0, "spawn_service_agent", v87, v82, v83, v84, v85, v86, v142);
LABEL_75:
    v116 = 0;
    v106 = 0;
    v98 = 0;
    v117 = off_10017B960;
LABEL_76:
    v148 = *v117;
    v118 = -1;
    goto LABEL_77;
  }
  v88 = CFDictionaryGetValue(v55, CFSTR("USBOnlyService"));
  if (sub_100010C10(v88) && CFEqual(v88, kCFBooleanTrue) && *(_DWORD *)(a1 + 16) != 1)
  {
    v114 = sub_100010BA8(v47);
    v115 = CFSTR("unknown");
    if (v114)
      LOBYTE(v115) = (_BYTE)v47;
    v142 = (char)v115;
    v87 = CFSTR("Service '%@' is only allowed to run over USB.");
    goto LABEL_74;
  }
  v89 = (const __CFNumber *)CFDictionaryGetValue(v55, CFSTR("InstanceLimit"));
  if (sub_100010B0C(v89))
  {
    valuePtr = 0;
    v90 = *(NSObject ***)(a1 + 8);
    v91 = CFNumberGetValue(v89, kCFNumberIntType, (char *)&valuePtr + 4);
    v92 = sub_100010BA8(v47);
    if (v91)
    {
      if (sub_10001A0E8(v90, (uint64_t)v92, SHIDWORD(valuePtr), (uint64_t)&valuePtr))
      {
        v149[0] = _NSConcreteStackBlock;
        v149[1] = 3221225472;
        v149[2] = sub_1000222B0;
        v149[3] = &unk_10017A970;
        v149[4] = v90;
        v150 = valuePtr;
        v98 = objc_retainBlock(v149);
        goto LABEL_68;
      }
      v92 = sub_100010BA8(v47);
      v120 = CFSTR("Too many instances of service '%@' already running.");
    }
    else
    {
      v120 = CFSTR("Invalid instance limit specified for '%@'");
    }
    v134 = CFSTR("unknown");
    if (v92)
      LOBYTE(v134) = (_BYTE)v47;
    sub_10001A7E4(0, "spawn_service_agent", v120, v93, v94, v95, v96, v97, (char)v134);
    v116 = 0;
    v106 = 0;
    v98 = 0;
    v117 = off_10017B918;
    goto LABEL_76;
  }
  v98 = 0;
LABEL_68:
  v106 = (const __CFString *)CFDictionaryGetValue(v55, CFSTR("XPCServiceName"));
  v144 = sub_100010BA8(v106);
  if (!v144)
  {
    v121 = sub_100010BA8(v47);
    v122 = (const __CFString *)sub_1000222C0(v121, v55);
    if (!v122)
    {
      if (v98)
        ((void (*)(_QWORD *))v98[2])(v98);
      v135 = sub_100010BA8(v47);
      v141 = CFSTR("unknown");
      if (v135)
        LOBYTE(v141) = (_BYTE)v47;
      sub_10001A7E4(0, "spawn_service_agent", CFSTR("Failed to register service '%@' with launchd."), v136, v137, v138, v139, v140, (char)v141);
      v116 = 0;
      v106 = 0;
      v117 = off_10017B910;
      goto LABEL_76;
    }
    v106 = v122;
    goto LABEL_93;
  }
  CFRetain(v106);
  v107 = CFDictionaryGetValue(v55, CFSTR("MultipleInstances"));
  if (!sub_100010C10(v107))
  {
LABEL_93:
    v143 = 0;
    goto LABEL_94;
  }
  v143 = CFEqual(v107, kCFBooleanTrue) != 0;
LABEL_94:
  v118 = a10;
  if (a10 == -1
    && (v45 ? (v123 = 30) : (v123 = 2), v118 = sub_100005C0C(&v152, v123, v108, v109, v110, v111, v112, v113),
                                        v118 == -1))
  {
    sub_10001A7E4(0, "spawn_service_agent", CFSTR("Failed to create a socket for the host to connect to."), v124, v125, v126, v127, v128, v142);
    v116 = 0;
    v148 = CFSTR("CheckinSetupFailed");
  }
  else
  {
    sub_100010C44(v118);
    sub_100010CBC(v118);
    if (sub_100022730(a1, v106, v118, v20, v144 == 0, v143, v98, &v148))
    {
      sub_10001A7E4(0, "spawn_service_agent", CFSTR("Failed to spawn XPC service agent for %@."), v129, v130, v131, v132, v133, (char)v106);
      v116 = 0;
    }
    else
    {
      *a11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &v152);
      v116 = 1;
    }
  }
LABEL_77:
  if (cf)
    CFRelease(cf);
  CFRelease(v55);
  if (v106)
    CFRelease(v106);
  if (v118 != -1)
    close(v118);

  if ((v116 & 1) == 0)
    goto LABEL_38;
LABEL_84:
  CFRelease(v20);
  if (v29)
    CFRelease(v29);
  if (v37)
  {
    v72 = (__CFDictionary *)v37;
    goto LABEL_88;
  }
  return v148;
}

void sub_10001F478(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const void *v17;
  char v18;
  __CFDictionary *v19;

  v19 = 0;
  if (a1)
  {
    if (*(_QWORD *)(a1 + 32))
    {
      sub_10001A7E4(0, "handle_start_service", CFSTR("Cannot start lockdown services via lockdown remote service. Use remote service discovery."), a4, a5, a6, a7, a8, v18);
      sub_100004354(1, (uint64_t)"handle_start_service", 0, CFSTR("InvalidConnection"));
      v16 = 0;
    }
    else
    {
      v17 = sub_10001F560(a1, a2, a3, 0xFFFFFFFFLL, &v19, a6, a7, a8);
      v16 = v17;
      if (v17)
        sub_10001A7E4(0, "handle_start_service", CFSTR("Failed to start service: %@"), v11, v12, v13, v14, v15, (char)v17);
    }
    if (v19)
    {
      sub_1000041C0(*(const __CFData **)(a1 + 24), v19, v10, v11, v12, v13, v14, v15, v18);
      v19 = 0;
    }
    if (v16)
      CFRelease(v16);
  }
  else
  {
    sub_10001A7E4(0, "handle_start_service", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

const void *sub_10001F560(uint64_t a1, const void *a2, const __CFString *a3, uint64_t a4, __CFDictionary **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  __CFDictionary *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  const void *Value;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _BOOL4 v30;
  const void *v31;
  const void *v32;
  const __CFString *v33;
  __CFString **v34;
  const __CFString *v35;
  uint64_t v36;
  _BOOL4 v37;
  _BOOL4 v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  const __CFDictionary *v44;
  const void *v45;
  const void *v46;
  const void *v47;
  const void *v48;
  _BOOL4 v49;
  const void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const void *v61;
  const void *v62;
  const __CFString *v63;
  const void *v64;
  const void *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const __CFString *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  const __CFString *v79;
  __CFDictionary *v80;
  __CFString *v81;
  CFTypeRef v82;
  const __CFString *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  const __CFString *v89;
  __CFString **v90;
  const __CFString *v91;
  char v92;
  const void *v93;
  const void *v94;
  const void *v95;
  const void *v96;
  CFTypeRef cf;
  CFTypeRef v98;

  cf = 0;
  v98 = 0;
  if (!a1)
  {
    sub_10001A7E4(0, "handle_start_service_with_socket", CFSTR("Invalid input."), a4, (uint64_t)a5, a6, a7, a8, v92);
    v31 = 0;
    v18 = 0;
LABEL_14:
    v32 = 0;
    goto LABEL_44;
  }
  v9 = a4;
  v18 = sub_1000042FC(CFSTR("StartService"));
  if (!v18)
  {
    sub_10001A7E4(0, "handle_start_service_with_socket", CFSTR("Failed to create response."), v13, v14, v15, v16, v17, v92);
    v31 = 0;
    goto LABEL_14;
  }
  if (!sub_100010BA8(a3))
    a3 = CFSTR("unknown");
  if (!sub_100010B40(a2))
  {
    v33 = CFSTR("Invalid message.");
LABEL_16:
    sub_10001A7E4(0, "handle_start_service_with_socket", v33, v19, v20, v21, v22, v23, v92);
    v34 = off_10017B868;
LABEL_41:
    sub_100004354(1, (uint64_t)"handle_start_service_with_socket", v18, *v34);
    v31 = 0;
    goto LABEL_42;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Service"));
  if (!sub_100010BA8(Value))
  {
    v92 = (char)a3;
    v35 = CFSTR("%@ did not specify a service to launch.");
LABEL_18:
    sub_10001A7E4(0, "handle_start_service_with_socket", v35, v25, v26, v27, v28, v29, v92);
    v34 = off_10017B908;
    goto LABEL_41;
  }
  v30 = sub_1000047F4(*(_QWORD *)(a1 + 24)) != 1 && sub_1000047F4(*(_QWORD *)(a1 + 24)) != 2
     || !CFEqual(Value, CFSTR("com.apple.mobile.insecure_notification_proxy"))
     && !CFEqual(Value, CFSTR("com.apple.preboardservice_v2"));
  v36 = *(_QWORD *)(a1 + 32);
  v37 = v36 != 0;
  if (v36)
    v38 = 0;
  else
    v38 = v30;
  if (!MKBDeviceUnlockedSinceBoot())
  {
    v63 = CFSTR("Device not unlocked since boot.");
LABEL_40:
    sub_10001A7E4(0, "handle_start_service_with_socket", v63, v39, v40, v41, v42, v43, v92);
    v34 = off_10017B8A8;
    goto LABEL_41;
  }
  if ((sub_10000D770() & 1) == 0)
  {
    v63 = CFSTR("Device not unlocked within required time.");
    goto LABEL_40;
  }
  CFDictionarySetValue(v18, CFSTR("Service"), Value);
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "handle_start_service_with_socket", CFSTR("%@ attempting to spawn %@ service."), v25, v26, v27, v28, v29, (char)a3);
  if (!v38)
  {
    v31 = 0;
    v62 = 0;
    v50 = 0;
    v61 = 0;
    if (!v37)
    {
LABEL_68:
      v82 = 0;
      v66 = 0;
LABEL_71:
      v83 = sub_10001EBDC(a1, Value, a3, v61, v66, v82, v31, v62, v50, v9, (CFNumberRef *)&v98);
      if (!v83)
      {
        CFDictionarySetValue(v18, CFSTR("Port"), v98);
        if (v31)
          CFDictionarySetValue(v18, CFSTR("EnableServiceSSL"), kCFBooleanTrue);
        goto LABEL_42;
      }
      v89 = v83;
      sub_10001A7E4(0, "handle_start_service_with_socket", CFSTR("Failed to spawn %@."), v84, v85, v86, v87, v88, (char)Value);
      v80 = v18;
      v81 = (__CFString *)v89;
      goto LABEL_73;
    }
    goto LABEL_56;
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    sub_10001A7E4(0, "handle_start_service_with_socket", CFSTR("The connection is not within a session. We cannot start services."), v25, v26, v27, v28, v29, v92);
    v34 = off_10017B8F0;
    goto LABEL_41;
  }
  v44 = *(const __CFDictionary **)(a1 + 40);
  if (!v44)
  {
    v35 = CFSTR("Invalid pair record.");
    goto LABEL_18;
  }
  v45 = CFDictionaryGetValue(v44, CFSTR("HostName"));
  v46 = v45;
  if (v45)
  {
    v47 = v45;
    v48 = sub_100010BA8(v45);
    v46 = v47;
    if (!v48)
    {
      v33 = CFSTR("Invalid hostname.");
      goto LABEL_16;
    }
  }
  v95 = v46;
  v49 = ((unint64_t)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), CFSTR("HostID")) | v36) != 0;
  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 3
    || !CFEqual(Value, CFSTR("com.apple.afc"))
    && !CFEqual(Value, CFSTR("com.apple.afc.unrestricted"))
    && !CFEqual(Value, CFSTR("com.apple.mobile.installation_proxy"))
    && !CFEqual(Value, CFSTR("com.apple.mobile.file_relay"))
    && !CFEqual(Value, CFSTR("com.apple.mobile.FactoryServices")))
  {
    v31 = (const void *)sub_10000ED98(*(_QWORD *)a1, 0, (uint64_t)CFSTR("DevicePrivateKey"));
    v93 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), CFSTR("DeviceCertificate"));
    v50 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), CFSTR("RootCertificate"));
    if (sub_100010BDC(v31))
    {
      if (sub_100010BDC(v93))
      {
        if (sub_100010BDC(v50))
        {
          v62 = v93;
          v61 = v95;
          if (!v49)
            goto LABEL_68;
          goto LABEL_56;
        }
        v91 = CFSTR("Missing root certificate.");
      }
      else
      {
        v91 = CFSTR("Missing certificate.");
      }
      sub_10001A7E4(0, "handle_start_service_with_socket", v91, v56, v57, v58, v59, v60, v92);
      v90 = off_10017B868;
    }
    else
    {
      sub_10001A7E4(0, "handle_start_service_with_socket", CFSTR("Missing private key."), v51, v52, v53, v54, v55, v92);
      v90 = off_10017B860;
    }
    v81 = *v90;
    v80 = v18;
    goto LABEL_73;
  }
  v31 = 0;
  v62 = 0;
  v50 = 0;
  v61 = v95;
  if (!v49)
    goto LABEL_68;
LABEL_56:
  v94 = v62;
  v96 = v61;
  v66 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("EscrowBag"));
  if (!sub_100010BDC(v66))
  {
    v82 = 0;
LABEL_70:
    v62 = v94;
    v61 = v96;
    goto LABEL_71;
  }
  v73 = sub_10001FB54(a1, &cf, v67, v68, v69, v70, v71, v72);
  if (!v73)
  {
    v82 = cf;
    goto LABEL_70;
  }
  v79 = v73;
  sub_10001A7E4(0, "handle_start_service_with_socket", CFSTR("Failed to copy escrow secret."), v74, v75, v76, v77, v78, v92);
  v80 = v18;
  v81 = (__CFString *)v79;
LABEL_73:
  sub_100004354(1, (uint64_t)"handle_start_service_with_socket", v80, v81);
LABEL_42:
  v64 = CFDictionaryGetValue(v18, CFSTR("Error"));
  v32 = v64;
  if (v64)
    CFRetain(v64);
LABEL_44:
  if (a5)
  {
    *a5 = v18;
    v18 = 0;
  }
  if (cf)
    CFRelease(cf);
  cf = 0;
  if (v31)
    CFRelease(v31);
  if (v98)
    CFRelease(v98);
  v98 = 0;
  if (v18)
    CFRelease(v18);
  return v32;
}

const __CFString *sub_10001FB54(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v10;
  id v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  char name;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  char v25;
  const __CFString *v26;
  const __CFDictionary *v27;
  void *Value;
  id v29;
  id v30;
  __CFString **v31;
  const __CFString *v32;
  char v34;
  id v35;
  id v36;

  v10 = *(void **)(a1 + 32);
  if (v10)
  {
    v36 = 0;
    v11 = sub_10002A534(v10, &v36);
    v12 = (id)objc_claimAutoreleasedReturnValue(v11);
    v18 = v36;
    if (v18)
    {
      name = remote_device_get_name(*(_QWORD *)(a1 + 32));
      sub_10001A7E4(0, "conn_state_copy_escrow_secret", CFSTR("Failed to copy escrow key for remote device '%s': %@"), v20, v21, v22, v23, v24, name);
      goto LABEL_4;
    }
    goto LABEL_11;
  }
  v27 = *(const __CFDictionary **)(a1 + 40);
  if (!v27)
  {
    v26 = CFSTR("MissingPairRecord");
    v32 = CFSTR("No pairing record to retrieve secret from.");
LABEL_19:
    sub_10001A7E4(0, "conn_state_copy_escrow_secret", v32, a4, a5, a6, a7, a8, v34);
    v12 = 0;
    v18 = 0;
    goto LABEL_20;
  }
  Value = (void *)CFDictionaryGetValue(v27, CFSTR("HostID"));
  if (!sub_100010BA8(Value))
  {
    v26 = CFSTR("InvalidPairRecord");
    v32 = CFSTR("Pairing record is missing host ID.");
    goto LABEL_19;
  }
  v35 = 0;
  v29 = sub_100028A04(Value, &v35);
  v12 = (id)objc_claimAutoreleasedReturnValue(v29);
  v30 = v35;
  v18 = v30;
  if (v30)
  {
    sub_10001A7E4(0, "conn_state_copy_escrow_secret", CFSTR("Failed to copy escrow key: %@"), v13, v14, v15, v16, v17, (char)v30);
LABEL_4:
    v25 = sub_10001079C(v18, CFSTR("com.apple.MobileLockdown.ErrorDomain"), (id)0xFFFFFFFFFFFFFFF8) ^ 1;
    if (v12)
      goto LABEL_5;
    goto LABEL_12;
  }
LABEL_11:
  v25 = 1;
  if (v12)
  {
LABEL_5:
    if (a2)
    {
      v12 = v12;
      v26 = 0;
      *a2 = v12;
    }
    else
    {
      v26 = 0;
    }
    goto LABEL_20;
  }
LABEL_12:
  if ((v25 & 1) != 0)
  {
    sub_10001A7E4(0, "conn_state_copy_escrow_secret", CFSTR("Failed to copy escrow key."), v13, v14, v15, v16, v17, v34);
    v12 = 0;
    v31 = off_10017B8A8;
  }
  else
  {
    sub_10001A7E4(0, "conn_state_copy_escrow_secret", CFSTR("Escrow unlock unavailable because user has not unlocked device since boot."), v13, v14, v15, v16, v17, v34);
    v12 = 0;
    v31 = off_10017B8D0;
  }
  v26 = *v31;
LABEL_20:

  return v26;
}

void sub_10001FD20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFString *v11;
  __CFDictionary *v12;
  __CFDictionary *v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __CFString **v20;
  const __CFString *v21;
  const __CFString *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  char v43;

  if (dword_1001A6AD0)
  {
    v11 = CFSTR("unknown");
    if (a3)
      LOBYTE(v11) = a3;
    sub_10001A7E4(0, "handle_enter_recovery", CFSTR("Preparing to enter recovery for %@."), a4, a5, a6, a7, a8, (char)v11);
  }
  if (!a1 || !a2)
  {
    v22 = CFSTR("Invalid input(s)");
    LODWORD(v12) = 0;
LABEL_14:
    sub_10001A7E4((int)v12, "handle_enter_recovery", v22, a4, a5, a6, a7, a8, a9);
    return;
  }
  v12 = sub_1000042FC(CFSTR("EnterRecovery"));
  if (!v12)
  {
    v22 = CFSTR("Failed to create response.");
    goto LABEL_14;
  }
  v13 = v12;
  v14 = sub_1000047F4(*(_QWORD *)(a1 + 24));
  v20 = off_10017B990;
  v21 = CFSTR("Invalid connection type.");
  switch(v14)
  {
    case 1:
    case 5:
      if (*(_QWORD *)(a1 + 48) || (sub_100026E68() & 1) != 0)
        goto LABEL_16;
      v20 = off_10017B8F0;
      v21 = CFSTR("Session required to enter recovery over USB.");
      goto LABEL_22;
    case 3:
    case 6:
      if (!*(_QWORD *)(a1 + 48))
      {
        v20 = off_10017B8F0;
        v21 = CFSTR("Session required to enter recovery over WiFi.");
        goto LABEL_22;
      }
LABEL_16:
      if (sub_100007368())
      {
        v21 = CFSTR("Failed to disable auto-boot.");
LABEL_22:
        sub_10001A7E4(0, "handle_enter_recovery", v21, v15, v16, v17, v18, v19, v42);
        sub_100004354(1, (uint64_t)"handle_enter_recovery", v13, *v20);
        sub_1000041C0(*(const __CFData **)(a1 + 24), v13, v36, v37, v38, v39, v40, v41, a9);
        return;
      }
      sub_1000041C0(*(const __CFData **)(a1 + 24), v13, v23, v15, v16, v17, v18, v19, v42);
      sub_10001A7E4(0, "handle_enter_recovery", CFSTR("Closing connection and rebooting the device into recovery mode."), v24, v25, v26, v27, v28, v43);
      sub_100004790(*(_QWORD *)(a1 + 24));
      if (reboot3(0))
      {
        v29 = *__error();
        v30 = __error();
        strerror(*v30);
        sub_10001A7E4(0, "handle_enter_recovery", CFSTR("Failed to reboot device: %d (%s)"), v31, v32, v33, v34, v35, v29);
      }
      break;
    default:
      goto LABEL_22;
  }
}

void sub_10001FF1C(uint64_t *a1, const __CFDictionary *a2, uint64_t a3, const void *a4)
{
  __CFDictionary *v8;
  const void *Value;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFString **v22;
  __CFString *v23;
  __CFDictionary *v24;
  char v25;
  const __CFString *v26;
  CFRange v27;

  v26 = CFSTR("InvalidResponse");
  v8 = sub_1000042FC(CFSTR("IsHostTrusted"));
  if (sub_1000047F4(a1[3]) != 4)
    goto LABEL_12;
  Value = CFDictionaryGetValue(a2, CFSTR("Client"));
  if (!sub_100010BA8(Value))
  {
    v22 = off_10017B860;
    goto LABEL_14;
  }
  v10 = (const __CFDictionary *)CFDictionaryGetValue(a2, CFSTR("Options"));
  v11 = v10;
  if (v10 && !sub_100010B40(v10))
  {
    v24 = v8;
    v23 = CFSTR("InvalidResponse");
    goto LABEL_16;
  }
  if (!sub_100010B40(a4)
    || CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("com.apple.private.lockdown.lockdown_query")) != kCFBooleanTrue
    && ((v15 = CFDictionaryGetValue((CFDictionaryRef)a4, CFSTR("com.apple.private.lockdown.is-host-trusted")),
         !sub_100010B74(v15))
     || (v27.length = CFArrayGetCount((CFArrayRef)v15),
         v27.location = 0,
         !CFArrayContainsValue((CFArrayRef)v15, v27, Value))))
  {
LABEL_12:
    v22 = off_10017B870;
LABEL_14:
    v23 = *v22;
LABEL_15:
    v24 = v8;
LABEL_16:
    sub_100004354(1, (uint64_t)"handle_is_host_trusted", v24, v23);
    goto LABEL_17;
  }
  if (!sub_100018F80(a1, Value, v11, (uint64_t *)&v26, a3, v12, v13, v14))
  {
    if (dword_1001A6AD0)
      sub_10001A7E4(0, "handle_is_host_trusted", CFSTR("Host client %@ is not trusted."), v17, v18, v19, v20, v21, (char)Value);
    v23 = (__CFString *)v26;
    goto LABEL_15;
  }
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "handle_is_host_trusted", CFSTR("Host client %@ is trusted."), v17, v18, v19, v20, v21, (char)Value);
LABEL_17:
  sub_1000041C0((const __CFData *)a1[3], v8, v16, v17, v18, v19, v20, v21, v25);
}

CFMutableDictionaryRef sub_100020104(uint64_t a1, NSObject **a2, const __CFString *a3, const __CFString *a4)
{
  const void *v8;
  const void *v9;
  uint64_t v10;
  CFMutableDictionaryRef result;
  const void *v12;
  const void *v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const void *v29;
  const CFBooleanRef *v30;
  const void *v31;
  int v32;
  const __CFString *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const __CFString *v40;
  const __CFString *v41;
  int v42;
  __CFString **v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  id v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  id v78;

  v8 = sub_100010BA8(a3);
  v9 = sub_100010BA8(a4);
  v10 = sub_100011198((uint64_t)v8, (uint64_t)v9, 0, 0);
  if (v10)
  {
    result = (CFMutableDictionaryRef)MGCopyAnswer(v10, 0);
    if (result)
      return result;
    v12 = sub_100010BA8(a3);
    v13 = sub_100010BA8(a4);
    v14 = sub_100011198((uint64_t)v12, (uint64_t)v13, 0, 1);
    sub_10001A7E4(0, "special_case_get", CFSTR("MGCopyAnswer(%@) returned NULL"), v15, v16, v17, v18, v19, v14);
    return 0;
  }
  if (!sub_100010BA8(a3))
  {
    result = (CFMutableDictionaryRef)sub_100010BA8(a4);
    if (!result)
      return result;
    v21 = CFEqual(a4, CFSTR("DeviceName"));
    if ((_DWORD)v21)
      return (CFMutableDictionaryRef)sub_10000841C(v21, v22, v23, v24, v25, v26, v27, v28);
    if (!CFEqual(a4, CFSTR("WeHaveATicket")))
    {
      if (CFEqual(a4, CFSTR("DevicePrivateKey")))
        return sub_10000BE88();
      if (CFEqual(a4, CFSTR("DevicePublicKey")))
        return sub_10000C03C();
      if (CFEqual(a4, CFSTR("BrickState")))
        return sub_1000287D8();
      if (CFEqual(a4, CFSTR("ActivationState")))
        return (CFMutableDictionaryRef)sub_100028848();
      if (CFEqual(a4, CFSTR("PasswordProtected")))
        return sub_100008CE4();
      if (CFEqual(a4, CFSTR("TimeIntervalSince1970")))
        return sub_10000898C();
      if (CFEqual(a4, CFSTR("TimeZone")))
        return (CFMutableDictionaryRef)sub_100008AB4();
      if (CFEqual(a4, CFSTR("TimeZoneOffsetFromUTC")))
        return sub_100008DA4();
      if (CFEqual(a4, CFSTR("Uses24HourClock")))
        return sub_100008BB8();
      if (CFEqual(a4, CFSTR("CarrierBundleInfo")))
        return (CFMutableDictionaryRef)sub_10000C960();
      if (CFEqual(a4, CFSTR("NonVolatileRAM")))
        return sub_10000C880();
      if (CFEqual(a4, CFSTR("IntegratedCircuitCardIdentity")))
      {
        v42 = 0;
      }
      else
      {
        if (!CFEqual(a4, CFSTR("IntegratedCircuitCardIdentity2")))
        {
          if (CFEqual(a4, CFSTR("PhoneNumber")))
          {
            v51 = 0;
          }
          else
          {
            if (!CFEqual(a4, CFSTR("PhoneNumber2")))
            {
              if (CFEqual(a4, CFSTR("EscrowBag")))
                return (CFMutableDictionaryRef)sub_100028D1C(a1, v58, v59, v60, v61, v62, v63, v64);
              if (CFEqual(a4, CFSTR("SIMStatus")))
                return (CFMutableDictionaryRef)sub_10000D210();
              if (CFEqual(a4, CFSTR("BasebandStatus")))
                return (CFMutableDictionaryRef)MGCopyAnswer(CFSTR("BasebandStatus"), 0);
              if (CFEqual(a4, CFSTR("ActivationPublicKey")))
                return (CFMutableDictionaryRef)sub_10000C520();
              if (CFEqual(a4, CFSTR("DeviceCertificate")))
                return sub_10000C5B0();
              if (CFEqual(a4, CFSTR("ActivationPrivateKey")))
                return (CFMutableDictionaryRef)sub_10000C568();
              if (CFEqual(a4, CFSTR("IDAMConfig")))
                return sub_10000D304();
              if (CFEqual(a4, CFSTR("MultiUserMode")))
                return sub_10000D364();
              if (CFEqual(a4, CFSTR("MultiUserLoginWindow")))
                return sub_10000D394();
              if (CFEqual(a4, CFSTR("PreflightInfo")))
                return sub_10000D3C4();
              if (CFEqual(a4, CFSTR("ApParameters")))
                return sub_10000D428();
              return 0;
            }
            v51 = 1;
          }
          return (CFMutableDictionaryRef)sub_10000D094(v51, v44, v45, v46, v47, v48, v49, v50);
        }
        v42 = 1;
      }
      return (CFMutableDictionaryRef)sub_10000CF24(v42);
    }
    v30 = &kCFBooleanTrue;
    return *v30;
  }
  if (CFEqual(a3, CFSTR("com.apple.mobile.lockdown.paired_hosts")))
  {
    v20 = (const __CFString *)sub_100010BA8(a4);
    return sub_100015A40(v20);
  }
  if (CFEqual(a3, CFSTR("com.apple.mobile.lockdown.paired_host_info")))
  {
    v29 = sub_100010BA8(a4);
    return (CFMutableDictionaryRef)sub_1000157D0(v29);
  }
  if (!CFEqual(a3, CFSTR("com.apple.mobile.internal")))
  {
    if (CFEqual(a3, CFSTR("com.apple.disk_usage")) || CFEqual(a3, CFSTR("com.apple.disk_usage.factory")))
    {
      v31 = sub_100010BA8(a4);
      return sub_100007480((uint64_t)a2, a3, v31);
    }
    if (CFEqual(a3, CFSTR("com.apple.mobile.iTunes")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
        return (CFMutableDictionaryRef)MCCopyCheckpointValue(a4);
      return result;
    }
    if (CFEqual(a3, CFSTR("com.apple.fairplay")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
      {
        if (CFEqual(a4, CFSTR("RentalBagRequest")))
          return sub_1000099DC(a2);
        if (CFEqual(a4, CFSTR("RBRequestVersion")))
          return sub_100009E84();
        if (CFEqual(a4, CFSTR("FairPlayRentalClockBias")))
          return sub_10000A14C();
        if (CFEqual(a4, CFSTR("RentalBagResponse")))
          return sub_100009D1C(a2);
        return 0;
      }
      return result;
    }
    if (CFEqual(a3, CFSTR("com.apple.mobile.restriction")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
      {
        if (CFEqual(a4, CFSTR("ProhibitAppInstall")))
          return sub_100027970();
        if (CFEqual(a4, CFSTR("ProhibitAppDelete")))
          return sub_1000279C4();
        return 0;
      }
      return result;
    }
    if (CFEqual(a3, CFSTR("com.apple.international")))
    {
      sub_100012E48(a2);
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
      {
        if (CFEqual(a4, CFSTR("Language")))
          return (CFMutableDictionaryRef)sub_100009214();
        if (CFEqual(a4, CFSTR("Locale")))
          return (CFMutableDictionaryRef)sub_10000939C();
        if (CFEqual(a4, CFSTR("Keyboard")))
          return (CFMutableDictionaryRef)sub_1000095D8();
        if (CFEqual(a4, CFSTR("SortSections")))
          return (CFMutableDictionaryRef)sub_100009670();
        return 0;
      }
      return result;
    }
    if (CFEqual(a3, CFSTR("com.apple.mobile.debug")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
      {
        if (CFEqual(a4, CFSTR("EnableVPNLogs")))
          return sub_10000AD04();
        if (CFEqual(a4, CFSTR("Enable8021XLogs")))
          return sub_10000B050();
        if (CFEqual(a4, CFSTR("EnableLockdownLogToDisk")))
          return (CFMutableDictionaryRef)sub_10000BA98();
        if (CFEqual(a4, CFSTR("EnableLockdownExtendedLogging")))
          return (CFMutableDictionaryRef)sub_10000BD60();
        if (CFEqual(a4, CFSTR("EnableCLTMLogs")) || CFEqual(a4, CFSTR("EnableCLTMTGraphLogs")))
          return (CFMutableDictionaryRef)sub_10000B2E4();
        if (CFEqual(a4, CFSTR("EnableMediaStreamLogs")))
          return (CFMutableDictionaryRef)sub_10000BDC8();
        if (CFEqual(a4, CFSTR("EnableRaptorCerts")))
          return (CFMutableDictionaryRef)sub_10000BD94();
        return 0;
      }
      return result;
    }
    if (CFEqual(a3, CFSTR("com.apple.mobile.demo")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
      {
        if (CFEqual(a4, CFSTR("EnableTetheredDisplayPortMode")))
          return (CFMutableDictionaryRef)sub_100008CD0();
        return 0;
      }
      return result;
    }
    if (CFEqual(a3, CFSTR("com.apple.PurpleBuddy")))
      return (CFMutableDictionaryRef)sub_100025818("/private/var/mobile/Library/Preferences/com.apple.purplebuddy.plist");
    if (CFEqual(a3, CFSTR("com.apple.fmip")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (!result)
        return result;
      if (CFEqual(a4, CFSTR("IsAssociated")))
      {
        v32 = sub_10002693C();
        goto LABEL_89;
      }
      return 0;
    }
    if (CFEqual(a3, CFSTR("com.apple.Accessibility")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
        return (CFMutableDictionaryRef)_AXSAccessibilityCopyiTunesPreference(a4);
      return result;
    }
    v33 = CFSTR("com.apple.AssetCacheTetherator");
    if (CFEqual(a3, CFSTR("com.apple.AssetCacheTetherator")))
      goto LABEL_105;
    if (CFEqual(a3, CFSTR("com.apple.MobileDeviceCrashCopy")))
    {
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (result)
        return sub_1000045C0(a4);
      return result;
    }
    v33 = CFSTR("com.apple.purplebuddy");
    if (CFEqual(a3, CFSTR("com.apple.purplebuddy")))
    {
LABEL_105:
      result = (CFMutableDictionaryRef)sub_100010BA8(a4);
      if (!result)
        return result;
      v40 = a4;
      v41 = v33;
    }
    else
    {
      if (CFEqual(a3, CFSTR("com.apple.mobileipod")))
      {
        result = (CFMutableDictionaryRef)sub_100010BA8(a4);
        if (!result)
          return result;
        v43 = off_10017B850;
      }
      else
      {
        if (CFEqual(a3, CFSTR("com.apple.mobile.user_preferences")))
        {
          result = (CFMutableDictionaryRef)sub_100010BA8(a4);
          if (result)
          {
            if (CFEqual(a4, CFSTR("FileSharingEnabled")))
              return sub_10000D278();
            else
              return (CFMutableDictionaryRef)sub_100013C70(a3, a4, v52, v53, v54, v55, v56, v57);
          }
          return result;
        }
        if (CFEqual(a3, CFSTR("com.apple.mobile.chaperone")))
        {
          result = (CFMutableDictionaryRef)sub_100010BA8(a4);
          if (result)
          {
            if (CFEqual(a4, CFSTR("DeviceIsChaperoned")))
              return sub_1000270D8();
            return 0;
          }
          return result;
        }
        if (CFEqual(a3, CFSTR("com.apple.healthd")))
        {
          result = (CFMutableDictionaryRef)sub_100010BA8(a4);
          if (result)
          {
            if (CFEqual(a4, CFSTR("HDHealthInUse")))
              return sub_10000D2B0();
            return 0;
          }
          return result;
        }
        if (!CFEqual(a3, CFSTR("com.apple.mobile.backup")))
        {
          if (CFEqual(a3, CFSTR("com.apple.lockdown.datamigrator")))
          {
            result = (CFMutableDictionaryRef)sub_100010BA8(a4);
            if (!result)
              return result;
            v32 = sub_100006FB4();
            goto LABEL_89;
          }
          if (CFEqual(a3, CFSTR("com.apple.security.mac.amfi")))
          {
            result = (CFMutableDictionaryRef)sub_100010BA8(a4);
            if (!result)
              return result;
            if (CFEqual(a4, CFSTR("DeveloperModeStatus")))
            {
              v32 = sub_10000D7F0();
LABEL_89:
              v30 = &kCFBooleanTrue;
              if (!v32)
                v30 = &kCFBooleanFalse;
              return *v30;
            }
          }
          else
          {
            if (CFEqual(a3, CFSTR("com.apple.securityd.ae")))
            {
              result = (CFMutableDictionaryRef)sub_100010BA8(a4);
              if (result)
              {
                if (CFEqual(a4, CFSTR("AEToken")))
                {
                  v70 = sub_1000232DC();
                  return (CFMutableDictionaryRef)objc_claimAutoreleasedReturnValue(v70);
                }
                return 0;
              }
              return result;
            }
            if (CFEqual(a3, CFSTR("com.apple.corerepair")))
            {
              result = (CFMutableDictionaryRef)sub_100010BA8(a4);
              if (result)
              {
                if (CFEqual(a4, CFSTR("RepairReport")))
                {
                  v78 = sub_10001B340(0, v71, v72, v73, v74, v75, v76, v77);
                  return (CFMutableDictionaryRef)objc_claimAutoreleasedReturnValue(v78);
                }
                return 0;
              }
              return result;
            }
          }
          return 0;
        }
        result = (CFMutableDictionaryRef)sub_100010BA8(a4);
        if (!result)
          return result;
        sub_10001A7E4(0, "special_case_get", CFSTR("key %@"), v65, v66, v67, v68, v69, (char)a4);
        v43 = off_10017B5D0;
      }
      v41 = *v43;
      v40 = a4;
    }
    return (CFMutableDictionaryRef)sub_10001AE30(v40, v41, v34, v35, v36, v37, v38, v39);
  }
  result = (CFMutableDictionaryRef)sub_100010BA8(a4);
  if (result)
  {
    if (CFEqual(a4, CFSTR("DevToolsAvailable")))
      return (CFMutableDictionaryRef)sub_10000CF54();
    return 0;
  }
  return result;
}

void sub_1000210C4(NSObject ***a1, const __CFString *a2, __CFDictionary *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFDictionary *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFDictionary *v18;
  const __CFDictionary *v19;
  const void *v20;
  const __CFString *v21;
  __CFString **v22;
  __CFString **v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const __CFDictionary *v45;
  const __CFDictionary *v46;
  char v47;
  char v48;
  _QWORD v49[5];
  _QWORD v50[5];
  _QWORD v51[5];

  if (!sub_100010BA8(a2) && sub_100010B40(a3))
  {
    sub_100021D30(a1, a3, a2, CFSTR("WeHaveATicket"));
    sub_100021D30(a1, a3, a2, CFSTR("ActivationState"));
    sub_100021D30(a1, a3, a2, CFSTR("BrickState"));
    sub_100021D30(a1, a3, a2, CFSTR("PasswordProtected"));
    sub_100021D30(a1, a3, a2, CFSTR("UniqueDeviceID"));
    sub_100021D30(a1, a3, a2, CFSTR("TimeIntervalSince1970"));
    sub_100021D30(a1, a3, a2, CFSTR("TimeZone"));
    sub_100021D30(a1, a3, a2, CFSTR("TimeZoneOffsetFromUTC"));
    sub_100021D30(a1, a3, a2, CFSTR("Uses24HourClock"));
    sub_100021D30(a1, a3, a2, CFSTR("NonVolatileRAM"));
    sub_100021D30(a1, a3, a2, CFSTR("SIMStatus"));
    sub_100021D30(a1, a3, a2, CFSTR("BoardId"));
    sub_100021D30(a1, a3, a2, CFSTR("ChipID"));
    sub_100021D30(a1, a3, a2, CFSTR("SerialNumber"));
    sub_100021D30(a1, a3, a2, CFSTR("MLBSerialNumber"));
    sub_100021D30(a1, a3, a2, CFSTR("ModelNumber"));
    sub_100021D30(a1, a3, a2, CFSTR("RegionInfo"));
    sub_100021D30(a1, a3, a2, CFSTR("WiFiAddress"));
    sub_100021D30(a1, a3, a2, CFSTR("EthernetAddress"));
    sub_100021D30(a1, a3, a2, CFSTR("BluetoothAddress"));
    sub_100021D30(a1, a3, a2, CFSTR("HardwareModel"));
    sub_100021D30(a1, a3, a2, CFSTR("BuildVersion"));
    sub_100021D30(a1, a3, a2, CFSTR("ProductVersion"));
    sub_100021D30(a1, a3, a2, CFSTR("HumanReadableProductVersionString"));
    sub_100021D30(a1, a3, a2, CFSTR("ProductName"));
    sub_100021D30(a1, a3, a2, CFSTR("ReleaseType"));
    sub_100021D30(a1, a3, a2, CFSTR("CPUArchitecture"));
    sub_100021D30(a1, a3, a2, CFSTR("FirmwareVersion"));
    sub_100021D30(a1, a3, a2, CFSTR("ProductionSOC"));
    sub_100021D30(a1, a3, a2, CFSTR("UniqueChipID"));
    sub_100021D30(a1, a3, a2, CFSTR("SupportedDeviceFamilies"));
    sub_100021D30(a1, a3, a2, CFSTR("DieID"));
    sub_100021D30(a1, a3, a2, CFSTR("DeviceColor"));
    sub_100021D30(a1, a3, a2, CFSTR("SoftwareBundleVersion"));
    sub_100021D30(a1, a3, a2, CFSTR("SDIOProductInfo"));
    sub_100021D30(a1, a3, a2, CFSTR("SDIOManufacturerTuple"));
    sub_100021D30(a1, a3, a2, CFSTR("InverseDeviceID"));
    sub_100021D30(a1, a3, a2, CFSTR("ProductType"));
    sub_100021D30(a1, a3, a2, CFSTR("DeviceClass"));
    sub_100021D30(a1, a3, a2, CFSTR("PartitionType"));
    sub_100021D30(a1, a3, a2, CFSTR("ProximitySensorCalibration"));
    sub_100021D30(a1, a3, a2, CFSTR("CompassCalibration"));
    sub_100021D30(a1, a3, a2, CFSTR("BasebandBoardSerialNumber"));
    sub_100021D30(a1, a3, a2, CFSTR("WirelessBoardSerialNumber"));
    sub_100021D30(a1, a3, a2, CFSTR("HardwarePlatform"));
    sub_100021D30(a1, a3, a2, CFSTR("TelephonyCapability"));
    sub_100021D30(a1, a3, a2, CFSTR("SoftwareBehavior"));
    if (!sub_10002935C())
    {
      CFDictionarySetValue(a3, CFSTR("BasebandStatus"), CFSTR("NoTelephonyCapabilty"));
      return;
    }
    sub_100021D30(a1, a3, a2, CFSTR("PhoneNumber"));
    sub_100021D30(a1, a3, a2, CFSTR("BasebandRegionSKU"));
    sub_100021D30(a1, a3, a2, CFSTR("BasebandVersion"));
    v18 = (const __CFDictionary *)MGCopyAnswer(CFSTR("BasebandPostponementStatusBlob"), 0);
    v19 = (const __CFDictionary *)MGCopyAnswer(CFSTR("BasebandSecurityInfoBlob"), 0);
    v20 = (const void *)MGCopyAnswer(CFSTR("BasebandPostponementStatus"), 0);
    if (sub_100010BA8(v20))
    {
      if (CFEqual(v20, CFSTR("kCTPostponementStatusNotReady")))
      {
        v21 = CFSTR("BBNotReady");
LABEL_31:
        CFDictionarySetValue(a3, CFSTR("BasebandStatus"), v21);
        v29 = 0;
        goto LABEL_32;
      }
      if (CFEqual(v20, CFSTR("kCTPostponementStatusReady")) || CFEqual(v20, CFSTR("kCTPostponementStatusActivated")))
      {
        if (v18)
        {
          v51[0] = _NSConcreteStackBlock;
          v51[1] = 3221225472;
          v51[2] = sub_100021D8C;
          v51[3] = &unk_10017AA58;
          v51[4] = a3;
          sub_1000258E8(v18, v51);
        }
        if (v19)
        {
          v50[0] = _NSConcreteStackBlock;
          v50[1] = 3221225472;
          v50[2] = sub_100021D94;
          v50[3] = &unk_10017AA58;
          v50[4] = a3;
          sub_1000258E8(v19, v50);
        }
        CFDictionaryRemoveValue(a3, CFSTR("kCTPostponementInfoUniqueID"));
        CFDictionaryRemoveValue(a3, CFSTR("ProposedTicket"));
        v21 = CFSTR("BBInfoAvailable");
        goto LABEL_31;
      }
      if (!CFEqual(v20, CFSTR("kCTPostponementStatusError")))
      {
        if (CFEqual(v20, CFSTR("kCTPostponementStatusRejected")))
        {
          sub_100021D30(a1, a3, a2, CFSTR("InternationalMobileEquipmentIdentity"));
          sub_100021D30(a1, a3, a2, CFSTR("MobileEquipmentIdentifier"));
          v21 = CFSTR("BBRejectedTicket");
        }
        else
        {
          v21 = CFSTR("Other-CheckLogs");
        }
        goto LABEL_31;
      }
      CFDictionarySetValue(a3, CFSTR("BasebandStatus"), CFSTR("BBError"));
      sub_10001A7E4(0, "special_case_get_domain", CFSTR("check for kCTPostponementStatusError* keys"), v40, v41, v42, v43, v44, v47);
    }
    else
    {
      CFDictionarySetValue(a3, CFSTR("BasebandStatus"), CFSTR("BBNotAnswering"));
    }
    v29 = 1;
LABEL_32:
    if (v20)
      CFRelease(v20);
    if (v18)
      CFRelease(v18);
    if (v19)
      CFRelease(v19);
    if ((v29 & 1) != 0)
      sub_10001A7E4(0, "special_case_get_domain", CFSTR("baseband error reported, no key hash available"), v24, v25, v26, v27, v28, v47);
    else
      sub_100021D30(a1, a3, a2, CFSTR("BasebandKeyHashInformation"));
    sub_100021D30(a1, a3, a2, CFSTR("MobileSubscriberNetworkCode"));
    sub_100021D30(a1, a3, a2, CFSTR("MobileSubscriberCountryCode"));
    if ((v29 & 1) != 0)
    {
      sub_10001A7E4(0, "special_case_get_domain", CFSTR("baseband error reported, no SIMTrayStatus available"), v30, v31, v32, v33, v34, v47);
      sub_10001A7E4(0, "special_case_get_domain", CFSTR("baseband error reported, no Carrier Bundle Info available"), v35, v36, v37, v38, v39, v48);
    }
    else
    {
      sub_100021D30(a1, a3, a2, CFSTR("SIMTrayStatus"));
      sub_100021D30(a1, a3, a2, CFSTR("CarrierBundleInfoArray"));
    }
    v23 = off_10017B2D0;
    goto LABEL_45;
  }
  if (!sub_100010BA8(a2))
    return;
  if (CFEqual(a2, CFSTR("com.apple.mobile.iTunes")))
  {
    v6 = MCCopyCheckpoint();
    if (v6)
    {
      v12 = (const __CFDictionary *)v6;
      if (sub_100010B40(a3))
      {
        v49[0] = _NSConcreteStackBlock;
        v49[1] = 3221225472;
        v49[2] = sub_100021D9C;
        v49[3] = &unk_10017AA58;
        v49[4] = a3;
        sub_1000258E8(v12, v49);
      }
      else
      {
        sub_10001A7E4(0, "special_case_get_domain", CFSTR("MobileCheckpoint returned nothing!"), v13, v14, v15, v16, v17, v47);
      }
      CFRelease(v12);
    }
    else
    {
      sub_10001A7E4(0, "special_case_get_domain", CFSTR("MobileCheckpoint returned nothing!"), v7, v8, v9, v10, v11, v47);
    }
    sub_100021D30(a1, a3, a2, CFSTR("FairPlayGUID"));
    v23 = off_10017B198;
LABEL_45:
    sub_100021D30(a1, a3, a2, *v23);
    return;
  }
  if (CFEqual(a2, CFSTR("com.apple.mobile.internal")))
  {
    sub_100021D30(a1, a3, a2, CFSTR("CarrierBuild"));
    sub_100021D30(a1, a3, a2, CFSTR("IsInternal"));
    v22 = off_10017B0A0;
LABEL_21:
    sub_100021D30(a1, a3, a2, *v22);
    return;
  }
  if (CFEqual(a2, CFSTR("com.apple.Accessibility")))
  {
    sub_100021D30(a1, a3, a2, CFSTR("VoiceOverTouchEnabledByiTunes"));
    sub_100021D30(a1, a3, a2, CFSTR("ZoomTouchEnabledByiTunes"));
    sub_100021D30(a1, a3, a2, CFSTR("InvertDisplayEnabledByiTunes"));
    sub_100021D30(a1, a3, a2, CFSTR("SpeakAutoCorrectionsEnabledByiTunes"));
    sub_100021D30(a1, a3, a2, CFSTR("MonoAudioEnabledByiTunes"));
    v22 = off_10017B830;
    goto LABEL_21;
  }
  if (CFEqual(a2, CFSTR("com.apple.international"))
    || CFEqual(a2, CFSTR("com.apple.mobile.wireless_lockdown"))
    || CFEqual(a2, CFSTR("com.apple.mobile.battery"))
    || CFEqual(a2, CFSTR("com.apple.mobile.software_behavior")))
  {
    sub_100011498((uint64_t)a2, (uint64_t)a3);
  }
  else if (CFEqual(a2, CFSTR("com.apple.mobile.backup")))
  {
    v45 = sub_10001B0C4(CFSTR("com.apple.mobile.ldbackup"));
    if (v45)
    {
      v46 = v45;
      CFDictionaryApplyFunction(v45, (CFDictionaryApplierFunction)sub_100021DA4, a3);
      CFRelease(v46);
    }
  }
}

void sub_100021D30(NSObject ***a1, __CFDictionary *a2, const __CFString *a3, const __CFString *a4)
{
  CFMutableDictionaryRef v6;
  CFMutableDictionaryRef v7;

  v6 = sub_100020104((uint64_t)a1, *a1, a3, a4);
  if (v6)
  {
    v7 = v6;
    CFDictionarySetValue(a2, a4, v6);
    CFRelease(v7);
  }
}

void sub_100021D8C(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

void sub_100021D94(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

void sub_100021D9C(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

void sub_100021DA4(void *key, void *value, CFMutableDictionaryRef theDict)
{
  CFDictionarySetValue(theDict, key, value);
}

uint64_t sub_100021DB8(NSObject ***a1, const __CFString *a2, const __CFString *a3, const __CFString *a4, const void *a5, CFTypeRef *a6, char a7)
{
  NSObject **v14;
  const void *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  const void *v22;
  const __CFString *v23;
  const __CFString *v24;
  CFStringRef v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  NSObject **v31;
  const void *v32;
  const void *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  NSObject **v38;
  const void *v39;
  const void *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  NSObject **v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  const __CFDictionary *v49;
  const void *v50;
  const void *v51;
  char v52;
  char v53;
  const void *v54;
  const __CFDictionary *v55;
  const void *v56;
  const void *v57;
  const __CFString *v58;
  CFStringRef v59;
  char v60;
  uint64_t v61;
  NSObject **v62;
  const void *v63;
  const void *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  NSObject **v69;
  const void *v70;

  if (sub_1000047F4((uint64_t)a1[3]) != 4)
  {
    if (a1[6])
    {
      v31 = *a1;
      v32 = sub_100010BA8(a2);
      v33 = sub_100010BA8(a3);
      if (!sub_10000F210(v31, (uint64_t)v32, (uint64_t)v33, 2, v34, v35, v36, v37))
        goto LABEL_37;
      v38 = *a1;
      v39 = sub_100010BA8(a2);
      v40 = sub_100010BA8(a3);
      v45 = v38;
      v46 = (uint64_t)v39;
      v47 = 3;
    }
    else
    {
      if (sub_1000047F4((uint64_t)a1[3]) == 3)
      {
        if ((a7 & 1) == 0)
        {
          v62 = *a1;
          v63 = sub_100010BA8(a2);
          v64 = sub_100010BA8(a3);
          if (!sub_10000F210(v62, (uint64_t)v63, (uint64_t)v64, 6, v65, v66, v67, v68))
          {
            v59 = 0;
            goto LABEL_42;
          }
        }
        goto LABEL_37;
      }
      v69 = *a1;
      v70 = sub_100010BA8(a2);
      v40 = sub_100010BA8(a3);
      v45 = v69;
      v46 = (uint64_t)v70;
      v47 = 0;
    }
    v61 = sub_10000F210(v45, v46, (uint64_t)v40, v47, v41, v42, v43, v44);
    v59 = 0;
LABEL_43:
    v60 = 1;
    goto LABEL_44;
  }
  v14 = *a1;
  v15 = sub_100010BA8(a2);
  v16 = sub_100010BA8(a3);
  if (sub_10000F210(v14, (uint64_t)v15, (uint64_t)v16, 4, v17, v18, v19, v20))
  {
    v21 = sub_100010BA8(a2);
    v22 = sub_100010BA8(a3);
    v23 = (const __CFString *)sub_100011198((uint64_t)v21, (uint64_t)v22, 1, 1);
    if (!sub_100010BA8(a4))
      a4 = CFSTR("unknown");
    if (!sub_100010BA8(v23))
      v23 = CFSTR("noKey");
    if (!a2)
      a2 = CFSTR("NULL");
    if (sub_100010BA8(a3))
      v24 = a3;
    else
      v24 = CFSTR("NULL");
    v25 = CFStringCreateWithFormat(0, 0, CFSTR("client %@ must use MGCopyAnswer(%@) instead of lockdown_copy_value(%@,%@)"), a4, v23, a2, v24);
    goto LABEL_31;
  }
  v48 = sub_100010BA8(a4);
  v49 = (const __CFDictionary *)sub_100010B40(a5);
  v50 = sub_100010BA8(a2);
  v51 = sub_100010BA8(a3);
  v52 = sub_1000265EC((uint64_t)a1, v48, v49, (uint64_t)v50, (uint64_t)v51, 3);
  v53 = v52;
  if (a2 || (v52 & 1) != 0 || !sub_100010BA8(a3) || !CFEqual(a3, CFSTR("ActivationState")))
  {
    if ((v53 & 1) == 0)
      goto LABEL_23;
LABEL_37:
    v59 = 0;
    v60 = 1;
    v61 = 1;
    goto LABEL_44;
  }
  v54 = sub_100010BA8(a4);
  v55 = (const __CFDictionary *)sub_100010B40(a5);
  v56 = sub_100010BA8(0);
  v57 = sub_100010BA8(a3);
  if ((sub_1000265EC((uint64_t)a1, v54, v55, (uint64_t)v56, (uint64_t)v57, 22) & 1) != 0)
    goto LABEL_37;
LABEL_23:
  if (!sub_100010BA8(a4))
    a4 = CFSTR("unknown");
  if (!a2)
    a2 = CFSTR("NULL");
  if (sub_100010BA8(a3))
    v58 = a3;
  else
    v58 = CFSTR("NULL");
  v25 = CFStringCreateWithFormat(0, 0, CFSTR("client %@'s entitlement plist must have a com.apple.private.lockdown.finegrained-get key whose value is an array containing the string %@/%@ (FATAL)"), a4, a2, v58);
LABEL_31:
  v59 = v25;
  if (!v25)
  {
LABEL_42:
    v61 = 0;
    goto LABEL_43;
  }
  if (a6)
  {
    v60 = 0;
    v61 = 0;
    *a6 = CFRetain(v25);
  }
  else
  {
    sub_10001A7E4(0, "connection_can_get_key", CFSTR("%@"), v26, v27, v28, v29, v30, (char)v25);
    v60 = 0;
    v61 = 0;
  }
LABEL_44:
  if (kCFBooleanFalse)
    CFRelease(kCFBooleanFalse);
  if ((v60 & 1) == 0)
    CFRelease(v59);
  return v61;
}

void sub_100022174(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  NSObject **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  void *v19;
  const void *v20;
  unint64_t v21;
  char v22;

  if (a1)
  {
    v9 = *(NSObject ***)a1;
    if (v9 && sub_10000F320(v9, a2, a3, a4, a5, a6, a7, a8))
      sub_10000E1DC(*(NSObject ***)a1, v10, v11, v12, v13, v14, v15, v16, v22);
    if (*(_QWORD *)(a1 + 48))
    {
      v17 = *(_QWORD *)(a1 + 24);
      if (v17 && sub_1000048D0(v17))
        sub_100004864(*(_QWORD *)(a1 + 24));
      CFRelease(*(CFTypeRef *)(a1 + 48));
      *(_QWORD *)(a1 + 48) = 0;
      v18 = *(const void **)(a1 + 40);
      if (v18)
      {
        CFRelease(v18);
        *(_QWORD *)(a1 + 40) = 0;
      }
    }
    v19 = *(void **)(a1 + 32);
    if (v19)
    {

      *(_QWORD *)(a1 + 32) = 0;
    }
    v20 = *(const void **)(a1 + 64);
    if (v20)
      CFRelease(v20);
    *(_QWORD *)(a1 + 64) = 0;
    v21 = *(_QWORD *)(a1 + 24);
    if (v21)
    {
      sub_100004790(v21);
      sub_100004760(*(void **)(a1 + 24));
      *(_QWORD *)(a1 + 24) = 0;
    }
  }
}

void sub_100022220(uint64_t a1, const __CFString *a2, const void *a3)
{
  NSObject ***v6;
  const __CFString *v7;
  const __CFString *v8;
  const void *v9;

  v6 = *(NSObject ****)(a1 + 32);
  v7 = *(const __CFString **)(a1 + 40);
  v8 = (const __CFString *)sub_100010BA8(*(const void **)(a1 + 48));
  v9 = sub_100010B40(*(const void **)(a1 + 56));
  if (sub_100021DB8(v6, v7, a2, v8, v9, 0, 0))
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 64), a2, a3);
}

void sub_1000222B0(uint64_t a1)
{
  sub_10001A308(*(NSObject ***)(a1 + 32), *(_DWORD *)(a1 + 40));
}

void *sub_1000222C0(const void *a1, const void *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void *Value;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void *v15;
  const void *v16;
  void *v17;
  const void *v18;
  id v19;
  CFDictionaryRef v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CFDictionaryRef v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  CFDictionaryRef v48;
  __CFDictionary *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  __CFDictionary *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  const __CFString *v63;
  char v64;
  int valuePtr;
  void *v66;
  void *v67;
  CFErrorRef outError;
  void *values;
  void *keys;

  values = 0;
  keys = 0;
  v67 = CFSTR("LOCKDOWN_MACH_SERVICE");
  outError = 0;
  v66 = CFSTR("JetsamMemoryLimit");
  valuePtr = -1;
  if (!sub_100010BA8(a1))
  {
    v63 = CFSTR("bad service string");
LABEL_45:
    sub_10001A7E4(0, "register_launchd_job", v63, v4, v5, v6, v7, v8, v64);
    goto LABEL_46;
  }
  if (!sub_100010B40(a2))
  {
    v63 = CFSTR("bad service info");
    goto LABEL_45;
  }
  Value = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ProgramArguments"));
  if (!Value)
  {
    sub_10001A7E4(0, "register_launchd_job", CFSTR("No ProgramArguments for %@"), v10, v11, v12, v13, v14, (char)a1);
LABEL_46:
    v55 = 0;
    v20 = 0;
    goto LABEL_22;
  }
  v15 = Value;
  v16 = CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("UserName"));
  v17 = (void *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("MaterializeDatalessFiles"));
  v18 = v17;
  if (v17)
  {
    v19 = sub_10001B298(v17);
    v20 = (CFDictionaryRef)objc_claimAutoreleasedReturnValue(v19);

    if (!v20)
    {
      sub_10001A7E4(0, "register_launchd_job", CFSTR("Invalid value for 'MaterializeDataLessFiles' for %@."), v21, v22, v23, v24, v25, (char)a1);
LABEL_21:
      v55 = 0;
LABEL_22:
      v42 = 0;
      goto LABEL_23;
    }
  }
  v26 = mach_absolute_time();
  keys = (void *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("lockdown.%llu.%@"), v26, a1);
  if (keys)
  {
    values = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
    if (values)
    {
      v20 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&kCFBooleanTrue, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (v20)
      {
        v42 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&v67, (const void **)&keys, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        if (v42)
        {
          v48 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&v66, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          if (v48)
          {
            v49 = sub_100025A4C();
            v55 = v49;
            if (v49)
            {
              CFDictionarySetValue(v49, CFSTR("Label"), keys);
              CFDictionarySetValue(v55, CFSTR("MachServices"), v20);
              CFDictionarySetValue(v55, CFSTR("EnvironmentVariables"), v42);
              CFDictionarySetValue(v55, CFSTR("POSIXSpawnType"), CFSTR("Interactive"));
              CFDictionarySetValue(v55, CFSTR("RunAtLoad"), kCFBooleanFalse);
              CFDictionarySetValue(v55, CFSTR("KeepAlive"), kCFBooleanFalse);
              CFDictionarySetValue(v55, CFSTR("LaunchOnlyOnce"), kCFBooleanTrue);
              CFDictionarySetValue(v55, CFSTR("ProgramArguments"), v15);
              if (v16)
                CFDictionarySetValue(v55, CFSTR("UserName"), v16);
              if (v18)
                CFDictionarySetValue(v55, CFSTR("MaterializeDatalessFiles"), v18);
              if (SMJobSubmit(kSMDomainSystemLaunchd, v55, 0, &outError))
              {
                v61 = keys;
                goto LABEL_27;
              }
              sub_10001A7E4(0, "register_launchd_job", CFSTR("SMJobSubmit failed for %@: %@"), v56, v57, v58, v59, v60, (char)a1);
            }
            else
            {
              sub_10001A7E4(0, "register_launchd_job", CFSTR("Couldn't create launchd plist for %@"), v50, v51, v52, v53, v54, (char)a1);
            }
          }
          else
          {
            sub_10001A7E4(0, "register_launchd_job", CFSTR("Couldn't create jetsam dict for %@"), v43, v44, v45, v46, v47, (char)a1);
            v55 = 0;
          }
          goto LABEL_24;
        }
        sub_10001A7E4(0, "register_launchd_job", CFSTR("Couldn't create env dict for %@"), v37, v38, v39, v40, v41, (char)a1);
        v55 = 0;
LABEL_23:
        v48 = 0;
LABEL_24:
        if (keys)
          CFRelease(keys);
        goto LABEL_26;
      }
      sub_10001A7E4(0, "register_launchd_job", CFSTR("Couldn't create mach dict for %@"), v32, v33, v34, v35, v36, (char)a1);
      goto LABEL_21;
    }
    v64 = (char)a1;
    v63 = CFSTR("Couldn't create memory limit for %@");
    goto LABEL_45;
  }
  sub_10001A7E4(0, "register_launchd_job", CFSTR("Couldn't create label for %@"), v27, v28, v29, v30, v31, (char)a1);
  v48 = 0;
  v42 = 0;
  v20 = 0;
  v55 = 0;
LABEL_26:
  v61 = 0;
LABEL_27:
  keys = 0;
  if (values)
    CFRelease(values);
  values = 0;
  if (v20)
    CFRelease(v20);
  if (v55)
    CFRelease(v55);
  if (v42)
    CFRelease(v42);
  if (v48)
    CFRelease(v48);
  if (outError)
    CFRelease(outError);
  return v61;
}

uint64_t sub_100022730(uint64_t a1, const __CFString *a2, int a3, const void *a4, int a5, int a6, void *a7, _QWORD *a8)
{
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  xpc_object_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  xpc_object_t v30;
  int64_t value;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFString *v37;
  _xpc_connection_s *mach_service;
  NSObject *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  NSObject *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  CFTypeRef v52;
  void *v53;
  _xpc_connection_s *v54;
  __CFDictionary *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  dispatch_time_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  const __CFString *v70;
  char v71;
  xpc_object_t xdate;
  id v74;
  _QWORD v75[7];
  _QWORD handler[4];
  _xpc_connection_s *v77;
  id v78;
  uint64_t *v79;
  _QWORD *v80;
  uint64_t *v81;
  _QWORD v82[3];
  char v83;
  uint64_t v84;
  uint64_t *v85;
  uint64_t v86;
  uint64_t (*v87)(uint64_t, uint64_t);
  void (*v88)(uint64_t);
  id v89;
  uint64_t v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t *v95;
  uint64_t v96;
  int v97;
  char buffer[1024];
  void **block;
  uint64_t v100;
  void (*v101)(uint64_t);
  void *v102;
  uint64_t *v103;

  v74 = a7;
  v90 = 0;
  v91 = &v90;
  v92 = 0x2020000000;
  v93 = 0;
  v84 = 0;
  v85 = &v84;
  v86 = 0x3032000000;
  v87 = sub_100022D3C;
  v88 = sub_100022D4C;
  v89 = 0;
  v82[0] = 0;
  v82[1] = v82;
  v82[2] = 0x2020000000;
  v83 = 0;
  if (!*(_QWORD *)(a1 + 24))
  {
    v37 = CFSTR("Invalid input.");
LABEL_11:
    sub_10001A7E4(0, "spawn_xpc_service", v37, v14, v15, v16, v17, v18, v71);
LABEL_12:
    v24 = 0;
LABEL_13:
    mach_service = 0;
    v30 = 0;
    xdate = 0;
    v39 = 0;
    v40 = -1;
LABEL_33:
    *a8 = CFSTR("InvalidService");
    v68 = 0xFFFFFFFFLL;
    goto LABEL_34;
  }
  if (!sub_100010BA8(a2))
  {
    v37 = CFSTR("bad xpc name string");
    goto LABEL_11;
  }
  if (!CFStringGetCString(a2, buffer, 1024, 0x8000100u))
  {
    v70 = CFSTR("Couldn't convert %@ to string");
LABEL_40:
    sub_10001A7E4(0, "spawn_xpc_service", v70, v19, v20, v21, v22, v23, (char)a2);
    goto LABEL_12;
  }
  v24 = xpc_dictionary_create(0, 0, 0);
  if (!v24)
  {
    v70 = CFSTR("Couldn't create xpc message for %@");
    goto LABEL_40;
  }
  v30 = sub_10001105C(a4);
  if (!v30)
  {
    sub_10001A7E4(0, "spawn_xpc_service", CFSTR("Couldn't convert checkin info to xpc"), v25, v26, v27, v28, v29, v71);
    goto LABEL_13;
  }
  xdate = xpc_date_create_from_current();
  value = xpc_date_get_value(xdate);
  xpc_dictionary_set_string(v24, "_LDCHECKININFO", "xpc");
  xpc_dictionary_set_date(v24, "_LDTIMESTAMP", value);
  xpc_dictionary_set_value(v24, "_LDCHECKINDICT", v30);
  xpc_dictionary_set_fd(v24, "_LDSERVICESOCK", a3);
  v94 = 0;
  v95 = &v94;
  v96 = 0x2020000000;
  v97 = -1;
  if (qword_1001A8090 != -1)
    dispatch_once(&qword_1001A8090, &stru_10017AAE8);
  if (qword_1001A8088)
  {
    block = _NSConcreteStackBlock;
    v100 = 3221225472;
    v101 = sub_100022FC4;
    v102 = &unk_10017A178;
    v103 = &v94;
    dispatch_sync((dispatch_queue_t)qword_1001A8088, &block);
  }
  else
  {
    sub_10001A7E4(0, "open_service_log_fd", CFSTR("Failed to create queue."), v32, v33, v34, v35, v36, v71);
  }
  v40 = *((_DWORD *)v95 + 6);
  _Block_object_dispose(&v94, 8);
  if (v40 != -1)
    xpc_dictionary_set_fd(v24, "_LDSERVICELOGSOCK", v40);
  if (a5)
    xpc_dictionary_set_BOOL(v24, "_LDSHUTDOWNLISTENER", 1);
  mach_service = xpc_connection_create_mach_service(buffer, 0, 0);
  if (!mach_service)
  {
    sub_10001A7E4(0, "spawn_xpc_service", CFSTR("Couldn't create xpc connection for %@"), v41, v42, v43, v44, v45, (char)a2);
    mach_service = 0;
LABEL_44:
    v39 = 0;
    goto LABEL_33;
  }
  v46 = dispatch_queue_create("com.apple.mobile.lockdown.checkin_queue", 0);
  if (!v46)
  {
    sub_10001A7E4(0, "spawn_xpc_service", CFSTR("Couldn't create checkin queue."), v47, v48, v49, v50, v51, v71);
    goto LABEL_44;
  }
  v39 = v46;
  xpc_connection_set_target_queue(mach_service, v46);
  if (v74)
    xpc_dictionary_set_BOOL(v24, "_LDKEEPCONNALIVE", 1);
  if (a6)
  {
    block = 0;
    v100 = 0;
    uuid_generate((unsigned __int8 *)&block);
    xpc_connection_set_oneshot_instance(mach_service, &block);
  }
  v52 = CFRetain(a2);
  v53 = (void *)v85[5];
  v85[5] = (uint64_t)v52;

  v54 = mach_service;
  v91[3] = (uint64_t)v54;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_100022D54;
  handler[3] = &unk_10017AAA0;
  v79 = &v84;
  v80 = v82;
  v78 = v74;
  v81 = &v90;
  mach_service = v54;
  v77 = mach_service;
  xpc_connection_set_event_handler(mach_service, handler);

  if (!*(_QWORD *)(a1 + 32))
    goto LABEL_28;
  v55 = sub_1000042FC(CFSTR("StartService"));
  if (!v55)
  {
    sub_10001A7E4(0, "spawn_xpc_service", CFSTR("Failed to create response."), v57, v58, v59, v60, v61, v71);
    goto LABEL_33;
  }
  sub_1000041C0(*(const __CFData **)(a1 + 24), v55, v56, v57, v58, v59, v60, v61, v71);
LABEL_28:
  xpc_connection_resume(mach_service);
  xpc_connection_send_message(mach_service, v24);
  v62 = dispatch_time(0, 60000000000);
  v75[0] = _NSConcreteStackBlock;
  v75[1] = 3221225472;
  v75[2] = sub_100022F38;
  v75[3] = &unk_10017AAC8;
  v75[4] = &v90;
  v75[5] = v82;
  v75[6] = &v84;
  dispatch_after(v62, v39, v75);
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "spawn_xpc_service", CFSTR("service %@ started"), v63, v64, v65, v66, v67, (char)a2);
  v68 = 0;
LABEL_34:
  if (v40 != -1)
    close(v40);
  _Block_object_dispose(v82, 8);
  _Block_object_dispose(&v84, 8);

  _Block_object_dispose(&v90, 8);
  return v68;
}

void sub_100022CEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,char a40,uint64_t a41,uint64_t a42,uint64_t a43,char a44)
{
  _Block_object_dispose(&a44, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose(&a40, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100022D3C(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100022D4C(uint64_t a1)
{

}

void sub_100022D54(uint64_t a1, void *a2)
{
  xpc_type_t type;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  uint64_t v15;
  xpc_object_t xdict;

  xdict = a2;
  type = xpc_get_type(xdict);
  if (type != (xpc_type_t)&_xpc_type_error)
  {
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      if (xpc_dictionary_get_BOOL(xdict, "ACK"))
      {
        if (dword_1001A6AD0)
          sub_10001A7E4(0, "spawn_xpc_service_block_invoke", CFSTR("Received checkin acknowledgement from '%@'"), v9, v10, v11, v12, v13, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
        *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24) = 1;
        xpc_connection_cancel(*(xpc_connection_t *)(a1 + 32));
      }
      else
      {
        sub_10001A7E4(0, "spawn_xpc_service_block_invoke", CFSTR("Received invalid checkin acknowledgment from '%@'"), v9, v10, v11, v12, v13, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
      }
    }
    goto LABEL_23;
  }
  if (xdict == &_xpc_error_connection_invalid)
  {
    if (!dword_1001A6AD0)
      goto LABEL_19;
    v14 = CFSTR("XPC_ERROR_CONNECTION_INVALID %@");
  }
  else if (xdict == &_xpc_error_connection_interrupted)
  {
    if (dword_1001A6AD0)
      sub_10001A7E4(0, "spawn_xpc_service_block_invoke", CFSTR("XPC_ERROR_CONNECTION_INTERRUPTED %@"), v4, v5, v6, v7, v8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
    if (*(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 56) + 8) + 24))
      goto LABEL_19;
    v14 = CFSTR("Service %@ did not acknowledge checkin before connection was closed.");
  }
  else
  {
    if (!dword_1001A6AD0)
      goto LABEL_19;
    v14 = CFSTR("Non specific XPC error %@");
  }
  sub_10001A7E4(0, "spawn_xpc_service_block_invoke", v14, v4, v5, v6, v7, v8, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 40));
LABEL_19:
  v15 = *(_QWORD *)(a1 + 40);
  if (v15 && *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24))
    (*(void (**)(void))(v15 + 16))();

  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 64) + 8) + 24) = 0;
LABEL_23:

}

void sub_100022F38(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24))
  {
    if (!*(_BYTE *)(*(_QWORD *)(a1[5] + 8) + 24))
      sub_10001A7E4(0, "spawn_xpc_service_block_invoke_2", CFSTR("Service %@ has taken longer than one minute to acknowledge checkin."), a4, a5, a6, a7, a8, *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 40));
  }
}

void sub_100022F98(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.mobile.lockdownd.log", 0);
  v2 = (void *)qword_1001A8088;
  qword_1001A8088 = (uint64_t)v1;

}

void sub_100022FC4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  stat v11;

  memset(&v11, 0, sizeof(v11));
  if (!lstat("/private/var/logs/lockdown_service.log", &v11))
    sub_10001A730((const std::__fs::filesystem::path *)"/private/var/logs/lockdown_service.log", v11.st_size);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = sub_10002639C("/private/var/logs/lockdown_service.log", 521, 0x1A4u, 0x8000, v2, v3, v4, v5);
  if (!*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    sub_10001A7E4(0, "open_service_log_fd_block_invoke_2", CFSTR("Failed to create %s."), v6, v7, v8, v9, v10, (char)"/private/var/logs/lockdown_service.log");
}

uint64_t sub_100023078(uint64_t a1, const char *a2, void *a3, char a4, void *a5)
{
  id v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  BOOL v17;
  BOOL v18;
  uint64_t v19;
  char v21;
  _QWORD handler[4];
  id v23;
  id v24;
  const char *v25;
  uint64_t v26;
  char v27;

  v9 = a3;
  v10 = a5;
  v16 = v10;
  if (a1)
    v17 = a2 == 0;
  else
    v17 = 1;
  v18 = v17 || v10 == 0;
  v19 = !v18;
  if (v18)
  {
    sub_10001A7E4(0, "register_lockdown_xpc_activity", CFSTR("Invalid argument(s)."), v11, v12, v13, v14, v15, v21);
  }
  else
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_100023180;
    handler[3] = &unk_10017AB10;
    v25 = a2;
    v23 = v9;
    v27 = a4;
    v24 = v16;
    v26 = a1;
    xpc_activity_register(a2, XPC_ACTIVITY_CHECK_IN, handler);

  }
  return v19;
}

void sub_100023180(uint64_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  xpc_activity_state_t state;
  _xpc_activity_s *v9;
  xpc_object_t v10;
  void *v11;
  void *v12;
  _xpc_activity_s *activity;

  activity = a2;
  if (xpc_activity_get_state(activity) == 2 && xpc_activity_should_defer(activity))
  {
    if (xpc_activity_set_state(activity, 3))
      goto LABEL_13;
    sub_10001A7E4(0, "register_lockdown_xpc_activity_block_invoke", CFSTR("Failed to defer activity '%s'."), v3, v4, v5, v6, v7, *(_QWORD *)(a1 + 48));
  }
  state = xpc_activity_get_state(activity);
  v9 = activity;
  if (!state)
  {
    v10 = xpc_activity_copy_criteria(activity);
    v11 = v10;
    v12 = *(void **)(a1 + 32);
    if (v12 && (!v10 || *(_BYTE *)(a1 + 64)))
      xpc_activity_set_criteria(activity, v12);

    v9 = activity;
  }
  if (xpc_activity_get_state(v9) == 2)
    (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
LABEL_13:

}

CFMutableDictionaryRef sub_100023258(NSObject **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFMutableDictionaryRef result;
  time_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  result = sub_10000F4E0((uint64_t)a1, 0, CFSTR("FirstPurpleBuddyCompletion"), a4, a5, a6, a7, a8);
  if (!result)
  {
    v10 = time(0);
    sub_10000EAAC((uint64_t)a1, 0, (uint64_t)CFSTR("FirstPurpleBuddyCompletion"), v10);
    sub_10000E1DC(a1, v11, v12, v13, v14, v15, v16, v17, v22);
    return (CFMutableDictionaryRef)sub_10000E484((uint64_t)a1, 0, (uint64_t)CFSTR("ActivationStateAcknowledged"), (uint64_t)kCFBooleanTrue, v18, v19, v20, v21);
  }
  return result;
}

id sub_1000232DC()
{
  id v0;
  void *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  void *v8;
  void *v9;
  const __CFString *v10;
  id v11;
  char v13;
  _QWORD v14[5];
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t, uint64_t);
  void (*v19)(uint64_t);
  id v20;

  v15 = 0;
  v16 = &v15;
  v17 = 0x3032000000;
  v18 = sub_100023418;
  v19 = sub_100023428;
  v20 = 0;
  v0 = sub_100023430();
  v1 = (void *)objc_claimAutoreleasedReturnValue(v0);
  v7 = v1;
  if (!v1)
  {
    v10 = CFSTR("Failed to create XPC connection.");
LABEL_6:
    sub_10001A7E4(0, "copySecuritydAEToken", v10, v2, v3, v4, v5, v6, v13);
    v9 = 0;
    goto LABEL_7;
  }
  objc_msgSend(v1, "resume");
  v8 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v7, "synchronousRemoteObjectProxyWithErrorHandler:", &stru_10017AB50));
  v9 = v8;
  if (!v8)
  {
    v10 = CFSTR("Failed to create remote object proxy.");
    goto LABEL_6;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_100023518;
  v14[3] = &unk_10017AB78;
  v14[4] = &v15;
  objc_msgSend(v8, "getLockdownToken:", v14);
LABEL_7:
  v11 = (id)v16[5];
  _Block_object_dispose(&v15, 8);

  return v11;
}

void sub_100023400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100023418(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100023428(uint64_t a1)
{

}

id sub_100023430()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  char v14;

  v5 = objc_msgSend(objc_alloc((Class)NSXPCConnection), "initWithMachServiceName:options:", CFSTR("com.apple.security.tribeca"), 4096);
  if (v5)
  {
    v6 = objc_claimAutoreleasedReturnValue(+[NSXPCInterface interfaceWithProtocol:](NSXPCInterface, "interfaceWithProtocol:", &OBJC_PROTOCOL___TribecaXPCProtocol));
    if (v6)
    {
      v12 = (void *)v6;
      objc_msgSend(v5, "setRemoteObjectInterface:", v6);

    }
    else
    {
      sub_10001A7E4(0, "createSecuritydXPCConnection", CFSTR("Failed to create service interface."), v7, v8, v9, v10, v11, v14);
    }
  }
  else
  {
    sub_10001A7E4(0, "createSecuritydXPCConnection", CFSTR("Failed to create connection to '%@'"), v0, v1, v2, v3, v4, (char)CFSTR("com.apple.security.tribeca"));
  }
  return v5;
}

void sub_1000234DC(id a1, NSError *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2)
    sub_10001A7E4(0, "copySecuritydAEToken_block_invoke", CFSTR("Error during XPC communication: %@"), v2, v3, v4, v5, v6, (char)a2);
}

void sub_100023518(uint64_t a1, void *a2)
{
  void *v3;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  unsigned __int8 v12;
  void *v13;
  void *v14;
  id v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  id v24;
  id v25;

  v25 = a2;
  v3 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("status")));
  v4 = sub_10001B244(v3);
  v5 = objc_claimAutoreleasedReturnValue(v4);
  if (v5
    && (v11 = (void *)v5,
        v12 = objc_msgSend(v3, "isEqual:", CFSTR("ok")),
        v11,
        (v12 & 1) != 0))
  {
    v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v25, "objectForKeyedSubscript:", CFSTR("aetoken")));
    v14 = v13;
    if (v13
      && (v15 = sub_10001B244(v13), v16 = (void *)objc_claimAutoreleasedReturnValue(v15), v16, !v16))
    {
      sub_10001A7E4(0, "copySecuritydAEToken_block_invoke_2", CFSTR("Invalid AEToken with value '%@'"), v17, v18, v19, v20, v21, (char)v14);

    }
    else
    {
      v22 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v23 = *(void **)(v22 + 40);
      *(_QWORD *)(v22 + 40) = v14;
      v24 = v14;

    }
  }
  else
  {
    sub_10001A7E4(0, "copySecuritydAEToken_block_invoke_2", CFSTR("Failed to get AEToken with status '%@'"), v6, v7, v8, v9, v10, (char)v3);
  }

}

BOOL sub_10002362C(void *a1)
{
  id v1;
  id v2;
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v16;
  const __CFString *v17;
  _BOOL8 v18;
  _QWORD v20[5];
  uint64_t v21;
  uint64_t *v22;
  uint64_t v23;
  char v24;
  const __CFString *v25;
  id v26;

  v1 = a1;
  v21 = 0;
  v22 = &v21;
  v23 = 0x2020000000;
  v24 = 0;
  v2 = sub_100023430();
  v3 = (void *)objc_claimAutoreleasedReturnValue(v2);
  v9 = v3;
  if (!v3)
  {
    v17 = CFSTR("Failed to create XPC connection.");
LABEL_7:
    sub_10001A7E4(0, "setSecuritydAEToken", v17, v4, v5, v6, v7, v8, v20[0]);
    v16 = 0;
    v10 = 0;
    goto LABEL_8;
  }
  objc_msgSend(v3, "resume");
  v10 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v9, "synchronousRemoteObjectProxyWithErrorHandler:", &stru_10017AB98));
  if (!v10)
  {
    v17 = CFSTR("Failed to create remote object proxy.");
    goto LABEL_7;
  }
  v25 = CFSTR("aetoken");
  v26 = v1;
  v16 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v26, &v25, 1));
  if (v16)
  {
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    v20[2] = sub_100023830;
    v20[3] = &unk_10017AB78;
    v20[4] = &v21;
    objc_msgSend(v10, "setLockdownToken::", v16, v20);
  }
  else
  {
    sub_10001A7E4(0, "setSecuritydAEToken", CFSTR("Failed to create request."), v11, v12, v13, v14, v15, v20[0]);
    v16 = 0;
  }
LABEL_8:
  v18 = *((_BYTE *)v22 + 24) != 0;

  _Block_object_dispose(&v21, 8);
  return v18;
}

void sub_1000237D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_list va;

  va_start(va, a6);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000237F4(id a1, NSError *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (a2)
    sub_10001A7E4(0, "setSecuritydAEToken_block_invoke", CFSTR("Error during XPC communication: %@"), v2, v3, v4, v5, v6, (char)a2);
}

void sub_100023830(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  unsigned __int8 v11;
  id v12;

  v12 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(a2, "objectForKeyedSubscript:", CFSTR("status")));
  v3 = sub_10001B244(v12);
  v4 = objc_claimAutoreleasedReturnValue(v3);
  if (v4
    && (v10 = (void *)v4,
        v11 = objc_msgSend(v12, "isEqual:", CFSTR("ok")),
        v10,
        (v11 & 1) != 0))
  {
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  else
  {
    sub_10001A7E4(0, "setSecuritydAEToken_block_invoke_2", CFSTR("Failed to set AEToken with status '%@'"), v5, v6, v7, v8, v9, (char)v12);
  }

}

uint64_t sub_1000238D8(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uintptr_t v15;
  id v16;
  NSObject *v17;
  dispatch_source_t v18;
  NSObject *v19;
  id v20;
  uint64_t v21;
  __CFString *v22;
  uint64_t v23;
  id v24;
  uint64_t v26;
  _QWORD v27[5];
  _QWORD handler[5];
  int v29;

  v10 = sub_10001095C("MyUnixSocket", (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if (v10 == -1)
  {
    v22 = CFSTR("Failed to checkin with launchd and setup communication port.");
    v23 = 171;
  }
  else
  {
    v14 = v10;
    v15 = v10;
    v16 = sub_100023A48();
    v17 = objc_claimAutoreleasedReturnValue(v16);
    v18 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v15, 0, v17);

    if (v18)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_100023A88;
      handler[3] = &unk_10017A970;
      v29 = v14;
      handler[4] = a1;
      v19 = v18;
      dispatch_source_set_event_handler(v19, handler);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_100023EE4;
      v27[3] = &unk_100179E10;
      v27[4] = v19;
      dispatch_source_set_cancel_handler(v19, v27);
      dispatch_resume(v19);

      v20 = 0;
      v21 = 1;
      goto LABEL_9;
    }
    v22 = CFSTR("Failed to create dispatch source.");
    v23 = 177;
  }
  v24 = sub_100010520((uint64_t)"local_worker", v23, -1, 0, v22, v11, v12, v13, v26);
  v20 = (id)objc_claimAutoreleasedReturnValue(v24);
  if (a2)
  {
    v20 = v20;
    v21 = 0;
    *a2 = v20;
  }
  else
  {
    v21 = 0;
  }
LABEL_9:

  return v21;
}

id sub_100023A48()
{
  if (qword_1001A80A0 != -1)
    dispatch_once(&qword_1001A80A0, &stru_10017ABF8);
  return (id)qword_1001A8098;
}

void sub_100023A88(uint64_t a1)
{
  sub_100023A98(*(_DWORD *)(a1 + 40), *(uint64_t **)(a1 + 32));
}

void sub_100023A98(int a1, uint64_t *a2)
{
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int sa_family;
  int v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  socklen_t v29;
  const __CFString *v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  void *v45;
  uint64_t v46;
  void *v47;
  dispatch_queue_global_t global_queue;
  NSObject *v49;
  char v50;
  _QWORD block[7];
  int v52;
  socklen_t v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  const char *v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t (*v66)(uint64_t, uint64_t);
  void (*v67)(uint64_t);
  id v68;
  socklen_t v69;
  socklen_t v70;
  sockaddr v71[8];

  v63 = 0;
  v64 = &v63;
  v65 = 0x3032000000;
  v66 = sub_100024E98;
  v67 = sub_100024EA8;
  v68 = 0;
  v54 = 0;
  v55 = &v54;
  v56 = 0x6810000000;
  v57 = "";
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  v61 = 0u;
  v62 = 0;
  memset(v71, 0, sizeof(v71));
  v52 = -1;
  v53 = 128;
  v3 = accept(a1, v71, &v53);
  v4 = v3;
  if (v3 == -1)
  {
    v21 = *__error();
    v22 = __error();
    strerror(*v22);
    sub_10001A7E4(0, "socket_accept_callback", CFSTR("Failed to accept the connection: %d (%s)"), v23, v24, v25, v26, v27, v21);
  }
  else
  {
    if (!sub_100010C44(v3) || !sub_100010CBC(v4))
      goto LABEL_35;
    sa_family = v71[0].sa_family;
    if (v71[0].sa_family == 1)
    {
      v70 = 4;
      if (getsockopt(v4, 0, 2, &v52, &v70))
      {
        v11 = *__error();
        v12 = __error();
        strerror(*v12);
        sub_10001A7E4(0, "socket_accept_callback", CFSTR("getsockopt failed: %d (%s)"), v13, v14, v15, v16, v17, v11);
        v52 = -1;
      }
      v18 = 0;
      v19 = v71[0].sa_family;
      v20 = 4;
    }
    else if (v71[0].sa_family == 2 && *(_DWORD *)&v71[0].sa_data[2] == 16777343
           || (v20 = 0,
               (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*(int32x4_t *)&v71[0].sa_data[6], (int32x4_t)xmmword_1001518C0)))) & 1) == 0)&& v71[0].sa_family == 30)
    {
      v20 = 0;
      v18 = 1;
      v19 = v71[0].sa_family;
    }
    else
    {
      v19 = v71[0].sa_family;
      v18 = 0;
    }
    if (v19 == 30 || v19 == 2)
    {
      if (v18)
      {
        v69 = 4;
        v70 = -1;
        v28 = getsockopt(v4, 6, 516, &v70, &v69);
        v29 = v70;
        if (v28)
          v29 = -1;
        if (v29)
        {
          sub_10001A7E4(0, "peer_is_safe", CFSTR("non kernel peer, pid %d!\n"), v5, v6, v7, v8, v9, v29);
          v30 = CFSTR("Peer is unsafe.");
LABEL_34:
          sub_10001A7E4(0, "socket_accept_callback", v30, v5, v6, v7, v8, v9, v50);
LABEL_35:
          close(v4);
          goto LABEL_36;
        }
        v20 = 1;
      }
      else
      {
        v20 = 3;
      }
    }
    else if (sa_family != 1)
    {
      v30 = CFSTR("Unknown connection type.");
      goto LABEL_34;
    }
    v31 = sub_10000F404(*a2, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiConnections"), v5, v6, v7, v8, v9);
    v37 = sub_10000F404(*a2, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiDebugging"), v32, v33, v34, v35, v36);
    v43 = sub_10000F404(*a2, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiPairing"), v38, v39, v40, v41, v42);
    if (v20 == 3 && !v37 && !v31 && !v43)
    {
      v30 = CFSTR("Killing the WiFi connection immediately.");
      goto LABEL_34;
    }
    v44 = v55;
    *((_OWORD *)v55 + 2) = *(_OWORD *)a2;
    *((_DWORD *)v44 + 12) = v20;
    *((_DWORD *)v44 + 22) = v52;
    v45 = sub_100004744();
    v55[7] = (uint64_t)v45;
    if (!v45)
    {
      v30 = CFSTR("Could not create lockconn");
      goto LABEL_34;
    }
    sub_10000476C((uint64_t)v45, v4, v20);
    v46 = os_transaction_create("com.apple.mobile.lockdownd");
    v47 = (void *)v64[5];
    v64[5] = v46;

    global_queue = dispatch_get_global_queue(0, 0);
    v49 = objc_claimAutoreleasedReturnValue(global_queue);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100024EB0;
    block[3] = &unk_10017AC20;
    block[4] = &v54;
    block[5] = &v63;
    block[6] = a2;
    dispatch_async(v49, block);

  }
LABEL_36:
  _Block_object_dispose(&v54, 8);
  _Block_object_dispose(&v63, 8);

}

void sub_100023EB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a32, 8);
  _Unwind_Resume(a1);
}

void sub_100023EE4(uint64_t a1)
{

}

uint64_t sub_100023EEC(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  BOOL v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  id v32;
  uint64_t v33;
  __CFString *v34;
  uint64_t v35;
  id v36;
  id v37;
  uint64_t v38;
  uint64_t v40;
  id v41;

  *(_QWORD *)(a1 + 8) = sub_100012BF8(*(NSObject ***)a1, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
  if ((sub_100024034(a1, 0, v10, v11, v12, v13, v14, v15) & 1) == 0)
  {
    v34 = CFSTR("Failed to enable ipv4 socket/listener.");
    v35 = 279;
    goto LABEL_9;
  }
  if ((sub_100024034(a1, 1, v16, v17, v18, v19, v20, v21) & 1) == 0)
  {
    v34 = CFSTR("Failed to enable ipv6 socket/listener.");
    v35 = 284;
    goto LABEL_9;
  }
  if ((sub_10000706C(*(_QWORD *)a1, a1, v22, v23, v24, v19, v20, v21) & 1) == 0)
  {
    v34 = CFSTR("Failed to notify configd to enable USB.");
    v35 = 290;
LABEL_9:
    v36 = sub_100010520((uint64_t)"remote_worker", v35, -1, 0, v34, v19, v20, v21, v40);
    v32 = (id)objc_claimAutoreleasedReturnValue(v36);
    if (!a2)
    {
LABEL_12:
      v33 = 0;
      goto LABEL_13;
    }
LABEL_10:
    v32 = v32;
    v33 = 0;
    *a2 = v32;
    goto LABEL_13;
  }
  v41 = 0;
  v28 = sub_10002A0C0(a1, &v41, v25, v26, v27, v19, v20, v21);
  v32 = v41;
  if (!v28)
  {
    v37 = sub_100010520((uint64_t)"remote_worker", 295, -1, v32, CFSTR("Failed to set up remote services."), v29, v30, v31, v40);
    v38 = objc_claimAutoreleasedReturnValue(v37);

    v32 = (id)v38;
    if (!a2)
      goto LABEL_12;
    goto LABEL_10;
  }
  v33 = 1;
LABEL_13:

  return v33;
}

uint64_t sub_100024034(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const __CFString *v38;
  id v39;
  NSObject *v40;
  dispatch_source_t v41;
  NSObject *v42;
  char v44;
  _QWORD v45[5];
  _QWORD handler[5];
  int v47;
  int v48;
  unsigned int v49;
  int v50;

  v8 = a2;
  v49 = 62078;
  v50 = 1;
  if ((_DWORD)a2)
    v10 = "MyIPv6Socket";
  else
    v10 = "MyIPv4Socket";
  v17 = sub_10001095C(v10, a2, a3, a4, a5, a6, a7, a8);
  if (v17 == -1)
  {
    v18 = v8 ? 30 : 2;
    v17 = sub_100005C0C(&v49, v18, v11, v12, v13, v14, v15, v16);
    if (v17 == -1)
    {
      v38 = CFSTR("Failed to create server socket.");
      goto LABEL_17;
    }
  }
  if (!setsockopt(v17, 0xFFFF, 4354, &v50, 4u))
  {
    v48 = 4;
    if (setsockopt(v17, 0xFFFF, 4225, &v48, 4u))
    {
      v31 = *__error();
      v32 = __error();
      strerror(*v32);
      sub_10001A7E4(0, "ipWorker", CFSTR("Failed to set socket options (SO_RESTRICTIONS): %d (%s)"), v33, v34, v35, v36, v37, v31);
      return 0;
    }
    sub_100010CBC(v17);
    v39 = sub_100023A48();
    v40 = objc_claimAutoreleasedReturnValue(v39);
    v41 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v17, 0, v40);

    if (v41)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_100024E80;
      handler[3] = &unk_10017A970;
      v47 = v17;
      handler[4] = a1;
      v42 = v41;
      dispatch_source_set_event_handler(v42, handler);
      v45[0] = _NSConcreteStackBlock;
      v45[1] = 3221225472;
      v45[2] = sub_100024E90;
      v45[3] = &unk_100179E10;
      v45[4] = v42;
      dispatch_source_set_cancel_handler(v42, v45);
      dispatch_resume(v42);

      return 1;
    }
    v38 = CFSTR("Failed to create dispatch source.");
LABEL_17:
    sub_10001A7E4(0, "ipWorker", v38, v19, v20, v21, v22, v23, v44);
    return 0;
  }
  v24 = *__error();
  v25 = __error();
  strerror(*v25);
  sub_10001A7E4(0, "ipWorker", CFSTR("Failed to set socket options (SO_OPPORTUNISTIC): %d (%s)"), v26, v27, v28, v29, v30, v24);
  return 0;
}

uint64_t sub_10002424C(_QWORD *a1)
{
  kern_return_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  IONotificationPort *v13;
  __CFRunLoop *Current;
  __CFRunLoopSource *RunLoopSource;
  CFMutableDictionaryRef v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFDictionary *v22;
  __CFDictionary *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __CFDictionary *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __CFNotificationCenter *DistributedCenter;
  __CFNotificationCenter *v36;
  __CFNotificationCenter *v37;
  __CFNotificationCenter *DarwinNotifyCenter;
  __CFNotificationCenter *v39;
  __CFNotificationCenter *v40;
  __CFNotificationCenter *v41;
  __CFNotificationCenter *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  __CFNotificationCenter *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  char v59;
  unsigned int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  const __CFString *v65;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char v72;
  _QWORD v73[5];
  _QWORD v74[5];
  mach_port_t mainPort;

  mainPort = 0;
  v2 = IOMasterPort(0, &mainPort);
  if (v2 || !mainPort)
  {
    v72 = v2;
    v65 = CFSTR("Failed to create IOKit master port: 0x%08x");
LABEL_18:
    LODWORD(v16) = 0;
LABEL_19:
    sub_10001A7E4((int)v16, "notification_worker", v65, v3, v4, v5, v6, v7, v72);
    v22 = 0;
LABEL_20:
    v29 = 0;
LABEL_21:
    v13 = 0;
LABEL_22:
    v64 = 0;
    goto LABEL_23;
  }
  v13 = IONotificationPortCreate(mainPort);
  if (!v13)
  {
    sub_10001A7E4(0, "notification_worker", CFSTR("Failed to create IOKit notification port: 0x%08x"), v8, v9, v10, v11, v12, 0);
    v22 = 0;
    v29 = 0;
    goto LABEL_22;
  }
  Current = CFRunLoopGetCurrent();
  RunLoopSource = IONotificationPortGetRunLoopSource(v13);
  CFRunLoopAddSource(Current, RunLoopSource, kCFRunLoopDefaultMode);
  v16 = IOServiceMatching("AppleUSBDeviceMux");
  if (!v16)
  {
    v65 = CFSTR("Failed to create IOKit matching dictionary for 'AppleUSBDeviceMux'.");
    goto LABEL_19;
  }
  v74[0] = _NSConcreteStackBlock;
  v74[1] = 3221225472;
  v74[2] = sub_100024720;
  v74[3] = &unk_10017ABB8;
  v74[4] = a1;
  if ((sub_100027668(v13, "IOServiceFirstMatch", (uint64_t)"IOGeneralInterest", (uint64_t)v16, 1, v74) & 1) == 0)
  {
    v65 = CFSTR("Failed to register IOKit matching message notification.");
    goto LABEL_18;
  }
  v22 = IOServiceMatching("IOUSBDeviceInterface");
  if (!v22)
  {
    sub_10001A7E4(0, "notification_worker", CFSTR("Failed to create IOKit matching dictionary for 'IOUSBDeviceInterface'."), v17, v18, v19, v20, v21, v72);
    goto LABEL_20;
  }
  v23 = sub_100025A4C();
  v29 = v23;
  if (!v23)
  {
    sub_10001A7E4(0, "notification_worker", CFSTR("Failed to create dictionary."), v24, v25, v26, v27, v28, v72);
    goto LABEL_21;
  }
  CFDictionarySetValue(v23, CFSTR("USBDeviceFunction"), CFSTR("PTP"));
  CFDictionarySetValue(v22, CFSTR("IOPropertyMatch"), v29);
  v73[0] = _NSConcreteStackBlock;
  v73[1] = 3221225472;
  v73[2] = sub_1000248A4;
  v73[3] = &unk_10017ABB8;
  v73[4] = a1;
  if ((sub_100027668(v13, "IOServiceFirstMatch", (uint64_t)"IOGeneralInterest", (uint64_t)v22, 0, v73) & 1) == 0)
  {
    sub_10001A7E4(0, "notification_worker", CFSTR("Failed to register IOKit matching message notification."), v30, v31, v32, v33, v34, v72);
    v22 = 0;
    goto LABEL_21;
  }
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterAddObserver(DistributedCenter, a1, (CFNotificationCallback)sub_1000248E0, CFSTR("com.apple.LaunchServices.applicationRegistered"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v36 = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterAddObserver(v36, a1, (CFNotificationCallback)sub_1000248E0, CFSTR("com.apple.LaunchServices.applicationUnregistered"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v37 = CFNotificationCenterGetDistributedCenter();
  CFNotificationCenterAddObserver(v37, a1, (CFNotificationCallback)sub_1000248E4, kDiskImageMountedNotification, kStorageMounterName, CFNotificationSuspensionBehaviorDeliverImmediately);
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(DarwinNotifyCenter, a1, (CFNotificationCallback)sub_100024A74, kMassStorageUnmountedNotification, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v39 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(v39, a1, (CFNotificationCallback)sub_100024AAC, CFSTR("com.apple.mobile.lockdown.BonjourServiceChanged"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v40 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(v40, a1, (CFNotificationCallback)sub_100024BDC, CFSTR("com.apple.mobile.lockdown.BonjourPairingServiceChanged"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v41 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(v41, a1, (CFNotificationCallback)sub_100024C98, CFSTR("com.apple.managedconfiguration.passcodechanged"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  v42 = CFNotificationCenterGetDarwinNotifyCenter();
  CFNotificationCenterAddObserver(v42, a1, (CFNotificationCallback)sub_100024D2C, CFSTR("com.apple.mobile.keybagd.lock_status"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  sub_100028148(&stru_10017ABD8);
  if ((sub_100006FB4() & 1) == 0)
  {
    v48 = CFNotificationCenterGetDarwinNotifyCenter();
    CFNotificationCenterAddObserver(v48, a1, (CFNotificationCallback)sub_100024E08, CFSTR("com.apple.datamigrator.migrationDidFinish"), 0, CFNotificationSuspensionBehaviorDeliverImmediately);
  }
  if (sub_10000F404(*a1, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiDebugging"), v43, v44, v45, v46, v47)|| sub_10000F404(*a1, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiConnections"), v49, v50, v51, v52, v53))
  {
    v13 = (IONotificationPort *)sub_100026BC8();
    v59 = v13 != 0;
  }
  else
  {
    v59 = 0;
    v13 = 0;
  }
  v60 = sub_10000F404(*a1, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiPairing"), v54, v55, v56, v57, v58);
  if ((v59 & 1) != 0 || v60)
  {
    v64 = 1;
    if (!sub_100005EF8(a1, (uint64_t)v13, v59, v60 != 0, 1, v61, v62, v63))
      sub_10001A7E4(0, "notification_worker", CFSTR("Failed to register DNS."), v67, v68, v69, v70, v71, v72);
    v22 = 0;
  }
  else
  {
    v22 = 0;
    v64 = 1;
  }
LABEL_23:
  if (mainPort)
    mach_port_deallocate(mach_task_self_, mainPort);
  if (v13)
    free(v13);
  if (v29)
    CFRelease(v29);
  if (v22)
    CFRelease(v22);
  return v64;
}

void sub_100024720(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  NSObject **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;

  v8 = a4;
  if (a3 == -469794303)
  {
    v9 = **(NSObject ****)(a1 + 32);
    sub_10000F0FC(v9, 0, (uint64_t)CFSTR("HostAttached"), 1, a5, a6, a7, a8);
    if (v8)
    {
      sub_10000E484((uint64_t)v9, 0, (uint64_t)CFSTR("HostAttached"), (uint64_t)kCFBooleanTrue, v10, v11, v12, v13);
      sub_10000F0FC(v9, 0, (uint64_t)CFSTR("TrustedHostAttached"), 1, v14, v15, v16, v17);
      sub_10000E484((uint64_t)v9, 0, (uint64_t)CFSTR("TrustedHostAttached"), (uint64_t)kCFBooleanFalse, v18, v19, v20, v21);
      sub_1000110EC(CFSTR("com.apple.mobile.lockdown.host_attached"));
      sub_100016D1C(1);
    }
    else
    {
      sub_10000E484((uint64_t)v9, 0, (uint64_t)CFSTR("HostAttached"), (uint64_t)kCFBooleanFalse, v10, v11, v12, v13);
      sub_10000F0FC(v9, 0, (uint64_t)CFSTR("TrustedHostAttached"), 1, v22, v23, v24, v25);
      sub_10000E484((uint64_t)v9, 0, (uint64_t)CFSTR("TrustedHostAttached"), (uint64_t)kCFBooleanFalse, v26, v27, v28, v29);
      sub_1000110EC(CFSTR("com.apple.mobile.lockdown.host_detached"));
      sub_100016F6C((uint64_t)v9, 1);
    }
  }
  else
  {
    sub_10001A7E4(0, "mux_notification_handler", CFSTR("Misc usbmuxd event: (messageType=0x%08x, argument=%p)"), a4, a5, a6, a7, a8, a3);
  }
}

void sub_1000248A4(uint64_t a1, uint64_t a2, int a3)
{
  if (a3 == -469794543)
  {
    sub_100016F6C(**(_QWORD **)(a1 + 32), 0);
  }
  else if (a3 == -469794544)
  {
    sub_100016D1C(0);
  }
}

void sub_1000248E4(int a1, uint64_t a2, int a3, uint64_t a4, CFDictionaryRef theDict, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  __CFString *Value;
  const __CFArray *v11;
  const __CFArray *v12;
  CFIndex v13;
  const __CFString *ValueAtIndex;
  char v15;
  const __CFString *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  if (!theDict)
  {
    v16 = CFSTR("No user info in notification.");
    LODWORD(v11) = 0;
LABEL_13:
    sub_10001A7E4((int)v11, "mounted_image_callback", v16, a4, (uint64_t)theDict, a6, a7, a8, a9);
    return;
  }
  Value = (__CFString *)CFDictionaryGetValue(theDict, kDiskImageMountPathKey);
  v11 = (const __CFArray *)sub_100010BA8(Value);
  if (!v11)
  {
    v16 = CFSTR("Missing mount path in notification.");
    goto LABEL_13;
  }
  v11 = (const __CFArray *)sub_10000A1CC();
  if (!v11)
  {
    v16 = CFSTR("Failed to query mounted paths list.");
    goto LABEL_13;
  }
  v12 = v11;
  if (CFArrayGetCount(v11) < 1)
  {
LABEL_9:
    v15 = 0;
  }
  else
  {
    v13 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v12, v13);
      if (sub_100010BA8(ValueAtIndex))
      {
        if (CFStringCompare(ValueAtIndex, Value, 0) == kCFCompareEqualTo)
          break;
      }
      if (++v13 >= CFArrayGetCount(v12))
        goto LABEL_9;
    }
    sub_10000A384(*(_QWORD *)a2, *(dispatch_queue_t **)(a2 + 8), Value, 0);
    v15 = 1;
  }
  if ((sub_100029F1C() & 1) != 0)
  {
    sub_10001A7E4(0, "mounted_image_callback", CFSTR("Reset the remote service interface in response to mounting image at %@."), v17, v18, v19, v20, v21, (char)Value);
    if ((v15 & 1) != 0)
      sub_1000110EC(CFSTR("com.apple.mobile.new_service_available"));
    else
      sub_10001A7E4(0, "mounted_image_callback", CFSTR("No service agents were loaded for %@."), v22, v23, v24, v25, v26, (char)Value);
  }
  else
  {
    sub_10001A7E4(0, "mounted_image_callback", CFSTR("Failed to reset the remote service interface in response to mounting image at %@."), v17, v18, v19, v20, v21, (char)Value);
  }
  CFRelease(v12);
}

void sub_100024A74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;

  if (sub_100029F1C())
    v14 = CFSTR("Reset the remote service interface in response to unmounting image.");
  else
    v14 = CFSTR("Failed to reset the remote service interface in response to unmounting image.");
  sub_10001A7E4(0, "unmounted_image_callback", v14, v9, v10, v11, v12, v13, a9);
}

void sub_100024AAC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  _BOOL4 v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char v24;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "bonjour_service_callback", CFSTR("Bonjour (sync) service notification."), a4, a5, a6, a7, a8, v24);
  if (a2)
  {
    if (sub_10000F404(*a2, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiDebugging"), a4, a5, a6, a7, a8)|| sub_10000F404(*a2, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiConnections"), v10, v11, v12, v13, v14))
    {
      v19 = sub_100026BC8();
      v20 = v19 != 0;
    }
    else
    {
      v20 = 0;
      v19 = 0;
    }
    sub_100006DB8(a2, 1, 0, 0, v15, v16, v17, v18, v24);
    lockdown_kill_wireless_connections(0);
    if (v20)
    {
      sub_100005EF8(a2, (uint64_t)v19, 1, 0, 1, v21, v22, v23);
      if (v19)
LABEL_9:
        free(v19);
    }
    else
    {
      lockdown_kill_wireless_connections(0);
      if (v19)
        goto LABEL_9;
    }
  }
  else
  {
    sub_10001A7E4(0, "bonjour_service_callback", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100024BDC(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "bonjour_service_pairing_callback", CFSTR("Bonjour (pairing) service notification."), a4, a5, a6, a7, a8, v14);
  if (a2)
  {
    if (sub_10000F404(*a2, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiPairing"), a4, a5, a6, a7, a8))sub_100005EF8(a2, 0, 0, 1, 1, v11, v12, v13);
    else
      sub_100006DB8(a2, 0, 1, 0, v10, v11, v12, v13, a9);
  }
  else
  {
    sub_10001A7E4(0, "bonjour_service_pairing_callback", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100024C98(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "password_changed_callback", CFSTR("Device passcode changed."), a4, a5, a6, a7, a8, v14);
  if (a2)
  {
    sub_100016AA4();
    sub_10000E484(*a2, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiDebugging"), (uint64_t)kCFBooleanFalse, v10, v11, v12, v13);
  }
  else
  {
    sub_10001A7E4(0, "password_changed_callback", CFSTR("Invalid input."), a4, a5, a6, a7, a8, a9);
  }
}

void sub_100024D2C(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  char v17;

  if (!a2)
  {
    v16 = CFSTR("Invalid input.");
LABEL_12:
    sub_10001A7E4(0, "lockstate_changed_callback", v16, a4, a5, a6, a7, a8, a9);
    return;
  }
  v10 = MKBGetDeviceLockState(0);
  if (v10 == 3 || !v10)
  {
    if ((sub_10001497C(*a2) & 1) == 0)
      sub_10001A7E4(0, "lockstate_changed_callback", CFSTR("Failed to upgrade pair records' protection class."), v11, v12, v13, v14, v15, v17);
    if (!sub_100016C40() || sub_100014914())
    {
      sub_100016BC4();
      return;
    }
    v16 = CFSTR("Failed to reset USB RM policy.");
    goto LABEL_12;
  }
}

void sub_100024DD4(id a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char v6;

  if (!sub_100014914())
    sub_10001A7E4(0, "notification_worker_block_invoke_3", CFSTR("Failed to reset USB RM policy."), v1, v2, v3, v4, v5, v6);
}

void sub_100024E08(__CFNotificationCenter *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v10;

  sub_10001A7E4(0, "migrator_finished_callback", CFSTR("Data Migration is complete."), a4, a5, a6, a7, a8, v10);
  CFNotificationCenterRemoveObserver(a1, a2, CFSTR("com.apple.datamigrator.migrationDidFinish"), 0);
}

void sub_100024E58(id a1)
{
  dispatch_workloop_t v1;
  void *v2;

  v1 = dispatch_workloop_create("com.apple.lockdown.workers");
  v2 = (void *)qword_1001A8098;
  qword_1001A8098 = (uint64_t)v1;

}

void sub_100024E80(uint64_t a1)
{
  sub_100023A98(*(_DWORD *)(a1 + 40), *(uint64_t **)(a1 + 32));
}

void sub_100024E90(uint64_t a1)
{

}

uint64_t sub_100024E98(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_100024EA8(uint64_t a1)
{

}

void sub_100024EB0(uint64_t a1)
{
  void *v2;
  dispatch_time_t v3;
  id v4;
  NSObject *v5;
  _QWORD block[5];

  v2 = objc_autoreleasePoolPush();
  sub_100024F80(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 32, *(uint64_t **)(a1 + 48));
  v3 = dispatch_time(0, 10000000000);
  v4 = sub_100023A48();
  v5 = objc_claimAutoreleasedReturnValue(v4);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100024F6C;
  block[3] = &unk_10017A178;
  block[4] = *(_QWORD *)(a1 + 40);
  dispatch_after(v3, v5, block);

  objc_autoreleasePoolPop(v2);
}

void sub_100024F6C(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v2 = *(void **)(v1 + 40);
  *(_QWORD *)(v1 + 40) = 0;

}

void sub_100024F80(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  const void *v5;
  const void *Value;
  const __CFBoolean *v7;
  _BOOL8 v8;
  LockdownSRPState *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  IOReturn v17;
  CFTypeRef v18;
  const __CFDictionary *v19;
  const void *v20;
  const void *v21;
  const void *v22;
  CFStringRef v23;
  CFStringRef v24;
  const void *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  const void *v33;
  const void *v34;
  const void *v35;
  uint64_t *v36;
  void *v37;
  const void *v38;
  const void *v39;
  _BOOL8 v40;
  uint64_t *v41;
  const void *v42;
  void *v43;
  const void *v44;
  const __CFString *v45;
  const void *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const __CFString *v51;
  const void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const __CFString *v57;
  void *v58;
  const __CFString *v59;
  const void *v60;
  const void *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const void *v66;
  const void *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  const __CFString *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  const void *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const void *v84;
  const void *v85;
  const void *v86;
  const void *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const void *v92;
  const __CFString *v93;
  const void *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  const __CFString *v113;
  const void *v114;
  IOPMAssertionID AssertionID;

  AssertionID = 0;
  v4 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v4 == -1)
  {
    v8 = 0;
    v5 = 0;
  }
  else
  {
    v5 = sub_100026434(v4);
    v8 = sub_100010B40(v5)
      && (Value = CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("com.apple.lockdownd.allow-save-value")),
          (v7 = (const __CFBoolean *)sub_100010C10(Value)) != 0)
      && CFBooleanGetValue(v7) != 0;
  }
  v9 = objc_alloc_init(LockdownSRPState);
  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 3)
  {
    v17 = IOPMAssertionCreateWithDescription(CFSTR("PreventUserIdleSystemSleep"), CFSTR("com.apple.mobile.lockdownd.active-connection"), CFSTR("Servicing a host-side client."), 0, 0, 0.0, 0, &AssertionID);
    if (v17)
      sub_10001A7E4(0, "handle_connection", CFSTR("Could not create power assertion while serving Wifi client: %d"), v12, v13, v14, v15, v16, v17);
  }
  v18 = 0;
  do
  {
    v19 = sub_100004E6C(*(int **)(a1 + 24), v10, v11, v12, v13, v14, v15, v16);
    if (sub_100010B40(v19))
    {
      if (!v18)
      {
        v20 = CFDictionaryGetValue(v19, CFSTR("Label"));
        v21 = sub_100010BA8(v20);
        if (!v21)
          goto LABEL_17;
        v22 = v21;
        v113 = CFSTR("com.apple.mobile.lockdownd.active-connection");
        v23 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@ %@"));
        if (v23)
        {
          v24 = v23;
          IOPMAssertionSetProperty(AssertionID, CFSTR("AssertName"), v23);
          CFRelease(v24);
        }
        v18 = CFRetain(v22);
        if (!v18)
LABEL_17:
          v18 = CFRetain(CFSTR("unknown"));
      }
      v25 = sub_100010BA8(v18);
      v32 = 1;
      switch(sub_10001B41C(a1, v19, v25))
      {
        case 1u:
          sub_10001B75C(a1, (uint64_t)v19, v26, v27, v28, v29, v30, v31, (char)v113);
          break;
        case 2u:
          sub_10001B78C(a1, (uint64_t)v19, v26, v27, v28, v29, v30, v31, (char)v113);
          goto LABEL_48;
        case 3u:
          v33 = sub_100010BA8(v18);
          v34 = sub_100010B40(v5);
          sub_10001C4FC(a1, v19, v33, v34, a2, 0, 0);
          goto LABEL_48;
        case 4u:
          v35 = sub_100010B40(v5);
          v36 = a2;
          v37 = (void *)objc_claimAutoreleasedReturnValue(-[LockdownSRPState pairingSession](v9, "pairingSession"));
          sub_10001C4FC(a1, v19, v18, v35, v36, v37, 1);

          a2 = v36;
          goto LABEL_48;
        case 5u:
          v38 = sub_100010BA8(v18);
          v39 = sub_100010B40(v5);
          sub_10001B7D4(a1, v19, (uint64_t)v38, v39, a2, 0, 0);
          goto LABEL_48;
        case 6u:
          v114 = sub_100010BA8(v18);
          v40 = v8;
          v41 = a2;
          v42 = sub_100010B40(v5);
          v43 = (void *)objc_claimAutoreleasedReturnValue(-[LockdownSRPState pairingSession](v9, "pairingSession"));
          v44 = v42;
          a2 = v41;
          v8 = v40;
          sub_10001B7D4(a1, v19, (uint64_t)v114, v44, a2, v43, 1);

          goto LABEL_48;
        case 7u:
          v45 = (const __CFString *)sub_100010BA8(v18);
          v46 = sub_100010B40(v5);
          sub_10001CAA0(a1, v19, v45, v46, v47, v48, v49, v50, (char)v113);
          goto LABEL_48;
        case 8u:
          v51 = (const __CFString *)sub_100010BA8(v18);
          v52 = sub_100010B40(v5);
          sub_10001DC0C(a1, v19, v51, v52, v53, v54, v55, v56, (char)v113);
          goto LABEL_48;
        case 9u:
          goto LABEL_31;
        case 0xAu:
          if (sub_10000F404(*a2, CFSTR("com.apple.mobile.wireless_lockdown"), CFSTR("EnableWifiPairing"), v27, v28, v29, v30, v31)&& sub_1000047F4(*(_QWORD *)(a1 + 24)) == 3)
          {
            v57 = (const __CFString *)sub_100010BA8(v18);
            v58 = (void *)objc_claimAutoreleasedReturnValue(-[LockdownSRPState pairingSession](v9, "pairingSession"));
            sub_10002AD68((uint64_t *)a1, v19, v57, 1, v58);

          }
          else
          {
LABEL_31:
            v59 = (const __CFString *)sub_100010BA8(v18);
            sub_10002AD68((uint64_t *)a1, v19, v59, 0, 0);
          }
          goto LABEL_48;
        case 0xBu:
          v60 = sub_100010B40(v5);
          v61 = sub_100010BA8(v18);
          sub_10001DF5C(a1, v19, v60, (uint64_t)v61, v62, v63, v64, v65);
          goto LABEL_48;
        case 0xCu:
          v66 = sub_100010BA8(v18);
          v67 = sub_100010B40(v5);
          sub_10001E3D4(a1, v19, (uint64_t)v66, v67, v68, v69, v70, v71, (char)v113);
          goto LABEL_48;
        case 0xDu:
          sub_10001E57C(a1, v19, v26, v27, v28, v29, v30, v31, (char)v113);
          goto LABEL_48;
        case 0xEu:
          sub_10001EA2C(a1, v19, v26, v27, v28, v29, v30, v31, (char)v113);
          goto LABEL_48;
        case 0xFu:
          v72 = (const __CFString *)sub_100010BA8(v18);
          sub_10001F478(a1, v19, v72, v73, v74, v75, v76, v77, (char)v113);
          goto LABEL_48;
        case 0x10u:
          v78 = sub_100010BA8(v18);
          sub_10001FD20(a1, (uint64_t)v19, (uint64_t)v78, v79, v80, v81, v82, v83, (char)v113);
          goto LABEL_48;
        case 0x11u:
          v93 = (const __CFString *)sub_100010BA8(v18);
          v94 = sub_100010B40(v5);
          sub_10001CAA0(a1, v19, v93, v94, v95, v96, v97, v98, (char)v113);
          if (v8)
          {
            if (sub_10000F320(*(NSObject ***)a1, v99, v100, v101, v102, v103, v104, v105))
              sub_10000E1DC(*(NSObject ***)a1, v106, v107, v108, v109, v110, v111, v112, (char)v113);
          }
          else
          {
            sub_10001A7E4(0, "handle_connection", CFSTR("but you didn't know the secret handshake"), v101, v102, v103, v104, v105, (char)v113);
          }
          goto LABEL_48;
        case 0x12u:
          v84 = sub_100010BA8(v18);
          v85 = sub_100010B40(v5);
          sub_10001FF1C((uint64_t *)a1, v19, (uint64_t)v84, v85);
          goto LABEL_48;
        case 0x13u:
          v86 = sub_100010BA8(v18);
          v87 = sub_100010B40(v5);
          sub_10002BDAC(a1, a2, v19, (uint64_t)v86, v87, v88, v89, v90, (char)v113);
          goto LABEL_48;
        case 0x14u:
          v91 = 1;
          goto LABEL_46;
        case 0x15u:
          v91 = 0;
LABEL_46:
          sub_10002BFB0(v91, a1, v9, v19);
LABEL_48:
          v32 = 0;
          break;
        case 0x17u:
          v92 = sub_100010BA8(v18);
          sub_100027A40(a1, v19, v92);
          break;
        default:
          break;
      }
    }
    else
    {
      v32 = 1;
    }
    if (v19)
      CFRelease(v19);
  }
  while (((sub_1000047E0(*(unsigned int **)(a1 + 24)) != -1) & ~v32) != 0);
  sub_100022174(a1, v10, v11, v12, v13, v14, v15, v16);
  if (v18)
    CFRelease(v18);
  if (AssertionID)
    IOPMAssertionRelease(AssertionID);
  if (v5)
    CFRelease(v5);
  -[LockdownSRPState invalidate](v9, "invalidate");

}

uint64_t sub_1000255E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v9;
  void *v10;
  void *v11;
  id v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *v19;
  unsigned __int8 v20;
  id v21;
  int v22;
  int v23;
  const __CFString *v24;
  const __CFString *v25;
  uint64_t v26;
  id v28;
  id v29;
  int *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  id v43;

  if (!a1 || !a2)
  {
    v25 = CFSTR("Invalid inputs.");
    LODWORD(v9) = 0;
LABEL_11:
    sub_10001A7E4((int)v9, "store_dict", v25, a4, a5, a6, a7, a8, v42);
    return 0xFFFFFFFFLL;
  }
  v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithCString:encoding:", a1, 4);
  if (!v9)
  {
    v25 = CFSTR("Failed to create string.");
    goto LABEL_11;
  }
  v10 = v9;
  v43 = 0;
  v11 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization dataWithPropertyList:format:options:error:](NSPropertyListSerialization, "dataWithPropertyList:format:options:error:", a2, 200, 0, &v43));
  v12 = v43;
  v18 = v12;
  if (v11)
  {
    v19 = (void *)objc_claimAutoreleasedReturnValue(+[NSFileManager defaultManager](NSFileManager, "defaultManager"));
    v20 = objc_msgSend(v19, "fileExistsAtPath:", v10);

    v21 = objc_retainAutorelease(v10);
    v22 = open_dprotected_np((const char *)objc_msgSend(v21, "fileSystemRepresentation"), 1794, 4, 0);
    if (v22 != -1)
    {
      v23 = v22;
      if ((v20 & 1) != 0
        || !chmod((const char *)objc_msgSend(objc_retainAutorelease(v21), "fileSystemRepresentation"), 0x1A4u))
      {
        v28 = objc_retainAutorelease(v11);
        v29 = (id)write(v23, objc_msgSend(v28, "bytes"), (size_t)objc_msgSend(v28, "length"));
        if (v29 == objc_msgSend(v28, "length"))
        {
          v26 = 0;
LABEL_20:
          close(v23);

          return v26;
        }
        v24 = CFSTR("Failed to write data to %@: %s");
      }
      else
      {
        v24 = CFSTR("Failed to update file permissions for %@: %s");
      }
      v36 = __error();
      strerror(*v36);
      sub_10001A7E4(0, "store_dict", v24, v37, v38, v39, v40, v41, (char)v21);
      v26 = 0xFFFFFFFFLL;
      goto LABEL_20;
    }
    v30 = __error();
    strerror(*v30);
    sub_10001A7E4(0, "store_dict", CFSTR("Failed to create %@: %s"), v31, v32, v33, v34, v35, (char)v21);

  }
  else
  {
    sub_10001A7E4(0, "store_dict", CFSTR("Failed to serialize dictionary: %@"), v13, v14, v15, v16, v17, (char)v12);

  }
  return 0xFFFFFFFFLL;
}

id sub_10002581C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v23;

  v8 = a1;
  if (!a1)
  {
    sub_10001A7E4(0, "_load_dict", CFSTR("Invalid input."), a4, a5, a6, a7, a8, v23);
    return v8;
  }
  v9 = objc_msgSend(objc_alloc((Class)NSString), "initWithCString:encoding:", a1, 4);
  if (!v9)
  {
    sub_10001A7E4(0, "_load_dict", CFSTR("Failed to create string for %s."), v10, v11, v12, v13, v14, (char)v8);
    return 0;
  }
  v15 = v9;
  v16 = objc_msgSend(objc_alloc((Class)NSMutableDictionary), "initWithContentsOfFile:", v9);
  if (!v16)
  {
    sub_10001A7E4(0, "_load_dict", CFSTR("Failed to load %s."), v17, v18, v19, v20, v21, (char)v8);

    return 0;
  }
  v8 = v16;

  return v8;
}

void sub_1000258E8(const __CFDictionary *a1, void *a2)
{
  CFIndex Count;
  const void **v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void (**v11)(id, uint64_t, uint64_t);

  v11 = a2;
  Count = CFDictionaryGetCount(a1);
  v4 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  v5 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  CFDictionaryGetKeysAndValues(a1, v4, v5);
  if (Count)
  {
    v6 = v4;
    v7 = v5;
    do
    {
      v9 = (uint64_t)*v6++;
      v8 = v9;
      v10 = (uint64_t)*v7++;
      v11[2](v11, v8, v10);
      --Count;
    }
    while (Count);
  }
  free(v4);
  free(v5);

}

void sub_1000259B8(const __CFSet *a1, void *a2)
{
  CFIndex Count;
  const void **v4;
  const void **v5;
  uint64_t v6;
  void (**v7)(id, _QWORD);

  v7 = a2;
  Count = CFSetGetCount(a1);
  v4 = (const void **)malloc_type_malloc(8 * Count, 0x80040B8603338uLL);
  CFSetGetValues(a1, v4);
  if (Count)
  {
    v5 = v4;
    do
    {
      v6 = (uint64_t)*v5++;
      v7[2](v7, v6);
      --Count;
    }
    while (Count);
  }
  free(v4);

}

CFMutableDictionaryRef sub_100025A4C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFMutableDictionaryRef Mutable;
  char v7;

  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    sub_10001A7E4(0, "create_dict", CFSTR("Failed to allocate dictionary."), v0, v1, v2, v3, v4, v7);
  return Mutable;
}

CFMutableArrayRef sub_100025AA0()
{
  CFMutableArrayRef result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char vars0;

  result = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!result)
  {
    sub_10001A7E4(0, "create_array", CFSTR("Could not create mutable dictionary! We are dead!"), v1, v2, v3, v4, v5, vars0);
    exit(-1);
  }
  return result;
}

__CFArray *sub_100025AEC(const __CFDictionary *a1)
{
  __CFArray *v2;
  size_t Count;
  uint64_t v4;
  const void **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void **v11;
  const void **v12;
  const void *v13;
  char v15;

  v2 = sub_100025AA0();
  if (a1)
  {
    Count = CFDictionaryGetCount(a1);
    if (Count)
    {
      v4 = Count;
      v5 = (const void **)malloc_type_calloc(Count, 8uLL, 0x80040B8603338uLL);
      if (!v5)
      {
        sub_10001A7E4(0, "copy_keys", CFSTR("Could not allocate key list. We are dead."), v6, v7, v8, v9, v10, v15);
        exit(-1);
      }
      v11 = v5;
      CFDictionaryGetKeysAndValues(a1, v5, 0);
      if (v4 >= 1)
      {
        v12 = v11;
        do
        {
          v13 = *v12++;
          CFArrayAppendValue(v2, v13);
          --v4;
        }
        while (v4);
      }
      free(v11);
    }
  }
  return v2;
}

char *sub_100025BA4(char *__s)
{
  int v2;
  char *v3;
  int v4;
  int v5;
  char *v6;
  char *v7;
  int v8;
  __int16 v9;

  if (__s)
  {
    v2 = *__s;
    if (*__s)
    {
      v3 = &__s[strlen(__s) - 1];
      while (v3 > __s)
      {
        v4 = *v3--;
        if (v4 != 47)
        {
          while (v3 > __s)
          {
            v5 = *v3--;
            if (v5 == 47)
            {
              ++v3;
              goto LABEL_11;
            }
          }
          goto LABEL_16;
        }
      }
LABEL_11:
      if (v3 == __s)
      {
LABEL_16:
        if (v2 == 47)
          v9 = 47;
        else
          v9 = 46;
        *(_WORD *)__s = v9;
        return __s;
      }
      v6 = v3 - 1;
      do
      {
        v7 = v3;
        if (v6 <= __s)
          break;
        v8 = *v6--;
        --v3;
      }
      while (v8 == 47);
      *v7 = 0;
    }
  }
  return __s;
}

char *sub_100025C54(char *__s)
{
  int v2;
  size_t v3;
  size_t v4;
  char *v5;
  int v6;
  size_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  char *v11;
  char *v12;
  int v13;

  if (__s)
  {
    v2 = *__s;
    if (*__s)
    {
      v3 = strlen(__s) - 1;
      do
      {
        v4 = v3;
        v5 = &__s[v3];
        if (v5 <= __s)
          break;
        v6 = *v5;
        v3 = v4 - 1;
      }
      while (v6 == 47);
      if (v4 || v2 != 47)
      {
        v7 = v4 + 1;
        v8 = 1;
        do
        {
          v9 = v7;
          v10 = v8;
          v11 = &__s[v7];
          v12 = v11 - 1;
          if (v11 - 1 <= __s)
            break;
          v13 = *(v11 - 2);
          v7 = v9 - 1;
          ++v8;
        }
        while (v13 != 47);
        if (v9 != 1)
          memmove(__s, v12, v10);
        __s[v10] = 0;
      }
      else
      {
        *(_WORD *)__s = 47;
      }
    }
  }
  return __s;
}

void sub_100025D10(const char *a1)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  stat v13;

  v1 = (char)a1;
  memset(&v13, 0, sizeof(v13));
  if (stat(a1, &v13))
  {
    v7 = __error();
    strerror(*v7);
    sub_10001A7E4(0, "log_file_info", CFSTR("Can't stat %s: %s"), v8, v9, v10, v11, v12, v1);
  }
  else
  {
    sub_10001A7E4(0, "log_file_info", CFSTR("stat %s uid=%d gid=%d p=%o"), v2, v3, v4, v5, v6, v1);
  }
}

void sub_100025DA4(const char *a1)
{
  char __s[1024];

  sub_100025D10(a1);
  __strlcpy_chk(__s, a1, 1024, 1024);
  sub_100025BA4(__s);
  sub_100025D10(__s);
}

uint64_t sub_100025E1C(uint64_t a1, char a2, const char *a3)
{
  char *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  FTS *v11;
  FTS *v12;
  FTSENT *v13;
  FTSENT *v14;
  const __CFString *v15;
  unsigned int fts_info;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  char *fts_path;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  char v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  char __s2[1024];
  char *v40[2];
  char v41[1024];
  _BYTE v42[1024];

  __strlcpy_chk(v42, a1, 1024, 1024);
  v40[0] = v42;
  v40[1] = 0;
  if (!a3)
    goto LABEL_4;
  v5 = v41;
  if (!realpath_DARWIN_EXTSN(a3, v41))
  {
    sub_10001A7E4(0, "empty_directory_ignoring_path", CFSTR("ignorePath %s was invalid"), v6, v7, v8, v9, v10, (char)a3);
LABEL_4:
    v5 = 0;
  }
  v11 = fts_open(v40, 21, 0);
  if (!v11)
  {
    v23 = CFSTR("fts_open: %s");
    goto LABEL_27;
  }
  v12 = v11;
  v13 = fts_read(v11);
  if (!v13)
  {
LABEL_22:
    v22 = 0;
    goto LABEL_25;
  }
  v14 = v13;
  v15 = CFSTR("unlink %s: %s");
  while (1)
  {
    fts_info = v14->fts_info;
    if (fts_info > 0xD)
      goto LABEL_14;
    if (((1 << fts_info) & 0x3108) == 0)
      break;
    if (v5 && realpath_DARWIN_EXTSN(v14->fts_path, __s2) && !strcmp(v5, __s2))
    {
      sub_10001A7E4(0, "empty_directory_ignoring_path", CFSTR("ignoring unlink of %s"), v17, v18, v19, v20, v21, (char)v5);
    }
    else if (unlink(v14->fts_path) == -1)
    {
      goto LABEL_24;
    }
LABEL_14:
    v14 = fts_read(v12);
    if (!v14)
      goto LABEL_22;
  }
  if (fts_info != 6 || (a2 & 1) == 0 && !v14->fts_level || rmdir(v14->fts_path) != -1)
    goto LABEL_14;
  v15 = CFSTR("rmdir %s: %s");
LABEL_24:
  fts_path = v14->fts_path;
  v25 = __error();
  strerror(*v25);
  sub_10001A7E4(0, "empty_directory_ignoring_path", v15, v26, v27, v28, v29, v30, (char)fts_path);
  sub_100025DA4(v14->fts_path);
  fts_read(v12);
  v22 = 1;
LABEL_25:
  if (fts_close(v12))
  {
    v23 = CFSTR("fts_close: %s");
LABEL_27:
    v31 = __error();
    v32 = strerror(*v31);
    sub_10001A7E4(0, "empty_directory_ignoring_path", v23, v33, v34, v35, v36, v37, v32);
    return 1;
  }
  return v22;
}

uint64_t sub_100026060(uint64_t a1)
{
  return sub_100025E1C(a1, 0, 0);
}

uint64_t sub_10002606C(const char *a1)
{
  FTS *v2;
  FTS *v3;
  FTSENT *v4;
  uint64_t v5;
  const __CFString *v6;
  int *v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char *v15[2];
  _BYTE v16[1024];

  __strlcpy_chk(v16, a1, 1024, 1024);
  v15[0] = v16;
  v15[1] = 0;
  v2 = fts_open(v15, 21, 0);
  if (!v2)
  {
    v5 = 1;
    v6 = CFSTR("fts_open: %s");
LABEL_10:
    v7 = __error();
    v8 = strerror(*v7);
    sub_10001A7E4(0, "is_empty_path", v6, v9, v10, v11, v12, v13, v8);
    return v5;
  }
  v3 = v2;
  while (1)
  {
    v4 = fts_read(v3);
    if (!v4)
      break;
    if (strcmp(v4->fts_path, a1))
    {
      v5 = 0;
      goto LABEL_8;
    }
  }
  v5 = 1;
LABEL_8:
  if (fts_close(v3))
  {
    v6 = CFSTR("fts_close: %s");
    goto LABEL_10;
  }
  return v5;
}

uint64_t sub_10002616C(const char *a1, __int16 a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x200) == 0)
    return sub_1000261C0(a1, a2, 0, a3);
  sub_10001A7E4(0, "safe_open", CFSTR("safe_open can't be used to create %s"), a4, a5, a6, a7, a8, (char)a1);
  *__error() = 22;
  return 0xFFFFFFFFLL;
}

uint64_t sub_1000261C0(const char *a1, int a2, unsigned int a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  stat v37;
  char __s1[1024];

  memset(&v37, 0, sizeof(v37));
  v6 = open(a1, a2 | 0x100, a3);
  if ((_DWORD)v6 == -1)
  {
    if (*__error() != 2)
    {
      __error();
      v13 = __error();
      strerror(*v13);
      sub_10001A7E4(0, "_safe_open", CFSTR("Failed to open %s: %d (%s)"), v14, v15, v16, v17, v18, (char)a1);
    }
  }
  else
  {
    v7 = v6;
    if (fcntl(v6, 50, __s1) == -1)
    {
      __error();
      v19 = __error();
      strerror(*v19);
      sub_10001A7E4(0, "_safe_open", CFSTR("F_GETPATH failed for %s: %d (%s)"), v20, v21, v22, v23, v24, (char)a1);
    }
    else if (!strcmp(__s1, a1))
    {
      if (fstat(v7, &v37) == -1)
      {
        __error();
        v31 = __error();
        strerror(*v31);
        sub_10001A7E4(0, "_safe_open", CFSTR("fstat failed for %s: %d (%s)"), v32, v33, v34, v35, v36, (char)a1);
      }
      else
      {
        if ((v37.st_mode & 0xF000) == a4)
          return v7;
        sub_10001A7E4(0, "_safe_open", CFSTR("File type for %s is not expected type (actual/expected): %d/%d"), v26, v27, v28, v29, v30, (char)a1);
      }
    }
    else
    {
      sub_10001A7E4(0, "_safe_open", CFSTR("%s was actually %s, something fishy is going on"), v8, v9, v10, v11, v12, (char)a1);
    }
    close(v7);
  }
  return 0xFFFFFFFFLL;
}

uint64_t sub_10002639C(const char *a1, __int16 a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x200) != 0)
    return sub_1000261C0(a1, a2, a3, a4);
  sub_10001A7E4(0, "safe_create", CFSTR("safe_create requires O_CREAT %s"), a4, a5, a6, a7, a8, (char)a1);
  *__error() = 22;
  return 0xFFFFFFFFLL;
}

BOOL sub_1000263E8()
{
  int v0;
  int v1;

  v0 = sub_1000261C0("/AppleInternal/Lockdown/.hactivateoff", 256, 0, 0x8000);
  v1 = v0;
  if (v0 != -1)
    close(v0);
  return v1 != -1;
}

const void *sub_100026434(uint64_t a1)
{
  UInt8 *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  CFIndex v21;
  const __CFData *v22;
  const __CFData *v23;
  CFPropertyListRef v24;
  const void *v25;
  CFTypeID v26;
  uint64_t v28;

  v28 = 0;
  if (!csops(a1, 7, &v28, 8))
    return 0;
  if (*__error() != 34)
  {
    v14 = __error();
    strerror(*v14);
    sub_10001A7E4(0, "copy_entitlements_for_pid", CFSTR("csops1(%d): %s\n"), v15, v16, v17, v18, v19, a1);
    return 0;
  }
  v2 = (UInt8 *)malloc_type_calloc(1uLL, bswap32(HIDWORD(v28)), 0x6A1037DEuLL);
  if (csops(a1, 7, v2, bswap32(HIDWORD(v28))))
  {
    v8 = __error();
    strerror(*v8);
    sub_10001A7E4(0, "copy_entitlements_for_pid", CFSTR("csops2(%d): %s\n"), v9, v10, v11, v12, v13, a1);
    if (!v2)
      return 0;
    goto LABEL_15;
  }
  if (*(_DWORD *)v2 != 1903288058)
  {
    sub_10001A7E4(0, "copy_entitlements_for_pid", CFSTR("bad magic 0x%08x\n"), v3, v4, v5, v6, v7, *(_DWORD *)v2);
LABEL_15:
    free(v2);
    return 0;
  }
  v20 = bswap32(*((_DWORD *)v2 + 1));
  if (v20 < 9)
    goto LABEL_15;
  v21 = v20 - 8;
  *((_DWORD *)v2 + 1) = v21;
  v22 = CFDataCreateWithBytesNoCopy(0, v2 + 8, v21, kCFAllocatorNull);
  if (!v22)
    goto LABEL_15;
  v23 = v22;
  v24 = CFPropertyListCreateWithData(0, v22, 0, 0, 0);
  v25 = v24;
  if (v24)
  {
    v26 = CFGetTypeID(v24);
    if (v26 != CFDictionaryGetTypeID())
    {
      CFRelease(v25);
      v25 = 0;
    }
  }
  free(v2);
  CFRelease(v23);
  return v25;
}

uint64_t sub_1000265EC(uint64_t a1, const void *a2, const __CFDictionary *Value, uint64_t a4, uint64_t a5, int a6)
{
  CFStringRef v12;
  const __CFString *v13;
  const __CFString *v14;
  CFTypeID v15;
  CFRange v16;

  if (sub_1000047F4(*(_QWORD *)(a1 + 24)) != 4)
    return 1;
  if (Value)
  {
    if (CFDictionaryGetValue(Value, CFSTR("com.apple.private.lockdown.lockdown_query"))
      && CFEqual(a2, CFSTR("lockdown_query")))
    {
      return 1;
    }
    if (a4 && a5)
    {
      v12 = CFStringCreateWithFormat(0, 0, CFSTR("%@/%@"), a4, a5);
    }
    else if (a4)
    {
      v12 = CFStringCreateWithFormat(0, 0, CFSTR("%@/NULL"), a4);
    }
    else
    {
      if (!a5)
      {
        v13 = CFSTR("NULL/NULL");
LABEL_15:
        if ((a6 - 3) > 1)
        {
          switch(a6)
          {
            case 22:
              Value = (const __CFDictionary *)CFDictionaryGetValue(Value, CFSTR("com.apple.private.MobileActivation"));
              if (v13)
                CFRelease(v13);
              v13 = CFSTR("GetActivationState");
LABEL_26:
              if (!Value)
                goto LABEL_30;
              v15 = CFGetTypeID(Value);
              if (v15 == CFArrayGetTypeID())
              {
                v16.length = CFArrayGetCount(Value);
                v16.location = 0;
                Value = (const __CFDictionary *)(CFArrayContainsValue(Value, v16, v13) != 0);
                goto LABEL_30;
              }
LABEL_29:
              Value = 0;
LABEL_30:
              if (v13)
                CFRelease(v13);
              return (uint64_t)Value;
            case 8:
              v14 = CFSTR("com.apple.private.lockdown.finegrained-remove");
              break;
            case 7:
              v14 = CFSTR("com.apple.private.lockdown.finegrained-set");
              break;
            default:
              goto LABEL_29;
          }
        }
        else
        {
          v14 = CFSTR("com.apple.private.lockdown.finegrained-get");
        }
        Value = (const __CFDictionary *)CFDictionaryGetValue(Value, v14);
        goto LABEL_26;
      }
      v12 = CFStringCreateWithFormat(0, 0, CFSTR("NULL/%@"), a5);
    }
    v13 = v12;
    goto LABEL_15;
  }
  return (uint64_t)Value;
}

unint64_t sub_1000267A0()
{
  uint64_t v0;
  unint64_t v1;
  unint64_t v2;

  if (qword_1001A80B0 != -1)
    dispatch_once(&qword_1001A80B0, &stru_10017AC40);
  v0 = mach_absolute_time();
  LODWORD(v1) = dword_1001A80A8;
  LODWORD(v2) = *(_DWORD *)algn_1001A80AC;
  return (unint64_t)((double)v0 * (double)v1 / (double)v2 / 1000000000.0);
}

void sub_10002680C(id a1)
{
  mach_timebase_info((mach_timebase_info_t)&dword_1001A80A8);
}

__darwin_time_t sub_100026818()
{
  timespec v1;

  v1.tv_sec = 0;
  v1.tv_nsec = 0;
  clock_gettime(_CLOCK_REALTIME, &v1);
  return v1.tv_sec;
}

id sub_100026844()
{
  id v0;
  void *v1;
  void *v2;
  size_t size;

  size = 0;
  v0 = 0;
  if (!sysctlbyname("kern.bootsessionuuid", 0, &size, 0, 0))
  {
    v1 = malloc_type_malloc(size, 0xF0FA1E88uLL);
    if (v1)
    {
      v2 = v1;
      v0 = 0;
      if (!sysctlbyname("kern.bootsessionuuid", v1, &size, 0, 0))
        v0 = objc_msgSend(objc_alloc((Class)NSString), "initWithUTF8String:", v2);
      free(v2);
    }
    else
    {
      return 0;
    }
  }
  return v0;
}

CFTypeRef sub_1000268F4(const void *a1, uint64_t a2)
{
  CFTypeRef result;

  result = (CFTypeRef)_MGSCopyLocalizedString("/System/Library/Lockdown/Localization.bundle", a1, a1, a2);
  if (!result)
    return CFRetain(a1);
  return result;
}

uint64_t sub_10002693C()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  char v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  if (qword_1001A80C0 != -1)
    dispatch_once(&qword_1001A80C0, &stru_10017AC60);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100026A24;
  block[3] = &unk_10017A178;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_1001A80B8, block);
  v0 = *((unsigned __int8 *)v4 + 24);
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1000269F8(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.lockdown.fmip.restore", 0);
  v2 = (void *)qword_1001A80B8;
  qword_1001A80B8 = (uint64_t)v1;

}

void sub_100026A24(uint64_t a1)
{
  id v2;

  v2 = (id)objc_claimAutoreleasedReturnValue(+[FMDFMIPManager sharedInstance](FMDFMIPManager, "sharedInstance"));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(v2, "lockdownShouldDisableDeviceRestore");

}

uint64_t sub_100026A70()
{
  uint64_t v0;
  _QWORD block[5];
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  char v6;

  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v6 = 0;
  if (qword_1001A80D0 != -1)
    dispatch_once(&qword_1001A80D0, &stru_10017AC80);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100026B58;
  block[3] = &unk_10017A178;
  block[4] = &v3;
  dispatch_sync((dispatch_queue_t)qword_1001A80C8, block);
  v0 = *((unsigned __int8 *)v4 + 24);
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_100026B2C(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.lockdown.fmip.pairing", 0);
  v2 = (void *)qword_1001A80C8;
  qword_1001A80C8 = (uint64_t)v1;

}

void sub_100026B58(uint64_t a1)
{
  id v2;

  v2 = (id)objc_claimAutoreleasedReturnValue(+[FMDFMIPManager sharedInstance](FMDFMIPManager, "sharedInstance"));
  *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = objc_msgSend(v2, "lockdownShouldDisableDevicePairing");

}

uint64_t sub_100026BA4()
{
  return notify_post((const char *)-[__CFString UTF8String](objc_retainAutorelease(CFSTR("com.apple.mobile.lockdown.BonjourServiceChanged")), "UTF8String"));
}

char *sub_100026BC8()
{
  void *v0;
  CFMutableSetRef Mutable;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFSet *v7;
  id v8;
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  _QWORD v17[4];
  id v18;
  _QWORD v19[5];

  v0 = objc_autoreleasePoolPush();
  Mutable = CFSetCreateMutable(0, 0, 0);
  if (Mutable)
  {
    v7 = Mutable;
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_100026D20;
    v19[3] = &unk_10017ACA0;
    v19[4] = Mutable;
    sub_100014DC0(v19);
    if (CFSetGetCount(v7))
    {
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      v17[2] = sub_100026E00;
      v17[3] = &unk_10017ACC8;
      v8 = (id)objc_claimAutoreleasedReturnValue(+[NSMutableString stringWithString:](NSMutableString, "stringWithString:", CFSTR("_apple-mobdev2._tcp")));
      v18 = v8;
      sub_1000259B8(v7, v17);

      v9 = objc_retainAutorelease(v8);
      v15 = strdup((const char *)objc_msgSend(v9, "UTF8String"));
      if (!v15)
        sub_10001A7E4(0, "copy_mdns_service_string", CFSTR("Failed to copy string."), v10, v11, v12, v13, v14, v17[0]);
    }
    else
    {
      v9 = 0;
      v15 = 0;
    }
    CFRelease(v7);

  }
  else
  {
    sub_10001A7E4(0, "copy_mdns_service_string", CFSTR("Failed to create set."), v2, v3, v4, v5, v6, v17[0]);
    v15 = 0;
  }
  objc_autoreleasePoolPop(v0);
  return v15;
}

uint64_t sub_100026D20(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  id v10;
  id v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  const Bytef *v19;
  uInt v20;
  const void *v21;
  char v23;

  v3 = a2;
  v9 = v3;
  if (v3)
  {
    v10 = (id)objc_claimAutoreleasedReturnValue(objc_msgSend(v3, "objectForKey:", CFSTR("SystemBUID")));
    v11 = sub_10001B244(v10);
    v12 = (void *)objc_claimAutoreleasedReturnValue(v11);

    if (v12)
    {
      v18 = objc_retainAutorelease(v10);
      v19 = (const Bytef *)objc_msgSend(v18, "UTF8String");
      v10 = objc_retainAutorelease(v18);
      v20 = strlen((const char *)objc_msgSend(v10, "UTF8String"));
      v21 = (const void *)adler32(0, v19, v20);
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v21);
    }
    else
    {
      sub_10001A7E4(0, "copy_mdns_service_string_block_invoke", CFSTR("Pair record doesn't contain buid."), v13, v14, v15, v16, v17, v23);
    }

  }
  else
  {
    sub_10001A7E4(0, "copy_mdns_service_string_block_invoke", CFSTR("Invalid pair record."), v4, v5, v6, v7, v8, v23);
  }

  return 1;
}

id sub_100026E00(uint64_t a1, uint64_t a2)
{
  return objc_msgSend(*(id *)(a1 + 32), "appendFormat:", CFSTR(",%08x"), a2);
}

id sub_100026E2C()
{
  void *v0;
  id v1;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"));
  v1 = objc_msgSend(v0, "isDeviceNameModificationAllowed");

  return v1;
}

id sub_100026E68()
{
  void *v0;
  id v1;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"));
  v1 = objc_msgSend(v0, "isUnpairedExternalBootToRecoveryAllowed");

  return v1;
}

uint64_t sub_100026EA4(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4, _BYTE *a5)
{
  void *v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t result;
  char v17;

  v9 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"));
  v10 = objc_msgSend(v9, "hostMayPairWithOptions:challenge:", a1, a3);

  switch(v10)
  {
    case 0u:
      sub_10001A7E4(0, "mc_allow_pairing", CFSTR("hostMayPairWithOptions said no"), v11, v12, v13, v14, v15, v17);
      result = 0;
      *a4 = 0;
      goto LABEL_6;
    case 1u:
      sub_10001A7E4(0, "mc_allow_pairing", CFSTR("hostMayPairWithOptions said yes with prompt"), v11, v12, v13, v14, v15, v17);
      *a4 = 0;
      *a5 = 0;
      result = 1;
      break;
    case 2u:
      sub_10001A7E4(0, "mc_allow_pairing", CFSTR("hostMayPairWithOptions said yes without prompt"), v11, v12, v13, v14, v15, v17);
      result = 1;
      *a4 = 1;
LABEL_6:
      *a5 = 0;
      break;
    case 3u:
      sub_10001A7E4(0, "mc_allow_pairing", CFSTR("hostMayPairWithOptions said challenge"), v11, v12, v13, v14, v15, v17);
      *a4 = 0;
      result = 1;
      *a5 = 1;
      break;
    default:
      sub_10001A7E4(0, "mc_allow_pairing", CFSTR("hostMayPairWithOptions returned unknown value: %d"), v11, v12, v13, v14, v15, v10);
      result = 0;
      break;
  }
  return result;
}

CFDataRef sub_100026FEC(size_t a1)
{
  int v2;
  int v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CFDataRef v11;

  v2 = sub_1000261C0("/dev/random", 0, 0, 0x2000);
  if (v2 == -1)
    return 0;
  v3 = v2;
  v4 = malloc_type_malloc(a1, 0xD4E5EDE5uLL);
  if (v4)
  {
    v5 = v4;
    if (read(v3, v4, a1) != a1)
    {
      sub_10001A7E4(0, "create_random_challenge", CFSTR("failed to read %zu random bytes"), v6, v7, v8, v9, v10, a1);
LABEL_9:
      close(v3);
      free(v5);
      return 0;
    }
    v11 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)v5, a1, kCFAllocatorMalloc);
    if (!v11)
      goto LABEL_9;
  }
  else
  {
    v11 = 0;
  }
  close(v3);
  return v11;
}

CFBooleanRef sub_1000270D8()
{
  void *v0;
  unsigned int v1;
  const CFBooleanRef *v2;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"));
  v1 = objc_msgSend(v0, "isSupervised");

  v2 = &kCFBooleanTrue;
  if (!v1)
    v2 = &kCFBooleanFalse;
  return *v2;
}

void sub_10002712C(void *a1)
{
  __CFDictionary *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFPropertyListRef v9;

  v2 = (__CFDictionary *)sub_10000ED98((uint64_t)a1, (uint64_t)CFSTR("com.apple.mobile.backup"), 0);
  v9 = sub_10001AE30(CFSTR("Version"), CFSTR("com.apple.mobile.ldbackup"), v3, v4, v5, v6, v7, v8);
  if (!v2)
  {
LABEL_8:
    if (!v9)
      goto LABEL_10;
    goto LABEL_9;
  }
  if (CFDictionaryGetCount(v2) > 0 || v9 == 0)
  {
    CFDictionarySetValue(v2, CFSTR("Version"), CFSTR("2.0"));
    CFDictionaryApplyFunction(v2, (CFDictionaryApplierFunction)sub_1000271F0, a1);
    goto LABEL_8;
  }
LABEL_9:
  CFRelease(v9);
LABEL_10:
  if (v2)
    CFRelease(v2);
}

uint64_t sub_1000271F0(const __CFString *a1, const void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  sub_10001AD28(a1, a2, CFSTR("com.apple.mobile.ldbackup"), a4, a5, a6, a7, a8);
  return sub_10000EFB4(a3, (uint64_t)CFSTR("com.apple.mobile.backup"), (uint64_t)a1, v10, v11, v12, v13, v14);
}

uint64_t sub_100027234(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFPropertyListRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFPropertyListRef v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFPropertyListRef v22;
  unsigned int v23;
  int v24;
  uint64_t v25;

  v8 = sub_10001AE30(CFSTR("SetupState"), CFSTR("com.apple.purplebuddy"), a3, a4, a5, a6, a7, a8);
  v15 = sub_10001AE30(CFSTR("SetupDone"), CFSTR("com.apple.purplebuddy"), v9, v10, v11, v12, v13, v14);
  v22 = sub_10001AE30(CFSTR("SetupFinishedAllSteps"), CFSTR("com.apple.purplebuddy"), v16, v17, v18, v19, v20, v21);
  v23 = sub_100004540();
  if (sub_100010C10(v15) && CFEqual(v15, kCFBooleanTrue)
    || sub_100010C10(v22) && CFEqual(v22, kCFBooleanTrue)
    || (sub_100010BA8(v8) ? (v24 = 1) : (v24 = v23), v24 == 1))
  {
    v25 = 1;
    if (!v8)
      goto LABEL_11;
    goto LABEL_10;
  }
  v25 = 0;
  if (v8)
LABEL_10:
    CFRelease(v8);
LABEL_11:
  if (v15)
    CFRelease(v15);
  if (v22)
    CFRelease(v22);
  return v25;
}

void sub_100027348(io_iterator_t a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  void (**v5)(id, _QWORD);

  v5 = a2;
  v3 = IOIteratorNext(a1);
  if ((_DWORD)v3)
  {
    v4 = v3;
    do
    {
      v5[2](v5, v4);
      IOObjectRelease(v4);
      v4 = IOIteratorNext(a1);
    }
    while ((_DWORD)v4);
  }

}

uint64_t sub_1000273B0(IONotificationPort *a1, const char *a2, uint64_t a3, void *a4)
{
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  id v14;
  id v15;
  void *v16;
  kern_return_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  io_iterator_t v23;
  id v24;
  char v26;
  io_iterator_t notification;

  v7 = a4;
  v13 = v7;
  notification = 0;
  if (a3)
  {
    v14 = objc_retainBlock(v7);
    v15 = sub_1000274B0(v14);
    v16 = (void *)objc_claimAutoreleasedReturnValue(v15);

    v17 = IOServiceAddMatchingNotification(a1, a2, (CFDictionaryRef)a3, (IOServiceMatchingCallback)sub_100027528, v16, &notification);
    if (v17)
    {
      sub_10001A7E4(0, "register_matching_notification", CFSTR("IOServiceAddMatchingNotification: 0x%08x"), v18, v19, v20, v21, v22, v17);
      a3 = 0;
    }
    else
    {
      v23 = notification;
      v24 = objc_retainBlock(v16);
      sub_100027348(v23, v24);

      a3 = 1;
    }
    v13 = v16;
  }
  else
  {
    sub_10001A7E4(0, "register_matching_notification", CFSTR("no matching dictionary"), v8, v9, v10, v11, v12, v26);
  }

  return a3;
}

id sub_1000274B0(void *a1)
{
  uint64_t v1;
  id v2;
  id v3;
  __CFSet *v4;
  id v5;

  v1 = qword_1001A80E0;
  v2 = a1;
  if (v1 != -1)
    dispatch_once(&qword_1001A80E0, &stru_10017AD50);
  v3 = objc_msgSend(v2, "copy");

  v4 = (__CFSet *)qword_1001A80D8;
  v5 = v3;
  CFSetAddValue(v4, v5);
  return v5;
}

void sub_100027528(void *a1, io_iterator_t a2)
{
  id v3;

  v3 = objc_retainBlock(a1);
  sub_100027348(a2, v3);

}

BOOL sub_100027564(IONotificationPort *a1, const char *a2, io_service_t a3, id a4)
{
  id v7;
  id v8;
  void *v9;
  kern_return_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  kern_return_t v16;
  io_object_t notification;

  notification = 0;
  v7 = objc_retainBlock(a4);
  v8 = sub_1000274B0(v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue(v8);

  v10 = IOServiceAddInterestNotification(a1, a3, a2, (IOServiceInterestCallback)sub_100027614, v9, &notification);
  v16 = v10;
  if (v10)
    sub_10001A7E4(0, "register_message_notification", CFSTR("IOServiceAddInterestNotification: 0x%08x"), v11, v12, v13, v14, v15, v10);

  return v16 == 0;
}

void sub_100027614(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void (**v7)(id, uint64_t, uint64_t, uint64_t);

  v7 = objc_retainBlock(a1);
  v7[2](v7, a2, a3, a4);

}

uint64_t sub_100027668(IONotificationPort *a1, const char *a2, uint64_t a3, uint64_t a4, char a5, void *a6)
{
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  id v17;
  id v18;
  id v19;
  void *v20;
  _QWORD v22[4];
  id v23;
  IONotificationPort *v24;
  uint64_t v25;
  char v26;

  v11 = a6;
  v17 = v11;
  if (a4)
  {
    v18 = objc_retainBlock(v11);
    v19 = sub_1000274B0(v18);
    v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472;
    v22[2] = sub_100027764;
    v22[3] = &unk_10017AD30;
    v26 = a5;
    v24 = a1;
    v25 = a3;
    v17 = v20;
    v23 = v17;
    a4 = sub_1000273B0(a1, a2, a4, v22);

  }
  else
  {
    sub_10001A7E4(0, "register_matching_message_notification", CFSTR("no matching dictionary"), v12, v13, v14, v15, v16, v22[0]);
  }

  return a4;
}

void sub_100027764(uint64_t a1, io_service_t a2)
{
  const __CFDictionary *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  io_iterator_t existing;

  existing = 0;
  if (*(_BYTE *)(a1 + 56))
  {
    v4 = IOServiceMatching("IOUSBDeviceInterface");
    if (IOServiceGetMatchingServices(kIOMasterPortDefault, v4, &existing))
      sub_10001A7E4(0, "register_matching_message_notification_block_invoke", CFSTR("Failed to get the IO service matching dictionary."), v5, v6, v7, v8, v9, v15);
    else
      sub_100027348(existing, &stru_10017AD08);
  }
  if (!sub_100027564(*(IONotificationPort **)(a1 + 40), *(const char **)(a1 + 48), a2, *(id *)(a1 + 32)))
    sub_10001A7E4(0, "register_matching_message_notification_block_invoke", CFSTR("register_matching_notification failed"), v10, v11, v12, v13, v14, v15);
}

void sub_100027818(id a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const __CFString *v12;
  const void *Value;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  char v21;
  CFMutableDictionaryRef properties;
  char v23;

  properties = 0;
  if (!a2)
  {
    sub_10001A7E4(0, "detect_connected_usb_host", CFSTR("Invalid input."), v2, v3, v4, v5, v6, v23);
    return;
  }
  if (IORegistryEntryCreateCFProperties(a2, &properties, kCFAllocatorDefault, 0))
  {
    v12 = CFSTR("Failed to create properties for IO service.");
LABEL_4:
    sub_10001A7E4(0, "detect_connected_usb_host", v12, v7, v8, v9, v10, v11, v21);
    goto LABEL_5;
  }
  Value = CFDictionaryGetValue(properties, CFSTR("USBDeviceFunction"));
  if (sub_100010BA8(Value))
  {
    if (CFEqual(Value, CFSTR("AppleUSBMux")) || CFEqual(Value, CFSTR("PTP")))
    {
      v14 = CFDictionaryGetValue(properties, CFSTR("IsActive"));
      if (sub_100010C10(v14))
      {
        if (CFEqual(v14, kCFBooleanTrue))
        {
          v20 = CFEqual(Value, CFSTR("AppleUSBMux"));
          if (v20)
            LOBYTE(v20) = 1;
          sub_100016D1C(v20);
        }
      }
      else
      {
        sub_10001A7E4(0, "detect_connected_usb_host", CFSTR("Invalid value: %@"), v15, v16, v17, v18, v19, (char)v14);
      }
    }
    goto LABEL_5;
  }
  if (Value)
  {
    v21 = (char)Value;
    v12 = CFSTR("Invalid value: %@");
    goto LABEL_4;
  }
LABEL_5:
  if (properties)
    CFRelease(properties);
}

CFBooleanRef sub_100027970()
{
  void *v0;
  unsigned int v1;
  const CFBooleanRef *v2;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"));
  v1 = objc_msgSend(v0, "isAppInstallationAllowed");

  v2 = &kCFBooleanFalse;
  if (!v1)
    v2 = &kCFBooleanTrue;
  return *v2;
}

CFBooleanRef sub_1000279C4()
{
  void *v0;
  unsigned int v1;
  const CFBooleanRef *v2;

  v0 = (void *)objc_claimAutoreleasedReturnValue(+[MCProfileConnection sharedConnection](MCProfileConnection, "sharedConnection"));
  v1 = objc_msgSend(v0, "isAppRemovalAllowed");

  v2 = &kCFBooleanFalse;
  if (!v1)
    v2 = &kCFBooleanTrue;
  return *v2;
}

void sub_100027A18(id a1)
{
  qword_1001A80D8 = (uint64_t)CFSetCreateMutable(0, 0, 0);
}

void sub_100027A40(uint64_t a1, const void *a2, const void *a3)
{
  __CFDictionary *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFDictionary *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFData *Value;
  const __CFDictionary *v19;
  const void *v20;
  uint64_t v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFString *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const void *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFData *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  __SecCertificate *v38;
  void *v39;
  id v40;
  id v41;
  __CFString *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  id v49;
  __CFString *v50;
  uint64_t v51;
  int v52;
  id v53;
  void *v54;
  __CFString *v55;
  void *v56;
  __CFString *v57;
  uint64_t v58;
  int v59;
  id v60;
  id v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  id v65;
  void *v66;
  id v67;
  void *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  SecKeyRef v72;
  __SecKey *v73;
  const __CFData *v74;
  int v75;
  BOOL v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  id v80;
  uint64_t v81;
  id v82;
  id v83;
  const void *v84;
  uint64_t v85;
  void *v86;
  __CFString *v87;
  uint64_t v88;
  id v89;
  void *v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  id v94;
  uint64_t v95;
  char v96;
  id v97;
  void *v98;
  __CFString *v99;
  id v100;
  __CFString *v101;
  uint64_t v102;
  int v103;
  id v104;
  id v105;
  uint64_t v106;
  const void *v107;
  id v108;
  CFErrorRef error;

  v6 = sub_1000042FC(CFSTR("ValidateAutomationRecord"));
  if (v6)
  {
    v10 = v6;
    if (!sub_100010BA8(a3) || (v14 = sub_100010B40(a2), !a1) || !v14)
    {
      v40 = sub_100010520((uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", 227, -3, 0, CFSTR("Invalid input(s)."), v11, v12, v13, v106);
      v41 = (id)objc_claimAutoreleasedReturnValue(v40);
      v42 = sub_100010878(v41);
      sub_100004354(1, (uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", v10, v42);
      if (!a1)
        goto LABEL_28;
      goto LABEL_27;
    }
    if (sub_1000047F4(*(_QWORD *)(a1 + 24)) == 5)
    {
      Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("SignedUDID"));
      if (sub_100010BDC(Value))
      {
        v19 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("PairRecord"));
        if (sub_100010B40(v19))
        {
          v20 = CFDictionaryGetValue(v19, CFSTR("HostID"));
          if (sub_100010BA8(v20))
          {
            error = 0;
            if (v19)
            {
              v23 = CFDictionaryGetValue(v19, CFSTR("DeviceCertificate"));
              if (sub_100010BDC(v23))
              {
                v27 = (const __CFString *)CFDictionaryGetValue(v19, CFSTR("HostID"));
                if (sub_100010BA8(v27))
                {
                  v28 = (const __CFDictionary *)sub_100015B64(v27);
                  if (v28)
                  {
                    v29 = v28;
                    v30 = CFDictionaryGetValue(v28, CFSTR("DeviceCertificate"));
                    if (sub_100010BDC(v30))
                    {
                      if (!CFEqual(v23, v30))
                      {
                        v101 = CFSTR("Host pairing record does not have a matching device certificate.");
                        v102 = 70;
                        v103 = -5;
LABEL_55:
                        v104 = sub_100010520((uint64_t)"copy_device_root_cert_for_host_record", v102, v103, 0, v101, v31, v32, v33, v106);
                        v39 = (void *)objc_claimAutoreleasedReturnValue(v104);
                        v38 = 0;
LABEL_56:
                        v61 = objc_retainAutorelease(v39);
                        CFRelease(v29);
LABEL_36:

                        v65 = v61;
                        if (!v38)
                        {
                          v83 = sub_100010520((uint64_t)"udid_signature_is_valid", 149, -5, v65, CFSTR("Failed to copy root cert matching host pair record."), v62, v63, v64, v106);
                          v84 = v20;
                          v85 = objc_claimAutoreleasedReturnValue(v83);

                          v86 = (void *)v85;
                          v20 = v84;
                          v82 = objc_retainAutorelease(v86);
                          v76 = 0;
LABEL_47:

                          v94 = v82;
                          if (v76)
                          {
                            v95 = sub_100028070(v19);
                            v108 = v94;
                            v96 = remotepairingAllowPromptlessPairing(v95, v20, &v108);
                            v41 = v108;

                            if ((v96 & 1) == 0)
                            {
                              v97 = sub_100010520((uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", 267, -1, v41, CFSTR("Failed to allowlist host for promptless RemotePairing."), v46, v47, v48, v106);
                              v98 = (void *)objc_claimAutoreleasedReturnValue(v97);

                              v99 = sub_100010878(v98);
                              sub_100004354(1, (uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", v10, v99);
                              v41 = v98;
                            }
                            goto LABEL_27;
                          }
                          v100 = sub_100010520((uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", 261, -5, v94, CFSTR("Failed to validate signature from host."), v91, v92, v93, v106);
                          v41 = (id)objc_claimAutoreleasedReturnValue(v100);

                          v54 = v41;
LABEL_26:
                          v55 = sub_100010878(v54);
                          sub_100004354(1, (uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", v10, v55);
LABEL_27:
                          sub_1000041C0(*(const __CFData **)(a1 + 24), v10, v43, v44, v45, v46, v47, v48, v106);
                          goto LABEL_28;
                        }
                        v66 = (void *)MGCopyAnswer(CFSTR("UniqueDeviceID"), 0);
                        v67 = sub_10001B244(v66);
                        v68 = (void *)objc_claimAutoreleasedReturnValue(v67);

                        if (v68)
                        {
                          v72 = SecCertificateCopyKey(v38);
                          if (v72)
                          {
                            v73 = v72;
                            v107 = v20;
                            v74 = (const __CFData *)objc_claimAutoreleasedReturnValue(objc_msgSend(v66, "dataUsingEncoding:", 4));
                            v75 = SecKeyVerifySignature(v73, kSecKeyAlgorithmRSASignatureDigestPKCS1v15Raw, v74, Value, &error);
                            v76 = v75 != 0;

                            if (!v75)
                            {
                              v80 = sub_100010520((uint64_t)"udid_signature_is_valid", 166, -5, error, CFSTR("Failed to validate signature."), v77, v78, v79, v106);
                              v81 = objc_claimAutoreleasedReturnValue(v80);

                              v65 = (id)v81;
                            }
                            v82 = objc_retainAutorelease(v65);
                            CFRelease(v73);
                            v20 = v107;
                            goto LABEL_46;
                          }
                          v87 = CFSTR("Failed to copy public key.");
                          v88 = 161;
                        }
                        else
                        {
                          v87 = CFSTR("Failed to query UDID.");
                          v88 = 155;
                        }
                        v89 = sub_100010520((uint64_t)"udid_signature_is_valid", v88, -1, 0, v87, v69, v70, v71, v106);
                        v90 = (void *)objc_claimAutoreleasedReturnValue(v89);

                        v82 = objc_retainAutorelease(v90);
                        v76 = 0;
LABEL_46:
                        CFRelease(v38);

                        goto LABEL_47;
                      }
                      v34 = (const __CFData *)CFDictionaryGetValue(v29, CFSTR("RootCertificate"));
                      if (sub_100010BDC(v34))
                      {
                        v38 = sub_100010210(v34);
                        if (v38)
                        {
                          v39 = 0;
                        }
                        else
                        {
                          v105 = sub_100010520((uint64_t)"copy_device_root_cert_for_host_record", 82, -5, 0, CFSTR("Failed to load PEM."), v35, v36, v37, v106);
                          v39 = (void *)objc_claimAutoreleasedReturnValue(v105);
                        }
                        goto LABEL_56;
                      }
                      v101 = CFSTR("Device pair record missing host certificate.");
                      v102 = 76;
                    }
                    else
                    {
                      v101 = CFSTR("Device pair record missing device certificate.");
                      v102 = 65;
                    }
                    v103 = -3;
                    goto LABEL_55;
                  }
                  v57 = CFSTR("Failed to load pair record for %@.");
                  v106 = (uint64_t)v27;
                  v58 = 59;
                  v59 = -7;
                }
                else
                {
                  v57 = CFSTR("Host pairing record is missing host id.");
                  v58 = 53;
                  v59 = -6;
                }
              }
              else
              {
                v57 = CFSTR("Host pair record missing device certificate.");
                v58 = 47;
                v59 = -3;
              }
              v60 = sub_100010520((uint64_t)"copy_device_root_cert_for_host_record", v58, v59, 0, v57, v24, v25, v26, v106);
              v56 = (void *)objc_claimAutoreleasedReturnValue(v60);
            }
            else
            {
              sub_10001A7E4(0, "copy_device_root_cert_for_host_record", CFSTR("Invalid inputs."), v21, v22, v15, v16, v17, v106);
              v56 = 0;
            }
            v61 = objc_retainAutorelease(v56);
            v38 = 0;
            goto LABEL_36;
          }
          v50 = CFSTR("Host pairing record is missing host id.");
          v51 = 255;
          v52 = -6;
LABEL_25:
          v53 = sub_100010520((uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", v51, v52, 0, v50, v15, v16, v17, v106);
          v54 = (void *)objc_claimAutoreleasedReturnValue(v53);
          v41 = v54;
          goto LABEL_26;
        }
        v50 = CFSTR("Request is missing the host's pair record.");
        v51 = 248;
      }
      else
      {
        v50 = CFSTR("Request is missing the signed UDID.");
        v51 = 240;
      }
      v52 = -3;
      goto LABEL_25;
    }
    v50 = CFSTR("Pairing upgrade is only supported over RSD.");
    v51 = 233;
    v52 = -4;
    goto LABEL_25;
  }
  v49 = sub_100010520((uint64_t)"handle_validate_pairing_and_enable_remotepairing_promptless_approval", 222, -1, 0, CFSTR("Failed to create response message."), v7, v8, v9, v106);
  v41 = (id)objc_claimAutoreleasedReturnValue(v49);
LABEL_28:

}

uint64_t sub_100028070(const __CFDictionary *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  const void *Value;
  const void *v7;
  uint64_t v8;
  __CFString *v9;
  uint64_t v10;
  int v11;
  id v12;
  uint64_t v14;

  v5 = objc_msgSend(objc_alloc((Class)NSData), "initWithBytes:length:", "-----BEGIN CERTIFICATE-----\nMIIDPTCCAiWgAwIBAgIBATANBgkqhkiG9w0BAQsFADBOMSkwJwYDVQQDDCBUZXN0\nIEF1dG9tYXRpb24gTG9ja2Rvd24gUm9vdCBDQTEUMBIGA1UECgwLQXBwbGUsIElu\nYy4xCzAJBgNVBAYTAlVTMB4XDTE3MDkyMTAxNDIyN1oXDTE3MDkyMjAxNDIyN1ow\nTjEpMCcGA1UEAwwgVGVzdCBBdXRvbWF0aW9uIExvY2tkb3duIFJvb3QgQ0ExFDAS\nBgNVBAoMC0FwcGxlLCBJbmMuMQswCQYDVQQGEwJVUzCCASIwDQYJKoZIhvcNAQEB\nBQADggEPADCCAQoCggEBALb4vJZBLlbrG9NE7BvAGf0WgNmgeHWKXEwM+HHTHM7x\n0gJunt5R6z+lb8lSH1/lz1VMwPV4mAoShObmLHhiYKfmdbeMzDmeOkGV6bJKNHxU\n854NJPd9e7yQkUlVXrkewsnmhRE1WytgGVpTns1JcKT7bFGiUGIFfX/l8ciLtGXA\nZ8rgeXzl2EUq62rOaNzLkHm1WAiUhWW3MU70MQXKFa3JbhLysa4XHxPqIzdmBe+N\nKHiMT3cLENYMQ/OSiIr1Ssa622+zTTaRHXT+ysc7smrgr2ZKaMY+a+oqJ00AMUJI\nXbEtMjLr5BPQqWPZSTThK2crxUwoTZuLg+PLYbApjrECAwEAAaMmMCQwEgYDVR0T\nAQH/BAgwBgEB/wIBADAOBgNVHQ8BAf8EBAMCAqQwDQYJKoZIhvcNAQELBQADggEB\nAD/1Hy7Sf6xE8nWiBy+ioOc7jXwWXNaRQb9lF8yAAFBtzRvkFKyN8LX+1QielIMx\n41Z8XTwv9ibhZF0ETlxZch9wduwL3wwKirBLbvqUJJ5XKW7hlUUXR7MC8trQFWIk\nntGLrtmcKSDWyWHu2eVPjJmQh+v6xetufq0u3TokqE/X+/fpPcu596mYRrovJY8g\np9gFmpAN8E4gqEfQUj9ak8aIces12cnOapL7ZHo0XHltLBBQd+4sLDO7JUlKAi2A\n"
         "SQxevep+SlLsUQYoAvr1CPxGkWuEBj/3oXhmk7EesJjDsnSnloMGoHVxxkRIipvr\n"
         "6TK70j9afDnOjNWRNmXMHLM=\n"
         "-----END CERTIFICATE-----\n",
         1184);
  if (!v5)
  {
    v9 = CFSTR("Failed to load automation root cert.");
    v10 = 111;
    v11 = -1;
LABEL_8:
    v12 = sub_100010520((uint64_t)"host_record_is_automation_record", v10, v11, 0, v9, v2, v3, v4, v14);

    v8 = 0;
    goto LABEL_9;
  }
  Value = CFDictionaryGetValue(a1, CFSTR("RootCertificate"));
  v7 = sub_100010BDC(Value);
  if (!v7)
  {
    v9 = CFSTR("Invalid root certificate.");
    v10 = 117;
    v11 = -3;
    goto LABEL_8;
  }
  if (!CFEqual(v7, v5))
  {
    v9 = CFSTR("Host pairing record is not for automation.");
    v10 = 122;
    v11 = -5;
    goto LABEL_8;
  }
  v8 = 1;
LABEL_9:

  return v8;
}

void sub_100028148(void *a1)
{
  id v1;
  __CFNotificationCenter *DarwinNotifyCenter;
  id v3;

  v1 = a1;
  DarwinNotifyCenter = CFNotificationCenterGetDarwinNotifyCenter();
  v3 = objc_msgSend(v1, "copy");

  CFNotificationCenterAddObserver(DarwinNotifyCenter, v3, (CFNotificationCallback)sub_1000281AC, kRemotePairingTrustedHostsUpdatedNotificationName, 0, CFNotificationSuspensionBehaviorDeliverImmediately);
}

void sub_1000281AC(int a1, id a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char v15;
  id v16;

  if (dword_1001A6AD0)
    sub_10001A7E4(0, "remotepairing_new_pairing_callback", CFSTR("New RemotePairing-based pairing established."), a4, a5, a6, a7, a8, v15);
  v9 = objc_retainBlock(a2);
  v16 = v9;
  if (v9)
    (*((void (**)(void))v9 + 2))();
  else
    sub_10001A7E4(0, "remotepairing_new_pairing_callback", CFSTR("Invalid input."), v10, v11, v12, v13, v14, v15);

}

SSLContext *sub_10002822C(int a1, const __CFData *a2, const __CFData *a3, const __CFData *a4, int a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFData *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFArray *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  SSLContext *v38;
  OSStatus v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  OSStatus v45;
  const void *LockdownPairing;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const __CFArray *v52;
  SSLContext *v53;
  const __CFString *v55;
  char v56;
  CFErrorRef error;
  CFArrayRef certs;
  CFTypeRef cf;
  SecTrustRef trust;
  void *values;
  SSLContextRef contextPtr;

  cf = 0;
  trust = 0;
  error = 0;
  certs = 0;
  contextPtr = 0;
  v14 = sub_100010210(a2);
  if (v14)
  {
    v15 = sub_100010260(a3);
    if (v15)
    {
      v21 = (const void *)v15;
      _SSLNewContext(a5 == 0, &contextPtr);
      if (contextPtr)
      {
        if (!SSLSetIOFuncs(contextPtr, (SSLReadFunc)sub_100028660, (SSLWriteFunc)sub_100028744)
          && !_SSLSetEnableCertVerify(contextPtr, 0)
          && (a5 || !SSLSetClientSideAuthenticate(contextPtr, kAlwaysAuthenticate)))
        {
          values = (void *)SecIdentityCreate(kCFAllocatorDefault, v14, v21);
          v27 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
          CFRelease(values);
          if (!SSLSetCertificate(contextPtr, v27))
          {
            if (!v27)
              goto LABEL_12;
            goto LABEL_10;
          }
          sub_10001A7E4(0, "lockssl_create_context", CFSTR("Could not set identity"), v28, v29, v30, v31, v32, v56);
          if (v27)
LABEL_10:
            CFRelease(v27);
        }
      }
      else
      {
        sub_10001A7E4(0, "lockssl_create_context", CFSTR("Could not create SSL context"), v22, v23, v24, v25, v26, v56);
      }
LABEL_12:
      CFRelease(v21);
      if (!v14)
        goto LABEL_14;
      goto LABEL_13;
    }
  }
  else
  {
    sub_10001A7E4(0, "lockssl_create_context", CFSTR("Could not decode certificate"), v9, v10, v11, v12, v13, v56);
    v21 = (const void *)sub_100010260(a3);
    if (v21)
      goto LABEL_12;
  }
  sub_10001A7E4(0, "lockssl_create_context", CFSTR("Could not decode private key"), v16, v17, v18, v19, v20, v56);
  if (v14)
LABEL_13:
    CFRelease(v14);
LABEL_14:
  v38 = contextPtr;
  if (contextPtr)
  {
    if (SSLSetProtocolVersionMin(contextPtr, kTLSProtocol1))
    {
      v55 = CFSTR("Could Not Set Minimum Protocol Version");
    }
    else
    {
      v39 = SSLSetConnection(v38, (SSLConnectionRef)a1);
      if (v39)
      {
        sub_10001A7E4(0, "lockssl_handshake", CFSTR("SSLSetConnection returned %ld"), v40, v41, v42, v43, v44, v39);
        goto LABEL_65;
      }
      SSLSetSessionOption(v38, (SSLSessionOption)(2 * (a5 == 0)), 1u);
      do
      {
        v45 = SSLHandshake(v38);
        if (v45 == -9841)
        {
          if (_SSLCopyPeerCertificates(v38, &certs))
          {
            v55 = CFSTR("SSLCopyPeerCertificates failed");
            goto LABEL_64;
          }
          LockdownPairing = (const void *)SecPolicyCreateLockdownPairing();
          if (SecTrustCreateWithCertificates(certs, LockdownPairing, &trust))
          {
            sub_10001A7E4(0, "lockssl_handshake", CFSTR("SecTrustCreateWithCertificates failed"), v47, v48, v49, v50, v51, v56);
LABEL_60:
            v53 = 0;
            goto LABEL_66;
          }
          cf = sub_100010210(a4);
          if (!cf)
            goto LABEL_60;
          v52 = CFArrayCreate(kCFAllocatorDefault, &cf, 1, &kCFTypeArrayCallBacks);
          if (SecTrustSetAnchorCertificates(trust, v52))
            goto LABEL_62;
          if (!SecTrustEvaluateWithError(trust, &error))
          {
            sub_10001A7E4(0, "lockssl_handshake", CFSTR("SecTrustEvalute failed"), v33, v34, v35, v36, v37, v56);
LABEL_62:
            v53 = 0;
            goto LABEL_38;
          }
          if (certs)
            CFRelease(certs);
          certs = 0;
          if (v52)
            CFRelease(v52);
          if (cf)
            CFRelease(cf);
          cf = 0;
          if (LockdownPairing)
            CFRelease(LockdownPairing);
          if (trust)
            CFRelease(trust);
          trust = 0;
          v45 = -9803;
        }
      }
      while (v45 == -9803);
      if (!v45)
      {
        LockdownPairing = 0;
        v52 = 0;
        v53 = v38;
        v38 = 0;
        goto LABEL_38;
      }
      v56 = v45;
      v55 = CFSTR("SSLHandshake returned %ld");
    }
  }
  else
  {
    v55 = CFSTR("Could not create ssl context");
  }
LABEL_64:
  sub_10001A7E4(0, "lockssl_handshake", v55, v33, v34, v35, v36, v37, v56);
LABEL_65:
  v53 = 0;
  LockdownPairing = 0;
LABEL_66:
  v52 = 0;
LABEL_38:
  if (certs)
    CFRelease(certs);
  certs = 0;
  if (v52)
    CFRelease(v52);
  if (cf)
    CFRelease(cf);
  cf = 0;
  if (LockdownPairing)
    CFRelease(LockdownPairing);
  if (trust)
    CFRelease(trust);
  trust = 0;
  if (error)
    CFRelease(error);
  error = 0;
  if (v38)
  {
    SSLClose(v38);
    _SSLDisposeContext(v38);
  }
  return v53;
}

uint64_t sub_100028660(int a1, char *a2, size_t *a3)
{
  size_t v6;
  size_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  ssize_t v20;
  uint64_t result;
  int v22;
  char v23;

  v6 = *a3;
  *a3 = 0;
  v7 = v6;
  while (1)
  {
    *__error() = -555;
    if (sub_100004A98(a1, v8, v9, v10, v11, v12, v13, v14))
    {
      sub_10001A7E4(0, "SocketRead", CFSTR("walk away"), v15, v16, v17, v18, v19, v23);
      goto LABEL_7;
    }
    v20 = recv(a1, a2, v7, 0);
    if (v20 <= 0)
      break;
    a2 += v20;
    v7 -= v20;
    if (!v7)
    {
      result = 0;
      goto LABEL_14;
    }
  }
  if (!v20)
  {
    result = 4294957491;
    goto LABEL_14;
  }
  v22 = *__error();
  result = 4294957493;
  if (v22 != 2 && v22 != 35)
  {
    if (v22 != 54)
    {
      result = 4294967260;
      goto LABEL_14;
    }
LABEL_7:
    result = 4294957490;
  }
LABEL_14:
  *a3 = v6 - v7;
  return result;
}

uint64_t sub_100028744(int __fd, uint64_t a2, unint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  ssize_t v8;
  uint64_t result;
  int v10;
  unsigned int v11;

  v6 = 0;
  v7 = *a3;
  *a3 = 0;
  while (1)
  {
    v8 = write(__fd, (const void *)(a2 + v6), v7 - v6);
    if (v8 < 1)
      break;
    v6 += v8;
    if (v6 >= v7)
    {
      result = 0;
      goto LABEL_11;
    }
  }
  v10 = *__error();
  if (v10 == 32)
    v11 = -9806;
  else
    v11 = -36;
  if (v10 == 35)
    result = 4294957493;
  else
    result = v11;
LABEL_11:
  *a3 = v6;
  return result;
}

CFBooleanRef sub_1000287D8()
{
  void *v0;
  const CFBooleanRef *v1;
  CFBooleanRef v2;

  v0 = (void *)MAEGetActivationStateWithError(0);
  if ((objc_msgSend(v0, "isEqualToString:", kMAActivationStateActivated) & 1) != 0
    || objc_msgSend(v0, "isEqualToString:", kMAActivationStateFactoryActivated))
  {
    v1 = &kCFBooleanFalse;
  }
  else
  {
    v1 = &kCFBooleanTrue;
  }
  v2 = *v1;

  return v2;
}

uint64_t sub_100028848()
{
  return MAEGetActivationStateWithError(0);
}

void sub_100028850(const __CFString *a1)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char __str[1024];
  char v19[1024];
  char buffer[1024];

  v1 = (char)a1;
  if (CFStringGetCString(a1, buffer, 1024, 0x8000100u))
  {
    sub_10000816C(v19);
    snprintf(__str, 0x400uLL, "%s%s/%s.plist", v19, "/Library/Lockdown/escrow_records", buffer);
    sub_10001A7E4(0, "destroy_escrow_record", CFSTR("Destroying escrow bag for %s"), v7, v8, v9, v10, v11, (char)buffer);
    if (unlink(__str) == -1 && *__error() != 2)
    {
      v12 = __error();
      strerror(*v12);
      sub_10001A7E4(0, "destroy_escrow_record", CFSTR("Could not unlink %s: %s"), v13, v14, v15, v16, v17, (char)__str);
      sub_100025DA4(__str);
    }
  }
  else
  {
    sub_10001A7E4(0, "destroy_escrow_record", CFSTR("CFStringGetCString failure for %@"), v2, v3, v4, v5, v6, v1);
  }
}

uint64_t sub_100028980()
{
  char __str[1024];
  char v2[1024];

  sub_10000816C(v2);
  snprintf(__str, 0x400uLL, "%s%s", v2, "/Library/Lockdown/escrow_records");
  return sub_100026060((uint64_t)__str);
}

id sub_100028A04(void *a1, _QWORD *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFDictionary *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const void *Value;
  void *v12;
  id v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  uint64_t v24;
  uint64_t v25;
  char __str[1024];
  char v27[1024];

  v3 = a1;
  if (MKBDeviceUnlockedSinceBoot() == 1)
  {
    sub_10000816C(v27);
    snprintf(__str, 0x400uLL, "%s%s/%s.plist", v27, "/Library/Lockdown/escrow_records", (const char *)objc_msgSend(objc_retainAutorelease(v3), "UTF8String"));
    v7 = (const __CFDictionary *)sub_100025818(__str);
    if (sub_100010B40(v7))
    {
      Value = CFDictionaryGetValue(v7, CFSTR("BagBag"));
      v12 = (void *)objc_claimAutoreleasedReturnValue(Value);
      v13 = sub_10001B1F0(v12);
      v14 = (void *)objc_claimAutoreleasedReturnValue(v13);

      if (v14)
      {
        v18 = v12;
        v19 = 0;
        v12 = v18;
        goto LABEL_11;
      }
      v22 = sub_100010520((uint64_t)"copy_escrow_key", 177, -3, 0, CFSTR("Escrow key is missing from escrow record."), v15, v16, v17, v25);
      v19 = (id)objc_claimAutoreleasedReturnValue(v22);
    }
    else
    {
      v21 = sub_100010520((uint64_t)"copy_escrow_key", 171, -9, 0, CFSTR("Failed to load escrow record."), v8, v9, v10, v25);
      v19 = (id)objc_claimAutoreleasedReturnValue(v21);
      v12 = 0;
    }
  }
  else
  {
    v20 = sub_100010520((uint64_t)"copy_escrow_key", 161, -8, 0, CFSTR("Escrow records are not available before first unlock."), v4, v5, v6, v24);
    v19 = (id)objc_claimAutoreleasedReturnValue(v20);
    v12 = 0;
    v7 = 0;
  }
  v18 = 0;
  if (a2 && v19)
  {
    v19 = objc_retainAutorelease(v19);
    v18 = 0;
    *a2 = v19;
  }
LABEL_11:
  if (v7)
    CFRelease(v7);

  return v18;
}

const void *sub_100028BD8(const __CFDictionary *a1)
{
  const void *result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v8 = 0;
  result = CFDictionaryGetValue(a1, CFSTR("HostID"));
  if (result)
  {
    sub_100028C10((uint64_t)result, (uint64_t)&v8, v2, v3, v4, v5, v6, v7);
    return (const void *)v8;
  }
  return result;
}

uint64_t sub_100028C10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  char v12;
  _QWORD block[7];
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;

  v14 = 0;
  v15 = &v14;
  v16 = 0x2020000000;
  v17 = -1;
  if (qword_1001A80F0 != -1)
  {
    dispatch_once(&qword_1001A80F0, &stru_10017AD70);
    if (a2)
      goto LABEL_3;
LABEL_7:
    sub_10001A7E4(0, "_create_escrow_bag", CFSTR("Invalid input."), a4, a5, a6, a7, a8, v12);
    goto LABEL_8;
  }
  if (!a2)
    goto LABEL_7;
LABEL_3:
  if (!a1 || !qword_1001A80E8)
    goto LABEL_7;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100028DF4;
  block[3] = &unk_10017A950;
  block[4] = &v14;
  block[5] = a1;
  block[6] = a2;
  dispatch_sync((dispatch_queue_t)qword_1001A80E8, block);
LABEL_8:
  v10 = *((unsigned int *)v15 + 6);
  _Block_object_dispose(&v14, 8);
  return v10;
}

void sub_100028D04(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

const __CFString *sub_100028D1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v8;
  const void *Value;
  uint64_t v10;
  int v11;
  const __CFString *v13;
  char v14;
  uint64_t v15;

  v15 = 0;
  if (!a1)
  {
    v13 = CFSTR("Can't create escrow bag without connection");
    goto LABEL_11;
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    v13 = CFSTR("Can't create escrow bag without session");
    goto LABEL_10;
  }
  v8 = *(const __CFDictionary **)(a1 + 40);
  if (!v8 || (Value = CFDictionaryGetValue(v8, CFSTR("HostID"))) == 0)
  {
    v13 = CFSTR("Can't determine host ID of connection");
LABEL_10:
    LODWORD(a1) = 0;
LABEL_11:
    sub_10001A7E4(a1, "create_escrow_bag", v13, a4, a5, a6, a7, a8, v14);
    return 0;
  }
  v11 = sub_100028C10((uint64_t)Value, (uint64_t)&v15, v10, a4, a5, a6, a7, a8);
  if (!v11)
    return (const __CFString *)v15;
  if (v11 == -2)
    return CFSTR("DEVICE_LOCKED");
  return 0;
}

void sub_100028DC8(id a1)
{
  dispatch_queue_t v1;
  void *v2;

  v1 = dispatch_queue_create("com.apple.mobile.lockdownd.escrow", 0);
  v2 = (void *)qword_1001A80E8;
  qword_1001A80E8 = (uint64_t)v1;

}

void sub_100028DF4(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFDataRef v7;
  CFDataRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  CFTypeRef v15;
  BOOL v16;
  const __CFString *v17;
  CFMutableDictionaryRef v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFMutableDictionaryRef v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  int v32;
  int *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFString *v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int *v46;
  char v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const char *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  char *v72;
  CFTypeRef cf;
  uint64_t v74;
  stat v75;
  _OWORD bytes[2];
  char buffer[1024];
  char __str[1024];
  char v79[1024];

  cf = 0;
  v74 = 0;
  memset(bytes, 0, sizeof(bytes));
  if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes))
  {
    sub_10001A7E4(0, "_create_escrow_bag_block_invoke_2", CFSTR("Failed to create key."), v2, v3, v4, v5, v6, v71);
    v7 = 0;
    goto LABEL_28;
  }
  v8 = CFDataCreate(0, (const UInt8 *)bytes, 32);
  v7 = v8;
  if (!v8)
  {
    v14 = CFSTR("Failed to create data.");
LABEL_27:
    sub_10001A7E4((int)v8, "_create_escrow_bag_block_invoke_2", v14, v9, v10, v11, v12, v13, v71);
    goto LABEL_28;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = MKBKeyBagCreateEscrow(v8, &v74);
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
  {
    v71 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v14 = CFSTR("Failed to create escrow bag: %d");
LABEL_26:
    LODWORD(v8) = 0;
    goto LABEL_27;
  }
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = MKBKeyBagCopyData(v74, &cf);
  v15 = cf;
  if (*(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    v16 = 1;
  else
    v16 = cf == 0;
  if (v16)
  {
    v71 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
    v14 = CFSTR("Failed to copy bag data: %d");
    goto LABEL_26;
  }
  v17 = *(const __CFString **)(a1 + 40);
  bzero(v79, 0x400uLL);
  bzero(__str, 0x400uLL);
  bzero(buffer, 0x400uLL);
  memset(&v75, 0, sizeof(v75));
  v18 = sub_100025A4C();
  if (!v18)
  {
    sub_10001A7E4(0, "store_escrow_record", CFSTR("Failed to create dictionary."), v19, v20, v21, v22, v23, v71);
LABEL_25:
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = -6;
    v14 = CFSTR("Failed to store escrow record.");
    goto LABEL_26;
  }
  v24 = v18;
  sub_10000816C(v79);
  snprintf(__str, 0x400uLL, "%s%s", v79, "/Library/Lockdown/escrow_records");
  if (mkdir(__str, 0x1EDu) && *__error() != 17)
  {
    v40 = __error();
    strerror(*v40);
    sub_10001A7E4(0, "store_escrow_record", CFSTR("Could not mkdir %s : %s"), v41, v42, v43, v44, v45, (char)__str);
    sub_100025DA4(__str);
    goto LABEL_24;
  }
  v30 = sub_10002616C(__str, 256, 0x4000, v25, v26, v27, v28, v29);
  if (v30 == -1)
  {
    v46 = __error();
    v47 = strerror(*v46);
    sub_10001A7E4(0, "store_escrow_record", CFSTR("Could not open escrow dir: %s"), v48, v49, v50, v51, v52, v47);
    sub_100025D10(__str);
    goto LABEL_24;
  }
  v31 = v30;
  if (fcntl(v30, 64, 3))
  {
    v32 = *__error();
    v33 = __error();
    strerror(*v33);
    LOBYTE(v72) = v32;
    v39 = CFSTR("Couldn't set escrow dir to class C: %d (%s)");
LABEL_19:
    sub_10001A7E4(0, "store_escrow_record", v39, v34, v35, v36, v37, v38, (char)v72);
LABEL_20:
    close(v31);
LABEL_24:
    CFRelease(v24);
    goto LABEL_25;
  }
  CFDictionaryAddValue(v24, CFSTR("HostID"), v17);
  CFDictionaryAddValue(v24, CFSTR("BagBag"), v15);
  if (!CFStringGetCString(v17, buffer, 1024, 0x8000100u))
  {
    sub_10001A7E4(0, "store_escrow_record", CFSTR("Failed to get C string (%@)."), v53, v54, v55, v56, v57, (char)v17);
    goto LABEL_20;
  }
  snprintf(__str, 0x400uLL, "%s%s/%s.plist", v79, "/Library/Lockdown/escrow_records", buffer);
  v58 = stat(__str, &v75);
  v64 = "Creating";
  if (!v58)
    v64 = "Replacing";
  sub_10001A7E4(0, "store_escrow_record", CFSTR("%s escrow bag for %s"), v59, v60, v61, v62, v63, (char)v64);
  if (sub_1000255E4((uint64_t)__str, (uint64_t)v24, v65, v66, v67, v68, v69, v70))
  {
    v72 = __str;
    v39 = CFSTR("Failed to store %s.");
    goto LABEL_19;
  }
  close(v31);
  CFRelease(v24);
  **(_QWORD **)(a1 + 48) = CFRetain(v7);
LABEL_28:
  if (v74)
    MKBKeyBagRelease();
  if (v7)
    CFRelease(v7);
  if (cf)
    CFRelease(cf);
}

uint64_t sub_100029244()
{
  if (qword_1001A8130 != -1)
    dispatch_once(&qword_1001A8130, &stru_10017ADB0);
  return byte_1001A8110;
}

void sub_100029284(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  if (qword_1001A8130 != -1)
    dispatch_once(&qword_1001A8130, &stru_10017ADB0);
  if (byte_1001A8108 == 1)
  {
    if (byte_1001A8112)
      v9 = (uint64_t *)&kCFBooleanTrue;
    else
      v9 = (uint64_t *)&kCFBooleanFalse;
    sub_10000E484(a1, 0, (uint64_t)CFSTR("TelephonyCapability"), *v9, a5, a6, a7, a8);
    sub_10000E484(a1, 0, (uint64_t)CFSTR("DeviceClass"), qword_1001A8100, v10, v11, v12, v13);
    sub_10000E484(a1, 0, (uint64_t)CFSTR("ProductType"), qword_1001A80F8, v14, v15, v16, v17);
  }
}

uint64_t sub_10002935C()
{
  if (qword_1001A8130 != -1)
    dispatch_once(&qword_1001A8130, &stru_10017ADB0);
  return byte_1001A8112;
}

BOOL sub_10002939C()
{
  if (qword_1001A8130 != -1)
    dispatch_once(&qword_1001A8130, &stru_10017ADB0);
  return dword_1001A8128 == 1;
}

void sub_1000293E4(id a1)
{
  const __CFString *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const __CFString *v7;
  CFTypeID v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  const char *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char v44;
  size_t v45;
  char __s[16];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;

  v1 = (const __CFString *)CFPreferencesCopyValue(CFSTR("MachineHack"), CFSTR("com.apple.mobile.lockdownd"), kCFPreferencesCurrentUser, kCFPreferencesCurrentHost);
  if (v1)
  {
    v7 = v1;
    byte_1001A8108 = 1;
    v8 = CFGetTypeID(v1);
    if (v8 != CFStringGetTypeID()
      || CFStringCompare(v7, CFSTR("n78"), 1uLL) && CFStringCompare(v7, CFSTR("iPod5,1"), 1uLL))
    {
      sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("MachineHack value of '%@' is not supported; assuming %@"),
        v9,
        v10,
        v11,
        v12,
        v13,
        (char)v7);
    }
    CFRelease(v7);
  }
  if ((byte_1001A8108 & 1) != 0)
    goto LABEL_12;
  v14 = (const __CFString *)MGCopyAnswer(CFSTR("ProductType"), 0);
  qword_1001A80F8 = (uint64_t)v14;
  if (v14 && CFStringFind(v14, CFSTR("iFPGA"), 1uLL).location != -1)
  {
    sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("This is an FPGA, faking out product type as %@"), v2, v3, v4, v5, v6, (char)CFSTR("n78"));
    byte_1001A8108 = 1;
    byte_1001A8110 = 1;
    CFRelease((CFTypeRef)qword_1001A80F8);
    qword_1001A80F8 = 0;
  }
  if (byte_1001A8108 == 1)
  {
LABEL_12:
    sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("Overriding machine type with %@ (%@)"), v2, v3, v4, v5, v6, (char)CFSTR("n78"));
    qword_1001A80F8 = (uint64_t)CFSTR("iPod5,1");
    qword_1001A8100 = (uint64_t)CFSTR("iPod");
    byte_1001A8112 = 0;
    v15 = byte_1001A8110;
    byte_1001A8118 = byte_1001A8110;
    v16 = -1;
    dword_1001A8120 = -1;
  }
  else
  {
    byte_1001A8112 = sub_1000297B0((uint64_t)CFSTR("HasBaseband"));
    byte_1001A8118 = sub_1000297B0((uint64_t)CFSTR("ShouldHactivate"));
    dword_1001A8120 = sub_100029818("IODeviceTree:/baseband", CFSTR("class"));
    v16 = sub_100029818("IODeviceTree:/product", CFSTR("lockdown-certtype"));
    v15 = byte_1001A8118;
  }
  dword_1001A8128 = v16;
  if (v15)
    goto LABEL_21;
  v52 = 0u;
  v53 = 0u;
  v50 = 0u;
  v51 = 0u;
  v48 = 0u;
  v49 = 0u;
  *(_OWORD *)__s = 0u;
  v47 = 0u;
  v45 = 128;
  if (sysctlbyname("hw.model", __s, &v45, 0, 0) == -1)
  {
    sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("Could not lookup hardware model"), v17, v18, v19, v20, v21, v44);
  }
  else
  {
    v22 = strlen(__s);
    v45 = v22;
    if (v22 >= 3 && !strncmp(&__s[v22 - 3], "DEV", 3uLL))
    {
      sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("This is some kinda dev board: %s"), v23, v24, v25, v26, v27, (char)__s);
      byte_1001A8118 = 1;
      goto LABEL_21;
    }
  }
  if (byte_1001A8118)
  {
LABEL_21:
    if (sub_1000263E8())
    {
      sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("we are overriding hactivation"), v28, v29, v30, v31, v32, v44);
      byte_1001A8118 = 0;
    }
    else
    {
      sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("no hactivation override detected"), v28, v29, v30, v31, v32, v44);
    }
  }
  sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("product_type: %@\n"), v23, v24, v25, v26, v27, qword_1001A80F8);
  if (byte_1001A8112)
    v38 = "true";
  else
    v38 = "false";
  sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("has_telephony: %s, should_hactivate: %s"), v33, v34, v35, v36, v37, (char)v38);
  sub_10001A7E4(0, "get_device_type_internal_block_invoke", CFSTR("baseband_class: %d, cert_type %d"), v39, v40, v41, v42, v43, dword_1001A8120);
}

BOOL sub_1000297B0(uint64_t a1)
{
  const __CFBoolean *v1;
  const __CFBoolean *v2;
  CFTypeID v3;
  _BOOL8 v4;

  v1 = (const __CFBoolean *)MGCopyAnswer(a1, 0);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFGetTypeID(v1);
  v4 = v3 == CFBooleanGetTypeID() && CFBooleanGetValue(v2) != 0;
  CFRelease(v2);
  return v4;
}

uint64_t sub_100029818(char *path, const __CFString *a2)
{
  io_registry_entry_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  io_object_t v9;
  CFTypeRef CFProperty;
  CFTypeID v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = IORegistryEntryFromPath(kIOMasterPortDefault, path);
  if (v3 && (v9 = v3, CFProperty = IORegistryEntryCreateCFProperty(v3, a2, 0, 0), IOObjectRelease(v9), CFProperty))
  {
    v11 = CFGetTypeID(CFProperty);
    if (v11 == CFDataGetTypeID() && CFDataGetLength((CFDataRef)CFProperty) == 4)
    {
      v17 = *(unsigned int *)CFDataGetBytePtr((CFDataRef)CFProperty);
    }
    else
    {
      sub_10001A7E4(0, "getDeviceTreeInt", CFSTR("value for %@ property of %s is invalid (%@)"), v12, v13, v14, v15, v16, (char)a2);
      v17 = 0xFFFFFFFFLL;
    }
    CFRelease(CFProperty);
  }
  else
  {
    sub_10001A7E4(0, "getDeviceTreeInt", CFSTR("no %@ property of %s"), v4, v5, v6, v7, v8, (char)a2);
    return 0xFFFFFFFFLL;
  }
  return v17;
}

uint64_t sub_100029910(void *a1, uint64_t a2, dispatch_queue_t *a3, char *a4)
{
  id v7;
  dispatch_queue_global_t global_queue;
  void *v9;
  NSObject **v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  id v19;
  void *v20;
  void *v21;
  id v22;
  uint64_t v23;
  void *v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _UNKNOWN **v32;
  id v33;
  void *v34;
  unsigned int v35;
  id v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  id v42;
  unsigned int v43;
  const char *v44;
  uint64_t v45;
  xpc_object_t v46;
  char v47;
  char v48;
  void *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  id v56;
  id v57;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  xpc_object_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  char v71;
  unsigned int v72;
  char *string;
  uint64_t v74;
  id v75;
  void *v76;
  _QWORD v77[4];
  id v78;
  uint64_t v79;
  dispatch_queue_t *v80;

  v7 = a1;
  global_queue = dispatch_get_global_queue(0, 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
  v10 = sub_100019FC0(a3, (uint64_t)v7);
  v11 = sub_10001B244(v7);
  v12 = objc_claimAutoreleasedReturnValue(v11);
  if (!v12
    || (v18 = (void *)v12,
        v19 = sub_10001B2EC(v10),
        v20 = (void *)objc_claimAutoreleasedReturnValue(v19),
        v20,
        v18,
        !v20))
  {
    sub_10001A7E4(0, "register_remote_service_for_lockdown_service", CFSTR("Service ark contains unexpected types."), v13, v14, v15, v16, v17, v71);
    goto LABEL_7;
  }
  v21 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("OmitFromRSD")));
  v22 = sub_10001B298(v21);
  v23 = objc_claimAutoreleasedReturnValue(v22);
  if (v23)
  {
    v24 = (void *)v23;
    v25 = objc_msgSend(v21, "BOOLValue");

    if (v25)
    {
      sub_10001A7E4(0, "register_remote_service_for_lockdown_service", CFSTR("Omitting service '%@' from registration with RSD."), v26, v27, v28, v29, v30, (char)v7);

LABEL_20:
      v31 = 1;
      goto LABEL_21;
    }
  }
  v32 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue(objc_msgSend(v10, "objectForKeyedSubscript:", CFSTR("ExposedToUntrustedDevices")));
  v33 = sub_10001B298(v32);
  v34 = (void *)objc_claimAutoreleasedReturnValue(v33);

  if (!v34)
  {

    v32 = &off_10019BEA0;
  }
  v35 = objc_msgSend(v32, "BOOLValue");
  v36 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("%@.shim.remote"));
  if (!v36)
  {
    sub_10001A7E4(0, "register_remote_service_for_lockdown_service", CFSTR("Failed to allocate string."), v37, v38, v39, v40, v41, (char)v7);

    goto LABEL_7;
  }
  v76 = v21;
  v74 = a2;
  v75 = objc_retainAutorelease(v36);
  v42 = objc_msgSend(v75, "UTF8String");
  v43 = v35;
  if (v35)
    v44 = "com.apple.mobile.lockdown.remote.untrusted";
  else
    v44 = "com.apple.mobile.lockdown.remote.trusted";
  v45 = xpc_copy_event("com.apple.remoted.service", v42);
  if (v45)
  {
    v46 = (xpc_object_t)v45;
    v47 = 0;
    v48 = 1;
  }
  else
  {
    v72 = v43;
    string = (char *)v44;
    v46 = xpc_dictionary_create(0, 0, 0);
    if (v46)
    {
      v64 = xpc_dictionary_create(0, 0, 0);
      v49 = v76;
      if (v64)
      {
        v70 = v64;
        xpc_dictionary_set_BOOL(v64, "UsesRemoteXPC", 0);
        xpc_dictionary_set_string(v46, "RequireEntitlement", string);
        xpc_dictionary_set_value(v46, "ServiceProperties", v70);
        if (v72)
          xpc_dictionary_set_BOOL(v46, "ExposedToUntrustedDevices", 1);
        xpc_set_event("com.apple.remoted.service", v42, v46);

        v48 = 1;
        v47 = 1;
      }
      else
      {
        sub_10001A7E4(0, "register_service_with_rsd", CFSTR("Failed to allocate XPC dictionary."), v65, v66, v67, v68, v69, (char)v7);
        v48 = 0;
        v47 = 0;
      }
      v50 = v75;
      if (!a4)
        goto LABEL_18;
      goto LABEL_17;
    }
    sub_10001A7E4(0, "register_service_with_rsd", CFSTR("Failed to allocate XPC dictionary."), v59, v60, v61, v62, v63, (char)v7);
    v48 = 0;
    v47 = 0;
  }
  v50 = v75;
  v49 = v76;
  if (a4)
LABEL_17:
    *a4 = v47;
LABEL_18:

  if ((v48 & 1) != 0)
  {
    v56 = objc_retainAutorelease(v50);
    v57 = objc_msgSend(v56, "UTF8String");
    v77[0] = _NSConcreteStackBlock;
    v77[1] = 3221225472;
    v77[2] = sub_100029CD8;
    v77[3] = &unk_10017ADD8;
    v78 = v7;
    v79 = v74;
    v80 = a3;
    remote_service_listen_with_device(v57, v9, v77);

    goto LABEL_20;
  }
  sub_10001A7E4(0, "register_remote_service_for_lockdown_service", CFSTR("Failed to register remote service: %@"), v51, v52, v53, v54, v55, (char)v50);

LABEL_7:
  v31 = 0;
LABEL_21:

  return v31;
}

void sub_100029CD8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  id v9;
  int type;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  __CFString *v24;
  id v25;
  void *v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  void *v30;
  __CFString *v31;
  const __CFString *v32;
  char v33;
  id v34;
  id v35;
  CFTypeRef cf;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;

  v5 = a2;
  v6 = *(_QWORD *)(a1 + 40);
  v7 = *(_QWORD *)(a1 + 48);
  v8 = *(id *)(a1 + 32);
  v9 = v5;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  cf = 0;
  type = remote_device_get_type(v9);
  v11 = objc_alloc_init((Class)NSMutableDictionary);
  v17 = v11;
  if (!v11)
  {
    v32 = CFSTR("Failed to create dictionary.");
LABEL_15:
    sub_10001A7E4((int)v11, "handle_connection_for_rsd_lockdown_service", v32, v12, v13, v14, v15, v16, v33);
    v26 = 0;
    v24 = 0;
    goto LABEL_16;
  }
  objc_msgSend(v11, "setObject:forKeyedSubscript:", v8, CFSTR("Service"));
  sub_100010D34(a3);
  if ((sub_100010DC4(a3) & 1) == 0)
  {
    v32 = CFSTR("Failed to turn on keepalive.");
    LODWORD(v11) = 0;
    goto LABEL_15;
  }
  if (sub_10002A66C((uint64_t)&v37, v9, v7, v6, a3))
  {
    v34 = 0;
    v35 = 0;
    v23 = sub_10002A7AC(*((int **)&v38 + 1), &v35, &v34, v18, v19, v20, v21, v22);
    v24 = (__CFString *)v35;
    v25 = v34;
    v26 = v25;
    if (v23)
    {
      if (!v25)
        goto LABEL_8;
      if (type == 13)
      {
        objc_msgSend(v17, "setObject:forKeyedSubscript:", v25, CFSTR("EscrowBag"));
LABEL_8:
        v27 = (void *)sub_10001F560((uint64_t)&v37, v17, v24, a3, (__CFDictionary **)&cf, v20, v21, v22);
        if (v27)
        {
          v30 = v27;
          v31 = (__CFString *)objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:", CFSTR("Failed to spawn lockdown service '%@': %@"), v8, v27);

          if (!v31)
            goto LABEL_21;
          if (cf && *((_QWORD *)&v38 + 1))
            sub_100004C98(*((const __CFData **)&v38 + 1), cf, v29, v18, v19, v20, v21, v22);
          goto LABEL_20;
        }
LABEL_16:
        v31 = 0;
        goto LABEL_21;
      }
      v31 = CFSTR("Unlocking with escrow bag requires trusted connection to host.");
    }
    else
    {
      v31 = CFSTR("RSD checkin failed.");
    }
  }
  else
  {
    v24 = 0;
    v26 = 0;
    v31 = CFSTR("Initializing connection state failed.");
  }
LABEL_20:
  sub_10001A7E4(0, "handle_connection_for_rsd_lockdown_service", CFSTR("Lockdown remote service shim error: %@"), v18, v19, v20, v21, v22, (char)v31);
  close(a3);
LABEL_21:
  if (cf)
    CFRelease(cf);
  cf = 0;
  sub_100022174((uint64_t)&v37, v28, v29, v18, v19, v20, v21, v22);

}

uint64_t sub_100029F1C()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  dispatch_semaphore_t v5;
  dispatch_queue_global_t global_queue;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  char v15;
  _QWORD v16[4];
  NSObject *v17;

  v5 = dispatch_semaphore_create(0);
  if (v5)
  {
    global_queue = dispatch_get_global_queue(0, 0);
    v12 = objc_claimAutoreleasedReturnValue(global_queue);
    if (v12)
    {
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_10002A00C;
      v16[3] = &unk_10017AE00;
      v13 = v5;
      v17 = v13;
      remote_device_browse_present(0xFFFFLL, v12, v16);

      dispatch_semaphore_wait(v13, 0xFFFFFFFFFFFFFFFFLL);
      v12 = 1;
    }
    else
    {
      sub_10001A7E4(0, "refresh_remote_services", CFSTR("Failed to create queue."), v7, v8, v9, v10, v11, v15);
    }
  }
  else
  {
    sub_10001A7E4(0, "refresh_remote_services", CFSTR("Failed to create semaphore."), v0, v1, v2, v3, v4, v15);
    v12 = 0;
  }

  return v12;
}

void sub_10002A00C(uint64_t a1, void *a2, int a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  char name;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;

  v5 = a2;
  v11 = v5;
  if (a3)
  {
    sub_10001A7E4(0, "refresh_remote_services_block_invoke", CFSTR("Done resetting remote devices."), v6, v7, v8, v9, v10, v18);
    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }
  else if ((remote_device_reset(v5) & 1) != 0)
  {
    name = remote_device_get_name(v11);
    sub_10001A7E4(0, "refresh_remote_services_block_invoke", CFSTR("Reset remote device %s"), v13, v14, v15, v16, v17, name);
  }
  else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
  {
    sub_1000F9A30();
  }

}

BOOL sub_10002A0C0(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  dispatch_queue_global_t global_queue;
  void *v10;
  id v11;
  id v13;
  uint64_t v15[5];
  _QWORD v16[5];

  if (a1)
  {
    global_queue = dispatch_get_global_queue(0, 0);
    v10 = (void *)objc_claimAutoreleasedReturnValue(global_queue);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_10002A1CC;
    v16[3] = &unk_10017AE20;
    v16[4] = a1;
    remote_service_listen_with_device("com.apple.mobile.lockdown.remote.trusted", v10, v16);
    v15[0] = (uint64_t)_NSConcreteStackBlock;
    v15[1] = 3221225472;
    v15[2] = (uint64_t)sub_10002A4C8;
    v15[3] = (uint64_t)&unk_10017AE20;
    v15[4] = a1;
    remote_service_listen_with_device("com.apple.mobile.lockdown.remote.untrusted", v10, v15);

    v11 = 0;
  }
  else
  {
    v13 = sub_100010520((uint64_t)"lockdown_rsd_setup", 482, -2, 0, CFSTR("Invalid argument(s)."), a6, a7, a8, v15[0]);
    v11 = (id)objc_claimAutoreleasedReturnValue(v13);
    if (a2)
    {
      v11 = objc_retainAutorelease(v11);
      *a2 = v11;
    }
  }

  return a1 != 0;
}

uint64_t sub_10002A1CC(uint64_t a1, void *a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = sub_10002A238(a2, a3, *(uint64_t **)(a1 + 32), 1);
  if ((result & 1) == 0)
  {
    sub_10001A7E4(0, "lockdown_rsd_setup_block_invoke", CFSTR("Failed to process trusted remote connection on socket %d."), v5, v6, v7, v8, v9, a3);
    return close(a3);
  }
  return result;
}

uint64_t sub_10002A238(void *a1, int a2, uint64_t *a3, int a4)
{
  id v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  dispatch_queue_global_t global_queue;
  NSObject *v23;
  uint64_t v24;
  const __CFString *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char v34;
  _QWORD block[7];
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  uint64_t (*v39)(uint64_t, uint64_t);
  void (*v40)(uint64_t);
  id v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  const char *v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  const __CFString *v51;
  const __CFString *v52;

  v7 = a1;
  v42 = 0;
  v43 = &v42;
  v44 = 0x6810000000;
  v46 = 0u;
  v47 = 0u;
  v48 = 0u;
  v49 = 0u;
  v45 = "";
  v50 = 0;
  v36 = 0;
  v37 = &v36;
  v38 = 0x3032000000;
  v39 = sub_10002AA60;
  v40 = sub_10002AA70;
  v41 = 0;
  sub_100010C44(a2);
  sub_100010CBC(a2);
  sub_100010D34(a2);
  if ((sub_100010DC4(a2) & 1) == 0)
  {
    v25 = CFSTR("Failed to turn on keepalive.");
LABEL_10:
    sub_10001A7E4(0, "handle_lockdown_remote_service", v25, v8, v9, v10, v11, v12, v34);
    sub_100022174((uint64_t)(v43 + 4), v26, v27, v28, v29, v30, v31, v32);
    v24 = 0;
    goto LABEL_11;
  }
  if (!sub_10002A66C((uint64_t)(v43 + 4), v7, a3[1], *a3, a2))
  {
    v25 = CFSTR("Initializing connection state failed.");
    goto LABEL_10;
  }
  if ((sub_10002A7AC((int *)v43[7], 0, 0, v8, v9, v10, v11, v12) & 1) == 0)
  {
    v25 = CFSTR("RSD checkin failed.");
    goto LABEL_10;
  }
  v51 = CFSTR("Request");
  v52 = CFSTR("StartService");
  v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v52, &v51, 1));
  sub_100004C98((const __CFData *)v43[7], v13, v14, v15, v16, v17, v18, v19);
  if (a4)
    v43[10] = (uint64_t)sub_10001111C();
  v20 = os_transaction_create("com.apple.mobile.lockdownd");
  v21 = (void *)v37[5];
  v37[5] = v20;

  global_queue = dispatch_get_global_queue(0, 0);
  v23 = objc_claimAutoreleasedReturnValue(global_queue);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10002AA78;
  block[3] = &unk_10017AC20;
  block[4] = &v42;
  block[5] = &v36;
  block[6] = a3;
  dispatch_async(v23, block);

  v24 = 1;
LABEL_11:
  _Block_object_dispose(&v36, 8);

  _Block_object_dispose(&v42, 8);
  return v24;
}

void sub_10002A49C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_10002A4C8(uint64_t a1, void *a2, int a3)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = sub_10002A238(a2, a3, *(uint64_t **)(a1 + 32), 0);
  if ((result & 1) == 0)
  {
    sub_10001A7E4(0, "lockdown_rsd_setup_block_invoke_2", CFSTR("Failed to process untrusted remote connection on socket %d."), v5, v6, v7, v8, v9, a3);
    return close(a3);
  }
  return result;
}

id sub_10002A534(void *a1, _QWORD *a2)
{
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t name;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v15;
  id v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  id v20;
  uint64_t v21;
  id v22;
  uint64_t v24;
  id v25;

  v3 = a1;
  if (MKBDeviceUnlockedSinceBoot() == 1)
  {
    name = remote_device_get_name(v3);
    if (!name)
    {
      sub_10001A7E4(0, "copy_escrow_secret_for_remote_device", CFSTR("Failed to get remote device name."), v8, v9, v10, v11, v12, v24);
      v16 = 0;
      v15 = 0;
      goto LABEL_10;
    }
    v13 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", name));
    v25 = 0;
    v14 = RemotePairingCopyRemoteUnlockDeviceKeyForTunnel(v13, &v25);
    v15 = (void *)objc_claimAutoreleasedReturnValue(v14);
    v16 = v25;

    if (!v15)
    {
      v20 = sub_100010628((uint64_t)"copy_escrow_secret_for_remote_device", 539, -1, v16, CFSTR("Failed to copy remote unlock key from RemotePairingDevice."), v17, v18, v19, v24);
      v21 = objc_claimAutoreleasedReturnValue(v20);

      v16 = (id)v21;
    }
  }
  else
  {
    v22 = sub_100010520((uint64_t)"copy_escrow_secret_for_remote_device", 527, -8, 0, CFSTR("Device has not been unlocked since boot."), v4, v5, v6, v24);
    v16 = (id)objc_claimAutoreleasedReturnValue(v22);
    v15 = 0;
  }
  if (a2 && v16)
  {
    v16 = objc_retainAutorelease(v16);
    *a2 = v16;
  }
LABEL_10:

  return v15;
}

uint64_t sub_10002A66C(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  id v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  id v16;
  int v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  const __CFString *v31;
  char type;

  v9 = a2;
  v15 = v9;
  if (!a1 || !a3 || !a4 || a5 < 0)
  {
    sub_10001A7E4(0, "init_rsd_conn_state", CFSTR("Invalid argument(s)."), v10, v11, v12, v13, v14, type);
    if (!a1)
      goto LABEL_18;
    goto LABEL_17;
  }
  *(_QWORD *)a1 = a4;
  *(_QWORD *)(a1 + 8) = a3;
  v16 = v9;
  *(_DWORD *)(a1 + 56) = -1;
  *(_QWORD *)(a1 + 64) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 32) = v16;
  if (((uint64_t (*)(void))remote_device_get_type)() == 9
    || remote_device_get_type(v16) == 13)
  {
    v17 = 5;
  }
  else
  {
    if (remote_device_get_type(v16) != 7)
    {
      type = remote_device_get_type(v16);
      v31 = CFSTR("Unexpected remote device type: %d");
      LODWORD(v18) = 0;
      goto LABEL_16;
    }
    v17 = 6;
  }
  *(_DWORD *)(a1 + 16) = v17;
  v18 = sub_100004744();
  *(_QWORD *)(a1 + 24) = v18;
  if (!v18)
  {
    v31 = CFSTR("Failed to create connection object.");
LABEL_16:
    sub_10001A7E4((int)v18, "init_rsd_conn_state", v31, v19, v20, v21, v22, v23, type);
LABEL_17:
    sub_100022174(a1, v24, v25, v26, v27, v28, v29, v30);
    a1 = 0;
    goto LABEL_18;
  }
  sub_10000476C((uint64_t)v18, a5, *(_DWORD *)(a1 + 16));
  a1 = 1;
LABEL_18:

  return a1;
}

uint64_t sub_10002A7AC(int *a1, _QWORD *a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v11;
  id v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  id v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  id v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  id v34;
  id v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  void *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  const __CFString *v56;
  char v58;
  const __CFString *v59;
  const __CFString *v60;

  if (!a1)
  {
    sub_10001A7E4(0, "rsd_client_checkin", CFSTR("Invalid input."), a4, a5, a6, a7, a8, v58);
    v55 = 0;
    v34 = 0;
    v20 = 0;
    v42 = 0;
    v13 = 0;
    v11 = 0;
    goto LABEL_18;
  }
  v11 = sub_100004E6C(a1, (uint64_t)a2, (uint64_t)a3, a4, a5, a6, a7, a8);
  v12 = sub_10001B2EC(v11);
  v13 = (void *)objc_claimAutoreleasedReturnValue(v12);

  if (!v13)
  {
    v56 = CFSTR("Failed to receive message.");
LABEL_14:
    sub_10001A7E4(0, "rsd_client_checkin", v56, v14, v15, v16, v17, v18, v58);
    v55 = 0;
    v34 = 0;
    v20 = 0;
LABEL_17:
    v42 = 0;
    goto LABEL_18;
  }
  v13 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v11, "objectForKeyedSubscript:", CFSTR("Request")));
  v19 = sub_10001B244(v13);
  v20 = (void *)objc_claimAutoreleasedReturnValue(v19);

  if (!v20)
  {
    sub_10001A7E4(0, "rsd_client_checkin", CFSTR("Invalid or missing request key: %@"), v21, v22, v23, v24, v25, (char)CFSTR("Request"));
LABEL_16:
    v55 = 0;
    v34 = 0;
    goto LABEL_17;
  }
  if ((objc_msgSend(v13, "isEqual:", CFSTR("RSDCheckin")) & 1) == 0)
  {
    v58 = (char)v13;
    v56 = CFSTR("Unexpected message type: %@");
    goto LABEL_14;
  }
  v20 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v11, "objectForKeyedSubscript:", CFSTR("Label")));
  v26 = sub_10001B244(v20);
  v27 = (void *)objc_claimAutoreleasedReturnValue(v26);

  if (!v27)
  {
    sub_10001A7E4(0, "rsd_client_checkin", CFSTR("Invalid or missing request key: %@"), v28, v29, v30, v31, v32, (char)CFSTR("Label"));
    goto LABEL_16;
  }
  v33 = (void *)objc_claimAutoreleasedReturnValue(-[__CFDictionary objectForKeyedSubscript:](v11, "objectForKeyedSubscript:", CFSTR("EscrowBag")));
  v34 = v33;
  if (v33)
  {
    v35 = sub_10001B1F0(v33);
    v36 = (void *)objc_claimAutoreleasedReturnValue(v35);

    if (!v36)
    {
      sub_10001A7E4(0, "rsd_client_checkin", CFSTR("Invalid request key: %@"), v37, v38, v39, v40, v41, (char)CFSTR("EscrowBag"));
      v55 = 0;
      goto LABEL_17;
    }
  }
  v59 = CFSTR("Request");
  v60 = CFSTR("RSDCheckin");
  v42 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v60, &v59, 1));
  v49 = sub_100004C98((const __CFData *)a1, v42, v43, v44, v45, v46, v47, v48);
  if (v49)
  {
    sub_10001A7E4(0, "rsd_client_checkin", CFSTR("Failed to send message: %d"), v50, v51, v52, v53, v54, v49);
    v55 = 0;
  }
  else
  {
    if (a2)
      *a2 = objc_retainAutorelease(v20);
    if (a3)
    {
      v34 = objc_retainAutorelease(v34);
      *a3 = v34;
    }
    v55 = 1;
  }
LABEL_18:

  return v55;
}

uint64_t sub_10002AA60(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10002AA70(uint64_t a1)
{

}

void sub_10002AA78(uint64_t a1)
{
  void *v2;
  dispatch_time_t v3;
  dispatch_queue_global_t global_queue;
  NSObject *v5;
  _QWORD block[5];

  v2 = objc_autoreleasePoolPush();
  sub_100024F80(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 32, *(uint64_t **)(a1 + 48));
  v3 = dispatch_time(0, 10000000000);
  global_queue = dispatch_get_global_queue(0, 0);
  v5 = objc_claimAutoreleasedReturnValue(global_queue);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10002AB3C;
  block[3] = &unk_10017A178;
  block[4] = *(_QWORD *)(a1 + 40);
  dispatch_after(v3, v5, block);

  objc_autoreleasePoolPop(v2);
}

void sub_10002AB3C(uint64_t a1)
{
  uint64_t v1;
  void *v2;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  v2 = *(void **)(v1 + 40);
  *(_QWORD *)(v1 + 40) = 0;

}

uint64_t sub_10002AC7C(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  const __CFString *v10;
  char v12;

  if (a1 && (v8 = *a1) != 0)
  {
    sub_10000E484(v8, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiPairing"), (uint64_t)kCFBooleanTrue, a5, a6, a7, a8);
    v9 = 1;
    v10 = CFSTR("Wireless pairing enabled.");
  }
  else
  {
    v9 = 0;
    v10 = CFSTR("Invalid input.");
  }
  sub_10001A7E4(0, "advertise_wireless_pairing", v10, a4, a5, a6, a7, a8, v12);
  return v9;
}

uint64_t sub_10002ACF8(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  const __CFString *v10;
  char v12;

  if (a1 && (v8 = *a1) != 0)
  {
    sub_10000EFB4(v8, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiPairing"), a4, a5, a6, a7, a8);
    v9 = 1;
    v10 = CFSTR("Wireless pairing disabled.");
  }
  else
  {
    v9 = 0;
    v10 = CFSTR("Invalid input.");
  }
  sub_10001A7E4(0, "stop_advertising_wireless_pairing", v10, a4, a5, a6, a7, a8, v12);
  return v9;
}

void sub_10002AD68(uint64_t *a1, void *a2, const __CFString *a3, int a4, void *a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  CFMutableDictionaryRef v14;
  const __CFString *v15;
  const __CFString *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __CFDictionary *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  id v28;
  __CFDictionary *v29;
  CFMutableDictionaryRef v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  CFMutableDictionaryRef v37;
  const __CFString *v38;
  void *v39;
  __CFString **v40;
  __CFString *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  const __CFDictionary *v54;
  const void *v55;
  const void *v56;
  _BOOL4 v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  void *v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  const __CFString *v80;
  __CFString **v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  const void *v87;
  CFDataRef v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  const __CFString *v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  const __CFString *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  id v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  void *v127;
  char v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  const __CFString *v133;
  char v134;
  char v135;
  void *v136;
  const __CFDictionary *v137;
  _BOOL4 v138;
  char v139;
  uint64_t *v140;
  __int16 v141;
  void *value;
  const __CFString *v143;
  void *v144;

  v14 = a5;
  value = 0;
  v141 = 0;
  if (a3)
    v15 = a3;
  else
    v15 = CFSTR("unknown");
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "handle_pair", CFSTR("Preparing to pair for %@ %s."), v9, v10, v11, v12, v13, (char)v15);
  if (a4)
    v16 = CFSTR("PairCU");
  else
    v16 = CFSTR("Pair");
  v22 = sub_1000042FC(v16);
  if (!v22)
  {
    v30 = v14;
    sub_10001A7E4(0, "handle_pair", CFSTR("Failed to create response message."), v17, v18, v19, v20, v21, v134);
    v36 = 0;
    v14 = 0;
    a1 = 0;
    v29 = 0;
    v37 = 0;
    goto LABEL_121;
  }
  v139 = (char)v15;
  v140 = a1;
  if (!sub_100010B40(a2))
  {
    v30 = v14;
    v38 = CFSTR("Invalid message.");
LABEL_19:
    sub_10001A7E4(0, "handle_pair", v38, v23, v24, v25, v26, v27, v134);
    v14 = 0;
LABEL_20:
    v29 = 0;
    goto LABEL_21;
  }
  if (!a1)
  {
    v30 = v14;
    sub_10001A7E4(0, "handle_pair", CFSTR("Invalid input."), v23, v24, v25, v26, v27, v134);
    v14 = 0;
    v29 = 0;
    goto LABEL_23;
  }
  if (!a4)
  {
    v29 = 0;
    goto LABEL_30;
  }
  if (!v14)
  {
    v30 = 0;
    sub_10001A7E4(0, "handle_pair", CFSTR("Invalid pairing session."), v23, v24, v25, v26, v27, v134);
    goto LABEL_20;
  }
  v28 = sub_10002B834(v14, a2);
  if (!v28)
  {
    v30 = v14;
    v38 = CFSTR("Failed to decrypt message.");
    goto LABEL_19;
  }
  a2 = v28;
  v29 = sub_100025A4C();
  if (!v29)
  {
    v30 = v14;
    sub_10001A7E4(0, "handle_pair", CFSTR("Failed to create response dictionary."), v23, v24, v25, v26, v27, v134);
    v14 = 0;
LABEL_21:
    a1 = 0;
LABEL_23:
    v39 = 0;
    v36 = 0;
LABEL_24:
    v40 = off_10017B868;
LABEL_25:
    v41 = *v40;
    goto LABEL_26;
  }
LABEL_30:
  if (dword_1001A6AD0)
    sub_10001A7E4(0, "handle_pair", CFSTR("Pair message: %@"), v23, v24, v25, v26, v27, (char)a2);
  v54 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("PairingOptions"));
  if (sub_100010B40(v54) && (v55 = CFDictionaryGetValue(v54, CFSTR("ExtendedPairingErrors")), sub_100010C10(v55)))
  {
    v56 = CFDictionaryGetValue(v54, CFSTR("ExtendedPairingErrors"));
    v57 = CFEqual(v56, kCFBooleanTrue) != 0;
  }
  else
  {
    v57 = 0;
  }
  v58 = (void *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("PairRecord"));
  if (!sub_100010B40(v58))
  {
    v30 = v14;
    sub_10001A7E4(0, "handle_pair", CFSTR("Invalid pair record."), v59, v60, v61, v62, v63, v134);
    v14 = 0;
    a1 = 0;
    v39 = 0;
    v36 = 0;
    v40 = off_10017B938;
    goto LABEL_25;
  }
  v138 = v57;
  v36 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v58, "objectForKeyedSubscript:", CFSTR("HostID")));
  if (!v36)
  {
    v30 = v14;
    sub_10001A7E4(0, "handle_pair", CFSTR("Pair record missing host ID."), v64, v65, v66, v67, v68, v134);
    v14 = 0;
    a1 = 0;
    v39 = 0;
LABEL_52:
    v40 = off_10017B858;
    goto LABEL_25;
  }
  v137 = (const __CFDictionary *)v58;
  v69 = (void *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("HostName"));
  v70 = v69;
  if (v69 && !sub_100010BA8(v69))
  {
    v30 = v14;
    v80 = CFSTR("Invalid host name.");
LABEL_68:
    sub_10001A7E4(0, "handle_pair", v80, v71, v72, v73, v74, v75, v134);
    v14 = 0;
    a1 = 0;
    v39 = 0;
    goto LABEL_24;
  }
  v136 = v70;
  v76 = (void *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("SerialNumber"));
  v77 = v76;
  if (v76 && !sub_100010BA8(v76))
  {
    v30 = v14;
    v80 = CFSTR("Invalid serial number.");
    goto LABEL_68;
  }
  v78 = (void *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("MarketingName"));
  v79 = v78;
  if (v78 && !sub_100010BA8(v78))
  {
    v30 = v14;
    v80 = CFSTR("Invalid marketing name.");
    goto LABEL_68;
  }
  if (sub_1000047F4(a1[3]) == 1 || sub_1000047F4(a1[3]) == 2)
    sub_100017294(v137);
  if (sub_100026A70())
  {
    v30 = v14;
    v14 = 0;
    a1 = 0;
    v39 = 0;
    v40 = off_10017B888;
    goto LABEL_70;
  }
  if (sub_1000047F4(a1[3]) != 1 && sub_1000047F4(a1[3]) != 5)
  {
    v30 = v14;
    v14 = 0;
    a1 = 0;
    v39 = 0;
    v40 = off_10017B968;
    goto LABEL_25;
  }
  if ((sub_100026EA4((uint64_t)v54, *a1, a1[8], (_BYTE *)&v141 + 1, &v141) & 1) == 0)
  {
    v30 = v14;
    v14 = 0;
    a1 = 0;
    v39 = 0;
    v40 = off_10017B890;
LABEL_70:
    if (!v138)
      v40 = off_10017B8A8;
    goto LABEL_25;
  }
  if ((_BYTE)v141)
  {
    v30 = v14;
    v81 = off_10017B898;
    if (!v138)
      v81 = off_10017B8A8;
    v41 = *v81;
    v14 = sub_100025A4C();
    if (v14)
    {
      v87 = (const void *)a1[8];
      if (v87)
        CFRelease(v87);
      a1[8] = 0;
      v88 = sub_100026FEC(0x400uLL);
      a1[8] = (uint64_t)v88;
      if (v88)
      {
        CFDictionaryAddValue(v14, CFSTR("PairingChallenge"), v88);
        CFDictionarySetValue(v22, CFSTR("ExtendedResponse"), v14);
LABEL_80:
        a1 = 0;
        v39 = 0;
        goto LABEL_26;
      }
      v94 = CFSTR("Failed to create random challenge.");
    }
    else
    {
      v94 = CFSTR("Failed to create dictionary.");
    }
    sub_10001A7E4(0, "handle_pair", v94, v82, v83, v84, v85, v86, v134);
    goto LABEL_80;
  }
  if (HIBYTE(v141) || (MGGetBoolAnswer(CFSTR("HasSpringBoard")) & 1) == 0 && !sub_100004480() && !sub_1000044E0())
  {
LABEL_75:
    if (sub_1000168EC(v137))
    {
      v30 = v14;
      sub_10001A7E4(0, "handle_pair", CFSTR("Invalid pairing record."), v89, v90, v91, v92, v93, v134);
      v14 = 0;
      a1 = 0;
      v39 = 0;
      v40 = off_10017B940;
      goto LABEL_25;
    }
    v39 = (void *)sub_100028BD8(v137);
    if (v39)
    {
      if (a4)
      {
        CFDictionarySetValue(v29, CFSTR("EscrowBag"), v39);
LABEL_96:
        a1 = (uint64_t *)MGCopyAnswer(CFSTR("re6Zb+zwFKJNlkQTUeT+/w"), 0);
        if (!sub_100010BA8(a1))
        {
          v30 = v14;
          sub_10001A7E4(0, "handle_pair", CFSTR("Failed to query udid."), v105, v106, v107, v108, v109, v134);
          v14 = 0;
          goto LABEL_24;
        }
        CFDictionarySetValue(v29, CFSTR("UDID"), a1);
        v110 = sub_10002BB14(v14, v29, (CFTypeRef *)&value);
        if (!v110 || !value)
        {
          v30 = v14;
          v133 = CFSTR("Failed to encrypt response.");
LABEL_135:
          sub_10001A7E4(0, "handle_pair", v133, v111, v112, v113, v114, v115, v134);
          v14 = 0;
          goto LABEL_52;
        }
        CFDictionarySetValue(v22, CFSTR("Payload"), v110);
        CFDictionarySetValue(v22, CFSTR("Nonce"), value);
LABEL_106:
        if (sub_100016234(*v140, v137, v136, v77, v79))
        {
          v30 = v14;
          sub_10001A7E4(0, "handle_pair", CFSTR("Failed to store pairing record."), v122, v123, v124, v125, v126, v134);
          v14 = 0;
          v40 = off_10017B948;
          goto LABEL_25;
        }
        sub_1000110EC(CFSTR("com.apple.mobile.lockdown.host_paired"));
        if (!a4)
        {
          v30 = v14;
          sub_10001E2CC((NSObject **)*v140, 1);
          sub_100016AA4();
          goto LABEL_117;
        }
        v143 = CFSTR("HostID");
        v144 = v36;
        v127 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v144, &v143, 1));
        v30 = v14;
        v128 = sub_100015EBC(v14, v127);

        if ((v128 & 1) != 0)
        {
          sub_10001E2CC((NSObject **)*v140, 1);
          sub_100016AA4();
          sub_10000E484(*v140, (uint64_t)CFSTR("com.apple.mobile.wireless_lockdown"), (uint64_t)CFSTR("EnableWifiDebugging"), (uint64_t)kCFBooleanTrue, v129, v130, v131, v132);
LABEL_117:
          v37 = 0;
          goto LABEL_118;
        }
        v133 = CFSTR("Failed to update SRP pairing record.");
        goto LABEL_135;
      }
      CFDictionarySetValue(v22, CFSTR("EscrowBag"), v39);
    }
    else if (a4)
    {
      goto LABEL_96;
    }
    a1 = 0;
    goto LABEL_106;
  }
  v95 = MKBGetDeviceLockState(0);
  if ((v95 - 1) < 2)
  {
    v103 = (uint64_t)v15;
    v30 = v14;
    v104 = (const __CFString *)sub_1000172B8((uint64_t)a1, v103, (uint64_t)v136, 1);
    if (v104)
    {
      v41 = (__CFString *)v104;
      if (CFStringCompare(v104, CFSTR("UserDeniedPairing"), 0) == kCFCompareEqualTo)
      {
        v14 = 0;
        a1 = 0;
        v37 = 0;
        goto LABEL_27;
      }
    }
LABEL_112:
    v14 = 0;
    a1 = 0;
    v39 = 0;
    v40 = off_10017B8A8;
    goto LABEL_25;
  }
  if (!v95)
    goto LABEL_100;
  if (v95 != 3)
  {
    v30 = v14;
    sub_10001A7E4(0, "handle_pair", CFSTR("Unknown lock state (%d), disallowing pairing."), v98, v99, v100, v101, v102, v95);
    goto LABEL_112;
  }
  if (a4)
  {
    v30 = v14;
    sub_10001A7E4(0, "handle_pair", CFSTR("Wireless pairing requires a passcode to be set."), v98, v99, v100, v101, v102, v134);
    v14 = 0;
    a1 = 0;
    v39 = 0;
    v40 = off_10017B988;
    goto LABEL_25;
  }
LABEL_100:
  if ((sub_100027234(*a1, v96, v97, v98, v99, v100, v101, v102) & 1) == 0)
  {
    sub_10001A7E4(0, "handle_pair", CFSTR("Buddy has not completed. Implicitly trusting host."), v116, v117, v118, v119, v120, v134);
    goto LABEL_75;
  }
  v121 = sub_1000172B8((uint64_t)a1, (uint64_t)v15, (uint64_t)v136, 0);
  if (!v121)
    goto LABEL_75;
  v30 = v14;
  v14 = 0;
  if (v138)
  {
    v41 = (__CFString *)v121;
    a1 = 0;
    v37 = 0;
LABEL_27:
    sub_10001A7E4(0, "handle_pair", CFSTR("Pair for %@ failed %s: %@"), v31, v32, v33, v34, v35, v139);
    CFDictionaryRemoveValue(v22, CFSTR("Payload"));
    sub_100004354(1, (uint64_t)"handle_pair", v22, v41);
    if (v36)
    {
      sub_100015CA8((uint64_t)v36, 0);
      sub_100015104((uint64_t)v36, 0, v48, v49, v50, v51, v52, v53);
    }
    goto LABEL_119;
  }
  v41 = CFSTR("PasswordProtected");
  a1 = 0;
  v39 = 0;
LABEL_26:
  v37 = v14;
  v14 = (CFMutableDictionaryRef)v39;
  if (v41)
    goto LABEL_27;
LABEL_118:
  sub_10001A7E4(0, "handle_pair", CFSTR("Pair for %@ succeeded %s."), v31, v32, v33, v34, v35, v139);
  v14 = (CFMutableDictionaryRef)v39;
LABEL_119:
  if (v140)
  {
    sub_1000041C0((const __CFData *)v140[3], v22, v42, v43, v44, v45, v46, v47, v135);
    v22 = 0;
  }
LABEL_121:
  if (value)
    CFRelease(value);
  value = 0;
  if (a1)
    CFRelease(a1);
  if (v14)
    CFRelease(v14);
  if (v22)
    CFRelease(v22);
  if (v29)
    CFRelease(v29);
  if (v37)
    CFRelease(v37);

}

id sub_10002B834(void *a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  id v8;
  id v9;
  void *v10;
  id v11;
  const UInt8 *BytePtr;
  CFIndex Length;
  id v14;
  id v15;
  char *v16;
  const __CFString *v17;
  char *v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  id v26;
  void *v27;
  void *v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  id v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  char v42;
  id v43;
  _OWORD v44[2];

  v8 = a1;
  memset(v44, 0, sizeof(v44));
  if (!v8 || !a2)
  {
    v17 = CFSTR("Invalid input(s)");
    goto LABEL_8;
  }
  v9 = objc_msgSend(a2, "objectForKey:", CFSTR("Payload"));
  v10 = (void *)sub_100010BDC(v9);
  if (!v10)
  {
    v17 = CFSTR("Invalid payload.");
    goto LABEL_15;
  }
  v11 = objc_msgSend(a2, "objectForKey:", CFSTR("Nonce"));
  v10 = (void *)sub_100010BDC(v11);
  if (!v10)
  {
    v17 = CFSTR("Invalid nonce.");
    goto LABEL_15;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)v11);
  Length = CFDataGetLength((CFDataRef)v11);
  v14 = objc_retainAutorelease(v9);
  v15 = objc_msgSend(v14, "bytes");
  v16 = (char *)objc_msgSend(v14, "length");
  if ((unint64_t)v16 > 0xF)
  {
    v18 = v16 - 16;
    v10 = malloc_type_malloc((size_t)(v16 - 16), 0xB98C0829uLL);
    if (!v10)
    {
      v17 = CFSTR("Failed to allocate memory.");
      goto LABEL_15;
    }
    v19 = v10;
    if (objc_msgSend(v8, "deriveKeyWithSaltPtr:saltLen:infoPtr:infoLen:keyLen:outputKeyPtr:", "WriteKeySaltMDLD", 16, "WriteKeyInfoMDLD", 16, 32, v44))
    {
      v25 = CFSTR("Failed to derive readKey.");
    }
    else
    {
      v42 = (char)v18;
      if (!CryptoAEADDecryptMessageOneShot(kCryptoAEADDescriptorChaCha20Poly1305, v44, 32, BytePtr, Length, 0, 0, v15))
      {
        v28 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v19, v18));
        if (v28)
        {
          v43 = 0;
          v27 = (void *)objc_claimAutoreleasedReturnValue(+[NSPropertyListSerialization propertyListWithData:options:format:error:](NSPropertyListSerialization, "propertyListWithData:options:format:error:", v28, 0, 0, &v43));
          v26 = v43;
          v35 = sub_10001B2EC(v27);
          v36 = (void *)objc_claimAutoreleasedReturnValue(v35);

          if (!v36)
            sub_10001A7E4(0, "doDecryptCUOneShotMessage", CFSTR("Failed to create message: %@"), v37, v38, v39, v40, v41, (char)v26);
          goto LABEL_21;
        }
        sub_10001A7E4(0, "doDecryptCUOneShotMessage", CFSTR("Failed to convert data."), v30, v31, v32, v33, v34, (char)v18);
LABEL_20:
        v27 = 0;
        v26 = 0;
LABEL_21:
        free(v19);
        goto LABEL_16;
      }
      v25 = CFSTR("Failed to decrypt message.");
    }
    sub_10001A7E4(0, "doDecryptCUOneShotMessage", v25, v20, v21, v22, v23, v24, v42);
    v28 = 0;
    goto LABEL_20;
  }
  v17 = CFSTR("ciphertext is too short.");
LABEL_8:
  LODWORD(v10) = 0;
LABEL_15:
  sub_10001A7E4((int)v10, "doDecryptCUOneShotMessage", v17, v3, v4, v5, v6, v7, v42);
  v26 = 0;
  v27 = 0;
  v28 = 0;
LABEL_16:

  return v27;
}

id sub_10002BB14(void *a1, void *a2, CFTypeRef *a3)
{
  id v5;
  id v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  id v18;
  id v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFString *v26;
  void *v27;
  const __CFString *v28;
  void *v29;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  const __CFData *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const __CFData *v40;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  char v53;
  uint64_t v54;
  _OWORD v55[2];

  v5 = a1;
  v6 = a2;
  memset(v55, 0, sizeof(v55));
  sub_10001A7E4(0, "doEncryptCUOneShotMessage", CFSTR("response_payload : %@"), v7, v8, v9, v10, v11, (char)v6);
  if (!v5 || !v6)
  {
    v28 = CFSTR("Invalid input(s)");
    LODWORD(v17) = 0;
LABEL_9:
    sub_10001A7E4((int)v17, "doEncryptCUOneShotMessage", v28, v12, v13, v14, v15, v16, v53);
    v18 = 0;
    goto LABEL_10;
  }
  v17 = (void *)sub_1000043DC(v6);
  if (!v17)
  {
    v28 = CFSTR("Failed to convert payload to binary blob.");
    goto LABEL_9;
  }
  v18 = objc_retainAutorelease(v17);
  v19 = objc_msgSend(v18, "bytes");
  v20 = (char *)objc_msgSend(v18, "length");
  if (objc_msgSend(v5, "deriveKeyWithSaltPtr:saltLen:infoPtr:infoLen:keyLen:outputKeyPtr:", "ReadKeySaltMDLD", 15, "ReadKeyInfoMDLD", 15, 32, v55))
  {
    v26 = CFSTR("Failed to derive writeKey.");
    LODWORD(v27) = 0;
LABEL_6:
    sub_10001A7E4((int)v27, "doEncryptCUOneShotMessage", v26, v21, v22, v23, v24, v25, v53);
LABEL_10:
    v29 = 0;
    goto LABEL_11;
  }
  v27 = malloc_type_malloc((size_t)(v20 + 16), 0xACBBE341uLL);
  if (!v27)
  {
    v26 = CFSTR("Failed to allocate memory.");
    goto LABEL_6;
  }
  v33 = v27;
  v34 = (const __CFData *)sub_10000D778(0xCu, v31, v32, v21, v22, v23, v24, v25);
  if (!v34)
  {
    sub_10001A7E4(0, "doEncryptCUOneShotMessage", CFSTR("Failed to create nonce."), v35, v36, v37, v38, v39, v53);
    free(v33);
    goto LABEL_10;
  }
  v40 = v34;
  v54 = kCryptoAEADDescriptorChaCha20Poly1305;
  BytePtr = CFDataGetBytePtr(v34);
  Length = CFDataGetLength(v40);
  if (CryptoAEADEncryptMessageOneShot(v54, v55, 32, BytePtr, Length, 0, 0, v19))
  {
    sub_10001A7E4(0, "doEncryptCUOneShotMessage", CFSTR("Failed to encrypt message."), v43, v44, v45, v46, v47, (char)v20);
    v29 = 0;
  }
  else
  {
    v29 = (void *)objc_claimAutoreleasedReturnValue(+[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v33, v20 + 16));
    if (v29)
    {
      if (a3)
        *a3 = CFRetain(v40);
    }
    else
    {
      sub_10001A7E4(0, "doEncryptCUOneShotMessage", CFSTR("Failed to convert to data."), v48, v49, v50, v51, v52, (char)v20);
    }
  }
  free(v33);
  CFRelease(v40);
LABEL_11:

  return v29;
}

void sub_10002BDAC(uint64_t a1, uint64_t *a2, const __CFDictionary *a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFString *v13;
  __CFDictionary *v14;
  __CFDictionary *v15;
  __CFString **v16;
  const __CFString *v17;
  uint64_t v18;
  const __CFString *v19;
  const void *Value;
  const void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char v29;

  if (a1 && *(_QWORD *)(a1 + 24))
  {
    if (dword_1001A6AD0)
    {
      v13 = CFSTR("unknown");
      if (a4)
        LOBYTE(v13) = a4;
      sub_10001A7E4(0, "handle_enable_wireless_pairing", CFSTR("%@ attempting to enable/disable wireless pairing."), a4, (uint64_t)a5, a6, a7, a8, (char)v13);
    }
    v14 = sub_1000042FC(CFSTR("EnableWirelessPairing"));
    if (v14)
    {
      v15 = v14;
      if (*(_QWORD *)(a1 + 32))
      {
        v16 = off_10017B990;
        v17 = CFSTR("Wireless pairing not supported over remote service interface.");
      }
      else
      {
        v16 = off_10017B858;
        v17 = CFSTR("Invalid inputs.");
        if (a2 && a3)
        {
          if (MKBGetDeviceLockState(0) == 3)
          {
            v16 = off_10017B988;
            goto LABEL_11;
          }
          Value = CFDictionaryGetValue(a3, CFSTR("Options"));
          if (Value && (v21 = Value, sub_100010C10(Value)))
          {
            if (sub_100010B40(a5))
            {
              if (CFEqual(v21, kCFBooleanTrue))
              {
                if ((sub_10002AC7C(a2, v22, v23, v24, v25, v26, v27, v28) & 1) != 0)
                  goto LABEL_12;
                v16 = off_10017B870;
                v17 = CFSTR("Failed to enable wireless pairing.");
              }
              else
              {
                if ((sub_10002ACF8(a2, v22, v23, v24, v25, v26, v27, v28) & 1) != 0)
                  goto LABEL_12;
                v16 = off_10017B870;
                v17 = CFSTR("Failed to disable wireless pairing.");
              }
            }
            else
            {
              v16 = off_10017B870;
              v17 = CFSTR("Invalid entitlements.");
            }
          }
          else
          {
            v16 = off_10017B870;
            v17 = CFSTR("Invalid options.");
          }
        }
      }
      sub_10001A7E4(0, "handle_enable_wireless_pairing", v17, a4, (uint64_t)a5, a6, a7, a8, v29);
LABEL_11:
      sub_100004354(1, (uint64_t)"handle_enable_wireless_pairing", v15, *v16);
LABEL_12:
      sub_1000041C0(*(const __CFData **)(a1 + 24), v15, v18, a4, (uint64_t)a5, a6, a7, a8, a9);
      return;
    }
    v19 = CFSTR("Failed to create response.");
  }
  else
  {
    v19 = CFSTR("Invalid connection.");
    LODWORD(v14) = 0;
  }
  sub_10001A7E4((int)v14, "handle_enable_wireless_pairing", v19, a4, (uint64_t)a5, a6, a7, a8, a9);
}

void sub_10002BFB0(int a1, uint64_t a2, void *a3, const __CFDictionary *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  id v12;
  const char *v13;
  __CFString *v14;
  int v15;
  __CFDictionary *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  _BOOL4 v24;
  void *Value;
  void *v26;
  void *v27;
  NSObject *v28;
  id v29;
  id v30;
  void *v31;
  _BOOL4 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  id v38;
  void *v39;
  _BOOL4 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  id v46;
  void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  dispatch_queue_t v60;
  void *v61;
  void *v62;
  void *v63;
  void *v64;
  const void *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  void *v71;
  NSObject *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  __CFString **v78;
  void *v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  const __CFData *v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  const __CFString *v93;
  void *v94;
  char v95;
  void *v96;
  _QWORD v97[5];
  id v98;
  _QWORD v99[5];
  id v100;
  _QWORD v101[5];
  id v102;
  id location;
  uint64_t v104;
  uint64_t *v105;
  uint64_t v106;
  uint64_t (*v107)(uint64_t, uint64_t);
  void (*v108)(uint64_t);
  id v109;
  const __CFString *v110;
  void *v111;

  v12 = a3;
  v104 = 0;
  v105 = &v104;
  v106 = 0x3032000000;
  v107 = sub_10002C978;
  v108 = sub_10002C988;
  v109 = 0;
  if (dword_1001A6AD0)
  {
    v13 = "verify";
    if (a1)
      v13 = "create";
    sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Request (%s): %@"), v7, v8, v9, v10, v11, (char)v13);
  }
  if (a2 && v12)
  {
    if (*(_QWORD *)(a2 + 32))
    {
      sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("CU pairing not supported over remote service interface."), v7, v8, v9, v10, v11, v95);
      v14 = CFSTR("InvalidConnection");
      v15 = 0;
LABEL_9:
      v16 = 0;
      goto LABEL_46;
    }
    if (a1)
    {
      v16 = sub_1000042FC(CFSTR("CUPairingCreate"));
      v22 = 2;
      if (v16)
        goto LABEL_14;
    }
    else
    {
      v16 = sub_1000042FC(CFSTR("CUPairingVerify"));
      v22 = 4;
      if (v16)
      {
LABEL_14:
        if (a4)
        {
          v23 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
          v24 = v23 == 0;

          if (v24)
          {
            v30 = objc_alloc_init((Class)CUPairingSession);
            objc_msgSend(v12, "setPairingSession:", v30);

          }
          else
          {
            Value = (void *)CFDictionaryGetValue(a4, CFSTR("Flags"));
            if (sub_100010C10(Value) && CFEqual(Value, kCFBooleanTrue)
              || sub_100010B0C(Value) && objc_msgSend(Value, "isEqualToValue:", &off_10019BEB8))
            {
              v26 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));

              if (v26)
              {
                v27 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                objc_msgSend(v27, "invalidate");

                if (objc_msgSend(v12, "pairingSessionStarted"))
                {
                  v28 = objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "sem"));
                  dispatch_semaphore_wait(v28, 0xFFFFFFFFFFFFFFFFLL);

                }
                objc_msgSend(v12, "setPairingSession:", 0);
              }
              v29 = objc_alloc_init((Class)CUPairingSession);
              objc_msgSend(v12, "setPairingSession:", v29);

              objc_msgSend(v12, "setPairingSessionStarted:", 0);
            }
          }
          v31 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
          v32 = v31 == 0;

          if (!v32)
          {
            if ((objc_msgSend(v12, "pairingSessionStarted") & 1) == 0)
            {
              objc_initWeak(&location, v12);
              v96 = (void *)MGCopyAnswer(CFSTR("UniqueDeviceID"), 0);
              v38 = sub_10001B244(v96);
              v39 = (void *)objc_claimAutoreleasedReturnValue(v38);
              v40 = v39 == 0;

              if (v40)
              {
                sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Failed to query udid."), v41, v42, v43, v44, v45, v95);
                v14 = 0;
              }
              else
              {
                v46 = objc_alloc_init((Class)NSMutableDictionary);
                v47 = (void *)v105[5];
                v105[5] = (uint64_t)v46;

                if (v105[5])
                {
                  v101[0] = _NSConcreteStackBlock;
                  v101[1] = 3221225472;
                  v101[2] = sub_10002C990;
                  v101[3] = &unk_10017BA58;
                  objc_copyWeak(&v102, &location);
                  v101[4] = &v104;
                  v53 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v53, "setCompletionHandler:", v101);

                  v99[0] = _NSConcreteStackBlock;
                  v99[1] = 3221225472;
                  v99[2] = sub_10002CAFC;
                  v99[3] = &unk_10017BA80;
                  objc_copyWeak(&v100, &location);
                  v99[4] = &v104;
                  v54 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v54, "setPromptForPINHandler:", v99);

                  v97[0] = _NSConcreteStackBlock;
                  v97[1] = 3221225472;
                  v97[2] = sub_10002CC18;
                  v97[3] = &unk_10017BAA8;
                  objc_copyWeak(&v98, &location);
                  v97[4] = &v104;
                  v55 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v55, "setSendDataHandler:", v97);

                  v56 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v56, "setSessionType:", v22);

                  v57 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v57, "setFlags:", 8);

                  if (a1)
                  {
                    v58 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                    objc_msgSend(v58, "setFlags:", objc_msgSend(v58, "flags") | 0x80);

                  }
                  v59 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v59, "setAcl:", &off_10019BF78);

                  v60 = dispatch_queue_create("com.apple.mobilelockdown-srp", 0);
                  v61 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v61, "setDispatchQueue:", v60);

                  v110 = CFSTR("udid");
                  v111 = v96;
                  v62 = (void *)objc_claimAutoreleasedReturnValue(+[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v111, &v110, 1));
                  v63 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v63, "setAdditionalSelfInfo:", v62);

                  objc_msgSend(v12, "setPairingSessionStarted:", 1);
                  v64 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v64, "activate");

                  objc_destroyWeak(&v98);
                  objc_destroyWeak(&v100);
                  objc_destroyWeak(&v102);

                  objc_destroyWeak(&location);
                  goto LABEL_37;
                }
                sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Failed to create dictionary."), v48, v49, v50, v51, v52, v95);
                v14 = CFSTR("MissingValue");
              }

              objc_destroyWeak(&location);
              goto LABEL_45;
            }
LABEL_37:
            v65 = CFDictionaryGetValue(a4, CFSTR("Payload"));
            if (sub_100010BDC(v65))
            {
              v71 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
              objc_msgSend(v71, "receivedData:", v65);

              v72 = objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "sem"));
              dispatch_semaphore_wait(v72, 0xFFFFFFFFFFFFFFFFLL);

              switch(objc_msgSend(v12, "retval"))
              {
                case 0u:
                  if (dword_1001A6AD0)
                    sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("SRP FAIL"), v73, v74, v75, v76, v77, v95);
                  v78 = off_10017B978;
                  goto LABEL_81;
                case 1u:
                  if (!dword_1001A6AD0)
                    goto LABEL_77;
                  v93 = CFSTR("SRP SUCCEED");
                  goto LABEL_76;
                case 2u:
                  if (!dword_1001A6AD0)
                    goto LABEL_77;
                  v93 = CFSTR("SRP PINCODE");
                  goto LABEL_76;
                case 3u:
                  if (dword_1001A6AD0)
                    sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("SRP BADPINCODE"), v73, v74, v75, v76, v77, v95);
                  v78 = off_10017B970;
                  goto LABEL_81;
                case 4u:
                  if (dword_1001A6AD0)
                    sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("SRP RESET"), v73, v74, v75, v76, v77, v95);
                  v94 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "pairingSession"));
                  objc_msgSend(v94, "invalidate");

                  objc_msgSend(v12, "setPairingSession:", 0);
                  objc_msgSend(v12, "setPairingSessionStarted:", 0);
                  goto LABEL_80;
                case 5u:
                  if (!dword_1001A6AD0)
                    goto LABEL_77;
                  v93 = CFSTR("SRP KEEPGOING");
LABEL_76:
                  sub_10001A7E4(0, "handle_cupairingdriver", v93, v73, v74, v75, v76, v77, v95);
LABEL_77:
                  v14 = 0;
                  goto LABEL_82;
                case 6u:
                  if (dword_1001A6AD0)
                    sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("SRP CANCELLED"), v73, v74, v75, v76, v77, v95);
LABEL_80:
                  v78 = off_10017B980;
                  goto LABEL_81;
                default:
                  if (dword_1001A6AD0)
                    sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Invalid SRP response."), v73, v74, v75, v76, v77, v95);
                  v78 = off_10017B858;
LABEL_81:
                  v14 = *v78;
LABEL_82:
                  v15 = 1;
                  break;
              }
              goto LABEL_46;
            }
            sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Missing payload data."), v66, v67, v68, v69, v70, v95);
            goto LABEL_44;
          }
          sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Failed to allocate pairing session."), v33, v34, v35, v36, v37, v95);
        }
        else
        {
          sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Invalid message."), v17, v18, v19, v20, v21, v95);
        }
LABEL_44:
        v14 = CFSTR("MissingValue");
LABEL_45:
        v15 = 0;
        goto LABEL_46;
      }
    }
    sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Failed to create response message."), v17, v18, v19, v20, v21, v95);
    v15 = 0;
    v14 = 0;
    goto LABEL_9;
  }
  sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Invalid inputs."), v7, v8, v9, v10, v11, v95);
  v14 = 0;
  if (!v12)
  {
    v16 = 0;
    goto LABEL_57;
  }
  v15 = 0;
  v16 = 0;
LABEL_46:
  v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "srpResponse"));
  if (objc_msgSend(v79, "count"))
  {
    v80 = objc_msgSend(v12, "pairingSessionStarted");

    if ((v15 & v80) == 0)
      goto LABEL_50;
    v79 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v12, "srpResponse"));
    -[__CFDictionary addEntriesFromDictionary:](v16, "addEntriesFromDictionary:", v79);
  }

LABEL_50:
  if (v16)
  {
    if (v14)
      sub_100004354(1, (uint64_t)"handle_cupairingdriver", v16, v14);
    if (dword_1001A6AD0)
      sub_10001A7E4(0, "handle_cupairingdriver", CFSTR("Response: %@"), v81, v82, v83, v84, v85, (char)v16);
    if (a2)
    {
      v86 = *(const __CFData **)(a2 + 24);
      v16 = v16;
      sub_1000041C0(v86, v16, v87, v88, v89, v90, v91, v92, v95);
    }
  }
LABEL_57:
  _Block_object_dispose(&v104, 8);

}

void sub_10002C90C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *a11, id *location, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
  id *v32;
  uint64_t v33;

  objc_destroyWeak(v32);
  objc_destroyWeak(location);
  objc_destroyWeak(a11);
  objc_destroyWeak(&a32);
  _Block_object_dispose((const void *)(v33 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10002C978(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void sub_10002C988(uint64_t a1)
{

}

void sub_10002C990(uint64_t a1, void *a2)
{
  id WeakRetained;
  void *v4;
  const __CFString *v5;
  char v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  NSObject *v14;
  id v15;

  v15 = a2;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (v15)
  {
    if (objc_msgSend(v15, "code") == (id)-6727)
    {
      objc_msgSend(WeakRetained, "setRetval:", 4);
      v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
      v5 = CFSTR("resetcu");
    }
    else
    {
      if (objc_msgSend(v15, "code") == (id)-6723)
      {
        objc_msgSend(WeakRetained, "setRetval:", 6);
        if (!WeakRetained)
          goto LABEL_11;
        goto LABEL_10;
      }
      v6 = objc_msgSend(v15, "code");
      sub_10001A7E4(0, "handle_cupairingdriver_block_invoke", CFSTR("SRP Failure: %ld"), v7, v8, v9, v10, v11, v6);
      objc_msgSend(WeakRetained, "setRetval:", 0);
      v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
      v5 = CFSTR("fail");
    }
  }
  else
  {
    objc_msgSend(WeakRetained, "setRetval:", 1);
    v4 = *(void **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
    v5 = CFSTR("succeed");
  }
  objc_msgSend(v4, "setObject:forKeyedSubscript:", v5, CFSTR("doSRPPair"));
  v12 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "srpResponse"));
  objc_msgSend(v13, "setObject:forKeyedSubscript:", v12, CFSTR("ExtendedResponse"));

  if (WeakRetained)
  {
LABEL_10:
    v14 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sem"));
    dispatch_semaphore_signal(v14);

  }
LABEL_11:

}

void sub_10002CAFC(uint64_t a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  void *v13;
  NSObject *v14;
  char v15;
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if ((a2 & 0x10000) != 0)
  {
    sub_10001A7E4(0, "handle_cupairingdriver_block_invoke_2", CFSTR("Invalid PIN code entered."), v6, v7, v8, v9, v10, v15);
    objc_msgSend(WeakRetained, "setRetval:", 3);
  }
  if (a3 >= 1)
    sub_10001A7E4(0, "handle_cupairingdriver_block_invoke_2", CFSTR("SRP Throttled. Wait %d seconds."), v6, v7, v8, v9, v10, a3);
  if (objc_msgSend(WeakRetained, "retval") != 3)
    objc_msgSend(WeakRetained, "setRetval:", 2);
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "setObject:forKeyedSubscript:", CFSTR("badPinCode"), CFSTR("doSRPPair"));
  v11 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v12 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "srpResponse"));
  objc_msgSend(v12, "setObject:forKeyedSubscript:", v11, CFSTR("ExtendedResponse"));

  v13 = WeakRetained;
  if (WeakRetained)
  {
    v14 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sem"));
    dispatch_semaphore_signal(v14);

    v13 = WeakRetained;
  }

}

void sub_10002CC18(uint64_t a1, uint64_t a2, void *a3)
{
  id *v4;
  id v5;
  uint64_t v6;
  void *v7;
  void *v8;
  NSObject *v9;
  id WeakRetained;

  v4 = (id *)(a1 + 40);
  v5 = a3;
  WeakRetained = objc_loadWeakRetained(v4);
  objc_msgSend(WeakRetained, "setRetval:", 5);
  objc_msgSend(*(id *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40), "setObject:forKeyedSubscript:", v5, CFSTR("Payload"));

  v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 40);
  v7 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "srpResponse"));
  objc_msgSend(v7, "setObject:forKeyedSubscript:", v6, CFSTR("ExtendedResponse"));

  v8 = WeakRetained;
  if (WeakRetained)
  {
    v9 = objc_claimAutoreleasedReturnValue(objc_msgSend(WeakRetained, "sem"));
    dispatch_semaphore_signal(v9);

    v8 = WeakRetained;
  }

}

void sub_10002CCD8(const __CFString *a1, const void *a2)
{
  CFStringRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFStringRef v10;
  const __CFString *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const __CFString *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  char buffer[1024];
  CFRange v40;

  if (CFStringHasSuffix(a1, CFSTR("-LogLevel")))
  {
    v40.length = CFStringGetLength(a1) - 9;
    v40.location = 0;
    v4 = CFStringCreateWithSubstring(0, a1, v40);
    if (v4)
    {
      v10 = v4;
      v11 = CFStringCreateWithFormat(0, 0, CFSTR("com.apple.MobileSystemServices.Logging.%@"), v4);
      if (v11)
      {
        v17 = v11;
        if (CFStringGetCString(v11, buffer, 1024, 0x8000100u))
        {
          v23 = CFStringCreateWithFormat(0, 0, CFSTR("MobileSystemServices-%@"), a1);
          if (sub_10001AD28(v23, a2, kCFPreferencesAnyApplication, v24, v25, v26, v27, v28))
          {
            sub_10001A7E4(0, "set_logging_key", CFSTR("failed to set %@ preference"), v29, v30, v31, v32, v33, (char)a1);
          }
          else if (notify_post(buffer))
          {
            sub_10001A7E4(0, "set_logging_key", CFSTR("failed to post %s notification"), v34, v35, v36, v37, v38, (char)buffer);
          }
        }
        else
        {
          sub_10001A7E4(0, "set_logging_key", CFSTR("failed to construct notification string from %@"), v18, v19, v20, v21, v22, (char)v17);
          v23 = 0;
        }
        CFRelease(v10);
        CFRelease(v17);
        if (v23)
          CFRelease(v23);
      }
      else
      {
        sub_10001A7E4(0, "set_logging_key", CFSTR("failed to build notename from %@"), v12, v13, v14, v15, v16, (char)a1);
        CFRelease(v10);
      }
    }
    else
    {
      sub_10001A7E4(0, "set_logging_key", CFSTR("failed to extract identifier from %@"), v5, v6, v7, v8, v9, (char)a1);
    }
  }
}

CFNumberRef sub_10002CEC4(const void *a1)
{
  const void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  dispatch_semaphore_t v8;
  dispatch_queue_t v9;
  CFNumberRef v10;
  _QWORD v12[4];
  dispatch_semaphore_t v13;
  uint64_t *v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD v21[4];

  v21[0] = 0;
  v21[1] = v21;
  v21[2] = 0x2020000000;
  v21[3] = 0;
  v17 = 0;
  v18 = &v17;
  v19 = 0x2020000000;
  v20 = 0;
  v2 = (const void *)MGCopyAnswer(CFSTR("IsUIBuild"), 0);
  if (sub_100010C10(v2) && CFEqual(v2, kCFBooleanFalse))
  {
    sub_10001A7E4(0, "copy_photo_usage", CFSTR("CameraUsage and PhotoUsage keys are not supported on non-UI builds."), v3, v4, v5, v6, v7, v12[0]);
LABEL_4:
    v8 = 0;
    v9 = 0;
    goto LABEL_17;
  }
  if (!CFEqual(a1, CFSTR("PhotoUsage")) && !CFEqual(a1, CFSTR("CameraUsage")))
    goto LABEL_4;
  v9 = dispatch_queue_create(0, 0);
  if (v9)
  {
    v8 = dispatch_semaphore_create(0);
    if (v8)
    {
      v10 = (CFNumberRef)off_1001A8138;
      if (off_1001A8138)
        goto LABEL_13;
      if (qword_1001A8140 != -1)
        dispatch_once(&qword_1001A8140, &stru_10017BAF0);
      v10 = (CFNumberRef)off_1001A8138;
      if (off_1001A8138)
      {
LABEL_13:
        v12[0] = _NSConcreteStackBlock;
        v12[1] = 3221225472;
        v12[2] = sub_10002D0F4;
        v12[3] = &unk_10017BAD0;
        v14 = &v17;
        v15 = v21;
        v16 = 32;
        v8 = v8;
        v13 = v8;
        ((void (*)(dispatch_queue_t, uint64_t, _QWORD *))v10)(v9, 32, v12);

        dispatch_semaphore_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
        v10 = CFNumberCreate(0, kCFNumberSInt64Type, v18 + 3);
      }
      if (v2)
        goto LABEL_18;
      goto LABEL_19;
    }
  }
  else
  {
    v8 = 0;
  }
LABEL_17:
  v10 = 0;
  if (v2)
LABEL_18:
    CFRelease(v2);
LABEL_19:

  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  return v10;
}

void sub_10002D0D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

intptr_t sub_10002D0F4(intptr_t result, uint64_t a2, uint64_t a3)
{
  if ((unint64_t)(a3 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 40) + 8) + 24) += a3;
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 48) + 8) + 24) |= a2;
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(result + 48) + 8) + 24) == *(_QWORD *)(result + 56))
    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(result + 32));
  return result;
}

void sub_10002D148(id a1)
{
  qword_1001A8148 = (uint64_t)dlopen("/System/Library/PrivateFrameworks/PhotoLibraryServicesCore.framework/PhotoLibraryServicesCore", 1);
  off_1001A8138 = dlsym((void *)qword_1001A8148, "ALGetLibrarySizes");
}

uint64_t sub_10002D184(mach_port_t a1, int a2, int *a3, uint64_t a4, int a5, _OWORD *a6, _QWORD *a7, _DWORD *a8, _DWORD *a9, _DWORD *a10, _DWORD *a11, _DWORD *a12)
{
  int v17;
  mach_port_t reply_port;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  int v27;
  mach_msg_header_t msg;
  int v30;
  uint64_t v31;
  int v32;
  int v33;
  NDR_record_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  int v47;
  int v48;
  int v49;
  int v50;

  v30 = 1;
  v31 = a4;
  v32 = 16777472;
  v33 = a5;
  v34 = NDR_record;
  v17 = *a3;
  v35 = a2;
  v36 = v17;
  v37 = a5;
  reply_port = mig_get_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4B000000000;
  if (&_voucher_mach_msg_set)
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v19 = mach_msg(&msg, 3, 0x40u, 0xDCu, reply_port, 0, 0);
  v20 = v19;
  if ((v19 - 268435458) <= 0xE && ((1 << (v19 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
  }
  else
  {
    if (!(_DWORD)v19)
    {
      if (msg.msgh_id == 71)
      {
        v20 = 4294966988;
      }
      else if (msg.msgh_id == 1300)
      {
        if ((msg.msgh_bits & 0x80000000) != 0)
        {
          v20 = 4294966996;
          if (v30 == 2
            && msg.msgh_size == 212
            && !msg.msgh_remote_port
            && HIBYTE(v32) == 1
            && HIWORD(v35) << 16 == 1114112)
          {
            v21 = v33;
            if (v33 == v47)
            {
              v20 = 0;
              v22 = *(_DWORD *)&v34.mig_vers;
              *a3 = v38;
              v23 = v46;
              a6[6] = v45;
              a6[7] = v23;
              v24 = v44;
              a6[4] = v43;
              a6[5] = v24;
              v25 = v40;
              *a6 = v39;
              a6[1] = v25;
              v26 = v42;
              a6[2] = v41;
              a6[3] = v26;
              *a7 = v31;
              *a8 = v21;
              v27 = v49;
              *a9 = v48;
              *a10 = v27;
              *a11 = v50;
              *a12 = v22;
              return v20;
            }
          }
        }
        else if (msg.msgh_size == 36)
        {
          v20 = 4294966996;
          if (HIDWORD(v31))
          {
            if (msg.msgh_remote_port)
              v20 = 4294966996;
            else
              v20 = HIDWORD(v31);
          }
        }
        else
        {
          v20 = 4294966996;
        }
      }
      else
      {
        v20 = 4294966995;
      }
      mach_msg_destroy(&msg);
      return v20;
    }
    mig_dealloc_reply_port(msg.msgh_local_port);
  }
  return v20;
}

uint64_t sub_10002D3DC(mach_port_t a1, unsigned int a2, __int128 *a3)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  mach_port_t reply_port;
  uint64_t v9;
  uint64_t v10;
  mach_msg_header_t msg;
  NDR_record_t v13;
  unsigned int v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v4 = a3[5];
  v19 = a3[4];
  v20 = v4;
  v5 = a3[7];
  v21 = a3[6];
  v22 = v5;
  v6 = a3[1];
  v15 = *a3;
  v16 = v6;
  v7 = a3[3];
  v17 = a3[2];
  v13 = NDR_record;
  v14 = a2;
  v18 = v7;
  reply_port = mig_get_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = 5395;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4B100000000;
  if (&_voucher_mach_msg_set)
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v9 = mach_msg(&msg, 3, 0xA4u, 0x2Cu, reply_port, 0, 0);
  v10 = v9;
  if ((v9 - 268435458) <= 0xE && ((1 << (v9 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
    return v10;
  }
  if ((_DWORD)v9)
  {
    mig_dealloc_reply_port(msg.msgh_local_port);
    return v10;
  }
  if (msg.msgh_id == 71)
  {
    v10 = 4294966988;
LABEL_17:
    mach_msg_destroy(&msg);
    return v10;
  }
  if (msg.msgh_id != 1301)
  {
    v10 = 4294966995;
    goto LABEL_17;
  }
  v10 = 4294966996;
  if ((msg.msgh_bits & 0x80000000) != 0)
    goto LABEL_17;
  if (msg.msgh_size != 36)
    goto LABEL_17;
  if (msg.msgh_remote_port)
    goto LABEL_17;
  v10 = v14;
  if (v14)
    goto LABEL_17;
  return v10;
}

uint64_t sub_10002D568(mach_port_t a1, int a2, int a3, int a4, _OWORD *a5, uint64_t a6, int a7, _OWORD *a8, _QWORD *a9, _DWORD *a10)
{
  mach_port_t reply_port;
  uint64_t v13;
  uint64_t v14;
  int v15;
  mach_msg_header_t msg;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  NDR_record_t v22;
  _BYTE v23[28];
  int v24;

  v18 = 1;
  v19 = a6;
  v20 = 16777472;
  v21 = a7;
  v22 = NDR_record;
  *(_DWORD *)v23 = a2;
  *(_DWORD *)&v23[4] = a3;
  *(_DWORD *)&v23[8] = a4;
  *(_OWORD *)&v23[12] = *a5;
  v24 = a7;
  reply_port = mig_get_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = -2147478253;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4B200000000;
  if (&_voucher_mach_msg_set)
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v13 = mach_msg(&msg, 3, 0x54u, 0x50u, reply_port, 0, 0);
  v14 = v13;
  if ((v13 - 268435458) <= 0xE && ((1 << (v13 - 2)) & 0x4003) != 0)
  {
    mig_put_reply_port(msg.msgh_local_port);
  }
  else
  {
    if (!(_DWORD)v13)
    {
      if (msg.msgh_id == 71)
      {
        v14 = 4294966988;
      }
      else if (msg.msgh_id == 1302)
      {
        if ((msg.msgh_bits & 0x80000000) != 0)
        {
          v14 = 4294966996;
          if (v18 == 1 && msg.msgh_size == 72 && !msg.msgh_remote_port && HIBYTE(v20) == 1)
          {
            v15 = v21;
            if (v21 == *(_DWORD *)&v23[16])
            {
              v14 = 0;
              *a8 = *(_OWORD *)v23;
              *a9 = v19;
              *a10 = v15;
              return v14;
            }
          }
        }
        else if (msg.msgh_size == 36)
        {
          v14 = 4294966996;
          if (HIDWORD(v19))
          {
            if (msg.msgh_remote_port)
              v14 = 4294966996;
            else
              v14 = HIDWORD(v19);
          }
        }
        else
        {
          v14 = 4294966996;
        }
      }
      else
      {
        v14 = 4294966995;
      }
      mach_msg_destroy(&msg);
      return v14;
    }
    mig_dealloc_reply_port(msg.msgh_local_port);
  }
  return v14;
}

uint64_t sub_10002D754(mach_port_t a1, _DWORD *a2, _DWORD *a3, _DWORD *a4, _DWORD *a5)
{
  mach_port_t reply_port;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  int v15;
  int v16;
  mach_msg_header_t msg;
  unsigned int v18;
  int v19;
  int v20;
  int v21;
  int v22;

  reply_port = mig_get_reply_port();
  msg.msgh_remote_port = a1;
  msg.msgh_local_port = reply_port;
  msg.msgh_bits = 5395;
  *(_QWORD *)&msg.msgh_voucher_port = 0x4B300000000;
  if (&_voucher_mach_msg_set)
  {
    voucher_mach_msg_set(&msg);
    reply_port = msg.msgh_local_port;
  }
  v11 = mach_msg(&msg, 3, 0x18u, 0x3Cu, reply_port, 0, 0);
  v12 = v11;
  if ((v11 - 268435458) > 0xE || ((1 << (v11 - 2)) & 0x4003) == 0)
  {
    if ((_DWORD)v11)
    {
      mig_dealloc_reply_port(msg.msgh_local_port);
      return v12;
    }
    if (msg.msgh_id == 71)
    {
      v12 = 4294966988;
    }
    else if (msg.msgh_id == 1303)
    {
      if ((msg.msgh_bits & 0x80000000) == 0)
      {
        if (msg.msgh_size == 52)
        {
          if (!msg.msgh_remote_port)
          {
            v12 = v18;
            if (!v18)
            {
              v15 = v20;
              *a2 = v19;
              *a3 = v15;
              v16 = v22;
              *a4 = v21;
              *a5 = v16;
              return v12;
            }
            goto LABEL_23;
          }
        }
        else if (msg.msgh_size == 36)
        {
          if (msg.msgh_remote_port)
            v13 = 1;
          else
            v13 = v18 == 0;
          if (v13)
            v12 = 4294966996;
          else
            v12 = v18;
          goto LABEL_23;
        }
      }
      v12 = 4294966996;
    }
    else
    {
      v12 = 4294966995;
    }
LABEL_23:
    mach_msg_destroy(&msg);
    return v12;
  }
  mig_put_reply_port(msg.msgh_local_port);
  return v12;
}

uint64_t sub_10002D8CC(uint64_t result)
{
  uint64_t v1;
  __int16 v2;
  int v3;
  int v4;

  v1 = *(_QWORD *)result;
  v2 = *(_DWORD *)(result + 8) ^ (-2705 * ((2 * (result & 0xE860) - result + 6047) ^ 0x5EC6));
  *(_DWORD *)(v1 - 0x73F39308AC2F35EFLL) = (((2 * (v2 & 0x1FF ^ 0x1AA)) & 0x142) - (v2 & 0x1FF ^ 0x1AA) + 11584862) & 0x8007FF ^ 0x16011234;
  *(_QWORD *)(v1 - 0x73F39308AC2F360FLL) = 0x52C4D95D9C42F88;
  *(_DWORD *)(v1 - 0x73F39308AC2F35F3) = 1763403438;
  v3 = v2 ^ 0xCE;
  if (v3 == 1)
  {
    v4 = 1763403454;
    goto LABEL_5;
  }
  if (v3 == 2)
  {
    *(_DWORD *)(v1 - 0x73F39308AC2F35F7) = -1563766843;
    v4 = 1763403458;
LABEL_5:
    *(_QWORD *)(v1 - 0x73F39308AC2F3607) = 0x8ED585BC065D0D34;
    *(_QWORD *)(v1 - 0x73F39308AC2F35FFLL) = 0x712A7A43F9A2F2CBLL;
    *(_DWORD *)(v1 - 0x73F39308AC2F35F3) = v4;
  }
  *(_DWORD *)(result + 16) = -1995200407;
  return result;
}

void sub_10002DA3C(uint64_t a1)
{
  int v1;
  unsigned int v2;
  unsigned int v3;
  _BOOL4 v4;
  _BOOL4 v5;

  v1 = 460628867 * ((a1 & 0x73B15F3F | ~(a1 | 0x73B15F3F)) ^ 0xC0D822BD);
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 32) - 0x4B0C828AC4754609) + 593867242;
  v3 = *(_DWORD *)(a1 + 8) - v1 + 2066776853;
  v4 = v2 < 0x7F917812;
  v5 = v2 > v3;
  if (v3 < 0x7F917812 != v4)
    v5 = v4;
  __asm { BR              X10 }
}

uint64_t sub_10002DB20(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * ((2029
                                          * (((*(unsigned __int8 *)(*(_QWORD *)(a1 + 16)
                                                                  + (v2 - 1546372649))
                                             - ((19 * (v3 ^ 0x123) - 1280) & (2
                                                                            * *(unsigned __int8 *)(*(_QWORD *)(a1 + 16)
                                                                                                 + (v2 - 1546372649))))
                                             - 324345622) & 0x1F) != 21)) ^ v3))
                            - 8))();
}

uint64_t sub_10002DB88(uint64_t a1, int a2)
{
  int v2;
  uint64_t v3;
  int v4;
  _BOOL4 v5;

  v5 = v4 - 338464996 > (v2 + 1134444614);
  if ((v2 + 1134444614) < 0x47FF3543 != (v4 - 338464996) < 0x47FF3543)
    v5 = (v4 - 338464996) < 0x47FF3543;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (((a2 + 28 * (a2 ^ 0x6D0) - 1828) * v5) ^ a2)) - 12))();
}

uint64_t sub_10002DC00(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;

  return ((uint64_t (*)(uint64_t, _QWORD))(*(_QWORD *)(v2
                                                              + 8
                                                              * ((1355
                                                                * (*(unsigned __int8 *)(v1 + (v3 + 1)) >> 7)) ^ v4))
                                                  - ((v4 - 38) | 0x135u)
                                                  + 375))(a1, ((v4 + 245) | 0x1A)+ (*(unsigned __int8 *)(v1 + (v3 + 1)) ^ 0xDBFFFFFF)+ 2 * *(unsigned __int8 *)(v1 + (v3 + 1))+ 2132670944);
}

uint64_t sub_10002DC68(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  int v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5
                                        + 8
                                        * ((217
                                          * (((((a5 - 367) | 0x7AA) - 1851) & (v6 + 1) ^ 0xEFFBBBCC)
                                           + ((2 * (v6 + 1)) & 0x98)
                                           + 268715059 < 4)) ^ a5))
                            - 8))();
}

uint64_t sub_10002DCCC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  _BOOL4 v13;
  _BOOL4 v14;

  v12 = a8 + v10 + ((v11 - 1866) ^ 0x45ACC392);
  v13 = v12 < 0x91D445D5;
  v14 = v12 > v8 - 1921822504;
  if ((v8 - 1921822504) < 0x91D445D5 != v13)
    v14 = v13;
  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * ((87 * !v14) ^ v11)) - (v11 - 1595) + 379))();
}

uint64_t sub_10002DD48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  int v12;
  int v13;

  v13 = *(unsigned __int8 *)(v8 + (v11 + v10 + 2));
  return ((uint64_t (*)(uint64_t, _QWORD))(*(_QWORD *)(v9
                                                              + 8
                                                              * ((236 * (a8 + 2138959159 != v12 + 1870243988)) ^ v12))
                                                  - 8))(a1, (v13 ^ 0xFFDFFB5E) + 1530789888 + ((v12 + 76) & (2 * v13)));
}

uint64_t sub_10002DDC4(uint64_t a1, int a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7)
{
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;

  v11 = *(unsigned __int8 *)(v7 + v10 + ((a7 - 1017) ^ a5)) | (a2 << 8);
  return ((uint64_t (*)(uint64_t, _QWORD))(*(_QWORD *)(v8 + 8 * ((857 * (v9 - 1 == a6 + 383)) ^ a7)) - 8))(a1, ((v11 - 503012864) ^ 0x7B9DFFDE) - 545260672 + ((2 * (v11 - 503012864)) & 0xF73BFFBC));
}

uint64_t sub_10002DE38(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  _BOOL4 v11;

  v8 = a2 + v5 + v7 + v6 - 434754007 - 228315178;
  v9 = v3 + 2069816915;
  v10 = (v9 < 0x7FBFDB50) ^ (v8 < 0x7FBFDB50);
  v11 = v8 > v9;
  if (v10)
    v11 = v8 < 0x7FBFDB50;
  return (*(uint64_t (**)(void))(v4 + 8 * ((52 * !v11) ^ (a3 + 1428))))();
}

uint64_t *sub_10002DEB8@<X0>(uint64_t *result@<X0>, int a2@<W1>, _DWORD *a3@<X8>)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v8 = result[5];
  v7 = result[6];
  v9 = *result;
  *a3 = v5 - 825222481;
  *(_DWORD *)(v9 - 0x69B379730EA9D302) = v4;
  *(_DWORD *)(v8 - 0x20685CAF9A69C67) = a2;
  *(_QWORD *)(v7 - 0x2DA3ABA5EF040A99) = v3 + (v6 - 842903580);
  *((_DWORD *)result + 6) = 489733862;
  return result;
}

void sub_10002DF34(_DWORD *a1)
{
  unsigned int v1;

  v1 = *a1 ^ (69008221 * ((-2 - ((a1 | 0xFC1C80D3) + (~(_DWORD)a1 | 0x3E37F2C))) ^ 0xD0412D26));
  __asm { BR              X9 }
}

uint64_t sub_10002DFF0@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v1
                              + 8
                              * ((782
                                * ((*(_DWORD *)(v2 - 0x56428495FB6297ELL) & 1) != ((12 * (((a1 - 1407) | 0x409) ^ 0x45C)) ^ 0x3E4))) ^ a1)))();
}

uint64_t sub_10002E048(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;

  return ((uint64_t (*)(uint64_t, _QWORD))(*(_QWORD *)(v2
                                                              + 8
                                                              * (((*(_DWORD *)(v3 - 0x56428495FB62986) != 718622751)
                                                                * (((v1 ^ 0x497) + 568) ^ 0x180)) | v1))
                                                  - 8))(a1, *(_QWORD *)(v3 - 0x56428495FB62992));
}

uint64_t sub_10002E0B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;

  v13 = ((unint64_t)&a10 ^ 0x5DF26BFFCFF7FEF7)
      - 0x45400A2108A035F7
      + ((2 * (_QWORD)&a10) & 0xBBE4D7FF9FEFFDE0);
  a10 = v11 - 1;
  *(_BYTE *)(a2 + a10) = (v13 ^ 0xBA) * (v13 + 17);
  return ((uint64_t (*)(uint64_t, uint64_t))(*(_QWORD *)(v12 + 8
                                                                     * (((a10 == 0) * ((v10 - 568) ^ 0x116)) ^ v10))
                                                   - 4))(a1, a2);
}

void sub_10002E13C()
{
  JUMPOUT(0x10002E104);
}

void sub_10002E144()
{
  uint64_t v0;

  *(_DWORD *)(v0 + 16) = 1105293997;
}

void sub_10002E27C(uint64_t a1)
{
  int v1;

  v1 = 831981571 * ((((2 * a1) | 0xACFEB304) - a1 + 696297086) ^ 0x4FDE89A6);
  __asm { BR              X10 }
}

uint64_t sub_10002E314@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * (((v1 - 429) * (v2 != 10207770)) ^ (v1 - 1016)))
                            - (v1 - 735)
                            + 859))();
}

uint64_t sub_10002E364@<X0>(uint64_t a1@<X8>)
{
  int v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * ((v1 - 2014397009) & 0x7811439F)) - 4))();
}

uint64_t sub_10002E47C@<X0>(int a1@<W7>, uint64_t a2@<X8>)
{
  int v2;
  int v3;
  int v4;
  int v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(a2 + 8 * (((v5 == ((v4 + 1094) ^ (v2 + 991))) * a1) ^ v4 ^ v3)) - 4))();
}

uint64_t sub_10002E4AC@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * ((4086 * (v1 == v2 - 2019)) ^ v2))
                            - (v2 - 1148)
                            + 867))();
}

uint64_t sub_10002E4D8@<X0>(int a1@<W2>, uint64_t a2@<X8>)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;

  v6 = (v5 - 1697) | 0x225;
  v7 = v2 + v3;
  v8 = (v6 ^ 0x366) + v3;
  *(_DWORD *)(*(_QWORD *)(v4 - 0x2DB44D49A49B0026) + 4 * (v7 + 1)) = a1;
  *(_DWORD *)(v4 - 0x2DB44D49A49B002ALL) = v8;
  if (v2 + v8 + 1 >= 0)
    v9 = v2 + v8 + 1;
  else
    v9 = ~(v2 + v8);
  return ((uint64_t (*)(void))(*(_QWORD *)(a2
                                        + 8
                                        * ((((int)((v9 ^ 0x2E6E57CB)
                                                 + ((2 * v9) & 0x5CDCAF96)
                                                 + ((v6 + 411) ^ 0xDFBFBBFF)
                                                 + v2) > v6 - 872)
                                          * ((67 * ((v6 + 411) ^ 0x50F)) ^ 0x36B)) ^ (v6 + 411)))
                            - 4))();
}

uint64_t sub_10002E5BC@<X0>(uint64_t a1@<X8>)
{
  int v1;
  _QWORD *v2;
  int v3;
  unsigned int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * ((1637 * (*(_DWORD *)(*v2 + 4 * v4) != v1)) ^ v3))
                            - ((((v3 - 1244306553) & 0x4A2A9F57) - 320) ^ v3 ^ 0x665u)))();
}

uint64_t sub_10002E608@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * (((v2 - 1 + v1 > v3 - 1283) * ((67 * (v3 ^ 0x50F)) ^ 0x36B)) ^ v3))
                            - 4))();
}

uint64_t sub_10002E648(uint64_t result)
{
  int v1;
  int v2;
  _DWORD *v3;
  int v4;
  int v5;

  if ((v2 + v1) >= 0x7FFFFFFF)
    v5 = 475803024 - v4;
  else
    v5 = v4;
  *v3 = v5;
  *(_DWORD *)(result + 24) = -2096774443;
  return result;
}

void sub_10002E690(_DWORD *a1)
{
  unsigned int v1;
  unsigned int v2;
  int v3;
  _BOOL4 v5;

  v1 = 1543737703 * ((1016161312 - (a1 | 0x3C916420) + (a1 | 0xC36E9BDF)) ^ 0xBD9ACBA3);
  v2 = *a1 + v1;
  v3 = a1[2] ^ v1;
  v5 = (~v3 & 0x30000000) == 0 || (v3 & 0x3F000000) == 385875968;
  __asm { BR              X11 }
}

uint64_t sub_10002E770@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, int a4, unint64_t *a5, char a6, int a7, int a8, unint64_t *a9, unint64_t *a10, uint64_t a11)
{
  int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;

  v15 = *(_QWORD *)(v12 + 16);
  v16 = 1224239923 * ((~&a4 & 0xAE13C0ED | &a4 & 0x51EC3F12) ^ 0x5CA03D3A);
  a6 = (51 * ((~&a4 & 0xED | &a4 & 0x12) ^ 0x3A)) ^ 0xE2;
  a5 = &STACK[0x1ED5BB0BF3801E93];
  a7 = v16 - 1882357696 + v14;
  a10 = &STACK[0x738D742E56AF1747];
  a11 = v15;
  a9 = &STACK[0x5E2EA96BD122BBF5];
  a4 = ((v11 ^ 0x6DD6009D) - 805784082 + ((v11 << (v14 + 25)) & 0x777FF764 ^ 0x2453F644)) ^ v16;
  v17 = ((uint64_t (*)(int *))(*(_QWORD *)(a1 + 8 * (v14 ^ 0x80)) - 12))(&a4);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v13 + 8 * ((2248 * (a8 == 489733862)) ^ v14)) - 12))(v17);
}

uint64_t sub_10002E8AC()
{
  uint64_t v0;
  int v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8 * (((114 * ((v1 + 716) ^ 0x3BF) - 1161) * (v2 != 385875968)) ^ (v1 + 716)))
                            - 8))();
}

uint64_t sub_10002E8E4@<X0>(uint64_t a1@<X0>, int a2@<W8>, unint64_t a3)
{
  uint64_t v3;

  return (*(uint64_t (**)(uint64_t))(v3 + 8
                                                 * (((a3 + 4 >= a3) * (((a2 ^ 0x20F) + 838) ^ 0x507)) ^ a2 ^ 0x20F)))(a1);
}

uint64_t sub_10002E96C()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * (v0 ^ ((8 * (v1 == 0xB7E41E8B)) | (32 * (v1 == 0xB7E41E8B)))))
                            - 12))();
}

uint64_t sub_10002E9C0@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;
  _BOOL4 v10;

  *(_BYTE *)(a1 + (v6 - 1025154504)) = *(_BYTE *)(v1 + (v6 - 1025154504));
  v8 = v6 + 680150421;
  v9 = (v4 > 0x9A5B1CA3) ^ (v8 < v3 + 1254);
  v10 = v8 < v5;
  if (v9)
    v10 = v4 > 0x9A5B1CA3;
  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * ((8 * !v10) | (32 * !v10) | v2)) - 12))();
}

uint64_t sub_10002EA48()
{
  unsigned int v0;
  int v1;
  uint64_t v2;
  _BOOL4 v3;

  v3 = ((2 * v1) & 0xAF69D532 ^ 0x2F481512) + (v1 ^ 0xE050F412) - 59829502 + ((v0 - 728) ^ 0x92) != 1411646081;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * (((4 * v3) | (16 * v3)) ^ v0)) - 4))();
}

uint64_t sub_10002EAB4()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((246 * (v1 - 1471474329 >= (((((2 * v0) ^ 0x800) + 24) | 0x8A) ^ 0x186u))) ^ v0))
                            - 4))();
}

uint64_t sub_10002EB0C(int a1, int a2, uint64_t a3, int a4)
{
  int v4;
  int v5;
  uint64_t v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(v6
                                        + 8
                                        * ((45
                                          * (((a1 + v5 + a4 - (((a2 - 274433698) & 0x105B85FF ^ 0xEB) & v4)) & 0xFFFFFFFC) <= a1 + v5 + a4 + 3)) ^ a2))
                            - ((a2 + 2014150131) & 0x87F285C3)
                            + 1333))();
}

uint64_t sub_10002EB88@<X0>(unsigned int a1@<W0>, uint64_t a2@<X8>, uint8x8_t a3@<D0>)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;

  a3.i32[0] = *(_DWORD *)(a2 + a1 + 1);
  *(_DWORD *)(a2 - 3 + v5 + (v4 ^ 0x6A8 ^ (v3 + 281))) = vmovn_s16((int16x8_t)vmovl_u8(a3)).u32[0];
  return (*(uint64_t (**)(void))(v7 + 8 * ((591 * (v6 == 4)) ^ v4)))();
}

uint64_t sub_10002EBE0@<X0>(int a1@<W2>, uint64_t a2@<X8>)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;

  *(_DWORD *)(a2 - 3 + (v4 + v3)) = *(_DWORD *)(v2 - 3 + (v4 + v3));
  return (*(uint64_t (**)(void))(v6 + 8 * ((1429 * (a1 - 228 == v5)) ^ (a1 + 435))))();
}

uint64_t sub_10002EC24(int a1, unsigned int a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  *(_DWORD *)(v7 + (v5 - a3)) = *(_DWORD *)(v4 + (v5 - a3));
  return (*(uint64_t (**)(void))(v8 + 8 * (((a1 + a3 - 997 == v6) * a4) ^ a2)))();
}

uint64_t sub_10002EC50(int a1)
{
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (a1 ^ (2002 * (v1 != v2))))
                            - (a1 - 769)
                            - ((a1 + 253) ^ 0xFFFFFFFFFFFFFBC6)))();
}

uint64_t sub_10002EC84@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;

  *(_BYTE *)(a1 + (v4 + v3)) = *(_BYTE *)(v1 + (v4 + v3));
  return (*(uint64_t (**)(void))(v6 + 8 * ((734 * (v4 - 1 == ((38 * (v5 ^ 0xC9)) ^ (v2 + 998)))) ^ (v5 + 1086))))();
}

uint64_t sub_10002ECCC()
{
  unsigned int v0;
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * (int)(((*(_QWORD *)(v1 + 24) == 0x1BEDD35B3BD10D1ALL) * (v0 - 1227)) ^ v0))
                            - (v0 ^ 0x4E2)))();
}

uint64_t sub_10002ED10()
{
  int v0;
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((2015 * (*(_QWORD *)(v1 + 32) != 0x2BB8ED8829EF03C6)) ^ v0))
                            - 12))();
}

uint64_t sub_10002ED4C@<X0>(uint64_t a1@<X8>, uint64_t a2, int a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;

  *(_DWORD *)(a1 - 0x1BEDD35B3BD10D1ALL) = a3;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5
                                        + 8
                                        * ((2015 * (*(_QWORD *)(v4 + 32) != 0x2BB8ED8829EF03C6)) ^ ((v3 - 1182) | 0xA0)))
                            - 12))();
}

void sub_10002EDB0(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(a1 - 0x2BB8ED8829EF03C6) = v2;
  *(_DWORD *)(v1 + 4) = 489733862;
}

uint64_t sub_10002EE08(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  BOOL v5;
  unsigned int v6;
  unsigned int v7;

  v1 = 235795823 * ((2 * (a1 & 0x125A82D6) - a1 - 307921623) ^ 0x79083470);
  v2 = *(_DWORD *)(a1 + 16) + v1;
  v3 = *(_DWORD *)(a1 + 4) - v1;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL);
  v6 = v4 - 237901512;
  v5 = v4 - 237901512 < 0;
  v7 = 237901512 - v4;
  if (!v5)
    v7 = v6;
  return (*(uint64_t (**)(void))((char *)*(&off_100180420 + (v2 ^ 0x1AA))
                              + 8 * ((1031 * ((v3 - 1066701861) >= 4 * (unint64_t)v7)) ^ v2)
                              - 4))();
}

uint64_t sub_10002EED0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  int v5;

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v4
                                                                       + 8
                                                                       * (((v5 ^ 0x5A0) * (v3 != 1066701861)) ^ v5)))(a1, a2, a3, 252595185);
}

uint64_t sub_10002EF00(uint64_t a1)
{
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(uint64_t, uint64_t))(*(_QWORD *)(v1
                                                               + 8
                                                               * ((722 * (((((v2 ^ 0x3A) - 258) | 0x102) ^ 0x1FA) == 32)) ^ ((v2 ^ 0x3A) + 671)))
                                                   - 8))(a1, 296133326);
}

uint64_t sub_10002EF8C@<X0>(uint64_t a1@<X0>, int a2@<W2>, int a3@<W4>, int a4@<W5>, int a5@<W8>)
{
  uint64_t v5;
  int v6;
  unsigned int v7;
  char v8;

  *(_BYTE *)(*(_QWORD *)(a1 + 24) + (a4 + a5)) = (a3 ^ v7) >> v8;
  return (*(uint64_t (**)(void))(v5 + 8 * (int)(((((a2 + 319885844) & 0xECEEEDF1) - 422) * (a4 - 1 == v6)) ^ a2)))();
}

uint64_t sub_10002EFE0(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * ((722
                                          * (v4 + ((229 * (a3 ^ 0x1DF)) ^ 0x471) == (((229 * (a3 ^ 0x1DF) - 929) | 0x102) ^ 0x1FA))) ^ (229 * (a3 ^ 0x1DF))))
                            - 8))();
}

uint64_t sub_10002F034(uint64_t a1, int a2, uint64_t a3, int a4)
{
  unsigned int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  _BOOL4 v8;

  v8 = v4 > v7;
  if (v8 == a2 + 978207733 < (int)((a4 - 654287482) & 0x26FF9FDA ^ 0xCBF4E719))
    v8 = a2 + 978207733 < v6;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((228 * v8) ^ a4)) - 8))();
}

uint64_t sub_10002F0B0@<X0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W3>, int a4@<W8>)
{
  int v4;
  _QWORD *v5;

  return sub_10002EF8C(a1, (a3 + 1744282466) & 0x980859FE, *(_DWORD *)(*v5 + 4 * (a2 - 296133326)), v4, a4);
}

_DWORD *sub_10002F0F4(_DWORD *result, uint64_t a2, uint64_t a3, int a4)
{
  *result = a4;
  return result;
}

void sub_10002F0FC(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v5;

  v1 = *(_DWORD *)(a1 + 4) + 1224239923 * ((2 * (a1 & 0x188FD632) - a1 - 412079667) ^ 0x15C3D41A);
  v2 = *(_QWORD *)(a1 + 8);
  v5 = v1 - 460628867 * (((&v3 | 0xA020558C) - (&v3 & 0xA020558C)) ^ 0xECB6D7F1) + 491;
  v3 = v2;
  sub_10002F264((uint64_t)&v3);
  __asm { BR              X8 }
}

void sub_10002F1F8()
{
  _DWORD *v0;
  int v1;
  uint64_t v2;
  int v3;

  if ((*(_DWORD *)(v2 - 0x2DB44D49A49B002ALL) - 237901513) >= 0x7FFFFFFF)
    v3 = v1;
  else
    v3 = v1 + 2;
  *v0 = v3;
}

uint64_t sub_10002F264(uint64_t a1)
{
  int v1;
  int v2;
  BOOL v3;
  int v4;
  int v5;

  v2 = *(_DWORD *)(*(_QWORD *)a1 - 0x2DB44D49A49B002ALL);
  v4 = v2 - 237901512;
  v3 = v2 - 237901512 < 0;
  v5 = 237901512 - v2;
  if (!v3)
    v5 = v4;
  v1 = *(_DWORD *)(a1 + 12) + 460628867 * ((((2 * a1) | 0x5510E07A) - a1 - 713584701) ^ 0x661EF240);
  return ((uint64_t (*)(void))(*(_QWORD *)((char *)*(&off_100180420 + v1 - 1118)
                                        + 8
                                        * ((855
                                          * ((v5 ^ (v1 + 1341514263)) - 1341515456 + ((2 * v5) & 0x9FEBCD7E) < 0x7FFFFFFF)) ^ (v1 - 27))
                                        - 4)
                            - ((v1 - 1024) | 0x400u)
                            + 1184))();
}

uint64_t sub_10002F384(uint64_t a1, int a2, uint64_t a3)
{
  int v3;
  _QWORD *v4;
  unsigned int v5;
  int v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(a3 + 8 * (((*(_DWORD *)(*v4 + 4 * v5) == v6) * a2) ^ v3)) - 8))();
}

void sub_10002F3B0()
{
  JUMPOUT(0x10002F358);
}

uint64_t sub_10002F3B8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  *(_DWORD *)(result + 8) = a4;
  return result;
}

void sub_10002F3C0(uint64_t a1, uint64_t a2)
{
  __asm { BR              X8 }
}

uint64_t sub_10002F448(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((778 * (**(_BYTE **)(a2 + 8) == 0)) | 0xE1u)) - 8))();
}

uint64_t sub_10002F474(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18)
{
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;

  *(_QWORD *)(*(_QWORD *)(a16 + 96) + 504) = v18 + 1;
  *(_DWORD *)(*(_QWORD *)(a16 + 96) + 496) = a18 - 1;
  v21 = 235795823 * ((((v20 - 160) | 0x8A773861) - (v20 - 160) + ((v20 - 160) & 0x7588C798)) ^ 0x1EDA7138);
  *(_DWORD *)(v20 - 152) = v21 ^ 0xFE0643CC;
  *(_DWORD *)(v20 - 148) = v21 + 426523017;
  *(_QWORD *)(v20 - 160) = &STACK[0x73F39308AC2F38FB];
  v22 = sub_10002D8CC(v20 - 160);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v19
                                                      + 8
                                                      * ((397
                                                        * (a18
                                                         + 753591412
                                                         + ((2 * LODWORD(STACK[0x2F0])) & 0x5A ^ 0xA)
                                                         + (STACK[0x2F0] & 0x3F ^ 0x77F71FF8u) < 0xFFFFFFC0)) ^ 0x671u))
                                          - 4))(v22);
}

uint64_t sub_10002F660(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;

  v13 = v7 - 2012684268;
  if (v13 <= 0x40)
    v13 = 64;
  return ((uint64_t (*)(void))(*(_QWORD *)(v11
                                        + 8
                                        * (((v12 + ((v9 - 516407938) & 0x1EC7BCBE) - 695561770 + 864)
                                          * (a7 - v8 - v10 + v13 > 0xE)) ^ (v9 - 1426)))
                            - 12))();
}

uint64_t sub_10002F700(unsigned int a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;

  v14 = v10 + v8;
  v15 = v9 + ((a1 - 750823119) & 0x2CC0A6FF) + v14 + 143;
  if (v15 <= 0x40)
    v15 = a3;
  return ((uint64_t (*)(void))(*(_QWORD *)(v13 + 8 * ((113 * (a7 - v14 < v12 + v11 + (v7 ^ 0xA17D8D68) + v15)) ^ a1))
                            - 12))();
}

uint64_t sub_10002F76C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  int v18;
  int v19;
  uint64_t v20;

  return ((uint64_t (*)(void))(*(_QWORD *)(v20
                                        + 8
                                        * ((782
                                          * ((unint64_t)&STACK[0x2AC]
                                           + 73 * (((a2 - 1844936415) | 0x44821084) ^ (a6 - 3))
                                           + ~a18
                                           + v18
                                           + v19 > 0xF)) ^ a2))
                            - 12))();
}

uint64_t sub_10002F7D0@<X0>(int a1@<W8>)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int8x16_t *v6;
  int8x16_t v7;
  int8x16_t v8;

  v7.i64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v7.i64[1] = 0xFCFCFCFCFCFCFCFCLL;
  v8.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v8.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  *(int8x16_t *)(v3 + (a1 + v1)) = vaddq_s8(vsubq_s8(*v6, vandq_s8(vaddq_s8(*v6, *v6), v7)), v8);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v5
                                                      + 8
                                                      * ((56
                                                        * (((v4 + 114) ^ ((((v4 - 24)
                                                                                           + 0x1FFFFFE9BLL) & (v2 + 1)) == 16)) & 1)) ^ (v4 - 24)))
                                          - 4))((((v4 - 24) + 0x1FFFFFE9BLL) & (v2 + 1)) - 16);
}

void sub_10002F84C()
{
  JUMPOUT(0x10002F808);
}

uint64_t sub_10002F854@<X0>(int a1@<W5>, int a2@<W8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8 * (((((a2 - 2046165211) | 0x50809280) ^ (a1 + 161)) * (v2 == v3)) ^ a2))
                            - 3 * (a2 ^ 0xC2u)
                            + 75))();
}

uint64_t sub_10002F8AC@<X0>(int a1@<W4>, int a2@<W8>)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  *((_BYTE *)&STACK[0x2AC] + (a2 + v2)) = *(_BYTE *)(v3 + v6 - 1856274308)
                                                      - ((2 * *(_BYTE *)(v3 + v6 - 1856274308)) & 0xFC)
                                                      - 2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((1893 * ((a1 + a2 + 1) < 0x40)) ^ (v7 + v4 + 374)))
                            - 12))();
}

uint64_t sub_10002F934(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int32x4_t a35,int32x4_t a36,int32x4_t a37,int32x4_t a38)
{
  int v38;
  uint64_t v39;
  uint64_t v40;
  int v41;
  int v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  int v46;
  uint64_t (*v47)(__n128, __n128, __n128, __n128, __n128);
  __n128 v48;
  __n128 v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  uint8x16_t v61;
  uint16x8_t v62;
  int8x16_t v63;
  int8x16_t v64;
  uint16x8_t v65;
  int8x16_t v66;
  int8x16_t v67;
  uint8x16_t v68;
  uint16x8_t v69;
  uint16x8_t v70;
  uint8x16_t v71;
  int8x16_t v74;
  int8x16_t v79;
  int32x4_t v80;
  int32x4_t v81;
  int32x4_t v82;
  int32x4_t v83;
  uint64_t v85;
  uint8x16_t v86;
  uint16x8_t v87;
  uint16x8_t v88;
  uint8x16_t v89;
  uint8x16_t v94;
  uint16x8_t v95;
  uint16x8_t v96;
  int32x4_t v97;
  int32x4_t v98;
  int32x4_t v99;
  int32x4_t v100;
  _DWORD *v101;
  int v102;
  uint64_t v103;
  int v104;
  int v105;
  unint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t (*v111)(__n128, __n128, __n128, __n128, __n128);
  int8x16x4_t v112;
  int8x16x4_t v113;

  v47 = *(uint64_t (**)(__n128, __n128, __n128, __n128, __n128))(v43 + 8 * v38);
  HIDWORD(v109) = HIDWORD(a17) + 545758092;
  LODWORD(v109) = (v38 ^ 0x38E) + 2074448658;
  v48.n128_u64[0] = 0xFEFEFEFEFEFEFEFELL;
  v48.n128_u64[1] = 0xFEFEFEFEFEFEFEFELL;
  v49 = (__n128)vdupq_n_s32(0x1D30BEEEu);
  v50 = (__n128)vdupq_n_s32(0x1D30BEE6u);
  a28 = v45 - 16;
  HIDWORD(a27) = 18360423;
  v51 = (__n128)vdupq_n_s32(0x1D30BEFFu);
  v52.n128_u64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v52.n128_u64[1] = 0xFCFCFCFCFCFCFCFCLL;
  LODWORD(v108) = 1915;
  v53 = STACK[0x2F4];
  v54 = STACK[0x2F8];
  v55 = LODWORD(STACK[0x2F8]);
  v56 = STACK[0x2FC];
  v57 = STACK[0x300];
  v58 = LODWORD(STACK[0x2FC]);
  v59 = LODWORD(STACK[0x300]);
  HIDWORD(v108) = LOBYTE(STACK[0x30C]) ^ 0xE;
  v60 = LOBYTE(STACK[0x30C]) ^ 0xE;
  if (v60 == 2)
  {
    v110 = __PAIR64__(v57, v56);
    v111 = v47;
    v113 = vld4q_s8((const char *)&STACK[0x2AC]);
    v85 = LODWORD(STACK[0x304]);
    HIDWORD(a20) = STACK[0x304];
    v86 = (uint8x16_t)veorq_s8(v113.val[0], (int8x16_t)v48);
    v87 = vmovl_u8(*(uint8x8_t *)v86.i8);
    v88 = vmovl_high_u8(v86);
    v89 = (uint8x16_t)veorq_s8(v113.val[1], (int8x16_t)v48);
    _Q22 = vmovl_u8(*(uint8x8_t *)v89.i8);
    _Q21 = vmovl_high_u8(v89);
    __asm
    {
      SHLL2           V23.4S, V21.8H, #0x10
      SHLL2           V24.4S, V22.8H, #0x10
    }
    v94 = (uint8x16_t)veorq_s8(v113.val[2], (int8x16_t)v48);
    v95 = vmovl_high_u8(v94);
    v96 = vmovl_u8(*(uint8x8_t *)v94.i8);
    v113.val[0] = veorq_s8(v113.val[3], (int8x16_t)v48);
    v113.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v113.val[0]);
    v113.val[2] = (int8x16_t)vmovl_high_u16((uint16x8_t)v113.val[1]);
    v113.val[1] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v113.val[1].i8);
    v113.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v113.val[0].i8);
    v113.val[3] = (int8x16_t)vmovl_high_u16((uint16x8_t)v113.val[0]);
    v113.val[0] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v113.val[0].i8);
    v97 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q22.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v96.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v87.i8), 0x18uLL)), v113.val[0]);
    v98 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8(_Q24, (int8x16_t)vshll_high_n_u16(v96, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v87), 0x18uLL)), v113.val[3]);
    v99 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q21.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v95.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v88.i8), 0x18uLL)), v113.val[1]);
    v100 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8(_Q23, (int8x16_t)vshll_high_n_u16(v95, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v88), 0x18uLL)), v113.val[2]);
    v113.val[0] = veorq_s8(vandq_s8((int8x16_t)v97, (int8x16_t)v49), (int8x16_t)(*(_OWORD *)v113.val & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v113.val[3] = veorq_s8(vandq_s8((int8x16_t)v98, (int8x16_t)v49), (int8x16_t)(*(_OWORD *)&v113.val[3] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v113.val[1] = veorq_s8(vandq_s8((int8x16_t)v99, (int8x16_t)v49), (int8x16_t)(*(_OWORD *)&v113.val[1] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v113.val[2] = veorq_s8(vandq_s8((int8x16_t)v100, (int8x16_t)v49), (int8x16_t)(*(_OWORD *)&v113.val[2] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    a37 = vaddq_s32(vsubq_s32(v99, vaddq_s32((int32x4_t)v113.val[1], (int32x4_t)v113.val[1])), (int32x4_t)v50);
    a38 = vaddq_s32(vsubq_s32(v100, vaddq_s32((int32x4_t)v113.val[2], (int32x4_t)v113.val[2])), (int32x4_t)v50);
    a35 = vaddq_s32(vsubq_s32(v97, vaddq_s32((int32x4_t)v113.val[0], (int32x4_t)v113.val[0])), (int32x4_t)v50);
    a36 = vaddq_s32(vsubq_s32(v98, vaddq_s32((int32x4_t)v113.val[3], (int32x4_t)v113.val[3])), (int32x4_t)v50);
    v101 = (_DWORD *)&a35 + v40 + 248599762;
    v102 = *((_DWORD *)&a35 + v40 + 248599754) ^ *(v101 - 3);
    v103 = *(v101 - 16);
    v104 = v103 ^ *(v101 - 14) ^ (v102 + v42 - ((2 * v102) & 0x3A617DCC));
    HIDWORD(v106) = v104 ^ v42;
    LODWORD(v106) = v104;
    v105 = v106 >> 31;
    v107 = (2 * v105) & 0x3A617DCC;
    *v101 = v105 + v42 - v107;
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t, uint64_t (*)(__n128, __n128, __n128, __n128, __n128), uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v43 + 8 * ((4 * (v45 != 248599699)) | 0x70B)) - 12))(v85, 1667, 979467724, v59, v55, v107, v103, v58, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, v39,
             a20,
             v108,
             0x5F7B7BFF0D0117A7,
             v109,
             __PAIR64__(v54, v53),
             v110,
             v111,
             a27,
             a28,
             a29,
             a30,
             a31,
             a32,
             a33,
             a34);
  }
  else if (v60 == 1)
  {
    v112 = vld4q_s8((const char *)&STACK[0x2AC]);
    v61 = (uint8x16_t)veorq_s8(v112.val[0], (int8x16_t)v48);
    v62 = vmovl_u8(*(uint8x8_t *)v61.i8);
    v63 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v62.i8);
    v64 = (int8x16_t)vmovl_high_u16(v62);
    v65 = vmovl_high_u8(v61);
    v66 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v65.i8);
    v67 = (int8x16_t)vmovl_high_u16(v65);
    v68 = (uint8x16_t)veorq_s8(v112.val[1], (int8x16_t)v48);
    v69 = vmovl_high_u8(v68);
    v70 = vmovl_u8(*(uint8x8_t *)v68.i8);
    v71 = (uint8x16_t)veorq_s8(v112.val[2], (int8x16_t)v48);
    _Q26 = (int8x16_t)vmovl_high_u8(v71);
    _Q25 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v71.i8);
    v74 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q25.i8, 0x10uLL);
    __asm { SHLL2           V25.4S, V25.8H, #0x10 }
    v79 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q26.i8, 0x10uLL);
    __asm { SHLL2           V26.4S, V26.8H, #0x10 }
    v112.val[0] = veorq_s8(v112.val[3], (int8x16_t)v48);
    v112.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v112.val[0]);
    v112.val[2] = (int8x16_t)vmovl_high_u16((uint16x8_t)v112.val[1]);
    v112.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v112.val[0].i8);
    v112.val[3] = (int8x16_t)vmovl_high_u16((uint16x8_t)v112.val[0]);
    v112.val[0] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v112.val[0].i8), 0x18uLL), v74), vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v70.i8, 8uLL), v63));
    v112.val[3] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)v112.val[3], 0x18uLL), _Q25), vorrq_s8((int8x16_t)vshll_high_n_u16(v70, 8uLL), v64));
    v112.val[1] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v112.val[1].i8), 0x18uLL), v79), vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v69.i8, 8uLL), v66));
    v112.val[2] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)v112.val[2], 0x18uLL), _Q26), vorrq_s8((int8x16_t)vshll_high_n_u16(v69, 8uLL), v67));
    v80 = (int32x4_t)veorq_s8(vandq_s8(v112.val[0], (int8x16_t)v51), (int8x16_t)(*(_OWORD *)&v63 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v81 = (int32x4_t)veorq_s8(vandq_s8(v112.val[3], (int8x16_t)v51), (int8x16_t)(*(_OWORD *)&v64 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v82 = (int32x4_t)veorq_s8(vandq_s8(v112.val[1], (int8x16_t)v51), (int8x16_t)(*(_OWORD *)&v66 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v83 = (int32x4_t)veorq_s8(vandq_s8(v112.val[2], (int8x16_t)v51), (int8x16_t)(*(_OWORD *)&v67 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    a37 = vaddq_s32(vsubq_s32((int32x4_t)v112.val[1], vaddq_s32(v82, v82)), (int32x4_t)v50);
    a38 = vaddq_s32(vsubq_s32((int32x4_t)v112.val[2], vaddq_s32(v83, v83)), (int32x4_t)v50);
    a35 = vaddq_s32(vsubq_s32((int32x4_t)v112.val[0], vaddq_s32(v80, v80)), (int32x4_t)v50);
    a36 = vaddq_s32(vsubq_s32((int32x4_t)v112.val[3], vaddq_s32(v81, v81)), (int32x4_t)v50);
    return (*(uint64_t (**)(char *, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t, uint64_t (*)(__n128, __n128, __n128, __n128, __n128), uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v43 + 8 * ((104 * (a28 + 1 == v45)) ^ (v46 - 695561419))))((char *)*(&off_100180420 + ((v46 - 695561419) ^ 0x31)) - 8, (v46 - 695561419), 3833969832, v59, v55, 248599762, v58, (v46 - 695561603) | 0xD0u, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, v39,
             a20,
             v108,
             0x5F7B7BFF0D0117A7,
             v109,
             __PAIR64__(v54, v53),
             __PAIR64__(v57, v56),
             v47,
             a27,
             a28,
             a29,
             a30,
             a31,
             a32,
             a33,
             a34);
  }
  else
  {
    LODWORD(STACK[0x2F4]) = 2 * (v53 ^ v44) + v44 - (v41 & (4 * (v53 ^ v44)));
    LODWORD(STACK[0x2F8]) = (v55 ^ v44) + (v54 ^ v44) + v44 - (v41 & (2 * ((v55 ^ v44) + (v54 ^ v44))));
    LODWORD(STACK[0x2FC]) = (v58 ^ v44) + (v56 ^ v44) + v44 - (v41 & (2 * ((v58 ^ v44) + (v56 ^ v44))));
    LODWORD(STACK[0x300]) = (v59 ^ v44) + (v57 ^ v44) + v44 - (v41 & (2 * ((v59 ^ v44) + (v57 ^ v44))));
    a34 = 0;
    return v47(v48, v49, v50, v51, v52);
  }
}

uint64_t sub_1000304F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, uint64_t a20,uint64_t a21,int a22,int a23,unsigned int a24,unsigned int a25)
{
  int v25;
  uint64_t v26;
  int v27;
  _BOOL4 v28;

  if (a25 < a24 != (a22 + a19) < 0x7BA596EB)
    v28 = (a22 + a19) < 0x7BA596EB;
  else
    v28 = a22 + a19 > a25;
  return ((uint64_t (*)(void))(*(_QWORD *)(v26 + 8 * (int)((v28 * (a23 & 0xA08487FE ^ 0x3E4)) ^ (v27 + v25 + 1635)))
                            - 4))();
}

uint64_t sub_10003057C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6)
{
  int v6;
  int v7;
  uint64_t v8;
  int v9;

  return ((uint64_t (*)(void))(*(_QWORD *)(v8
                                        + 8
                                        * (((v9 + (a6 ^ (v7 + 891)) + 220) * (v6 + a3 + 63 >= (v6 + a3))) ^ a6))
                            - 12))();
}

uint64_t sub_1000305B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  return ((uint64_t (*)(void))(*(_QWORD *)(v21
                                        + 8
                                        * ((201
                                          * (((a6 - 122) ^ (~a18
                                                                           + v19
                                                                           - (unint64_t)(((v20 + a6 - 1915) ^ 0x47D112F8u)
                                                                                              + v18) < 0x10)) & 1)) ^ a6))
                            - 12))();
}

uint64_t sub_100030630(int8x16_t a1, double a2, double a3, double a4, int8x16_t a5, uint64_t a6, uint64_t a7, int a8, int a9)
{
  int v9;
  int8x16_t *v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;

  *v10 = vaddq_s8(vsubq_s8(*(int8x16_t *)(v14 + (v9 + a8)), vandq_s8(vaddq_s8(*(int8x16_t *)(v14 + (v9 + a8)), *(int8x16_t *)(v14 + (v9 + a8))), a5)), a1);
  return ((uint64_t (*)(void))(*(_QWORD *)(v13 + 8 * ((v11 - v12 + 52) ^ a9 ^ (v15 + v11 + 886))) - 8))();
}

uint64_t sub_100030690@<X0>(int a1@<W2>, uint64_t a2@<X8>)
{
  int v2;
  int v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  *(_BYTE *)(v4 + a2) = *(_BYTE *)(v7 + (v2 + a1))
                      - ((2 * *(_BYTE *)(v7 + (v2 + a1))) & 0xFC)
                      - 2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * (((a2 == 63) * v5) ^ (v8 + v3 + 174))) - 8))();
}

uint64_t sub_1000306E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18)
{
  int v18;
  int v19;
  uint64_t v20;
  _BOOL4 v21;

  v21 = v18 - 492112148 < (a18 - 164529391);
  if ((a18 - 164529391) < 0x514F7670 != (v18 - 492112148) < 0x514F7670)
    v21 = (a18 - 164529391) < 0x514F7670;
  return ((uint64_t (*)(void))(*(_QWORD *)(v20 + 8 * ((!v21 * (26 * (v19 ^ 0x3D0) + 810)) ^ v19)) - 8))();
}

uint64_t sub_10003075C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18)
{
  int v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  int v26;

  v26 = v21 + (a1 ^ (v18 + 932));
  v22 = 831981571 * ((~((v20 - 160) | 0x33845586) + ((v20 - 160) & 0x33845586)) ^ 0x55DA7A5D);
  *(_QWORD *)(v20 - 152) = a15;
  *(_DWORD *)(v20 - 160) = (a18 + 81201159) ^ v22;
  *(_DWORD *)(v20 - 156) = v22 + a1 + 142;
  v23 = sub_10005533C(v20 - 160);
  v24 = STACK[0x2F0] & (v26 + 55);
  *((_BYTE *)&STACK[0x2AC] + (v24 ^ 0x15)) = 126;
  return (*(uint64_t (**)(uint64_t))(v19
                                            + 8
                                            * (((32 * ((v24 ^ 0x15) > 0x37)) | (((v24 ^ 0x15) > 0x37) << 6)) ^ a1)))(v23);
}

uint64_t sub_100030858()
{
  int v0;
  int v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v2
                              + 8
                              * (int)(((v0 == ((v1 + 204798551) & 0xF3CB05E4) - 5)
                                     * (((v1 + 2025356790) & 0x874787FF) - 1294)) ^ (v1 + 1136))))();
}

uint64_t sub_1000308AC()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;

  return (*(uint64_t (**)(void))(v2 + 8 * ((1022 * ((v0 ^ 0x2Au) < ((v1 - 2080208378) | 0x52880280u) + v3)) ^ v1)))();
}

uint64_t sub_1000308F0@<X0>(uint64_t a1@<X8>)
{
  int v1;
  char v2;
  int v3;
  uint64_t v4;
  int v5;

  *(unint64_t *)((char *)&STACK[0x2AC] + a1 - 499642548) = 0xFEFEFEFEFEFEFEFELL;
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((((v2 & 0x38) == 8) * (v1 - v3 + 1992)) ^ (v5 + v1 + 910)))
                            - 12))();
}

uint64_t sub_100030948(double a1)
{
  int v1;
  double *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  *v2 = a1;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * (((v4 == 0) * v3) ^ v1)) - 12))();
}

uint64_t sub_10003096C@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;

  return (*(uint64_t (**)(void))(v3
                              + 8
                              * (int)((((v4 + ((a1 + 276986744) | 0xC6081284) + 708) ^ ((a1 - 1096) | 4)) * (v2 != v1)) ^ a1)))();
}

void sub_1000309B8()
{
  JUMPOUT(0x10002F954);
}

uint64_t sub_1000309CC@<X0>(int a1@<W2>, int a2@<W8>)
{
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v9;
  unsigned int v10;
  int v11;
  _BOOL4 v12;

  v9 = v2 < v5;
  *((_BYTE *)&STACK[0x2AC] + (a2 - 2012419040)) = v6
                                                              + *(_BYTE *)(v8 + (v3 + a1))
                                                              - ((2 * *(_BYTE *)(v8 + (v3 + a1))) & 0xFC);
  v10 = v3 + 1 + v4;
  v11 = v9 ^ (v10 < v5);
  v12 = v10 < v2;
  if (!v11)
    v9 = v12;
  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * ((2006 * !v9) ^ v6)) - 8))();
}

uint64_t sub_100030A4C@<X0>(int a1@<W8>)
{
  int v1;
  uint64_t v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((51 * (((v1 + 1967854761) & 0xB42A5FF3) + a1 - 499644373 > 0x37)) ^ (v3 + v1 + 1107)))
                            - 4))();
}

uint64_t sub_100030A9C@<X0>(unsigned int a1@<W8>)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v3 = a1;
  v4 = a1 - 499642548;
  if ((unint64_t)(v4 + 1) > 0x38)
    v5 = v4 + 1;
  else
    v5 = 56;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((15 * (v5 - v3 + ((v1 - 671372154) ^ 0xCA3C4313uLL) > 7)) ^ v1))
                            - 12))();
}

uint64_t sub_100030B14()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  *(unint64_t *)((char *)&STACK[0x2AC] + v2 + (((v0 - 683) | 0x428u) ^ 0xFFFFFFFFE2380B24)) = 0xFEFEFEFEFEFEFEFELL;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (v0 ^ (16 * ((v1 & 0xFFFFFFFFFFFFFFF8) == 8)))) - 4))();
}

uint64_t sub_100030B68(double a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(double *)(v5 + (v3 ^ v2)) = a1;
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * (v1 ^ (16 * (v4 == 0)))) - 4))();
}

uint64_t sub_100030B90()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (((v4 + v2 - 695562724 + 369) * (v0 != v1)) ^ v2))
                            - ((v2 - 154208724) & 0xDFBB97EF)
                            + 3599405696))();
}

void sub_100030BE8()
{
  char v0;
  char v1;
  int v2;
  char v3;
  unsigned int v4;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  unint64_t v11;

  v2 = LOBYTE(STACK[0x30C]) ^ 0xE;
  if (v2 == 1)
  {
    v8 = STACK[0x2F0];
    v9 = STACK[0x2EC];
    v10 = LODWORD(STACK[0x2F0]) >> 5;
    LOBYTE(STACK[0x2E4]) = -((8 * LOBYTE(STACK[0x2F0])) ^ 0xA8) - 2;
    LOBYTE(STACK[0x2E5]) = (v10 ^ 0x6C) + ((v10 << (v1 + v0 - 7)) & 0xFC ^ 0x27) - 1;
    LOBYTE(STACK[0x2E6]) = ((v8 >> 13) ^ 0x62) + ((v8 >> 12) & 0xFC ^ 0x3B) - 1;
    LOBYTE(STACK[0x2E7]) = ((v8 >> 21) ^ 0x29) - ((2 * ((v8 >> 21) ^ 0x29)) & 0xFC) - 2;
    HIDWORD(v11) = v9 ^ 8;
    LODWORD(v11) = v8;
    LOBYTE(STACK[0x2E8]) = (v11 >> 29) - ((2 * (v11 >> 29)) & 0xFC) - 2;
    LOBYTE(STACK[0x2E9]) = ((v9 >> 5) ^ 0x7C) + ((v9 >> 4) & 0xFC ^ 7) - 1;
    LOBYTE(STACK[0x2EA]) = ((v9 >> 13) ^ 0x21) - ((2 * ((v9 >> 13) ^ 0x21)) & 0xFC) - 2;
    v3 = v1 + v0 + 76;
    v6 = (v9 >> 21) ^ 0xFFFFFFCE;
    v7 = (4 * (v9 >> 22)) ^ 0x63;
  }
  else
  {
    if (v2 != 2)
      goto LABEL_6;
    v3 = (v0 + 121) & 0x56;
    v7 = STACK[0x2EC];
    v4 = STACK[0x2F0];
    LOBYTE(STACK[0x2E4]) = ((LODWORD(STACK[0x2EC]) >> 21) ^ 0xCE) + ((LODWORD(STACK[0x2EC]) >> 20) & 0xFC ^ 0x63) - 1;
    LOBYTE(STACK[0x2E5]) = ((v3 - 51) ^ (v7 >> 13)) + ((2 * (((v3 - 51) ^ (v7 >> 13) | 0x7E) ^ (v7 >> 13))) ^ 0x41) - 1;
    LOBYTE(STACK[0x2E6]) = ((v7 >> 5) ^ 0x7C) + ((v7 >> 4) & 0xFC ^ 7) - 1;
    HIDWORD(v5) = v7 ^ 8;
    LODWORD(v5) = v4;
    LOBYTE(STACK[0x2E7]) = (v5 >> 29) - ((2 * (v5 >> 29)) & 0xFC) - 2;
    LOBYTE(STACK[0x2E8]) = ((v4 >> 21) ^ 0x29) + ((2 * (((v4 >> 21) ^ 0x29 | 0x7E) ^ (v4 >> 21))) ^ 0x51) - 1;
    LOBYTE(STACK[0x2E9]) = ((v4 >> 13) ^ 0x62) + ((v4 >> 12) & 0xFC ^ 0x3B) - 1;
    LOBYTE(STACK[0x2EA]) = ((v4 >> 5) ^ 0x6C) + ((v4 >> 4) & 0xFC ^ 0x27) - 1;
    LOBYTE(v6) = (8 * v4) ^ 0xA8;
    LOBYTE(v7) = (16 * v4) ^ 0xAF;
  }
  LOBYTE(STACK[0x2EB]) = v7 + v6 + ((v3 - 101) & 0x94 ^ 0x7B);
LABEL_6:
  JUMPOUT(0x10002F954);
}

uint64_t sub_100031138(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  unsigned int v4;
  int v5;
  int v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  _BOOL4 v13;

  v9 = (v6 + v3);
  v10 = *(_DWORD *)((char *)&STACK[0x2AC] + v9 + 72);
  v11 = v10 >> (v5 ^ (v7 + 67) ^ (v7 + 24));
  *(_BYTE *)(a3 + v9) = (v11 ^ 0x61) + ((2 * ((v11 ^ 0x61 | 0x7E) ^ v11)) ^ 0xC1) - 1;
  *(_BYTE *)(a3 + (v9 + 1)) = (BYTE2(v10) ^ 0x18) + ((v10 >> 15) & 0xFC ^ 0xCF) - 1;
  *(_BYTE *)(a3 + (v9 + 2)) = (BYTE1(v10) ^ 0x2E) - ((2 * (BYTE1(v10) ^ 0x2E)) & 0xFC) - 2;
  *(_BYTE *)(a3 + (v9 + 3)) = v10 ^ 0xCB;
  v12 = LODWORD(STACK[0x308]) + 252055612;
  v13 = v6 + 381120270 < v12;
  if (v6 + 381120270 < v4 != v12 < v4)
    v13 = v12 < v4;
  return (*(uint64_t (**)(void))(v8 + 8 * (v5 | (32 * v13))))();
}

void sub_1000312D4()
{
  JUMPOUT(0x1000312A4);
}

uint64_t sub_1000312DC@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, int a9@<W8>, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  uint64_t v36;

  *(_DWORD *)(&a36 + a35) = 543829288;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v36 + 8 * ((((a9 + 1392) | 0x1C) - 248) ^ (a9 - 431))) - 8))(a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26);
}

uint64_t sub_1000313A4()
{
  int v0;
  int v1;
  uint64_t v2;
  _BOOL4 v3;

  v3 = v1 == ((v0 - 972945432) | 0x10888280) + 1909213665;
  return ((uint64_t (*)(char *))(*(_QWORD *)(v2 + 8 * ((v3 | (2 * v3)) ^ v0))
                                         - ((v0 - 273771841) & 0x105167E7 ^ 0x2C7)))((char *)*(&off_100180420
                                                                                               + (v0 ^ 0x8BE)) - 4);
}

uint64_t sub_10003141C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18)
{
  unsigned int v18;
  uint64_t v19;

  return ((uint64_t (*)(void))(*(_QWORD *)(v19
                                        + 8
                                        * ((7
                                          * ((((v18 + 922741816) & 0x490013F7 ^ 0xFFFFFD0F) & (a2 - 1528691547)) - a18 != (v18 ^ 0xA4E20662))) ^ v18))
                            - 8))();
}

uint64_t sub_100031480@<X0>(int a1@<W1>, int a2@<W8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,int a24)
{
  int v24;
  uint64_t v25;
  _BOOL4 v27;

  v27 = a24 - a1 == 17681099 && a2 != v24 + 543828533;
  return (*(uint64_t (**)(void))(v25 + 8 * ((v27 * (563 * (v24 ^ 0x2F1) - 67)) ^ v24)))();
}

uint64_t sub_1000314D8(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int a29,int a30)
{
  int v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  int v34;
  _BOOL4 v35;

  v33 = ((v30 + v32 + 659377127) & 0xD8B2B4F1 ^ 0x1258F2E6) + a30;
  v34 = (a2 + 325500114 < ((v30 + v32) | 0x243u) + 1854191077) ^ (v33 < 0x6E84B830);
  v35 = v33 < a2 + 325500114;
  if (v34)
    v35 = a2 + 325500114 < ((v30 + v32) | 0x243u) + 1854191077;
  return ((uint64_t (*)(void))(*(_QWORD *)(v31 + 8 * ((v30 + v32 + 1991) ^ (16 * !v35))) - 4))();
}

uint64_t sub_100031670(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * (((((*(_DWORD *)(a1 + 48 * (v3 + v2) + 36) == v3) ^ (v1 - 84)) & 1)
                                          * ((v1 ^ 0x2AA) - 177)) | v1))
                            - 8))();
}

uint64_t sub_1000316D0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;

  v18 = 460628867 * ((v17 - 644137947 - 2 * ((v17 - 160) & 0xD99B3CC5)) ^ 0x950DBEB8);
  v19 = (_QWORD *)(v17 - 160);
  v19[4] = a13;
  v19[5] = a11;
  v19[2] = v16;
  v19[6] = a10;
  *(_DWORD *)(v17 - 132) = v14 - v18 + 158;
  *(_DWORD *)(v17 - 152) = a2 + ((v14 + 581) ^ 0xA942FAB9) + v18;
  *v19 = a12;
  ((void (*)(uint64_t))((char *)*(&off_100180420 + v14 - 214) - 4))(v17 - 160);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v15
                                                      + 8
                                                      * (int)(((*(_DWORD *)(v17 - 136) == v13)
                                                             * (((v14 - 557854228) & 0xF7CABFB6) + 695563492)) ^ v14))
                                          - 8))(a1);
}

uint64_t sub_1000317E0(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((25
                                          * (*(_DWORD *)(a1 + 48 * ((v3 ^ (v1 - 734)) + v2)) != (v3 ^ 0x3C7)
                                                                                                + 182904710)) | v3))
                            - 4))();
}

uint64_t sub_10003183C@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8 * ((1096 * ((a1 ^ 0xECAAE0EA) == v2 + (v1 ^ (v3 - 31)) + 495879445)) ^ v1))
                            - 8))();
}

uint64_t sub_100031888(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;
  int v5;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * ((123 * ((a3 & 0xFFFFFFFFFFFFFFFLL) != ((v3 + 1141609595) & 0xE569DBF3) - 755)) ^ (v5 + v3 + 305))))();
}

uint64_t sub_1000318D0@<X0>(uint64_t a1@<X2>, int a2@<W8>)
{
  int v3;

  if ((a2 + 324345626) <= 0x18 && ((1 << (a2 + 26)) & 0x1094001) != 0)
    __asm { BR              X9 }
  return v3 ^ 0xE2CFE538;
}

void sub_100031CB8(uint64_t a1)
{
  int v1;
  _BOOL4 v4;

  v4 = *(_QWORD *)(a1 + 8) != 0x56428495FB62992
    && *(_QWORD *)(a1 + 32) != 0x7D59DC543B842D40
    && *(_QWORD *)(a1 + 24) != 0x721003D414281A36;
  v1 = *(_DWORD *)(a1 + 16) ^ (69008221 * ((~(_DWORD)a1 & 0xFA1A7A5E | a1 & 0x5E585A1) ^ 0x29B82854));
  __asm { BR              X9 }
}

uint64_t sub_100031DB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v20;
  int v21;

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v20
                                                                                         + 8
                                                                                         * (((*(_DWORD *)(a20 - 0x56428495FB6297ALL) == 489733862)
                                                                                           * ((v21 ^ 0x7DD) - 388)) ^ v21)))(a1, a2, a3, a4, a5, a6);
}

uint64_t sub_100031E04(__n128 a1, __n128 a2, __n128 a3, __n128 a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24)
{
  int v24;
  uint64_t v25;
  unsigned int v26;
  __n128 v27;
  __n128 v28;
  unsigned int v29;
  _BOOL4 v30;
  unsigned int v31;
  int v32;
  _BOOL4 v33;

  v26 = (v24 + 730412659) & 0xD476C7FF;
  v27.n128_u64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v27.n128_u64[1] = 0xFCFCFCFCFCFCFCFCLL;
  v28.n128_u64[0] = 0xFEFEFEFEFEFEFEFELL;
  v28.n128_u64[1] = 0xFEFEFEFEFEFEFEFELL;
  v29 = *(_DWORD *)(a24 - 0x56428495FB62982) - 687119335;
  v30 = v29 < 0xDE03405E;
  v31 = ((v26 - 21080292) & 0x141A5BD ^ 0xBB4FE3B4) + 582180445;
  v32 = v30 ^ (v31 < ((v26 - 21080292) ^ 0x20BD1BA9));
  v33 = v31 < v29;
  if (!v32)
    v30 = v33;
  return ((uint64_t (*)(__n128, __n128, __n128, __n128, __n128, __n128))(*(_QWORD *)(v25
                                                                                             + 8
                                                                                             * (int)((v30 | (32 * v30)) ^ v26))
                                                                                 - 8))(a1, a2, a3, a4, v27, v28);
}

uint64_t sub_10003205C()
{
  int v0;
  uint64_t v1;

  return (*(uint64_t (**)(void))(v1 + 8 * v0))();
}

uint64_t sub_100032D40(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, unsigned int a13)
{
  int v13;
  int v14;
  uint64_t v15;
  _QWORD *v16;
  _BOOL4 v17;

  *(_BYTE *)(*v16 + (v13 + a7)) = 126;
  v17 = v13 + 711576632 < v14 + 1487 + a13 + 852869341;
  if (a13 > 0xCD2A379E != (v13 + 711576632) < 0x32D5C861)
    v17 = a13 > 0xCD2A379E;
  return ((uint64_t (*)(void))(*(_QWORD *)(v15 + 8 * (!v17 | (v14 + 1487))) - 4))();
}

uint64_t sub_100032DBC@<X0>(unsigned int a1@<W1>, int a2@<W6>, int a3@<W8>)
{
  int v3;
  int v4;
  int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  _QWORD *v9;
  _BOOL4 v10;
  int v11;

  v10 = a1 > v7;
  v11 = v3 + 1;
  *(_BYTE *)(*v9 + (v11 + a2)) = -2;
  if (v10 == v11 + v5 < (a3 ^ 0x631u) + v4)
    v10 = v11 + v5 < v6;
  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * (v10 ^ a3 ^ 1)) - 4))();
}

void sub_100032E18(uint64_t a1, int a2)
{
  _QWORD *v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;

  *(_QWORD *)(v4 - 0x7D59DC543B842D40) = *v2;
  *(_DWORD *)(v5 - 0x721003D414281A36) = a2;
  *v2 = 0;
  *(_QWORD *)(v8 - 0x56428495FB6298ALL) = 0x2AD5501F2AD5501FLL;
  *v3 = 116907077;
  *(_DWORD *)(v8 - 0x56428495FB6297ELL) = ((*(_DWORD *)(v8 - 0x56428495FB6297ELL) & 0xFFFFFFFE ^ 0x278ACFA1) - 1) ^ 0x278ACFA0;
  *v7 = *v6;
}

void sub_100032F0C(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  _DWORD v7[2];
  uint64_t v8;

  v1 = *(_DWORD *)a1 ^ (2078219279 * (((a1 | 0x2CA10C87) - (a1 & 0x2CA10C87)) ^ 0xF65B9AF3));
  v2 = *(_QWORD *)(a1 + 8);
  if (*(_DWORD *)(v2 - 0x2DB44D49A49B002ALL) - 237901512 >= 0)
    v4 = *(_DWORD *)(v2 - 0x2DB44D49A49B002ALL) - 237901512;
  else
    v4 = 237901512 - *(_DWORD *)(v2 - 0x2DB44D49A49B002ALL);
  v3 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v3 - 0x2DB44D49A49B002ALL) - 237901512 >= 0)
    v5 = *(_DWORD *)(v3 - 0x2DB44D49A49B002ALL) - 237901512;
  else
    v5 = 237901512 - *(_DWORD *)(v3 - 0x2DB44D49A49B002ALL);
  v7[1] = v1
        - 1224239923 * ((v7 - 1649905341 - 2 * ((unint64_t)v7 & 0x9DA87143)) ^ 0x6F1B8C94)
        - 1045;
  v8 = v2;
  sub_10002F0FC((uint64_t)v7);
  if (v4 >= v5)
    v6 = v5;
  else
    v6 = v4;
  __asm { BR              X14 }
}

uint64_t sub_1000330C0()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  _BOOL4 v5;

  v5 = v2 + 1881265921 > 357232988 || v2 + 1881265921 < v3 + v1 - 880 - 1790250951;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((v5 * ((413 * (v1 ^ 0x496)) ^ 0x334)) ^ v1)) - 12))();
}

uint64_t sub_100033120(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  _BOOL4 v19;

  v15 = 4 * (v10 + v8);
  v16 = v12
      + v3
      + (((v6 ^ 0x126) * a2) ^ (v9 + 790) ^ *(_DWORD *)(*(_QWORD *)(v14 - 0x2DB44D49A49B0026) + v15))
      + 1172;
  *(_DWORD *)(*(_QWORD *)(v13 - 0x2DB44D49A49B0026) + v15) = v16 + v9 - (v11 & (2 * v16));
  v17 = v10 + 1 + v4;
  v19 = v17 <= v5 && v17 >= v7;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((1456 * v19) ^ v6)) - 12))();
}

uint64_t sub_1000331EC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10)
{
  uint64_t v10;
  int v11;
  int v12;
  _BOOL4 v14;

  v14 = v12 - 833335516 > 1937598847 || v12 - 833335516 < a10 - 209884800;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * ((v14 * ((7 * (v11 ^ 0x226)) ^ 0x7B8)) ^ v11)) - 8))();
}

uint64_t sub_100033248(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  _BOOL4 v25;

  v21 = 4 * (v18 + v16);
  v22 = v11 + 621719539 + (*(_DWORD *)(*(_QWORD *)(a10 - 0x2DB44D49A49B0026) + v21) ^ 0x1B785768);
  *(_DWORD *)(*(_QWORD *)(v20 - 0x2DB44D49A49B0026) + v21) = v22 + v17 - (v19 & (2 * v22));
  v23 = v18 + 1 + v13;
  v25 = v23 > v14 || v23 < v15;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * ((202 * v25) ^ v12)) - 8))();
}

uint64_t sub_100033328()
{
  uint64_t v0;
  uint64_t v1;
  int v2;

  return (*(uint64_t (**)(void))(v0
                              + 8
                              * (int)(((v1 != 0x72D85362DAF1500DLL) * (((v2 + 855390230) & 0xCD03C6F7) - 1722)) ^ v2)))();
}

uint64_t sub_100033370()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;

  return (*(uint64_t (**)(void))(v0 + 8 * ((((v2 + v3 - 1) < 0x7FFFFFFF) * (v1 + 267)) ^ (v1 - 1431))))();
}

uint64_t sub_1000335FC()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  int v4;
  uint64_t v5;

  return (*(uint64_t (**)(void))(v0
                              + 8
                              * (int)((v1 + 320328869) & 0xECE825BB ^ (8
                                                                     * (*(_DWORD *)(*(_QWORD *)(v5 - 0x2DB44D49A49B0026)
                                                                                  + 4 * (v2 + v4 - 1)) != v3)))))();
}

uint64_t sub_100033654()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;

  return (*(uint64_t (**)(void))(v0 + 8 * (((v3 + v2 - 2 < (((v1 - 299) | 0x123) ^ 0x7FFFFECCu)) * (v1 + 1067)) ^ v1)))();
}

uint64_t sub_100033694()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;

  return (*(uint64_t (**)(void))(v0 + 8 * (v2 ^ (8 * (*(_DWORD *)(v1 + 4 * (v3 + v5 - 1)) != v4)))))();
}

void sub_1000336BC()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;

  *(_DWORD *)(v3 - 0x2DB44D49A49B002ALL) = (((v2 + v1) * (v0 - 405110594)) ^ 0x3FFE56CA)
                                         - 835731458
                                         + ((2 * (v2 + v1) * (v0 - 405110594)) & 0x7FFCAD94);
}

void sub_100033748(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 32) + 1543737703 * ((150514792 - (a1 | 0x8F8AC68) + (a1 | 0xF7075397)) ^ 0x89F303EB);
  __asm { BR              X14 }
}

uint64_t sub_100033884(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, int a13)
{
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  _BOOL4 v18;

  v16 = ((v14 - 354) ^ 0xA67CAEFD) + v13;
  v18 = v16 <= 1493913784 && v16 >= a13 - 653569863;
  return ((uint64_t (*)(void))(*(_QWORD *)(v15 + 8 * (v18 | (8 * v18) | v14)) - 8))();
}

uint64_t sub_1000338EC@<X0>(int a1@<W1>, int a2@<W8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  BOOL v18;

  *(_DWORD *)(a10 + 4 * (v10 + a2)) = a1;
  v16 = v12 + v10 + 67;
  v18 = v16 > v13 || v16 < v14;
  return ((uint64_t (*)(void))(*(_QWORD *)(v15
                                        + 8
                                        * ((((v11 + 1) ^ v18) & 1 | (8
                                                                                    * (((v11 + 1) ^ v18) & 1))) ^ v11))
                            - 8))();
}

uint64_t sub_100033938(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  int v6;
  uint64_t v7;
  _BOOL4 v8;

  v8 = v5 != ((v6 + 763) ^ 0x5AA) - 279;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v7
                                                                                          + 8 * (v8 | (16 * v8) | v6))
                                                                              - 4))(a1, a2, a3, a4, a5);
}

uint64_t sub_100033970@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6, uint64_t a7, uint64_t a8, uint64_t a9, _DWORD *a10)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  _BOOL4 v16;

  v12 = (a1 - 997156550) & 0x3B6F63CA;
  v13 = (*(_DWORD *)(*(_QWORD *)(a4 + 8) - 0x73495CDCA303A980) - 786631598) * (*a10 ^ 0xE487A897);
  v14 = 69008221 * ((((v11 - 128) | 0x8CA5F255) - ((v11 - 128) & 0x8CA5F255)) ^ 0x5F07A05F);
  *(_QWORD *)(v11 - 120) = a8;
  *(_DWORD *)(v11 - 112) = ((v13 ^ 0x3C9FDCBA) + ((v12 - 171) ^ 0xEFFE66C7) + ((2 * v13) & 0x793FB974)) ^ v14;
  *(_QWORD *)(v11 - 104) = a7;
  *(_DWORD *)(v11 - 128) = v14 + v12 + 593;
  *(_DWORD *)(v11 - 124) = 237901512 - v14;
  v15 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + v12 - 420) - 4))(v11 - 128);
  v16 = (int)(a6 + 1885727700) > 1885727701;
  if (a6 > 0xF9A142B)
    v16 = 1;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v10 + 8 * ((1407 * v16) ^ v12)) - 4))(v15);
}

void sub_100033B08()
{
  JUMPOUT(0x1000339E8);
}

uint64_t sub_100033B10(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, _DWORD *a9, int a10, int a11, uint64_t a12, int a13, int a14, uint64_t a15)
{
  uint64_t v15;
  uint64_t v16;
  int v17;

  v17 = 3804331
      * ((((2 * ((v16 - 128) ^ 0x377493FC)) | 0xB4D0945C) - ((v16 - 128) ^ 0x377493FC) - 1516784174) ^ 0x13C9FC24);
  *(_QWORD *)(v16 - 120) = a15;
  *(_DWORD *)(v16 - 128) = a11 - v17 + 1795;
  *(_DWORD *)(v16 - 124) = (((a14 << 6) & 0xE7F6ED00) - 16843269 + ((3 * (a11 ^ 0x1A5)) ^ (32 * a14) ^ 0x73FB7481)) ^ v17;
  sub_100050D1C(v16 - 128);
  return ((uint64_t (*)(void))(*(_QWORD *)(v15 + 8 * ((859 * ((*a9 - 237901513) < 0x7FFFFFFF)) ^ a11))
                            - 8))();
}

uint64_t sub_100033BF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;

  *(_QWORD *)(v18 - 112) = &STACK[0x2DB44D49A49B006E];
  *(_DWORD *)(v18 - 120) = v17
                         + 831981571 * ((((2 * (v18 - 128)) | 0x7BACAC24) - (v18 - 128) - 1037456914) ^ 0xA4778636)
                         + 65;
  *(_QWORD *)(v18 - 128) = a14;
  sub_10004F498(v18 - 128);
  *(_DWORD *)(v18 - 104) = (v17 + 1181) ^ (((((v18 - 128) | 0xD2A1CF3A) - ((v18 - 128) & 0xD2A1CF3A)) ^ 0x1039D30) * v16);
  *(_QWORD *)(v18 - 128) = v15;
  *(_QWORD *)(v18 - 112) = a14;
  v19 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + (v17 ^ 0x1CE)) - 8))(v18 - 128);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v14
                                                      + 8
                                                      * ((63
                                                        * (*(_DWORD *)(v18 - 120) > ((v17 + 1053) | 0x83u) + 162893182)) ^ v17))
                                          - 8))(v19);
}

uint64_t sub_100033D0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16)
{
  uint64_t v16;
  int v17;
  int v18;
  int v19;

  v18 = (v17 + 490) | 0x45;
  v19 = (v18 ^ 0xF1D1ED7D) + a16;
  if (v19 < 0)
    v19 = -v19;
  return ((uint64_t (*)(void))(*(_QWORD *)(v16
                                        + 8
                                        * ((3197
                                          * ((int)((v19 ^ 0xFFEEF6DF) + ((2 * v19) & 0xFFDDEDBE) + 1116448) > (int)(((v18 + 706437626) & 0xD5E49BD6) - 535))) ^ v18))
                            - ((5 * (v18 ^ 0x413u)) ^ 0x1A2)))();
}

uint64_t sub_100033DD4(uint64_t a1, int a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;

  return ((uint64_t (*)(void))(*(_QWORD *)(v10
                                        + 8
                                        * (((*(_DWORD *)(v8 + 4 * v9) != ((a5 + 559) ^ (a8 + 1083)))
                                          * (((a5 - 404) | a2) ^ a3)) ^ a5))
                            - 12))();
}

void sub_100033E0C()
{
  JUMPOUT(0x100033DA0);
}

uint64_t sub_100033E1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t (*v14)(uint64_t);
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v20 = 3804331 * ((v19 - 128) ^ 0x7ED525F6);
  *(_QWORD *)(v19 - 128) = v18;
  *(_DWORD *)(v19 - 120) = v20 + v16 + 1107;
  *(_DWORD *)(v19 - 116) = v16 - 502 - v20 + v17 + 1248106410;
  sub_100034614(v19 - 128);
  *(_DWORD *)(v19 - 104) = (v16 + 679) ^ (69008221
                                        * ((((v19 - 128) | 0x867F775D) + (~(v19 - 128) | 0x798088A2)) ^ 0x55DD2556));
  *(_QWORD *)(v19 - 128) = a13;
  *(_QWORD *)(v19 - 112) = a14;
  v21 = v14(v19 - 128);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v15
                                                      + 8
                                                      * (int)(((*(_DWORD *)(v19 - 120) > 0x9B59335u)
                                                             * (((v16 - 561111894) & 0x2171E5FF ^ 0xFFFFFB9E)
                                                              + ((v16 - 502) ^ 0x301))) ^ (v16 - 502)))
                                          - 8))(v21);
}

uint64_t sub_100033F1C()
{
  uint64_t (*v0)(uint64_t);
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)(v6 - 128) = v2;
  *(_QWORD *)(v6 - 112) = v5;
  *(_DWORD *)(v6 - 104) = (v4 - 3) ^ (((v6 - 128) ^ 0xD3A2520A) * v3);
  v7 = v0(v6 - 128);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v1 + 8 * ((853 * (*(_DWORD *)(v6 - 120) > 0x9B59335u)) ^ v4))
                                          - (v4 - 719)
                                          + 736))(v7);
}

uint64_t sub_100033F94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13)
{
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;

  *(_DWORD *)(v17 - 128) = (v16 + 135) ^ (268847287
                                        * ((((v17 - 128) | 0xD959A92C) - ((v17 - 128) & 0xD959A92C)) ^ 0x26F3B804));
  *(_QWORD *)(v17 - 120) = a13;
  *(_QWORD *)(v17 - 112) = v15;
  v18 = ((uint64_t (*)(uint64_t))*(&off_100180420 + v16 - 566))(v17 - 128);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v13 + 8 * (v16 ^ (1887 * (v14 != 348103576))))
                                          - ((v16 - 1406592987) & 0x53D6E7FF ^ 0x305)))(v18);
}

uint64_t sub_10003404C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t (*v14)(uint64_t);
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  *(_DWORD *)(v19 - 104) = (v18 + 716) ^ (69008221
                                        * (((((v19 - 128) | 0x22BA0E34) ^ 0xFFFFFFFE) - (~(v19 - 128) | 0xDD45F1CB)) ^ 0xEE7A3C1));
  *(_QWORD *)(v19 - 128) = v16;
  *(_QWORD *)(v19 - 112) = a14;
  v20 = v14(v19 - 128);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v15
                                                      + 8
                                                      * ((485
                                                        * (*(_DWORD *)(v19 - 120) != (((v18 - 721) | 0x100) ^ (v17 - 277)))) ^ v18))
                                          - ((v18 + 37) ^ 0x305)))(v20);
}

uint64_t sub_1000340F0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;

  *(_QWORD *)(v5 - 112) = *(_QWORD *)(v7 + 16);
  *(_QWORD *)(v5 - 128) = v4;
  *(_DWORD *)(v5 - 120) = a4
                        + 831981571 * ((((v5 - 128) | 0x955F512A) - (v5 - 128) + ((v5 - 128) & 0x6AA0AED0)) ^ 0xCFE810E)
                        - 86;
  return sub_10004F498(v5 - 128);
}

void sub_100034248(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 16) ^ (3804331 * ((-2 - ((a1 | 0x7F5042C2) + (~(_DWORD)a1 | 0x80AFBD3D))) ^ 0xFE7A98CB));
  __asm { BR              X10 }
}

uint64_t sub_100034314(_QWORD *a1)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((50 * (*(_DWORD *)(*a1 + v3) == v2)) ^ v4))
                            - (((v4 + 1819806905) & 0x9387F7B1)
                             - 78)
                            + 1574))();
}

uint64_t sub_10003435C@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;

  v6 = v2;
  v5 = a1 + 831981571 * (&v4 ^ 0x99A1D024) - 1320;
  v4 = a2;
  return sub_10004F498((uint64_t)&v4);
}

void sub_1000344DC(uint64_t a1)
{
  int v1;
  uint64_t v2;

  v1 = *(_DWORD *)(a1 + 8) ^ (831981571
                            * (((a1 ^ 0x8A003497) - 575953088 - 2 * ((a1 ^ 0x8A003497) & 0xDDABA740)) ^ 0xCE0A43F3));
  v2 = *(_QWORD *)((char *)*(&off_100180420 + (v1 ^ 0xCD))
                 + 8
                 * (((((uint64_t (*)(uint64_t, uint64_t))*(&off_100180420 + v1 + 91))(32, 0x101004023FF3BD5) == 0)
                   * (((v1 + 9) | 3) - 127)) ^ v1)
                 - 4);
  __asm { BR              X8 }
}

void sub_100034594()
{
  uint64_t v0;

  *(_DWORD *)(v0 + 12) = -489691854;
}

void sub_100034614(uint64_t a1)
{
  int v1;

  v1 = 3804331 * ((a1 - 881405234 - 2 * (a1 & 0xCB76D2CE)) ^ 0xB5A3F738);
  __asm { BR              X15 }
}

uint64_t sub_1000346E0@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  unsigned int v5;
  unsigned int v6;
  uint64_t v8;
  int v9;
  unsigned int v10;

  v5 = (v4 + 1102546768) & 0xADEFEEEC;
  v6 = 944348131 * ((((2 * &v8) | 0x25FABA30) - &v8 + 1828889320) ^ 0x31E4F956);
  v8 = v2;
  v9 = v3 - v6 - 1200;
  v10 = a1 - v5 + v6 + (v3 ^ 0xF7D3BE44);
  return ((uint64_t (*)(uint64_t *))(*(_QWORD *)(v1 + 8 * (v3 ^ 0x5B1)) - 4))(&v8);
}

void sub_100034824(uint64_t a1, uint64_t a2)
{
  __asm { BR              X11 }
}

uint64_t sub_10003488C()
{
  return 4294925278;
}

void sub_100034A2C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 12) - 69008221 * ((-2 - ((~(_DWORD)a1 | 0x2A929A22) + (a1 | 0xD56D65DD))) ^ 0xF930C828);
  __asm { BR              X9 }
}

uint64_t sub_100034B28@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((((a1 - 403) ^ 0x98) * (v1 == 0)) ^ a1)) - 4))();
}

uint64_t sub_100034B64@<X0>(uint64_t (*a1)(uint64_t *)@<X8>)
{
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  int v11;

  v5 = (((&v7 | 0x41D7377E) - (&v7 & 0x41D7377E)) ^ 0x3F021288) * v1;
  v11 = ((v2 ^ 0x565) - 763) ^ v5;
  v10 = 0x118C242060FB2D82;
  v7 = v4;
  v8 = v5 ^ 0xC6395E95;
  v9 = v5 ^ 0x49D399AF;
  result = a1(&v7);
  *(_DWORD *)(v3 + 8) = *(_DWORD *)(v4 - 0x56428495FB6297ALL);
  return result;
}

void sub_1000353D4()
{
  uint64_t v0;
  uint64_t v1;
  char v2;

  v0 = qword_1001A6C58 - (_QWORD)&v2 + qword_1001A6C08;
  qword_1001A6C58 = (45734839 * v0) ^ 0xA77260646F1BC58ALL;
  qword_1001A6C08 = 45734839 * (v0 ^ 0xA77260646F1BC58ALL);
  *(_DWORD *)*(&off_100180420
             + ((-73 * ((qword_1001A6C08 - qword_1001A6C58) ^ 0x8A)) ^ byte_100161A20[byte_10015DDA0[(-73 * ((qword_1001A6C08 - qword_1001A6C58) ^ 0x8A))] ^ 0x19])
             + 64) = 489733862;
  v1 = ((uint64_t (*)(uint64_t, uint64_t))*(&off_100180420
                                                  + ((-73
                                                                                   * ((qword_1001A6C08 - qword_1001A6C58) ^ 0x8A)) ^ byte_100161A20[byte_10015DDA0[(-73 * ((qword_1001A6C08 - qword_1001A6C58) ^ 0x8A))] ^ 0xF1])
                                                  + 195))(512, 1509315540);
  *(_QWORD *)((char *)*(&off_100180420
                      + ((-73 * ((qword_1001A6C08 + qword_1001A6C58) ^ 0x8A)) ^ byte_10015DFA0[byte_100159170[(-73 * ((qword_1001A6C08 + qword_1001A6C58) ^ 0x8A))] ^ 0x8B])
                      - 119)
            - 4) = v1;
  __asm { BR              X8 }
}

void sub_100035578()
{
  int v0;
  _DWORD *v1;

  *v1 = v0;
}

void sub_10003C5BC(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  _BOOL4 v5;

  v1 = 831981571 * ((-2 - ((~(_DWORD)a1 | 0xF33FFBC4) + (a1 | 0xCC0043B))) ^ 0x6A9E2BE0);
  v2 = *(_DWORD *)(a1 + 8) + v1;
  v3 = (unsigned __int16)(*(_WORD *)(a1 + 12) + v1);
  v5 = *(_QWORD *)a1 == 0x70B15AEA8D1E196 || v3 == 28728;
  __asm { BR              X8 }
}

void sub_10003C6AC()
{
  int v0;
  uint64_t v1;

  *(_DWORD *)(v1 + 16) = v0;
}

void sub_10003D2F8(_DWORD *a1)
{
  unsigned int v1;
  int v2[10];

  v1 = *a1 + 1543737703 * (a1 ^ 0x7EF4507C);
  v2[1] = v1
        + 1178560073 * (((~v2 & 0x39D0C9BC) - (~v2 | 0x39D0C9BD)) ^ 0xDEE5EBD5)
        - 1501687297;
  sub_100074AF8(v2);
  __asm { BR              X8 }
}

uint64_t sub_10003D3E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t *a13, unsigned int a14, int a15)
{
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  a13 = &STACK[0x82D647BA4E69FD9];
  a14 = (v16 - 1318) ^ (831981571
                      * (((&a13 | 0xEDA12E04) - (&a13 & 0xEDA12E04)) ^ 0x7400FE20));
  sub_1000344DC((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v17
                                                                                + 8
                                                                                * (((a15 == v15)
                                                                                  * (145 * (v16 ^ 0x5A8) - 206)) ^ v16)))(v18, v19, v20, v21, v22);
}

uint64_t sub_10003D47C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int a13, int a14, uint64_t a15, int a16)
{
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v21 = *(_DWORD *)(v16 + 8) + v18;
  v22 = 1224239923 * ((54336456 - (&a13 | 0x33D1BC8) + (&a13 | 0xFCC2E437)) ^ 0xE7119E0);
  a15 = a11;
  a13 = 2083868941 * v21
      - v22
      + ((((v20 - 573) | 0x240) - 1535864529) ^ ((v20 - 692) | 0x58C))
      - ((-127229414 * v21 + 1789755642) & 0xDE3BA25A);
  a16 = (v20 + 207) ^ v22;
  sub_10004A21C((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v19
                                                                                         + 8
                                                                                         * ((13 * (a14 != v17)) ^ v20)))(v23, v24, v25, v26, v27, v28);
}

uint64_t sub_10003D580(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, unsigned int a15, uint64_t a16, unint64_t *a17, int a18)
{
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;

  v22 = (((&a13 | 0x37E51031) + (~&a13 | 0xC81AEFCE)) ^ 0xC556EDE7) * v21;
  a13 = v22 ^ 0x12B68929;
  a14 = (v19 + 368399449) ^ v22;
  a16 = a11;
  a17 = &STACK[0x72F2C1D3322B8800];
  a15 = v22 ^ 0xEC19DF6E;
  v23 = sub_100074BB8((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t))(v20 + 8 * ((1611 * (a18 == v18 + v19 + 725 - 1453)) ^ v19)))(v23);
}

uint64_t sub_10003D634()
{
  uint64_t v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  void (*v5)(unint64_t **);
  int v6;
  int v7;
  uint64_t result;
  int v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t *v12;
  unint64_t *v13;
  unsigned int v14;

  v6 = (v4 + 721) | 4;
  v14 = v4 - 944348131 * ((&v12 + 1244961591 - 2 * (&v12 & 0x4A349B37)) ^ 0xE92D3F79) - 210;
  v12 = &STACK[0x20BA795F69D3F0D];
  v13 = v11;
  ((void (*)(unint64_t **))(*(_QWORD *)(v3 + 8 * (v4 ^ 0x232)) - 8))(&v12);
  LODWORD(v13) = v4
               - 241568881 * (((&v12 | 0xD00DEA05) - (&v12 & 0xD00DEA05)) ^ 0x61CEE47)
               - 146;
  v12 = v11;
  sub_10005A5D8((uint64_t)&v12);
  if (HIDWORD(v13) == v1 + v6 - 1453)
    v7 = v9;
  else
    v7 = HIDWORD(v13);
  v13 = v11;
  LODWORD(v12) = (v4 - 576) ^ (((2 * (&v12 & 0x181C2120) - &v12 - 404496677) ^ 0x34418CD1)
                             * v2);
  v5(&v12);
  v13 = v10;
  LODWORD(v12) = (v6 - 1301) ^ (((&v12 & 0xF2CCF7CB | ~(&v12 | 0xF2CCF7CB)) ^ 0xDE915A3E)
                              * v2);
  result = ((uint64_t (*)(unint64_t **))v5)(&v12);
  *(_DWORD *)(v0 + 4) = v7;
  return result;
}

void sub_10003D7F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __asm { BR              X8 }
}

uint64_t sub_10003D868(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((253 * (a3 != 0)) ^ 0x16Cu)) - 8))();
}

uint64_t sub_10003D8A4()
{
  char v0;
  _DWORD *v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((1493 * (((*v1 == 0) ^ (v0 - 1) ^ 0x91) & 1)) ^ 0x191u))
                            - 8))();
}

uint64_t sub_10003D8E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, unsigned int a18)
{
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;

  v22 = v21 ^ (v18 + 2212);
  a18 = v21
      + 1178560073 * ((((2 * &a17) | 0x40AB890A) - &a17 + 1604991867) ^ 0x4760E6ED)
      - 1501687516;
  v23 = sub_100074AF8(&a17);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v20
                                                      + 8
                                                      * (((a17 == v19) * (((v21 - 128520601) & 0xF54) - 816)) | v21))
                                          - (v22 ^ 0x246EBAD7)))(v23);
}

uint64_t sub_10003D988(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t *a17, unsigned int a18, int a19)
{
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  a18 = (v19 - 957) ^ (831981571
                     * ((((2 * &a17) | 0x74AE8078) - &a17 + 1168687044) ^ 0x23F69018));
  a17 = &STACK[0x82D647BA4E69FF1];
  sub_1000344DC((uint64_t)&a17);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v20 + 8 * (((a19 == 489733862) * (((v19 + 771667895) & 0x246EFEDF) - 611235932)) ^ v19)) - ((v19 - 1091) | 0x300u) + 761))(v21, v22, v23, v24, v25, v26, v27, v28, a9);
}

uint64_t sub_10003DA58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18, uint64_t a19, int a20)
{
  int *v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;

  v27 = v22 - 283258579 + (~(2 * v22) | 0x21C45DA5);
  v28 = v26 + 163;
  v29 = 1224239923 * ((((2 * &a17) | 0xE12D7366) - &a17 - 1888926131) ^ 0x82254464);
  a19 = a14;
  a20 = (v26 + 163) ^ v29;
  a17 = v27 - v29 + 1;
  sub_10004A21C((uint64_t)&a17);
  v30 = 1224239923 * ((&a17 & 0x244F7FC | ~(&a17 | 0x244F7FC)) ^ 0xF08F5D4);
  a20 = (v26 + 163) ^ v30;
  a17 = v21 - v30 - 283258579 - ((v21 << ((v26 + 67) ^ 0x45)) & 0xDE3BA25A);
  a19 = a14;
  sub_10004A21C((uint64_t)&a17);
  v31 = -283258580;
  if (v25)
    v31 = -283258579;
  v32 = 1224239923 * ((&a17 - 107021952 - 2 * (&a17 & 0xF99EF980)) ^ 0xB2D0457);
  a17 = v31 - v32;
  a19 = a14;
  a20 = v28 ^ v32;
  sub_10004A21C((uint64_t)&a17);
  v33 = *v20;
  v34 = (2 * *v20) & 0xDE3BA25A;
  v35 = 1224239923 * ((2 * (&a17 & 0x71B1DCE0) - &a17 + 240001818) ^ 0xFCFDDECD);
  a19 = a14;
  a20 = v28 ^ v35;
  a17 = v33 - v35 - 283258579 - v34;
  sub_10004A21C((uint64_t)&a17);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v24 + 8 * ((1548 * (a18 == v23)) ^ v26)))(v36, v37, v38, v39, v40, v41, v42, v43, a9, a10);
}

uint64_t sub_10003DC50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18, unsigned int a19, uint64_t a20,unint64_t *a21,int a22)
{
  int v22;
  int v23;
  uint64_t v24;
  int v25;
  unsigned int v26;
  uint64_t v27;

  v26 = ((2 * (&a17 & 0x137ED580) - &a17 - 327079302) ^ 0x1E32D7AD) * v22;
  a20 = a14;
  a21 = &STACK[0x72F2C1D3322B8818];
  a17 = v26 ^ 0x12B6892A;
  a18 = (v25 + 368399408) ^ v26;
  a19 = v26 ^ 0xBA447838;
  v27 = sub_100074BB8((uint64_t)&a17);
  return (*(uint64_t (**)(uint64_t))(v24 + 8 * (v25 ^ (8 * (a22 == v23 + ((v25 - 256) | 0xD0) + 371 - 1092)))))(v27);
}

uint64_t sub_10003DD0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unint64_t *a15, uint64_t a16, unint64_t *a17, unint64_t *a18, unint64_t *a19, unint64_t *a20)
{
  int v20;
  int v21;
  uint64_t v22;
  void (*v23)(unint64_t **);
  uint64_t v24;

  a19 = &STACK[0x20BA795F69D3FD1];
  a20 = a15;
  a18 = &STACK[0x7F1325F673F67E8F];
  LODWORD(a17) = v20
               - 2078219279
               * (((&a17 | 0x90938D6A) - &a17 + (&a17 & 0x6F6C7290)) ^ 0x4A691B1E)
               - 231789511;
  sub_1000751F8((uint64_t)&a17);
  LODWORD(a19) = v20
               - 203
               - 944348131
               * ((((&a17 | 0xA7B65146) ^ 0xFFFFFFFE) - (~&a17 | 0x5849AEB9)) ^ 0xFB500AF7);
  a17 = &STACK[0x20BA795F69D3FD1];
  a18 = a15;
  v23 = (void (*)(unint64_t **))((char *)*(&off_100180420 + (v20 ^ 0x23B)) - 8);
  v23(&a17);
  a17 = &STACK[0x20BA795F69D3FD5];
  a18 = a15;
  LODWORD(a19) = v20 - 203 - 944348131 * (&a17 ^ 0xA319A44E);
  v23(&a17);
  a17 = a15;
  LODWORD(a18) = v20
               - 241568881 * ((&a17 & 0x63445CEA | ~(&a17 | 0x63445CEA)) ^ 0x4AAAA757)
               - 139;
  v24 = sub_10005A5D8((uint64_t)&a17);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v22
                                                      + 8
                                                      * ((1824
                                                        * (HIDWORD(a18) == ((v20 + 1039449642) & 0xC20B3FA7 ^ (v21 - 161)))) ^ v20))
                                          - (((v20 - 209) | 0x101u) ^ 0x30DLL)))(v24);
}

uint64_t sub_10003DEE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14)
{
  int v14;
  uint64_t v15;
  int v16;
  BOOL v17;
  int v18;

  if (a12)
    v17 = a14 == v14;
  else
    v17 = 0;
  v18 = v17;
  return ((uint64_t (*)(void))(*(_QWORD *)(v15 + 8 * ((v18 * ((v16 + 611236408) ^ v16 ^ 0x246EBA21)) ^ v16)) - 8))();
}

uint64_t sub_10003DF34(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int v16;
  uint64_t v17;

  return ((uint64_t (*)(void))(*(_QWORD *)(v17 + 8 * (((a16 != 0) * (a8 + a7 + (v16 ^ 0x6EF) + 1412 + 13)) ^ v16))
                            - 12))();
}

uint64_t sub_10003DF7C@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  uint64_t v3;
  unsigned int v4;

  v4 = (a1 ^ v2) - ((2 * (a1 ^ v2)) & 0xE90E7872) - 192463815;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (v1 ^ (25
                                               * (((((v1 + 120) | 0x88) - 921946678) ^ (2 * v4) & 0xDFBCBFFE)
                                                + (v4 ^ 0x1B5963C6)
                                                + 1513619417 == 1242980312))))
                            - 4))();
}

uint64_t sub_10003E010(int a1)
{
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (v1 ^ (19 * ((a1 + v2 + 270639105) > 7))))
                            - ((((v1 - 2102938409) & 0x7D584FAC) - 520) ^ (v1 - 850801449) & 0x32B635A0)))();
}

uint64_t sub_10003E088(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  return (*(uint64_t (**)(uint64_t, uint64_t))(v8
                                                     + 8
                                                     * (a3 + 13 * ((unint64_t)(v6 - a6) < 0x20))))(a1, v7);
}

uint64_t sub_10003E0D0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unsigned int v8;
  uint64_t v9;

  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * (((((a4 + 74194903) | 0x20029842) + a8) * (v8 < 0x20)) | a4))
                            - ((2 * a4) ^ 0x588)))();
}

uint64_t sub_10003E11C(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  unsigned int v14;
  int8x16_t v15;
  uint64_t v16;
  uint64_t v17;
  int8x16_t v18;

  v14 = a1 + v11 + v10;
  v15.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v15.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v16 = v8 + v14;
  v17 = a6 + v14;
  v18 = veorq_s8(*(int8x16_t *)(v16 - 31), v15);
  *(int8x16_t *)(v17 - 15) = veorq_s8(*(int8x16_t *)(v16 - 15), v15);
  *(int8x16_t *)(v17 - 31) = v18;
  return ((uint64_t (*)(void))(*(_QWORD *)(v13
                                        + 8
                                        * ((((v9 & 0xFFFFFFE0) != 32) * (((a8 + v12 + 1591) | 0x100) - 1834)) ^ (a8 + v12 + 1244)))
                            - 12))();
}

void sub_10003E184()
{
  JUMPOUT(0x10003E134);
}

uint64_t sub_10003E190()
{
  unsigned int v0;
  int v1;
  int v2;
  void (*v4)(unsigned int *);
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;

  v7 = (v1 - 617) ^ (69008221 * ((((2 * &v7) | 0x865F37CA) - &v7 + 1020290075) ^ 0x108DC9EF));
  v8 = v6;
  v4(&v7);
  v8 = v5;
  v7 = (v1 - 617) ^ (69008221 * (((&v7 | 0xB5CD1467) - (&v7 & 0xB5CD1467)) ^ 0x666F466D));
  v4(&v7);
  return v2 ^ v0;
}

void sub_10003E404(uint64_t a1)
{
  int v1;
  BOOL v2;

  v1 = *(_DWORD *)a1 - 69008221 * ((a1 - 2 * (a1 & 0x90A0864D) - 1868528051) ^ 0x4302D447);
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL) == 237901512;
  __asm { BR              X14 }
}

uint64_t sub_10003E504()
{
  int v0;
  uint64_t v1;
  int v2;
  unsigned int v3;
  int v4;
  _BOOL4 v5;
  _BOOL4 v6;

  v4 = v2 + 266;
  v5 = v3 > v2 + 1549220276;
  if (v5 != v0 + 360361347 < -1549220789)
    v6 = v5;
  else
    v6 = v0 + 360361347 < (int)(v3 + 598262859);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v1 + 8 * (int)((!v6 * ((v4 - 1676184679) ^ 0x9C17768A)) ^ v4))
                                          - ((v4 - 1676184679) & 0x63E88B5C)
                                          + 500))(0x14D7C48520198B99);
}

uint64_t sub_10003E644@<X0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W3>, uint64_t a4@<X8>)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int v8;
  uint64_t v9;
  int v10;
  _QWORD *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  _BOOL4 v19;

  v16 = (v8 ^ 0xE487A897)
      + a1
      + (((v4 ^ v13) - 265) ^ 0xEB283B7ADFE6776DLL)
      + v12 * (unint64_t)(*(_DWORD *)(*v11 + 4 * a2) ^ v8);
  *(_DWORD *)(v6 + 4 * v9) = v16 + v8 - ((2 * v16) & 0xC90F512E);
  v17 = (v14 ^ HIDWORD(v16)) + (v15 & (v16 >> 31)) + a4;
  v19 = a2 - 736813956 < v10 && a2 - 736813956 >= a3;
  return (*(uint64_t (**)(uint64_t))(v5 + 8 * (v4 ^ (v19 * v7))))(v17);
}

uint64_t sub_10003E6F8(uint64_t a1)
{
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * (v2 ^ (182 * (a1 != 0x14D7C48520198B99))))
                            - ((v2 - 110) ^ 0x3ADLL)))();
}

uint64_t sub_10003E748@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  _BOOL4 v8;

  v5 = 229 * (a2 ^ 0xF4);
  v6 = ((v5 + 1260829741) & 0xB4D942FE ^ 0xD3C2D1D0) + v2;
  v8 = v6 > 1643177965 || v6 < (int)((v5 ^ 0xE1F0E624) + v4);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8 * (v5 | (4 * v8))))(a1, 1643177965);
}

uint64_t sub_10003E800(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;

  v14 = a1 - 0x14D7C48520198B99 + (*(_DWORD *)(v9 + 4 * v11) ^ v10);
  *(_DWORD *)(v9 + 4 * v11) = v14 + (((a8 ^ a4) + 212) ^ (v10 + 198)) - (((a8 ^ a4) - 921743304) & (2 * v14));
  return ((uint64_t (*)(void))(*(_QWORD *)(v8
                                        + 8
                                        * ((((a5 ^ HIDWORD(v14)) + (a6 & (v14 >> 31)) + a7 == v13) * v12) ^ a8 ^ a4))
                            - 8))();
}

uint64_t sub_10003E890(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v4;
  _DWORD *v5;
  int v6;
  _BOOL4 v7;
  int v8;
  _BOOL4 v9;

  v6 = *v5 + 1784796755;
  v7 = v3 + 1784796755 < 149 * (a3 ^ 0x3A2) - 124786424;
  v8 = v7 ^ (v6 < -124785381);
  v9 = v3 + 1784796755 > v6;
  if (!v8)
    v7 = v9;
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((v7 * ((a3 + 110) ^ 0x41E)) ^ a3)) - 12))();
}

void sub_10003E908()
{
  int v0;
  _DWORD *v1;

  *v1 = v0;
}

void sub_10003E92C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 20) - 1178560073 * ((-846133519 - (a1 | 0xCD9106F1) + (a1 | 0x326EF90E)) ^ 0xD55BDB66);
  __asm { BR              X10 }
}

uint64_t sub_10003EA0C@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, unint64_t *a4, unint64_t *a5, int a6, unsigned int a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;

  v14 = (((&a4 | 0x76062D6A) - &a4 + (&a4 & 0x89F9D290)) ^ 0x91330F02) * a1;
  a4 = &STACK[0x7F1325F673F67E5F];
  a5 = &STACK[0x20BA795F69D3FB5];
  a9 = v12;
  a6 = v13 - v14 - 478;
  a7 = 858862209 - v14;
  v15 = ((uint64_t (*)(unint64_t **))(*(_QWORD *)(v9 + 8 * (v13 - 858)) - 8))(&a4);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v11
                                                      + 8
                                                      * (((*(_DWORD *)(v12 - 0x56428495FB6297ALL) == v10)
                                                        * (((v13 - 1380672038) & 0x524B5FB4) + 1424)) ^ v13))
                                          - ((v13 - 1380672038) ^ 0xADB4A6EA)
                                          + 1925))(v15);
}

uint64_t sub_10003EB00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10)
{
  int v10;
  uint64_t v11;
  int v12;

  return ((uint64_t (*)(void))(*(_QWORD *)(v11
                                        + 8 * ((52 * ((a10 ^ (v10 - 933) ^ ((v12 ^ 0x6A1u) + 1143)) > 0x14)) ^ v12))
                            - 12))();
}

void sub_10003EB3C(_DWORD *a1@<X8>)
{
  uint64_t v1;
  int v2;

  *a1 = v2 + 148;
  *(_DWORD *)(v1 + 16) = *a1;
}

void sub_10003EF4C()
{
  int v0[10];

  v0[1] = 1178560073 * ((-1176344558 - (v0 | 0xB9E26812) + (v0 | 0x461D97ED)) ^ 0xA128B585)
        - 1501685844;
  sub_100074AF8(v0);
  __asm { BR              X8 }
}

uint64_t sub_10003F024(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t *a13, unsigned int a14, int a15)
{
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  a14 = (831981571 * ((295820161 - (&a13 | 0x11A1DB81) + (&a13 | 0xEE5E247E)) ^ 0x77FFF45A)) ^ 0x87;
  a13 = &STACK[0x82D647BA4E69FD1];
  sub_1000344DC((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v16
                                                                                + 8 * ((470 * (a15 == v15)) ^ 0x655u)))(v17, v18, v19, v20, v21);
}

uint64_t sub_10003F0CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, uint64_t a15, int a16)
{
  int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v20 = 1224239923
      * ((-1424351604 - (&a13 | 0xAB1A1E8C) + (&a13 | 0x54E5E173)) ^ 0xA6561CA4);
  a15 = a10;
  a16 = v20 ^ 0x3A4;
  a13 = v16 - v20 - (((v19 ^ 0x1F428E9D) - 1090971246) & (2 * v16)) - 283258579;
  sub_10004A21C((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v18
                                                                                         + 8
                                                                                         * ((435 * (a14 == v17)) ^ v19)))(v21, v22, v23, v24, v25, v26);
}

uint64_t sub_10003F184(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, int a15, uint64_t a16, unint64_t *a17, int a18)
{
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  unsigned int v22;
  uint64_t v23;

  v22 = ((((2 * &a13) | 0x1A80A97C) - &a13 + 1925163842) ^ 0x7FF3A969) * v21;
  a16 = a10;
  a17 = &STACK[0x72F2C1D3322B8800];
  a15 = v22 ^ 0x6377A211;
  a13 = v22 ^ 0x12B68929;
  a14 = (v20 + 368401670) ^ v22;
  v23 = sub_100074BB8((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v19 + 8 * ((870 * (a18 == v18)) ^ (v20 + 2752)))
                                          - ((v20 - 928912332) & 0x375E1FF5)
                                          + 1617))(v23);
}

uint64_t sub_10003F254@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t *a5, unint64_t *a6, uint64_t a7, unsigned int a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  a8 = v8
     - 944348131
     * (((&a6 ^ 0x314AC0E1 | 0xCC251B0C) + (&a6 ^ 0x240B00 | 0x33DAE4F3)) ^ 0x92776FAE)
     - 741;
  a6 = &STACK[0x20BA795F69D3FC5];
  a7 = a1;
  ((void (*)(unint64_t **))(*(_QWORD *)(v10 + 8 * (v8 & 0x3E6A59FA)) - 8))(&a6);
  a6 = a5;
  LODWORD(a7) = v8
              - 241568881
              * ((((&a6 | 0xDDC2490C) ^ 0xFFFFFFFE) - (~&a6 | 0x223DB6F3)) ^ 0xF42CB2B1)
              - 677;
  v11 = sub_10005A5D8((uint64_t)&a6);
  return (*(uint64_t (**)(uint64_t))(v9 + 8 * ((237 * (a5 != 0)) ^ (v8 + 362))))(v11);
}

uint64_t sub_10003F380@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t (*v8)(unsigned int *);
  int v9;
  uint64_t v10;

  a6 = (v9 - 524453936) ^ (69008221
                         * (((&a6 | 0x6BD0036D) - (&a6 & 0x6BD0036D)) ^ 0xB8725167));
  a7 = a1;
  v10 = v8(&a6);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v7 + 8 * ((483 * (a3 == 0)) ^ (v9 - 524453328)))
                                          - ((v9 - 1821333865) & 0x4D4CD3BB)
                                          + 791))(v10);
}

uint64_t sub_10003F428@<X0>(uint64_t a1@<X8>)
{
  int v1;
  unsigned int v2;
  void (*v3)(unsigned int *);
  int v4;
  unsigned int v6;
  uint64_t v7;

  v7 = a1;
  v6 = (v1 - 643) ^ (69008221
                   * (((&v6 | 0x4F9F18DC) - &v6 + (&v6 & 0xB060E720)) ^ 0x9C3D4AD6));
  v3(&v6);
  return v4 ^ v2;
}

void sub_10003F4F8(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t *v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;

  v1 = *(_DWORD *)(a1 + 8) + 460628867 * ((-1228667218 - (a1 | 0xB6C406AE) + (a1 | 0x493BF951)) ^ 0x5AD7B2C);
  v2 = *(_QWORD *)(a1 + 40);
  v4 = *(unint64_t **)(a1 + 16);
  v3 = *(_QWORD *)(a1 + 24);
  v5 = *(unint64_t **)(v2 - 0x73495CDCA303A988);
  v12 = *(_QWORD *)a1;
  v11 = v1 - 1224239923 * ((&v7 - 1600500025 - 2 * (&v7 & 0xA09A4EC7)) ^ 0x5229B310) + 860;
  v9 = v5;
  v10 = v2;
  v7 = v3;
  v8 = &STACK[0x2DB44D49A49B004E];
  ((void (*)(uint64_t *))((char *)*(&off_100180420 + v1 - 675) - 8))(&v7);
  v6 = *(_QWORD *)(v2 - 0x73495CDCA303A990);
  LODWORD(v8) = v1
              + 831981571
              * ((1193525828 - (&v7 | 0x4723C244) + (&v7 | 0xB8DC3DBB)) ^ 0x217DED9F)
              - 473;
  v7 = v6;
  v9 = &STACK[0x2DB44D49A49B005E];
  sub_10004F498((uint64_t)&v7);
  v8 = v4;
  LODWORD(v9) = (944348131 * (((&v7 | 0x113A7D54) - (&v7 & 0x113A7D54)) ^ 0xB223D91A)) ^ (v1 - 651);
  sub_10004953C((uint64_t)&v7);
  __asm { BR              X8 }
}

uint64_t sub_10003F758(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t (*a11)(uint64_t), uint64_t a12)
{
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;

  *(_QWORD *)(v19 - 128) = v14;
  *(_QWORD *)(v19 - 120) = v16;
  *(_QWORD *)(v19 - 104) = a12;
  *(_QWORD *)(v19 - 144) = v15;
  *(_QWORD *)(v19 - 136) = v14;
  *(_DWORD *)(v19 - 112) = v13 - 1224239923 * ((v19 - 144) ^ 0xF2B3FDD7) + 611;
  v20 = a11(v19 - 144);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v12
                                                      + 8
                                                      * ((13
                                                        * (v18 + v17 + 13 * ((v13 - 249) ^ 0x363u) - 1067 < 0x7FFFFFFF)) ^ (v13 - 249)))
                                          - 8))(v20);
}

uint64_t sub_10003F7DC()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  *(_DWORD *)(v7 - 120) = v1 + 69008221 * ((v7 - 144) ^ 0xD3A2520A) + 937;
  *(_QWORD *)(v7 - 136) = v2;
  *(_QWORD *)(v7 - 128) = v2;
  *(_QWORD *)(v7 - 112) = v4;
  *(_QWORD *)(v7 - 144) = v3;
  ((void (*)(uint64_t))((char *)*(&off_100180420 + (v1 ^ 0x40D)) - 8))(v7 - 144);
  v8 = 2078219279 * ((((v7 - 144) | 0xFA4A981B) - (v7 - 144) + ((v7 - 144) & 0x5B567E0)) ^ 0x20B00E6F);
  *(_DWORD *)(v7 - 140) = -1307958045 - v8 + v5;
  *(_QWORD *)(v7 - 136) = v6;
  *(_DWORD *)(v7 - 128) = (v1 + 612) ^ v8;
  v9 = sub_10005A1B4(v7 - 144);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v0 + 8 * ((500 * (*(_DWORD *)(v7 - 144) != 657247804)) ^ v1))
                                          - ((43 * (v1 ^ 0x439u)) ^ 0x339)))(v9);
}

uint64_t sub_10003F8D8()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((13 * (v3 + v2 + 13 * (v1 ^ 0x363u) - 1067 < 0x7FFFFFFF)) ^ v1))
                            - 8))();
}

uint64_t sub_10003F918()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v8;
  void (*v9)(uint64_t);
  uint64_t v10;

  v5 = *(_QWORD *)(v8 + 32);
  v6 = 831981571 * ((((v4 - 144) | 0x90F04090) - ((v4 - 144) & 0x90F04090)) ^ 0x95190B4);
  *(_QWORD *)(v4 - 144) = v10;
  *(_DWORD *)(v4 - 136) = v0 - v6 - 611;
  *(_DWORD *)(v4 - 132) = v6 + 376798310;
  sub_1000548E8(v4 - 144);
  *(_QWORD *)(v4 - 128) = v1;
  *(_QWORD *)(v4 - 120) = v3;
  *(_DWORD *)(v4 - 112) = v0 - 1224239923 * ((v4 - 144) ^ 0xF2B3FDD7) + 860;
  *(_QWORD *)(v4 - 144) = v2;
  *(_QWORD *)(v4 - 136) = v1;
  *(_QWORD *)(v4 - 104) = v10;
  v9(v4 - 144);
  *(_DWORD *)(v4 - 136) = v0 + 831981571 * (((v4 - 144) & 0x591B3C7C | ~((v4 - 144) | 0x591B3C7C)) ^ 0x3F4513A7) - 473;
  *(_QWORD *)(v4 - 144) = v1;
  *(_QWORD *)(v4 - 128) = v5;
  return sub_10004F498(v4 - 144);
}

void sub_10003FA38(uint64_t a1)
{
  int v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  _DWORD v6[2];
  uint64_t v7;

  v1 = *(_DWORD *)(a1 + 24) - 1224239923 * ((-223099009 - (a1 | 0xF2B3C77F) + (a1 | 0xD4C3880)) ^ 0xFFFFC557);
  if (*(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL) - 237901512 >= 0)
    v3 = *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL) - 237901512;
  else
    v3 = 237901512 - *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL);
  v2 = *(_QWORD *)(a1 + 16);
  if (*(_DWORD *)(v2 - 0x2DB44D49A49B002ALL) - 237901512 >= 0)
    v4 = *(_DWORD *)(v2 - 0x2DB44D49A49B002ALL) - 237901512;
  else
    v4 = 237901512 - *(_DWORD *)(v2 - 0x2DB44D49A49B002ALL);
  v7 = *(_QWORD *)(a1 + 8);
  v6[1] = v1 - 1224239923 * ((((2 * v6) | 0x15CF2FCC) - v6 + 1964533786) ^ 0x78546A31) + 196;
  sub_10002F0FC((uint64_t)v6);
  if (v3 >= v4)
    v5 = v4;
  else
    v5 = v3;
  __asm { BR              X13 }
}

uint64_t sub_10003FBB4@<X0>(uint64_t a1@<X8>, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  _BOOL4 v16;

  v11 = v3 - 1251728825;
  v12 = (v10 - 111) | 0x41;
  v13 = 4 * (v9 + v4);
  v14 = v7
      + 927270150
      + (*(_DWORD *)(*(_QWORD *)(v6 - 0x2DB44D49A49B0026) + v13) ^ v8)
      + (*(_DWORD *)(*(_QWORD *)(a2 - 0x2DB44D49A49B0026) + v13) ^ v8);
  *(_DWORD *)(*(_QWORD *)(a1 - 0x2DB44D49A49B0026) + v13) = v14 + v8 - ((v14 << (((v12 + 53) | 0x74) ^ 0x75)) & v5);
  v16 = v9 + 1953609186 < 895754823 && v9 + 1953609186 >= v11;
  return ((uint64_t (*)(uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v2 + 8 * ((50 * v16) ^ v12))
                                                                                                - 8))(116, 373, 0xDBD6AF3EFFFF77D6, 0x37FFDDD737458D30, 1953609186, 895754823);
}

uint64_t sub_10003FCB8()
{
  uint64_t v0;
  int v1;
  int v2;
  unsigned int v3;
  _BOOL4 v4;

  v4 = v2 - 165332095 < (int)(v3 + 924297191);
  if (v2 - 165332095 < -1223186457 != v3 > ((4 * v1) ^ 0x48E85C31 ^ (5 * (v1 ^ 0x111u))))
    v4 = v3 > ((4 * v1) ^ 0x48E85C31 ^ (5 * (v1 ^ 0x111u)));
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((224 * !v4) ^ v1)) - 8))();
}

uint64_t sub_10003FD3C()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  int v4;
  _BOOL4 v6;

  v4 = v1 + 886 + v2 + 1146477976;
  v6 = v4 > 88625455 || v4 < v3 + ((v1 - 952) | 0x12A) - 2058858494;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((1248 * v6) ^ v1)) - 12))();
}

uint64_t sub_10003FD98@<X0>(uint64_t a1@<X8>, uint64_t a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  _BOOL4 v17;

  v13 = 4 * (v12 + v8);
  v14 = v3 + v10 + (*(_DWORD *)(*(_QWORD *)(a2 - 0x2DB44D49A49B0026) + v13) ^ v11);
  *(_DWORD *)(*(_QWORD *)(a1 - 0x2DB44D49A49B0026) + v13) = v14 + v11 - (v9 & (2 * v14));
  v15 = v4 + v12 + 1843;
  v17 = v15 <= v5 && v15 >= v7;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((658 * v17) ^ v6)) - 12))();
}

uint64_t sub_10003FE5C()
{
  uint64_t v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((88 * (v1 != ((v2 - 1513) | 0xB0u) + 0x13D68D163745030DLL)) ^ v2))
                            - 8))();
}

void sub_10003FEA0(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  char v3;
  int v4;
  int v5;
  int v6;

  *(_DWORD *)(*(_QWORD *)(a1 - 0x2DB44D49A49B0026) + 4 * (v6 + v4)) = v2
                                                                        - (((v2 << (v3 - 49)) - 1854540300) & v5)
                                                                        - 1388141679;
  *(_DWORD *)(a1 - 0x2DB44D49A49B002ALL) = (((v6 + 1 + v4) * (v1 - 405110594)) ^ 0xAE7F17DF)
                                         + 1605304041
                                         + ((2 * (v6 + 1 + v4) * (v1 - 405110594)) & 0x5CFE2FBE);
}

void sub_100040068(uint64_t a1)
{
  int v1;
  _BOOL4 v3;

  v3 = *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL) != 237901512
    && *(_DWORD *)(*(_QWORD *)a1 - 0x2DB44D49A49B002ALL) != 237901512;
  v1 = *(_DWORD *)(a1 + 16) + 460628867 * ((-2 - ((a1 | 0x675F0E27) + (~(_DWORD)a1 | 0x98A0F1D8))) ^ 0xD43673A5);
  __asm { BR              X13 }
}

uint64_t sub_100040174@<X0>(int a1@<W8>)
{
  uint64_t v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (v3 ^ (2 * (((v3 ^ ((a1 + v2 - 133) < 0x7FFFFF7D)) & 1) == 0))))
                            - ((353 * (v3 ^ 0x3E8u)) ^ 0x588)))();
}

uint64_t sub_1000401C0()
{
  uint64_t v0;
  int v1;
  int v2;

  return (*(uint64_t (**)(uint64_t))(v0 + 8 * (v2 ^ (820 * (v1 > 0)))))(1239661710);
}

uint64_t sub_100040220(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  _BOOL4 v18;
  int v19;
  uint64_t v20;
  int v21;
  _BOOL4 v22;

  v18 = v15 > v17;
  *(_DWORD *)(a12 + 4 * (a1 - 1239661710)) = v13;
  v19 = a1 - 1326985272;
  v20 = (a1 + 1);
  v21 = v18 ^ (v19 < ((v16 - 1678771124) & 0x641005BF) + 2060158673);
  v22 = v19 < v14;
  if (!v21)
    v18 = v22;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v12 + 8 * ((248 * !v18) ^ v16)) - 4))(v20);
}

uint64_t sub_1000402A8()
{
  uint64_t v0;
  int v1;
  int v2;

  return (*(uint64_t (**)(void))(v0 + 8 * (int)(((((v2 + 939314737) & 0xC8032D7F) - 299) * (v1 == 0)) | v2)))();
}

uint64_t sub_1000402E0()
{
  uint64_t v0;
  int v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((((v2 + 931) ^ 0x4B3) * (v1 > 0)) ^ v2))
                            - ((v2 + 1584) ^ 0x671)))();
}

uint64_t sub_100040334(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;

  return ((uint64_t (*)(void))(*(_QWORD *)(v12
                                        + 8
                                        * (int)(((*(_DWORD *)(a12 + 4 * (v15 + v16 + 1)) == v13)
                                               * (((v14 - 489771659) ^ 0xE2CEB3A7)
                                                + ((v14 - 489771659) & 0x1D314FFD)
                                                - 844)) ^ (v14 - 1584)))
                            - 8))();
}

uint64_t sub_100040390()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * (v1 | (4 * ((v2 + v3) < 0x7FFFFFFF)) | (((v2 + v3) < 0x7FFFFFFF) << 9)))
                            - 8))();
}

uint64_t sub_1000403E4@<X0>(int a1@<W8>)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (((*(_DWORD *)(v3 + 4 * (v5 + v6 + 1)) == v2)
                                          * (((v4 + a1) ^ (a1 + 1586)) + ((v4 + a1) & 0x1D314FFD) - 844)) ^ (v4 - 1584)))
                            - 8))();
}

uint64_t sub_100040434()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  *(_DWORD *)(v2 - 116) = v1 - 303 - 1224239923 * ((v2 - 2134978843 - 2 * ((v2 - 120) & 0x80BECF5D)) ^ 0x720D328A);
  *(_QWORD *)(v2 - 112) = v4;
  sub_10002F0FC(v2 - 120);
  *(_DWORD *)(v2 - 116) = v1
                        - 303
                        - 1224239923 * ((((v2 - 120) | 0x1D62533F) + (~(v2 - 120) | 0xE29DACC0)) ^ 0xEFD1AEE9);
  *(_QWORD *)(v2 - 112) = v5;
  sub_10002F0FC(v2 - 120);
  *(_QWORD *)(v2 - 120) = v0;
  *(_QWORD *)(v2 - 104) = v5;
  *(_DWORD *)(v2 - 112) = v1 + 831981571 * ((2 * ((v2 - 120) & 0x6F747E28) - (v2 - 120) - 1869905454) ^ 0x92A51F6) - 660;
  return sub_10004F498(v2 - 120);
}

void sub_100040840(uint64_t a1)
{
  __asm { BR              X9 }
}

uint64_t sub_10004087C@<X0>(uint64_t a1@<X8>)
{
  (*(void (**)(void))(a1 + 208))();
  return 0;
}

uint64_t sub_100040890()
{
  return 4294925273;
}

void sub_10004089C(unint64_t a1)
{
  unsigned int v2;
  int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  _DWORD *v9;
  char *v10;
  uint64_t v11;
  unsigned int v12;
  _BOOL4 v13;
  uint64_t v14;
  char *v15;
  unsigned int v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  unint64_t v22;
  _DWORD *v23;
  int v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  unint64_t *v28;
  int v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  int v33;
  char v34;
  char v35;
  char v36;
  char v37;
  int v38;
  unint64_t *v39;
  unsigned int v40;
  unsigned int v41;

  v2 = 3804331 * ((-2 - ((~(_DWORD)a1 | 0x3DED129D) + (a1 | 0xC212ED62))) ^ 0x4338376B);
  v3 = *(_DWORD *)(a1 + 28);
  v4 = *(_DWORD *)(a1 + 24) + v2;
  v5 = 235795823 * ((&v39 - 1061334659 - 2 * (&v39 & 0xC0BD517D)) ^ 0x54101824);
  v6 = *(_DWORD *)(a1 + 40) + v2;
  v22 = 3804331 * ((-2 - ((~a1 | 0xEED202043DED129DLL) + (a1 | 0x112DFDFBC212ED62))) ^ 0x217B62004338376BLL);
  v7 = v3 - v2;
  v40 = v5 ^ 0xFE0643CC;
  v41 = v4 + v5 + 426522932;
  v28 = &STACK[0x73F39308AC2F38BB];
  v39 = &STACK[0x73F39308AC2F38BB];
  sub_10002D8CC((uint64_t)&v39);
  v8 = v6;
  v9 = (_DWORD *)a1;
  v10 = (char *)*(&off_100180420 + (int)(v4 - 11)) - 4;
  v21 = v7 - 1372468415;
  v20 = v7 + 992622547;
  v18 = v7 + 1509110672;
  v17 = v4 + 1733885513;
  v24 = v7 + 1385117784;
  v15 = (char *)&v15 - 192133341;
  v29 = v4 ^ 0x34;
  v33 = v4 ^ 0x3C;
  v16 = v4 + 1292136346;
  v19 = v4 + 1292136346;
  v32 = v19;
  v31 = v4;
  v26 = vdupq_n_s32(0x1D30BEE6u);
  v27 = vdupq_n_s32(0x1D30BEEEu);
  v25 = vdupq_n_s32(0x1D30BEFFu);
  v23 = v9;
  v11 = *((_QWORD *)v9 + 2);
  v12 = v8 - (((v8 << (((v4 - 87) & 0xDF) + 35)) + (((v4 + 505) | 0xA0) ^ 0x7777A370)) & 0x59B231B0) + 1754589607;
  v34 = (HIBYTE(v12) ^ 0xAC) + ((4 * (v12 >> 25)) ^ 0xA7) - 1;
  v35 = (BYTE2(v12) ^ 0xD9) + ((2 * ((BYTE2(v12) ^ 0xD9 | 0x7E) ^ BYTE2(v12))) ^ 0xB1) - 1;
  v36 = (BYTE1(v12) ^ 0x18) - ((2 * (BYTE1(v12) ^ 0x18)) & 0xFC) - 2;
  v37 = (v8 - ((((_BYTE)v8 << (((v4 - 87) & 0xDF) + 35)) + (((v4 - 7) | 0xA0) ^ 0x70)) & 0xB0) - 89) ^ 0x26;
  v13 = ((2 * v38) & 0x6A ^ 0x2A) + (v38 & 0x3F ^ 0x39FDFCE0u) - 972946737 > 0xFFFFFFBF;
  v14 = *(_QWORD *)&v10[8 * (v13 | (2 * v13) | (v4 + 1539))] - 4;
  v30 = v11;
  __asm { BR              X16 }
}

uint64_t sub_100040C7C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, int a9@<W8>, uint64_t a10, uint64_t a11)
{
  int v11;
  char v12;
  int v13;
  uint64_t v14;
  int v15;

  v15 = v11 - 713;
  *(_BYTE *)(a3 + (v13 + v15 - 1046)) = v12;
  *(_BYTE *)(a3 + a9 + ((v15 - 960) ^ 0xC72A3B59)) = *(_BYTE *)(a6 + 1);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v14 + 8 * (v15 ^ 0x1AD)))(a1, a2, a3, a4, a5, a6, a7, a8, a10, a11);
}

uint64_t sub_10004248C@<X0>(uint64_t a1@<X2>, uint64_t a2@<X5>, int a3@<W8>)
{
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;

  *(_BYTE *)(a1 + (a3 - 953533768 + v5)) = *(_BYTE *)(a2 + (v6 - 637245485));
  return (*(uint64_t (**)(void))(v7 + 8 * (v4 ^ (934 * ((v3 & 0xFFFFFFFC) == 637245484)))))();
}

uint64_t sub_1000424DC@<X0>(uint64_t a1@<X2>, uint64_t a2@<X5>, int a3@<W8>, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t (*a13)(uint64_t), uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;

  *(_BYTE *)(a1 + (a3 - 953533682)) = *(_BYTE *)(a2 + (v21 - 637245569 + v20));
  v23 = 831981571
      * ((((v22 - 160) ^ 0xA1FAE2DE | 0x727E95CD)
        - ((v22 - 160) ^ 0xA1FAE2DE)
        + (((v22 - 160) ^ 0xA1FAE2DE) & 0x8D816A32)) ^ 0x4A25A737);
  *(_DWORD *)(v22 - 160) = v23 ^ 0x5FF5036A;
  *(_DWORD *)(v22 - 156) = v23 + v20 + 1253;
  *(_QWORD *)(v22 - 152) = a20;
  v24 = sub_10005533C(v22 - 160);
  return a13(v24);
}

uint64_t sub_10004257C()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;

  return (*(uint64_t (**)(void))(v3 + 8 * ((((v2 ^ 0x6AF) + 409) * (v0 != v1)) ^ v2)))();
}

uint64_t sub_1000425A8@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  int v2;
  int v3;
  uint64_t v4;
  char v5;
  uint64_t v6;

  *(_BYTE *)(a1 + a2 + v4) = v5;
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * ((((unint64_t)(a2 + 1 + v4) < 0x38) * v3) ^ (v2 + 627)))
                            - 4))();
}

void sub_1000425D8(uint64_t a1, char a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, char a11)
{
  int v11;
  unsigned int v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned int v16;
  char v17;
  unint64_t v18;

  v11 = LOBYTE(STACK[0x2CC]) ^ 0xE;
  if (v11 == 1)
  {
    v15 = STACK[0x2B0];
    v16 = STACK[0x2AC];
    v17 = (LODWORD(STACK[0x2B0]) >> 5) ^ 0x6C;
    LOBYTE(STACK[0x2A4]) = -((LOBYTE(STACK[0x2B0]) << ((a2 + 26) ^ 0x6C)) ^ 0xA8) - 2;
    LOBYTE(STACK[0x2A5]) = v17 + ((v15 >> 4) & 0xFC ^ 0x27) - 1;
    LOBYTE(STACK[0x2A6]) = ((v15 >> 13) ^ 0x62) + ((v15 >> 12) & 0xFC ^ 0x3B) - 1;
    LOBYTE(STACK[0x2A7]) = ((v15 >> 21) ^ 0x29) - ((2 * ((v15 >> 21) ^ 0x29)) & 0xFC) - 2;
    HIDWORD(v18) = v16 ^ 8;
    LODWORD(v18) = v15;
    LOBYTE(STACK[0x2A8]) = (v18 >> 29) - ((2 * (v18 >> 29)) & 0xFC) - 2;
    LOBYTE(STACK[0x2A9]) = ((v16 >> 5) ^ 0x7C) + ((v16 >> 4) & 0xFC ^ 7) - 1;
    LOBYTE(STACK[0x2AA]) = ((v16 >> 13) ^ 0x21) + ((2 * (((v16 >> 13) ^ 0x21 | 0x7E) ^ (v16 >> 13))) ^ 0x41) - 1;
    v14 = ((v16 >> 21) ^ 0xFFFFFFCE) - 4 * (((v16 >> 21) ^ 0xFFFFFFCE) >> 1) - 2;
  }
  else
  {
    if (v11 != 2)
      goto LABEL_6;
    v14 = STACK[0x2AC];
    v12 = STACK[0x2B0];
    LOBYTE(STACK[0x2A4]) = ((LODWORD(STACK[0x2AC]) >> 21) ^ 0xCE) + ((LODWORD(STACK[0x2AC]) >> 20) & 0xFC ^ 0x63) - 1;
    LOBYTE(STACK[0x2A5]) = (a11 & 0x7F ^ (v14 >> 13) ^ 0x4E) - ((2 * (a11 & 0x7F ^ (v14 >> 13) ^ 0x4E)) & 0xFC) - 2;
    LOBYTE(STACK[0x2A6]) = ((v14 >> 5) ^ 0x7C) - ((2 * ((v14 >> 5) ^ 0x7C)) & 0xFC) - 2;
    HIDWORD(v13) = v14 ^ 8;
    LODWORD(v13) = v12;
    LOBYTE(STACK[0x2A7]) = (v13 >> 29) - ((2 * (v13 >> 29)) & 0xFC) - 2;
    LOBYTE(STACK[0x2A8]) = ((v12 >> 21) ^ 0x29) - ((2 * ((v12 >> 21) ^ 0x29)) & 0xFC) - 2;
    LOBYTE(STACK[0x2A9]) = ((v12 >> 13) ^ 0x62) - ((2 * ((v12 >> 13) ^ 0x62)) & 0xFC) - 2;
    LOBYTE(STACK[0x2AA]) = ((v12 >> 5) ^ 0x6C) - ((2 * ((v12 >> 5) ^ 0x6C)) & 0xFC) - 2;
    LOBYTE(v14) = ((16 * v12) ^ 0xAF) + ((8 * v12) ^ 0xAB) - 4;
  }
  LOBYTE(STACK[0x2AB]) = v14;
LABEL_6:
  JUMPOUT(0x100041534);
}

uint64_t sub_100042840(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,char a33)
{
  uint64_t v33;
  int v35;
  unint64_t v36;

  if (a30 == 2)
    return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v33
                                                        + 8
                                                        * ((a2 + 1068) | (32
                                                                        * (LODWORD(STACK[0x2C8]) == (a2 ^ 0x4D4) + 1763402285))))
                                            - 8))(a17);
  if (a30 == 1)
    return ((uint64_t (*)(void))(*(_QWORD *)(v33
                                          + 8
                                          * ((107 * (LODWORD(STACK[0x2C8]) != (((a2 - 52) | 0x480) ^ 0x691B620F))) ^ (a2 + 1100)))
                              - 8))();
  v35 = 23 * (a2 ^ 0x45);
  v36 = ((unint64_t)&a33 ^ 0xBB67EF6777FF5BFBLL)
      + 0x75FF5BDDDFABBD8BLL
      + (((_QWORD)&a33 << (23 * (a2 ^ 0x45u) - 111)) & 0x76CFDECEEFFEB7F0);
  LOBYTE(STACK[0x2C7]) = ((v36 + 122) ^ 0xBA) * (v36 + (v35 ^ 0xFB));
  return ((uint64_t (*)(void))(*(_QWORD *)(v33 + 8 * v35) - 4))();
}

void sub_100042BC4()
{
  JUMPOUT(0x100042B90);
}

uint64_t sub_100042BCC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  v19 = *(_QWORD *)(a15 + 8);
  *(_QWORD *)(v18 - 176) = 0xFEFEFEFEFEFEFEFELL;
  *(_QWORD *)(v18 - 168) = 0xFEFEFEFEFEFEFEFELL;
  v20 = ((2 * ((v18 - 160) & 0x8B7C4E0) - (v18 - 160) - 146261217) ^ 0x63E57246) * a3;
  *(_QWORD *)(v18 - 120) = v18 - 176;
  *(_QWORD *)(v18 - 160) = v18 - 192;
  *(_QWORD *)(v18 - 144) = &STACK[0x258];
  *(_QWORD *)(v18 - 136) = v19;
  *(_DWORD *)(v18 - 124) = (v16 + 1799) ^ v20;
  *(_DWORD *)(v18 - 152) = v20 + 2046750649;
  v21 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + (v16 ^ 0xF2)) - 8))(v18 - 160);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v15 + 8 * ((1044 * (*(_DWORD *)(v18 - 128) == v17)) ^ v16))
                                          - ((v16 + 899) | 0x91u)
                                          + 1175))(v21);
}

uint64_t sub_100042CC0()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  _BOOL4 v10;

  v6 = *(unsigned __int8 *)(*(_QWORD *)(v1 + 32) + v0 - 0x6BCE5708FE675609);
  v7 = ((v6 - *(unsigned __int8 *)(v5 + v0 - 0x6BCE5708FE675609)) ^ 0x6ED67FBB)
     - 1335563
     + ((2 * (v6 - *(unsigned __int8 *)(v5 + v0 - 0x6BCE5708FE675609))) & 0xDDACFF76);
  v8 = v0 + 1;
  v10 = v7 != 1858215600 || v8 == ((v4 - 1098) ^ (unint64_t)(v2 + 67));
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((618 * v10) ^ v4)) - 8))();
}

uint64_t sub_100042D48@<X0>(int a1@<W8>)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v4 = 460628867 * ((~(v3 - 160) & 0x21D797604EF5C5DELL | (v3 - 160) & 0xDE28689FB10A3A21) ^ 0x6348DA0E026347A3);
  *(_DWORD *)(v3 - 144) = ((a1 + 1328983807) | 9) + v4;
  *(_DWORD *)(v3 - 140) = a1 + 1328983807 - v4;
  *(_DWORD *)(v3 - 148) = ((a1 + 1328983807) ^ 0x8B) - v4;
  *(_QWORD *)(v3 - 136) = v4 + v1;
  *(_QWORD *)(v3 - 128) = 1858215600 - v4;
  *(_DWORD *)(v3 - 160) = v4;
  *(_DWORD *)(v3 - 156) = (a1 - 1017209884) ^ v4;
  v5 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + a1 - 76) - 8))(v3 - 160);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v2 + 8 * *(int *)(v3 - 152)) - 8))(v5);
}

void sub_100042E1C()
{
  uint64_t v0;

  *(_DWORD *)(v0 + 4) = 489733862;
}

void sub_100042E68(uint64_t a1)
{
  __asm { BR              X8 }
}

uint64_t sub_100042EF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a67;
  uint64_t v67;

  a21 = 2037438032;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, int *, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t, unint64_t *))(*(_QWORD *)(v67 + 3952) - 4))(a1, a2, a3, a4, a5, &a21, a7, 2507737077, a9, &a67, a11, &STACK[0x2DA3ABA5EF040AE9]);
}

uint64_t sub_100043064()
{
  int v0;
  int v1;
  uint64_t v2;
  char v3;
  char v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((230 * (((v1 == 1787230218) ^ (v4 + v3 + v0 - 127 - 60)) & 1)) ^ v0))
                            - 4))();
}

uint64_t sub_1000430B0@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14)
{
  int v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  unsigned int v21;
  _BOOL4 v22;

  v17 = v16 + a1;
  v18 = (v17 - 128) ^ 0x3EC;
  v19 = (v17 - 128) | 0x80;
  v20 = v17 + 840;
  v21 = v19 + v14 - 446080321;
  v22 = a14 - 463761223 < v21;
  if (a14 - 463761223 < (v18 ^ 0x4087554Bu) != v21 < 0x408756E2)
    v22 = v21 < 0x408756E2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v15 + 8 * (v20 ^ (16 * v22))) - 12))();
}

uint64_t sub_1000432F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, _QWORD *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  int v21;
  uint64_t v22;

  v21 = 460628867 * ((~((v20 - 160) | 0x6BDD079) + ((v20 - 160) & 0x6BDD079)) ^ 0xB5D4ADFB);
  a6[72] = a17;
  a6[76] = a12;
  a6[75] = a13;
  a6[74] = a15;
  a6[70] = a14;
  *(_DWORD *)(v20 - 152) = v21 + v17 - 1455228513;
  *(_DWORD *)(v20 - 132) = v19 - v21 + 186;
  v22 = ((uint64_t (*)(uint64_t))(*(_QWORD *)(a5 + 8 * (v19 - 186)) - 4))(v20 - 160);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v18
                                                      + 8
                                                      * (((*(_DWORD *)(v20 - 136) == 489733862)
                                                        * (v19 + ((v19 - 174) | 0x528) - 70)) ^ v19))
                                          - 4))(v22);
}

uint64_t sub_1000433E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v11
                                                                                          + 8
                                                                                          * (int)(((*(_DWORD *)(v13 + 48 * (v9 + a8)) != 956521911)
                                                                                                 * ((v12 + ((v10 - 439803738) & 0x1A36DADF) - 280) ^ ((v10 + 170442196) | 0xA0010C40))) ^ v10))
                                                                              - 4))(a1, a2, a3, a4, v8);
}

uint64_t sub_10004345C()
{
  int v0;
  unsigned int v1;
  int v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((2275 * ((v0 ^ 0x46832FB9 ^ (v1 - 9707850) & 0xAABDEFD7) == v3 - 973299127)) ^ v1))
                            + 2854866763
                            - (v2 - 197)
                            + 4))();
}

void sub_1000434CC(int a1@<W8>)
{
  __asm { BR              X10 }
}

uint64_t sub_1000435A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20)
{
  int v20;
  uint64_t v21;

  return ((uint64_t (*)(void))(*(_QWORD *)(v21
                                        + 8
                                        * ((115
                                          * (((((v20 + 1972291997) & 0x8A7133F7) - 0x52D08832010C84D4) ^ (a20 - 1528691550))
                                           + 0x52D08832F37818DBLL
                                           + ((2 * (a20 - 1528691550)) & 0x1FDE6F7E2) == a7)) ^ v20))
                            - 12))();
}

uint64_t sub_100043658()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  v5 = *(unsigned __int8 *)(v0 + v3 - 0x7705FC3E89A913DLL)
     - (*(unsigned __int8 *)(v1 + v3 - 0x7705FC3E89A913DLL) ^ 0xFE);
  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((343
                                          * (((v5 << (((v2 + 75) | 0x20) - 47)) & (((v2 - 1474280308) | 0x2098A02) ^ 0xD5D6203D))
                                           + (v5 ^ 0x3FFFF7B7) == 1073739703)) ^ v2))
                            - 4))();
}

uint64_t sub_1000436F0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unint64_t a7)
{
  unint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  _BOOL4 v11;

  v11 = v7 < a7;
  if (v11 == v8 - 0x7705FC2F62EFC70 < a7)
    v11 = v8 - 0x7705FC2F62EFC70 < v7;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * (((((v9 - 688) | 0x45) - 82) * !v11) ^ v9)) - 12))();
}

uint64_t sub_100043758()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (int)(((v2 ^ (v4 + 67) ^ (v4 + ((v2 + 1742772986) & 0x981F67DF) - 2045))
                                               * (v0 - v1 == 198084261)) ^ v2))
                            - 4))();
}

uint64_t sub_1000437C0@<X0>(uint64_t a1@<X8>)
{
  int v1;
  uint64_t v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * (v1 ^ (37 * (a1 != 0))))
                            - (v1 - v3 - 730)
                            - ((v1 - v3 - 730) ^ 0xFFFFFFFFFFFFFFE6)))();
}

uint64_t sub_1000437F4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21)
{
  int v21;
  uint64_t v22;
  int v23;

  return ((uint64_t (*)(void))(*(_QWORD *)(v22
                                        + 8
                                        * ((((a21 & 0xFFFFFFF0) == 2037438032) * (v21 + v23 + 1680)) ^ (v21 + v23)))
                            - 4))();
}

uint64_t sub_100043828@<X0>(uint64_t a1@<X5>, uint64_t a2@<X8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  int a64;
  int a65;
  int a66;
  int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  int v72;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  if (!a2)
    return ((uint64_t (*)(void))(*(_QWORD *)(v69
                                          + 8
                                          * ((((a15 & 0xFFFFFFF0) == 2037438032) * (v71 + v72 + 1680)) ^ (v71 + v72)))
                              - 4))();
  if (a2 != 3)
    return ((uint64_t (*)(void))(*(_QWORD *)(v69
                                          + 8
                                          * ((106
                                            * (((24 - v71) ^ (*(_DWORD *)(v73 + 48 * v70 + 36)
                                                                             + 360253429 < v74)) & 1)) ^ (v72 - 1440100547)))
                              - 4))();
  a64 = v66;
  a65 = a14;
  *(_QWORD *)(a1 + 400) = a13;
  a66 = HIDWORD(a14) - v67 + 1604277838;
  *(_QWORD *)(a1 + 416) = a11 + (v67 - 1546372649);
  v75 = (*(uint64_t (**)(uint64_t, uint64_t))(v73 + 48 * v70 + 8))(a5, a4);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v69 + 8 * ((1286 * ((_DWORD)v75 + 489733862 - ((2 * (_DWORD)v75) & 0x3A617DCC) == 489733862)) ^ (v71 + v72))) - 4))(v75, v76, v77, 489733862, v68, &a15, v78, 2507737077, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13,
           a14,
           a15,
           a16,
           a17,
           a18,
           a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48,
           a49,
           a50,
           a51,
           a52,
           a53,
           a54,
           a55,
           a56,
           a57);
}

uint64_t sub_100043990@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, int a9@<W8>, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,int a22)
{
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;

  v29 = a6 + 24 * (((a9 + 1377585914) & 0xADE3B4EF ^ 0x868F291F) + v22);
  *(_DWORD *)(v29 + 8) = v23;
  *(_DWORD *)(v29 + 12) = v24;
  *(_QWORD *)(v29 + 16) = a18;
  *(_DWORD *)(v29 + 24) = a22;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v25 + 8 * ((1134 * (*(_DWORD *)(v27 + 48 * v26 + 32) + 360253429 < v28)) ^ a9)) - 4))(a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13);
}

uint64_t sub_100043A24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  int v12;
  uint64_t v13;
  int v14;
  int v15;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v13 + 8 * ((((_DWORD)a4 == 489733862) * ((v12 + 22 - v15) ^ (v14 - 114))) ^ (v12 + 22))) - 4))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

void sub_100043A78()
{
  JUMPOUT(0x100043A88);
}

void sub_100043AD4(uint64_t a1, uint64_t a2)
{
  __asm { BR              X11 }
}

uint64_t sub_100043B24@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;
  int v3;
  int v4;

  *(_DWORD *)(*(_QWORD *)(a2 + 96) + 24) = v3;
  v4 = *(_DWORD *)(a1 + 4) - ((2 * *(_DWORD *)(a1 + 4) + 163842372) & 0x2E4F20BE) + 1007260929;
  return ((uint64_t (*)(_QWORD))(*(_QWORD *)(v2
                                                     + 8
                                                     * ((211
                                                       * (((2 * v4) & 0xABDFB9C6 ^ 0x2A4F2086)
                                                        + (v4 ^ 0x42C84CBC)
                                                        + 1862005726 == 1156305089)) ^ 0x552u))
                                         - 4))(0);
}

uint64_t sub_100043BBC()
{
  uint64_t v0;
  int v1;
  int v2;

  return (*(uint64_t (**)(void))(v0 + 8 * ((11 * ((((v2 + v1 + 705700637) < 8) ^ 0xE5) & 1)) | 0x4E4u)))();
}

uint64_t sub_100043C2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  uint64_t v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5
                                        + 8
                                        * ((94
                                          * ((((a5 ^ 0x7A) + 80) ^ 0x81 ^ (v6
                                                                                          - a1
                                                                                          - (unint64_t)(((a5 ^ 0x57A) + 35890768) & 0xD19)
                                                                                          + 1284 < 0x20)) & 1)) ^ a5 ^ 0x57Au))
                            - 12))();
}

uint64_t sub_100043C88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  uint64_t v5;
  int v6;
  unsigned int v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * (((((a5 + 38847302) | 0xD1311) ^ (v6 + 1324)) * (v7 > 0x1F)) ^ a5))
                            - ((a5 - 776) | 0x128)
                            + 800))();
}

uint64_t sub_100043CD8@<X0>(int a1@<W2>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v8 = v7 + (a1 ^ (v5 + 1519) ^ v4);
  v9 = *(_OWORD *)(v3 + v8 - 15);
  v10 = *(_OWORD *)(v3 + v8 - 31);
  v11 = a2 + v8;
  *(_OWORD *)(v11 - 15) = v9;
  *(_OWORD *)(v11 - 31) = v10;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((47 * ((v6 & 0xFFFFFFE0) == 32)) ^ (a1 - 39704276))) - 4))();
}

void sub_100043D38()
{
  JUMPOUT(0x100043CF4);
}

uint64_t sub_100043D44(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7;
  int v8;
  int v9;

  return (*(uint64_t (**)(_QWORD))(v7 + 8
                                                * ((((((a7 - 785) | 0x100) + v8) ^ (v8 + 1222)) * (v9 == a2)) | a7)))(0);
}

uint64_t sub_100043D74(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  char v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((890 * ((v6 & 0x18) == ((a5 - 1177) ^ 0x6F))) ^ a5))
                            - (a5 - 480)
                            + 800))();
}

uint64_t sub_100043DB0@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;

  *(_QWORD *)(a3 - 7 + (v6 + v7 + v8 - a2)) = *(_QWORD *)(v4 - 7 + (v6 + v7 + v8 - a2));
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (((16 * (a2 - (v5 & 0xFFFFFFF8) == -8)) | ((a2 - (v5 & 0xFFFFFFF8) == -8) << 7)) ^ a1))
                            - ((a1 - 1003906954) & 0x3BD665FF ^ 0x19ALL)))();
}

void sub_100043E20()
{
  JUMPOUT(0x100043DF4);
}

uint64_t sub_100043E2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  int v6;
  int v7;

  return ((uint64_t (*)(_QWORD))(*(_QWORD *)(v5
                                                     + 8 * (((((v7 - 399) | 0x60) ^ (v7 + 263)) * (v6 == a5)) ^ v7))
                                         - 12))(0);
}

uint64_t sub_100043E5C@<X0>(int a1@<W2>, int a2@<W3>, uint64_t a3@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;

  *(_BYTE *)(a3 + (v5 + a2 + 1815)) = *(_BYTE *)(v4 + (v5 + a2 + 1815));
  return ((uint64_t (*)(_QWORD))(*(_QWORD *)(v3
                                                     + 8 * ((827 * (a2 - 1 == (a1 ^ (v6 + 1241)) + 1116599650)) ^ a1))
                                         - 12))(0);
}

void sub_100043EB0(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 36) ^ (235795823
                             * ((-2 - ((a1 ^ 0x29040430 | 0x96E8ABCB) + (a1 ^ 0x10C0A082 | 0x69175434))) ^ 0x52961214));
  __asm { BR              X13 }
}

uint64_t sub_100043FF0()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v2
                                                      + 8
                                                      * ((23
                                                        * (((v1 << ((v0 + 23) & 0xDF ^ 0x44)) & 0xBDAD79FE ^ 0xB1A1096E)
                                                         + ((v0 + 103232250) ^ v1)
                                                         + 725212067 == 168859810)) ^ v0))
                                          - 4))(725212067);
}

uint64_t sub_100044078(uint64_t a1, int a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5
                                        + 8
                                        * ((1733
                                          * (a4 + a2 + 556352257 >= ((v4 + 2006940053) & 0x886080FE ^ 0xFFFFF894)
                                                                  + 114 * ((v4 - 1047) ^ 0x226))) ^ (v4 - 1047)))
                            - 12))();
}

uint64_t sub_100044110(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8
                                                                                 + 8
                                                                                 * (((a7 >> 4 != 233663440)
                                                                                   * ((v7 + 40) ^ 0x10E)) ^ v7))
                                                                     - 4))(a1, a2, a3, a4);
}

uint64_t sub_10004415C(uint64_t a1, int a2, int a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  BOOL v19;
  unint64_t v20;
  int v22;

  v11 = a3 + a4 + a2 + ((a5 + 278) | 0xAu) + 1384 - 1938;
  v12 = v11 + v5;
  v13 = v11 + *(_QWORD *)(v9 - 120);
  v14 = (a4 + a2) & 0xF;
  v15 = v6 + v14 - v13;
  v16 = (v8 | v14) - v13;
  v17 = (v7 | v14) - v13;
  v19 = (unint64_t)(v12 - v13) > 0xF && v15 > 0xF && v16 > 0xF;
  v20 = v17 + 1;
  v22 = v19 && v20 > 0xF;
  return (*(uint64_t (**)(void))(v10 + 8 * ((21 * v22) ^ a5)))();
}

uint64_t sub_1000441D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t (*v8)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD);

  v8 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v7
                                                                                      + 8 * (v4 ^ (26 * (v5 > 0xF))))
                                                                          - (((v4 + 185) | 0x104u) ^ 0x3EBLL));
  *(_DWORD *)(v6 - 136) = v5;
  return v8(a1, a2, a3, a4, 0);
}

uint64_t sub_100044214(uint64_t a1, int a2, int a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  int8x16x4_t v20;
  int8x16x4_t v21;

  v20.val[1].i64[0] = v9 & 0xF;
  v20.val[1].i64[1] = ((_BYTE)v9 - 1) & 0xF;
  v20.val[2].i64[0] = ((_BYTE)v9 + 14) & 0xF;
  v20.val[2].i64[1] = ((_BYTE)v9 + 13) & 0xF;
  v20.val[3].i64[0] = ((_BYTE)v9 + 12) & 0xF;
  v20.val[3].i64[1] = ((_BYTE)v9 + 11) & 0xF;
  v21.val[0].i64[0] = ((_BYTE)v9 + 10) & 0xF;
  v21.val[0].i64[1] = ((_BYTE)v9 + 9) & 0xF;
  v21.val[1].i64[0] = ((_BYTE)v9 + 8) & 0xF;
  v21.val[1].i64[1] = ((_BYTE)v9 + 7) & 0xF;
  v21.val[2].i64[0] = ((_BYTE)v9 + 6) & 0xF;
  v21.val[2].i64[1] = (v9 + 5) & 0xF;
  v21.val[3].i64[0] = ((_BYTE)v9 + 4) & 0xF;
  v21.val[3].i64[1] = ((_BYTE)v9 + 3) & 0xF;
  v13 = a4 + a2 + a3;
  v14.i64[0] = 0x1F1F1F1F1F1F1F1FLL;
  v14.i64[1] = 0x1F1F1F1F1F1F1F1FLL;
  v15.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v15.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v20.val[0].i64[0] = ((_BYTE)a4 + (_BYTE)a2 + (_BYTE)a3) & 0xF;
  v20.val[0].i64[1] = ((_BYTE)v9 + 1) & 0xF;
  v16.i64[0] = vqtbl4q_s8(v20, (int8x16_t)xmmword_100151920).u64[0];
  v16.i64[1] = vqtbl4q_s8(v21, (int8x16_t)xmmword_100151920).u64[0];
  v17 = vrev64q_s8(veorq_s8(veorq_s8(*(int8x16_t *)(v5 - 15 + v13), *(int8x16_t *)(v6 + v20.val[0].i64[0] - 15)), veorq_s8(*(int8x16_t *)(v8 + v20.val[0].i64[0] - 15), *(int8x16_t *)(v20.val[0].i64[0] + v7 - 14))));
  v18 = vrev64q_s8(veorq_s8(veorq_s8(vextq_s8(v17, v17, 8uLL), v15), vmulq_s8(v16, v14)));
  *(int8x16_t *)(*(_QWORD *)(v11 - 120) - 15 + v13) = vextq_s8(v18, v18, 8uLL);
  return ((uint64_t (*)(void))(*(_QWORD *)(v12 + 8 * ((1130 * ((v10 & 0xFFFFFFF0) == 16)) ^ (v4 + 348)))
                            - (v4 + 1071)
                            + 1617))();
}

void sub_100044384()
{
  JUMPOUT(0x1000442FCLL);
}

uint64_t sub_100044390()
{
  int v0;
  int v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v2 + 8 * (int)(v0 & 0x8D7AC57F ^ (241 * (v1 == 0xD8F185B7)))))();
}

uint64_t sub_1000443F4()
{
  unsigned int v0;
  uint64_t v1;
  int v2;
  int v3;
  unsigned int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  uint64_t v11;

  v10 = v4 > 0x1D19DBD6;
  v11 = (v6 - 531228858);
  *(_BYTE *)(*(_QWORD *)(v8 - 120) + v11) = *(_BYTE *)(v1 + v11) ^ (97 * ((v6 + 70) & 0xF)) ^ *(_BYTE *)(*(_QWORD *)(v7 + 8 * (v2 ^ 0x56F)) + (v11 & 0xF)) ^ *(_BYTE *)(*(_QWORD *)(v7 + 8 * (v2 - 1387)) + (v11 & 0xF) - 12) ^ *(_BYTE *)(*(_QWORD *)(v7 + 8 * (v2 ^ 0x5D1)) + (v11 & 0xF) - 8) ^ 0xFE;
  if (v10 == v6 - 1019462800 < (v3 + 701))
    v10 = v6 - 1019462800 < v0;
  return (*(uint64_t (**)(void))(v9 + 8 * ((!v10 * v5) ^ v2)))();
}

uint64_t sub_1000444C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7
                                        + 8
                                        * ((3649 * (((*(_DWORD *)(v6 - 136) == a5) ^ (v5 - 88)) & 1)) ^ v5))
                            - (v5 ^ 0x31Cu)
                            + 1345))();
}

uint64_t sub_100044504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  int v6;
  char v7;
  uint64_t v8;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v8
                                                                                                  + 8 * (((((((v5 - 1625) | 0x22A) - 958116403) & 0x391BB79A) - 1909) * ((v7 & 8) == 0)) ^ ((v5 - 1625) | 0x22A)))
                                                                                      - (((v5 - 1625) | 0x22Au) ^ 0x226)))(a1, a2, a3, a4, a5, (v6 - a5));
}

uint64_t sub_10004455C(char a1, int a2, int a3, int a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46)
{
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char v50;
  int v51;
  int v52;
  uint64_t v53;
  unsigned int v54;
  int v55;
  char v56;
  uint64_t v57;
  int8x16x4_t v59;

  v54 = ((v52 - 15) ^ 0xFFFFFC20) & v51;
  *(_QWORD *)(v53 - 128) = *(_QWORD *)(v53 - 120) - 7;
  v55 = -a5;
  *(_DWORD *)(v53 - 144) = v54;
  v56 = a1 + a4 + a2;
  *(_DWORD *)(v53 - 152) = v52 - 432;
  v57 = (v55 + a4 + a2 + a3);
  v59.val[0].i64[0] = ((_BYTE)v55 + (_BYTE)a4 + (_BYTE)a2 + (_BYTE)a3) & 0xF;
  v59.val[0].i64[1] = ((_BYTE)v55 + v56 - 36) & 0xF;
  v59.val[1].i64[0] = ((_BYTE)v55 + v50) & 0xF;
  v59.val[1].i64[1] = ((_BYTE)v55 + v56 - 22) & 0xF;
  v59.val[2].i64[0] = ((_BYTE)v55 + v56 - 23) & 0xF;
  v59.val[2].i64[1] = ((_BYTE)v55 + v56 - 24) & 0xF;
  v59.val[3].i64[0] = ((_BYTE)v55 + (_BYTE)a4 + (_BYTE)a2 + (_BYTE)v52 + a1) & 0xF;
  v59.val[3].i64[1] = ((_BYTE)v55 + v56 - 26) & 0xF;
  *(int8x8_t *)(*(_QWORD *)(v53 - 128) + v57) = vrev64_s8(veor_s8(veor_s8(vrev64_s8(veor_s8(veor_s8(*(int8x8_t *)(v46 - 7 + v57), *(int8x8_t *)(v47 + (v57 & 0xF) - 7)), veor_s8(*(int8x8_t *)(v49 + (v57 & 0xF) - 7), *(int8x8_t *)((v57 & 0xF) + v48 - 6)))), (int8x8_t)0xFEFEFEFEFEFEFEFELL), vmul_s8((int8x8_t)*(_OWORD *)&vqtbl4q_s8(v59, (int8x16_t)xmmword_100151930), (int8x8_t)0x1F1F1F1F1F1F1F1FLL)));
  return ((uint64_t (*)(__n128))(*(_QWORD *)(a46 + 8 * ((63 * (v55 != 8 - v54)) ^ (v52 - 15))) - 4))((__n128)xmmword_100151930);
}

void sub_1000446AC()
{
  JUMPOUT(0x1000445D4);
}

uint64_t sub_1000446D4()
{
  uint64_t v0;
  uint64_t v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * ((((*(_DWORD *)(v0 - 152) + 1371) ^ 0x73)
                                          * (*(_DWORD *)(v0 - 136) == *(_DWORD *)(v0 - 144))) ^ *(_DWORD *)(v0 - 152)))
                            - ((19 * (*(_DWORD *)(v0 - 152) ^ 0x270u)) ^ 0x549)))();
}

uint64_t sub_10004472C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8)
{
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  *(_BYTE *)(*(_QWORD *)(v13 - 120) + (a6 - 168860798)) = *(_BYTE *)(v10 + ((a6 - 168860798) & 0xFLL)) ^ *(_BYTE *)(v8 + (a6 - 168860798)) ^ *(_BYTE *)(v12 + (((_BYTE)a6 - 126) & 0xF)) ^ (19 * (a8 ^ 0xD5) - 71) ^ *(_BYTE *)((((_BYTE)a6 - 126) & 0xF) + v11 + 1) ^ (31 * ((a6 - 126) & 0xF));
  return ((uint64_t (*)(void))(*(_QWORD *)(v14 + 8 * ((1861 * (a6 - 1 == v9)) ^ (a8 - 1654))) - 4))();
}

uint64_t sub_1000447B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  int v43;

  v41 = *(_QWORD *)(v38 + 24);
  *(int8x16_t *)(v39 - 112) = veorq_s8(*(int8x16_t *)*(_QWORD *)(v38 + 40), (int8x16_t)xmmword_100151940);
  if (*(_QWORD *)(v39 - 120))
    v42 = v41 == 0x697D3DFF8FBD18CALL;
  else
    v42 = 1;
  v43 = !v42;
  HIDWORD(a12) = v37 << ((a7 - 72) & 0x9F ^ 0x9C);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v40 + 8 * (int)((246 * v43) ^ a7)) - 499 * (a7 ^ 0x546) + 1485))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37);
}

uint64_t sub_100044850(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37)
{
  int v37;
  int v38;
  uint64_t v39;
  unsigned int v40;
  _BOOL4 v42;

  v40 = v37 ^ 0xFDCE49BB;
  v42 = (((BYTE4(a12) & 0x76) + (_BYTE)v40 + (_BYTE)v38 - 60 + 104) & 0xF) != 0
     || (HIDWORD(a12) & 0xFB9C9376) + v40 == -36812357;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v39 + 8 * ((v42 * ((v38 - 577635870) & 0x226E03FF ^ 0x7B)) ^ v38)) - 8))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37);
}

uint64_t sub_1000448C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11, uint64_t a12, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,int a47,int a48)
{
  uint64_t v48;

  return ((uint64_t (*)(void))(*(_QWORD *)(v48
                                        + 8
                                        * (a48 ^ (59
                                                * (((2 * (a11 - (a14 & 0xE7A1C8A) - 1925308772)) & 0xCDF33E76 ^ 0xC721C02)
                                                 + ((a11 - (a14 & 0xE7A1C8A) - 1925308772) ^ 0x61C4917E)
                                                 - 37752322 == 1689882937))))
                            - 4))();
}

uint64_t sub_10004499C()
{
  unsigned int v0;
  int v1;
  int v2;
  uint64_t v3;

  return (*(uint64_t (**)(uint64_t))(v3
                                            + 8
                                            * ((89
                                              * (v2 + v1 + ((v0 - 1816128180) & 0x6C3FE7EF) - 1727635260 - 1356 >= ((v0 - 127) ^ 0x79A))) ^ v0)))(2567332036);
}

uint64_t sub_100044A20(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7)
{
  uint64_t v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7
                                        + 8
                                        * (((a1 + a7 - 16 < (((a6 - 1229) | 0x50A) ^ 0xFFFFFA7A))
                                          * ((57 * (a6 ^ 0x56F)) ^ 0x755)) ^ a6))
                            - 8))();
}

uint64_t sub_100044A74(int a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _BOOL4 v22;
  int v25;

  v10 = (v7 + v6 + a1);
  v11 = *(_QWORD *)(v8 - 120);
  v12 = v10 + v11 + 1;
  v13 = (202 * (a3 ^ 0x58F) - 995) & v10;
  v14 = v4 + v13 - v10;
  v15 = v13 + v4 + 1;
  v16 = v13 + v5 - v10 + 2;
  v17 = v13 + v5 + 3;
  v18 = v13 + v3;
  v19 = v18 - v10 + 4;
  v20 = v18 + 5;
  v22 = v15 > v11 && v14 < v12;
  if (v17 > v11 && v16 < v12)
    v22 = 1;
  v25 = v20 > v11 && v19 < v12 || v22;
  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * ((810 * (v25 ^ 1)) ^ a3)) - 8))();
}

uint64_t sub_100044B1C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v7;
  uint64_t v8;

  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(v8
                                                             + 8
                                                             * ((v7 < ((((a7 - 1689007093) & 0x64AC37DA) - 1553) ^ a7 ^ 0x225u)) ^ a7)))(a1, a2, 0);
}

uint64_t sub_100044B5C(int a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16x4_t v17;
  int8x16x4_t v18;

  v17.val[1].i64[0] = ((_BYTE)a2 + 4) & 0xF;
  v17.val[1].i64[1] = ((_BYTE)a2 + 3) & 0xF;
  v17.val[2].i64[0] = ((_BYTE)a2 + 2) & 0xF;
  v17.val[2].i64[1] = ((_BYTE)a2 + 1) & 0xF;
  v17.val[3].i64[0] = a2 & 0xF;
  v17.val[3].i64[1] = ((_BYTE)a2 - 1) & 0xF;
  v12 = v9 + v8 + a1;
  v13.i64[0] = 0x7777777777777777;
  v13.i64[1] = 0x7777777777777777;
  v17.val[0].i64[0] = v12 & 0xF;
  v17.val[0].i64[1] = ((_BYTE)a2 + 5) & 0xF;
  v14.i64[0] = vqtbl4q_s8(v17, (int8x16_t)xmmword_100151920).u64[0];
  v18.val[0].i64[1] = ((_BYTE)a2 + 13) & 0xF;
  v18.val[1].i64[1] = ((_BYTE)a2 + 11) & 0xF;
  v18.val[2].i64[1] = (a2 + 9) & 0xF;
  v18.val[3].i64[1] = ((_BYTE)a2 + 7) & 0xF;
  v18.val[0].i64[0] = ((_BYTE)a2 + 14) & 0xF;
  v18.val[1].i64[0] = ((_BYTE)a2 + 12) & 0xF;
  v18.val[2].i64[0] = (a2 + 10) & 0xF;
  v18.val[3].i64[0] = ((_BYTE)a2 + 8) & 0xF;
  v14.i64[1] = vqtbl4q_s8(v18, (int8x16_t)xmmword_100151920).u64[0];
  v15 = vrev64q_s8(vmulq_s8(v14, v13));
  *(int8x16_t *)(*(_QWORD *)(v10 - 120) - 15 + v12) = veorq_s8(veorq_s8(veorq_s8(*(int8x16_t *)(v5 + v17.val[0].i64[0] - 15), *(int8x16_t *)(*(_QWORD *)(v10 - 120) - 15 + v12)), veorq_s8(*(int8x16_t *)(v17.val[0].i64[0] + v6 - 13), *(int8x16_t *)(v17.val[0].i64[0] + v4 - 11))), vextq_s8(v15, v15, 8uLL));
  return (*(uint64_t (**)(void))(v11 + 8 * ((((v7 & 0xFFFFFFF0) == 16) * (((a4 - 455) | 0x80) + 1800)) ^ a4)))();
}

void sub_100044CB0()
{
  JUMPOUT(0x100044C34);
}

uint64_t sub_100044CBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46)
{
  int v46;
  uint64_t v47;
  unsigned __int8 *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  uint64_t v53;
  int v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  unsigned __int8 v63;
  int v64;
  int v65;
  int v66;
  int v67;
  unsigned int v68;
  int v69;
  int v70;
  int v71;
  unsigned int v72;
  uint64_t v73;
  unint64_t v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  uint64_t v82;
  int v83;
  int v84;
  unsigned int v85;
  int v86;
  int v87;
  int v88;
  unsigned int v89;
  int v90;
  int v91;
  unsigned int v92;
  unsigned int v93;
  int v94;
  unsigned int v95;
  int v96;
  int v97;
  int v98;
  int v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  int v104;
  unsigned int v105;
  int v106;
  unsigned int v107;
  unsigned int v108;
  int v109;
  unsigned int v110;
  int v111;
  int v112;
  int v113;
  unsigned int v114;
  int v115;
  uint64_t v116;
  int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned __int8 *v121;
  uint64_t v122;
  uint64_t v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  int v128;
  int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  int v142;
  int v143;
  int v144;
  unsigned int v145;
  unsigned int v146;
  int v147;
  int v148;
  unsigned int v149;
  int v150;
  unsigned int v151;
  unsigned int v152;
  int v153;
  int v154;
  unsigned int v155;
  unsigned int v156;
  int v157;
  int v158;
  unsigned int v159;
  unsigned int v160;
  int v161;
  unsigned int v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  unsigned int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  int v173;
  int v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  unsigned int v178;
  int v179;
  int v180;
  int v181;
  unsigned int v182;
  int v183;
  unsigned int v184;
  unsigned int v185;
  unsigned int v186;
  int v187;
  int v188;
  unsigned int v189;
  int v190;
  int v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  int v195;
  int v196;
  unsigned int v197;
  unsigned int v198;
  int v199;
  char *v200;
  uint64_t v201;
  int v202;
  char *v203;
  int v204;
  int v205;
  char *v206;
  int v207;
  unsigned int v208;
  uint64_t v209;
  char *v210;
  char *v211;
  char *v212;
  char *v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  unint64_t v233;
  uint64_t v234;
  uint64_t v235;
  unint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  int v241;
  int v242;
  int v243;
  int v244;
  int v245;
  int v246;
  int v247;
  int v248;
  int v249;
  unsigned int v250;
  int v251;
  unsigned int v252;

  v52 = (v46 - 1415924737) & 0x54654FD7;
  v53 = *(_QWORD *)(v50 + 8 * (v46 & 0x2BFEB86E)) - 12;
  v54 = *(unsigned __int8 *)(v53 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C9) ^ 0x85));
  HIDWORD(v55) = v54 ^ 0xC;
  LODWORD(v55) = (v54 ^ 0x40) << 24;
  LOBYTE(v54) = (v55 >> 30) ^ (((v46 - 1) & 0xD7) + 13);
  v56 = *(_QWORD *)(v50 + 8 * (v46 ^ 0x31Fu)) - 4;
  v57 = *(unsigned __int8 *)(v56 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18BFLL) ^ 0xBFLL));
  HIDWORD(v55) = v57 ^ 5;
  LODWORD(v55) = (v57 ^ 0x60) << 24;
  LOBYTE(v57) = v55 >> 28;
  v58 = *(unsigned __int8 *)(v53 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C5) ^ 0x6FLL));
  HIDWORD(v55) = v58 ^ 0xC;
  LODWORD(v55) = (v58 ^ 0x40) << 24;
  v59 = v54 << 16;
  v60 = *(_QWORD *)(v50 + 8 * (v46 - 723)) - 12;
  v61 = v57 | ((*(unsigned __int8 *)(v60 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C0) ^ 0xB7)) ^ 0xC1) << 8);
  v62 = *(_QWORD *)(v50 + 8 * (v46 ^ 0x382u));
  v63 = *(_BYTE *)(v62 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18BELL) ^ 0xD8));
  v64 = (((v55 >> 30) ^ 0x68) << 16) | ((*(unsigned __int8 *)(v60
                                                                             + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C4) ^ 0xDFLL)) ^ 0xE0) << 8);
  v65 = *(unsigned __int8 *)(v56 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18BBLL) ^ 0xBCLL));
  HIDWORD(v55) = v65 ^ 5;
  LODWORD(v55) = (v65 ^ 0x60) << 24;
  LOBYTE(v65) = v55 >> 28;
  v66 = v64 | (*(unsigned __int8 *)(v62 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C6) ^ 0xAFLL)) << 24);
  v67 = *(unsigned __int8 *)(v56 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C3) ^ 0x98));
  HIDWORD(v55) = v67 ^ 5;
  LODWORD(v55) = (v67 ^ 0x60) << 24;
  v68 = v66 & 0xFFFFFF00 | (v55 >> 28);
  v69 = v59 | ((*(unsigned __int8 *)(v60 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C8) ^ 0x49)) ^ 0x6A) << 8) | ((*(unsigned __int8 *)(v62 + (*v48 ^ 0xFELL)) ^ 0xD9) << 24);
  v70 = *(unsigned __int8 *)(v56 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C7) ^ 0xD0));
  HIDWORD(v55) = v70 ^ 5;
  LODWORD(v55) = (v70 ^ 0x60) << 24;
  v71 = *(unsigned __int8 *)(v53 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18BDLL) ^ 0xB6));
  LOBYTE(v70) = (v55 >> 28) ^ 0x3C;
  HIDWORD(v55) = v71 ^ 0xC;
  LODWORD(v55) = (v71 ^ 0x40) << 24;
  v72 = v69 & 0xFFFFFF00 | v70;
  v73 = (v55 >> 30) ^ 0x21;
  v74 = ((*(unsigned __int8 *)(v60 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18BCLL) ^ 0xC7)) ^ 0x21) << 8) & 0xFFFFFFFF00FFFFFFLL | ((unint64_t)(v63 ^ 0xD0u) << 24) | (v73 << 16) | v65 ^ 0x68;
  LODWORD(v53) = *(unsigned __int8 *)(v53 + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C1) ^ 0xC8));
  HIDWORD(v55) = v53 ^ 0xC;
  LODWORD(v55) = (v53 ^ 0x40) << 24;
  v251 = v74 ^ 0x75F49EF4;
  v75 = v61 & 0xFF00FFFF | (((v55 >> 30) ^ 0x37) << 16) | ((*(unsigned __int8 *)(v62
                                                                                                + (*(unsigned __int8 *)(v47 - 0x697D3DFF8FBD18C2) ^ 0x18)) ^ 0xFFFFFF9F) << 24);
  v76 = *(_QWORD *)(v50 + 8 * (v46 - 853)) - 12;
  LODWORD(v62) = (((unsigned __int16)(v74 ^ 0x9EF4) >> 8)
                - ((2 * ((v74 ^ 0x75F49EF4) >> 8)) & 0x1FC)
                + 176939518) ^ *(_DWORD *)(v76 + 4 * (((unsigned __int16)(v74 ^ 0x9EF4) >> 8) ^ 0xF5));
  LODWORD(v60) = v62 - ((2 * v62) & 0xB00627E0);
  v77 = *(_QWORD *)(v50 + 8 * (v46 - 902)) - 8;
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (v63 ^ 0xCFu));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  v78 = *(_QWORD *)(v50 + 8 * (v46 - 911));
  LODWORD(v73) = (v55 >> 2) ^ *(_DWORD *)(v78 + 4 * (v73 ^ 0xDD)) ^ (v60 + 1476596720);
  v79 = *(_QWORD *)(v50 + 8 * (v46 ^ 0x3FEu)) - 8;
  v252 = v72;
  v80 = *(_DWORD *)(v79 + 4 * (v65 ^ 0xD9u)) ^ v72 ^ (v73 - ((2 * v73) & 0xEDF410FC) - 151385986);
  v250 = v75;
  v248 = v68 ^ 0x2789BBD4 ^ v80;
  LODWORD(v73) = v248 ^ v75 ^ v74;
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (BYTE3(v73) ^ 0x54));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  LODWORD(v74) = ((v55 >> 2) - ((2 * (v55 >> 2)) & 0xEDF410FC) - 151385986) ^ *(_DWORD *)(v79
                                                                                        + 4
                                                                                        * ((v248 ^ v75 ^ v74) ^ 0xCCu));
  v81 = v73 ^ 0x7B28F9D9;
  LODWORD(v73) = *(_DWORD *)(v76 + 4 * (BYTE1(v73) ^ 0x80u)) ^ *(_DWORD *)(v78 + 4 * (BYTE2(v73) ^ 0x7Bu)) ^ ((BYTE1(v73) ^ 0x75) - ((2 * ((v73 >> 8) ^ 0x3E5275)) & 0x1FC) + 176939518) ^ (v74 - ((2 * v74) & 0xB00627E0) + 1476596720);
  v82 = v68;
  v83 = v73 ^ v68 ^ 0xD7E75F8C;
  v246 = v248 ^ v75 ^ 0xE6;
  v247 = v81;
  v84 = v73 ^ v68 ^ v246;
  v85 = v84 ^ v81;
  v86 = v84 ^ v81 ^ 0x71FC2683;
  LODWORD(v74) = v85 ^ 0xB07EBFEF;
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (HIBYTE(v85) ^ 0xDA));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  v87 = *(_DWORD *)(v76 + 4 * (BYTE1(v74) ^ 0xF5u)) ^ *(_DWORD *)(v78 + 4 * (BYTE2(v86) ^ 0xABu)) ^ (BYTE1(v74) - ((v74 >> 7) & 0x1FC) + 176939518) ^ ((v55 >> 2) - ((2 * (v55 >> 2)) & 0xB00627E0) + 1476596720);
  v249 = v80;
  v242 = v73 ^ v80;
  v243 = v86;
  v88 = v73 ^ v80 ^ *(_DWORD *)(v79 + 4 * (v86 ^ 0x29u)) ^ (v87 - ((2 * v87) & 0xEDF410FC) - 151385986);
  v244 = v84;
  v245 = v83;
  HIDWORD(v240) = ((v88 ^ 0x516EF336) - ((2 * (v88 ^ 0x516EF336)) & 0x42002EDC) - 1593829522) ^ v83;
  v89 = HIDWORD(v240) ^ 0x8EDEEA78 ^ v84;
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (((v89 ^ v74) >> 24) ^ 0x11));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  LODWORD(v73) = (v55 >> 2) ^ *(_DWORD *)(v76 + 4 * (((unsigned __int16)(v89 ^ v74) >> 8) ^ 0xDFu)) ^ ((((unsigned __int16)(v89 ^ v74) >> 8) ^ 0x2A) - ((2 * (((v89 ^ v74) >> 8) ^ 0x7B6C2A)) & 0x1FC) + 176939518);
  LODWORD(v73) = (v73 - ((2 * v73) & 0xEDF410FC) - 151385986) ^ *(_DWORD *)(v79
                                                                          + 4 * ((v89 ^ v74) ^ 3u));
  v241 = v88;
  LODWORD(v73) = v88 ^ *(_DWORD *)(v78 + 4 * (((v89 ^ v74) >> 16) ^ 0x45u)) ^ (v73 - ((2 * v73) & 0xB00627E0) + 1476596720);
  LODWORD(v239) = v73 ^ 0x6934DABC;
  HIDWORD(v239) = v89 ^ v74;
  LODWORD(v240) = v89;
  v90 = v73 ^ 0x6934DABC ^ ((HIDWORD(v240) ^ 0x8EDEEA78) - ((2 * (HIDWORD(v240) ^ 0x8EDEEA78)) & 0x70B45314) + 945432970) ^ 0x307C325C;
  LODWORD(v238) = v90 ^ v89 ^ 0x2816F2D5;
  HIDWORD(v238) = v73 ^ 0x6934DABC ^ ((HIDWORD(v240) ^ 0x8EDEEA78)
                                    - ((2 * (HIDWORD(v240) ^ 0x8EDEEA78)) & 0x70B45314)
                                    + 945432970);
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (((v238 ^ v89 ^ v74) >> 24) ^ 0xD2));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  v91 = ((v55 >> 2) - ((2 * (v55 >> 2)) & 0xEDF410FC) - 151385986) ^ *(_DWORD *)(v79
                                                                               + 4
                                                                               * ((v238 ^ v89 ^ v74) ^ 0xFAu));
  HIDWORD(v237) = v238 ^ v89 ^ v74;
  LODWORD(v73) = *(_DWORD *)(v76 + 4 * (((unsigned __int16)(WORD2(v237) ^ 0x33BF) >> 8) ^ 0xF5u)) ^ *(_DWORD *)(v78 + 4 * (BYTE6(v237) ^ 0x2Du)) ^ v73 ^ (((unsigned __int16)(WORD2(v237) ^ 0x33BF) >> 8) - (((HIDWORD(v237) ^ 0xB80433BF) >> 7) & 0x1FC) + 176939518) ^ (v91 - ((2 * v91) & 0xB00627E0) + 1476596720);
  v92 = v73 ^ v89 ^ 0x2816F2D5;
  v93 = v92 ^ HIDWORD(v237) ^ 0xB80433BF;
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (HIBYTE(v93) ^ 0x21));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  v94 = ((v55 >> 2) - ((2 * (v55 >> 2)) & 0xB00627E0) + 1476596720) ^ *(_DWORD *)(v78 + 4 * (BYTE2(v93) ^ 0xCEu));
  v95 = (v94 - ((2 * v94) & 0xEDF410FC) - 151385986) ^ *(_DWORD *)(v79
                                                                 + 4
                                                                 * ((v92 ^ BYTE4(v237) ^ 0xBF) ^ 0xA7u));
  v96 = ((unsigned __int16)(v93 ^ 0x48E2) >> 8);
  v97 = (v95 - ((2 * v95) & 0x1517C3FC) + 176939518) ^ *(_DWORD *)(v76 + 4 * (v96 ^ 0xF5u));
  v98 = v73 ^ 0xE8B0D562 ^ v96 ^ (v97 - ((2 * v97) & 0x73BC4CA8) - 1176623532);
  LODWORD(v237) = v73 ^ 0xE8B0D562;
  v99 = v73 ^ 0xE8B0D562 ^ (v90 - ((2 * v90) & 0x73BC4CA8) - 1176623532);
  HIDWORD(v235) = v99;
  v236 = __PAIR64__(v92, v93);
  LODWORD(v235) = v98 ^ 0x519C7071;
  v100 = v98 ^ 0x519C7071 ^ (v99 - ((2 * v99) & 0xA338E0E2) + 1369206897);
  v101 = v100 ^ 0xE6F58988 ^ v92;
  v102 = v101 ^ v93 ^ 0x4BE748E2;
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (HIBYTE(v102) ^ 0x12));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  LODWORD(v73) = *(_DWORD *)(v76 + 4 * (((unsigned __int16)(v102 ^ 0x8988) >> 8) ^ 0xF5u)) ^ *(_DWORD *)(v78 + 4 * (BYTE2(v102) ^ 0xDCu)) ^ (((unsigned __int16)(v102 ^ 0x8988) >> 8) - (((v102 ^ 0x78F58988) >> 7) & 0x1FC) + 176939518) ^ ((v55 >> 2) - ((2 * (v55 >> 2)) & 0xB00627E0) + 1476596720);
  v103 = *(_DWORD *)(v79 + 4 * ((v101 ^ v93 ^ 0xE2) ^ 0xCDu)) ^ v98 ^ 0xC1A61C2C ^ (v73 - ((2 * v73) & 0xEDF410FC) - 151385986);
  LODWORD(v234) = v101 ^ 0x56645FA8;
  HIDWORD(v234) = v100;
  HIDWORD(v232) = v103 ^ ((v100 ^ 0xE6F58988) - 2 * ((v100 ^ 0xE6F58988) & 0x41A61C3F ^ v100 & 0x13) - 1046078420);
  v104 = ((HIDWORD(v232) ^ 0x5BF36347) - ((2 * (HIDWORD(v232) ^ 0x5BF36347)) & 0xE15593C) + 118140062) ^ v101 ^ 0x56645FA8;
  v105 = v104 ^ v102 ^ 0x78F58988;
  LODWORD(v73) = ((BYTE1(v105) ^ 0xBB) - ((2 * ((v105 >> 8) ^ 0x1A89BB)) & 0x1FC) + 176939518) ^ *(_DWORD *)(v76 + 4 * (BYTE1(v105) ^ 0x4Eu));
  LODWORD(v73) = (v73 - ((2 * v73) & 0xEDF410FC) - 151385986) ^ *(_DWORD *)(v79
                                                                          + 4
                                                                          * ((((BYTE4(v232) ^ 0x47)
                                                                                              - ((2
                                                                                                * (BYTE4(v232) ^ 0x47)) & 0x3C)
                                                                                              - 98) ^ v101 ^ 0xA8 ^ v102 ^ 0x88) ^ 0x91u));
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (HIBYTE(v105) ^ 0x70));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  LODWORD(v73) = (v55 >> 2) ^ *(_DWORD *)(v78 + 4 * (BYTE2(v105) ^ 0xA0u)) ^ (v73
                                                                              - ((2 * v73) & 0xB00627E0)
                                                                              + 1476596720);
  v233 = __PAIR64__(v102, v103);
  LODWORD(v231) = (v73 - ((2 * v73) & 0x834C3858) - 1046078420) ^ v103;
  HIDWORD(v231) = v105;
  v106 = v231 ^ 0x930000ED ^ HIDWORD(v232) ^ 0x5BF36347;
  v107 = v106 ^ 0x8D06EA22;
  v108 = (v106 ^ 0x8D06EA22) & 0x6C03BFB;
  HIDWORD(v230) = v106;
  v109 = v106 & 8;
  LODWORD(v230) = v104 ^ 0x2185EB0C ^ (v107 - 2 * (v108 ^ v109) + 113261555);
  v110 = v230 ^ v105;
  v111 = ((unsigned __int16)(v110 ^ 0x1195) >> 8);
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (HIBYTE(v110) ^ 0x23));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  v112 = *(_DWORD *)(v76 + 4 * (v111 ^ 0xF5u)) ^ *(_DWORD *)(v79 + 4 * (v110 ^ 0xD0u)) ^ (v55 >> 2);
  HIDWORD(v229) = v110;
  v113 = ((v112 ^ 0xFC71E980) - 2 * ((v112 ^ 0xFC71E980) & 0x580313F5 ^ v112 & 5) + 1476596720) ^ *(_DWORD *)(v78 + 4 * (BYTE2(v110) ^ 0x7Eu)) ^ v231 ^ 0x930000ED ^ v111;
  v114 = v107 - 2 * (v107 & 0x434AE0EF ^ v109);
  LODWORD(v232) = v104;
  LODWORD(v73) = v113 ^ v104 ^ v110 ^ 0x49571195;
  BYTE2(v109) = BYTE2(v73) ^ 0x45;
  LODWORD(v229) = v73 ^ 0xAA7E53B8;
  HIDWORD(v55) = *(_DWORD *)(v77 + 4 * (BYTE3(v73) ^ 0x63));
  LODWORD(v55) = HIDWORD(v55) ^ 0x15FA8F20;
  LODWORD(v73) = *(_DWORD *)(v76 + 4 * (BYTE1(v73) ^ 0x2Du)) ^ *(_DWORD *)(v79
                                                                           + 4
                                                                           * (~(_BYTE)v73 ^ 0xC4u)) ^ ((BYTE1(v73) ^ 0xD8) - ((2 * ((v73 >> 8) ^ 0x97AD8)) & 0x1FC) + 176939518) ^ ((v55 >> 2) - ((2 * (v55 >> 2)) & 0xEDF410FC) - 151385986);
  LODWORD(v73) = (v73 - ((2 * v73) & 0xB00627E0) + 1476596720) ^ *(_DWORD *)(v78 + 4 * (BYTE2(v109) ^ 0x16u));
  v115 = v73 - ((2 * v73) & 0x8695C1CE);
  LODWORD(v76) = v113 ^ v104 ^ 0x452FF2BF;
  v116 = *(_QWORD *)(v50 + 8 * (v46 & 0x2FBDB490)) - 8;
  v117 = *(unsigned __int8 *)(v116 + (*(unsigned __int8 *)(v51 - 109) ^ 0xA5));
  HIDWORD(v55) = v117 ^ 0x3B;
  LODWORD(v55) = v117 << 24;
  v227 = v116;
  v228 = *(_QWORD *)(v50 + 8 * (v46 ^ 0x30Fu)) - 12;
  v225 = *(_QWORD *)(v50 + 8 * (v46 & 0x3AD530B0));
  v226 = *(_QWORD *)(v50 + 8 * (v46 & 0x3E53F437));
  v118 = (((((v55 >> 30) ^ 0xDB) >> 2) | (((v55 >> 30) ^ 0xDB) << 6)) | ((*(unsigned __int8 *)(v226 + (*(unsigned __int8 *)(v51 - 111) ^ 0x7ALL)) ^ 0x49) << 16) | ((*(unsigned __int8 *)(v225 + (*(unsigned __int8 *)(v51 - 112) ^ 0x78)) ^ 0xC8) << 24) | (((*(_BYTE *)(v228 + (*(unsigned __int8 *)(v51 - 110) ^ 0x5DLL)) + (*(_BYTE *)(v51 - 110) ^ 0x52) - 94) ^ 0x5D) << 8)) ^ 0xBDBADDE8;
  LODWORD(v74) = ((*(unsigned __int8 *)(v116 + (*(unsigned __int8 *)(v51 - 101) ^ 0x60)) ^ 0xF0) & 0xFFFF00FF | ((*(unsigned __int8 *)(v226 + (*(unsigned __int8 *)(v51 - 103) ^ 5)) ^ 0x18) << 16) | (((*(_BYTE *)(v228 + (*(unsigned __int8 *)(v51 - 102) ^ 4)) + (*(_BYTE *)(v51 - 102) ^ 0xB) - 94) ^ 0x33) << 8) | ((*(unsigned __int8 *)(v225 + (*(unsigned __int8 *)(v51 - 104) ^ 0x1CLL)) ^ 0x3D) << 24)) ^ 0x63E9B244;
  v119 = ((*(unsigned __int8 *)(v116 + (*(unsigned __int8 *)(v51 - 105) ^ 0x28)) ^ 0x31) & 0xFFFF00FF | ((((*(_BYTE *)(v51 - 106) ^ 0xAC) + *(_BYTE *)(v228 + (*(unsigned __int8 *)(v51 - 106) ^ 0xA3)) - 94) ^ 0xF6) << 8) | ((*(unsigned __int8 *)(v225 + (*(unsigned __int8 *)(v51 - 108) ^ 0xB2)) ^ 0xCA) << 24) | ((*(unsigned __int8 *)(v226 + (*(unsigned __int8 *)(v51 - 107) ^ 0x27)) ^ 0x7C) << 16)) ^ 0x50A18A30;
  v120 = ((*(unsigned __int8 *)(v116 + (*(unsigned __int8 *)(v51 - 97) ^ 0x7BLL)) ^ 0x44) & 0xFFFF00FF | ((((*(_BYTE *)(v51 - 98) ^ 0xD0) + *(_BYTE *)(v228 + (*(unsigned __int8 *)(v51 - 98) ^ 0xDFLL)) - 94) ^ 0xE4) << 8) | ((*(unsigned __int8 *)(v226 + (*(unsigned __int8 *)(v51 - 99) ^ 0xAALL)) ^ 0x2A) << 16) | ((*(unsigned __int8 *)(v225 + (*(unsigned __int8 *)(v51 - 100) ^ 0x45)) ^ 0xF2) << 24)) ^ 0x7FCBA760;
  HIDWORD(v224) = v49 + 36812357;
  LODWORD(v223) = v52 + 95866379;
  HIDWORD(v222) = v52 ^ 0x789;
  LODWORD(v222) = v52 ^ 0x7A5;
  HIDWORD(v221) = v52 ^ 0x718;
  LODWORD(v221) = v113 ^ 0xC34AE0E7 ^ (v114 - 1018502937);
  HIDWORD(v220) = v52 ^ 0x7CB;
  LODWORD(v220) = v52 ^ 0x7F7;
  LODWORD(v224) = v113 ^ 0xC34AE0E7;
  HIDWORD(v219) = (v115 - 1018502937) ^ v113 ^ 0xC34AE0E7;
  LODWORD(v219) = v52 ^ 0x777;
  HIDWORD(v218) = (v46 - 1415924737) & 0x10410812;
  LODWORD(v218) = v52 ^ 0x7DC;
  *(_DWORD *)(v51 - 128) = v52;
  HIDWORD(v217) = v52 ^ 0x738;
  HIDWORD(a25) = v76;
  HIDWORD(v223) = (v114 - 1018502937) ^ 0x3DC8BA5D ^ (v115 - 1018502937);
  LODWORD(v217) = HIDWORD(v223) ^ v76;
  *(_QWORD *)(v51 - 208) = 7;
  v121 = *(unsigned __int8 **)(v51 - 120);
  v122 = v121[7];
  v123 = (((v52 + 95866379) & 0xFA492FFF) - 1005865502) ^ 0xC40BBB73;
  *(_QWORD *)(v51 - 176) = v123;
  v124 = *(unsigned __int8 *)(v116 + (v122 ^ 0x41));
  v125 = v121[v123] ^ 0x60;
  *(_QWORD *)(v51 - 160) = 8;
  *(_QWORD *)(v51 - 136) = 1;
  LODWORD(v116) = *(unsigned __int8 *)(v225 + v125) ^ 0x49;
  LODWORD(v76) = *(unsigned __int8 *)(v225 + (v121[8] ^ 0xC1)) ^ 0xFFFFFFFD;
  LODWORD(v125) = *(unsigned __int8 *)(v226 + (v121[1] ^ 0x66)) ^ 0xA5;
  *(_QWORD *)(v51 - 144) = 15;
  LODWORD(v77) = (_DWORD)v125 << 16;
  v126 = v121[15] ^ 0xE9;
  *(_QWORD *)(v51 - 168) = 11;
  LODWORD(v126) = *(unsigned __int8 *)(v227 + v126) ^ 0xE6;
  LODWORD(v60) = *(unsigned __int8 *)(v227 + (v121[11] ^ 0xC3));
  *(_QWORD *)(v51 - 184) = 0;
  LODWORD(v77) = v77 | ((*(unsigned __int8 *)(v225 + (*v121 ^ 0x30)) ^ 0x79) << 24);
  LODWORD(v76) = v60 ^ 0x2C | ((_DWORD)v76 << 24);
  *(_QWORD *)(v51 - 152) = 2;
  LODWORD(v77) = v77 & 0xFFFF00FF | (((*(_BYTE *)(v228 + (v121[2] ^ 0xC0)) + (v121[2] ^ 0xCF) - 94) ^ 0xF9) << 8);
  *(_QWORD *)(v51 - 224) = 4;
  LODWORD(v60) = *(unsigned __int8 *)(v225 + (v121[4] ^ 0xFCLL)) ^ 0xFFFFFFC7;
  *(_QWORD *)(v51 - 216) = 5;
  v127 = v124 ^ 0x36 | ((_DWORD)v60 << 24);
  LODWORD(v60) = *(unsigned __int8 *)(v226 + (v121[5] ^ 0xA9)) ^ 0x98;
  *(_QWORD *)(v51 - 240) = 9;
  v128 = v127 | ((_DWORD)v60 << 16);
  LODWORD(v76) = v76 | ((*(unsigned __int8 *)(v226 + (v121[9] ^ 0x5DLL)) ^ 0x76) << 16);
  *(_QWORD *)(v51 - 200) = 10;
  LOBYTE(v60) = (*(_BYTE *)(v228 + (v121[10] ^ 0xD5)) + (v121[10] ^ 0xDA) - 94) ^ 0xCF;
  *(_QWORD *)(v51 - 192) = 14;
  LODWORD(v76) = v76 & 0xFFFF00FF | (v60 << 8);
  LODWORD(v60) = (*(_BYTE *)(v228 + (v121[14] ^ 0xE4)) + (v121[14] ^ 0xEB) + 34);
  *(_QWORD *)(v51 - 232) = 3;
  v129 = *(unsigned __int8 *)(v227 + (v121[3] ^ 0xDCLL)) ^ 0xF2;
  *(_QWORD *)(v51 - 248) = 13;
  LODWORD(v73) = ((_DWORD)v60 << 8) | ((*(unsigned __int8 *)(v226 + (v121[13] ^ 0x92)) ^ 0x4B) << 16) | v126 | ((_DWORD)v116 << 24);
  *(_QWORD *)(v51 - 256) = 6;
  v130 = v128 & 0xFFFF00FF | (((*(_BYTE *)(v228 + (v121[6] ^ 0x4FLL)) + (v121[6] ^ 0x40) - 94) ^ 0xB7) << 8);
  v131 = v118 ^ v252 ^ ((v129 | v77) + 67331281 - 2 * ((v129 | v77) & 0x40364D3 ^ v129 & 2));
  v132 = v119 ^ v82 ^ (v130 - ((2 * v130) & 0xD2306712) - 384289911);
  v133 = v120 ^ v251 ^ (v73 - 2 * (v73 & 0x46721EDF ^ v126 & 6) - 965599527);
  LODWORD(v126) = v74 ^ v250 ^ (v76 - ((2 * v76) & 0xB4A017FA) - 632288259);
  v134 = *(_QWORD *)(v50 + 8 * (*(_DWORD *)(v51 - 128) - 1783)) - 8;
  v135 = *(_QWORD *)(v50 + 8 * v222) - 12;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v126) ^ 0x3F));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v116) = (v55 >> 1) ^ ((BYTE2(v133) ^ 0x68)
                              - 949305767
                              - 2 * ((HIWORD(v133) ^ 0xB768) & 0x5D ^ HIWORD(v133) & 4)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v133) ^ 0x34u));
  v136 = *(_QWORD *)(v50 + 8 * HIDWORD(v222)) - 8;
  LODWORD(v60) = *(_DWORD *)(v136 + 4 * (v126 ^ 0xC6u)) ^ ((BYTE2(v131) ^ 0xD5)
                                                                            - 949305767
                                                                            - ((2 * (HIWORD(v131) ^ 0x6CD5)) & 0xB2)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v131) ^ 0x89u)) ^ ((v126 ^ 0xAB) - 95202670 + ((2 * (v126 ^ 0xAB) + 62) & 0x24 ^ 0xFDD6FFFF));
  LODWORD(v73) = *(_DWORD *)(v134 + 4 * (BYTE2(v132) ^ 0x8Cu)) ^ *(_DWORD *)(v136
                                                                             + 4 * (v133 ^ 0xB6u)) ^ ((v133 ^ 0xDB) - 95202670 + ((2 * (v133 ^ 0xDB) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ ((BYTE2(v132) ^ 0xD0) - 949305767 - 2 * ((HIWORD(v132) ^ 0xC8D0) & 0x5D ^ HIWORD(v132) & 4));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v132) ^ 0xC8));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v116) = v116 - 1430543584 - ((2 * v116) & 0x55774640);
  LODWORD(v74) = ((BYTE2(v126) ^ 0xAD) - 949305767 - 2 * ((WORD1(v126) ^ 0x3FAD) & 0x5B ^ WORD1(v126) & 2)) ^ *(_DWORD *)(v136 + 4 * (v131 ^ 0x1Cu)) ^ ((v131 ^ 0x71) - 95202670 + ((2 * (v131 ^ 0x71) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ (v55 >> 1) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v126) ^ 0xF1u));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v131) ^ 0x6C));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v76) = v55 >> 1;
  v137 = v74 - 1430543584 - ((2 * v74) & 0x55774640);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v133) ^ 0xB7));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v138 = *(_QWORD *)(v50 + 8 * HIDWORD(v221)) - 8;
  v139 = *(_DWORD *)(v138 + 4 * (BYTE1(v131) ^ 0xDEu)) ^ v246 ^ ((v132 ^ 0x10)
                                                                 - 95202670
                                                                 + ((2 * (v132 ^ 0x10) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136 + 4 * (v132 ^ 0x7Du));
  v140 = (v60 - 1430543584 - ((2 * v60) & 0x55774640)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v132) ^ 0x2Fu)) ^ (v55 >> 1);
  LODWORD(v77) = v140 - ((2 * v140) & 0x8AF518A0);
  LOWORD(v132) = v139 ^ v116;
  LODWORD(v126) = *(_DWORD *)(v138 + 4 * (BYTE1(v126) ^ 0x29u)) ^ v249 ^ v76 ^ (v73
                                                                                - 1430543584
                                                                                - ((2 * v73) & 0x55774640));
  v141 = *(_DWORD *)(v138 + 4 * (BYTE1(v133) ^ 0x66u)) ^ v248 ^ v137;
  LODWORD(v73) = (v139 ^ v116) >> 16;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * ((v139 ^ ~(_DWORD)v116) >> 24));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v60) = v55 >> 1;
  LODWORD(v76) = (*(_BYTE *)(v138 + 4 * (BYTE1(v133) ^ 0x66u)) ^ v248 ^ v137);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v126) ^ 0x91));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v142 = v55 >> 1;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v141) ^ 0xA3));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v143 = v142 ^ *(_DWORD *)(v134 + 4 * (BYTE2(v141) ^ 0xF0u)) ^ ((BYTE2(v141) ^ 0xAC)
                                                                 - 949305767
                                                                 - 2
                                                                 * ((HIWORD(v141) ^ 0xA3AC) & 0x5B ^ HIWORD(v141) & 2));
  LODWORD(v73) = (v55 >> 1) ^ *(_DWORD *)(v134 + 4 * (v73 ^ 0x15u)) ^ *(_DWORD *)(v136 + 4 * (v126 ^ 0x7Bu)) ^ ((v73 ^ 0x49) - 949305767 - 2 * ((v73 ^ 0xFF49) & 0x5D ^ v73 & 4)) ^ ((v126 ^ 0x16) - 95202670 + ((2 * (v126 ^ 0x16) + 62) & 0x24 ^ 0xFDD6FFFF));
  LODWORD(v116) = (v77 + 1165659216) ^ v247;
  LODWORD(v73) = (v73 - 1430543584 - ((2 * v73) & 0x55774640)) ^ *(_DWORD *)(v138
                                                                           + 4
                                                                           * (((unsigned __int16)((v77 - 29616) ^ v247) >> 8) ^ 0x70u));
  v144 = (v143 - 1430543584 - ((2 * v143) & 0x55774640)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v132) ^ 0x2Cu));
  LODWORD(v76) = v60 ^ *(_DWORD *)(v136 + 4 * (v76 ^ 3)) ^ ((v76 ^ 0x6E)
                                                                          - 95202670
                                                                          + ((2 * (v76 ^ 0x6E) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ ((BYTE2(v116) ^ 0x9F) - 949305767 - ((2 * (WORD1(v116) ^ 0x259F)) & 0xB2)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v116) ^ 0xC3u));
  LODWORD(v77) = *(_DWORD *)(v134 + 4 * (BYTE2(v126) ^ 0x2Eu)) ^ ((BYTE2(v126) ^ 0x72)
                                                                  - 949305767
                                                                  - ((2 * (WORD1(v126) ^ 0x9172)) & 0xB2));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v116) ^ 0x25));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v77) = ((v132 ^ 0xFC)
                - 95202670
                + ((2 * (v132 ^ 0xFC) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v138
                                                                                               + 4
                                                                                               * (BYTE1(v141) ^ 0xBDu)) ^ *(_DWORD *)(v136 + 4 * (v132 ^ 0x91u)) ^ (v77 - 1430543584 - ((2 * v77) & 0x55774640)) ^ (v55 >> 1);
  v145 = ((v116 ^ 0xD6) - 1726037377) ^ v242 ^ *(_DWORD *)(v136 + 4 * (v116 ^ 0xBBu)) ^ (v144 + 1630834706 - ((2 * v144) & 0xC2692024));
  v146 = *(_DWORD *)(v138 + 4 * (BYTE1(v126) ^ 0x57u)) ^ v244 ^ (v76 - 1430543584 - ((2 * v76) & 0x55774640));
  LODWORD(v126) = (v77 - ((2 * v77) & 0x84C3C462) + 1113711153) ^ v243;
  LODWORD(v77) = (v73 - 1593829522 - ((2 * v73) & 0x42002EDC)) ^ v245;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v126) ^ 0xA6));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v116) = ((v77 ^ 0xA1)
                 - 95202670
                 + ((2 * (v77 ^ 0xA1) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136
                                                                                               + 4
                                                                                               * (v77 ^ 0xCCu));
  LODWORD(v73) = *(_DWORD *)(v134 + 4 * (BYTE2(v145) ^ 0xDBu)) ^ ((BYTE2(v145) ^ 0x87)
                                                                  - 949305767
                                                                  - ((2 * (HIWORD(v145) ^ 0x3A87)) & 0xB2)) ^ (v55 >> 1);
  LODWORD(v76) = (v116 - 1430543584 - ((2 * v116) & 0x55774640)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v145) ^ 0xDEu));
  LODWORD(v116) = ((v145 ^ 0x9E)
                 - 95202670
                 + ((2 * (v145 ^ 0x9E) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136
                                                                                                + 4
                                                                                                * (v145 ^ 0xF3u));
  LODWORD(v73) = (v73 - 1430543584 - ((2 * v73) & 0x55774640)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v77) ^ 0x57u));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v146) ^ 0x41));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v147 = *(_DWORD *)(v134 + 4 * (BYTE2(v126) ^ 0x20u)) ^ BYTE2(v126) ^ (v55 >> 1);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v145) ^ 0x3A));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v76) = v147 ^ (v76 - 949305767 - ((2 * v76) & 0x8ED57CB2));
  v148 = *(_DWORD *)(v138 + 4 * (BYTE1(v146) ^ 0xF4u)) ^ BYTE2(v77) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v77) ^ 0xF6u)) ^ 0x6DD11DD3 ^ (v55 >> 1);
  v149 = ((v126 ^ 0x8B) - 1726037377) ^ v241 ^ *(_DWORD *)(v136 + 4 * (v126 ^ 0xE6u)) ^ (v148 + 1630834706 - ((2 * v148) & 0xC2692024));
  v150 = *(_DWORD *)(v138 + 4 * (BYTE1(v126) ^ 0xBu));
  LODWORD(v126) = *(_DWORD *)(v136 + 4 * (v146 ^ 0xB5u)) ^ ((v146 ^ 0xD8)
                                                                             - 1726037377) ^ (v73
                                                                                            + 1630834706
                                                                                            - ((2 * v73) & 0xC2692024));
  LODWORD(v126) = (v126 - ((2 * v126) & 0x6E2E9A2E) + 924273943) ^ HIDWORD(v239);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v77) ^ 0x7C));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v151 = ((v76 ^ 0x7C) - ((2 * (v76 ^ 0x7C)) & 0x841FA638) - 1039150308) ^ v240;
  v152 = v150 ^ HIDWORD(v240) ^ ((BYTE2(v146) ^ 0xEB) - 949305767 - ((2 * (HIWORD(v146) ^ 0x2EB)) & 0xB2)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v146) ^ 0xB7u)) ^ (v116 - 1430543584 - ((2 * v116) & 0x55774640)) ^ (v55 >> 1);
  LODWORD(v76) = (((v76 ^ 0x7C) - ((2 * (v76 ^ 0x7C)) & 0x38) + 28) ^ v240);
  LODWORD(v76) = ((v76 ^ 0x3D) - 95202670 + ((2 * (v76 ^ 0x3D) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136 + 4 * (v76 ^ 0x50));
  LODWORD(v77) = v76 - 1430543584 - ((2 * v76) & 0x55774640);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v149) ^ 0x2D));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v73) = (v55 >> 1) ^ *(_DWORD *)(v136 + 4 * (v126 ^ 0xEAu));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v126) ^ 0x69));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v153 = v55 >> 1;
  LODWORD(v73) = v73 ^ ((v126 ^ 0x87)
                      - 95202670
                      + ((2 * (v126 ^ 0x87) + 62) & 0x24 ^ 0xFDD6FFFF));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v151) ^ 0xD));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v76) = v55 >> 1;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v152) ^ 0xB4));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v76) = v76 ^ *(_DWORD *)(v136 + 4 * (v152 ^ 0x8Bu)) ^ ((v152 ^ 0xE6)
                                                                                  - 95202670
                                                                                  + ((2 * (v152 ^ 0xE6)
                                                                                    + 62) & 0x24 ^ 0xFDD6FFFF));
  LODWORD(v73) = *(_DWORD *)(v134 + 4 * (BYTE2(v152) ^ 5u)) ^ ((BYTE2(v152) ^ 0x59)
                                                               - 949305767
                                                               - 2 * ((HIWORD(v152) ^ 0xB459) & 0x5D ^ HIWORD(v152) & 4)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v151) ^ 0x3Eu)) ^ (v73 - 1430543584 - ((2 * v73) & 0x55774640));
  LODWORD(v60) = BYTE2(v149) ^ 0x72;
  LODWORD(v116) = v60 - 949305767 - ((2 * (HIWORD(v149) ^ 0x2D72)) & 0xB2);
  v154 = v149;
  v155 = (v149 ^ 0x16) - 95202670 + ((2 * (v149 ^ 0x16) + 62) & 0x24 ^ 0xFDD6FFFF);
  v156 = *(_DWORD *)(v138 + 4 * (BYTE1(v149) ^ 0x57u)) ^ v238 ^ ((BYTE2(v126) ^ 0xE4)
                                                                 - 949305767
                                                                 - 2 * ((WORD1(v126) ^ 0x69E4) & 0x5B ^ WORD1(v126) & 2)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v126) ^ 0xB8u)) ^ (v76 - 1430543584 - ((2 * v76) & 0x55774640));
  v157 = *(_DWORD *)(v138 + 4 * (BYTE1(v152) ^ 0x34u));
  LODWORD(v126) = *(_DWORD *)(v138 + 4 * (BYTE1(v126) ^ 0x17u)) ^ HIDWORD(v238) ^ *(_DWORD *)(v136
                                                                                              + 4 * (v154 ^ 0x7Bu)) ^ v155 ^ ((v55 >> 1) - 1430543584 - ((2 * (v55 >> 1)) & 0x55774640)) ^ ((BYTE2(v151) ^ 0x8C) - 949305767 - ((2 * (HIWORD(v151) ^ 0x4E8C)) & 0xB2));
  v158 = *(_DWORD *)(v134 + 4 * (BYTE2(v151) ^ 0xD0u));
  v159 = (v73 + 945432970 - ((2 * v73) & 0x70B45314)) ^ v239;
  v160 = v126 ^ v158;
  LODWORD(v126) = v157 ^ HIDWORD(v237) ^ v116 ^ *(_DWORD *)(v134 + 4 * (v60 ^ 0x5C)) ^ v77 ^ v153;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v126) ^ 0x9D));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v161 = (v55 >> 1) - 1430543584 - ((2 * (v55 >> 1)) & 0x55774640);
  LODWORD(v73) = ((BYTE2(v160) ^ 0x81) - 949305767 - 2 * ((HIWORD(v160) ^ 0x1481) & 0x79 ^ HIWORD(v160) & 0x20)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v160) ^ 0xDDu));
  v162 = ((v160 ^ 0x51) - 95202670 + ((2 * (v160 ^ 0x51) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136 + 4 * (v160 ^ 0x3Cu));
  LODWORD(v116) = *(_DWORD *)(v134 + 4 * (BYTE2(v156) ^ 0xDBu)) ^ ((BYTE2(v156) ^ 0x87)
                                                                   - 949305767
                                                                   - ((2 * (HIWORD(v156) ^ 0x7787)) & 0xB2));
  LODWORD(v53) = ((v126 ^ 0xDE9BA169) >> 16) ^ *(_DWORD *)(v134
                                                                                        + 4
                                                                                        * (((v126 ^ 0xDE9BA169) >> 16) ^ 0x5Cu)) ^ (v162 - 949305767 - ((2 * v162) & 0x8ED57CB2));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v160) ^ 0x14));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v163 = v55 >> 1;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v159) ^ 0x9A));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v73) = *(_DWORD *)(v136 + 4 * (v126 ^ 4u)) ^ ((v126 ^ 0x69)
                                                                         - 95202670
                                                                         + ((2 * (v126 ^ 0xDE9BA169) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v156) ^ 0xDEu)) ^ (v73 - 1430543584 - ((2 * v73) & 0x55774640)) ^ (v55 >> 1);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v156) ^ 0x77));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v53) = (v55 >> 1) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v159) ^ 0x2Du)) ^ (v53
                                                                               - 1430543584
                                                                               - ((2 * v53) & 0x55774640));
  LODWORD(v77) = *(_DWORD *)(v138 + 4 * (BYTE1(v126) ^ 0x43u));
  LODWORD(v126) = *(_DWORD *)(v138 + 4 * (BYTE1(v160) ^ 0x34u)) ^ v236 ^ v161 ^ ((v156 ^ 0x9E)
                                                                                 - 95202670
                                                                                 + ((2 * (v156 ^ 0x9E)
                                                                                   + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v159) ^ 0xB5u)) ^ ((BYTE2(v159) ^ 0xE9) - 949305767 - 2 * ((HIWORD(v159) ^ 0x9AE9) & 0x5B ^ HIWORD(v159) & 2)) ^ *(_DWORD *)(v136 + 4 * (v156 ^ 0xF3u));
  v164 = v77 ^ HIDWORD(v235) ^ v163 ^ ((v159 ^ 0xA8)
                                     - 95202670
                                     + ((2 * (v159 ^ 0xA8) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136 + 4 * (v159 ^ 0xC5u)) ^ (v116 - 1430543584 - ((2 * v116) & 0x55774640));
  v165 = (v53 - ((2 * v53) & 0xA8DE103E) + 1416562719) ^ HIDWORD(v236);
  LODWORD(v77) = (v73 - 1176623532 - ((2 * v73) & 0x73BC4CA8)) ^ v237;
  LODWORD(v116) = *(_DWORD *)(v135 + 4 * (BYTE3(v77) ^ 0xFD));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v164) ^ 0x6D));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v73) = v55 >> 1;
  LODWORD(v53) = *(_DWORD *)(v134 + 4 * (BYTE2(v164) ^ 0x52u)) ^ ((_DWORD)v116 << 31) ^ (v116 >> 1) ^ ((BYTE2(v164) ^ 0xE) - 949305767 - ((2 * (HIWORD(v164) ^ 0x2E0E)) & 0xB2)) ^ 0x1CBC311A;
  LODWORD(v76) = ((v164 ^ 0x4A)
                - 95202670
                + ((2 * (v164 ^ 0x4A) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136
                                                                                               + 4
                                                                                               * (v164 ^ 0x27u));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v165) ^ 0xAB));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v76) = (v55 >> 1) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v77) ^ 0xA4u)) ^ (v76
                                                                              - 1430543584
                                                                              - ((2 * v76) & 0x55774640));
  LODWORD(v76) = BYTE2(v126) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v126) ^ 0x24u)) ^ (v76
                                                                                - 949305767
                                                                                - ((2 * v76) & 0x8ED57CB2));
  LODWORD(v73) = *(_DWORD *)(v134 + 4 * (BYTE2(v165) ^ 0x3Bu)) ^ v73 ^ ((v77 ^ 0x20)
                                                                        - 95202670
                                                                        + ((2 * v77 + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136 + 4 * (v77 ^ 0x4Du)) ^ ((BYTE2(v165) ^ 0x67) - 949305767 - ((2 * (HIWORD(v165) ^ 0xAB67)) & 0xB2));
  LODWORD(v116) = ((v126 ^ 0x34)
                 - 95202670
                 + ((2 * (v126 ^ 0x34) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v138
                                                                                                + 4
                                                                                                * (BYTE1(v165) ^ 0x87u));
  v165 = v165;
  LODWORD(v53) = v116 ^ *(_DWORD *)(v136 + 4 * (v126 ^ 0x59u)) ^ (v53
                                                                                   - 1430543584
                                                                                   - ((2 * v53) & 0x55774640));
  v166 = ((v165 ^ 0x9A) + 1138386336 + ((2 * (v165 ^ 0x9A) + 254) & 0x240 ^ 0xEFCAFBFF)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v164) ^ 0x65u));
  v167 = *(_DWORD *)(v138 + 4 * (BYTE1(v126) ^ 0x38u));
  v168 = (v166 + 1630834706 - ((2 * v166) & 0xC2692024)) ^ *(_DWORD *)(v136 + 4 * (v165 ^ 0xF7u));
  v169 = *(_DWORD *)(v134 + 4 * (BYTE2(v77) ^ 0x40u)) ^ ((BYTE2(v77) ^ 0x1C)
                                                         - 949305767
                                                         - 2 * ((WORD1(v77) ^ 0xFD1C) & 0x5B ^ WORD1(v77) & 2));
  LODWORD(v116) = v169 ^ 0xFF84C9E3 ^ (v168 - 1130766032 - ((2 * v168) & 0x7933C260));
  v168 ^= 0x6500C283u;
  LODWORD(v116) = (v168 + v116 + 1) ^ ((v169 ^ 0x261DEA50) + 1);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v126) ^ 0x6E));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v170 = ((v76 ^ 0x78) + 118140062 - ((2 * (v76 ^ 0x78)) & 0xE15593C)) ^ v234;
  LODWORD(v126) = ((v169 ^ 0x657BF49F ^ (v116 - 1130766032 - ((2 * v116) & 0x7933C260))) + v168) ^ (v55 >> 1);
  v171 = v167 ^ HIDWORD(v234) ^ (v73 - 1430543584 - ((2 * v73) & 0x55774640));
  v172 = (v53 + 1369206897 - ((2 * v53) & 0xA338E0E2)) ^ v235;
  LODWORD(v73) = ((BYTE2(v172) ^ 0xE9) - 949305767 - 2 * ((HIWORD(v172) ^ 0xB8E9) & 0x5F ^ HIWORD(v172) & 6)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v172) ^ 0xB5u));
  LODWORD(v77) = v73 - 1430543584 - ((2 * v73) & 0x55774640);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v170) ^ 0x9D));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v173 = v55 >> 1;
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v171) ^ 0x61));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v53) = *(_DWORD *)(v136 + 4 * (v172 ^ 0xC5u)) ^ (v55 >> 1) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v170) ^ 0x28u)) ^ ((v172 ^ 0xA8) - 95202670 + ((2 * (v172 ^ 0xA8) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ ((BYTE2(v170) ^ 0x74) - 949305767 - ((2 * (HIWORD(v170) ^ 0x9D74)) & 0xB2));
  LODWORD(v60) = (v126 - ((2 * v126) & 0x83B1FAC) - 2078437418) ^ v102;
  LODWORD(v126) = v173 ^ ((BYTE2(v60) ^ 0x95) - 949305767 + (~(2 * (WORD1(v60) ^ 0x6595)) | 0xFFFFFF4D) + 1) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v60) ^ 0xC9u));
  v174 = v126 - 1430543584 - ((2 * v126) & 0x55774640);
  LODWORD(v126) = v53 - 1430543584 - ((2 * v53) & 0x55774640);
  LODWORD(v53) = v171;
  v175 = (v171 ^ 0x85) - 95202670 + ((2 * (v171 ^ 0x85) + 62) & 0x24 ^ 0xFDD6FFFF);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v172) ^ 0xB8));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v73) = *(_DWORD *)(v136 + 4 * (v60 ^ 0xC9u)) ^ *(_DWORD *)(v134
                                                                                      + 4 * (BYTE2(v171) ^ 0x54u)) ^ ((BYTE2(v171) ^ 8) - 949305767 - 2 * ((HIWORD(v171) ^ 0x6108) & 0x5F ^ HIWORD(v171) & 6)) ^ (v55 >> 1) ^ ((v60 ^ 0xA4) - 95202670 + ((2 * (v60 ^ 0xA4) + 62) & 0x24 ^ 0xFDD6FFFF));
  LODWORD(v126) = *(_DWORD *)(v138 + 4 * (BYTE1(v60) ^ 0xA1u)) ^ HIDWORD(v232) ^ v126;
  LODWORD(v73) = (v73 - 1430543584 - ((2 * v73) & 0x55774640)) ^ *(_DWORD *)(v138
                                                                           + 4
                                                                           * (((unsigned __int16)(((v76 ^ 0x78) - 21346 - ((2 * (v76 ^ 0x78)) & 0x593C)) ^ v234) >> 8) ^ 0xBDu));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v60) ^ 0x65));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v176 = *(_DWORD *)(v136 + 4 * ((((v76 ^ 0x78) - 98 - ((2 * (v76 ^ 0x78)) & 0x3C)) ^ v234) ^ 0xB4u)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v171) ^ 0x8Fu)) ^ ((v170 ^ 0xD9) - 95202670 + ((2 * (v170 ^ 0xD9) + 62) & 0x24 ^ 0xFDD6FFFF));
  LODWORD(v76) = *(_DWORD *)(v138 + 4 * (BYTE1(v172) ^ 0x2Du));
  v177 = (v73 - 1046078420 - ((2 * v73) & 0x834C3858)) ^ v233;
  LODWORD(v77) = ((v176 ^ v77 ^ (v55 >> 1)) - ((2 * (v176 ^ v77 ^ (v55 >> 1))) & 0x862492D4) + 1125271914) ^ HIDWORD(v231);
  v178 = v76 ^ v232 ^ v175 ^ *(_DWORD *)(v136 + 4 * (v53 ^ 0xE8)) ^ v174;
  v179 = ((BYTE2(v178) ^ 0x66) - 949305767 - ((2 * (HIWORD(v178) ^ 0xAE66)) & 0xB2)) ^ *(_DWORD *)(v134
                                                                                                 + 4
                                                                                                 * (BYTE2(v178) ^ 0x3Au));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v77) ^ 0x7C));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v73) = ((v55 >> 1) - 949305767 - ((2 * (v55 >> 1)) & 0x8ED57CB2)) ^ *(_DWORD *)(v134
                                                                                        + 4 * (BYTE2(v177) ^ 0x40u));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v177) ^ 0xEF));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v180 = (v55 >> 1) ^ *(_DWORD *)(v136 + 4 * (v77 ^ 5u)) ^ ((v77 ^ 0x68)
                                                                             - 95202670
                                                                             + ((2 * (v77 ^ 0x68) + 62) & 0x24 ^ 0xFDD6FFFF));
  LODWORD(v60) = v179 - 1430543584 - ((2 * v179) & 0x55774640);
  v181 = v180 - 1430543584 - ((2 * v180) & 0x55774640);
  v182 = ((v126 ^ 0x4A) - 95202670 + ((2 * (v126 ^ 0x4A) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ *(_DWORD *)(v136 + 4 * (v126 ^ 0x27u));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v178) ^ 0xAE));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v183 = (v55 >> 1) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v77) ^ 0x58u)) ^ (v182 - 949305767 - ((2 * v182) & 0x8ED57CB2));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v126) ^ 0xDC));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v184 = ((BYTE2(v126) ^ 0xE) - 949305767 - ((2 * (WORD1(v126) ^ 0xDC0E)) & 0xB2)) ^ v231 ^ *(_DWORD *)(v134 + 4 * (BYTE2(v126) ^ 0x52u)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v178) ^ 0x7Cu)) ^ v181;
  LODWORD(v116) = (v76 ^ v232 ^ v175 ^ *(_BYTE *)(v136 + 4 * (v53 ^ 0xE8)) ^ v174);
  v185 = (v178 ^ 0xB3) - 95202670 + ((2 * (v178 ^ 0xB3) + 62) & 0x24 ^ 0xFDD6FFFF);
  v186 = *(_DWORD *)(v138 + 4 * (BYTE1(v77) ^ 0x82u)) ^ HIDWORD(v230) ^ *(_DWORD *)(v136
                                                                                    + 4
                                                                                    * (v177 ^ 0x4Du)) ^ (v55 >> 1) ^ ((v177 ^ 0x20) - 95202670 + ((2 * v177 + 62) & 0x24 ^ 0xFDD6FFFF)) ^ v60;
  LODWORD(v76) = WORD1(v77);
  LODWORD(v121) = (v73 - 1430543584 - ((2 * v73) & 0x55774640)) ^ v110 ^ *(_DWORD *)(v138 + 4 * (BYTE1(v126) ^ 0x65u)) ^ *(_DWORD *)(v136 + 4 * (v116 ^ 0xDE)) ^ v185;
  LODWORD(v77) = *(_DWORD *)(v138 + 4 * (BYTE1(v177) ^ 0xA4u)) ^ v230 ^ (v183 - 1430543584 - ((2 * v183) & 0x55774640));
  LODWORD(v116) = (*(_BYTE *)(v138 + 4 * (BYTE1(v177) ^ 0xA4u)) ^ v230 ^ (v183
                                                                                           + 32
                                                                                           - ((2 * v183) & 0x40)) ^ v76);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * ((v121 >> 24) ^ 0x6C));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v187 = v55 >> 1;
  LODWORD(v73) = (BYTE2(v186) ^ 0xFB) - 949305767 - ((2 * (HIWORD(v186) ^ 0x57FB)) & 0xB2);
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v184) ^ 0xF7));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v188 = v55 >> 1;
  LODWORD(v76) = (v184 ^ 0xA8)
               - 95202670
               + ((2 * (v184 ^ 0xA8) + 62) & 0x24 ^ 0xFDD6FFFF);
  v189 = ((BYTE2(v121) ^ 0xC8)
        - 949305767
        - 2 * (((v121 >> 16) ^ 0x6CC8) & 0x5F ^ (v121 >> 16) & 6)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v121) ^ 0x94u));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (BYTE3(v77) ^ 0xE7));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  v190 = v55 >> 1;
  v191 = v187 ^ *(_DWORD *)(v136 + 4 * (v116 ^ 0x4F)) ^ *(_DWORD *)(v134 + 4 * (BYTE2(v184) ^ 0xB5u)) ^ ((BYTE2(v184) ^ 0xE9) - 949305767 - 2 * ((HIWORD(v184) ^ 0xF7E9) & 0x5F ^ HIWORD(v184) & 6)) ^ ((v116 ^ 0x22) - 95202670 + ((2 * (v116 ^ 0x22) + 62) & 0x24 ^ 0xFDD6FFFF));
  v192 = (v191 - 1430543584 - ((2 * v191) & 0x55774640)) ^ *(_DWORD *)(v138 + 4 * (BYTE1(v186) ^ 0xECu));
  v193 = v188 ^ *(_DWORD *)(v134 + 4 * (BYTE2(v186) ^ 0xA7u)) ^ *(_DWORD *)(v136
                                                                            + 4
                                                                            * ((v121 ^ BYTE2(v177)) ^ 0x32u)) ^ (((v121 ^ BYTE2(v177)) ^ 0x5F) - 95202670 + ((2 * ((v121 ^ BYTE2(v177)) ^ 0x5F) + 62) & 0x24 ^ 0xFDD6FFFF));
  HIDWORD(v55) = *(_DWORD *)(v135 + 4 * (HIBYTE(v186) ^ 0x57));
  LODWORD(v55) = HIDWORD(v55) ^ 0x39786234;
  LODWORD(v73) = ((v193 ^ v73) - 1430543584 - ((2 * (v193 ^ v73)) & 0x55774640)) ^ *(_DWORD *)(v138
                                                                                             + 4
                                                                                             * (BYTE1(v77) ^ 0x6Du));
  v194 = ((BYTE2(v77) ^ 0x31) - 949305767 - 2 * ((WORD1(v77) ^ 0xE731) & 0x5B ^ WORD1(v77) & 2)) ^ *(_DWORD *)(v136 + 4 * (v184 ^ 0xC5u));
  v195 = *(_DWORD *)(v138 + 4 * (BYTE1(v184) ^ 0x2Du));
  v196 = v194 ^ v76 ^ *(_DWORD *)(v134 + 4 * (BYTE2(v77) ^ 0x6Du)) ^ (v55 >> 1);
  v197 = v221 ^ *(_DWORD *)(v138 + 4 * (BYTE1(v121) ^ 0x61u)) ^ (v196 - 1430543584 - ((2 * v196) & 0x55774640));
  LODWORD(v126) = v197 ^ 0xADE748E2;
  LODWORD(v138) = (v73 - 1018502937 - ((2 * v73) & 0x8695C1CE)) ^ v113 ^ 0xC34AE0E7;
  v198 = (v192 - 1559983162 - ((2 * v192) & 0x4609178C)) ^ v229;
  LODWORD(v136) = v195 ^ HIDWORD(a25) ^ v190 ^ *(_DWORD *)(v136 + 4 * (v186 ^ 0x42u)) ^ ((v186 ^ 0x2F) - 95202670 + ((2 * (v186 ^ 0x2F) + 62) & 0x24 ^ 0xFDD6FFFF)) ^ (v189 - 1430543584 - ((2 * v189) & 0x55774640));
  LODWORD(v73) = HIBYTE(v197) ^ 0x89;
  v199 = *(_DWORD *)(v51 - 128);
  v200 = (char *)*(&off_100180420 + v199 - 1874) - 12;
  v201 = (uint64_t)*(&off_100180420 + v199 - 1856);
  v202 = *(_DWORD *)(v201 + 4 * (BYTE3(v138) ^ 0xE7));
  LODWORD(v76) = *(_DWORD *)&v200[4 * (v138 ^ 0xA2)];
  v203 = (char *)*(&off_100180420 + v220) - 8;
  v204 = (*(_DWORD *)&v203[4 * (BYTE2(v138) ^ 0x9E)] - 1462736865) ^ (*(_DWORD *)&v200[4
                                                                                     * (v136 ^ 0xC9)]
                                                                    - 1948694933);
  v205 = *(_DWORD *)&v200[4 * (v126 ^ 0x2A)];
  LODWORD(v73) = (*(_DWORD *)&v203[4 * (BYTE2(v136) ^ 0x38)] - 1462736865) ^ (*(_DWORD *)(v201 + 4 * v73)
                                                                            - 991314136);
  LODWORD(v60) = *(_DWORD *)&v200[4 * (v198 ^ 0xB9)];
  LODWORD(v200) = *(_DWORD *)(v201 + 4 * (BYTE3(v136) ^ 0xB8));
  v206 = (char *)*(&off_100180420 + HIDWORD(v220)) - 12;
  LODWORD(v138) = *(_DWORD *)&v206[4 * (BYTE1(v138) ^ 0xA0)];
  LODWORD(v134) = *(_DWORD *)&v206[4 * (BYTE1(v136) ^ 0xE9)];
  v207 = *(_DWORD *)&v203[4 * (BYTE2(v126) ^ 0x6B)];
  LODWORD(v126) = (v204 + 201756776 - ((2 * v204) & 0x180D20D0)) ^ *(_DWORD *)&v206[4 * (BYTE1(v126) ^ 0x29)] ^ (*(_DWORD *)(v201 + 4 * (HIBYTE(v198) ^ 0x65)) - 991314136);
  LODWORD(v201) = *(_DWORD *)&v203[4 * (BYTE2(v198) ^ 0x1D)];
  v208 = *(_DWORD *)&v206[4 * (BYTE1(v198) ^ 0x74)] ^ HIDWORD(v223) ^ ((v73 ^ (v76 - 1948694933))
                                                                     + 201756776
                                                                     - ((2 * (v73 ^ (v76 - 1948694933))) & 0x180D20D0));
  v209 = *(_QWORD *)(v51 - 120);
  v210 = (char *)*(&off_100180420 + v219) - 12;
  LODWORD(v126) = v217 ^ v229 ^ (v126 - 1559983162 - ((2 * v126) & 0x4609178C));
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 256)) = v210[BYTE1(v208) ^ 0x99] ^ 0x6F;
  v211 = (char *)*(&off_100180420 + HIDWORD(v218)) - 4;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 248)) = (v211[BYTE2(v126) ^ 0xADLL] + 23) ^ 0xC5;
  LODWORD(v138) = v138 ^ v217 ^ (v205 - ((2 * v205 + 397577430) & 0x180D20D0) - 1746938157) ^ ((_DWORD)v200 - 991314136) ^ (v201 - 1462736865);
  v212 = (char *)*(&off_100180420 + v218) - 12;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 208)) = v212[v208 ^ 0xFCLL] ^ 0x39;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 240)) = (v211[BYTE2(v138) ^ 0x8CLL] + 23) ^ 0x47;
  v213 = (char *)*(&off_100180420 + HIDWORD(v217)) - 12;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 224)) = (v213[HIBYTE(v208) ^ 0xDELL] - 15) ^ 0x1B;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 216)) = ((v211[BYTE2(v208) ^ 0x15]
                                              + ((v211[BYTE2(v208) ^ 0x15] + 23) ^ 0xDA)
                                              + 24) ^ 0xFE)
                                            + v211[BYTE2(v208) ^ 0x15]
                                            + 23;
  v214 = HIDWORD(v219) ^ v134 ^ (v207 - 1462736865) ^ ((_DWORD)v60 - 1948694933) ^ (v202
                                                                                                - 2
                                                                                                * ((v202 + 82427688) & 0xC06906D ^ v202 & 5)
                                                                                                - 789557360);
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 232)) = v212[v214 ^ 5] ^ 0xCB;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 176)) = (v213[BYTE3(v126) ^ 0x4ELL] - 15) ^ 0xE6;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 160)) = (v213[BYTE3(v138) ^ 0x9CLL] - 15) ^ 0xB8;
  v215 = *(_QWORD *)(v51 - 184);
  *(_BYTE *)(v209 + v215) = (v213[BYTE3(v214) ^ 0x67] - 15) ^ 0x91;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 168)) = v212[v138 ^ 0xF2] ^ 0xC1;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 200)) = v210[BYTE1(v138) ^ 0x1ELL] ^ 0xCC;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 152)) = v210[BYTE1(v214) ^ 0x33] ^ 0xD5;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 192)) = v210[BYTE1(v126) ^ 0xBCLL] ^ 0x1B;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 144)) = v212[v126 ^ 0x9FLL] ^ 0x39;
  *(_BYTE *)(v209 + *(_QWORD *)(v51 - 136)) = (v211[BYTE2(v214) ^ 0xDLL] + 23) ^ 0x8E;
  return ((uint64_t (*)(uint64_t, uint64_t, char *, uint64_t, char *, uint64_t, char *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a46 + 8 * ((7 * ((((_DWORD)v215 - 1005864073 - ((2 * (_DWORD)v215 + 32) & 0x881776EE) + 16) ^ 0xC40BBB77) >= v49 + 36812357)) ^ (v199 - 592))) - 12))(57, 27, v203, 201756776, v210, v214, v212, 403513552, a9, a10, a11, a12, v217, v218, v219, v220, v221, v222, v223,
           v224,
           v225,
           v226,
           v227,
           v228,
           a25,
           v229,
           v230,
           v231,
           v232,
           v233,
           v234,
           v235,
           v236,
           v237,
           v238,
           v239,
           v240);
}

void sub_100047F0C()
{
  JUMPOUT(0x100045BE0);
}

uint64_t sub_100047F40(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((505 * (v3 != a3)) ^ v4)) - ((v4 - 80) | 0x185u) + 445))();
}

uint64_t sub_100047F70(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v8 + 8 * ((1020 * ((((a7 ^ 0x657) - 1930) & v7) == 0)) ^ a7))
                                          - ((a7 + 1555) ^ 0x7D4)))(a1);
}

uint64_t sub_100047FAC(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46)
{
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  char v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  int v57;
  char v58;
  char v59;
  char v60;
  char v61;
  char v62;
  unsigned int v63;
  int8x16x4_t v65;

  *(_DWORD *)(v54 - 128) = v53;
  *(_DWORD *)(v54 - 136) = v49;
  v55 = *(_QWORD *)(v54 - 120) - 7;
  *(_DWORD *)(v54 - 144) = v49 & 0xFFFFFFF8;
  v56 = a3 - (v49 & 0xFFFFFFF8) + 8;
  v57 = v52 + v51;
  v58 = v52 + v51 + v50;
  v59 = v58 - a3;
  v60 = v58 - a3 + 15;
  v61 = v58 - a3 + 1;
  v62 = v58 + a6 - a3 + 42;
  v63 = v57 + a1 - a3;
  v65.val[0].i64[0] = v63 & 0xF;
  v65.val[0].i64[1] = (v59 + 5) & 0xF;
  v65.val[1].i64[0] = (v59 + 4) & 0xF;
  v65.val[1].i64[1] = (v59 + 3) & 0xF;
  v65.val[2].i64[0] = v62 & 0xF;
  v65.val[2].i64[1] = v61 & 0xF;
  v65.val[3].i64[0] = v59 & 0xF;
  v65.val[3].i64[1] = v60 & 0xF;
  *(int8x8_t *)(v55 + v63) = veor_s8(veor_s8(veor_s8(*(int8x8_t *)(v47 + v65.val[0].i64[0] - 7), *(int8x8_t *)(v55 + v63)), veor_s8(*(int8x8_t *)(v65.val[0].i64[0] + v48 - 5), *(int8x8_t *)(v65.val[0].i64[0] + v46 - 3))), vrev64_s8(vmul_s8((int8x8_t)*(_OWORD *)&vqtbl4q_s8(v65, (int8x16_t)xmmword_100151930), (int8x8_t)0x7777777777777777)));
  return (*(uint64_t (**)(__n128))(a46 + 8 * ((61 * (v56 == 0)) ^ a6)))((__n128)xmmword_100151930);
}

void sub_1000480E0()
{
  JUMPOUT(0x10004801CLL);
}

uint64_t sub_1000480E8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, int a4@<W8>)
{
  uint64_t v4;
  uint64_t v5;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v5
                                                                                + 8
                                                                                * (a4 ^ (168
                                                                                       * (*(_DWORD *)(v4 - 136) == *(_DWORD *)(v4 - 144)))))
                                                                    - 57 * (a4 ^ 0x21Bu)
                                                                    + 1926))(a1, a2, a3, a4 ^ 0x5ABu);
}

uint64_t sub_100048134(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = (a5 - 1689882938);
  *(_BYTE *)(*(_QWORD *)(v9 - 120) + v11) ^= *(_BYTE *)(v7 + (v11 & 0xF)) ^ *(_BYTE *)((v11 & 0xF) + v8 + 2) ^ *(_BYTE *)((v11 & 0xF) + v6 + 4) ^ (119 * (v11 & 0xF));
  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * ((239 * (a5 - 1 == v5)) ^ (a4 - 1811))) - 8))();
}

void sub_1000481A4()
{
  int v0;
  int v1;
  uint64_t v2;

  if (v0 == 834867671)
    v1 = 489733862;
  else
    v1 = -489691842;
  *(_DWORD *)(v2 + 32) = v1;
}

uint64_t sub_100048208(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)(void))((char *)*(&off_10017BFF0 + ((1275 * (*(_DWORD *)(a2 + 4) == 1528691551)) ^ 0x2CAu)) - 4))();
}

uint64_t sub_100048248(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 16) = (**(unsigned __int8 **)(a2 + 8) ^ 0x71BD7F2E)
                       - 8994862
                       + ((2 * **(unsigned __int8 **)(a2 + 8)) & 0x5C);
  return 0;
}

uint64_t sub_10004827C()
{
  return 4294925278;
}

void sub_100048284(_DWORD *a1)
{
  unsigned int v1;

  v1 = *a1 + 1178560073 * ((((2 * (_DWORD)a1) | 0xD228BF70) - (_DWORD)a1 - 1762942904) ^ 0x8E217DD0);
  __asm { BR              X10 }
}

uint64_t sub_100048334()
{
  unsigned int v0;
  _DWORD *v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * (int)((659 * (*v1 != 0)) ^ (v0 + 473))) - (v0 ^ 0x37BLL)))();
}

uint64_t sub_10004837C()
{
  _DWORD *v0;
  uint64_t v1;
  uint64_t (*v2)(_QWORD);
  int v3;
  unsigned int *v4;
  uint64_t v5;

  v5 = v2(*v4);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v1 + 8 * ((220 * (*v0 != 0)) ^ v3)) - 8))(v5);
}

uint64_t sub_1000483A8()
{
  uint64_t v0;
  _DWORD *v1;
  uint64_t (*v2)(_QWORD);
  unsigned int *v3;
  uint64_t result;

  result = v2(*v3);
  *v1 = 0;
  *(_DWORD *)v0 = 0;
  *(_QWORD *)(v0 + 344) = 0;
  *(_QWORD *)(v0 + 352) = 0;
  *(_DWORD *)(v0 + 360) = 775263486;
  *(_DWORD *)(v0 + 56) = 733061813;
  return result;
}

uint64_t sub_1000483E8()
{
  _DWORD *v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((220 * (*v0 != 0)) ^ v2)) - 8))();
}

void sub_10004840C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v5;
  int v6;

  if (a4)
    v5 = a5 == 0;
  else
    v5 = 1;
  v6 = v5;
  __asm { BR              X9 }
}

uint64_t sub_1000484A4(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, _DWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14)
{
  uint64_t v14;
  int v15;
  uint64_t v16;

  *a4 = 0;
  *a5 = 0;
  a14 = 1178560073 * ((&a13 & 0xFB2A6C05 | ~(&a13 | 0xFB2A6C05)) ^ 0xE3E0B192) - 1501685844;
  v16 = sub_100074AF8(&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v14 + 8 * ((1912 * (a13 == v15)) ^ 0x3CDu)) - 4))(v16);
}

uint64_t sub_100048534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t *a13, unsigned int a14, int a15)
{
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  a13 = &STACK[0x82D647BA4E69FD9];
  a14 = (831981571 * (&a13 ^ 0x99A1D024)) ^ 0x87;
  sub_1000344DC((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16
                                                                                          + 8
                                                                                          * ((1472 * (a15 == v17)) ^ v15))
                                                                              - 4))(v18, v19, v20, v21, v22);
}

uint64_t sub_1000485B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unsigned int a16)
{
  uint64_t v16;
  int v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v20 = 1224239923 * ((2 * (&a13 & 0x7345948) - &a13 + 2026612400) ^ 0x8A785B67);
  LODWORD(a15) = v20 ^ 0x3A4;
  a14 = a11;
  LODWORD(a13) = v18 - ((2 * v18) & 0xDE3BA25A) - v20 - 283258579;
  sub_10004A21C((uint64_t)&a13);
  v21 = 69008221 * (&a13 ^ 0xD3A2520A);
  a13 = v16;
  a16 = (((2 * v17) & 0xF9CEBFF0) - 1879330880 + (v17 ^ 0x7CE75FF8)) ^ v21;
  HIDWORD(a14) = v21 + 1026;
  a15 = a11;
  sub_100034A2C((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v19 + 8 * ((67 * ((_DWORD)a14 != 489733862)) ^ 0x21Bu))
                                                                                                - 12))(v22, v23, v24, v25, v26, v27, v28);
}

uint64_t sub_10004871C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, int a15, uint64_t a16, unint64_t *a17, int a18)
{
  int v18;
  int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;

  v22 = ((2 * (&a13 & 0x619B6640) - &a13 - 1637574216) ^ 0x6CD7646F) * v21;
  a15 = v22 ^ 0x4C38421D;
  a16 = a11;
  a17 = &STACK[0x72F2C1D3322B87F0];
  a13 = v22 ^ 0x12B68929;
  a14 = (v19 + 368399638) ^ v22;
  v23 = sub_100074BB8((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v20
                                                      + 8
                                                      * (((a18 == v18) * (((v19 - 411) | 0x34D) + 1007)) ^ (v19 + 61)))
                                          - 12))(v23);
}

uint64_t sub_1000487DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unint64_t *a10, uint64_t a11, uint64_t a12, unint64_t *a13, unint64_t *a14, unint64_t *a15, unint64_t *a16)
{
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;

  v18 = v16 - 414;
  a15 = &STACK[0x20BA795F69D3FB1];
  a16 = a10;
  LODWORD(a13) = v18
               - 2078219279
               * ((((&a13 | 0xEC8CA36A) ^ 0xFFFFFFFE) - (~&a13 | 0x13735C95)) ^ 0xC989CAE1)
               - 231788976;
  a14 = &STACK[0x7F1325F673F67E6F];
  sub_1000751F8((uint64_t)&a13);
  a13 = &STACK[0x20BA795F69D3FB5];
  a14 = a10;
  LODWORD(a15) = v18
               - 944348131 * (((&a13 | 0xDB8EA39F) - (&a13 & 0xDB8EA39F)) ^ 0x789707D1)
               + 332;
  ((void (*)(unint64_t **))((char *)*(&off_100180420 + (int)(v18 ^ 0x50)) - 8))(&a13);
  a13 = a10;
  LODWORD(a14) = v18
               - 241568881 * ((&a13 & 0xF6FDF46A | ~(&a13 | 0xF6FDF46A)) ^ 0xDF130FD7)
               + 396;
  v19 = sub_10005A5D8((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v17 + 8 * (int)((1403 * (HIDWORD(a14) == 489733862)) ^ v18))
                                          - (v18 ^ 0xBELL)))(v19);
}

uint64_t sub_100048964(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10)
{
  int v10;
  int v11;
  uint64_t v12;

  return ((uint64_t (*)(void))(*(_QWORD *)(v12
                                        + 8 * (int)(((a10 == v11) * ((v10 + 1500070692) & 0xA696BE79 ^ 0x195)) ^ v10))
                            - 4))();
}

uint64_t sub_1000489A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int v9;
  int v10;
  uint64_t v11;

  return ((uint64_t (*)(void))(*(_QWORD *)(v11 + 8 * ((74 * (a9 != (v9 ^ 0x2E2 ^ (v10 - 552)))) ^ v9)) - 4))();
}

uint64_t sub_1000489E0@<X0>(int a1@<W8>)
{
  int v1;
  unsigned int v2;
  uint64_t v3;
  BOOL v4;

  v4 = ((uint64_t (*)(_QWORD, uint64_t))*(&off_100180420 + v1 + 40))(a1 ^ v2, 2089196818) == 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((978 * ((v4 ^ (v1 - 1)) & 1)) ^ v1))
                            - (v1 + 414)
                            + 596))();
}

uint64_t sub_100048A3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9)
{
  int v9;
  int v10;
  uint64_t v11;
  unsigned int v12;

  v12 = (a9 ^ v10) - (((a9 ^ v10) << (((v9 + 69) & 0xEF) + 18)) & 0xE90E7872) - 192463815;
  return ((uint64_t (*)(void))(*(_QWORD *)(v11
                                        + 8
                                        * ((2034
                                          * (((v12 << ((v9 + 64) & 0xBF ^ 0xBB)) & 0xDFBCBFFE ^ 0xC90C3872)
                                           + (v12 ^ 0x1B5963C6)
                                           + 1513619417 != 1242980312)) ^ (v9 + 774)))
                            - 12))();
}

uint64_t sub_100048B08(uint64_t a1)
{
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  return (*(uint64_t (**)(uint64_t, uint64_t))(v5
                                                     + 8
                                                     * ((1804
                                                       * (v2 + v1 + 270639105 >= ((v4 + 2136206848) & 0xDBFFBBDD)
                                                                               - 1532210117)) ^ v4)))(a1, v3);
}

uint64_t sub_100048B70(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * (a3 ^ (972 * ((unint64_t)(v3 - a1) > 0x1F))))
                            - ((a3 + 574) | 0x29u)
                            + 2079))();
}

uint64_t sub_100048BB0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v4;
  uint64_t v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((4 * (v4 < a4 - 2059)) | (16 * (v4 < a4 - 2059)) | a4))
                            + 1532210121
                            - ((a4 - 606885950) & 0x7F7FFBDF)))();
}

uint64_t sub_100048C00(uint64_t a1)
{
  int v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int8x16_t v10;
  uint64_t v11;
  int8x16_t v12;
  int8x16_t v13;
  uint64_t v14;

  v10.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v10.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v11 = v5 + v4 + v6 + 23 * (v7 ^ (v8 + 1465));
  v12 = *(int8x16_t *)(v2 + v11 - 15);
  v13 = *(int8x16_t *)(v2 + v11 - 31);
  v14 = a1 + v11;
  *(int8x16_t *)(v14 - 15) = veorq_s8(v12, v10);
  *(int8x16_t *)(v14 - 31) = veorq_s8(v13, v10);
  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * ((v1 + v7 + 640) | (2 * ((v3 & 0xFFFFFFE0) != 32)))) - 8))();
}

void sub_100048C68()
{
  JUMPOUT(0x100048C18);
}

uint64_t sub_100048C74(uint64_t a1)
{
  int v1;
  int v2;
  _DWORD *v3;
  _QWORD *v4;
  void (*v5)(unsigned int *);
  unsigned int v6;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  *v4 = a1;
  *v3 = v2;
  v6 = (v1 + 2136909635) & 0x80A15BCF;
  v10 = (v1 - 34) ^ (69008221 * ((2 * (&v10 & 0x64DF65F8) - &v10 + 455121410) ^ 0xC882C808));
  v11 = v8;
  v5(&v10);
  v10 = (v6 - 821) ^ (69008221 * (((&v10 | 0xD42F85AB) - (&v10 & 0xD42F85AB)) ^ 0x78DD7A1));
  v11 = v9;
  v5(&v10);
  return 0;
}

void sub_100048F50(uint64_t a1)
{
  int v1;
  int v2;
  _BYTE v3[4];
  unsigned int v4;
  uint64_t v5;

  v1 = *(_DWORD *)(a1 + 8) + 944348131 * ((((2 * a1) | 0x23956760) - a1 + 1848986704) ^ 0x32D317FE);
  v2 = *(_DWORD *)(*(_QWORD *)a1 - 0x2DB44D49A49B002ALL);
  v5 = *(_QWORD *)a1;
  v4 = v1 - 1224239923 * (((v3 | 0x11165558) - (v3 & 0x11165558)) ^ 0xE3A5A88F) + 531;
  sub_10002F0FC((uint64_t)v3);
  __asm { BR              X9 }
}

uint64_t sub_100049070@<X0>(uint64_t a1@<X8>)
{
  int v1;
  char v2;
  char v3;

  return (*(uint64_t (**)(void))(a1
                              + 8
                              * ((13 * (((v3 - v2) & 0x1F ^ 0x16) == (((v1 - 138) | 0x803) ^ 0xC38) - 1051)) ^ ((v1 - 138) | 0x803))))();
}

uint64_t sub_1000490E0@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  int v3;

  return (*(uint64_t (**)(void))(a1
                              + 8
                              * ((67
                                * (((v2 + 1616668128) & 0x9FA396DF ^ 0x801DAB38)
                                 + (v3 ^ 0x7FF7D71C)
                                 - 1409792
                                 + (v1 & 0xFFEFAE38) < (v2 ^ 0x7FFFFBE4u))) ^ v2)))();
}

uint64_t sub_10004915C@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  int v3;
  int v4;
  uint64_t v5;

  *(_DWORD *)(*(_QWORD *)(v5 - 0x2DB44D49A49B0026) + 4 * (v1 + 1077661677 + v2)) = *(_DWORD *)(*(_QWORD *)(v5 - 0x2DB44D49A49B0026)
                                                                                                 + 4
                                                                                                 * (v3 + v2 + 171));
  return (*(uint64_t (**)(uint64_t, uint64_t))(a1
                                                     + 8
                                                     * ((2009
                                                       * ((v4 ^ 0xC0 ^ ((v3 + v2 + 170) < 0x7FFFFFFF)) & 1)) ^ v4 ^ 0x7D9)))(793, 0x7FFFFFFFLL);
}

void sub_1000491CC()
{
  JUMPOUT(0x10004918CLL);
}

uint64_t sub_1000491D4@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1
                                        + 8
                                        * ((((int)((v3 ^ 0xF6FEFFFF) + 2046417652 + (v1 & 0xEDFDFFFE) - 1895357172) > (int)((v2 - 434) ^ 0xFFFFFD96))
                                          * (((2 * (v2 - 434)) ^ 0xBE) - 1128)) ^ (v2 - 434)))
                            - 4))();
}

uint64_t sub_10004926C@<X0>(int a1@<W2>, int a2@<W3>, uint64_t a3@<X8>)
{
  int v3;
  int v4;
  int v5;
  char v6;
  int v7;
  int v8;
  uint64_t v9;
  unsigned int v10;

  v10 = *(_DWORD *)(*(_QWORD *)(v9 - 0x2DB44D49A49B0026) + 4 * (v8 + v7 + (a1 ^ 0x19Fu) + 118)) ^ v5;
  *(_DWORD *)(*(_QWORD *)(v9 - 0x2DB44D49A49B0026) + 4 * (v3 + v4)) = ((v10 >> (32 - v6)) | a2 ^ v5)
                                                                        + v5
                                                                        - ((2 * ((v10 >> (32 - v6)) | a2 ^ v5)) & 0xC90F512E);
  return ((uint64_t (*)(void))(*(_QWORD *)(a3 + 8 * ((415 * (v8 + v7 + 1131 >= 0)) ^ ((a1 ^ 0x19F) - 397))) - 4))();
}

void sub_100049310()
{
  JUMPOUT(0x1000492A0);
}

uint64_t sub_100049318@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;

  return (*(uint64_t (**)(void))(a1
                              + 8
                              * (((((17 * (v2 ^ 0x83)) ^ 0xC01E21D1) + v1 > 0x7FFFFFFE) * ((17 * (v2 ^ 0xD1)) ^ 0x170)) ^ v2)))();
}

void sub_100049370()
{
  int v0;
  int v1;
  int v2;
  int v3;
  _DWORD *v4;
  int v5;

  v5 = 1405333480 - v0;
  if (*v4 + 1909582136 < 0)
    v5 = v1;
  *v4 = v3 + v2 + *v4 + v5 - 927;
}

uint64_t sub_10004953C(uint64_t a1)
{
  int v1;
  int v2;
  BOOL v3;
  int v4;
  int v5;

  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL);
  v4 = v2 - 237901512;
  v3 = v2 - 237901512 < 0;
  v5 = 237901512 - v2;
  if (!v3)
    v5 = v4;
  v1 = (*(_DWORD *)(a1 + 16) ^ (944348131 * ((-2 - ((a1 | 0x128ABCF6) + (~(_DWORD)a1 | 0xED754309))) ^ 0x4E6CE747)))
     + 1358;
  return (*(uint64_t (**)(void))((char *)*(&off_100180420 + v1 - 1450)
                              + 8
                              * (((v1 + (v5 ^ 0x5FD39BD9) + ((2 * v5) & 0xBFA737B2) - 1607705038 < 0x7FFFFFFF)
                                * ((v1 ^ 0x552) + 840)) ^ v1)
                              - 4))();
}

uint64_t sub_100049648()
{
  int v0;
  uint64_t v1;
  _QWORD *v2;
  int v3;
  unsigned int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8 * ((1622 * (*(_DWORD *)(*v2 + 4 * v4) != 762 * (v3 ^ 0xA4) + v0)) ^ v3))
                            - ((131 * (v3 ^ 0xA4u)) ^ 0x102)))();
}

uint64_t sub_100049694@<X0>(int a1@<W8>)
{
  uint64_t v1;
  int v2;

  return (*(uint64_t (**)(void))(*(_QWORD *)(v1 + 8 * (v2 - 1450))
                              - 4
                              + 8 * ((((a1 - 1574144914) < 0x7FFFFFFF) * ((v2 ^ 0x552) + 840)) ^ v2)))();
}

_DWORD *sub_1000496D8(_DWORD *result)
{
  *result = 1307958044;
  return result;
}

uint64_t sub_1000496E8()
{
  int v0;
  uint64_t v1;
  int v2;
  int v3;
  unsigned int v4;
  _BOOL4 v5;

  v4 = (v3 + 578823846) & 0xDD7FD953;
  v5 = ((v2 ^ (v0 + 1780) ^ v4) & 0x80000000) == 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * (int)((2 * v5) | (4 * v5) | v4)) - 4))();
}

uint64_t sub_100049758()
{
  unsigned int v0;
  uint64_t v1;
  int v2;
  char v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8
                                             * ((2 * (((v0 >> v3) & 1) == 0)) | (4 * (((v0 >> v3) & 1) == 0)) | v2))
                            - 4))();
}

_DWORD *sub_100049784@<X0>(_DWORD *result@<X0>, int a2@<W8>)
{
  int v2;
  int v3;

  *result = v3 + 32 * a2 + v2 - 1820040439;
  return result;
}

void sub_1000497A0(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 16) + 944348131 * ((2 * (a1 & 0x4CB3C068) - a1 - 1286848617) ^ 0x10559BD9);
  __asm { BR              X11 }
}

uint64_t sub_10004986C@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, unint64_t *a4, unint64_t *a5, int a6, unsigned int a7, uint64_t a8, uint64_t a9)
{
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  unsigned int v14;
  uint64_t v15;

  v13 = v9 + 37;
  v14 = 1178560073
      * (((&a4 | 0x93C5D81) - &a4 + (&a4 & 0xF6C3A278)) ^ 0xEE097FE9);
  a4 = &STACK[0x7F1325F673F67E57];
  a5 = &STACK[0x20BA795F69D3FBD];
  a9 = v12;
  a6 = v9 + 37 - v14 - 104;
  a7 = 866342037 - v14;
  v15 = ((uint64_t (*)(unint64_t **))(*(_QWORD *)(a1 + 8 * ((v9 + 37) ^ 0x26C)) - 8))(&a4);
  return (*(uint64_t (**)(uint64_t))(v11
                                            + 8
                                            * (((*(_DWORD *)(v12 - 0x56428495FB6297ALL) == v10)
                                              * (311 * (v13 ^ 0x229) - 121)) ^ v13)))(v15);
}

uint64_t sub_100049958(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11)
{
  int v11;
  uint64_t v12;
  int v13;

  return ((uint64_t (*)(void))(*(_QWORD *)(v12 + 8 * ((25 * (a11 == ((v11 + (v13 ^ 0x45) - 1096) ^ (v13 - 67)))) ^ v13))
                            - 4))();
}

void sub_100049994(_DWORD *a1@<X8>)
{
  char v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  unsigned __int8 *v6;

  v4 = v6[3] ^ 0xFE;
  v5 = ((*v6 ^ 0xFE) << 24) | ((v6[1] ^ 0xFE) << 16) | ((v6[2] ^ (((v1 - 41) | 4) - 8)) << 8) | v4;
  *(_DWORD *)(*(_QWORD *)v2 - 0x20BA795F69D3FB1) = v5 + v3 - 2 * (v5 & (v3 + 8) ^ v4 & 8);
  *(_DWORD *)(v2 + 20) = *a1;
}

void sub_100049A58(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 8) ^ (831981571 * ((~(_DWORD)a1 & 0xE26CEAFC | a1 & 0x1D931503) ^ 0x7BCD3AD8));
  __asm { BR              X10 }
}

uint64_t sub_100049B20@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, unsigned int a4, int a5, unint64_t *a6, int a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v10 = 3804331
      * (((&a3 | 0x4F6F6A9A) - &a3 + (&a3 & 0xB0909560)) ^ 0x31BA4F6C);
  a6 = &STACK[0x118C242060FB2D82];
  a7 = (v7 - 163) ^ v10;
  a3 = v8;
  a4 = v10 ^ 0xC69D8745;
  a5 = v10 ^ 0x49D399B7;
  v11 = (*(uint64_t (**)(uint64_t *))(a1 + 8 * (v7 - 372)))(&a3);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v9
                                                      + 8
                                                      * ((82 * (*(_DWORD *)(v8 - 0x56428495FB6297ALL) == 489733862)) ^ v7))
                                          - 8))(v11);
}

void sub_100049BF4(_DWORD *a1@<X8>)
{
  char v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _BYTE *v5;

  v4 = 0x4B2E0CD15FF33695 * (*(_QWORD *)v2 ^ v3)
     - ((0x965C19A2BFE66D2ALL * (*(_QWORD *)v2 ^ v3) + 0x4FF97877D62CBDFELL) & 0xA4F186FB0AF33512)
     - 0x58A80468F700678;
  *v5 = (HIBYTE(v4) ^ v1) + ((2 * HIBYTE(v4)) & 0xFC ^ 0x5B) - 1;
  v5[1] = (BYTE6(v4) ^ 0x78) + ((2 * BYTE6(v4)) & 0xFC ^ 0xF) - 1;
  v5[2] = (BYTE5(v4) ^ 0xC3) + ((2 * ((BYTE5(v4) ^ 0xC3 | 0x7E) ^ BYTE5(v4))) ^ 0x85) - 1;
  v5[3] = (BYTE4(v4) ^ 0x7D) - ((2 * (BYTE4(v4) ^ 0x7D)) & 0xFC) - 2;
  v5[4] = (BYTE3(v4) ^ 0x85) - ((2 * (BYTE3(v4) ^ 0x85)) & 0xFC) - 2;
  v5[5] = (BYTE2(v4) ^ 0x79) - ((2 * (BYTE2(v4) ^ 0x79)) & 0xFC) - 2;
  v5[6] = (BYTE1(v4) ^ 0x9A) - ((2 * (BYTE1(v4) ^ 0x9A)) & 0xFC) - 2;
  v5[7] = v4 ^ 0x77;
  *(_DWORD *)(v2 + 12) = *a1;
}

void sub_100049D90()
{
  int v0[10];

  v0[1] = 1178560073 * ((v0 & 0x294D8B40 | ~(v0 | 0x294D8B40)) ^ 0x318756D7) - 1501685844;
  sub_100074AF8(v0);
  __asm { BR              X8 }
}

uint64_t sub_100049E50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t *a13, unsigned int a14, int a15)
{
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  a13 = &STACK[0x82D647BA4E69FD9];
  a14 = (831981571 * ((2 * (&a13 & 0x49672DD0) - &a13 - 1231498705) ^ 0x2F39020B)) ^ 0x87;
  sub_1000344DC((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v16
                                                                                          + 8
                                                                                          * ((171 * (a15 == v15)) ^ 0x25Eu))
                                                                              - 4))(v17, v18, v19, v20, v21);
}

uint64_t sub_100049EE4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int a13, int a14, uint64_t a15, int a16)
{
  int v16;
  int v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v19 = 1224239923
      * ((((&a13 | 0x5C26CAC4) ^ 0xFFFFFFFE) - (~&a13 | 0xA3D9353B)) ^ 0x516AC8EC);
  a16 = v19 ^ 0x3A4;
  a15 = a11;
  a13 = v16 - v19 - ((2 * v16) & 0xDE3BA25A) - 283258579;
  sub_10004A21C((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v18
                                                                                         + 8
                                                                                         * ((940 * (a14 == v17)) ^ 0x4D2u)))(v20, v21, v22, v23, v24, v25);
}

uint64_t sub_100049FB8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, unsigned int a15, uint64_t a16, unint64_t *a17, int a18)
{
  int v18;
  unsigned int v19;
  uint64_t v20;
  int v21;
  unsigned int v22;
  uint64_t v23;

  v22 = ((&a13 & 0x94F48E05 | ~(&a13 | 0x94F48E05)) ^ 0x99B88C2D) * v21;
  a16 = a11;
  a17 = &STACK[0x72F2C1D3322B87F0];
  a15 = v22 ^ 0xB49415C2;
  a13 = v22 ^ 0x12B68929;
  a14 = (v19 + 368398943) ^ v22;
  v23 = sub_100074BB8((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t))(v20 + 8 * ((11 * (a18 == v18 + (v19 ^ 0x68C) - 606)) ^ v19)))(v23);
}

uint64_t sub_10004A070()
{
  void (*v0)(unint64_t **);
  unsigned int v1;
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  unint64_t *v8;
  unint64_t *v9;
  int v10;
  unint64_t *v11;
  unint64_t *v12;
  unsigned int v13;

  v5 = 101 * (v4 ^ 0x4D4);
  v13 = v4
      - 944348131 * ((((2 * &v11) | 0xFE58FDAA) - &v11 - 2133622485) ^ 0xDC35DA9B)
      - 716;
  v11 = &STACK[0x20BA795F69D3F1D];
  v12 = v8;
  ((void (*)(unint64_t **))(*(_QWORD *)(v3 + 8 * (v4 ^ 0x438u)) - 8))(&v11);
  LODWORD(v12) = v4 - 241568881 * (&v11 ^ 0xD6110442) - 652;
  v11 = v8;
  sub_10005A5D8((uint64_t)&v11);
  if (HIDWORD(v12) == (v5 ^ (v1 - 558)))
    v6 = v10;
  else
    v6 = HIDWORD(v12);
  LODWORD(v11) = (v4 - 1082) ^ (((((&v11 | 0x239FE8D4) ^ 0xFFFFFFFE) - (~&v11 | 0xDC60172B)) ^ 0xFC24521)
                              * v2);
  v12 = v8;
  v0(&v11);
  LODWORD(v11) = (v5 - 454) ^ (((((&v11 | 0x7CEACA56) ^ 0xFFFFFFFE) - (~&v11 | 0x831535A9)) ^ 0x50B767A3)
                             * v2);
  v12 = v9;
  v0(&v11);
  return v6 ^ v1;
}

void sub_10004A21C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 16) ^ (1224239923 * ((((2 * a1) | 0x124C8F9E) - a1 - 153503695) ^ 0xFB95BA18));
  __asm { BR              X10 }
}

uint64_t sub_10004A2F0@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, unsigned int a4, int a5, unint64_t *a6, int a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v10 = 3804331 * ((101839932 - (&a3 | 0x611F43C) + (&a3 | 0xF9EE0BC3)) ^ 0x873B2E35);
  a7 = (v7 - 669) ^ v10;
  a3 = v8;
  a4 = v10 ^ 0xC69D8745;
  a5 = v10 ^ 0x49D399B3;
  a6 = &STACK[0x118C242060FB2D82];
  v11 = (*(uint64_t (**)(uint64_t *))(a1 + 8 * (v7 ^ 0x392)))(&a3);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v9
                                                      + 8
                                                      * ((2962 * (*(_DWORD *)(v8 - 0x56428495FB6297ALL) == 489733862)) ^ v7))
                                          - 8))(v11);
}

void sub_10004A3D0(_DWORD *a1@<X8>)
{
  _DWORD *v1;
  int v2;
  int v3;
  _BYTE *v4;

  v3 = *v1 + v2;
  *v4 = (HIBYTE(v3) ^ 0xEF) + ((2 * ((HIBYTE(v3) ^ 0xEF | 0x7E) ^ HIBYTE(v3))) ^ 0xDD) - 1;
  v4[1] = (BYTE2(v3) ^ 0x1D) + ((2 * ((BYTE2(v3) ^ 0x1D | 0x7E) ^ BYTE2(v3))) ^ 0x39) - 1;
  v4[2] = (BYTE1(v3) ^ 0xD1) - ((2 * (BYTE1(v3) ^ 0xD1)) & 0xFC) - 2;
  v4[3] = v3 ^ 0xD3;
  v1[1] = *a1;
}

void sub_10004A48C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 24) ^ (3804331 * (((a1 | 0x16831F20) - (a1 | 0xE97CE0DF) - 377691937) ^ 0x68563AD6));
  __asm { BR              X9 }
}

uint64_t sub_10004A568@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7, uint64_t a8)
{
  uint64_t v8;
  _DWORD *v9;
  int v10;
  uint64_t v11;
  int v12;
  int v13;
  unsigned int v14;
  uint64_t v15;

  v14 = 235795823 * ((&a5 & 0x844DC5BB | ~(&a5 | 0x844DC5BB)) ^ 0xEF1F731D);
  a7 = (*(_DWORD *)(a1 + 12) ^ v12) + *(_DWORD *)(v8 - 0x56428495FB62982) - 1238604199 - v14 + 1437477768;
  a8 = v8;
  a6 = (v13 + 1835) ^ v14;
  a5 = 39978617 - v14;
  v15 = (*(uint64_t (**)(unsigned int *))(a2 + 8 * (v13 - 235)))(&a5);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v11 + 8 * ((1143 * (*v9 == v10)) ^ v13))
                                          - ((v13 + 1183) | 9u)
                                          + 1451))(v15);
}

uint64_t sub_10004A64C()
{
  uint64_t v0;
  int v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v2
                              + 8
                              * (int)(((*(_QWORD *)(v0 + 16) != 0x118C242060FB2D82)
                                     * (v1 ^ 0x4BE ^ (v1 + 708022840) & 0xD5CC691F)) ^ v1)))();
}

uint64_t sub_10004A6B4@<X0>(int a1@<W8>)
{
  uint64_t v1;
  int v2;
  _DWORD *v3;
  uint64_t v4;
  _DWORD *v5;
  int v6;
  uint64_t v7;

  *(_QWORD *)(v1 - 0x118C242060FB2D82) = (*v3 + a1) + *(_QWORD *)(v4 - 0x56428495FB62992) + 8;
  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * ((79 * (*v5 == v6)) ^ v2)) - 4))();
}

void sub_10004A710(int a1@<W8>)
{
  unsigned int v1;
  _DWORD *v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  unsigned int v8;
  int v9;

  v5 = *(_QWORD *)(v3 - 0x56428495FB62992);
  v6 = *v2 + a1;
  *(_BYTE *)(v5 + v6) = (HIBYTE(v1) ^ 0xC6) + ((v1 >> 23) & 0xFC ^ 0x73) - 1;
  *(_BYTE *)(v5 + v6 + 1) = (BYTE2(v1) ^ 0x66) + ((v1 >> 15) & 0xFC ^ 0x33) - 1;
  *(_BYTE *)(v5 + v6 + 2) = (BYTE1(v1) ^ 0x9E) - ((2 * (BYTE1(v1) ^ 0x9E)) & 0xFC) - 2;
  *(_BYTE *)(v5 + v6 + 3) = v1 ^ 0xE3;
  v7 = *(_QWORD *)(v3 - 0x56428495FB62992);
  LODWORD(v5) = v4 - ((2 * v4 + 1817758882) & 0x59B231B0) + 1661304617;
  v8 = ((2 * (a1 + *v2 + 4)) & 0xEFDEBEB6) + ((a1 + *v2 + 4) ^ 0xF7EF5F5B) + 135307429;
  *(_BYTE *)(v7 + v8) = (BYTE3(v5) ^ 0xAC) + ((v5 >> 23) & 0xFC ^ 0xA7) - 1;
  *(_BYTE *)(v7 + v8 + 1) = (BYTE2(v5) ^ 0xD9) + ((2 * ((BYTE2(v5) ^ 0xD9 | 0x7E) ^ BYTE2(v5))) ^ 0xB1) - 1;
  *(_BYTE *)(v7 + v8 + 2) = (BYTE1(v5) ^ 0x18) - ((2 * (BYTE1(v5) ^ 0x18)) & 0xFC) - 2;
  *(_BYTE *)(v7 + v8 + 3) = (v4 - ((2 * v4 - 94) & 0xB0) + 41) ^ 0x26;
  *v2 = v9;
}

void sub_10004A960(uint64_t a1)
{
  int v1;
  int v2;
  BOOL v3;
  int v4;

  v1 = 2078219279 * ((a1 & 0x58BF7D47 | ~(a1 | 0x58BF7D47)) ^ 0x7DBA14CC);
  v2 = *(_DWORD *)(a1 + 60) - v1;
  if (*(_QWORD *)(a1 + 8) | *(_QWORD *)(a1 + 64))
    v3 = *(_DWORD *)(a1 + 24) + v1 == 726518779;
  else
    v3 = 1;
  v4 = !v3;
  __asm { BR              X8 }
}

uint64_t sub_10004AAD0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  _BOOL4 v4;

  v4 = *(_QWORD *)(v1 + 16) == 0x4FE3AE517815B46FLL || *(_OWORD *)(v1 + 40) == 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((v4 * ((v0 + 30) ^ 0x745 ^ ((v0 - 319) | 4))) ^ v0)) - 12))();
}

uint64_t sub_10004AB2C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, int a9@<W8>)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = *(_QWORD *)(v11 + 32);
  *(_DWORD *)(v9 - 0x4FE3AE517815B46FLL) = 0;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v12 + 8 * ((11 * ((((a9 + 345) ^ (v13 == 0x2DB44D49A49B002ELL)) & 1) == 0)) ^ a9)) - ((a9 - 775) | 0x460u) + 1108))(a1, a2, a3, a4, a5, a6, a7, a8, v10);
}

uint64_t sub_10004AC00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v8 + 8 * ((923 * (((v7 == 0) ^ (v6 - 1)) & 1)) ^ (v6 + 380)))
                                                                                       - 12))(a1, a2, a3, a4, a5, a6);
}

uint64_t sub_10004AC4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  int v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  uint64_t v29;

  v26 = v16 + 670;
  v27 = ((((2 * (v25 - 144)) | 0x4F0C6938) - (v25 - 144) + 1484376932) ^ 0x3E27E4B8) * v18;
  *(_QWORD *)(v25 - 136) = v24;
  *(_QWORD *)(v25 - 128) = v23;
  *(_DWORD *)(v25 - 144) = (v19 - 716312215 + v16 + 670) ^ v27;
  *(_DWORD *)(v25 - 140) = v27 + v16 + 1070;
  v28 = v17;
  ((void (*)(uint64_t))((char *)*(&off_100180420 + v16 - 404) - 4))(v25 - 144);
  *(_DWORD *)(v25 - 144) = v26
                         - 1224239923
                         * ((((v25 - 144) | 0x608DC9E7) - (v25 - 144) + ((v25 - 144) & 0x9F723618)) ^ 0x923E3430)
                         + 271;
  *(_QWORD *)(v25 - 136) = a15;
  *(_QWORD *)(v25 - 128) = v20;
  ((void (*)(uint64_t))*(&off_100180420 + v26 - 1048))(v25 - 144);
  *(_DWORD *)(v25 - 136) = v26 - ((((2 * (v25 - 144)) | 0x495F6FA2) - (v25 - 144) - 615495633) ^ 0x683935AC) * v28 - 389;
  *(_QWORD *)(v25 - 128) = a14;
  *(_QWORD *)(v25 - 120) = v20;
  *(_QWORD *)(v25 - 144) = a10;
  *(_QWORD *)(v25 - 112) = a16;
  *(_QWORD *)(v25 - 104) = a15;
  v29 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + v26 - 1050) - 4))(v25 - 144);
  return (*(uint64_t (**)(uint64_t))(v22 + 8 * (((((v26 - 1006) | 0x513) ^ 0x595) * (v21 != 0)) ^ v26)))(v29);
}

uint64_t sub_10004AED4()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t result;
  int v8;
  uint64_t v9;
  _DWORD *v10;

  v6 = 3804331 * ((((v5 - 144) | 0x65655D98) - ((v5 - 144) & 0x65655D98)) ^ 0x1BB0786E);
  *(_QWORD *)(v5 - 120) = v2;
  *(_DWORD *)(v5 - 128) = (v4 - 1327) ^ v6;
  *(_DWORD *)(v5 - 124) = (v4 + v1 - 659318627) ^ v6;
  *(_QWORD *)(v5 - 136) = v9;
  result = ((uint64_t (*)(uint64_t))(*(_QWORD *)(v3 + 8 * (v4 - 1376)) - 8))(v5 - 144);
  *v10 = v8;
  *(_DWORD *)(v0 + 56) = 489733862;
  return result;
}

void sub_10004B004(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  char v6;
  void (*v7)(_QWORD, void (*)());
  _BYTE v8[8];

  v2 = (unint64_t)&v8[qword_1001A6C08 ^ qword_1001A6C10];
  v3 = 45734839 * v2 + 0x588D9F9B90E43A76;
  v4 = 45734839 * (v2 ^ 0xA77260646F1BC58ALL);
  v5 = (-73 * (v3 ^ 0x8A ^ v4));
  v6 = byte_100161B20[byte_10015DEA0[v5] ^ 0x4A];
  qword_1001A6C10 = v3;
  LOBYTE(v5) = byte_100161D20[byte_10015E0A0[v5] ^ 0x23];
  v7 = (void (*)(_QWORD, void (*)()))*(&off_100180420 + ((-73 * (v3 ^ 0x8A ^ v4)) ^ v6) - 30);
  qword_1001A6C08 = v4;
  v7(*(&off_100180420 + ((-73 * (v3 ^ 0x8A ^ v4)) ^ v5) + 57), sub_1000746B0);
  __asm { BR              X11 }
}

uint64_t sub_10004B118()
{
  unsigned int v0;
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((1375 * (**(_QWORD **)(v2 + 1752) == 0)) ^ v0)) - 4))();
}

uint64_t sub_10004B168@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t))(v2 + 8 * (a1 ^ 0x573u)))(v1);
}

void sub_10004B188(uint64_t a1)
{
  __asm { BR              X8 }
}

uint64_t sub_10004B1FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, unsigned int a16)
{
  int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;

  a16 = 1178560073 * ((((2 * &a15) | 0x3D2F85A6) - &a15 - 513262291) ^ 0xF9A2E0BB)
      - 1501685844;
  v19 = sub_100074AF8(&a15);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v17 + 8 * ((326 * (a15 == v16)) ^ v18)) - 4))(v19);
}

uint64_t sub_10004B270(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unint64_t *a15, unsigned int a16, int a17)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  a15 = &STACK[0x82D647BA4E69FE1];
  a16 = (831981571 * ((2 * (&a15 & 0x65541590) - &a15 + 447474284) ^ 0x830A3A48)) ^ 0x87;
  sub_1000344DC((uint64_t)&a15);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v17 + 8 * ((1524 * (a17 == 489733862)) ^ 0x2DFu))
                                                                                                - 4))(v18, v19, v20, v21, v22, v23, v24);
}

uint64_t sub_10004B30C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, unsigned int a17, uint64_t a18, unint64_t *a19, int a20)
{
  int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;

  v22 = 1224239923 * ((((2 * &a15) | 0x7801179A) - &a15 + 1140814899) ^ 0x4EB3761A);
  a16 = v22 ^ 0x15F55731;
  a17 = v22 ^ 0xE932552D;
  a15 = v22 ^ 0x12B68929;
  a18 = a12;
  a19 = &STACK[0x72F2C1D3322B8808];
  v23 = sub_100074BB8((uint64_t)&a15);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v21 + 8 * ((32 * (a20 != v20)) ^ 0x209)) - 12))(v23);
}

uint64_t sub_10004B3EC()
{
  unsigned int v0;
  int v1;
  void (*v2)(int *);
  int v3;
  int v4;
  uint64_t v6;
  int v7;
  uint64_t v8;

  v7 = (v4 - 420) ^ (((&v7 + 2080036327 - 2 * ((unint64_t)&v7 & 0x7BFAD5E7)) ^ 0xA85887ED) * v1);
  v8 = v6;
  v2(&v7);
  return v3 ^ v0;
}

uint64_t sub_10004B690(_DWORD *a1, uint64_t a2)
{
  return ((uint64_t (*)(void))((char *)*(&off_10017BFF0
                                      + ((2314 * ((*a1 + *(_DWORD *)(a2 + 4) - 1789133834) < 0xC9)) ^ 0x14Bu))
                            - 12))();
}

uint64_t sub_10004B6DC@<X0>(uint64_t a1@<X8>)
{
  int v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * ((3477 * (v1 != 1528691550)) ^ 0x59Au)) - 12))();
}

uint64_t sub_10004B714@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v3;
  int v4;
  unsigned int v5;
  _BOOL4 v6;
  _BOOL4 v7;

  *(_BYTE *)(a1 + (v4 + v3 + 315) + 4) = (**(_BYTE **)(a2 + 8) ^ 0xBD)
                                                     + ((2 * **(_BYTE **)(a2 + 8)) & 0x7A)
                                                     + 123;
  v5 = *(_DWORD *)(a2 + 4) - 1310909493;
  v6 = v5 < 0xCFB1729;
  v7 = v5 > 0xCFB172A;
  if (v6)
    v7 = v6;
  return ((uint64_t (*)(void))(*(_QWORD *)(a3 + 8 * ((19 * !v7) ^ 0x589u)) - 12))();
}

void sub_10004B7C0()
{
  JUMPOUT(0x10004B744);
}

uint64_t sub_10004B7C8()
{
  return 4294925278;
}

uint64_t sub_10004B7D0(_DWORD *a1)
{
  int v1;
  unsigned int v2;
  int v3;

  *((_BYTE *)a1 + (v3 ^ v2) + v1 + 4) = 56;
  *a1 = v1;
  return 0;
}

void sub_10004B7F0(unint64_t a1)
{
  unsigned int v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  int v7;
  int v8;
  char *v9;
  unsigned int v10;
  unsigned int v11;
  _QWORD v12[2];
  int v13;
  unint64_t v14;
  int v15;
  int v16;
  unint64_t v17;
  uint64_t v18;
  int32x4_t v19;
  unint64_t *v20;
  int32x4_t v21;
  unsigned int v22;
  int32x4_t v23;
  int v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  int v30;
  uint64_t v31;
  int v32;
  char v33;
  char v34;
  char v35;
  char v36;
  uint64_t v37;
  _BYTE v38[7];
  unint64_t *v40;
  unsigned int v41;
  unsigned int v42;

  v2 = 1224239923 * ((-2 - ((~(_DWORD)a1 | 0xC412E5) + (a1 | 0xFF3BED1A))) ^ 0xF277EF32);
  v3 = *(_DWORD *)(a1 + 20) - v2;
  v4 = *(_DWORD *)(a1 + 44) ^ v2;
  v5 = 235795823 * ((&v40 - 357749991 - 2 * (&v40 & 0xEAAD2B19)) ^ 0x7E006240);
  v6 = *(_DWORD *)a1;
  v14 = 1224239923 * ((-2 - ((~a1 | 0x60AD954400C412E5) + (a1 | 0x9F526ABBFF3BED1ALL))) ^ 0x48F7202DF277EF32);
  v7 = v6 - v2;
  v41 = v5 ^ 0xFE0643CC;
  v42 = v3 + v5 + 426522968;
  v20 = &STACK[0x73F39308AC2F38CF];
  v40 = &STACK[0x73F39308AC2F38CF];
  sub_10002D8CC((uint64_t)&v40);
  v8 = v4;
  v9 = (char *)*(&off_100180420 + (int)(v3 ^ 0x7B)) - 4;
  v10 = (v3 + 321) | 0x201;
  v18 = v10 + *(_QWORD *)&v9[8 * v3] - 891;
  v30 = v7 - 1101486580;
  v13 = v7 - 1686503861;
  v16 = v7 + 904658901;
  v15 = v7 - 99780761;
  v26 = &v37;
  v12[1] = (char *)&v12[-268299389] + 3;
  v12[0] = v38;
  v32 = v3 ^ 0x17B;
  v23 = vdupq_n_s32(0x1D30BEEEu);
  v22 = (v3 + 1392056206) & 0xAD06EF73;
  v21 = vdupq_n_s32(0x1D30BEFFu);
  v29 = v3;
  v24 = v3 ^ 0x7D;
  v25 = v3 + 1392056206;
  v31 = 4294966414;
  v27 = 4294966414;
  v28 = 4294967246;
  v19 = vdupq_n_s32(0x1D30BEE6u);
  v17 = a1;
  v11 = v8 - ((2 * v8 + 1553945956) & (((v10 + 230564935) & 0xF241D8ED) + 1504850184)) + 1529398154;
  v33 = ((v10 + 57) ^ HIBYTE(v11)) + ((v11 >> 23) & 0xFC ^ 0xA7) - 1;
  v34 = (BYTE2(v11) ^ 0xD9) + ((2 * ((BYTE2(v11) ^ 0xD9 | 0x7E) ^ BYTE2(v11))) ^ 0xB1) - 1;
  v35 = (BYTE1(v11) ^ 0x18) - ((2 * (BYTE1(v11) ^ 0x18)) & 0xFC) - 2;
  v36 = (v8 - ((2 * v8 + 100) & (((v10 + 71) & 0xED) + 8)) - 118) ^ 0x26;
  __asm { BR              X10 }
}

uint64_t sub_10004BC48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,unsigned int a33)
{
  int v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  unsigned int v38;

  v38 = v36 - 468581837;
  if (v38 <= 0x40)
    v38 = 64;
  return ((uint64_t (*)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v37
                                                                       + 8
                                                                       * (((226
                                                                          * ((v33 - 617988276) & 0x24D5C2FF ^ 0x2F1)
                                                                          - 1026)
                                                                         * (468581837 - v34 - v35 + v38 < 0xF)) ^ v33))
                                                           - 12))(a1, 1176923396, a33);
}

uint64_t sub_10004BCE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  int v28;
  int v29;
  int v30;
  int v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  _BOOL4 v35;

  v33 = v30 + v29;
  v34 = v30 + v29 - 468581837;
  if (v34 <= 0x40)
    v34 = 64;
  v35 = __CFADD__(v33 + (((v28 ^ 0x1C3) - 693) ^ 0xE41200C6), v31 + v34);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v32 + 8 * (v28 | (4 * v35))) - 4))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28);
}

uint64_t sub_10004BD40@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, int a9@<W8>, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  uint64_t v29;
  int v30;
  _OWORD *v31;
  uint64_t v32;

  *(_OWORD *)(a6 + (a1 + a9 + 30)) = *v31;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v32 + 8 * ((245 * (((((((v30 - 93) | 0x10u) + 0x1FFFFFA94) & (v29 + 1)) == 16) ^ (((v30 - 93) | 0x10) - 1)) & 1)) ^ ((v30 - 93) | 0x10))))(a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29);
}

void sub_10004BDAC()
{
  JUMPOUT(0x10004BD78);
}

uint64_t sub_10004BDB4()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * ((((((v1 - 1244) | 0x40) + 564) ^ 0x84) * (v0 == v2)) ^ ((v1 - 1244) | 0x40)))
                            - ((((v1 - 1244) | 0x40) - 178) | 0x10u)
                            + 18))();
}

uint64_t sub_10004BDF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,int a28,unsigned __int8 a29,unint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  int v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  int v42;
  uint64_t (*v43)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t *);
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  int v49;
  int v50;
  BOOL v52;
  uint64_t (*v53)(_QWORD, uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  BOOL v56;

  v43 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t *))(v40 + 8 * v38);
  v44 = STACK[0x2CC];
  v45 = STACK[0x2CC];
  v46 = STACK[0x2D0];
  v47 = STACK[0x2D4];
  v48 = STACK[0x2D0];
  v49 = STACK[0x2D4];
  v50 = LOBYTE(STACK[0x2E0]) ^ 0xE;
  if (v50 == 2)
  {
    v56 = (unint64_t)&STACK[0x280] < a30 && v41 < (unint64_t)&STACK[0x2C0];
    return ((uint64_t (*)(_QWORD, _QWORD))(*(_QWORD *)(v40
                                                               + 8
                                                               * ((1979 * ((v56 ^ (a38 + 1)) & 1)) ^ ((int)a3 + 298)))
                                                   - 12))(LODWORD(STACK[0x2D8]), LODWORD(STACK[0x2D8]));
  }
  else if (v50 == 1)
  {
    v52 = (unint64_t)&STACK[0x280] < a30 && v41 < (unint64_t)&STACK[0x2C0];
    v53 = *(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, unint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v40 + 8 * ((((v52 ^ a29) & 1) * a28) ^ ((int)a3 + 1792)));
    return v53(v53, 93, a3, 27, &STACK[0x280], a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
             a20,
             a21,
             a22,
             a23,
             a24,
             a25,
             a26,
             a27);
  }
  else
  {
    LODWORD(STACK[0x2C8]) = 2 * (LODWORD(STACK[0x2C8]) ^ v39) + v39 - (v42 & (4 * (LODWORD(STACK[0x2C8]) ^ v39)));
    LODWORD(STACK[0x2CC]) = (v45 ^ v39) + (v44 ^ v39) + v39 - (v42 & (2 * ((v45 ^ v39) + (v44 ^ v39))));
    LODWORD(STACK[0x2D0]) = (v48 ^ v39) + (v46 ^ v39) + v39 - (v42 & (2 * ((v48 ^ v39) + (v46 ^ v39))));
    LODWORD(STACK[0x2D4]) = (v49 ^ v39) + (v47 ^ v39) + v39 - (v42 & (2 * ((v49 ^ v39) + (v47 ^ v39))));
    return v43(3259404976, 93, a3, 27, &STACK[0x280]);
  }
}

uint64_t sub_10004CE1C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,int a30,uint64_t a31,uint64_t a32,unsigned int a33)
{
  uint64_t v33;
  _BOOL4 v34;

  if (a33 < 0x2440320B != a30 - 427375365 < ((a3 + 1231) ^ 0x2440370Bu))
    v34 = a30 - 427375365 < ((a3 + 1231) ^ 0x2440370Bu);
  else
    v34 = a30 - 427375365 > a33;
  return ((uint64_t (*)(void))(*(_QWORD *)(v33 + 8 * ((!v34 | (4 * !v34)) ^ (a3 + 1736)))
                            - (a3 + 1031)
                            + 1068))();
}

uint64_t sub_10004CE9C@<X0>(int a1@<W0>, int a2@<W8>)
{
  int v2;
  uint64_t v3;
  int v4;

  v4 = (((v2 - 56) | 0x23) ^ (a1 + 1052)) + a2 >= ((v2 - 1031) ^ (a1 - 47)) + a2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((2 * v4) | (v4 << 6) | v2)) - 4))();
}

uint64_t sub_10004CEE8@<X0>(int a1@<W0>, unint64_t a2@<X1>, int8x16_t *a3@<X5>, int a4@<W8>)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int8x16_t v7;
  int8x16_t v8;

  *a3 = vaddq_s8(vsubq_s8(*(int8x16_t *)(v6 + (a4 + a1)), vandq_s8(vaddq_s8(*(int8x16_t *)(v6 + (a4 + a1)), *(int8x16_t *)(v6 + (a4 + a1))), v8)), v7);
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((7 * (((v4 - 20) ^ a2) != 16)) ^ (v4 + 1010))) - 4))();
}

uint64_t sub_10004CF44@<X0>(int a1@<W0>, int a2@<W3>, uint64_t a3@<X5>, int a4@<W8>)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  *(_BYTE *)(a3 + v4) = *(_BYTE *)(v7 + (a4 + a1))
                      - ((2 * *(_BYTE *)(v7 + (a4 + a1))) & 0xFC)
                      - 2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * (((v4 + 1 != (v5 - 1030) + 35) * a2) ^ v5)) - 4))();
}

uint64_t sub_10004CF90(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,int a36)
{
  uint64_t v36;

  return (*(uint64_t (**)(uint64_t, uint64_t))(v36
                                                     + 8
                                                     * ((((a36 - 1176923337) > 0xFFFFFFFA)
                                                       * (((a3 - 17) | 4) + 26)) ^ (a3 + 492))))(a1, a2);
}

uint64_t sub_10004CFE8(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11)
{
  uint64_t v11;

  return (*(uint64_t (**)(uint64_t, uint64_t))(v11
                                                     + 8
                                                     * ((((a11 - 1176923337) > 0xFFFFFFFA)
                                                       * (((a3 - 17) | 4) + 26)) ^ (a3 + 492))))(a1, a2);
}

void sub_10004D040()
{
  JUMPOUT(0x10004C134);
}

uint64_t sub_10004D064@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7)
{
  int v7;
  uint64_t v8;
  _BOOL4 v9;

  v9 = a7 < 0x9BD38BD4;
  if (v9 == (a1 + 1578770052) < 0x9BD38BD4)
    v9 = a1 + 1578770052 < a7;
  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * ((26 * !v9) | v7)) - ((v7 - 1258) ^ 0x1ELL)))();
}

uint64_t sub_10004D0CC@<X0>(int a1@<W0>, unsigned int a2@<W1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X5>, int a6@<W8>)
{
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  unsigned int v14;
  int v15;
  _BOOL4 v16;

  v13 = a2 < v9;
  *(_BYTE *)(a5 + (v6 + v8)) = a4
                                           + *(_BYTE *)(v12 + (a6 + a1))
                                           - ((2 * *(_BYTE *)(v12 + (a6 + a1))) & 0xFC)
                                           - 24;
  v14 = a6 + 1 + v10;
  v15 = v13 ^ (v14 < v9);
  v16 = v14 < a2;
  if (!v15)
    v13 = v16;
  return ((uint64_t (*)(void))(*(_QWORD *)(v11 + 8 * ((!v13 * a3) ^ v7)) - 8))();
}

uint64_t sub_10004D138(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,int a32,unsigned int a33)
{
  uint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t v36;
  uint64_t v39;

  v39 = (a4 ^ 0x5Eu) * a3;
  v35 = 831981571 * ((v34 - 168) ^ 0x99A1D024);
  *(_QWORD *)(v34 - 160) = a20;
  *(_DWORD *)(v34 - 168) = v35 ^ a13;
  *(_DWORD *)(v34 - 164) = v35 + a4 + 1316;
  sub_10005533C(v34 - 168);
  v36 = STACK[0x2C4] & 0x3F;
  *((_BYTE *)&STACK[0x280] + (v36 ^ 0x15)) = 126;
  return ((uint64_t (*)(uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v33
                                                                                + 8
                                                                                * ((((v36 ^ 0x15) > 0x37)
                                                                                  * (a4 + 1547)) ^ a4))
                                                                    - v39
                                                                    + 1868))(3259404976, 93, a33, 27);
}

uint64_t sub_10004D21C@<X0>(int a1@<W8>)
{
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8 * ((62 * ((((v1 - 1866) ^ (a1 == ((v1 - 1245) ^ 0x24C))) & 1) == 0)) ^ v1))
                            - 12))();
}

uint64_t sub_10004D26C()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((262 * ((v0 ^ 0x2Au) >= ((v1 - 578) ^ 0x39u))) ^ v1)) - 4))();
}

uint64_t sub_10004D2A4@<X0>(unsigned int a1@<W8>, uint64_t a2)
{
  char v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(a2 + a1) = v5;
  return (*(uint64_t (**)(void))(v4 + 8 * ((((v2 & 0x38) == 8) * ((v3 ^ 0x634) - 1115)) ^ v3 ^ 0x634)))();
}

uint64_t sub_10004D2E4()
{
  int v0;
  _QWORD *v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *v1 = v5;
  return (*(uint64_t (**)(void))(v4 + 8 * (((v3 == 0) * v2) ^ v0)))();
}

uint64_t sub_10004D304@<X0>(unsigned int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (int)((((a1 + 1439276644) & 0xAA365F3E ^ 0x10) * (v2 == v1)) ^ a1))
                            - (a1 ^ 0x277)))();
}

uint64_t sub_10004D35C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  char v10;
  uint64_t v11;

  *(_BYTE *)(a6 + v6 + v8) = v10;
  return ((uint64_t (*)(void))(*(_QWORD *)(v11
                                        + 8 * ((((unint64_t)(v6 + 1 + v8) < 0x40) * (v7 ^ v9)) ^ (v7 + 580)))
                            - 4))();
}

void sub_10004D394()
{
  JUMPOUT(0x10004C130);
}

uint64_t sub_10004D3C8()
{
  int v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * ((1590 * ((v2 + 1419 + v0 - 2146397217) < 0x38)) ^ (v2 + 865)))
                            - 4))();
}

uint64_t sub_10004D40C@<X0>(int a1@<W8>)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;

  v4 = v2 + v1 + ((a1 - 1514955843) & 0x5A4C5EB7) - 48;
  if (v4 <= 0x38)
    v4 = 56;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * ((712 * (((a1 - 39) ^ (v4 - v1 + 2146395749 < 8)) & 1)) ^ a1))
                            - 4))();
}

uint64_t sub_10004D480(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  *(_QWORD *)(a10 + v11) = v14;
  return ((uint64_t (*)(void))(*(_QWORD *)(v13
                                        + 8
                                        * ((25
                                          * ((((((v12 ^ 0x19u) - 404) & v10) == 8) ^ ((v12 ^ 0x19) + 1)) & 1)) ^ v12 ^ 0x19))
                            - 4))();
}

uint64_t sub_10004D4DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  unsigned __int8 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v6 + v9) = v11;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * (((((v7 == v9) ^ v8) & 1) * a5) ^ v5)) - 4))();
}

uint64_t sub_10004D508()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((1582 * (((v0 == v1) ^ (v2 - 97)) & 1)) ^ v2))
                            - ((v2 - 865) ^ 0x35)))();
}

uint64_t sub_10004D548@<X0>(uint64_t a1@<X5>, uint64_t a2@<X8>)
{
  int v2;
  uint64_t v3;
  char v4;
  uint64_t v5;

  *(_BYTE *)(a1 + a2 + v3) = v4;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5
                                        + 8
                                        * (((2 * ((unint64_t)(a2 + 1 + v3) < 0x38)) | (8
                                                                                            * ((unint64_t)(a2 + 1 + v3) < 0x38))) ^ (v2 + 865)))
                            - 4))();
}

void sub_10004D57C(uint64_t a1, uint64_t a2, char a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  char v7;
  char v8;
  unsigned int v9;
  unsigned int v10;
  unint64_t v11;
  unsigned int v12;

  v3 = LOBYTE(STACK[0x2E0]) ^ 0xE;
  if (v3 == 1)
  {
    v9 = STACK[0x2C4];
    v10 = STACK[0x2C0];
    LOBYTE(STACK[0x2B8]) = (a3 ^ 0x8A) + ((16 * LOBYTE(STACK[0x2C4])) ^ 0xAF) + ((8 * LOBYTE(STACK[0x2C4])) ^ 0xAA) + 66;
    LOBYTE(STACK[0x2B9]) = ((v9 >> 5) ^ 0x6C) + ((v9 >> 4) & 0xFC ^ 0x27) - 1;
    LOBYTE(STACK[0x2BA]) = ((v9 >> 13) ^ 0x62) + ((v9 >> 12) & 0xFC ^ 0x3B) - 1;
    LOBYTE(STACK[0x2BB]) = ((v9 >> 21) ^ 0x29) - ((2 * ((v9 >> 21) ^ 0x29)) & 0xFC) - 2;
    HIDWORD(v11) = v10 ^ 8;
    LODWORD(v11) = v9;
    LOBYTE(STACK[0x2BC]) = (v11 >> 29) - ((2 * (v11 >> 29)) & 0xFC) - 2;
    LOBYTE(STACK[0x2BD]) = ((v10 >> 5) ^ 0x7C) + ((v10 >> 4) & 0xFC ^ 7) - 1;
    LOBYTE(STACK[0x2BE]) = ((v10 >> 13) ^ 0x21) + ((2 * (((v10 >> 13) ^ 0x21 | 0x7E) ^ (v10 >> 13))) ^ 0x41) - 1;
    v12 = (v10 >> 21) ^ 0xFFFFFFCE;
    v8 = (2 * v12) & 0xFC;
    v7 = v12 - 2;
  }
  else
  {
    if (v3 != 2)
      goto LABEL_6;
    v4 = STACK[0x2C0];
    v5 = STACK[0x2C4];
    LOBYTE(STACK[0x2B8]) = ((-93 * (a3 ^ 0x38)) ^ (LODWORD(STACK[0x2C0]) >> 21) ^ 0x75)
                         - ((2 * ((-93 * (a3 ^ 0x38)) ^ (LODWORD(STACK[0x2C0]) >> 21) ^ 0x75)) & 0xFC)
                         - 2;
    LOBYTE(STACK[0x2B9]) = ((v4 >> 13) ^ 0x21) - ((2 * ((v4 >> 13) ^ 0x21)) & 0xFC) - 2;
    LOBYTE(STACK[0x2BA]) = ((v4 >> 5) ^ 0x7C) - ((2 * ((v4 >> 5) ^ 0x7C)) & 0xFC) - 2;
    HIDWORD(v6) = v4 ^ 8;
    LODWORD(v6) = v5;
    LOBYTE(STACK[0x2BB]) = (v6 >> 29) - ((2 * (v6 >> 29)) & 0xFC) - 2;
    LOBYTE(STACK[0x2BC]) = ((v5 >> 21) ^ 0x29) + ((2 * (((v5 >> 21) ^ 0x29 | 0x7E) ^ (v5 >> 21))) ^ 0x51) - 1;
    LOBYTE(STACK[0x2BD]) = ((v5 >> 13) ^ 0x62) + ((v5 >> 12) & 0xFC ^ 0x3B) - 1;
    LOBYTE(STACK[0x2BE]) = ((v5 >> 5) ^ 0x6C) + ((v5 >> 4) & 0xFC ^ 0x27) - 1;
    LOBYTE(v5) = (8 * v5) ^ 0xA8;
    v7 = v5 - 2;
    v8 = 2 * v5;
  }
  LOBYTE(STACK[0x2BF]) = v7 - v8;
LABEL_6:
  JUMPOUT(0x10004C130);
}

uint64_t sub_10004D7E4@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v3
                                                                                 + 8
                                                                                 * (((((((a2 - 678) ^ 0x29F) - 674) & v2) == 1176923396)
                                                                                   * (((a2 - 678) | 0x30) ^ 0x1E5)) ^ a2))
                                                                     - 4))(a1, 3054478549, 1240488125, 4099281650);
}

uint64_t sub_10004D84C@<X0>(int a1@<W1>, unsigned int a2@<W2>, int a3@<W3>, uint64_t a4@<X5>, uint64_t a5@<X6>, unint64_t a6@<X7>, int a7@<W8>)
{
  int v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  *(_BYTE *)(a4 + (a7 + a3)) = *(_BYTE *)(v10 + (((v7 + a1) & a2 ^ a6) & (v8 + a5)));
  return ((uint64_t (*)(void))(*(_QWORD *)(v11 + 8 * ((57 * (((v8 + 1) & 0xFFFFFFFC) != v9)) ^ v7)) - 4))();
}

uint64_t sub_10004D8A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t (*a16)(uint64_t), uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;

  v22 = 831981571 * (((((v21 - 168) | 0xEC6C17E8) ^ 0xFFFFFFFE) - (~(v21 - 168) | 0x1393E817)) ^ 0x8A323833);
  *(_QWORD *)(v21 - 160) = a20;
  *(_DWORD *)(v21 - 168) = v22 ^ 0x5FF5036A;
  *(_DWORD *)(v21 - 164) = v22 + v20 + 1289;
  v23 = sub_10005533C(v21 - 168);
  return a16(v23);
}

uint64_t sub_10004D90C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,int a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  uint64_t v39;

  if (a34 == 2)
    return (*(uint64_t (**)(uint64_t, uint64_t))(v39
                                                       + 8
                                                       * ((2025
                                                         * (LODWORD(STACK[0x2DC]) != (((a3 + 467) | 0x100) ^ 0x691B65AA))) ^ (a3 + 723))))(a1, 235795823);
  if (a34 == 1)
    return (*(uint64_t (**)(uint64_t, uint64_t))(v39
                                                       + 8
                                                       * ((382
                                                         * (LODWORD(STACK[0x2DC]) == (((a3 + 463) | 0x7A) ^ 0x691B64D4))) ^ (a3 + 585))))(a15, 235795823);
  LOBYTE(STACK[0x2DB]) = ((((unint64_t)&a39 ^ 0x1D7FFF3FEFFF2EE7) - 7 + ((a3 - 113) & (2 * (_QWORD)&a39)) + 32) ^ 0xBA)
                       * (((unint64_t)&a39 ^ 0x1D7FFF3FEFFF2EE7) - 7 + ((a3 - 113) & (2 * (_QWORD)&a39)) + a3);
  return (*(uint64_t (**)(uint64_t, uint64_t))(v39 + 8 * ((a3 + 471) | 0x100)))(a15, 235795823);
}

void sub_10004DC70()
{
  JUMPOUT(0x10004DC44);
}

uint64_t sub_10004DC78@<X0>(int a1@<W1>, int a2@<W8>)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  _QWORD *v8;
  uint64_t result;

  v5 = *(_QWORD *)(v2 + 24);
  v6 = *(_QWORD *)(v2 + 8);
  *(_QWORD *)(v3 - 204) = 0xFEFEFEFEFEFEFEFELL;
  *(_QWORD *)(v3 - 196) = 0xFEFEFEFEFEFEFEFELL;
  v7 = ((v3 - 168) ^ 0x94AD4959) * a1;
  v8 = (_QWORD *)(v3 - 168);
  v8[5] = v3 - 204;
  *v8 = v5;
  v8[2] = v3 - 188;
  v8[3] = v6;
  *(_DWORD *)(v3 - 132) = (a2 + 1889) ^ v7;
  *(_DWORD *)(v3 - 160) = v7 + 2046750649;
  result = ((uint64_t (*)(uint64_t))(*(_QWORD *)(v4 + 8 * (a2 | 0x48)) - 8))(v3 - 168);
  *(_DWORD *)(v2 + 40) = *(_DWORD *)(v3 - 136);
  return result;
}

void sub_10004DD38(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 8) - 268847287 * ((((2 * a1) | 0x834EB920) - a1 - 1101487248) ^ 0xBE0D4DB8);
  __asm { BR              X10 }
}

uint64_t sub_10004DE04@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v2
                              + 8
                              * (((*(_QWORD *)(v1 + 16) == 0)
                                * ((a1 & 0x7AE091B7 ^ 0x516) + (a1 & 0x7AE091B7 ^ 0x11) - 772)) ^ a1 & 0x7AE091B7)))();
}

uint64_t sub_10004DE88@<X0>(int a1@<W8>)
{
  uint64_t (*v1)(uint64_t *);
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t result;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  int v12;

  v6 = (((&v8 | 0x2E438E06) - (&v8 & 0x2E438E06)) ^ 0x5096ABF0) * v2;
  v11 = 0x118C242060FB2D82;
  v12 = (v3 - 794) ^ v6;
  v8 = v5;
  v9 = v6 ^ a1;
  v10 = v6 ^ 0x49D399AF;
  result = v1(&v8);
  *(_DWORD *)(v4 + 24) = *(_DWORD *)(v5 - 0x56428495FB6297ALL);
  return result;
}

void sub_10004E148(_DWORD *a1)
{
  unsigned int v1;

  v1 = (*a1
      + 1224239923 * (((a1 | 0xA81C68C2) - (_DWORD)a1 + (a1 & 0x57E3973D)) ^ 0x5AAF9515)) ^ 0x436;
  __asm { BR              X6 }
}

uint64_t sub_10004E2F0(uint64_t a1, uint64_t a2, int a3, unsigned int a4, unint64_t a5, int a6)
{
  int v6;
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * (((v6 - 242) | v7) ^ ((8 * (a6 == 31)) | ((a6 == 31) << 9))))
                            - ((((v6 - 242) | v7) + a3) & a4 ^ a5)))();
}

void sub_10004E358()
{
  JUMPOUT(0x10004E2C8);
}

uint64_t sub_10004E360(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t v27;

  v23 = a8 - 162;
  *(_DWORD *)(a10 - 0x73495CDCA303A980) = 1676444741 - v18;
  v24 = v19 << (((a8 + 94) ^ 0x1C) - 58);
  v25 = 831981571 * ((((v22 - 136) | 0x1D8DD29A) - (v22 - 136) + ((v22 - 136) & 0xE2722D60)) ^ 0x842C02BE);
  *(_QWORD *)(v22 - 136) = a12;
  *(_DWORD *)(v22 - 128) = a8 - 162 - v25 - 1109;
  *(_DWORD *)(v22 - 124) = v25 + 376798310;
  sub_1000548E8(v22 - 136);
  v26 = 3804331 * (((v22 - 136) & 0xBBAC2B3F | ~((v22 - 136) | 0xBBAC2B3F)) ^ 0x3A86F136);
  *(_DWORD *)(v22 - 128) = v26 + v23 + 573;
  *(_DWORD *)(v22 - 124) = ((v19 << 6) & 0xBF6D79C0) - v26 + (v24 ^ (((8 * v23) ^ 0x2E38) + 1605809624)) - 9601184;
  *(_QWORD *)(v22 - 136) = a12;
  sub_100034614(v22 - 136);
  *(_DWORD *)(v22 - 128) = v23
                         + 831981571 * (((v22 - 136) & 0x2C0498D9 | ~((v22 - 136) | 0x2C0498D9)) ^ 0x4A5AB702)
                         - 971;
  *(_QWORD *)(v22 - 136) = a18;
  *(_QWORD *)(v22 - 120) = &STACK[0x2DB44D49A49B007E];
  sub_10004F498(v22 - 136);
  *(_DWORD *)(v22 - 112) = (v23 + 145) ^ (69008221
                                        * (((v22 - 136) & 0xDFB6986 | ~((v22 - 136) | 0xDFB6986)) ^ 0x21A6C473));
  *(_QWORD *)(v22 - 136) = a12;
  *(_QWORD *)(v22 - 120) = a18;
  v27 = ((uint64_t (*)(uint64_t))(*(_QWORD *)(v21 + 8 * (v23 - 1098)) - 8))(v22 - 136);
  return (*(uint64_t (**)(uint64_t))(v20 + 8 * ((100 * (*(_DWORD *)(v22 - 128) > 0x9B59335u)) ^ v23)))(v27);
}

uint64_t sub_10004E59C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  *(_QWORD *)(v20 - 136) = v18;
  *(_QWORD *)(v20 - 120) = a17;
  *(_DWORD *)(v20 - 128) = v17
                         + 831981571 * (((v20 - 136) & 0xF66E908A | ~((v20 - 136) | 0xF66E908A)) ^ 0x9030BF51)
                         + 25;
  v21 = sub_10004F498(v20 - 136);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v19
                                                      + 8
                                                      * (((((a12 < 1) ^ (v17 + 2)) & 1)
                                                        * ((211 * (v17 ^ 0x138)) ^ 0x5B3)) ^ v17))
                                          - 12))(v21);
}

uint64_t sub_10004E654@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  int v3;
  uint64_t v4;
  int v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((1576
                                          * (((((a1 << ((v5 - 114) & 0xED ^ 0xC4)) ^ v3)
                                             + v2
                                             - (v3 & (2 * ((a1 << ((v5 - 114) & 0xED ^ 0xC4)) ^ v3)))) ^ v2) > v1)) ^ v5))
                            - 12))();
}

uint64_t sub_10004E6AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t (*a17)(uint64_t), uint64_t a18)
{
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;

  *(_QWORD *)(v19 - 120) = a15;
  *(_DWORD *)(v19 - 128) = v18
                         + 831981571
                         * ((-882225999 - ((v19 - 136) | 0xCB6A4CB1) + ((v19 - 136) | 0x3495B34E)) ^ 0xAD34636A)
                         - 1133;
  *(_QWORD *)(v19 - 136) = a18;
  sub_10004F498(v19 - 136);
  v20 = 3804331 * (((v19 - 136) & 0xE7895B79 | ~((v19 - 136) | 0xE7895B79)) ^ 0x66A38170);
  *(_QWORD *)(v19 - 136) = a16;
  *(_DWORD *)(v19 - 128) = v20 + v18 + 411;
  *(_DWORD *)(v19 - 124) = 1596210265 - v20;
  sub_100034614(v19 - 136);
  *(_QWORD *)(v19 - 120) = a18;
  *(_QWORD *)(v19 - 136) = a16;
  *(_DWORD *)(v19 - 112) = (v18 - 17) ^ (69008221
                                       * (((v19 - 136) & 0xDA783752 | ~((v19 - 136) | 0xDA783752)) ^ 0xF6259AA7));
  v21 = a17(v19 - 136);
  return (*(uint64_t (**)(uint64_t))(a14
                                            + 8
                                            * (((*(_DWORD *)(v19 - 128) > 0x9B59335u)
                                              * ((((v18 - 314) | 0x40) + 200) ^ 0x5AD)) ^ (v18 - 1264))))(v21);
}

uint64_t sub_10004EB20(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12)
{
  uint64_t v12;
  int v13;

  return ((uint64_t (*)(void))(*(_QWORD *)(v12
                                        + 8
                                        * ((89
                                          * ((a12 ^ 0x3B8EED9A)
                                           - 41992192
                                           + ((a12 << (((v13 - 79) | 0x81) + 60)) & 0x771DDB34)
                                           + (((v13 - 771) | 0x121) ^ 0xC6F1D1D5) < 0x7FFFFFFE)) ^ v13))
                            - 12))();
}

uint64_t sub_10004F498(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 8) - 831981571 * ((2 * (a1 & 0x1F062D56) - a1 - 520498519) ^ 0x7958028D);
  return (*(uint64_t (**)(void))((char *)*(&off_100180420 + v1 - 270)
                              + 8
                              * (int)(((*(_QWORD *)a1 != *(_QWORD *)(a1 + 16)) * ((v1 + 1362194087) & 0xAECE913A ^ 0x46E)) ^ v1)
                              - 4))();
}

uint64_t sub_10004F528@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  v4 = *(_DWORD *)(v2 - 0x2DB44D49A49B002ALL);
  v5 = v4 - 237901512;
  if (v4 - 237901512 < 0)
    v5 = 237901512 - v4;
  *(_DWORD *)(v1 - 0x2DB44D49A49B002ALL) = v4;
  return (*(uint64_t (**)(void))(a1
                              + 8
                              * ((98
                                * ((v5 ^ 0xFFDBFFDF) + 1588531711 + ((46 * (v3 ^ 0x125) - 4720084) & (2 * v5)) == ((v3 - 66249692) & 0x3F2E3F9 ^ 0x5E8B1086))) ^ v3)))();
}

uint64_t sub_10004F5D8@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;

  *(_DWORD *)(*(_QWORD *)(v1 - 0x2DB44D49A49B0026) + 4 * (v5 - 1586172383)) = *(_DWORD *)(*(_QWORD *)(v2 - 0x2DB44D49A49B0026)
                                                                                            + 4 * (v5 - 1586172383));
  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * ((974 * (v5 + 8 * (v3 ^ 0x5B9) - 345 == v4 + 344)) ^ v3)) - 8))();
}

void sub_10004F644()
{
  JUMPOUT(0x10004F608);
}

void sub_10004F64C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 24) + 1543737703 * (((a1 | 0xC7921CD6) - (a1 & 0xC7921CD6)) ^ 0xB9664CAA);
  __asm { BR              X10 }
}

uint64_t sub_10004F70C@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (int)((((((a1 ^ 0x5A3) - 1379) ^ 0xFFFFFFD3) + (a1 ^ 0x5A3) - 1379) * (v2 == 0)) ^ a1 ^ 0x5A3))
                            - 12))();
}

uint64_t sub_10004F74C@<X0>(uint64_t (*a1)(uint64_t *)@<X8>)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  int v11;

  v4 = v1 - 345;
  v5 = 3804331 * ((2 * (&v7 & 0x3A058450) - &v7 - 973440084) ^ 0xBB2F5E5A);
  v11 = v4 ^ v5;
  v7 = v3;
  v10 = 0x118C242060FB2D82;
  v8 = v5 ^ 0xC6EE6959;
  v9 = v5 ^ 0x49D399AF;
  result = a1(&v7);
  *(_DWORD *)(v2 + 8) = *(_DWORD *)(v3 - 0x56428495FB6297ALL);
  return result;
}

void sub_10004FD30(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  int v11;

  if (a5)
    v8 = a6 == 0;
  else
    v8 = 1;
  v11 = !v8 && a7 != 0 && a8 != 0;
  __asm { BR              X9 }
}

uint64_t sub_10004FDBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, _DWORD *a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,unsigned int a22)
{
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v26;

  *a5 = 0;
  *a6 = 0;
  a22 = 1178560073 * (((&a21 | 0xD492092) - (&a21 & 0xD492092)) ^ 0xEA7C02FA) - 1501685844;
  v26 = v22;
  v24 = sub_100074AF8(&a21);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v26 + 8 * ((60 * (a21 != v23)) ^ 0x154u)) - 8))(v24);
}

uint64_t sub_10004FE6C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,unint64_t *a21,unsigned int a22,int a23)
{
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;

  a21 = &STACK[0x82D647BA4E6A019];
  a22 = (831981571 * (&a21 ^ 0x99A1D024)) ^ 0x87;
  sub_1000344DC((uint64_t)&a21);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a14 + 8 * ((1337 * (a23 == 489733862)) ^ 0x168u)) - (v25 ^ 0x42E2F00D)))(v26, v27, v28, v29, v30, v31, v32, v33, a9, v24, v23, a12, a13);
}

uint64_t sub_10004FF08(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23)
{
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  int v30;
  int v31;
  unint64_t v32;
  void (*v33)(uint64_t *);
  unint64_t v34;
  uint64_t v35;

  v29 = v28 + 555;
  v30 = 1224239923 * ((v23 & 0x2790CF84 | ~(v23 | 0x2790CF84)) ^ 0x2ADCCDAC);
  LODWORD(a23) = (v29 + 17) ^ v30;
  LODWORD(a21) = v27 - ((2 * v27) & 0xDE3BA25A) - 283258579 - v30;
  a22 = a19;
  sub_10004A21C((uint64_t)&a21);
  v31 = 1224239923 * ((((2 * v23) | 0x97CE40C2) - v23 + 874045343) ^ 0x3954DDB6);
  a22 = a19;
  LODWORD(a21) = v26 - v31 - 283258579 - ((v29 - 566518073) & (2 * v26));
  LODWORD(a23) = (v29 + 17) ^ v31;
  sub_10004A21C((uint64_t)&a21);
  v32 = 831981571 * ((v23 - 2 * (v23 & 0x26717E1E77E9F691) + 0x26717E1E77E9F691) ^ 0xF7813F5EEE4826B5);
  LODWORD(a22) = (v29 - 489) ^ v32;
  a23 = a19;
  a21 = ((((v29 - 1545887274) & 0xBFE) + 0x62D8807FC884E355) * v25 + 0x6F7458225064C1BDLL) ^ v32;
  v33 = (void (*)(uint64_t *))((char *)*(&off_100180420 + (int)(v29 - 776)) - 4);
  v33(&a21);
  v34 = 831981571 * ((-2 - ((~v23 | 0x54A2F2BB4CFCE4EBLL) + (v23 | 0xAB5D0D44B3031B14))) ^ 0x8552B3FBD55D34CFLL);
  a23 = a19;
  a21 = v34 ^ (0x62D8807FC884E4BDLL * v24 + 0x6F7458225064C1BDLL);
  LODWORD(a22) = (v29 - 489) ^ v34;
  v35 = ((uint64_t (*)(uint64_t *))v33)(&a21);
  return (*(uint64_t (**)(uint64_t))(a14 + 8 * ((1762 * (HIDWORD(a22) == 489733862)) ^ v29)))(v35);
}

uint64_t sub_100050150(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, int a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,int a22,int a23,int a24,uint64_t a25,unint64_t *a26,int a27)
{
  int v27;
  unsigned int v28;
  uint64_t v29;

  v28 = 1224239923 * ((((2 * &a22) | 0xA63C9F70) - &a22 - 1394495416) ^ 0xA1ADB26F);
  a25 = a20;
  a26 = &STACK[0x72F2C1D3322B8818];
  a23 = (a10 + 368399352) ^ v28;
  a24 = v28 ^ 0x2705443;
  a22 = v28 ^ 0x12B6892A;
  v29 = sub_100074BB8((uint64_t)&a22);
  return (*(uint64_t (**)(uint64_t))(a15 + 8 * (((a27 != v27) * ((a10 ^ 0x251) - 190)) ^ a10)))(v29);
}

uint64_t sub_100050210(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unint64_t *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,unint64_t *a21,unint64_t *a22,unint64_t *a23,unint64_t *a24)
{
  int v24;
  uint64_t v25;
  int v26;
  uint64_t v27;

  v26 = v24 + 186;
  LODWORD(a21) = v26 - 2078219279 * (&a21 ^ 0xDAFA9674) - 231789336;
  a23 = &STACK[0x20BA795F69D3FF5];
  a24 = a15;
  a22 = &STACK[0x7F1325F673F67EAF];
  sub_1000751F8((uint64_t)&a21);
  LODWORD(a22) = v26
               + 3804331
               * ((-1325552261 - (&a21 | 0xB0FDAD7B) + (&a21 | 0x4F025284)) ^ 0x31D77772)
               + 371;
  a21 = &STACK[0x1CAC648E56C35109];
  a23 = a15;
  a24 = &STACK[0x5B1E97A52371A255];
  (*(void (**)(unint64_t **))(v25 + 8 * (int)(v26 & 0xE89FE81F)))(&a21);
  LODWORD(a23) = v26 - 944348131 * (&a21 ^ 0xA319A44E) - 28;
  a21 = &STACK[0x20BA795F69D3FF1];
  a22 = a15;
  ((void (*)(unint64_t **))(*(_QWORD *)(v25 + 8 * (v26 - 312)) - 8))(&a21);
  LODWORD(a22) = v26
               - 241568881 * ((2 * (&a21 & 0x36C70448) - &a21 + 1228471220) ^ 0x9F29FFF6)
               + 36;
  a21 = a15;
  v27 = sub_10005A5D8((uint64_t)&a21);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(a14
                                                      + 8
                                                      * ((1466 * (HIDWORD(a22) == ((v26 - 34) | 0x21) + 489733317)) ^ v26))
                                          - ((305 * (v26 ^ 0x221u)) ^ 0x397)))(v27);
}

uint64_t sub_100050410(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17)
{
  uint64_t v17;
  int v18;
  int v19;

  return ((uint64_t (*)(void))(*(_QWORD *)(v17
                                        + 8
                                        * (((((a17 == v18) ^ (31 * (v19 ^ 0x30))) & 1)
                                          * (305 * (v19 ^ 0x222) - 912)) ^ v19))
                            - 4))();
}

uint64_t sub_10005045C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, int a8@<W8>, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17)
{
  int v17;
  uint64_t v18;
  int v19;
  int v20;

  v20 = (v17 ^ 0x1EF) + (a17 ^ v19) - ((((v17 - 527) | a8) ^ 0x2E4F229C) & (2 * (a17 ^ v19))) - 1759015809;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v18 + 8 * ((1717 * (((2 * v20) & 0xABDFB9C6 ^ 0x2A4F2086) + (v20 ^ 0x42C84CBC) + 1862005726 != 1156305089)) ^ v17)) - 4))(a1, a2, a3, a4, a5, a6, a7, 489733862);
}

uint64_t sub_100050500()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (((v1 ^ 0x404) * ((v2 + v0 + 705700637) > 7)) ^ v1))
                            - 8))();
}

uint64_t sub_100050564()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((1068 * (v0 - v5 >= ((v2 - v1 - 992) ^ (v3 + 2175) ^ 0x709uLL))) ^ v2))
                            - 8))();
}

uint64_t sub_1000505A4(uint64_t a1, int a2)
{
  unsigned int v2;
  int v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * ((111 * (v2 < 352 * ((a2 - 152637386) & 0x4BFBF8AD ^ (v3 + 356)) - 1376)) ^ a2)))();
}

uint64_t sub_1000505F0()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;

  v8 = v3 + ((v5 + 1731978106) & 0x55E12E7F ^ (v2 - 517));
  v9 = *(_OWORD *)(v0 + v8 - 15);
  v10 = *(_OWORD *)(v0 + v8 - 31);
  v11 = v7 + v8;
  *(_OWORD *)(v11 - 15) = v9;
  *(_OWORD *)(v11 - 31) = v10;
  return (*(uint64_t (**)(void))(v6 + 8 * ((549 * ((v4 & 0xFFFFFFE0) == 32)) ^ (v1 + v5 + 334))))();
}

void sub_10005065C()
{
  JUMPOUT(0x100050620);
}

uint64_t sub_100050668()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((((v2 - 360) ^ 0x2B5 ^ ((v2 - 5) | 0x20)) * (v0 == v1)) ^ v2))
                            - 4))();
}

uint64_t sub_10005069C(uint64_t a1, int a2)
{
  int v2;
  char v3;
  int v4;
  uint64_t v5;
  _BOOL4 v6;

  v6 = (v3 & 0x18) == ((a2 + 1249) ^ (v4 + 1768)) + v2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * (((4 * v6) | (32 * v6)) ^ a2)) - 4))();
}

uint64_t sub_1000506D4(int a1)
{
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)(v7 - 7 + (v3 + v2 - v5)) = *(_QWORD *)(v1 - 7 + (v3 + v2 - v5));
  return ((uint64_t (*)(void))(*(_QWORD *)(v6
                                        + 8
                                        * ((1018 * ((((a1 - 1391) | 0xAA) ^ 0xB3) + v5 == (v4 & 0xFFFFFFF8))) ^ a1))
                            - 4))();
}

uint64_t sub_100050730(uint64_t a1, int a2, int a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * ((((v3 + (a3 ^ (v5 + 529)) + 546) ^ 0x96) * (v4 == a2)) ^ a3)) - 4))();
}

uint64_t sub_100050764()
{
  int v0;
  uint64_t v1;
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;

  *(_BYTE *)(v7 + (v5 + v3)) = *(_BYTE *)(v1 + (v5 + v3));
  return ((uint64_t (*)(void))(*(_QWORD *)(v6
                                        + 8 * (((v5 - 1 == v0) * (((v2 + v4 + 512) | 0x22) - 493)) ^ (v2 + v4 + 1238)))
                            - 8))();
}

uint64_t sub_1000507A8@<X0>(int a1@<W7>, unsigned int a2@<W8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int *a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12)
{
  int v12;
  uint64_t v13;

  *a7 = (a2 >> 2) ^ 0x74C2FB9;
  return ((uint64_t (*)(void))(*(_QWORD *)(v13 + 8 * ((421 * (a12 != a1)) ^ v12)) - (v12 + 369) + 911))();
}

uint64_t sub_1000507F8@<X0>(unsigned int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7;
  int v8;
  uint64_t v9;
  uint64_t (*v10)(void);

  v10 = (uint64_t (*)(void))(*(_QWORD *)(a7
                                      + 8
                                      * ((7
                                        * ((((*(uint64_t (**)(_QWORD, uint64_t))(v9 + 8 * (v7 ^ 0x2C0)))((v8 + v7 - 26 - 520) ^ a1, 51302153) == 0) ^ (v7 - 17)) & 1)) ^ v7))- 4);
  return v10();
}

uint64_t sub_100050860(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, int a18)
{
  int v18;
  int v19;
  uint64_t v20;
  int v21;

  v21 = (a18 ^ v19) - (((v18 ^ 0x2F0) - 384927878) & (2 * (a18 ^ v19))) - 192463815;
  return ((uint64_t (*)(void))(*(_QWORD *)(v20
                                        + 8
                                        * ((143
                                          * ((((6 * (v18 ^ 0x2F0)) ^ 0xDFBCBA2E) & (2 * v21) ^ 0xC90C3872)
                                           + (v21 ^ 0x1B5963C6)
                                           + 1513619417 != 1242980312)) ^ v18))
                            - 4))();
}

uint64_t sub_1000508F8()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (v2 ^ (62 * ((v1 + v0 + 270639105) > 7))))
                            - ((((v2 + 39905848) | 0x40820005u) - 1122168018) ^ 0x337)))();
}

uint64_t sub_100050988(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;

  return (*(uint64_t (**)(void))(v9
                              + 8
                              * (((v8 - a1 >= (a4 ^ (a8 + 1169) ^ (unint64_t)(a6 + 40)))
                                * (((a4 - 517) | 0x680) - 1852)) ^ a4)))();
}

uint64_t sub_1000509C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6)
{
  unsigned int v6;
  uint64_t v7;

  return ((uint64_t (*)(void))(a6
                            + *(_QWORD *)(v7 + 8 * (((a5 ^ 0x7E4) * (v6 > 0x1F)) ^ a5))
                            - ((a5 + 1995172713) & 0xCBF6FCED)
                            - 4))();
}

uint64_t sub_100050A18(uint64_t a1, int a2)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int8x16_t v8;
  uint64_t v9;
  int8x16_t v10;
  int8x16_t v11;
  uint64_t v12;

  v8.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v8.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v9 = (v6 + v4);
  v10 = *(int8x16_t *)(v2 + v9 - 15);
  v11 = *(int8x16_t *)(v2 + v9 - 31);
  v12 = a1 + v9;
  *(int8x16_t *)(v12 - 15) = veorq_s8(v10, v8);
  *(int8x16_t *)(v12 - 31) = veorq_s8(v11, v8);
  return (*(uint64_t (**)(void))(v7
                              + 8
                              * ((1991 * (((a2 + 405390958) & 0xA4F34B8E ^ 0x22A) == (v5 & 0xFFFFFFE0))) ^ (v3 + a2 + 369))))();
}

uint64_t sub_100050A98(uint64_t a1)
{
  int v1;
  int v2;
  void (*v3)(unsigned int *);
  int v4;
  _QWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;

  v4 = 5 * ((v2 + 298) ^ 0x295);
  *v6 = a1;
  *v7 = v1;
  v11 = v8;
  v10 = (v4 - 763) ^ (69008221 * ((&v10 & 0x5AEC8B8A | ~(&v10 | 0x5AEC8B8A)) ^ 0x76B1267F));
  v3(&v10);
  v11 = v9;
  v10 = (v4 - 763) ^ (69008221 * (&v10 ^ 0xD3A2520A));
  v3(&v10);
  return 0;
}

void sub_100050D1C(uint64_t a1)
{
  int v1;

  v1 = 3804331 * ((-2 - ((a1 | 0xD3EE21B) + (~(_DWORD)a1 | 0xF2C11DE4))) ^ 0x8C143812);
  __asm { BR              X15 }
}

uint64_t sub_100050DF0@<X0>(int a1@<W8>)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  unsigned int v6;
  _DWORD v8[2];
  uint64_t v9;

  v6 = ((2 * (v8 & 0x3297F1E8) - v8 - 848818670) ^ 0xB3BD2BE4) * v2;
  v9 = v3;
  v8[0] = a1 - ((v4 + 436934364) & 0xED5F0690) - v6 + v5 - 2085288292;
  v8[1] = v6 + v5 - 377 - 1180;
  return (*(uint64_t (**)(_DWORD *))(v1 + 8 * ((v5 - 377) ^ 0x69D)))(v8);
}

void sub_100050F34(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  unint64_t *v5;
  unsigned int v6;
  unsigned int v7;

  **(_DWORD **)(a1 + 96) = *(_DWORD *)(a2 + 16);
  v3 = 235795823
     * (((&v5 | 0xD878EB21) - &v5 + (&v5 & 0x278714D8)) ^ 0x4CD5A278);
  v5 = &STACK[0x73F39308AC2F3883];
  v6 = v3 ^ 0xFE0643CC;
  v7 = v3 + 426523017;
  sub_10002D8CC((uint64_t)&v5);
  __asm { BR              X9 }
}

uint64_t sub_1000510DC()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  unsigned int v5;

  v5 = v0 - 2011786153;
  if (v5 <= 0x40)
    v5 = 64;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v3 + 8 * ((7 * (v4 - v2 - v1 + v5 < 0xF)) ^ 0x6A9u)) - 4))(2891363383);
}

uint64_t sub_10005114C()
{
  int v0;
  int v1;
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  _BOOL4 v9;

  v7 = v0 + v1;
  v8 = v7 - 2011786153;
  if ((v7 - 2011786153) <= 0x40)
    v8 = v4;
  v9 = v6 - v7 >= (v3 + v6 + v2 + v8);
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((4 * v9) | (8 * v9) | 0x193u)) - 12))();
}

uint64_t sub_1000511A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  int v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;

  return ((uint64_t (*)(void))(*(_QWORD *)(v17
                                        + 8
                                        * (((a14 + v18 - 220 + (unint64_t)(v16 + v14 + 1283) >= ((899 * (v15 ^ 0x191)) ^ 0x716uLL))
                                          * ((v15 + 258182003) & 0x7FD ^ 0x11A)) ^ v15))
                            - 12))();
}

uint64_t sub_100051208@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, int a9@<W8>)
{
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  int8x16_t *v13;
  int8x16_t v14;
  int8x16_t v15;

  v14.i64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v14.i64[1] = 0xFCFCFCFCFCFCFCFCLL;
  v15.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v15.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  *(int8x16_t *)(v10 + (a3 + a9)) = vaddq_s8(vsubq_s8(*v13, vandq_s8(vaddq_s8(*v13, *v13), v14)), v15);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v12 + 8 * ((501 * ((v11 ^ 0x695u) - 387 != ((v9 + 1) & 0x1FFFFFFF0))) ^ v11 ^ 0x1F5u)) - 4))(a1, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t sub_100051290(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6
                                                                        + 8
                                                                        * ((((v5 + 881) ^ 0x56D) * (v3 == v4)) ^ v5))
                                                            - ((v5 - 201324115) & 0xFF4FF)
                                                            + 52))(a1, a2, v2);
}

uint64_t sub_1000512DC(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int32x4_t a29,int32x4_t a30,int32x4_t a31,int32x4_t a32)
{
  int v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t (*v40)(__n128, __n128, __n128, __n128, __n128);
  const char *v41;
  __n128 v42;
  __n128 v43;
  __n128 v44;
  __n128 v45;
  __n128 v46;
  int v47;
  int v48;
  int v49;
  int v50;
  uint8x16_t v51;
  uint16x8_t v52;
  int8x16_t v53;
  int8x16_t v54;
  uint16x8_t v55;
  int8x16_t v56;
  int8x16_t v57;
  uint8x16_t v58;
  uint16x8_t v59;
  uint16x8_t v60;
  uint8x16_t v61;
  int8x16_t v64;
  int8x16_t v69;
  int32x4_t v70;
  int32x4_t v71;
  int32x4_t v72;
  int32x4_t v73;
  uint8x16_t v75;
  uint16x8_t v76;
  uint16x8_t v77;
  uint8x16_t v78;
  uint8x16_t v83;
  uint16x8_t v84;
  uint16x8_t v85;
  int32x4_t v86;
  int32x4_t v87;
  int32x4_t v88;
  int32x4_t v89;
  _DWORD *v90;
  int v91;
  int v92;
  unint64_t v93;
  int8x16x4_t v94;
  int8x16x4_t v95;

  v40 = (uint64_t (*)(__n128, __n128, __n128, __n128, __n128))(*(_QWORD *)(v33 + 8 * v32) - 4);
  v41 = (const char *)(v39 - 220);
  v42 = (__n128)vdupq_n_s32(0x1D30BEEEu);
  v43 = (__n128)vdupq_n_s32(0x1D30BEE6u);
  v44.n128_u64[0] = 0xFEFEFEFEFEFEFEFELL;
  v44.n128_u64[1] = 0xFEFEFEFEFEFEFEFELL;
  a21 = v38 - 16;
  v45.n128_u64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v45.n128_u64[1] = 0xFCFCFCFCFCFCFCFCLL;
  v46 = (__n128)vdupq_n_s32(0x1D30BEFFu);
  v47 = *(_DWORD *)(v39 - 144);
  v49 = *(_DWORD *)(v39 - 140);
  v48 = *(_DWORD *)(v39 - 136);
  v50 = *(_BYTE *)(v39 - 124) ^ 0xE;
  if (v50 == 2)
  {
    v95 = vld4q_s8(v41);
    v75 = (uint8x16_t)veorq_s8(v95.val[0], (int8x16_t)v44);
    v76 = vmovl_u8(*(uint8x8_t *)v75.i8);
    v77 = vmovl_high_u8(v75);
    v78 = (uint8x16_t)veorq_s8(v95.val[1], (int8x16_t)v44);
    _Q22 = vmovl_u8(*(uint8x8_t *)v78.i8);
    _Q21 = vmovl_high_u8(v78);
    __asm
    {
      SHLL2           V23.4S, V21.8H, #0x10
      SHLL2           V24.4S, V22.8H, #0x10
    }
    v83 = (uint8x16_t)veorq_s8(v95.val[2], (int8x16_t)v44);
    v84 = vmovl_high_u8(v83);
    v85 = vmovl_u8(*(uint8x8_t *)v83.i8);
    v95.val[0] = veorq_s8(v95.val[3], (int8x16_t)v44);
    v95.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v95.val[0]);
    v95.val[2] = (int8x16_t)vmovl_high_u16((uint16x8_t)v95.val[1]);
    v95.val[1] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v95.val[1].i8);
    v95.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v95.val[0].i8);
    v95.val[3] = (int8x16_t)vmovl_high_u16((uint16x8_t)v95.val[0]);
    v95.val[0] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v95.val[0].i8);
    v86 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q22.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v85.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v76.i8), 0x18uLL)), v95.val[0]);
    v87 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8(_Q24, (int8x16_t)vshll_high_n_u16(v85, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v76), 0x18uLL)), v95.val[3]);
    v88 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q21.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v84.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v77.i8), 0x18uLL)), v95.val[1]);
    v89 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8(_Q23, (int8x16_t)vshll_high_n_u16(v84, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v77), 0x18uLL)), v95.val[2]);
    v95.val[0] = veorq_s8(vandq_s8((int8x16_t)v86, (int8x16_t)v42), (int8x16_t)(*(_OWORD *)v95.val & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v95.val[3] = veorq_s8(vandq_s8((int8x16_t)v87, (int8x16_t)v42), (int8x16_t)(*(_OWORD *)&v95.val[3] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v95.val[1] = veorq_s8(vandq_s8((int8x16_t)v88, (int8x16_t)v42), (int8x16_t)(*(_OWORD *)&v95.val[1] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v95.val[2] = veorq_s8(vandq_s8((int8x16_t)v89, (int8x16_t)v42), (int8x16_t)(*(_OWORD *)&v95.val[2] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    a31 = vaddq_s32(vsubq_s32(v88, vaddq_s32((int32x4_t)v95.val[1], (int32x4_t)v95.val[1])), (int32x4_t)v43);
    a32 = vaddq_s32(vsubq_s32(v89, vaddq_s32((int32x4_t)v95.val[2], (int32x4_t)v95.val[2])), (int32x4_t)v43);
    a29 = vaddq_s32(vsubq_s32(v86, vaddq_s32((int32x4_t)v95.val[0], (int32x4_t)v95.val[0])), (int32x4_t)v43);
    a30 = vaddq_s32(vsubq_s32(v87, vaddq_s32((int32x4_t)v95.val[3], (int32x4_t)v95.val[3])), (int32x4_t)v43);
    v90 = (_DWORD *)&a29 + v37 + 1138821655;
    v91 = *(v90 - 8) ^ *(v90 - 3);
    v92 = *(v90 - 16) ^ *(v90 - 14) ^ (v91 + v35 - ((v91 << ((a7 + a2 - 114) ^ 0xDC)) & 0x3A617DCC));
    HIDWORD(v93) = v92 ^ v35;
    LODWORD(v93) = v92;
    *v90 = (v93 >> 31) + v35 - ((2 * (v93 >> 31)) & 0x3A617DCC);
    return (*(uint64_t (**)(uint64_t))(v33 + 8 * ((571 * (v38 == 1138821592)) ^ (a7 + a2 + 1174))))(a21);
  }
  else if (v50 == 1)
  {
    v94 = vld4q_s8(v41);
    v51 = (uint8x16_t)veorq_s8(v94.val[0], (int8x16_t)v44);
    v52 = vmovl_u8(*(uint8x8_t *)v51.i8);
    v53 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v52.i8);
    v54 = (int8x16_t)vmovl_high_u16(v52);
    v55 = vmovl_high_u8(v51);
    v56 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v55.i8);
    v57 = (int8x16_t)vmovl_high_u16(v55);
    v58 = (uint8x16_t)veorq_s8(v94.val[1], (int8x16_t)v44);
    v59 = vmovl_high_u8(v58);
    v60 = vmovl_u8(*(uint8x8_t *)v58.i8);
    v61 = (uint8x16_t)veorq_s8(v94.val[2], (int8x16_t)v44);
    _Q26 = (int8x16_t)vmovl_high_u8(v61);
    _Q25 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v61.i8);
    v64 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q25.i8, 0x10uLL);
    __asm { SHLL2           V25.4S, V25.8H, #0x10 }
    v69 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q26.i8, 0x10uLL);
    __asm { SHLL2           V26.4S, V26.8H, #0x10 }
    v94.val[0] = veorq_s8(v94.val[3], (int8x16_t)v44);
    v94.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v94.val[0]);
    v94.val[2] = (int8x16_t)vmovl_high_u16((uint16x8_t)v94.val[1]);
    v94.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v94.val[0].i8);
    v94.val[3] = (int8x16_t)vmovl_high_u16((uint16x8_t)v94.val[0]);
    v94.val[0] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v94.val[0].i8), 0x18uLL), v64), vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v60.i8, 8uLL), v53));
    v94.val[3] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)v94.val[3], 0x18uLL), _Q25), vorrq_s8((int8x16_t)vshll_high_n_u16(v60, 8uLL), v54));
    v94.val[1] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v94.val[1].i8), 0x18uLL), v69), vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v59.i8, 8uLL), v56));
    v94.val[2] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)v94.val[2], 0x18uLL), _Q26), vorrq_s8((int8x16_t)vshll_high_n_u16(v59, 8uLL), v57));
    v70 = (int32x4_t)veorq_s8(vandq_s8(v94.val[0], (int8x16_t)v46), (int8x16_t)(*(_OWORD *)&v53 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v71 = (int32x4_t)veorq_s8(vandq_s8(v94.val[3], (int8x16_t)v46), (int8x16_t)(*(_OWORD *)&v54 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v72 = (int32x4_t)veorq_s8(vandq_s8(v94.val[1], (int8x16_t)v46), (int8x16_t)(*(_OWORD *)&v56 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v73 = (int32x4_t)veorq_s8(vandq_s8(v94.val[2], (int8x16_t)v46), (int8x16_t)(*(_OWORD *)&v57 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    a31 = vaddq_s32(vsubq_s32((int32x4_t)v94.val[1], vaddq_s32(v72, v72)), (int32x4_t)v43);
    a32 = vaddq_s32(vsubq_s32((int32x4_t)v94.val[2], vaddq_s32(v73, v73)), (int32x4_t)v43);
    a29 = vaddq_s32(vsubq_s32((int32x4_t)v94.val[0], vaddq_s32(v70, v70)), (int32x4_t)v43);
    a30 = vaddq_s32(vsubq_s32((int32x4_t)v94.val[3], vaddq_s32(v71, v71)), (int32x4_t)v43);
    return ((uint64_t (*)(uint64_t, __n128))(*(_QWORD *)(v33
                                                                + 8
                                                                * ((1237 * (a21 + 1 == v38)) ^ (34 * (a2 ^ (a2 - 11)))))
                                                    - 8))(1138821655, v42);
  }
  else
  {
    *(_DWORD *)(v39 - 148) = 2 * (*(_DWORD *)(v39 - 148) ^ v36) + v36 - (v34 & (4 * (*(_DWORD *)(v39 - 148) ^ v36)));
    *(_DWORD *)(v39 - 144) = 2 * (v47 ^ v36) + v36 - (v34 & (4 * (v47 ^ v36)));
    *(_DWORD *)(v39 - 140) = 2 * (v49 ^ v36) + v36 - (v34 & (4 * (v49 ^ v36)));
    *(_DWORD *)(v39 - 136) = 2 * (v48 ^ v36) + v36 - (v34 & (4 * (v48 ^ v36)));
    return v40(v42, v43, v44, v45, v46);
  }
}

uint64_t sub_100051EA0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, int a17, int a18, unsigned int a19)
{
  unsigned int v19;
  uint64_t v20;
  _BOOL4 v21;

  if (v19 < a19 != a16 + 237793377 < (((a7 + a2 - 303) | 0xD1) ^ 0x64AD787Cu))
    v21 = a16 + 237793377 < (((a7 + a2 - 303) | 0xD1) ^ 0x64AD787Cu);
  else
    v21 = a16 + 237793377 > v19;
  return ((uint64_t (*)(void))(*(_QWORD *)(v20 + 8 * ((a7 + a2 + 1047) | (8 * v21)))
                            - ((41 * (a2 ^ (a2 - 4))) ^ 0xA8)))();
}

uint64_t sub_100051F3C@<X0>(int a1@<W1>, int a2@<W4>, int a3@<W8>)
{
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8
                                             * ((23 * (a2 + a3 + 63 >= ((a1 + v3 - 164) ^ 0x21C3C66Bu) + a3)) ^ v3))
                            - 4))();
}

uint64_t sub_100051F80@<X0>(int a1@<W1>, int a2@<W4>, int a3@<W6>, int a4@<W8>, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;

  return ((uint64_t (*)(void))(*(_QWORD *)(v13
                                        + 8
                                        * (((a10 + v10 - (unint64_t)(a4 + a2) >= v11 + (unint64_t)(v12 ^ (a1 - 164)) + 6)
                                          * ((v12 - a3 + 171) ^ (a1 - 261))) ^ v12))
                            - 4))();
}

uint64_t sub_100051FD0@<X0>(int a1@<W0>, int a2@<W4>, int a3@<W6>, int a4@<W7>, int a5@<W8>, int8x16_t a6@<Q2>, int8x16_t a7@<Q3>)
{
  int8x16_t *v7;
  uint64_t v8;
  uint64_t v9;

  *v7 = vaddq_s8(vsubq_s8(*(int8x16_t *)(v9 + (a5 + a2)), vandq_s8(vaddq_s8(*(int8x16_t *)(v9 + (a5 + a2)), *(int8x16_t *)(v9 + (a5 + a2))), a7)), a6);
  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * (((a3 + a1 == 383) * a4) ^ (a3 + a1 - 117))) - 4))();
}

uint64_t sub_10005202C@<X0>(int a1@<W4>, unint64_t a2@<X5>, int a3@<W6>, int a4@<W8>)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;

  *(_BYTE *)(v4 + v6) = *(_BYTE *)(v9 + (a4 + a1))
                      - ((2 * *(_BYTE *)(v9 + (a4 + a1))) & 0xFC)
                      - 2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v8
                                        + 8 * ((((((a3 + v7 - 331) | v10) ^ a2) + v6 != 64) * v5) ^ (a3 + v7 + 865)))
                            - 4))();
}

uint64_t sub_100052084@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v6;
  uint64_t v7;
  unsigned int v8;
  _BOOL4 v9;

  v8 = a6 + v6 - 139759037;
  v9 = a1 + 13222166 < v8;
  if (v8 < 0x574AC982 != (a1 + 13222166) < 0x574AC982)
    v9 = v8 < 0x574AC982;
  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * (v6 ^ (2 * v9))) - 8))();
}

uint64_t sub_1000520E4(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13)
{
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v19;

  v19 = (a1 + 974102436) & 0xC5F067BF;
  v15 = 831981571 * ((((2 * (v14 - 120)) | 0xA7832B06) - (v14 - 120) - 1405195651) ^ 0xCA6045A7);
  *(_QWORD *)(v14 - 112) = a11;
  *(_DWORD *)(v14 - 120) = (a13 + 5614872) ^ v15;
  *(_DWORD *)(v14 - 116) = v15 + a1 + 1267;
  v16 = sub_10005533C(v14 - 120);
  v17 = *(_DWORD *)(v14 - 152) & 0x3F;
  *(_BYTE *)(v14 - 220 + (v17 ^ 0x15)) = 126;
  return ((uint64_t (*)(uint64_t, uint64_t))(*(_QWORD *)(v13
                                                               + 8
                                                               * ((154 * ((v17 ^ 0x15) > 0x37)) ^ a1))
                                                   - v19
                                                   + 1955))(v16, 2294100479);
}

uint64_t sub_1000521FC(uint64_t a1, int a2)
{
  int v2;
  int v3;
  uint64_t v4;
  _BOOL4 v5;

  v5 = v2 != (((v3 ^ (a2 + 1109)) - a2 + 1485) ^ 0x5F2);
  return (*(uint64_t (**)(void))(v4 + 8 * (((2 * v5) | (4 * v5)) ^ v3)))();
}

uint64_t sub_100052238(uint64_t a1, int a2)
{
  int v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8 * ((((v3 - 1265) ^ (a2 - 220) ^ (a2 + 369)) * ((v2 ^ 0x2Au) > 7)) ^ v3))
                            - 4))();
}

uint64_t sub_100052270@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  int v2;
  char v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(v5 - 220 + a2 + a1) = 0xFEFEFEFEFEFEFEFELL;
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((1718 * (((27 * (v2 ^ 0xEBu)) ^ 0x5C5) == (v3 & 0x38))) ^ v2))
                            - 4))();
}

uint64_t sub_1000522D8@<X0>(int a1@<W2>, int a2@<W4>, int a3@<W8>)
{
  unsigned int v3;
  int v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  unsigned int v11;
  int v12;
  _BOOL4 v13;

  v10 = v3 < v5;
  *(_BYTE *)(v9 - 220 + (v4 ^ 0xB6u) + a1 - 1403603913) = *(_BYTE *)(v8 + (a3 + a2))
                                                        - ((2 * *(_BYTE *)(v8 + (a3 + a2))) & 0xFC)
                                                        - 2;
  v11 = a3 + 1 + v6;
  v12 = v10 ^ (v11 < v5);
  v13 = v11 < v3;
  if (!v12)
    v10 = v13;
  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * (v4 | (2 * v10))) - 8))();
}

uint64_t sub_100052354@<X0>(uint64_t a1@<X0>, int a2@<W6>, int a3@<W8>)
{
  uint64_t v3;
  int v4;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v3
                                                                        + 8
                                                                        * ((1637
                                                                          * (a3 - 186471976 < ((v4 - 647096012) & 0x9DD4B7EE)
                                                                                            - 746)) ^ (a2 + v4 + 457)))
                                                            - 4))(a1, 2294100475, -186471976);
}

uint64_t sub_1000523B4@<X0>(uint64_t a1@<X2>, unsigned int a2@<W8>)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  v4 = a1 + a2;
  if ((unint64_t)(v4 + 1) > 0x38)
    v5 = v4 + 1;
  else
    v5 = 56;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * ((1589
                                          * (v5 - a2 + (unint64_t)((v2 - 344152867) & 0x14835E2D) + 186470395 > 7)) ^ v2))
                            - (((v2 - 761) | 0x206u) ^ 0x22BLL)))();
}

uint64_t sub_10005242C@<X0>(uint64_t a1@<X2>, uint64_t a2@<X8>)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  *(_QWORD *)(v5 - 220 + a2 + a1) = 0xFEFEFEFEFEFEFEFELL;
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * (int)((280 * ((v2 ^ 0x227) == (v3 & 0xFFFFFFFFFFFFFFF8))) ^ v2))
                            - 12))();
}

uint64_t sub_100052484(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  unint64_t v26;

  if (a17 == 2)
    return ((uint64_t (*)(void))(*(_QWORD *)(v22
                                          + 8
                                          * ((1343
                                            * (*(_DWORD *)(v23 - 128) != ((a2 - 982075024) & 0xB1CC15DF) + 1763403103)) ^ (a2 + a7)))
                              - 12))();
  if (a17 == 1)
    return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v22
                                                        + 8
                                                        * ((249 * (*(_DWORD *)(v23 - 128) != 1763403438)) ^ (a2 + a7)))
                                            - ((a2 + 1022729712) & 0x3A4D315F)
                                            + 323))(a10);
  v25 = (-2000865919 - a2);
  v26 = ((v25 - 0x488189C440019593) ^ (unint64_t)&a22)
      + ((2 * (_QWORD)&a22) & 0x6EFCEC777FFCDBD0)
      + 0x7895BFDED3BD9AA0;
  *(_BYTE *)(v23 - 129) = ((v26 + 113) ^ 0xBA) * (v26 + ((-127 - a2) ^ (a2 + 126) ^ 0x7D));
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v22 + 8 * (int)(v25 ^ 0xB)) - 4))(a10);
}

void sub_100052BF0()
{
  JUMPOUT(0x100052BACLL);
}

uint64_t sub_100052BF8()
{
  return 0;
}

void sub_100052C38(_DWORD *a1)
{
  unsigned int v1;

  v1 = *a1 ^ (268847287 * (((a1 | 0xE34F1B4D) - (a1 & 0xE34F1B4D)) ^ 0x1CE50A65));
  __asm { BR              X10 }
}

uint64_t sub_100052CF8(uint64_t a1)
{
  uint64_t v1;
  int v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((491 * (*(_DWORD *)(*(_QWORD *)(a1 + 8) + v4) != v2)) ^ v3))
                            - (((v3 - 1242) | 0x34Eu) ^ 0x367)))();
}

uint64_t sub_100052D38()
{
  int v0;
  uint64_t v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (int)((44
                                               * (((((3 * ((v2 + 289) ^ 0x739)) ^ 0xF1D1EA57) + v3)
                                                 * (((293 * ((v2 + 289) ^ 0x61F)) ^ 0xF1D1EA57) + v0)) >> 31)) ^ (v2 + 289)))
                            - 8))();
}

uint64_t sub_100052D90@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;

  v6 = v2;
  v7 = a1;
  v5 = v2;
  v8 = v3 + 1224239923 * ((&v5 + 396803106 - 2 * (&v5 & 0x17A6BC22)) ^ 0xE51541F5) - 374;
  return ((uint64_t (*)(uint64_t *))(*(_QWORD *)(v1 + 8 * (v3 ^ 0x3D3)) - 4))(&v5);
}

void sub_100052EE0(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 16) + 1178560073 * ((2 * (a1 & 0xDA2E353F) - a1 + 634505920) ^ 0xC2E4E8A8);
  __asm { BR              X11 }
}

uint64_t sub_100052F94@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (((*(_DWORD *)(v2 - 0x56428495FB6297ALL) == ((a1 + 4) ^ 0x1D30BF21))
                                          * (a1 ^ 0x532)) ^ (a1 + 4)))
                            - 8))();
}

uint64_t sub_100052FF0()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  _BOOL4 v5;
  _BOOL4 v6;

  v3 = *(_DWORD *)(v2 - 0x56428495FB62982) + 819906255;
  v4 = *(_DWORD *)(v2 - 0x56428495FB62986) + 218190573;
  v5 = v3 < ((v1 + 492787797) & 0xE2A0A0DC ^ 0x37D6A3D4);
  v6 = v3 > v4;
  if (v5 != v4 < 0x37D6A30C)
    v6 = v5;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((4007 * !v6) ^ v1)) - 12))();
}

uint64_t sub_10005309C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  v10 = *(_QWORD *)(v9 - 0x56428495FB62992);
  v11 = *(unsigned __int8 *)(v10 + (v7 - 116907074)) ^ 0xFE;
  v12 = ((*(unsigned __int8 *)(v10 + (v7 - 116907077)) ^ 0xFE) << 24) | ((*(unsigned __int8 *)(v10 + (v7 - 116907076)) ^ 0xFE) << 16) | ((*(unsigned __int8 *)(v10 + ((a5 + 1834) ^ 0xF90829F4) + v7 + ((a5 + 169) | 0x46)) ^ 0xFE) << 8) | v11;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5
                                        + 8
                                        * ((451
                                          * (((v12 + v6 - 2 * (v12 & (v6 + 8) ^ v11 & 8)) & 0xFFFFFF ^ 0x30BEE6)
                                           - (v8
                                            + *(_DWORD *)(a1 + 20)) == -849886013)) ^ a5))
                            - 4))();
}

uint64_t sub_100053170(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  uint64_t v6;
  _BOOL4 v7;

  v7 = ((a4 ^ 0x40000802) & a6) == a4 - 2050;
  return (*(uint64_t (**)(void))(v6 + 8 * ((v7 | (16 * v7)) ^ a4)))();
}

uint64_t sub_100053218(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  _BOOL4 v14;

  v9 = a4 ^ 0xBA5;
  v10 = a3 + v6 + (v8 ^ (v5 - 1718) ^ ((v9 - 803) | 0x652)) + 8;
  v11 = ((2 * v10) & 0x6DEFFBBE) + (v10 ^ 0x36F7FDDF) - 771017320;
  v12 = v7 - 567418479 + v9 - 480;
  v13 = (v12 < 0x9033377) ^ (v11 < 0x9033377);
  v14 = v11 > v12;
  if (v13)
    v14 = v11 < 0x9033377;
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((97 * v14) ^ v9)) - 12))();
}

uint64_t sub_1000532C4@<X0>(uint64_t result@<X0>, _DWORD *a2@<X8>)
{
  int v2;

  *a2 = v2;
  *(_DWORD *)(result + 24) = -489691693;
  return result;
}

uint64_t sub_100053338@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X1>, _DWORD *a3@<X8>)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;

  *(_QWORD *)(*a1 - 0x7F1325F673F67E57) = a2 + v6 + 8;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((1869 * (*a3 == (((v5 ^ 0x711) - 4) ^ (v4 + 63)))) ^ v5 ^ 0x711))
                            - 8))();
}

uint64_t sub_1000533A0@<X0>(_QWORD *a1@<X0>, _DWORD *a2@<X8>)
{
  uint64_t v2;
  int v3;
  int v4;

  *(_QWORD *)(*a1 - 0x7F1325F673F67E57) = 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((1869 * (*a2 == ((v4 - 4) ^ (v3 + 63)))) ^ v4)) - 8))();
}

void sub_100053404(uint64_t a1)
{
  int v1;
  _DWORD *v2;
  int v3;

  *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x20BA795F69D3FB1) = v3;
  *v2 = v1;
  JUMPOUT(0x10005332CLL);
}

void sub_100053428(uint64_t a1)
{
  int v1;
  BOOL v2;

  v1 = *(_DWORD *)a1 + 1178560073 * (((a1 | 0x375468D4) - a1 + (a1 & 0xC8AB972B)) ^ 0xD0614ABC);
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 24) - 0x2DB44D49A49B002ALL) == 237901512;
  __asm { BR              X14 }
}

uint64_t sub_100053588@<X0>(_QWORD *a1@<X0>, uint64_t a2@<X8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,char a28,uint64_t a29,char a30,uint64_t a31,char a32,uint64_t a33,char a34,uint64_t a35,char a36,uint64_t a37,char a38)
{
  uint64_t v38;
  int v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  char *v44;
  char *v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char *v55;
  char *v56;
  char *v57;
  char *v58;
  char *v59;
  char *v60;
  int v61;
  int v62;
  int v63;
  void (*v64)(uint64_t);
  uint64_t v65;

  v44 = &a38 + v38;
  v60 = &a36 + v38;
  v59 = &a22 + v38;
  v58 = &a28 + v38;
  v57 = &a32 + v38;
  v56 = &a26 + v38;
  v55 = &a34 + v38;
  v45 = &a30 + v38;
  v46 = v39 & 0x4DBC57FB;
  v65 = a1[4];
  v48 = a1[1];
  v47 = a1[2];
  v49 = *(_QWORD *)(v47 - 0x73495CDCA303A988);
  v63 = (v39 & 0x4DBC57FB) + 1204;
  *(_QWORD *)(v43 - 104) = a2;
  *(_DWORD *)(v43 - 112) = v63 - 1224239923 * ((((v43 - 144) | 0x4AC3EA30) - ((v43 - 144) & 0x4AC3EA30)) ^ 0xB87017E7);
  *(_QWORD *)(v43 - 128) = v49;
  *(_QWORD *)(v43 - 120) = v47;
  v50 = ((v39 & 0x4DBC57FB) - 463) | 0x1B0u;
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = &a38 + v38;
  v64 = (void (*)(uint64_t))(*(_QWORD *)(v40 + 8 * ((v39 & 0x4DBC57FB) - 331)) - 8);
  v64(v43 - 144);
  v62 = v46;
  *(_DWORD *)(v43 - 120) = v46
                         + 69008221
                         * ((((v43 - 144) | 0xADA53259) - (v43 - 144) + ((v43 - 144) & 0x525ACDA0)) ^ 0x7E076053)
                         + 1530;
  *(_QWORD *)(v43 - 112) = v47;
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v44;
  *(_QWORD *)(v43 - 128) = v45;
  ((void (*)(uint64_t))((char *)*(&off_100180420 + (v46 ^ 0x1FEu)) - 8))(v43 - 144);
  *(_QWORD *)(v43 - 128) = v44;
  *(_QWORD *)(v43 - 120) = v47;
  v51 = v47;
  *(_QWORD *)(v43 - 104) = v45;
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v60;
  LODWORD(v47) = v63 - 1224239923 * ((v43 - 144) ^ 0xF2B3FDD7);
  *(_DWORD *)(v43 - 112) = v47;
  v64(v43 - 144);
  *(_DWORD *)(v43 - 112) = v47;
  *(_QWORD *)(v43 - 104) = v45;
  *(_QWORD *)(v43 - 128) = v60;
  *(_QWORD *)(v43 - 120) = v51;
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v59;
  v64(v43 - 144);
  *(_QWORD *)(v43 - 104) = v45;
  *(_DWORD *)(v43 - 112) = v63
                         - 1224239923
                         * (((((v43 - 144) | 0xBB10DC) ^ 0xFFFFFFFE) - (~(v43 - 144) | 0xFF44EF23)) ^ 0xDF712F4);
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v58;
  *(_QWORD *)(v43 - 128) = v59;
  *(_QWORD *)(v43 - 120) = v51;
  v64(v43 - 144);
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v57;
  *(_DWORD *)(v43 - 112) = v63 - 1224239923 * ((((v43 - 144) | 0xF29ABA3C) - ((v43 - 144) & 0xF29ABA3C)) ^ 0x2947EB);
  *(_QWORD *)(v43 - 128) = v58;
  *(_QWORD *)(v43 - 120) = v51;
  *(_QWORD *)(v43 - 104) = v45;
  v64(v43 - 144);
  *(_DWORD *)(v43 - 112) = v63 - 1224239923 * (((v43 - 144) & 0xF279EF04 | ~((v43 - 144) | 0xF279EF04)) ^ 0xFF35ED2C);
  *(_QWORD *)(v43 - 128) = v57;
  *(_QWORD *)(v43 - 120) = v51;
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v56;
  *(_QWORD *)(v43 - 104) = v45;
  v64(v43 - 144);
  *(_DWORD *)(v43 - 112) = v63 - 1224239923 * (((v43 - 144) & 0x3B67870F | ~((v43 - 144) | 0x3B67870F)) ^ 0x362B8527);
  *(_QWORD *)(v43 - 128) = v56;
  *(_QWORD *)(v43 - 120) = v51;
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v55;
  *(_QWORD *)(v43 - 104) = v45;
  v64(v43 - 144);
  v61 = 2 * (v43 - 144);
  *(_DWORD *)(v43 - 112) = v63 - 1224239923 * (((v61 | 0x9B7A3224) - (v43 - 144) + 843245294) ^ 0x3F0EE4C5);
  *(_QWORD *)(v43 - 104) = v45;
  *(_QWORD *)(v43 - 144) = v48;
  *(_QWORD *)(v43 - 136) = v45;
  *(_QWORD *)(v43 - 128) = v55;
  *(_QWORD *)(v43 - 120) = v51;
  v64(v43 - 144);
  v52 = *(_QWORD *)(v51 - 0x73495CDCA303A990);
  *(_QWORD *)(v43 - 128) = v41;
  *(_QWORD *)(v43 - 144) = v52;
  *(_DWORD *)(v43 - 136) = v62 + 831981571 * ((v43 + 1572311972 - 2 * ((v43 - 144) & 0x5DB79434)) ^ 0xC4164410) - 129;
  sub_10004F498(v43 - 144);
  *(_DWORD *)(v43 - 128) = (v62 - 307) ^ (944348131 * (((v61 | 0x7083DFB6) - (v43 - 144) - 943845339) ^ 0x9B584B95));
  *(_QWORD *)(v43 - 136) = v65;
  v53 = sub_10004953C(v43 - 144);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v42
                                                      + 8
                                                      * (v62
                                                       + 4
                                                       * ((*(_DWORD *)(v43 - 144)
                                                                                     - 1307958045) < 0x7FFFFFFF)))
                                          - v50
                                          + 434))(v53);
}

uint64_t sub_100053A24()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v6;
  uint64_t v7;
  void (*v8)(uint64_t);
  uint64_t v9;

  v4 = 831981571 * ((-609318725 - ((v3 - 144) | 0xDBAE88BB) + ((v3 - 144) | 0x24517744)) ^ 0xBDF0A760);
  *(_QWORD *)(v3 - 144) = v7;
  *(_DWORD *)(v3 - 136) = v2 - v4 - 1274;
  *(_DWORD *)(v3 - 132) = v4 + 376798310;
  sub_1000548E8(v3 - 144);
  *(_QWORD *)(v3 - 144) = v9;
  *(_QWORD *)(v3 - 136) = v1;
  *(_DWORD *)(v3 - 112) = v2 - 1224239923 * (((v3 - 144) & 0x229A5DFF | ~((v3 - 144) | 0x229A5DFF)) ^ 0x2FD65FD7) + 197;
  *(_QWORD *)(v3 - 128) = v1;
  *(_QWORD *)(v3 - 120) = v0;
  *(_QWORD *)(v3 - 104) = v7;
  v8(v3 - 144);
  *(_QWORD *)(v3 - 128) = v6;
  *(_DWORD *)(v3 - 136) = (v2 ^ 0x1E8)
                        + 831981571 * ((((v3 - 144) | 0xF8EEAC69) - (v3 - 144) + ((v3 - 144) & 0x7115390)) ^ 0x614F7C4D)
                        - 712;
  *(_QWORD *)(v3 - 144) = v1;
  return sub_10004F498(v3 - 144);
}

uint64_t sub_100054814(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)(uint64_t))*(&off_10017BFF0 + ((377 * (*(_DWORD *)(a2 + 4) == 1528691563)) ^ 0x2ABu)))(4294925278);
}

uint64_t sub_100054858@<X0>(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  uint64_t v2;

  *(_BYTE *)(*(_QWORD *)(a2 + 96) + 448) = *(_BYTE *)(*(_QWORD *)(a1 + 8) + 12);
  return (*(uint64_t (**)(_QWORD))(v2 + 2968))(0);
}

uint64_t sub_1000548B0@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  unsigned int v2;
  int v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;

  *(_BYTE *)(a1 + (v7 + v5)) = *(_BYTE *)(v4 + (v7 + v5));
  return (*(uint64_t (**)(_QWORD))(v1 + 8 * (((v2 + v7 - 372 == v3) * v6) ^ v2)))(0);
}

uint64_t sub_1000548E8(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  BOOL v4;
  unsigned int v5;
  uint64_t v6;

  v1 = 831981571 * ((((2 * a1) | 0xFDCFEF62) - a1 - 2129131441) ^ 0xE7462795);
  v2 = *(_DWORD *)(a1 + 8) + v1;
  v3 = *(_DWORD *)(a1 + 12) - v1;
  v5 = v3 - 376798309;
  v4 = v3 - 376798309 < 0;
  LODWORD(v6) = 376798309 - v3;
  if (v4)
    v6 = v6;
  else
    v6 = v5;
  return ((uint64_t (*)(void))(*(_QWORD *)((char *)*(&off_100180420 + (v2 & 0x44BD676A))
                                        + 8
                                        * ((878
                                          * (v6 - 0x66409B29DA6A68E4 + (~(2 * v6) | 0xFFFFFFFFB4D4D1C7) != 0x99BF64D62595971BLL)) ^ v2)
                                        - 4)
                            - 4))();
}

void sub_1000549BC(int a1@<W8>)
{
  uint64_t v1;
  int v2;

  **(_DWORD **)(v1 - 0x2DB44D49A49B0026) = v2 ^ 0xC1123F8B;
  *(_DWORD *)(v1 - 0x2DB44D49A49B002ALL) = a1 + 1;
}

uint64_t sub_100054A00(_DWORD *a1)
{
  unsigned int v1;

  v1 = 268847287
     * ((2 * ((a1 ^ 0x2D90AAAC) & 0xA0689A7) - (a1 ^ 0x2D90AAAC) + 1979283032) ^ 0xA7C3CDDC);
  return ((uint64_t (*)(void))(*(_QWORD *)((char *)*(&off_100180420 + (int)((a1[4] - v1) ^ 0x7BA))
                                        + 8
                                        * (int)((((*a1 ^ v1 ^ 0x1D30BEE6) - 1 > 0x62) * (((a1[4] - v1) ^ 0x5FB) + 3535)) ^ (a1[4] - v1))
                                        - 4)
                            - 12))();
}

uint64_t sub_100054AA4()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((1348 * ((((v0 - 100) < 0x9C) ^ v1) & 1)) ^ v1))
                            - 12))();
}

uint64_t sub_100054AD8@<X0>(uint64_t result@<X0>, int a2@<W8>)
{
  int v2;
  int v3;
  int v4;

  if (v2 + 49998 < (v4 + 7475))
    v3 = a2;
  *(_DWORD *)(*(_QWORD *)(result + 8) - 0x2F801B1FA3259451) = v3;
  return result;
}

void sub_100054B64(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 8) - 3804331 * (((a1 | 0x51A664) - (a1 & 0x51A664)) ^ 0x7E848392);
  __asm { BR              X10 }
}

uint64_t sub_100054C28@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, unint64_t *a4, unint64_t *a5, int a6, unsigned int a7, uint64_t a8, uint64_t a9)
{
  int v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t v14;

  v13 = 1178560073 * ((2 * (&a4 & 0x493717C8) - &a4 - 1228347340) ^ 0x51FDCA5C);
  a6 = v11 - v13 - 466;
  a7 = 856161221 - v13;
  a9 = v12;
  a4 = &STACK[0x7F1325F673F67E57];
  a5 = &STACK[0x20BA795F69D3FBD];
  v14 = ((uint64_t (*)(unint64_t **))(*(_QWORD *)(a1 + 8 * (v11 - 846)) - 8))(&a4);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v10
                                                      + 8
                                                      * (((*(_DWORD *)(v12 - 0x56428495FB6297ALL) == v9) * (v11 + 278)) ^ v11))
                                          - 8))(v14);
}

uint64_t sub_100054D00(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11)
{
  int v11;
  uint64_t v12;
  int v13;

  return ((uint64_t (*)(void))(*(_QWORD *)(v12
                                        + 8
                                        * (((a11 == (v13 ^ (v11 - 371))) | (4 * (a11 == (v13 ^ (v11 - 371))))) ^ (v13 + 150)))
                            - 8))();
}

uint64_t sub_100054D4C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11)
{
  uint64_t v11;
  int v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;

  *(_BYTE *)(v11 + (v14 + v13)) = *(_BYTE *)(a9 + (v14 + v13)) ^ 0xFE;
  return ((uint64_t (*)(void))(*(_QWORD *)(v16
                                        + 8
                                        * (((v12 ^ (v14 + 1 + v13 < (a11 ^ v15))) & 1 | (4 * ((v12 ^ (v14 + 1 + v13 < (a11 ^ v15))) & 1))) ^ v12))
                            - 8))();
}

void sub_100054D94(_DWORD *a1@<X8>)
{
  uint64_t v1;
  int v2;
  uint64_t *v3;
  uint64_t v4;

  v4 = *v3;
  *(_QWORD *)(v3[3] - 0x5B1E97A52371A20DLL) = v1;
  *(_DWORD *)(v4 - 0x1CAC648E56C350CDLL) = v2;
  *((_DWORD *)v3 + 3) = *a1;
}

void sub_100054E00()
{
  int v0[10];

  v0[1] = 1178560073
        * (((v0 | 0xE965F012) - v0 + (v0 & 0x169A0FE8)) ^ 0xE50D27A)
        - 1501685844;
  sub_100074AF8(v0);
  __asm { BR              X8 }
}

uint64_t sub_100054EC8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t *a13, unsigned int a14, int a15)
{
  int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  a13 = &STACK[0x82D647BA4E69FE1];
  a14 = (831981571 * (((&a13 | 0x5366F27) + (~&a13 | 0xFAC990D8)) ^ 0x9C97BF02)) ^ 0x87;
  sub_1000344DC((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v17
                                                                                + 8 * ((2767 * (a15 == v15)) ^ v16)))(v18, v19, v20, v21, v22);
}

uint64_t sub_100054F50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unsigned int a16)
{
  uint64_t v16;
  int v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;

  v22 = 1224239923
      * ((((2 * (&a13 ^ 0x9F5B1C94)) | 0xF1532BEC) - (&a13 ^ 0x9F5B1C94) + 123103754) ^ 0x954174B5);
  LODWORD(a13) = v18 - ((2 * v18) & 0xDE3BA25A) - v22 - 283258579;
  LODWORD(a15) = v22 ^ 0x3A4;
  a14 = a12;
  sub_10004A21C((uint64_t)&a13);
  v23 = 69008221 * (((~&a13 & 0x57029748) - (~&a13 | 0x57029749)) ^ 0x84A0C543);
  a13 = v16;
  a16 = (((2 * v17) & 0xFDD65FFE) + (v17 ^ 0xFEEB2FFF) + 234348473) ^ v23;
  a15 = a12;
  HIDWORD(a14) = v23 + 1026;
  v24 = ((uint64_t (*)(uint64_t *))(*(_QWORD *)(v20 + 360) - 8))(&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v21 + 8 * ((265 * ((_DWORD)a14 == v19)) ^ 0x66Eu)) - 12))(v24);
}

uint64_t sub_1000550A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, unsigned int a15, uint64_t a16, unint64_t *a17, int a18)
{
  int v18;
  int v19;
  unsigned int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;

  v22 = ((&a13 + 487303392 - 2 * ((unint64_t)&a13 & 0x1D0BA8E0)) ^ 0xEFB85537) * v19;
  a14 = (v20 + 368398531) ^ v22;
  a15 = v22 ^ 0xF8F44488;
  a16 = a12;
  a17 = &STACK[0x72F2C1D3322B87F0];
  a13 = v22 ^ 0x12B68929;
  v23 = sub_100074BB8((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v21 + 8 * ((323 * (a18 == v18)) ^ v20))
                                          - ((v20 - 312869505) & 0x1FEDB ^ 0x2C5)))(v23);
}

uint64_t sub_10005516C()
{
  void (*v0)(unint64_t **);
  int v1;
  unsigned int v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  unint64_t *v8;
  int v9;
  unint64_t *v10;
  unint64_t *v11;
  unint64_t *v12;
  unsigned int v13;

  v5 = (v4 - 1118675583) & 0x1ED9;
  v13 = v4
      - 944348131 * ((((2 * &v11) | 0x21534596) - &v11 + 1867930933) ^ 0x33B00685)
      - 1128;
  v11 = &STACK[0x20BA795F69D3F15];
  v12 = v8;
  ((void (*)(unint64_t **))(*(_QWORD *)(v3 + 8 * (v4 ^ 0x684u)) - 8))(&v11);
  LODWORD(v12) = v4
               - 241568881 * ((&v11 - 1200860867 - 2 * (&v11 & 0xB86C513D)) ^ 0x6E7D557F)
               - 1064;
  v11 = v8;
  sub_10005A5D8((uint64_t)&v11);
  if (HIDWORD(v12) == (v5 ^ (v2 - 695)))
    v6 = v9;
  else
    v6 = HIDWORD(v12);
  v12 = v8;
  LODWORD(v11) = (v4 - 1494) ^ (((((2 * (&v11 ^ 0x804118BC)) | 0x67E0F30A)
                                - (&v11 ^ 0x804118BC)
                                - 871397765) ^ 0x60133333)
                              * v1);
  v0(&v11);
  LODWORD(v11) = (v5 - 561) ^ (((&v11 & 0xFBD564C | ~(&v11 | 0xFBD564C)) ^ 0x23E0FBB9) * v1);
  v12 = v10;
  v0(&v11);
  return v6 ^ v2;
}

uint64_t sub_10005533C(uint64_t a1)
{
  int v1;
  int v2;
  uint64_t v3;
  unsigned int v4;
  int v5;

  v1 = 831981571 * ((a1 & 0x847A176C | ~(a1 | 0x847A176C)) ^ 0xE22438B7);
  v2 = *(_DWORD *)(a1 + 4) - v1;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = (*(_DWORD *)a1 ^ v1) - 1609892710;
  v5 = v4
     + (*(_DWORD *)(v3 - 0x73F39308AC2F360BLL) ^ 0x52C4D95)
     - ((2 * (v4 + (*(_DWORD *)(v3 - 0x73F39308AC2F360BLL) ^ 0x52C4D95))) & 0xA589B2A)
     + 86789525;
  *(_DWORD *)(v3 - 0x73F39308AC2F360BLL) = v5;
  return ((uint64_t (*)(void))(*(_QWORD *)((char *)*(&off_100180420 + (v2 ^ 0x570))
                                        + 8 * ((625 * ((v5 ^ 0x52C4D95u) < v4)) ^ v2)
                                        - 4)
                            - 4))();
}

void sub_100055404(uint64_t a1@<X8>)
{
  *(_DWORD *)(a1 - 0x73F39308AC2F360FLL) = (*(_DWORD *)(a1 - 0x73F39308AC2F360FLL) ^ 0xD9C42F88)
                                         - 641454200
                                         - ((2 * (*(_DWORD *)(a1 - 0x73F39308AC2F360FLL) ^ 0xD9C42F88) + 2) & 0xB3885F10)
                                         + 1;
}

void sub_10005544C(uint64_t a1)
{
  int v1;
  BOOL v2;
  int v3;

  v1 = 268847287 * ((a1 - 2 * (a1 & 0x4542390B) + 1161967883) ^ 0xBAE82823);
  if (*(_QWORD *)(a1 + 24))
    v2 = (*(_DWORD *)(a1 + 4) ^ v1) == 718622751;
  else
    v2 = 1;
  v3 = v2;
  __asm { BR              X8 }
}

uint64_t sub_10005550C()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  BOOL v3;

  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v0 + 8 * (v2 - 1114)))(32, 0x101004023FF3BD5) == 0;
  return (*(uint64_t (**)(void))(v1 + 8 * (((((v2 + 105) ^ v3) & 1) * ((v2 ^ 0x358) - 1466)) ^ v2)))();
}

uint64_t sub_100055570()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * (((v1 == ((v3 + 959) ^ (v0 + 1628))) * ((4 * v3) ^ 0xA82)) ^ v3))
                            - 8))();
}

uint64_t sub_1000555C4@<X0>(uint64_t result@<X0>, uint64_t a2@<X8>)
{
  int v2;
  uint64_t v4;
  char v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  unsigned int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;

  v11 = v2 - 718622752;
  v12 = v2 - 1;
  v13 = *(unsigned __int8 *)(v8 + v11);
  if (v13 == 254)
    __asm { BR              X11 }
  if (v13 == 126)
  {
    v14 = 489733862;
    v15 = *(_QWORD *)(v4 + 16);
    v16 = (*(_BYTE *)(v4 + 8) + v5);
    *(_QWORD *)result = v8;
    *(_DWORD *)(result + 8) = v7;
    *(_DWORD *)(result + 12) = v12;
    if (v16 == 6)
      v17 = 429502578;
    else
      v17 = 429502579;
    *(_DWORD *)(result + 16) = 116907077;
    *(_DWORD *)(result + 20) = v17;
    *(_DWORD *)(result + 24) = 489733862;
    *(_QWORD *)(v15 - 0x6B80B300B999BABLL) = a2;
  }
  else
  {
    result = (*(uint64_t (**)(void))(v6 + 8 * (v9 ^ 0x67E)))();
    v14 = -489691841;
  }
  *(_DWORD *)(v4 + 12) = v14;
  return result;
}

void sub_1000556A8(uint64_t a1, uint64_t a2)
{
  __asm { BR              X9 }
}

uint64_t sub_1000556F0(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  unsigned int v3;

  return (*(uint64_t (**)(void))(v2 + 8 * ((3860 * (**(_BYTE **)(a2 + 8) == 0)) ^ v3)))();
}

uint64_t sub_10005572C()
{
  uint64_t v0;
  int v1;
  int v2;

  v2 = v1 - ((2 * v1 + 163842370) & 0x2B1346DE) - 1167349744;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * ((32
                                          * (((2 * v2) & 0xD95FFBDA ^ 0x91342DA) + (v2 ^ 0xF9265E82) + 2079678464 == 1755667949)) ^ 0x449u))
                            - 4))();
}

uint64_t sub_1000557CC(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;

  *(_DWORD *)(*(_QWORD *)(a1 + 96) + 1424) = v4 + 2090229896 + v2 + v3;
  *(_QWORD *)(*(_QWORD *)(a1 + 96) + 520) = *(_QWORD *)(a2 + 8) + 1;
  return 0;
}

void sub_100055B2C(uint64_t a1, uint64_t a2)
{
  __asm { BR              X9 }
}

uint64_t sub_100055B9C@<X0>(int a1@<W8>)
{
  uint64_t v1;

  return (*(uint64_t (**)(void))(v1
                              + 8
                              * ((52
                                * (((a1 - 1528691550) ^ 0x6DBFFE7FFBFDEFABLL)
                                 - 0x6DBFFE7F4F94EF26
                                 + ((2 * (a1 - 1528691550)) & 0x1F7FBDF56) == 2892562565)) ^ 0xD4u)))();
}

uint64_t sub_100055C2C()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  v5 = *(unsigned __int8 *)(v2 + v3 - 0x3F1C0A44C246FA9FLL) - *(unsigned __int8 *)(v0 + v3 - 0x3F1C0A44C246FA9FLL);
  return (*(uint64_t (**)(uint64_t))(v4
                                            + 8
                                            * ((239
                                              * (((v5 << (v1 - 121)) & 0xFFED3BFE)
                                               + ((v1 - 1883246715) & 0xF8DC5BFB ^ 0xF76AD604 ^ v5) == 2146868735)) ^ v1)))(4294925278);
}

uint64_t sub_100055CB4()
{
  unint64_t v0;
  int v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _BOOL4 v5;

  v5 = v2 < v0;
  if (v5 == v3 - 0x3F1C0A4415DDFA19 < ((v0 + ((v1 + 73087360) & 0xFBA4C67F) - 198) ^ (v1 + 66)))
    v5 = v3 - 0x3F1C0A4415DDFA19 < v2;
  return (*(uint64_t (**)(void))(v4 + 8 * ((52 * !v5) ^ (v1 + 90))))();
}

uint64_t sub_100055D34@<X0>(int a1@<W8>)
{
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v2
                                                      + 8
                                                      * ((1879
                                                        * (a1 == ((v1 + 120660663) & 0xF8CEDFBF)
                                                               + ((v1 - 2003023041) ^ 0xD381B3CF))) ^ v1))
                                          - 8))(4294925278);
}

uint64_t sub_100055D90()
{
  unsigned __int8 *v0;
  int v1;
  uint64_t v2;
  unsigned int v3;

  v3 = ((v1 - 1519571780) & 0x5A92D2B3 ^ 0xFFFFFD75) + *v0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((1758 * (((2 * v3) & 0x7FFFEF6E) + (v3 ^ 0x3FFFF7B7) == 1073739703)) ^ v1))
                            - 8))();
}

uint64_t sub_100055E00()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((1295
                                          * ((((*(unsigned __int8 *)(v2 + 1) - 134) << ((74 * (v3 ^ 0x31)) ^ 0x95)) & v1)
                                           + ((*(unsigned __int8 *)(v2 + 1) - 134) ^ v0) == (((v3 ^ 0x331) + 673) ^ (v0 - 675)))) ^ v3))
                            - 8))();
}

uint64_t sub_100055E60()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * ((506
                                * (((v1 + ((v3 - 146) | 0x2A1) - 675) & (2 * (*(unsigned __int8 *)(v2 + 2) - 72)))
                                 + ((*(unsigned __int8 *)(v2 + 2) - 72) ^ v0) == v0)) ^ v3)))();
}

uint64_t sub_100055EA8()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * ((((v1 & (2 * (*(unsigned __int8 *)(v2 + 3) - 134)))
                                 + ((*(unsigned __int8 *)(v2 + 3) - 134) ^ v0) == v0)
                                * (((v3 - 116) | 0x283) ^ 0x2C3)) | v3)))();
}

uint64_t sub_100055EEC()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * ((((v1 & (2 * (*(unsigned __int8 *)(v2 + 4) - 247)))
                                 + ((*(unsigned __int8 *)(v2 + 4) - 247) ^ v0) == v0)
                                * (v3 + 752)) ^ v3)))();
}

uint64_t sub_100055F24()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  unsigned int v5;

  v5 = *(unsigned __int8 *)(v2 + 5) + ((v3 - 148) | 0x2A3) + ((273 * (v3 ^ 0x97)) ^ 0xFFFFFE63);
  return (*(uint64_t (**)(void))(v4 + 8 * ((1027 * ((v1 & (2 * v5)) + (v5 ^ v0) == v0)) ^ v3)))();
}

uint64_t sub_100055F80()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((1904
                                          * ((((*(unsigned __int8 *)(v2 + 6) - 1) << ((v3 + 112) ^ 0xA2)) & v1)
                                           + ((*(unsigned __int8 *)(v2 + 6) - 1) ^ v0) == v0)) ^ v3))
                            - 8))();
}

uint64_t sub_100055FCC()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((1792
                                          * ((((*(unsigned __int8 *)(v2 + 7) - 1) << (((v3 + 110) ^ 0x35) + 109)) & v1)
                                           + ((*(unsigned __int8 *)(v2 + 7) - 1) ^ (v0 + ((v3 - 146) | 2) - 675)) == v0)) ^ v3))
                            - 8))();
}

uint64_t sub_100056024()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * (int)((((((v3 - 1089062061) & 0x40E9C6BB ^ (v1 - 417)) & (2
                                                                                        * (*(unsigned __int8 *)(v2 + 8)
                                                                                         - 4)))
                                      + ((*(unsigned __int8 *)(v2 + 8) - 4) ^ v0) == v0)
                                     * (((v3 - 1089062061) ^ 0xBF163B53) - 131)) ^ v3)))();
}

uint64_t sub_10005607C(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  *(_DWORD *)(*(_QWORD *)(v4 + 96) + 1428) = 1373296687;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8 * ((903 * (*(_DWORD *)(a2 + 4) == ((v2 + 1528690960) ^ (v2 + 495)))) ^ v2))
                            - 8))();
}

uint64_t sub_1000560D4(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;

  v6 = **(unsigned __int8 **)(a2 + 8) - 42;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((1651 * ((v3 & (2 * v6)) + (v6 ^ v2) == v2)) ^ v4))
                            - (v4 ^ 0x202u)
                            + 157))();
}

uint64_t sub_100056118()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((((v1 & (2 * (*(unsigned __int8 *)(v3 + 1) - 134)))
                                           + ((*(unsigned __int8 *)(v3 + 1) - 134) ^ v0) == ((v2 - 669) ^ 0xA7 ^ (v0 - 161)))
                                          * (((v2 - 669) | 0x289) ^ 0x435)) ^ v2))
                            - 4))();
}

uint64_t sub_10005616C()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((((v1 & (2 * (*(unsigned __int8 *)(v2 + 2) - 72)))
                                           + ((*(unsigned __int8 *)(v2 + 2) - 72) ^ v0) != v0
                                                                                         + ((v3 - 622) | 0x80)
                                                                                         - 161)
                                          * (v3 - 611)) ^ v3))
                            - 4))();
}

uint64_t sub_1000561B0()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((1935
                                          * ((((*(unsigned __int8 *)(v2 + 3) - 134) << ((v3 + 114) | 0xA0)) & v1)
                                           + ((*(unsigned __int8 *)(v2 + 3) - 134) ^ v0) == v0)) ^ (v3 + 20)))
                            - 4))();
}

uint64_t sub_1000561F8()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;

  v5 = (((v2 ^ 0x2A7) + 157) ^ 0xFFFFFFA8) + *(unsigned __int8 *)(v3 + 4);
  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((363 * ((((491 * (v2 ^ 0x2A7)) ^ (v1 - 1708)) & (2 * v5)) + (v5 ^ v0) == v0)) ^ v2))
                            - 4))();
}

uint64_t sub_100056250()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((4001
                                          * ((v1 & (2 * (*(unsigned __int8 *)(v2 + 5) - 13)))
                                           + ((135 * (v3 ^ 0x7A9)) ^ (v0 - 675) ^ (*(unsigned __int8 *)(v2 + 5) - 13)) == v0 + v3 - 1803 - 161)) ^ v3))
                            - 8))();
}

uint64_t sub_1000562A8()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((1290
                                          * ((((*(unsigned __int8 *)(v3 + 6) - 1) << ((v2 + 18) & 0xEB)) & v1)
                                           + ((*(unsigned __int8 *)(v3 + 6) - 1) ^ v0) == v0)) ^ v2))
                            - 4))();
}

uint64_t sub_1000562F8()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5
                                        + 8
                                        * ((1694
                                          * ((((*(unsigned __int8 *)(v3 + 7) - 1) << ((4 * v2) ^ 0x8D)) & v1)
                                           + ((v2 - 514) ^ v4 ^ (*(unsigned __int8 *)(v3 + 7) - 1)) == v0)) ^ v2))
                            - 4))();
}

uint64_t sub_100056344()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4
                                        + 8
                                        * ((3997
                                          * ((v1 & (2 * (*(unsigned __int8 *)(v2 + 8) - 5)))
                                           + ((*(unsigned __int8 *)(v2 + 8) - 5) ^ v0) == (((v3 ^ 0xD20) - 1803) ^ 0x15 ^ (v0 - 180)))) ^ v3 ^ 0xD20))
                            - 8))();
}

uint64_t sub_100056394(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  uint64_t v4;

  *(_DWORD *)(*(_QWORD *)(v4 + 96) + 1428) = 1373296691;
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((1816 * (*(_DWORD *)(a2 + 4) == 1528691559)) ^ v2))
                            - (((v2 - 180) | 0xA1) ^ (587 * (v2 ^ 0xB6u)) ^ 0x43FLL)))();
}

uint64_t sub_10005640C(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;

  return (*(uint64_t (**)(void))(v5
                              + 8
                              * ((745
                                * ((((**(unsigned __int8 **)(a2 + 8) - 42) << v4) & v3)
                                 + ((**(unsigned __int8 **)(a2 + 8) - 42) ^ v2) == v2)) ^ v4)))();
}

uint64_t sub_100056448()
{
  int v0;
  int v1;
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  return (*(uint64_t (**)(void))(v5
                              + 8
                              * ((578
                                * ((v1 & (2 * (*(unsigned __int8 *)(v4 + 1) - 134)))
                                 + (v3 ^ (v0 - 180) ^ (*(unsigned __int8 *)(v4 + 1) - 134)) == v0)) | v2)))();
}

uint64_t sub_100056480()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  return (*(uint64_t (**)(void))(v5
                              + 8
                              * (v2 ^ (8
                                     * ((v1 & (2 * (*(unsigned __int8 *)(v3 + 2) - 72)))
                                      + ((*(unsigned __int8 *)(v3 + 2) - 72) ^ v0) == ((v2 + 19) ^ v4))))))();
}

uint64_t sub_1000564B0()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * ((1633
                                * ((((*(unsigned __int8 *)(v3 + 3) - 134) << ((v2 ^ 0x15) + 77)) & v1)
                                 + ((*(unsigned __int8 *)(v3 + 3) - 134) ^ v0) == v0)) ^ v2)))();
}

uint64_t sub_1000564F0()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  return (*(uint64_t (**)(void))(v5
                              + 8
                              * ((947
                                * ((v1 & (2 * (*(unsigned __int8 *)(v3 + 4) - 247)))
                                 + ((6 * (v2 ^ 0xBF)) ^ v4 ^ (*(unsigned __int8 *)(v3 + 4) - 247)) == v0)) ^ v2)))();
}

uint64_t sub_100056534()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;

  v5 = ((v2 - 629422573) & 0x258439FF ^ 0xFFFFFF47) + *(unsigned __int8 *)(v3 + 5);
  return (*(uint64_t (**)(void))(v4 + 8 * ((509 * ((v1 & (2 * v5)) + (v5 ^ v0) == v0)) ^ v2)))();
}

uint64_t sub_100056584()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  return (*(uint64_t (**)(void))(v5
                              + 8
                              * ((1568
                                * ((v1 & (2 * (*(unsigned __int8 *)(v3 + 6) - 1)))
                                 + ((15 * (v2 ^ 0xAD)) ^ v4 ^ (*(unsigned __int8 *)(v3 + 6) - 1)) == v0)) ^ v2)))();
}

uint64_t sub_1000565C8()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  return (*(uint64_t (**)(void))(v5
                              + 8
                              * ((415
                                * ((v1 & (2 * (*(unsigned __int8 *)(v3 + 7) - 1)))
                                 + ((*(unsigned __int8 *)(v3 + 7) - 1) ^ v0) == ((v2 - 895235757) & 0x355C36BF ^ v4))) ^ v2)))();
}

uint64_t sub_100056614()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;

  v5 = ((v2 + 1495530076) & 0xA6DC05B6 ^ 0xFFFFFF41) + *(unsigned __int8 *)(v3 + 8);
  return (*(uint64_t (**)(void))(v4 + 8 * ((1757 * (((v5 << v2) & v1) + (v5 ^ v0) == v0)) ^ v2)))();
}

void sub_10005666C()
{
  int v0;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;

  *(_DWORD *)(*(_QWORD *)(v2 + 96) + 1428) = 1373296703;
  v6 = v0 + 994;
  v4 = 235795823 * ((((v3 - 120) ^ 0x256BA31D) & 0xF7DF73A9 | ~((v3 - 120) ^ 0x256BA31D | 0xF7DF73A9)) ^ 0xB9E66612);
  *(_DWORD *)(v3 - 112) = (-33143855 - 2 * ((((v0 + 522727186) & 0xE0D7D2BB) - 639) & 0x7E0643CF ^ 1)) ^ v4;
  *(_DWORD *)(v3 - 108) = v4 + v0 + 426522837;
  *(_QWORD *)(v3 - 120) = &STACK[0x73F39308AC2F33DB];
  v5 = (v0 + 522727186) ^ 0x1F282E62;
  sub_10002D8CC(v3 - 120);
  __asm { BR              X10 }
}

uint64_t sub_1000568C8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int a7)
{
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;

  v11 = v8 - 502529979;
  if (v11 <= 0x40)
    v11 = 64;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10
                                        + 8
                                        * ((733
                                          * (a5 - v7 - v9 + ((a7 - 1950396841) & 0xFCDCFBFF) - a6 + 1519 + v11 > 0xE)) ^ a7))
                            - 12))();
}

uint64_t sub_100056954(int a1, int a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  int v9;
  int v10;
  int v11;
  uint64_t v12;
  int v13;
  unsigned int v14;

  v13 = v9 + v8;
  v14 = v13 + v10 + ((a2 - 1483) | 0x180);
  if (v14 <= 0x40)
    v14 = a3;
  return ((uint64_t (*)(void))(*(_QWORD *)(v12
                                        + 8
                                        * ((992 * (a5 - v13 + 1519 >= v11 + a1 + a2 - a8 - 939 - 1789414464 + v14)) ^ a2))
                            - 8))();
}

uint64_t sub_1000569B8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,char a25)
{
  int v25;
  int v26;
  int v27;
  uint64_t v28;

  return ((uint64_t (*)(void))(*(_QWORD *)(v28
                                        + 8
                                        * ((88
                                          * ((((unint64_t)(&a25 + a14 + (v26 + v25 + 419)) < 0x10) ^ (v27 - 1)) & 1)) ^ v27))
                            + 2291944431
                            - (a6 + v27 - 420)))();
}

uint64_t sub_100056A10@<X0>(int a1@<W8>)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int8x16_t *v6;
  int8x16_t v7;
  int8x16_t v8;

  v7.i64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v7.i64[1] = 0xFCFCFCFCFCFCFCFCLL;
  v8.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v8.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  *(int8x16_t *)(v2 + a1 + (v4 ^ (v1 + 92))) = vaddq_s8(vsubq_s8(*v6, vandq_s8(vaddq_s8(*v6, *v6), v7)), v8);
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((1922 * (((v3 + 1) & 0x1FFFFFFF0) == 16)) ^ (v4 + 506))) - 4))();
}

void sub_100056A7C()
{
  JUMPOUT(0x100056A3CLL);
}

uint64_t sub_100056A88(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;

  return ((uint64_t (*)(void))(*(_QWORD *)(v11 + 8 * (((a8 + a6 + v10 - 420 + 417) * (v8 == v9)) ^ v10))
                            - ((v10 - a8 + 160) ^ 0x889C4BF7)))();
}

uint64_t sub_100056AD4@<X0>(int a1@<W3>, int a2@<W7>, int a3@<W8>, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, int a19, char a20)
{
  int v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  *(&a20 + (a3 + v20)) = *(_BYTE *)(v21 + v24 - 1434071027)
                                     - ((2 * *(_BYTE *)(v21 + v24 - 1434071027)) & 0xFC)
                                     - 2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v23
                                        + 8
                                        * ((((a1 + a3 + 1) < 0x40) | (2
                                                                                  * ((a1 + a3 + 1) < 0x40))) ^ (a2 + v22 - 3)))
                            - 12))();
}

uint64_t sub_100056B3C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,int32x4_t a37,int32x4_t a38,int32x4_t a39,int32x4_t a40)
{
  int v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t (*v48)(__n128, __n128, __n128, __n128, __n128);
  __n128 v49;
  __n128 v50;
  __n128 v51;
  __n128 v52;
  __n128 v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  int v57;
  uint8x16_t v58;
  uint16x8_t v59;
  int8x16_t v60;
  int8x16_t v61;
  uint16x8_t v62;
  int8x16_t v63;
  int8x16_t v64;
  uint8x16_t v65;
  uint16x8_t v66;
  uint16x8_t v67;
  uint8x16_t v68;
  int8x16_t v71;
  int8x16_t v76;
  int32x4_t v77;
  int32x4_t v78;
  int32x4_t v79;
  int32x4_t v80;
  uint64_t v81;
  int v82;
  uint64_t (*v83)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t, uint64_t (*)(__n128, __n128, __n128, __n128, __n128), uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint8x16_t v85;
  uint16x8_t v86;
  uint16x8_t v87;
  uint8x16_t v88;
  uint8x16_t v93;
  uint16x8_t v94;
  uint16x8_t v95;
  int32x4_t v96;
  int32x4_t v97;
  int32x4_t v98;
  int32x4_t v99;
  _DWORD *v100;
  int v101;
  int v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int8x16x4_t v108;
  int8x16x4_t v109;

  v104 = v41;
  v48 = (uint64_t (*)(__n128, __n128, __n128, __n128, __n128))(*(_QWORD *)(v42 + 8 * (a8 + v40 - 502)) - 8);
  v49.n128_u64[0] = 0xFEFEFEFEFEFEFEFELL;
  v49.n128_u64[1] = 0xFEFEFEFEFEFEFEFELL;
  v50 = (__n128)vdupq_n_s32(0x1D30BEEEu);
  v51 = (__n128)vdupq_n_s32(0x1D30BEE6u);
  v107 = v47 - 16;
  HIDWORD(v105) = a6 + 546720471;
  LODWORD(v106) = 326563401;
  v52.n128_u64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v52.n128_u64[1] = 0xFCFCFCFCFCFCFCFCLL;
  v53 = (__n128)vdupq_n_s32(0x1D30BEFFu);
  v54 = HIDWORD(a33);
  v55 = HIDWORD(a34);
  v56 = BYTE4(a36) ^ 0xE;
  if (v56 == 2)
  {
    v109 = vld4q_s8((const char *)&a24 + 4);
    v85 = (uint8x16_t)veorq_s8(v109.val[0], (int8x16_t)v49);
    v86 = vmovl_u8(*(uint8x8_t *)v85.i8);
    v87 = vmovl_high_u8(v85);
    v88 = (uint8x16_t)veorq_s8(v109.val[1], (int8x16_t)v49);
    _Q22 = vmovl_u8(*(uint8x8_t *)v88.i8);
    _Q21 = vmovl_high_u8(v88);
    __asm
    {
      SHLL2           V23.4S, V21.8H, #0x10
      SHLL2           V24.4S, V22.8H, #0x10
    }
    v93 = (uint8x16_t)veorq_s8(v109.val[2], (int8x16_t)v49);
    v94 = vmovl_high_u8(v93);
    v95 = vmovl_u8(*(uint8x8_t *)v93.i8);
    v109.val[0] = veorq_s8(v109.val[3], (int8x16_t)v49);
    v109.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v109.val[0]);
    v109.val[2] = (int8x16_t)vmovl_high_u16((uint16x8_t)v109.val[1]);
    v109.val[1] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v109.val[1].i8);
    v109.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v109.val[0].i8);
    v109.val[3] = (int8x16_t)vmovl_high_u16((uint16x8_t)v109.val[0]);
    v109.val[0] = (int8x16_t)vmovl_u16(*(uint16x4_t *)v109.val[0].i8);
    v96 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q22.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v95.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v86.i8), 0x18uLL)), v109.val[0]);
    v97 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8(_Q24, (int8x16_t)vshll_high_n_u16(v95, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v86), 0x18uLL)), v109.val[3]);
    v98 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8((int8x16_t)vshll_n_s16(*(int16x4_t *)_Q21.i8, 0x10uLL), (int8x16_t)vshll_n_u16(*(uint16x4_t *)v94.i8, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v87.i8), 0x18uLL)), v109.val[1]);
    v99 = (int32x4_t)vorrq_s8(vorrq_s8(vorrq_s8(_Q23, (int8x16_t)vshll_high_n_u16(v94, 8uLL)), (int8x16_t)vshlq_n_s32((int32x4_t)vmovl_high_u16(v87), 0x18uLL)), v109.val[2]);
    v109.val[0] = veorq_s8(vandq_s8((int8x16_t)v96, (int8x16_t)v50), (int8x16_t)(*(_OWORD *)v109.val & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v109.val[3] = veorq_s8(vandq_s8((int8x16_t)v97, (int8x16_t)v50), (int8x16_t)(*(_OWORD *)&v109.val[3] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v109.val[1] = veorq_s8(vandq_s8((int8x16_t)v98, (int8x16_t)v50), (int8x16_t)(*(_OWORD *)&v109.val[1] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    v109.val[2] = veorq_s8(vandq_s8((int8x16_t)v99, (int8x16_t)v50), (int8x16_t)(*(_OWORD *)&v109.val[2] & __PAIR128__(0xFFFFFF08FFFFFF08, 0xFFFFFF08FFFFFF08)));
    a39 = vaddq_s32(vsubq_s32(v98, vaddq_s32((int32x4_t)v109.val[1], (int32x4_t)v109.val[1])), (int32x4_t)v51);
    a40 = vaddq_s32(vsubq_s32(v99, vaddq_s32((int32x4_t)v109.val[2], (int32x4_t)v109.val[2])), (int32x4_t)v51);
    a37 = vaddq_s32(vsubq_s32(v96, vaddq_s32((int32x4_t)v109.val[0], (int32x4_t)v109.val[0])), (int32x4_t)v51);
    a38 = vaddq_s32(vsubq_s32(v97, vaddq_s32((int32x4_t)v109.val[3], (int32x4_t)v109.val[3])), (int32x4_t)v51);
    v100 = (_DWORD *)&a37 + v46 + 1653984181;
    v101 = *(v100 - 8) ^ *(v100 - 3);
    v102 = *(v100 - 16) ^ *(v100 - 14) ^ (v101 + v44 - ((2 * v101) & 0x3A617DCC));
    HIDWORD(v103) = v102 ^ v44;
    LODWORD(v103) = v102;
    *v100 = (v103 >> 31) + v44 - ((2 * (v103 >> 31)) & 0x3A617DCC);
    return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v42
                                                                                  + 8
                                                                                  * (((4 * (v47 != 1653984118)) | (16 * (v47 != 1653984118))) ^ (163 * (a6 ^ (a6 - 3))))))(v107, v54, 783, 1928, v55);
  }
  else if (v56 == 1)
  {
    v108 = vld4q_s8((const char *)&a24 + 4);
    v57 = a8 + a6 + 798;
    v58 = (uint8x16_t)veorq_s8(v108.val[0], (int8x16_t)v49);
    v59 = vmovl_u8(*(uint8x8_t *)v58.i8);
    v60 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v59.i8);
    v61 = (int8x16_t)vmovl_high_u16(v59);
    v62 = vmovl_high_u8(v58);
    v63 = (int8x16_t)vmovl_u16(*(uint16x4_t *)v62.i8);
    v64 = (int8x16_t)vmovl_high_u16(v62);
    v65 = (uint8x16_t)veorq_s8(v108.val[1], (int8x16_t)v49);
    v66 = vmovl_high_u8(v65);
    v67 = vmovl_u8(*(uint8x8_t *)v65.i8);
    v68 = (uint8x16_t)veorq_s8(v108.val[2], (int8x16_t)v49);
    _Q26 = (int8x16_t)vmovl_high_u8(v68);
    _Q25 = (int8x16_t)vmovl_u8(*(uint8x8_t *)v68.i8);
    v71 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q25.i8, 0x10uLL);
    __asm { SHLL2           V25.4S, V25.8H, #0x10 }
    v76 = (int8x16_t)vshll_n_s16(*(int16x4_t *)_Q26.i8, 0x10uLL);
    __asm { SHLL2           V26.4S, V26.8H, #0x10 }
    v108.val[0] = veorq_s8(v108.val[3], (int8x16_t)v49);
    v108.val[1] = (int8x16_t)vmovl_high_u8((uint8x16_t)v108.val[0]);
    v108.val[2] = (int8x16_t)vmovl_high_u16((uint16x8_t)v108.val[1]);
    v108.val[0] = (int8x16_t)vmovl_u8(*(uint8x8_t *)v108.val[0].i8);
    v108.val[3] = (int8x16_t)vmovl_high_u16((uint16x8_t)v108.val[0]);
    v108.val[0] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v108.val[0].i8), 0x18uLL), v71), vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v67.i8, 8uLL), v60));
    v108.val[3] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)v108.val[3], 0x18uLL), _Q25), vorrq_s8((int8x16_t)vshll_high_n_u16(v67, 8uLL), v61));
    v108.val[1] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)v108.val[1].i8), 0x18uLL), v76), vorrq_s8((int8x16_t)vshll_n_u16(*(uint16x4_t *)v66.i8, 8uLL), v63));
    v108.val[2] = vorrq_s8(vorrq_s8((int8x16_t)vshlq_n_s32((int32x4_t)v108.val[2], 0x18uLL), _Q26), vorrq_s8((int8x16_t)vshll_high_n_u16(v66, 8uLL), v64));
    v77 = (int32x4_t)veorq_s8(vandq_s8(v108.val[0], (int8x16_t)v53), (int8x16_t)(*(_OWORD *)&v60 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v78 = (int32x4_t)veorq_s8(vandq_s8(v108.val[3], (int8x16_t)v53), (int8x16_t)(*(_OWORD *)&v61 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v79 = (int32x4_t)veorq_s8(vandq_s8(v108.val[1], (int8x16_t)v53), (int8x16_t)(*(_OWORD *)&v63 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    v80 = (int32x4_t)veorq_s8(vandq_s8(v108.val[2], (int8x16_t)v53), (int8x16_t)(*(_OWORD *)&v64 & __PAIR128__(0xFFFFFF19FFFFFF19, 0xFFFFFF19FFFFFF19)));
    a39 = vaddq_s32(vsubq_s32((int32x4_t)v108.val[1], vaddq_s32(v79, v79)), (int32x4_t)v51);
    a40 = vaddq_s32(vsubq_s32((int32x4_t)v108.val[2], vaddq_s32(v80, v80)), (int32x4_t)v51);
    a37 = vaddq_s32(vsubq_s32((int32x4_t)v108.val[0], vaddq_s32(v77, v77)), (int32x4_t)v51);
    a38 = vaddq_s32(vsubq_s32((int32x4_t)v108.val[3], vaddq_s32(v78, v78)), (int32x4_t)v51);
    v81 = ((a8 + a6 - 303) ^ (unint64_t)(v46 + 243)) + v107;
    v82 = (HIDWORD(a33) ^ v43)
        - 460997464
        + ((HIDWORD(a34) ^ v43) & (a34 ^ v43) | (a34 ^ 0x9EE7D1CA) & (a35 ^ v43))
        + *((_DWORD *)*(&off_100180420 + v57 - 1273) + v81 - 3)
        + (a37.i32[(*((_BYTE *)*(&off_100180420 + v57 - 1298) + v81 - 4) - 55)] ^ v44);
    LOBYTE(v81) = *((_BYTE *)*(&off_100180420 + v57 - 1242) + v81 - 8) - 113;
    v83 = (uint64_t (*)(uint64_t, _QWORD, uint64_t, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, unint64_t, unint64_t, uint64_t (*)(__n128, __n128, __n128, __n128, __n128), uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v42 + 8 * v57) - 4);
    LODWORD(v105) = BYTE4(a36) ^ 0xE;
    HIDWORD(v106) = HIDWORD(a13) - 1277714437;
    return v83(v47 - 15, a35, 1653984181, v83, HIDWORD(a34), ((v82 + v43 - (v45 & (2 * v82))) ^ v43) << v81, a34, -v81, a9, a10, a11, a12, a13, a14, v104, a16, v105, v106, __PAIR64__(a34, HIDWORD(a33)),
             __PAIR64__(a35, HIDWORD(a34)),
             v48,
             v47 - 16,
             a23,
             a24,
             a25,
             a26,
             a27,
             a28,
             a29,
             a30,
             a31,
             a32,
             a33,
             a34,
             a35,
             a36);
  }
  else
  {
    HIDWORD(a33) = 2 * (HIDWORD(a33) ^ v43) + v43 - (v45 & (4 * (HIDWORD(a33) ^ v43)));
    LODWORD(a34) = 2 * (a34 ^ v43) + v43 - (v45 & (4 * (a34 ^ v43)));
    HIDWORD(a34) = v43 + 2 * (HIDWORD(a34) ^ v43) - (v45 & (4 * (HIDWORD(a34) ^ v43)));
    LODWORD(a35) = 2 * (a35 ^ v43) + v43 - (v45 & (4 * (a35 ^ v43)));
    return v48(v49, v50, v51, v52, v53);
  }
}

void sub_100056BEC()
{
  JUMPOUT(0x100056C08);
}

void sub_100056E78()
{
  JUMPOUT(0x100056D7CLL);
}

uint64_t sub_100056E84@<X0>(uint64_t a1@<X2>, int a2@<W8>)
{
  uint64_t v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((1151 * (a1 + 1 != v3 + 16)) ^ a2)) - 4))();
}

uint64_t sub_100056F64(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((482 * (a1 + 1 != v3 + 32)) ^ v1)) - 4))();
}

uint64_t sub_100057024(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;

  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * ((1619 * (a8 + 1 == v10 + 48)) ^ v8)) - 4))();
}

void sub_100057110()
{
  JUMPOUT(0x100057684);
}

uint64_t sub_1000572F4(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;

  return (*(uint64_t (**)(void))(v2 + 8 * ((1692 * (a1 + 1 == v3 + 4)) ^ v1)))();
}

uint64_t sub_1000573CC@<X0>(int a1@<W1>, uint64_t a2@<X2>, int a3@<W4>, int a4@<W7>, int a5@<W8>)
{
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;

  HIDWORD(v15) = a1 ^ v8;
  LODWORD(v15) = a1 ^ 0x60000000;
  v16 = (v15 >> 27)
      + (a5 ^ v10)
      + (((a3 ^ v7) + v10 - (((a3 ^ v7) << ((2 * v6) ^ 0xEB)) & v12)) ^ a4)
      + (*(_DWORD *)(v5 + 4 * (a2 + v13)) ^ v11);
  return (*(uint64_t (**)(_QWORD, _QWORD))(v9 + 8 * ((3921 * (a2 + 1 == v14 + 24)) ^ v6)))((2 * v6) ^ 0x944u, v16 - ((2 * v16 - 575416510) & v12) - 806217258);
}

uint64_t sub_100057494(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * ((31 * (a7 + 1 != v8 + 44)) ^ a1)) - 8))();
}

uint64_t sub_100057564@<X0>(uint64_t a1@<X8>)
{
  int v1;
  uint64_t v2;
  uint64_t v3;

  return (*(uint64_t (**)(void))(v2 + 8 * ((71 * (a1 + 1 == v3 + 64)) ^ v1)))();
}

void sub_100057634()
{
  JUMPOUT(0x100057680);
}

uint64_t sub_100057700(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, uint64_t a16, int a17, int a18, unsigned int a19, unsigned int a20)
{
  uint64_t v20;
  _BOOL4 v21;

  if (a20 < a19 != a15 - 1107507562 < (a18 & 0x56CD6BAF ^ 0x1376F4CBu))
    v21 = a15 - 1107507562 < (a18 & 0x56CD6BAF ^ 0x1376F4CBu);
  else
    v21 = a15 - 1107507562 > a20;
  return ((uint64_t (*)(void))(*(_QWORD *)(v20 + 8 * ((!v21 | (32 * !v21)) ^ (a8 + a6 + 594))) - 8))();
}

uint64_t sub_100057788(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5, int a6)
{
  int v6;
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(uint64_t, uint64_t))(*(_QWORD *)(v8
                                                               + 8
                                                               * ((2042 * (v6 + 568951889 + a6 + a3 - 783 >= v6 + v7)) ^ a3))
                                                   - 4))(a1, 52);
}

uint64_t sub_1000577D0@<X0>(unsigned int a1@<W2>, unsigned __int8 a2@<W8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  return ((uint64_t (*)(void))(*(_QWORD *)(v10
                                        + 8 * ((22 * ((((unint64_t)(a8 + v8 - v9) < 0x10) ^ a2) & 1)) ^ a1))
                            - 4))();
}

uint64_t sub_100057808@<X0>(unint64_t a1@<X1>, int a2@<W5>, int a3@<W7>, int a4@<W8>, int8x16_t a5@<Q0>, int8x16_t a6@<Q3>)
{
  int v6;
  int8x16_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;

  *v7 = vaddq_s8(vsubq_s8(*(int8x16_t *)(v10 + (v6 + v8)), vandq_s8(vaddq_s8(*(int8x16_t *)(v10 + (v6 + v8)), *(int8x16_t *)(v10 + (v6 + v8))), a6)), a5);
  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * (a3 + a4 + 136)) - ((10 * (a4 ^ (a2 + 2))) ^ a1)))();
}

uint64_t sub_100057870@<X0>(int a1@<W4>, int a2@<W5>, int a3@<W7>, int a4@<W8>)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;

  *(_BYTE *)(v6 + v5) = *(_BYTE *)(v9 + (v4 + v7))
                      - ((2 * *(_BYTE *)(v9 + (v4 + v7))) & 0xFC)
                      - 2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v8
                                        + 8
                                        * (((v5 + 4 * (a4 ^ (a2 - 7)) == 123) * a1) ^ (a3 + a4 + 707)))
                            - 8))();
}

uint64_t sub_1000578CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14)
{
  int v14;
  uint64_t v15;
  int v16;
  _BOOL4 v17;

  v17 = v14 - 2127134125 < (a14 + 1997626360);
  if ((a14 + 1997626360) < 0xD6B0B246 != (v14 - 2127134125) < 0xD6B0B246)
    v17 = (a14 + 1997626360) < 0xD6B0B246;
  return ((uint64_t (*)(void))(*(_QWORD *)(v15 + 8 * ((393 * !v17) ^ v16)) - 8))();
}

uint64_t sub_100057948(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,int a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,int a35)
{
  uint64_t v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  int v41;
  int v43;

  v43 = a2 ^ 0x32;
  v41 = 173 * (a2 ^ 0x32);
  v37 = 831981571 * ((2 * ((v36 - 120) & 0x62362E68) - (v36 - 120) - 1647717994) ^ 0x46801B2);
  *(_DWORD *)(v36 - 120) = (a14 + 5614872) ^ v37;
  *(_DWORD *)(v36 - 116) = v37 + a2 + 1290;
  *(_QWORD *)(v36 - 112) = a11;
  v38 = sub_10005533C(v36 - 120);
  v39 = a35 & (v43 + 61);
  *(&a26 + (v39 ^ 0x15)) = 126;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v35
                                                      + 8 * ((1965 * ((v39 ^ 0x15) > v41 - 291)) ^ a2))
                                          - 4))(v38);
}

uint64_t sub_100057A58(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v6;
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * (v7 ^ (202 * (v6 != 63))))
                            - ((a6 + v7 - 346) ^ (a6 - 246) ^ 0xF2)))();
}

uint64_t sub_100057A90(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  int v9;
  uint64_t v10;

  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * (v9 ^ (488 * ((v8 ^ 0x2Au) < 8))))
                            + 2291944431
                            - (((v9 - 1004954913) & 0x3BE667FEu)
                             - a8
                             - 408)
                            + 4))();
}

uint64_t sub_100057AEC@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, int a17, char a18)
{
  char v18;
  unsigned int v19;
  uint64_t v20;

  *(_QWORD *)(&a18 + a1 - 1385208810) = 0xFEFEFEFEFEFEFEFELL;
  return (*(uint64_t (**)(void))(v20 + 8 * ((((v18 & 0x38) == 8) * (v19 ^ 0x622)) ^ v19)))();
}

uint64_t sub_100057B3C(double a1)
{
  unsigned int v1;
  double *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  *v2 = a1;
  return (*(uint64_t (**)(void))(v5 + 8 * (((v4 == 0) * v3) ^ v1)))();
}

uint64_t sub_100057B5C@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (int)(((((a1 + 143130778) | 0x80144A4B)
                                                + ((a1 + 143149309) | 0x801401E8)
                                                - 288919858)
                                               * (v2 == v1)) ^ a1))
                            - 8))();
}

void sub_100057BC0()
{
  JUMPOUT(0x100056C08);
}

uint64_t sub_100057BD0@<X0>(int a1@<W0>, int a2@<W8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, char a19)
{
  int v19;
  unsigned int v20;
  int v21;
  unsigned int v22;
  int v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  _BOOL4 v29;

  *(&a19 + (a2 - 502519068)) = *(_BYTE *)(v26 + (v19 + v23))
                                           - ((2 * *(_BYTE *)(v26 + (v19 + v23))) & 0xFC)
                                           - 2;
  v27 = v19 + 1 + a1;
  v28 = (v20 < v22) ^ (v27 < v22);
  v29 = v27 < v20;
  if (v28)
    v29 = v20 < v22;
  return ((uint64_t (*)(void))(*(_QWORD *)(v24 + 8 * ((!v29 * v21) ^ v25)) - 8))();
}

uint64_t sub_100057C50@<X0>(int a1@<W5>, int a2@<W7>, int a3@<W8>)
{
  uint64_t v3;
  int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * ((799 * ((v4 - a1 + 1893 + a3 - 1385210703) < 0x38)) ^ (a2 + v4 - 310)))
                            - 4))();
}

uint64_t sub_100057C90@<X0>(int a1@<W5>, unsigned int a2@<W8>)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v4 = a2;
  v5 = a2 - 1385208810 + ((v2 - 985526160) & 0x3ABDEEFB) - 1744;
  if (v5 <= 0x38)
    v5 = 56;
  return (*(uint64_t (**)(void))(v3
                              + 8 * (((v5 - v4 + 1385208810 < 8) * ((v2 - 985526160) ^ 0x4DDE5C2E ^ (a1 - 12))) ^ v2)))();
}

uint64_t sub_100057D0C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,char a25)
{
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  *(_QWORD *)(&a25 + v27 - 1385208810) = 0xFEFEFEFEFEFEFEFELL;
  return ((uint64_t (*)(void))(*(_QWORD *)(v28 + 8 * ((((v26 & 0xFFFFFFFFFFFFFFF8) == 8) * (v25 ^ 0x71C)) ^ v25))
                            - 12))();
}

uint64_t sub_100057D60(double a1)
{
  unsigned int v1;
  double *v2;
  int v3;
  uint64_t v4;
  uint64_t v5;

  *v2 = a1;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * (((v4 == 0) * v3) ^ v1)) - 12))();
}

uint64_t sub_100057D84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;

  return ((uint64_t (*)(void))(*(_QWORD *)(v9
                                        + 8
                                        * (int)(((a6 + v8 + ((v8 - 1663144210) & 0xEBBDDBFF ^ 0xFFFFFFF3) - 269)
                                               * (v6 == v7)) ^ v8))
                            - 4))();
}

void sub_100057DD0()
{
  JUMPOUT(0x100056C08);
}

uint64_t sub_100058284(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, char a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,int a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,int a37)
{
  int v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  _BOOL4 v44;

  v42 = v40 + v37;
  v43 = *(_DWORD *)(&a25 + ((v40 + v37) & 0xFFFFFFFC) + 72);
  *(_BYTE *)(a2 + v42 + 1) = (BYTE2(v43) ^ 0x18) + ((v43 >> 15) & 0xFC ^ 0xCF) - 1;
  *(_BYTE *)(a2 + v42 + 2) = (BYTE1(v43) ^ 0x2E) - ((2 * (BYTE1(v43) ^ 0x2E)) & 0xFC) - 2;
  *(_BYTE *)(a2 + v42) = (HIBYTE(v43) ^ 0x61)
                       + ((v39 - a8) ^ 4)
                       + ((2 * ((HIBYTE(v43) ^ 0x61 | 0x7E) ^ HIBYTE(v43))) ^ 0xC1);
  *(_BYTE *)(a2 + v42 + 3) = v43 ^ 0xCB;
  v44 = v40 + 1986907766 < (a37 + 1172283898);
  if (v40 + 1986907766 < v38 != a37 + 1172283898 < v38)
    v44 = a37 + 1172283898 < v38;
  return ((uint64_t (*)(void))(*(_QWORD *)(v41 + 8 * ((204 * v44) ^ v39)) - 4))();
}

void sub_100058434()
{
  JUMPOUT(0x1000583ECLL);
}

void sub_10005843C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __asm { BR              X8 }
}

uint64_t sub_1000584B8(uint64_t a1, int a2)
{
  uint64_t v2;
  BOOL v3;
  int v4;

  if (a1)
    v3 = a2 == 0;
  else
    v3 = 0;
  v4 = v3;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((8 * v4) | 0x2D3u)) - 12))();
}

uint64_t sub_100058504(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, unsigned int a14)
{
  int v14;
  uint64_t v15;
  int v16;
  uint64_t v17;

  a14 = v16
      + 1178560073 * ((2 * (&a13 & 0xFF65FB8) - &a13 + 1879679046) ^ 0x973C822E)
      - 1501686575;
  v17 = sub_100074AF8(&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v15 + 8 * ((1671 * (a13 == (v16 ^ v14))) ^ v16)) - 12))(v17);
}

uint64_t sub_100058584(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t *a13, unsigned int a14, int a15)
{
  int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  a13 = &STACK[0x82D647BA4E69FE1];
  a14 = (v17 - 596) ^ (831981571 * (((&a13 | 0x8187B219) - (&a13 & 0x8187B219)) ^ 0x1826623D));
  sub_1000344DC((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(2392068377
                                                                              - (v17 - 1902899638)
                                                                              + *(_QWORD *)(v16
                                                                                          + 8
                                                                                          * ((45
                                                                                            * (a15 == v15 + v17 + 817 - 867)) ^ v17))))(v18, v19, v20, v21, v22);
}

uint64_t sub_100058634(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15, uint64_t a16, int a17)
{
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  uint64_t v24;

  v23 = 69008221 * ((&a13 & 0x3E414D53 | ~(&a13 | 0x3E414D53)) ^ 0x121CE0A6);
  a16 = a12;
  a17 = (((2 * v18) & 0x1FFFBFF8) - 52219972 + ((((v22 - 1567712045) & 0x5D715FFB) + 268426529) ^ v18)) ^ v23;
  a13 = v17;
  a15 = v23 + v22 - 522;
  v24 = ((uint64_t (*)(uint64_t *))(*(_QWORD *)(v20 + 8 * (v22 ^ 0x621)) - 8))(&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v21 + 8 * ((29 * (a14 == v19 + 681)) ^ v22)) - 4))(v24);
}

uint64_t sub_10005871C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int a13, int a14, int a15, uint64_t a16, unint64_t *a17, int a18)
{
  int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t v22;

  v21 = 1224239923
      * (((&a13 | 0x2599EE82) - &a13 + (&a13 & 0xDA661178)) ^ 0xD72A1355);
  a16 = a12;
  a17 = &STACK[0x72F2C1D3322B87F0];
  a15 = v21 ^ 0x7AAC1B42;
  a13 = v21 ^ 0x12B68929;
  a14 = (v20 + 368398629) ^ v21;
  v22 = sub_100074BB8((uint64_t)&a13);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v19
                                                      + 8
                                                      * (((a18 == ((v20 + 845365711) & 0xCD9CBAFF ^ v18))
                                                        * (((v20 - 418) | 0x190) - 1122)) ^ v20))
                                          - 4))(v22);
}

uint64_t sub_1000587FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12, uint64_t a13, unint64_t *a14, uint64_t a15, unsigned int a16)
{
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  a16 = v16 - 944348131 * ((2 * (&a14 & 0xA75C168) - &a14 + 1971994257) ^ 0xD6939ADF) - 1012;
  a14 = &STACK[0x20BA795F69D3FC5];
  a15 = a10;
  v19 = ((uint64_t (*)(unint64_t **))(*(_QWORD *)(v17 + 8 * (v16 & 0x73EA20EA)) - 8))(&a14);
  return (*(uint64_t (**)(uint64_t))(v18 + 8 * ((1020 * (a12 == v16 + 489732332)) ^ v16)))(v19);
}

uint64_t sub_1000588B8()
{
  uint64_t v0;
  void (*v1)(uint64_t *);
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;

  v13 = v0;
  v10 = 0x13240EAB5AFDBE9DLL;
  v11 = v7;
  v12 = v4
      + 1178560073 * ((2 * (&v10 & 0xE19D760) - &v10 - 236574567) ^ 0x16D30AF1)
      + v5
      + 152;
  ((void (*)(uint64_t *))(*(_QWORD *)(v3 + 8 * (int)(v5 ^ 0x8E9411CA)) - 4))(&v10);
  v10 = v7;
  LODWORD(v11) = v4
               - 241568881 * ((2 * (&v10 & 0x242697B0) - &v10 - 606508978) ^ 0xDC86C0C)
               + v5
               + 430;
  sub_10005A5D8((uint64_t)&v10);
  v11 = v7;
  LODWORD(v10) = (v5 + 1902899059) ^ (69008221
                                    * ((2 * (&v10 & 0x7906D9E0) - &v10 + 116991516) ^ 0xD55B7416));
  v1(&v10);
  LODWORD(v10) = (17 * (v5 ^ 0x8E94110E) - 579) ^ (69008221
                                                 * ((((2 * &v10) | 0x85777BEA)
                                                   - &v10
                                                   - 1119600117) ^ 0x9119EFFF));
  v11 = v9;
  v1(&v10);
  return v8 ^ (v2 + 681);
}

void sub_100058A9C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 32) + 1224239923 * (a1 ^ 0xF2B3FDD7);
  __asm { BR              X14 }
}

void sub_100058B94(uint64_t a1@<X1>, uint64_t a2@<X8>)
{
  *(_DWORD *)(a1 + a2) = 237901512;
}

void sub_100059B48(uint64_t a1)
{
  int v1;

  v1 = 460628867 * (((a1 | 0xB9F12765) - a1 + (a1 & 0x460ED89A)) ^ 0xF567A518);
  __asm { BR              X9 }
}

uint64_t sub_100059BE8@<X0>(int a1@<W6>, uint64_t a2@<X8>)
{
  int v2;

  return (*(uint64_t (**)(void))(a2 + 8 * (((a1 == ((v2 + 812) ^ 0x1622A93B)) * (14 * (v2 ^ 0x1C0) + 320)) ^ v2)))();
}

uint64_t sub_100059C40@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v2;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)(a2 + 8 * (v2 ^ 0x7A6)) - 4))(a1, 1629, 3373224238);
}

uint64_t sub_100059D30@<X0>(int a1@<W4>, int a2@<W6>, uint64_t a3@<X8>)
{
  int v3;
  int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(a3 + 8 * (((a2 != v4 - 557 + v3 + v4 - 727) * a1) ^ v4)) - 8))();
}

uint64_t sub_100059D5C@<X0>(int a1@<W7>, uint64_t a2@<X8>)
{
  int v2;

  return (*(uint64_t (**)(void))(a2 + 8 * ((1528 * ((((a1 + 112) ^ (v2 == 0)) & 1) == 0)) ^ a1)))();
}

uint64_t sub_100059D8C@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  *(_DWORD *)(*(_QWORD *)(v3 - 0x2DB44D49A49B0026) + 4 * (v1 + v2 + 1)) = v5;
  v6 = v2 + v4 - 671;
  *(_DWORD *)(v3 - 0x2DB44D49A49B002ALL) = v6;
  if (v1 + v6 + 1 >= 0)
    v7 = v1 + v6 + 1;
  else
    v7 = ~(v1 + v6);
  v8 = (v7 ^ 0x7F3E57CB) - 1896890627 + ((v7 << (v4 ^ 0xA1)) & 0xFE7CAF96) + v1;
  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * (((v8 >= 0) | (4 * (v8 >= 0))) ^ v4 ^ 0x32))
                            - (((v4 ^ 0x32u) + 683) ^ 0x535)))();
}

uint64_t sub_100059E5C@<X0>(uint64_t a1@<X8>)
{
  int v1;
  _QWORD *v2;
  int v3;
  int v4;
  unsigned int v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * (((*(_DWORD *)(*v2 + 4 * v5) == v1) * v3) ^ v4)) - 8))();
}

uint64_t sub_100059E80@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(a1
                                        + 8
                                        * (((v3 + 9 * (v2 ^ 0x207) - 1342 + v1 >= 0) | (4
                                                                                      * (v3
                                                                                       + 9 * (v2 ^ 0x207)
                                                                                       - 1342
                                                                                       + v1 >= 0))) ^ v2))
                            - ((v2 + 683) ^ 0x535)))();
}

uint64_t sub_100059EC0(uint64_t result)
{
  int v1;
  int v2;
  _DWORD *v3;
  int v4;
  int v5;

  if ((v2 + v1) >= 0x7FFFFFFF)
    v5 = 475803024 - v4;
  else
    v5 = v4;
  *v3 = v5;
  *(_DWORD *)(result + 4) = 360887506;
  return result;
}

uint64_t sub_100059F00(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  _BOOL4 v5;
  _BOOL4 v6;

  v2 = *(_DWORD *)(*(_QWORD *)a1 - 0x2DB44D49A49B002ALL) + 970372953;
  v3 = *(_DWORD *)(*(_QWORD *)(a1 + 16) - 0x2DB44D49A49B002ALL) + 970372953;
  v4 = (v2 < -939209183) ^ (v3 < -939209183);
  v5 = v2 > v3;
  if (v4)
    v6 = v2 < -939209183;
  else
    v6 = v5;
  v1 = *(_DWORD *)(a1 + 24) ^ (69008221 * ((a1 - 1382558880 - 2 * (a1 & 0xAD97D360)) ^ 0x7E35816A));
  return ((uint64_t (*)(void))(*(_QWORD *)((char *)*(&off_100180420 + (v1 ^ 0x5FE)) + 8 * ((906 * !v6) ^ v1) - 4)
                            - ((v1 + 490) ^ 0x79ALL)))();
}

uint64_t sub_100059FE4()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  int v4;
  _BOOL4 v5;
  _BOOL4 v6;

  v4 = v1 - 818262370;
  v5 = v4 < 1567122790;
  v6 = v3 - 818262370 < v4;
  if (v3 - 818262370 < 1567122790 != v5)
    v6 = v5;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * (v2 ^ (57 * !v6))) - ((v2 - 258917216) & 0xF6EBFFF ^ 0x436)))();
}

uint64_t sub_10005A064()
{
  uint64_t v0;
  int v1;
  int v2;
  int v3;
  int v4;

  v3 = v2 + 374;
  if (v1 + 1909582136 <= v2 - 1087)
    v4 = v1;
  else
    v4 = 475803024 - v1;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((3484 * (v4 - 237901513 >= 0)) ^ v3)) - 4))();
}

uint64_t sub_10005A0E8()
{
  uint64_t v0;
  unsigned int v1;
  int v2;
  _QWORD *v3;
  _QWORD *v4;
  unsigned int v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * ((((*(_DWORD *)(*v4 + 4 * v5) ^ v1) <= (*(_DWORD *)(*v3 + 4 * v5) ^ v1))
                                          * ((543 * (v2 ^ 0x5B6)) ^ 0x7A4)) ^ v2))
                            - 4))();
}

uint64_t sub_10005A13C(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t v3;
  unsigned int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (a2 ^ (3074 * (v4 < a3)))) - ((a2 - 1054) | 0x594u) + 1452))();
}

uint64_t sub_10005A16C()
{
  uint64_t v0;
  int v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((3484 * (v2 - 237901513 >= 0)) ^ v1)) - 4))();
}

uint64_t sub_10005A1A0(uint64_t result)
{
  int v1;

  *(_DWORD *)(result + 8) = 325789292 - v1;
  return result;
}

uint64_t sub_10005A1B4(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  BOOL v5;
  unsigned int v6;
  unsigned int v7;

  v1 = 2078219279 * (((a1 | 0x62FDDF9E) - (a1 & 0x62FDDF9E)) ^ 0xB80749EA);
  v2 = *(_DWORD *)(a1 + 16) ^ v1;
  v3 = *(_DWORD *)(a1 + 4) + v1;
  if (v3 < 0)
    v3 = -v3;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 8) - 0x2DB44D49A49B002ALL);
  v6 = v4 - 237901512;
  v5 = v4 - 237901512 < 0;
  v7 = 237901512 - v4;
  if (!v5)
    v7 = v6;
  return ((uint64_t (*)(void))(*(_QWORD *)((char *)*(&off_100180420 + (v2 ^ 0x6C4))
                                        + 8 * ((v3 >> 5 < v7) | (16 * (v3 >> 5 < v7)) | v2)
                                        - 4)
                            - 8))();
}

unsigned int *sub_10005A270@<X0>(unsigned int *result@<X0>, int a2@<W8>)
{
  char v2;
  uint64_t v3;
  unsigned int v4;

  *result = ((*(_DWORD *)(*(_QWORD *)(v3 - 0x2DB44D49A49B0026) + 4 * v4) ^ 0xE487A897) >> v2) & 1 | a2;
  return result;
}

_DWORD *sub_10005A2A8@<X0>(_DWORD *result@<X0>, int a2@<W8>)
{
  *result = a2;
  return result;
}

void sub_10005A2B0(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;
  _DWORD v7[2];
  uint64_t v8;
  int v9;
  unint64_t *v10;
  unint64_t *v11;
  int v12;

  v1 = 944348131 * ((a1 & 0x896AFC50 | ~(a1 | 0x896AFC50)) ^ 0xD58CA7E1);
  v2 = *(_DWORD *)(a1 + 40) - v1;
  v3 = *(_DWORD *)a1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = 69008221 * (((v7 | 0x904891BE) - v7 + (v7 & 0x6FB76E40)) ^ 0x43EAC3B4);
  v6 = (*(_DWORD *)(a1 + 56) ^ v1) - v5;
  v9 = v5 ^ (v2 - 360);
  v12 = v3 - v1 + v5 - 499816963;
  v8 = v4;
  v7[1] = v6 - 720291271;
  v10 = &STACK[0x721003D414281A4A];
  v11 = &STACK[0x7D59DC543B842D48];
  ((void (*)(_DWORD *))*(&off_100180420 + v2 - 640))(v7);
  __asm { BR              X9 }
}

uint64_t sub_10005A444(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, int a11, int a12, uint64_t a13, int a14, uint64_t a15, int a16, uint64_t a17, int a18, uint64_t a19, int a20)
{
  uint64_t v20;
  int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;

  v25 = *(_QWORD *)(v20 + 32);
  v26 = 268847287 * ((270127462 - (&a13 | 0x1019D166) + (&a13 | 0xEFE62E99)) ^ 0x104C3FB1);
  a19 = *(_QWORD *)(v20 + 24);
  a17 = a10;
  a20 = v22 - ((2 * v22 + 1893722436) & 0x51D99EAE) - v26 - 514014215;
  a18 = v23 - v26 + 1695026742;
  a13 = v25;
  a15 = a10;
  a16 = v23 + 87 - v26 + 1617030143 * a12 + 1155256775;
  v27 = sub_100074978((uint64_t)&a13);
  return (*(uint64_t (**)(uint64_t))(v24 + 8 * ((28 * (a14 != v21)) ^ v23)))(v27);
}

uint64_t sub_10005A534()
{
  uint64_t v0;
  uint64_t v1;
  int v2;
  int v3;
  uint64_t result;
  uint64_t v5;
  unsigned int v6;

  result = (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(v1 + 8 * (v3 ^ 0x3F0u)))(**(unsigned int **)(v1 + 8 * (v3 ^ 0x3CCu)), v5, v6);
  *(_DWORD *)(v0 + 16) = v2;
  return result;
}

uint64_t sub_10005A5D8(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 8) + 241568881 * ((-720613086 - (a1 | 0xD50C5122) + (a1 | 0x2AF3AEDD)) ^ 0xFCE2AA9F);
  return (*(uint64_t (**)(void))((char *)*(&off_100180420 + (v1 ^ 0x20C))
                              + 8 * ((52 * (*(_QWORD *)a1 != 0x56428495FB62992)) ^ v1)
                              - 4))();
}

uint64_t sub_10005A670()
{
  int v0;
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v1 + 8 * ((2014 * (*(_DWORD *)(v2 - 0x56428495FB6297ALL) == 489733862)) ^ v0)))();
}

uint64_t sub_10005A6AC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  _BOOL4 v5;
  _BOOL4 v6;

  v3 = *(_DWORD *)(v2 - 0x56428495FB62982) - 1437517598;
  v4 = *(_DWORD *)(v2 - 0x56428495FB62986) - 2039233272;
  v5 = v4 < 0xB1491527;
  v6 = v3 < v4;
  if (v3 < 0xB1491527 != v5)
    v6 = v5;
  return (*(uint64_t (**)(void))(v1 + 8 * ((1327 * v6) ^ v0)))();
}

uint64_t sub_10005A734@<X0>(uint64_t result@<X0>, int a2@<W8>)
{
  _DWORD *v2;

  *v2 = a2;
  *(_DWORD *)(result + 12) = -489691693;
  return result;
}

void sub_10005A748(uint64_t a1)
{
  __asm { BR              X10 }
}

uint64_t sub_10005A7A4(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  _BOOL4 v6;

  v6 = (*(uint64_t (**)(_QWORD, uint64_t))(v2 + 1808))(a2, 1252601147) != 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * ((107 * v6) ^ v4)) - ((v3 + 8) ^ 0xE3DAF5CALL)))();
}

uint64_t sub_10005A7F0(uint64_t a1)
{
  _QWORD *v1;

  *v1 = a1;
  return 0;
}

void sub_10005A80C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 4) ^ (3804331 * (((a1 | 0x72B1B0A3) - a1 + (a1 & 0x8D4E4F5C)) ^ 0xC649555));
  __asm { BR              X9 }
}

uint64_t sub_10005A8B8()
{
  uint64_t v0;
  int v1;
  uint64_t v2;
  _BOOL4 v3;

  v3 = (*(uint64_t (**)(uint64_t, uint64_t))(v0 + 8 * (v1 - 258)))(200, 2354554103) == 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((v3 * (v1 ^ 0x1EC)) | v1)) - 8))();
}

uint64_t sub_10005A8FC(uint64_t a1)
{
  _DWORD *v1;
  int v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;
  int v6;
  uint64_t result;
  int v9;

  result = (*(uint64_t (**)(uint64_t, _QWORD))(v4 + 8 * ((v6 ^ 8) - 367)))(a1, 0);
  if ((_DWORD)result == 16)
  {
    --v2;
    goto LABEL_7;
  }
  if ((_DWORD)result == 12)
  {
LABEL_7:
    result = (*(uint64_t (**)(uint64_t))(v4 + 8 * (v3 ^ 0x1F6)))(a1);
    v9 = v2;
    goto LABEL_8;
  }
  if ((_DWORD)result)
  {
    v2 -= 2;
    goto LABEL_7;
  }
  *v5 = a1;
  v9 = 1943224805;
LABEL_8:
  *v1 = v9 - 1943224805;
  return result;
}

uint64_t sub_10005A984(_DWORD *a1)
{
  unsigned int v2;
  unsigned int v3;
  int v4;
  uint64_t result;
  unsigned int v6;
  uint64_t v7;
  _DWORD v8[2];

  v2 = 1224239923 * (((a1 | 0x1AEAD958) - (_DWORD)a1 + (a1 & 0xE51526A7)) ^ 0xE859248F);
  v3 = a1[5] - v2;
  v4 = *a1 ^ v2;
  v8[1] = v3
        - 1178560073 * (((v8 | 0xB082C97F) - (v8 & 0xB082C97F)) ^ 0x57B7EB17)
        - 1347953141;
  result = nullsub_2(v8);
  if (v4 > 213430694)
  {
    if (v4 == 498643366)
    {
      v6 = 3;
    }
    else
    {
      if (v4 != 213430695)
        goto LABEL_11;
      v6 = 1;
    }
LABEL_10:
    v7 = *(_QWORD *)((char *)*(&off_100180420 + (int)(v3 ^ 0x8FCD8162))
                   + 8
                   * (int)(((((uint64_t (*)(_QWORD, uint64_t))*(&off_100180420 + (int)(v3 ^ 0x8FCD81CA)))((*((_DWORD *)*(&off_100180420 + (int)(v3 ^ 0x8FCD8107)) + 6 * v6 + 4)- 1528691550), 3511634213) == 0)* ((v3 + 1882359051) ^ 0x600)) ^ (v3 + 1882358377))- 4)- 12;
    __asm { BR              X9 }
  }
  if (v4 == 213430691)
  {
    v6 = 0;
    goto LABEL_10;
  }
  if (v4 == 213430694)
  {
    v6 = 2;
    goto LABEL_10;
  }
LABEL_11:
  a1[6] = -489691814;
  return result;
}

void sub_10005AFB8(_DWORD *a1)
{
  unsigned int v1;

  v1 = *a1 + 241568881 * (((_DWORD)a1 - 348976960 - 2 * (a1 & 0xEB3308C0)) ^ 0x3D220C82);
  __asm { BR              X8 }
}

uint64_t sub_10005B06C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, unsigned int a16)
{
  uint64_t v16;
  int v17;
  uint64_t v18;

  a16 = v17
      + 1178560073 * (((~&a15 & 0xD8E99ADE) - (~&a15 | 0xD8E99ADF)) ^ 0x3FDCB8B7)
      - 1501686882;
  v18 = sub_100074AF8(&a15);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v16 + 8 * ((966 * (a15 == 489733862)) ^ v17)) - 8))(v18);
}

uint64_t sub_10005B0E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unint64_t *a15, unsigned int a16, int a17)
{
  uint64_t v17;
  int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  a16 = (v19 - 903) ^ (831981571 * ((&a15 & 0x6D2950CC | ~(&a15 | 0x6D2950CC)) ^ 0xB777F17));
  a15 = &STACK[0x82D647BA4E69FE1];
  sub_1000344DC((uint64_t)&a15);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v17 + 8 * ((992 * (a17 == v18)) ^ v19))
                                                                                                - ((v19 + 344) | 0x19u)
                                                                                                + 1399))(v20, v21, v22, v23, v24, v25, v26);
}

uint64_t sub_10005B184(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, unsigned int a16, uint64_t a17, unsigned int a18)
{
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  void (*v23)(uint64_t *);
  uint64_t v24;
  uint64_t v26;
  uint64_t v27;

  v26 = v18[4];
  v27 = v18[5];
  v22 = v18[1];
  a18 = v21
      - 799
      - 1543737703 * ((-377324932 - (&a15 | 0xE9827A7C) + (&a15 | 0x167D8583)) ^ 0x6889D5FF);
  a17 = a12;
  a15 = v22;
  v23 = (void (*)(uint64_t *))(*(_QWORD *)(v20 + 8 * (v21 ^ 0x5EE)) - 12);
  v23(&a15);
  a18 = v21 - 799 - 1543737703 * (&a15 ^ 0x7EF4507C);
  a15 = v26;
  a17 = a12;
  v23(&a15);
  a16 = v21 + 268847287 * ((&a15 & 0xEDF895C2 | ~(&a15 | 0xEDF895C2)) ^ 0xEDAD7B15) - 531;
  a17 = v27;
  a15 = a12;
  v24 = ((uint64_t (*)(uint64_t *))(*(_QWORD *)(v20 + 8 * (v21 & 0x6F7DAA9F)) - 8))(&a15);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v19 + 8 * ((928 * (a18 == 489733862)) ^ v21))
                                          - ((v21 - 1684320257) & 0x6464AE8F)
                                          + 1026))(v24);
}

uint64_t sub_10005B2F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, int a15, int a16, int a17, uint64_t a18, unint64_t *a19, int a20)
{
  uint64_t v20;
  int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;

  v23 = 1224239923 * (&a15 ^ 0xF2B3FDD7);
  a18 = a12;
  a19 = &STACK[0x72F2C1D3322B8808];
  a15 = v23 ^ 0x12B68929;
  a16 = (v22 + 368398770) ^ v23;
  a17 = v23 ^ 0x71C60F36;
  v24 = sub_100074BB8((uint64_t)&a15);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v20
                                                      + 8
                                                      * (int)(((a20 == v21)
                                                             * ((((v22 + 691290228) & 0xD6CBBACE) + 1521) ^ (v22 - 369))) ^ v22))
                                          - 12))(v24);
}

uint64_t sub_10005B3B0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unint64_t *a13, uint64_t a14, unint64_t *a15, unint64_t *a16, unsigned int a17)
{
  uint64_t v17;
  uint64_t v18;
  int v19;
  void (*v20)(unint64_t **);
  uint64_t v21;

  a17 = v19 + 324 - 944348131 * ((&a15 & 0xD828319E | ~(&a15 | 0xD828319E)) ^ 0x84CE6A2F);
  a15 = &STACK[0x20BA795F69D3FDD];
  a16 = a13;
  v20 = (void (*)(unint64_t **))(*(_QWORD *)(v18 + 8 * (v19 | 0x28)) - 8);
  v20(&a15);
  a17 = v19 + 324 - 944348131 * ((&a15 & 0x7C2082A7 | ~(&a15 | 0x7C2082A7)) ^ 0x20C6D916);
  a15 = &STACK[0x20BA795F69D3FC5];
  a16 = a13;
  v20(&a15);
  LODWORD(a16) = v19
               - 241568881
               * (((&a15 | 0x247E0372) - &a15 + (&a15 & 0xDB81FC88)) ^ 0xF26F0730)
               + 388;
  a15 = a13;
  v21 = sub_10005A5D8((uint64_t)&a15);
  return (*(uint64_t (**)(uint64_t))(v17
                                            + 8 * (((HIDWORD(a16) == 489733862) * (((v19 - 4) ^ 0x4B0) + 723)) ^ v19)))(v21);
}

uint64_t sub_10005B500(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, uint64_t a10, int a11, int a12)
{
  uint64_t v12;
  int v13;

  return (*(uint64_t (**)(void))(v12 + 8 * ((124 * (a12 != ((v13 + a9 + 848 - 2060) ^ (a9 + 848)))) ^ a9)))();
}

uint64_t sub_10005B534()
{
  uint64_t v0;
  int *v1;
  int v2;
  int v3;
  uint64_t result;
  void (*v5)(unsigned int *);
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t v10;

  *v1 = v8 ^ v2;
  v10 = v7;
  v9 = (v3 - 886) ^ (69008221
                   * ((((&v9 | 0x475A7F8C) ^ 0xFFFFFFFE) - (~&v9 | 0xB8A58073)) ^ 0x6B07D279));
  v5(&v9);
  v10 = v6;
  v9 = (v3 - 886) ^ (69008221 * ((&v9 & 0x83CD08BF | ~(&v9 | 0x83CD08BF)) ^ 0xAF90A54A));
  result = ((uint64_t (*)(unsigned int *))v5)(&v9);
  *(_DWORD *)(v0 + 24) = 489733862;
  return result;
}

uint64_t sub_10005B638(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  BOOL v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;

  v1 = 3804331 * ((676526031 - (a1 | 0x2852F7CF) + (a1 | 0xD7AD0830)) ^ 0xA9782DC6);
  v2 = *(_DWORD *)(a1 + 16) ^ v1;
  v3 = *(_DWORD *)(a1 + 20) ^ v1;
  v4 = *(_DWORD *)(*(_QWORD *)(a1 + 24) - 0x2DB44D49A49B002ALL);
  v6 = v4 - 237901512;
  v5 = v4 - 237901512 < 0;
  v7 = 237901512 - v4;
  if (v5)
    v8 = v7;
  else
    v8 = v6;
  return (*(uint64_t (**)(void))((char *)*(&off_100180420 + v2 - 98)
                              + 8
                              * ((664 * (((v2 ^ ((v3 - 67201651) < 4 * (unint64_t)v8)) & 1) == 0)) ^ v2)
                              - 4))();
}

uint64_t sub_10005B70C()
{
  int v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (((((v2 ^ 0x5D0) - 1816190557) & 0x6C40D9F4 ^ 0x1FF) * (v0 != 67201651)) ^ v2 ^ 0x5D0))
                            - ((((v2 ^ 0x5D0) - 1276) | 0x2Cu) ^ 0xA0)))();
}

uint64_t sub_10005B770(uint64_t a1)
{
  uint64_t v1;
  int v2;

  return (*(uint64_t (**)(uint64_t, uint64_t))(v1
                                                     + 8
                                                     * ((((181 * (v2 ^ 0x116) - 20) ^ 0xEE) + 181 * (v2 ^ 0x116) - 190) ^ (181 * (v2 ^ 0x116)))))(a1, 3834095767);
}

uint64_t sub_10005B7F0@<X0>(uint64_t a1@<X0>, int a2@<W1>, int a3@<W3>, int a4@<W8>)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  char v7;
  int v8;

  *(_BYTE *)(*(_QWORD *)(a1 + 8) + (a3 + a4)) = v8
                                                            - 66
                                                            + ((a2 ^ v6) >> v7)
                                                            - ((2 * ((a2 ^ v6) >> v7)) & 0xFC)
                                                            - 108;
  return (*(uint64_t (**)(void))(v4 + 8 * (v8 ^ (440 * (a3 - 1 != v5)))))();
}

uint64_t sub_10005B844(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;

  return (*(uint64_t (**)(uint64_t, uint64_t))(v3
                                                     + 8
                                                     * (((v4 == 24) * ((((a3 | 0x100) - 20) ^ 0xEE) + (a3 | 0x100) - 190)) ^ (a3 | 0x100))))(a1, a2);
}

uint64_t sub_10005B87C(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  int v4;
  int v5;
  _BOOL4 v7;

  v7 = v5 + 1092042573 <= (((a3 ^ 0x3C) - 190) ^ 0x2CFB57CE) && v5 + 1092042573 >= v4;
  return (*(uint64_t (**)(uint64_t, uint64_t))(v3 + 8 * ((60 * v7) ^ a3)))(a1, 3834095767);
}

uint64_t sub_10005B8CC@<X0>(uint64_t a1@<X0>, int a2@<W4>, int a3@<W8>)
{
  int v3;
  _QWORD *v4;
  int v5;

  return sub_10005B7F0(a1, *(_DWORD *)(*v4 + 4 * (int)((((a2 - 326) | 0x88) ^ 0x941BE746) + v5)), v3, a3);
}

_DWORD *sub_10005B900(_DWORD *result)
{
  int v1;

  *result = v1;
  return result;
}

uint64_t sub_10005B908(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)(void))((char *)*(&off_10017BFF0 + ((1441 * (*(_DWORD *)(a2 + 4) == 1528691563)) ^ 0x15Fu)) - 4))();
}

uint64_t sub_10005B94C(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  *(_BYTE *)(*(_QWORD *)(a1 + 96) + 468) = *(_BYTE *)(*(_QWORD *)(a2 + 8) + 12);
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 2832) - 4))();
}

void sub_10005B9C8()
{
  JUMPOUT(0x10005B998);
}

uint64_t sub_10005B9D0@<X0>(uint64_t a1@<X8>)
{
  return a1;
}

void sub_10005B9D8(uint64_t a1)
{
  int v1;
  unsigned int v2;
  unsigned int v3;
  int v4;
  _BOOL4 v5;

  v1 = 235795823 * (a1 ^ 0x94AD4959);
  v2 = *(_DWORD *)(*(_QWORD *)(a1 + 16) - 0x56428495FB62986) - 838085059;
  v3 = *(_DWORD *)(a1 + 8) + v1 - 1673847153;
  v4 = (v3 < 0xF8E1265C) ^ (v2 < 0xF8E1265C);
  v5 = v2 < v3;
  if (v4)
    v5 = v3 < 0xF8E1265C;
  __asm { BR              X11 }
}

uint64_t sub_10005BABC()
{
  int v0;
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((22
                                          * ((((v0 ^ 0x572) - 406) & *(_DWORD *)(v1 - 0x56428495FB6297ELL)) != ((71 * (v0 ^ 0x4F2)) ^ 0x661))) ^ v0))
                            - 12))();
}

uint64_t sub_10005BB18@<X0>(int a1@<W8>, uint64_t a2, ...)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  _BOOL4 v5;
  va_list va;

  va_start(va, a2);
  v5 = (*(uint64_t (**)(_QWORD, char *, _QWORD, uint64_t))(v3 + 8 * (v4 ^ 0x6AC)))(**(unsigned int **)(v3 + 8 * (v4 ^ 0x6B0)), va, ((v4 - 831207618) & 0x318B33F7 ^ 0xD5022BF6)+ ((a1 - 1554380750) & 0xFFFFF000 ^ 0x2AFDD59F)+ ((2 * (a1 - 1554380750)) & 0x55FBA000), 1) != 0;
  return (*(uint64_t (**)(void))(v2 + 8 * ((2 * v5) | (16 * v5) | v4)))();
}

uint64_t sub_10005BBB0()
{
  uint64_t v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (((*(_QWORD *)(v0 - 0x56428495FB62992) == 0)
                                          * ((v2 - 1511332270) & 0x5A1517FF ^ 0x510)) ^ (v2 - 880)))
                            - 11 * ((v2 - 880) ^ 0x2D4u)
                            + 399))();
}

void sub_10005BC28()
{
  uint64_t v0;
  _DWORD *v1;
  int v2;
  uint64_t v3;
  _QWORD *v4;

  *v4 = v3;
  *(_DWORD *)(v0 - 0x56428495FB6298ALL) = v2;
  *v1 = v2;
}

uint64_t sub_10005C160(uint64_t a1, uint64_t a2)
{
  unint64_t v2;
  int v3;
  char *v4;
  int v5;
  char v7;

  v2 = (unint64_t)&v7 ^ qword_1001A6E40 ^ qword_1001A6C08;
  qword_1001A6E40 = (45734839 * v2) ^ 0xA77260646F1BC58ALL;
  qword_1001A6C08 = 45734839 * (v2 ^ 0xA77260646F1BC58ALL);
  v3 = *(_DWORD *)(a2 + 4);
  v4 = (char *)*(&off_100180420
               + ((-73 * ((qword_1001A6C08 - ((-73 * v2) ^ 0x8A)) ^ 0x8A)) ^ byte_100159270[byte_100154280[(-73 * ((qword_1001A6C08 - ((-73 * v2) ^ 0x8A)) ^ 0x8A))] ^ 0x3A])
               - 139)
     - 4;
  if (v3 == 1528691553)
    __asm { BR              X17 }
  if (v3 == 1528691560)
  {
    v5 = **(unsigned __int8 **)(a2 + 8) - 9;
    __asm { BR              X3 }
  }
  return 4294925278;
}

void sub_10005C85C(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 40) + 235795823 * (((a1 | 0xBFD03985) - a1 + (a1 & 0x402FC67A)) ^ 0x2B7D70DC);
  __asm { BR              X10 }
}

uint64_t sub_10005C99C()
{
  int v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  _BOOL4 v5;

  v5 = *(_OWORD *)(v2 + 48) == 0 || (*(_DWORD *)(v2 + 44) ^ v0) == ((17 * (v1 ^ 0xCD)) ^ 0x3FD7AA8B);
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((100 * v5) ^ v1)) - 12))();
}

uint64_t sub_10005C9F0()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  int v3;
  unsigned __int8 v4;
  BOOL v6;

  v3 = v0 ^ 0x6F9;
  v4 = v0 ^ 0xDE;
  v6 = *(_QWORD *)(v1 + 32) == 0x5C4A884E2BA70EBCLL || *(_OWORD *)v1 == 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((1342 * ((v4 ^ v6) & 1)) ^ v3)) - 12))();
}

uint64_t sub_10005CA50(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  int v3;
  uint64_t v4;

  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v4
                                                              + 8
                                                              * ((((((v3 - 1484) | 0x80) + 36) ^ ((v3 - 1492) | 0x88))
                                                                * (v2 == 0)) ^ v3)))(a1, a2, 831981571);
}

uint64_t sub_10005CB58@<X0>(uint64_t a1@<X1>, int a2@<W2>, uint64_t a3@<X8>, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20)
{
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  int v31;
  void (*v32)(uint64_t);
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  void (*v42)(uint64_t);
  uint64_t v43;
  void (*v44)(uint64_t);
  void (*v45)(uint64_t);
  uint64_t v46;

  v30 = v22 + 77;
  v31 = ((2 * ((v29 - 144) & 0x46CC6E78) - (v29 - 144) - 1187802749) ^ 0x209241A7) * a2;
  *(_QWORD *)(v29 - 136) = v26;
  *(_QWORD *)(v29 - 128) = v20;
  *(_DWORD *)(v29 - 144) = (((v22 + 77) ^ 0xC0C4174C) + v23) ^ v31;
  *(_DWORD *)(v29 - 140) = v31 + v22 + 957;
  v46 = a3 + v21;
  ((void (*)(uint64_t))(*(_QWORD *)(a1 + 8 * (v22 ^ 0x20D)) - 4))(v29 - 144);
  HIDWORD(a10) = v30 ^ 0x4DD;
  *(_DWORD *)(v29 - 144) = v30
                         + 751
                         - 1224239923
                         * ((((v29 - 144) | 0x72DB4EC0) - (v29 - 144) + ((v29 - 144) & 0x8D24B138)) ^ 0x8068B317);
  *(_QWORD *)(v29 - 136) = a19;
  *(_QWORD *)(v29 - 128) = v24;
  v45 = (void (*)(uint64_t))*(&off_100180420 + v30 - 568);
  v45(v29 - 144);
  HIDWORD(v43) = v30 - 296;
  *(_QWORD *)(v29 - 144) = v26;
  *(_QWORD *)(v29 - 136) = a19;
  *(_DWORD *)(v29 - 112) = v30
                         - 296
                         - 1543737703
                         * ((((v29 - 144) | 0x4EA87986) - (v29 - 144) + ((v29 - 144) & 0xB1578678)) ^ 0x305C29FA);
  *(_QWORD *)(v29 - 128) = a20;
  *(_QWORD *)(v29 - 120) = v24;
  v44 = (void (*)(uint64_t))*(&off_100180420 + v30 - 631);
  v44(v29 - 144);
  HIDWORD(a8) = v30 + 951;
  *(_QWORD *)(v29 - 128) = v25;
  *(_QWORD *)(v29 - 120) = a19;
  *(_QWORD *)(v29 - 104) = a20;
  *(_QWORD *)(v29 - 144) = v24;
  *(_QWORD *)(v29 - 136) = a20;
  *(_DWORD *)(v29 - 112) = v30 + 951 - 1224239923 * ((v29 - 144) ^ 0xF2B3FDD7);
  v32 = (void (*)(uint64_t))((char *)*(&off_100180420 + v30 - 584) - 8);
  v32(v29 - 144);
  LODWORD(v43) = v30 + 330;
  *(_DWORD *)(v29 - 144) = v30
                         + 330
                         - 1178560073
                         * ((((v29 - 144) ^ 0xE0146109 | 0xF4B9EC4) + ((v29 - 144) ^ 0xF488E44 | 0xF0B4613B)) ^ 0x869CD24);
  *(_QWORD *)(v29 - 128) = a19;
  *(_QWORD *)(v29 - 120) = a20;
  *(_QWORD *)(v29 - 112) = a15;
  *(_QWORD *)(v29 - 104) = a20;
  *(_QWORD *)(v29 - 136) = v24;
  v42 = (void (*)(uint64_t))((char *)*(&off_100180420 + (v30 ^ 0x27A)) - 8);
  v42(v29 - 144);
  *(_DWORD *)(v29 - 144) = v30 + 751 - 1224239923 * ((v29 - 411936759 - 2 * ((v29 - 144) & 0xE7725899)) ^ 0x15C1A54E);
  *(_QWORD *)(v29 - 136) = a19;
  *(_QWORD *)(v29 - 128) = a14;
  v45(v29 - 144);
  *(_DWORD *)(v29 - 112) = v30
                         - 296
                         - 1543737703 * (((v29 - 144) & 0xED32F927 | ~((v29 - 144) | 0xED32F927)) ^ 0x6C3956A4);
  *(_QWORD *)(v29 - 144) = v26;
  *(_QWORD *)(v29 - 136) = a19;
  *(_QWORD *)(v29 - 128) = v28;
  *(_QWORD *)(v29 - 120) = a14;
  v44(v29 - 144);
  *(_DWORD *)(v29 - 112) = v30
                         + 951
                         - 1224239923
                         * (((((v29 - 144) | 0x2E18EB56) ^ 0xFFFFFFFE) - (~(v29 - 144) | 0xD1E714A9)) ^ 0x2354E97E);
  *(_QWORD *)(v29 - 144) = a14;
  *(_QWORD *)(v29 - 136) = v28;
  *(_QWORD *)(v29 - 128) = v25;
  *(_QWORD *)(v29 - 120) = a19;
  *(_QWORD *)(v29 - 104) = v28;
  v32(v29 - 144);
  *(_QWORD *)(v29 - 136) = a14;
  *(_QWORD *)(v29 - 128) = a19;
  *(_DWORD *)(v29 - 144) = v30 + 330 - 1178560073 * ((v29 - 435891113 - 2 * ((v29 - 144) & 0xE604D4E7)) ^ 0x131F68F);
  *(_QWORD *)(v29 - 112) = a12;
  *(_QWORD *)(v29 - 104) = v28;
  *(_QWORD *)(v29 - 120) = v28;
  v42(v29 - 144);
  *(_DWORD *)(v29 - 144) = (v30 + 153) ^ (268847287
                                        * ((((v29 - 144) | 0x44694F9C) - (v29 - 144) + ((v29 - 144) & 0xBB96B060)) ^ 0xBBC35EB4));
  *(_QWORD *)(v29 - 136) = v28;
  *(_QWORD *)(v29 - 128) = a20;
  ((void (*)(uint64_t))*(&off_100180420 + v30 - 548))(v29 - 144);
  *(_QWORD *)(v29 - 136) = v28;
  *(_DWORD *)(v29 - 140) = v30
                         - 1224239923 * ((((2 * (v29 - 144)) | 0xFB28F40) - (v29 - 144) + 2015803488) ^ 0x756ABA77)
                         - 25;
  sub_10002F0FC(v29 - 144);
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, void (*)(uint64_t), uint64_t, void (*)(uint64_t), uint64_t, void (*)(uint64_t), uint64_t, void (*)(uint64_t), char *, uint64_t, uint64_t, uint64_t, uint64_t))(v27 + 8 * ((((v30 ^ 0xDD ^ (*(_DWORD *)(v29 - 144) < 0x18257F42u)) & 1) * ((v30 ^ 0x4DD) - 1497)) ^ v30)))(v33, v34, v35, v36, v37, v38, v39, v40, a4, v42, v43, v44, a8, v45, a10, v32, (char *)*(&off_100180420 + v30 - 544) - 4, v46, a14,
           v24,
           a16);
}

uint64_t sub_10005D04C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void (*a16)(uint64_t), void (*a17)(uint64_t), uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29)
{
  void (*v29)(uint64_t);
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;

  *(_QWORD *)(v34 - 144) = v33;
  *(_QWORD *)(v34 - 136) = v30;
  *(_DWORD *)(v34 - 128) = (v31 + 117) ^ (3804331
                                        * ((2 * ((v34 - 144) & 0x24362F0) - (v34 - 144) + 2109512971) ^ 0x369B8FD));
  v29(v34 - 144);
  *(_QWORD *)(v34 - 104) = v33;
  *(_QWORD *)(v34 - 128) = a29;
  *(_QWORD *)(v34 - 120) = a24;
  *(_DWORD *)(v34 - 112) = v31
                         + 130
                         - 1224239923
                         * ((((v34 - 144) ^ 0xCA7DE41E) & 0xF0BA43E2 | ~((v34 - 144) ^ 0xCA7DE41E | 0xF0BA43E2)) ^ 0x378BA5D4);
  *(_QWORD *)(v34 - 144) = v30;
  *(_QWORD *)(v34 - 136) = v33;
  a16(v34 - 144);
  *(_DWORD *)(v34 - 112) = v31
                         + 130
                         - 1224239923 * ((((v34 - 144) | 0x4AD5FD1B) - ((v34 - 144) & 0x4AD5FD1B)) ^ 0xB86600CC);
  *(_QWORD *)(v34 - 104) = a18;
  *(_QWORD *)(v34 - 144) = v30;
  *(_QWORD *)(v34 - 136) = v33;
  *(_QWORD *)(v34 - 128) = v33;
  *(_QWORD *)(v34 - 120) = a24;
  a16(v34 - 144);
  *(_DWORD *)(v34 - 144) = v31
                         - 235795823 * (((v34 - 144) & 0x46F1697D | ~((v34 - 144) | 0x46F1697D)) ^ 0x2DA3DFDB)
                         + 2138961813;
  *(_QWORD *)(v34 - 136) = a20;
  *(_QWORD *)(v34 - 128) = v33;
  sub_1000747F8(v34 - 144);
  *(_DWORD *)(v34 - 128) = (v31 + 117) ^ (3804331
                                        * ((1507516239 - ((v34 - 144) | 0x59DADF4F) + ((v34 - 144) | 0xA62520B0)) ^ 0xD8F00546));
  *(_QWORD *)(v34 - 144) = v33;
  *(_QWORD *)(v34 - 136) = a25;
  a17(v34 - 144);
  *(_QWORD *)(v34 - 144) = v33;
  *(_DWORD *)(v34 - 136) = v31
                         + 831981571 * (((v34 - 144) & 0xA0A8D7DE | ~((v34 - 144) | 0xA0A8D7DE)) ^ 0xC6F6F805)
                         - 1203;
  *(_QWORD *)(v34 - 128) = a25;
  v35 = sub_10004F498(v34 - 144);
  return (*(uint64_t (**)(uint64_t))(v32
                                            + 8
                                            * (((((a21 == 0) ^ (v31 - 4)) & 1)
                                              * (((v31 - 1541) | 0x480) ^ 0x4EE)) ^ (v31 + 262))))(v35);
}

uint64_t sub_10005D2B8()
{
  int v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t result;
  uint64_t v7;
  int v8;

  v5 = 3804331 * ((((2 * (v4 - 144)) | 0x1839231E) - (v4 - 144) + 1944284785) ^ 0xF2C9B479);
  *(_QWORD *)(v4 - 120) = v2;
  *(_DWORD *)(v4 - 128) = (v0 - 986) ^ v5;
  *(_DWORD *)(v4 - 124) = (v8 - 1003897599 + ((v0 - 1156) | 0xF0)) ^ v5;
  *(_QWORD *)(v4 - 136) = v3;
  result = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + v0 - 1035) - 8))(v4 - 144);
  *(_DWORD *)(v7 - 0x5C4A884E2BA70EBCLL) = v8;
  *(_DWORD *)(v1 + 24) = 489733862;
  return result;
}

void sub_10005D420(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  _DWORD v8[2];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;

  v1 = 2078219279 * ((2 * (a1 & 0x636844EC) - a1 - 1667777773) ^ 0x466D2D67);
  v2 = *(_DWORD *)(a1 + 64) - v1;
  v3 = *(_DWORD *)(a1 + 40) ^ v1;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_QWORD *)a1;
  v6 = *(_DWORD *)(a1 + 60) - v1;
  v7 = 831981571 * (((v8 | 0x3F000E94) - (v8 & 0x3F000E94)) ^ 0xA6A1DEB0);
  v11 = *(_QWORD *)(a1 + 16);
  v12 = v4;
  v8[0] = v2 - v7 - 504207465;
  v9 = v4;
  v10 = v5;
  v13 = v7 ^ (v3 - 122105303);
  v14 = v6 + v7 - 296005617;
  sub_100075024((uint64_t)v8);
  __asm { BR              X8 }
}

uint64_t sub_10005D598(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, int a11, char a12, int a13, unint64_t *a14, uint64_t a15)
{
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  int v20;
  int v21;
  char v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v22 = *(_BYTE *)(v15 + 56) - v19;
  v23 = 268847287 * ((((2 * &a10) | 0x96A7D3F6) - &a10 + 883693061) ^ 0x34F9F8D3);
  a14 = &STACK[0x6B80B300B999BAB];
  a15 = v18;
  a12 = ((v21 + 33) ^ 0x3E)
      - -73 * ((((2 * &a10) | 0xF6) - &a10 + 5) ^ 0xD3)
      + (v21 ^ v22 ^ 0xF7)
      + 2 * (v22 & 7);
  a10 = v23 + v21 + 1220;
  a11 = (v20 - 371451500) ^ v23;
  sub_10005544C((uint64_t)&a10);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v17
                                                                                          + 8
                                                                                          * ((19 * (a13 != v16)) | v21))
                                                                              - 12))(v24, v25, v26, v27, v28);
}

uint64_t sub_10005D660()
{
  uint64_t v0;
  int v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * ((398
                                          * (v1
                                           + ((v2 + 2034078398) ^ 0x793D94CC)
                                           + ((v2 + 2034078398) & 0x86C26FCE)
                                           - 1715142297 < 0xFFFFFFFE)) ^ v2))
                            - 12))();
}

uint64_t sub_10005D6B8@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;

  a3 = a1;
  a4 = a2;
  a5 = v9 - 944348131 * ((&a3 & 0xE4E14E4C | ~(&a3 | 0xE4E14E4C)) ^ 0xB80715FD) - 840;
  v10 = ((uint64_t (*)(uint64_t *))(*(_QWORD *)(v7 + 8 * (v9 ^ 0x5A4)) - 8))(&a3);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v8
                                                      + 8
                                                      * ((219 * (a6 == v9 - 923 + ((v9 - 923) ^ (v6 - 614)))) ^ v9))
                                          - 12))(v10);
}

void sub_10005D750(uint64_t a1@<X8>)
{
  uint64_t v1;

  *(_QWORD *)(*(_QWORD *)(v1 + 48) - 0x72F2C1D3322B87E8) = a1;
  *(_DWORD *)(v1 + 24) = 489733862;
}

void sub_10005D830(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 24) - 69008221 * ((a1 - 1655620505 - 2 * (a1 & 0x9D513C67)) ^ 0x4EF36E6D);
  __asm { BR              X15 }
}

void sub_10005D93C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t v4;

  *(_DWORD *)(a3 + v4) = v3;
}

void sub_10005E78C(uint64_t a1)
{
  int v1;
  int v2;
  int v3;
  unsigned int v4;
  uint64_t v5;

  v1 = 1178560073 * ((a1 - 2 * (a1 & 0xA5CBBCEE) - 1513374482) ^ 0x42FE9E86);
  v2 = *(_DWORD *)(a1 + 32) ^ v1;
  v3 = (*(_BYTE *)(a1 + 16) - v1);
  ((void (*)(char *, void (*)()))*(&off_100180420 + (v2 & 0x54B9E8E0)))((char *)*(&off_100180420 + (int)(v2 & 0xC43D0CA1)) - 12, sub_10007434C);
  v5 = *(_QWORD *)((char *)*(&off_100180420 + (int)(v2 & 0xD9B6D844)) - 4);
  v4 = (235795823 * (((&v4 | 0xAD911F22) - (&v4 & 0xAD911F22)) ^ 0x393C567B)) ^ (v2 + 9);
  sub_10005EDD8((uint64_t)&v4);
  __asm { BR              X8 }
}

uint64_t sub_10005E8D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, int a16, char a17)
{
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;

  v21 = (&a16 ^ 0xE7352268) * v17;
  a16 = v18 - v21 - 128;
  a17 = v21 ^ 0x80;
  sub_100048284(&a16);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v19 + 8 * (((**(_DWORD **)(v20 + 8 * ((v18 - 565035232) & 0x21ADBDF8 ^ 0x1A0u)) == ((v18 - 565035232) & 0x21ADBDF8) - 280) * (((v18 - 565035232) & 0x21ADBDF8) - 230)) ^ (v18 - 565035232) & 0x21ADBDF8))
                                                                                                - 4))(v22, v23, v24, v25, v26, v27, v28);
}

uint64_t sub_10005E984()
{
  uint64_t v0;
  _DWORD *v1;
  _DWORD *v2;
  int v3;
  uint64_t v5;
  uint64_t v6;
  int v7;
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  _BYTE *v11;
  _BYTE *v12;
  uint64_t (*v13)(uint64_t, _BYTE *, _DWORD *);
  int v14;
  unsigned int v15;
  uint64_t v16;
  _BYTE *v17;
  int v18;
  unsigned int v19;
  uint64_t result;
  uint64_t v21;
  _BYTE v22[20];
  _BYTE v23[150];

  v8 = *(unsigned int **)(v5 + 8 * ((v7 + 743) & 0x21EA3085));
  v9 = *(_QWORD *)(v5 + 8 * ((v7 + 743) & 0x11A6746E));
  v10 = *v8;
  v11 = *(_BYTE **)(v9 - 4);
  v23[0] = *v11 - 91;
  v23[1] = v11[1] - 91;
  v23[2] = v11[2] - 91;
  v23[3] = v11[3] - 91;
  v23[4] = v11[4] - 91;
  v23[5] = v11[5] - 91;
  v23[6] = v11[6] - 91;
  v23[7] = v11[7] - 91;
  v23[8] = v11[8] - 91;
  v23[9] = v11[9] - 91;
  v23[10] = v11[10] - 91;
  v23[11] = v11[11] - 91;
  v23[12] = v11[12] - 91;
  v23[13] = v11[13] - 91;
  v23[14] = v11[14] - 91;
  v23[15] = v11[15] - 91;
  v23[16] = v11[16] - 91;
  v23[17] = v11[17] - 91;
  v23[18] = v11[18] - 91;
  v23[19] = v11[19] - 91;
  v23[20] = v11[20] - 91;
  v23[21] = v11[21] - 91;
  v12 = *(_BYTE **)(v9 - 4);
  v23[22] = v12[22] - 91;
  v23[23] = v12[23] - 91;
  v23[24] = v12[24] - 91;
  v23[25] = v12[25] - 91;
  v23[26] = v12[26] - 91;
  v23[27] = v12[27] - 91;
  v23[28] = v12[28] - 91;
  v23[29] = v12[29] - 91;
  v13 = *(uint64_t (**)(uint64_t, _BYTE *, _DWORD *))(v5 + 8 * (v7 - 47));
  v14 = v13(v10, v23, v1);
  v15 = ((2 * v14) & 0xE7E7FDF6) + (v14 ^ 0x73F3FEFB);
  if (v15 != 1945370363)
  {
    if (v15 == 1945371465)
    {
      v16 = *v8;
      v17 = *(_BYTE **)(*(_QWORD *)(v5 + 8 * (v3 ^ 0x37E)) - 4);
      v22[0] = *v17 - 2;
      v22[1] = v17[1] - 2;
      v22[2] = v17[2] - 2;
      v22[3] = v17[3] - 2;
      v22[4] = v17[4] - 2;
      v22[5] = v17[5] - 2;
      v22[6] = v17[6] - 2;
      v22[7] = v17[7] - 2;
      v22[8] = v17[8] - 2;
      v22[9] = v17[9] - 2;
      v22[10] = v17[10] - 2;
      v22[11] = v17[11] - 2;
      v22[12] = v17[12] - 2;
      v22[13] = v17[13] - 2;
      v22[14] = v17[14] - 2;
      v22[15] = v17[15] - 2;
      v22[16] = v17[16] - 2;
      v22[17] = v17[17] - 2;
      v22[18] = v17[18] - 2;
      v22[19] = v17[19] - 2;
      v18 = v13(v16, v22, v1);
      v19 = (2 * v18) & 0xFBF7FDFA;
      v15 = (v18 ^ 0xFDFBFEFD) + 1677164508;
    }
    else
    {
      v19 = -302022690;
    }
    __asm { BR              X8 }
  }
  *(_DWORD *)(v6 + 348) |= (v3 + 7) ^ 0x40C;
  *(_DWORD *)(v6 + 48) = 733061813;
  result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, _DWORD *))(v5 + 8 * (v3 - 916)))(*v1, v6 + 336, v6 + 340, v6 + 344, v2);
  v21 = *(_QWORD *)(v0 + 24);
  *(_DWORD *)(*(_QWORD *)(v0 + 8) - 0x3974ED3FA12E689) = *v1;
  *(_DWORD *)(v21 - 0x64312DEF5EC77446) = *v2 - ((v3 ^ 0x374E45D7) & (2 * *v2)) + 463938324;
  *(_DWORD *)v0 = 489733862;
  return result;
}

void sub_10005EDD8(uint64_t a1)
{
  int v1;
  uint64_t v2;

  v1 = *(_DWORD *)a1 ^ (235795823 * (a1 ^ 0x94AD4959));
  v2 = *(_QWORD *)(a1 + 8);
  ((void (*)(_QWORD, void (*)()))*(&off_100180420 + v1 - 808))(*(&off_100180420 + v1 - 919), sub_1000746B0);
  __asm { BR              X10 }
}

uint64_t sub_10005EE74()
{
  uint64_t v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * ((1384
                                          * ((((v2 - 680) ^ (**(_QWORD **)(v1 + 8 * ((v2 - 680) ^ 0x1BB)) == 0)) & 1) == 0)) ^ (v2 - 680)))
                            - 12))();
}

uint64_t sub_10005EEB4@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t))(v2 + 8 * (a1 ^ 0x1ED)))(v1);
}

void sub_10005EEE4(uint64_t a1)
{
  __asm { BR              X8 }
}

uint64_t sub_10005EF28(uint64_t a1)
{
  uint64_t v1;
  int v3;
  unsigned int v4;
  uint64_t v5;

  v3 = (*(uint64_t (**)(void))(v1 + 1352))();
  if (v3 == 16)
    v4 = -42029;
  else
    v4 = -42030;
  if (v3)
    v5 = v4;
  else
    v5 = 0;
  (*(void (**)(uint64_t))(v1 + 208))(a1);
  return v5;
}

uint64_t sub_10005EF70(uint64_t a1, uint64_t a2)
{
  return ((uint64_t (*)(void))((char *)*(&off_10017BFF0 + ((21 * (*(_DWORD *)(a2 + 4) != 1528691551)) ^ 0x42Fu)) - 8))();
}

uint64_t sub_10005EFB0()
{
  return 4294925278;
}

uint64_t sub_10005EFB8(uint64_t a1, uint64_t a2)
{
  char v2;

  if (**(_BYTE **)(a2 + 8))
    v2 = 77;
  else
    v2 = 76;
  *(_BYTE *)(a1 + 88) = v2;
  return 0;
}

void sub_10005EFFC(uint64_t a1)
{
  unint64_t v2;
  uint64_t v3;
  unint64_t v4;
  char v5;
  void (*v6)(_QWORD, void (*)());
  char v7;

  v2 = (unint64_t)&v7 ^ qword_1001A6E88 ^ qword_1001A6C08;
  v3 = 45734839 * v2 - 0x354AA8AFC6EBC5ALL;
  v4 = 45734839 * (v2 ^ 0xA77260646F1BC58ALL);
  qword_1001A6E88 = v3;
  v5 = byte_100161D20[byte_10015E0A0[(-73 * ((v4 + v3) ^ 0x8A))] ^ 0x17];
  v6 = (void (*)(_QWORD, void (*)()))*(&off_100180420
                                                + ((-73 * (v3 ^ 0x8A ^ v4)) ^ byte_10015DFA0[byte_100159170[(-73 * (v3 ^ 0x8A ^ v4))] ^ 0x11])
                                                + 3);
  qword_1001A6C08 = v4;
  v6(*(&off_100180420 + ((-73 * ((v4 + v3) ^ 0x8A)) ^ v5) + 24), sub_1000746B0);
  __asm { BR              X11 }
}

uint64_t sub_10005F11C()
{
  unsigned int v0;
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v1 + 8 * ((1529 * (**(_QWORD **)(v2 + 1752) == 0)) ^ v0)))();
}

uint64_t sub_10005F154@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t))(v2 + 8 * (a1 ^ 0x482u)))(v1);
}

void sub_10005F178(uint64_t a1)
{
  int v1;

  v1 = *(_DWORD *)(a1 + 44) - 1224239923 * (((a1 | 0x1FD8AEE4) - a1 + (a1 & 0xE027511B)) ^ 0xED6B5333);
  __asm { BR              X16 }
}

uint64_t sub_10005F2AC()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v2 + 8 * ((1966 * (v1 != 0x4A24EF6A)) ^ (v0 - 603))) - 4))(1664037403);
}

uint64_t sub_10005F300(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  unsigned int v13;
  uint64_t v14;
  int v15;
  _BOOL4 v16;

  v12 = v7 > 0x25BD9D53;
  *(_BYTE *)(v10 + (a1 - 1664037403)) = *(_BYTE *)(v3 + ((a1 - 1664037403) & 0xFLL)) ^ *(_BYTE *)(v1 + (a1 - 1664037403)) ^ *(_BYTE *)(v4 + ((a1 - 1664037403) & 0xFLL)) ^ *(_BYTE *)(((a1 - 1664037403) & 0xFLL) + v2 + 1) ^ (23 * ((a1 - 27) & 0xF));
  v13 = a1 + 1997746322;
  v14 = (a1 + 1);
  v15 = v12 ^ (v13 < v5 - 46 + v6);
  v16 = v13 < v8;
  if (!v15)
    v12 = v16;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v11 + 8 * ((v12 * v9) ^ v5)) - 4))(v14);
}

uint64_t sub_10005F398(uint64_t a1, int a2)
{
  int v2;
  int v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v4
                              + 8
                              * ((31
                                * ((v3 ^ (((a2 - 1267753107) & 0x4B905FB4) - 1133) ^ 0xB5D91316)
                                 + 1069268593
                                 + ((2 * v3) & 0xFFFBFBBE ^ v2) != 1069136976)) ^ a2)))();
}

uint64_t sub_10005F408(int a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * (a3 ^ (117 * ((v3 + a1 + 131617) > 7))))
                            - ((a3 - 488) | 4u)
                            + 1056))();
}

uint64_t sub_10005F44C(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, unsigned int a6)
{
  uint64_t v6;

  return ((uint64_t (*)(uint64_t, uint64_t))(*(_QWORD *)(v6
                                                               + 8 * ((a3 - 644) ^ (1904 * (a6 >> 4 == 268427230))))
                                                   - ((89 * ((a3 - 644) ^ 0x380) - 975944845) & 0x3A2BBBEA ^ 0x38ELL)))(a1, a2);
}

uint64_t sub_10005F4A8(int a1, int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  BOOL v18;
  unint64_t v19;
  int v21;

  v10 = ((a3 + 162) ^ (a2 + 1004)) + v7 + a1;
  v11 = v10 + v3;
  v12 = v10 + v8;
  v13 = (v7 + a1) & 0xF;
  v14 = v13 + v5 - v12;
  v15 = (v13 | v6) - v12;
  v16 = (v13 | v4) - v12;
  v18 = (unint64_t)(v11 - v12) >= 0x10
     && v14 >= (unint64_t)((a3 - 1022725196) & 0x3CF58FDF) - 1806
     && v15 >= 0x10;
  v19 = v16 + 1;
  v21 = !v18 || v19 < 0x10;
  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * (((2 * v21) | (4 * v21)) ^ a3)) - 4))();
}

uint64_t sub_10005F534(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v7;
  uint64_t v8;

  return ((uint64_t (*)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v8
                                                                       + 8
                                                                       * (((((a7 + 471240926) & 0x63E969B7) - 387)
                                                                         * (v7 < 0x10)) ^ a7))
                                                           - 4))(a1, a2, 0);
}

uint64_t sub_10005F570(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  int v61;
  int v62;
  unsigned int v63;
  int8x16_t v64;
  int8x16_t v65;
  int8x16_t v66;
  int8x16x4_t v68;
  int8x16x4_t v69;

  v68.val[1].i64[0] = ((_BYTE)v60 + 13) & 0xF;
  v68.val[1].i64[1] = ((_BYTE)v60 + 12) & 0xF;
  v68.val[2].i64[0] = ((_BYTE)v60 + 11) & 0xF;
  v68.val[2].i64[1] = ((_BYTE)v60 + 10) & 0xF;
  v68.val[3].i64[0] = ((_BYTE)v60 + (_BYTE)a7 - 120 + 99) & 0xF;
  v68.val[3].i64[1] = ((_BYTE)v60 + 8) & 0xF;
  v63 = v62 + a1 + a2;
  v64.i64[0] = 0x1717171717171717;
  v64.i64[1] = 0x1717171717171717;
  v68.val[0].i64[0] = v63 & 0xF;
  v68.val[0].i64[1] = ((_BYTE)v60 + 14) & 0xF;
  v65.i64[0] = vqtbl4q_s8(v68, (int8x16_t)xmmword_100151920).u64[0];
  v69.val[0].i64[1] = ((_BYTE)v60 + 6) & 0xF;
  v69.val[1].i64[1] = ((_BYTE)v60 + 4) & 0xF;
  v69.val[2].i64[1] = ((_BYTE)v60 + 2) & 0xF;
  v69.val[3].i64[1] = v60 & 0xF;
  v69.val[0].i64[0] = ((_BYTE)v60 + 7) & 0xF;
  v69.val[1].i64[0] = ((_BYTE)v60 + 5) & 0xF;
  v69.val[2].i64[0] = (v60 + 3) & 0xF;
  v69.val[3].i64[0] = ((_BYTE)v60 + 1) & 0xF;
  v65.i64[1] = vqtbl4q_s8(v69, (int8x16_t)xmmword_100151920).u64[0];
  v66 = vrev64q_s8(vmulq_s8(v65, v64));
  *(int8x16_t *)(a54 - 15 + v63) = veorq_s8(veorq_s8(veorq_s8(veorq_s8(*(int8x16_t *)(v58 + v68.val[0].i64[0] - 15), *(int8x16_t *)(v56 - 15 + v63)), *(int8x16_t *)(v59 + v68.val[0].i64[0] - 15)), *(int8x16_t *)(v57 + v68.val[0].i64[0] + (((a7 - 1422) | 0x40u) ^ 0x1D1) - 15)), vextq_s8(v66, v66, 8uLL));
  return (*(uint64_t (**)(void))(a56 + 8 * ((99 * ((v61 & 0xFFFFFFF0) != 16)) ^ (a7 - 888))))();
}

void sub_10005F6E0()
{
  JUMPOUT(0x10005F660);
}

uint64_t sub_10005F6EC(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * (v4 | (v3 == a3))) - ((v4 + 1971774487) & 0x8A791BBB ^ 0x1A7)))();
}

uint64_t sub_10005F728(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v6
                                                                                + 8
                                                                                * ((v5 + 1088) | (4
                                                                                                * ((((v5 - 2135244828) & 0x7F453FFF ^ 0x1BC) & v4) != ((v5 - 767308769) & 0x2DBC363C) - 1068))))
                                                                    - 12))(a1, a2, a3, (v3 - a3));
}

uint64_t sub_10005F788(int a1, int a2, int a3, uint64_t a4, uint64_t a5, unsigned int a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char v60;
  int v61;
  char v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  char v67;
  uint64_t v68;
  int8x16x4_t v70;

  *(_DWORD *)(v65 - 132) = v61;
  *(_QWORD *)(v65 - 120) = v56 - 7;
  *(_QWORD *)(v65 - 128) = v64 - 7;
  *(_DWORD *)(v65 - 136) = v61 & 0xFFFFFFF8;
  v66 = -a3;
  v67 = v62 + v63 + a1;
  v68 = (v63 + a1 + a2 + v66);
  v70.val[0].i64[0] = ((_BYTE)v63 + (_BYTE)a1 + (_BYTE)a2 + (_BYTE)v66) & 0xF;
  v70.val[0].i64[1] = (v67 + 14 + (_BYTE)v66) & 0xF;
  v70.val[1].i64[0] = (v67 + 13 + (_BYTE)v66) & 0xF;
  v70.val[1].i64[1] = (v67 + 12 + (_BYTE)v66) & 0xF;
  v70.val[2].i64[0] = (v67 + 11 + (_BYTE)v66) & 0xF;
  v70.val[2].i64[1] = (v67 + 10 + (_BYTE)v66) & 0xF;
  v70.val[3].i64[0] = (v60 + (_BYTE)v66 + ((a6 + 29) ^ 8)) & 0xF;
  v70.val[3].i64[1] = (v67 + 8 + (_BYTE)v66) & 0xF;
  *(int8x8_t *)(*(_QWORD *)(v65 - 128) + v68) = veor_s8(veor_s8(veor_s8(*(int8x8_t *)(v58 + (v68 & 0xF) - 7), *(int8x8_t *)(*(_QWORD *)(v65 - 120) + v68)), veor_s8(*(int8x8_t *)(v59 + (v68 & 0xF) - 7), *(int8x8_t *)((v68 & 0xF) + v57 - 6))), vrev64_s8(vmul_s8((int8x8_t)*(_OWORD *)&vqtbl4q_s8(v70, (int8x16_t)xmmword_100151930), (int8x8_t)0x1717171717171717)));
  return ((uint64_t (*)(__n128))(*(_QWORD *)(a56 + 8 * ((1474 * (8 - (v61 & 0xFFFFFFF8) == v66)) ^ a6))
                                         - 12))((__n128)xmmword_100151930);
}

void sub_10005F8C8()
{
  JUMPOUT(0x10005F7E8);
}

uint64_t sub_10005F8D4(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (((((a2 + 599) | 4) - 463) * (*(_DWORD *)(v2 - 132) != *(_DWORD *)(v2 - 136))) ^ a2))
                            - ((a2 - 886318034) & 0x34D423A3 ^ 0x1A7)))();
}

uint64_t sub_10005F928(uint64_t a1, uint64_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;

  *(_BYTE *)(v10 + (a4 - 1069136977)) = *(_BYTE *)(v7 + ((a4 - 1069136977) & 0xFLL)) ^ *(_BYTE *)(v5 + (a4 - 1069136977)) ^ *(_BYTE *)(v8 + (((_BYTE)a4 - 81) & 0xF)) ^ *(_BYTE *)((((_BYTE)a4 - 81) & 0xF) + v6 + 1) ^ (23 * ((a4 - 81) & 0xF));
  return ((uint64_t (*)(void))(*(_QWORD *)(v11 + 8 * (((a4 - 1 == v9) * (a5 - 1016)) ^ (a5 + 554))) - 12))();
}

uint64_t sub_10005F994(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  BOOL v53;
  int v54;

  v52 = *(_QWORD *)(v48 + 24);
  *(int8x16_t *)(v50 - 112) = veorq_s8(*(int8x16_t *)*(_QWORD *)(v48 + 16), (int8x16_t)xmmword_100151950);
  if (v49)
    v53 = v52 == 0x697D3DFF8FBD18CALL;
  else
    v53 = 1;
  v54 = !v53;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v51 + 8 * (int)((v54 * ((a6 ^ 0x55C) - 16)) ^ a6)) - 8))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48);
}

uint64_t sub_10005F9F8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,int a57)
{
  uint64_t v57;
  _BOOL4 v59;

  v59 = ((((a57 - 1187921920) & 0x46CE3FFF) - 1264) & (HIDWORD(a23) + 6)) != 0 || HIDWORD(a23) == 314638490;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v57 + 8 * ((v59 * (a57 - 1246)) ^ (a57 - 893))) - 8))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48);
}

uint64_t sub_10005FA5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,int a23,int a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,int a56,uint64_t a57,int a58)
{
  uint64_t v58;
  int v59;
  int v60;

  v59 = a24 - ((a58 ^ 0xD215ED8) & (2 * a56)) - 204493703;
  v60 = ((2 * v59) & 0xFCFCB42E ^ 0xC201026) + (v59 ^ 0xF8EEF704) + 1974991779 != 1949717946;
  return ((uint64_t (*)(void))(*(_QWORD *)(v58 + 8 * (((v60 << 6) | (v60 << 8)) ^ a58)) - 8))();
}

uint64_t sub_10005FB1C()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;

  return (*(uint64_t (**)(void))(v3
                              + 8
                              * ((((15 * (v0 ^ 0x47E)) ^ (3 * (v0 ^ 0x59B)) ^ 0x3BA)
                                * ((v2 + v1 + 25273833) < 8)) ^ v0 ^ 0xCF4)))();
}

uint64_t sub_10005FBA8(int a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, int a7)
{
  uint64_t v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7
                                        + 8
                                        * (((((a5 - 638) ^ 0x13D) + 2918) * ((a1 + a7 - 16) < 0xFFFFFFF0)) ^ a5))
                            - (((a5 - 638) | 0x2AAu) ^ 0x7B3)))();
}

uint64_t sub_10005FBF0(int a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  _BOOL4 v22;
  int v25;

  v10 = (v7 + v6 + a1);
  v11 = v10 + v8 + 1;
  v12 = ((_BYTE)v7 + (_BYTE)v6 + (_BYTE)a1) & 0xF;
  v13 = v12 - v10;
  v14 = v5 + v13;
  v15 = (((a3 ^ 0x282u) - 269) ^ 0x42DLL) + v12;
  v16 = v5 + v15;
  v17 = v4 + v13;
  v18 = v4 + v15;
  v19 = v3 + v13;
  v20 = v3 + v15;
  v22 = v14 < v11 && v16 > v8;
  if (v17 < v11 && v18 > v8)
    v22 = 1;
  v25 = v19 < v11 && v20 > v8 || v22;
  return ((uint64_t (*)(void))(*(_QWORD *)(v9 + 8 * ((109 * (v25 ^ 1)) ^ a3)) - 12))();
}

uint64_t sub_10005FC7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  unsigned int v7;
  uint64_t v8;

  return ((uint64_t (*)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v8
                                                                       + 8
                                                                       * ((121 * (v7 < (((a7 - 389) | 0x41) ^ 0x3E5u))) ^ a7))
                                                           - 8))(a1, a2, 0);
}

uint64_t sub_10005FCB8(int a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16x4_t v19;
  int8x16x4_t v20;

  v19.val[1].i64[0] = ((_BYTE)a2 + 10) & 0xF;
  v19.val[1].i64[1] = ((_BYTE)a2 + 9) & 0xF;
  v19.val[2].i64[0] = ((_BYTE)a2 + 8) & 0xF;
  v19.val[2].i64[1] = ((_BYTE)a2 + 7) & 0xF;
  v19.val[3].i64[0] = ((_BYTE)a2 + 6) & 0xF;
  v19.val[3].i64[1] = ((_BYTE)a2 + 5) & 0xF;
  v20.val[0].i64[0] = ((_BYTE)a2 + 4) & 0xF;
  v20.val[0].i64[1] = ((_BYTE)a2 + 3) & 0xF;
  v12 = v9 + v8 + a1;
  v20.val[1].i64[0] = ((_BYTE)a2 + 2) & 0xF;
  v20.val[1].i64[1] = (a2 + 1) & 0xF;
  v20.val[2].i64[0] = a2 & 0xF;
  v20.val[2].i64[1] = (a2 - 1) & 0xF;
  v20.val[3].i64[0] = (a2 + 14) & 0xF;
  v20.val[3].i64[1] = (a2 + 13) & 0xF;
  v13.i64[0] = 0x505050505050505;
  v13.i64[1] = 0x505050505050505;
  v14.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v14.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v19.val[0].i64[0] = v12 & 0xF;
  v19.val[0].i64[1] = ((_BYTE)a2 + 11) & 0xF;
  v15.i64[0] = vqtbl4q_s8(v19, (int8x16_t)xmmword_100151920).u64[0];
  v15.i64[1] = vqtbl4q_s8(v20, (int8x16_t)xmmword_100151920).u64[0];
  v16 = vrev64q_s8(veorq_s8(veorq_s8(*(int8x16_t *)(v10 - 15 + v12), *(int8x16_t *)(v6 + v19.val[0].i64[0] - 15)), veorq_s8(*(int8x16_t *)(v5 + v19.val[0].i64[0] - 15), *(int8x16_t *)(v4 + v19.val[0].i64[0] - 15))));
  v17 = vrev64q_s8(veorq_s8(veorq_s8(vextq_s8(v16, v16, 8uLL), v14), vmulq_s8(v15, v13)));
  *(int8x16_t *)(v10 - 15 + v12) = vextq_s8(v17, v17, 8uLL);
  return (*(uint64_t (**)(void))(v11 + 8 * ((((v7 & 0xFFFFFFF0) == 16) * (a4 ^ 0x59C)) ^ a4)))();
}

void sub_10005FE18()
{
  JUMPOUT(0x10005FD9CLL);
}

uint64_t sub_10005FE24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,unsigned __int8 *a54,unsigned int a55,uint64_t a56)
{
  uint64_t v56;
  unsigned __int8 *v57;
  int v58;
  uint64_t v59;
  int v60;
  int v61;
  char *v62;
  char *v63;
  uint64_t v64;
  int v65;
  unsigned __int8 v66;
  unint64_t v67;
  char *v68;
  int v69;
  char v70;
  int v71;
  unsigned int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  uint64_t v78;
  char *v79;
  char *v80;
  unsigned int v81;
  char *v82;
  unsigned int v83;
  unsigned int v84;
  int v85;
  unsigned int v86;
  int v87;
  int v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  int v93;
  unsigned int v94;
  unsigned int v95;
  int v96;
  unsigned int v97;
  int v98;
  unsigned int v99;
  unsigned int v100;
  int v101;
  unsigned int v102;
  int v103;
  int v104;
  unsigned int v105;
  unsigned int v106;
  int v107;
  unsigned int v108;
  int v109;
  unsigned int v110;
  unsigned int v111;
  int v112;
  int v113;
  unsigned int v114;
  unsigned int v115;
  unsigned int v116;
  int v117;
  unsigned int v118;
  int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  int v123;
  unsigned int v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  int v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  int v136;
  int v137;
  unsigned int v138;
  unsigned int v139;
  char *v140;
  int v141;
  int v142;
  char *v143;
  char *v144;
  unsigned int v145;
  char *v146;
  int v147;
  unsigned int v148;
  int v149;
  unsigned int v150;
  int v151;
  int v152;
  int v153;
  unsigned int v154;
  int v155;
  int v156;
  int v157;
  unsigned int v158;
  unsigned int v159;
  unsigned int v160;
  unsigned int v161;
  int v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  int v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  int v172;
  unsigned int v173;
  int v174;
  unsigned int v175;
  int v176;
  int v177;
  unsigned int v178;
  unsigned int v179;
  unsigned int v180;
  int v181;
  int v182;
  int v183;
  unsigned int v184;
  unsigned int v185;
  unsigned int v186;
  unsigned int v187;
  unsigned int v188;
  unsigned int v189;
  unsigned int v190;
  unsigned int v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  int v195;
  int v196;
  unsigned int v197;
  unsigned int v198;
  unsigned int v199;
  int v200;
  int v201;
  unsigned int v202;
  int v203;
  int v204;
  int v205;
  int v206;
  unsigned int v207;
  unsigned int v208;
  int v209;
  int v210;
  int v211;
  unsigned int v212;
  unsigned int v213;
  int v214;
  unsigned int v215;
  unsigned int v216;
  unsigned int v217;
  int v218;
  unsigned int v219;
  int v220;
  unsigned int v221;
  int v222;
  int v223;
  int v224;
  unsigned int v225;
  unsigned int v226;
  unsigned int v227;
  unsigned int v228;
  unsigned int v229;
  unsigned int v230;
  int v231;
  int v232;
  int v233;
  char *v234;
  char *v235;
  char *v236;
  char *v237;
  uint64_t v238;
  unsigned int v239;
  unsigned int v240;
  unsigned int v241;
  int v242;
  int v243;
  int v244;
  int v245;
  unsigned __int8 v246;
  uint64_t v247;
  int v248;
  uint64_t v249;
  uint64_t v250;
  int v251;
  int v252;
  uint64_t v253;
  int v254;
  uint64_t v255;
  int v256;
  int v257;
  int v258;
  unsigned int v259;
  int v260;
  uint64_t v261;
  unsigned int v262;
  char *v263;
  char *v264;
  unsigned int v265;
  int v266;
  int v267;
  char *v268;
  int v269;
  int v270;
  unint64_t v271;
  char *v272;
  int v273;
  int v274;
  int v275;
  int v276;
  int v277;
  int v278;
  int v279;
  int v280;
  unsigned int v281;
  unsigned int v282;
  unsigned int v283;
  int v284;
  unsigned int v285;
  int v286;
  int v287;
  int v288;
  int v289;
  int v290;
  int v291;
  int v292;
  int v293;
  unsigned int v294;
  unsigned int v295;
  unsigned int v296;
  int v297;
  int v298;
  unsigned int v299;
  int v300;
  unsigned int v301;
  unsigned int v302;
  unsigned int v303;
  unsigned int v304;
  int v305;
  int v306;
  int v307;
  int v308;
  int v309;
  unsigned int v310;
  int v311;
  int v312;
  int v313;
  int v314;
  int v315;
  unsigned int v316;
  unsigned int v317;
  unsigned int v318;
  int v319;
  int v320;
  int v321;
  int v322;
  int v323;
  int v324;
  int v325;
  int v326;
  int v327;
  int v328;
  int v329;
  unsigned int v330;
  unsigned int v331;
  unsigned int v332;
  int v333;
  int v334;
  int v335;
  unsigned int v336;
  int v337;
  unsigned int v338;
  int v339;
  int v340;
  int v341;
  unsigned int v342;
  unsigned int v343;
  unsigned int v344;
  int v345;
  unsigned int v346;
  unsigned int v347;
  int v348;
  int v349;
  int v350;
  int v351;
  int v352;
  int v353;
  unsigned int v354;
  unsigned int v355;
  unsigned int v356;
  unsigned int v357;
  int v358;
  unsigned int v359;
  int v360;
  int v361;
  int v362;
  int v363;
  unsigned int v364;
  int v365;
  int v366;
  int v367;
  int v368;
  unsigned int v369;
  unsigned int v370;
  unsigned int v371;
  int v372;
  int v373;
  int v374;
  unsigned int v375;
  int v376;
  unsigned int v377;
  int v378;
  int v379;
  unsigned int v380;
  int v381;
  int v382;
  unsigned int v383;
  unsigned int v384;
  unsigned int v385;
  int v386;
  int v387;
  int v388;
  int v389;
  int v390;
  int v391;
  unsigned int v392;
  int v393;
  int v394;
  int v395;
  int v396;
  int v397;
  unsigned int v398;
  int v399;
  int v400;
  int v401;
  unsigned int v402;
  unsigned int v403;
  int v404;
  uint64_t v405;
  char *v406;
  unsigned int v407;
  int v408;
  int v409;
  char *v410;
  uint64_t v411;
  int v412;
  char *v413;
  int v414;
  int v415;
  int v416;
  uint64_t v417;
  char *v418;
  char *v419;
  uint64_t v420;
  int v421;
  uint64_t v422;
  char *v423;
  uint64_t v424;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  unsigned int v430;
  uint64_t v431;
  unsigned int v432;
  uint64_t v433;
  unsigned int v434;
  uint64_t v435;
  unsigned int v436;
  unsigned int v437;
  unsigned int v438;
  uint64_t v439;
  unsigned int v440;
  unsigned __int8 v441;
  uint64_t v442;
  unsigned int v443;
  uint64_t v444;
  int v445;
  int v446;
  int v447;
  uint64_t v448;
  int v449;
  unsigned int v450;
  unsigned int v451;
  unsigned int v452;
  uint64_t v453;
  unsigned int v454;
  unsigned int v455;
  unsigned int v456;
  int v457;
  uint64_t v458;
  int v459;
  unsigned int v460;
  unsigned int v461;
  uint64_t v462;
  unsigned int v463;
  unsigned int v464;
  unsigned __int8 v465;
  unsigned int v466;
  unsigned int v467;
  uint64_t v468;
  unsigned int v469;
  unsigned int v470;
  int v471;
  unsigned int v472;
  uint64_t v473;
  unsigned int v474;
  int v475;
  unsigned int v476;
  int v477;
  uint64_t v478;
  int v479;
  unsigned int v480;
  int v481;
  unsigned int v482;
  int v483;
  uint64_t v484;
  unsigned int v485;
  unsigned int v486;
  int v487;
  unsigned int v488;
  unsigned int v489;
  uint64_t v490;
  int v491;
  int v492;
  unsigned __int8 v493;
  unsigned int v494;
  unsigned int v495;
  uint64_t v496;
  __int16 v497;
  unsigned int v498;
  int v499;
  unsigned int v500;
  uint64_t v501;
  int v502;
  unsigned int v503;
  int v504;
  int v505;
  int v506;
  uint64_t v507;
  unsigned int v508;
  unsigned int v509;
  unsigned int v510;
  unsigned int v511;
  uint64_t v512;
  int v513;
  unsigned int v514;
  int v515;
  int v516;
  int v517;
  unsigned int v518;
  uint64_t v519;
  unsigned int v520;
  unsigned int v521;
  unsigned int v522;
  unsigned int v523;
  int v524;
  uint64_t v525;
  int v526;
  unsigned int v527;
  int v528;
  int v529;
  int v530;
  uint64_t v531;
  int v532;
  unsigned int v533;
  int v534;
  int v535;
  unsigned int v536;
  int v537;
  uint64_t v538;
  int v539;
  int v540;
  unsigned int v541;
  uint64_t v542;
  unsigned int v543;
  int v544;
  int v545;
  unsigned int v546;
  int v547;
  uint64_t v548;
  unsigned int v549;
  int v550;
  int v551;
  uint64_t v552;
  unsigned int v553;
  int v554;
  unsigned int v555;
  unsigned int v556;
  uint64_t v557;
  int v558;
  int v559;
  unsigned int v560;
  unsigned int v561;
  uint64_t v562;
  unsigned int v563;
  int v564;
  unsigned int v565;
  uint64_t v566;
  int v567;
  unsigned int v568;
  unsigned int v569;
  char *v570;
  int v571;
  unsigned int v572;
  char *v573;
  unsigned int v574;
  char *v575;
  int v576;
  char *v577;
  int v578;
  uint64_t v579;
  uint64_t v580;
  unint64_t v581;
  uint64_t v582;
  unsigned int v583;
  uint64_t v584;
  int v585;
  int v586;
  unsigned int v587;
  int v588;
  int v589;
  int v590;
  int v591;
  unsigned int v592;
  int v593;
  unsigned int v594;
  int v595;
  int v596;
  int v597;
  int v598;
  int v599;
  int v600;
  int v601;
  unsigned int v602;
  unsigned int v603;
  unsigned int v604;

  v60 = v58 - 193;
  v61 = v58 + 678;
  *(_DWORD *)(v59 - 120) = v61 | 4;
  v62 = (char *)*(&off_100180420 + (v60 ^ 0x22)) - 8;
  v63 = (char *)*(&off_100180420 + (v60 ^ 0x8E)) - 8;
  v64 = (uint64_t)*(&off_100180420 + (v60 ^ 0x15));
  v65 = ((v62[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C8) ^ 0xD7] ^ 0x68) << 8) | ((v63[*v57 ^ 0xB1] ^ ((v61 | 4) - 41)) << 24);
  HIDWORD(v67) = *(unsigned __int8 *)(v64 + (*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18BDLL) ^ 0x49));
  LODWORD(v67) = (HIDWORD(v67) ^ 0xB0) << 24;
  v66 = v67 >> 26;
  v68 = (char *)*(&off_100180420 + v60 - 112) - 4;
  v69 = v63[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18BELL) ^ 0xB8];
  HIDWORD(v67) = *(unsigned __int8 *)(v64 + (*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C1) ^ 0x6BLL));
  LODWORD(v67) = (HIDWORD(v67) ^ 0xB0) << 24;
  v70 = v62[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18BCLL) ^ 0x2ELL];
  v71 = ((v67 >> 26) ^ 0x53) << 16;
  HIDWORD(v67) = *(unsigned __int8 *)(v64 + (*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C9) ^ 0x47));
  LODWORD(v67) = (HIDWORD(v67) ^ 0xB0) << 24;
  v72 = v65 & 0xFF00FF00 | (v68[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C7) ^ 0xECLL] + 68) ^ 9 | (((v67 >> 26) ^ 0x1E) << 16);
  v73 = v62[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C4) ^ 0x30];
  LODWORD(v62) = v71 | ((v62[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C0) ^ 0x77] ^ 0xA7) << 8);
  HIDWORD(v67) = *(unsigned __int8 *)(v64 + (*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C5) ^ 0xCBLL));
  LODWORD(v67) = (HIDWORD(v67) ^ 0xB0) << 24;
  v74 = ((v66 ^ 0xFB) << 16) | ((v69 ^ 0xBBBBBBBB) << 24) | ((v70 ^ 0xAD) << 8);
  v75 = ((v68[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C3) ^ 0xA9] + 68) | ((v73 ^ 0x5D) << 8)) & 0xFF00FFFF | (((v67 >> 26) ^ 0xBA) << 16);
  LOBYTE(v71) = v68[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18BBLL) ^ 0x36];
  LOBYTE(v68) = v68[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18BFLL) ^ 0xB5];
  v76 = v75 | ((v63[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C6) ^ 0x35] ^ 0xCCCCCCCC) << 24);
  v77 = v62 | ((v63[*(unsigned __int8 *)(v56 - 0x697D3DFF8FBD18C2) ^ 0xBFLL] ^ 0xD5) << 24);
  v78 = (uint64_t)*(&off_100180420 + (v60 ^ 0x11));
  v79 = (char *)*(&off_100180420 + v60 - 6) - 4;
  LODWORD(v63) = *(_DWORD *)(v78 + 4 * ((v71 + 68) ^ 0xFDu)) ^ 0x832295F6 ^ *(_DWORD *)&v79[4 * (v66 ^ 0x61)];
  *(_DWORD *)(v59 - 132) = v60;
  v80 = (char *)*(&off_100180420 + (v60 ^ 0x78)) - 4;
  v81 = ((_DWORD)v63 - ((2 * (_DWORD)v63) & 0xBC5733B2) - 567567911) ^ *(_DWORD *)&v80[4 * (v69 ^ 0x2E)];
  v82 = (char *)*(&off_100180420 + (v60 ^ 0x83)) - 8;
  HIDWORD(v582) = v72;
  v83 = *(_DWORD *)&v82[4 * (v70 ^ 0x95)] ^ v72 ^ (v81 - ((2 * v81) & 0xB8B60D40) + 1549469344);
  LODWORD(v582) = v74 & 0xFFFFFF00 | (v71 + 68) ^ 0x2A;
  v84 = v77 & 0xFFFFFF00 | ((_BYTE)v68 + 68) ^ 0xA8;
  v85 = v83 ^ v76;
  v86 = v83;
  v469 = v83;
  v87 = v83 ^ v76 ^ 0x4D;
  *(_DWORD *)(v59 - 192) = v87 ^ v84;
  LODWORD(v64) = v87;
  v465 = v87;
  v88 = v87 ^ v84 ^ (v582 - 2 * (v582 & 0x326140A3 ^ ((v71 + 68) ^ 0x2A) & 3) + 845234336);
  v89 = v88 ^ 0x88966D09;
  v578 = BYTE1(v88);
  v499 = ((v88 ^ 0x88966D09) >> 16);
  v90 = *(_DWORD *)&v82[4 * (BYTE1(v88) ^ 0xBA)] ^ 0x3BDB89E ^ *(_DWORD *)&v79[4 * (v499 ^ 0x49)];
  v505 = v88;
  v91 = (v90 - ((2 * v90) & 0xB9885790) - 591123512) ^ *(_DWORD *)(v78 + 4 * (v88 ^ 0x89u));
  v485 = v89;
  *(_DWORD *)(v59 - 208) = HIBYTE(v89);
  v92 = v86 ^ *(_DWORD *)&v80[4 * (HIBYTE(v89) ^ 0x65)] ^ (v91 - ((2 * v91) & 0xBC5733B2) - 567567911);
  v93 = v84 & 0x883397B ^ (((_BYTE)v68 + 68) ^ 0xA8) & 0x10;
  *(_DWORD *)(v59 - 184) = v85;
  v581 = __PAIR64__(v76, v84);
  *(_DWORD *)(v59 - 160) = v92;
  v94 = v92 ^ 0x8883396B ^ (v84 - 2 * v93 - 2004666005);
  *(_DWORD *)(v59 - 128) = v94;
  v520 = ((v94 ^ v89) >> 16) ^ 0x74A7;
  v516 = ((v94 ^ v89) >> 16) ^ 0xA7;
  v513 = ((unsigned __int16)(v92 ^ 0x396B ^ (v84 - 2 * v93 + 14699) ^ v89) >> 8);
  v95 = (v85 ^ 0xBAF72DE4) - 2 * ((v85 ^ 0xBAF72DE4) & 0x883397B ^ v85 & 0x10);
  v96 = *(_DWORD *)&v79[4 * (((v94 ^ v89) >> 16) ^ 0x2E)] ^ *(_DWORD *)&v82[4 * (v513 ^ 0x9B)] ^ 0x3BDB89E;
  v600 = v92 ^ 0x6B ^ (v84 - 2 * v93 + 107) ^ v89;
  v97 = (v96 - ((2 * v96) & 0xB9885790) - 591123512) ^ *(_DWORD *)(v78 + 4 * (v600 ^ 0xD2u));
  v98 = v94 ^ v89 ^ 0x25D5AED7;
  v99 = (v94 ^ v89) >> 24;
  *(_DWORD *)(v59 - 216) = v99;
  v100 = (v97 - ((2 * v97) & 0xBC5733B2) - 567567911) ^ *(_DWORD *)&v80[4 * (v99 ^ 0x69)];
  v101 = v100 ^ v64 ^ 0x7BF382F9;
  v545 = v100 ^ v64;
  *(_DWORD *)(v59 - 152) = v101 ^ v94;
  v102 = ((v101 ^ v94 ^ 0xE1758F13) - ((2 * (v101 ^ v94 ^ 0xE1758F13)) & 0xA2E41F3C) + 1366429598) ^ v98;
  v558 = ((v102 ^ 0x9547167F) >> 16);
  v571 = ((unsigned __int16)(v102 ^ 0x167F) >> 8);
  v103 = *(_DWORD *)&v82[4 * (v571 ^ 0x3A)] ^ *(_DWORD *)&v79[4 * (v558 ^ 0x89)];
  v567 = (((v101 ^ v94 ^ 0x13) - ((2 * (v101 ^ v94 ^ 0x13)) & 0x3C) - 98) ^ v98);
  v104 = ((v103 ^ 0x3BDB89E) - 2 * ((v103 ^ 0x3BDB89E) & 0x5CC42BC9 ^ v103 & 1) - 591123512) ^ *(_DWORD *)(v78 + 4 * (v567 ^ 0xE4u));
  v583 = (v102 ^ 0x9547167F) >> 24;
  v105 = (v104 - ((2 * v104) & 0xBC5733B2) - 567567911) ^ *(_DWORD *)&v80[4 * (v583 ^ 0x1D)];
  v522 = v100 ^ v92;
  v594 = (v105 + 159488450 + (~(2 * v105) | 0xECFCCC7B) + 1) ^ v100 ^ v92;
  *(_DWORD *)(v59 - 248) = v594 ^ 0x98199C2;
  v603 = v594 ^ 0x98199C2 ^ v100 ^ v64;
  v106 = ((v603 ^ 0xFE25CD6D) - ((2 * (v603 ^ 0xFE25CD6D)) & 0xA2E41F3C) + 1366429598) ^ v98;
  *(_DWORD *)(v59 - 220) = BYTE1(v106);
  v107 = *(_DWORD *)&v82[4 * (BYTE1(v106) ^ 0x6F)];
  v108 = v95 - 2004666005;
  *(_DWORD *)(v59 - 232) = BYTE2(v106);
  v109 = v107 ^ *(_DWORD *)&v79[4 * (BYTE2(v106) ^ 0xA8)] ^ 0x3BDB89E;
  v587 = HIBYTE(v106);
  v110 = (v109 - ((2 * v109) & 0xBC5733B2) - 567567911) ^ *(_DWORD *)&v80[4 * (HIBYTE(v106) ^ 0x85)];
  v585 = (((v603 ^ 0x6D) - ((2 * (v603 ^ 0x6D)) & 0x3C) - 98) ^ v98);
  v111 = (v110 - ((2 * v110) & 0xB9885790) - 591123512) ^ *(_DWORD *)(v78 + 4 * (v585 ^ 0x25u));
  LODWORD(v64) = (v111 - ((2 * v111) & 0x82095EA0) - 1056657584) ^ v101;
  v602 = v603 ^ v101 ^ v94;
  v460 = v64;
  v563 = v602 ^ v64;
  v112 = v106 ^ v602 ^ v64 ^ 0xCC3D50BA;
  v443 = v602 ^ v64 ^ 0xCC3D50BA;
  *(_DWORD *)(v59 - 256) = v106;
  v494 = (v112 ^ 0x3A3C68AAu) >> 24;
  v113 = *(_DWORD *)&v80[4 * (v494 ^ 0x1D)];
  *(_DWORD *)(v59 - 168) = v92 ^ 0x8883396B ^ v108;
  v479 = ((v112 ^ 0x3A3C68AAu) >> 16);
  v114 = v113 ^ *(_DWORD *)&v79[4 * (v479 ^ 0x89)] ^ 0x81CD27E7;
  v487 = ((unsigned __int16)(v112 ^ 0x68AA) >> 8);
  v115 = (v114 - ((2 * v114) & 0xB8B60D40) + 1549469344) ^ *(_DWORD *)&v82[4 * (v487 ^ 0x3A)];
  *(_DWORD *)(v59 - 200) = v594 ^ 0x98199C2 ^ v111;
  v598 = v112;
  v116 = (v115 - ((2 * v115) & 0xB9885790) - 591123512) ^ *(_DWORD *)(v78 + 4 * (v112 ^ 0x31u)) ^ v594 ^ 0x98199C2 ^ v111;
  v493 = BYTE2(v64) ^ 0x16;
  v117 = v116 ^ v64 ^ 0x7C166C11;
  v553 = v116;
  v118 = ((v603 ^ 0xFE25CD6D) - ((2 * (v603 ^ 0xFE25CD6D)) & 0xA2E41F3C) + 1366429598) ^ v98 ^ v117;
  *(_DWORD *)(v59 - 240) = HIBYTE(v118);
  v564 = (((v603 ^ 0x6D) - ((2 * (v603 ^ 0x6D)) & 0x3C) - 98) ^ v98 ^ v117);
  v119 = *(_DWORD *)&v80[4 * (HIBYTE(v118) ^ 0x9B)] ^ *(_DWORD *)(v78 + 4 * (v564 ^ 0x31u)) ^ 0x2EFB211;
  v535 = (v118 >> 8) ^ 0x86839A;
  v540 = BYTE1(v118) ^ 0x9A;
  v120 = (v119 - ((2 * v119) & 0xB8B60D40) + 1549469344) ^ *(_DWORD *)&v82[4 * (BYTE1(v118) ^ 0xA0)];
  v121 = v118 ^ 0xDAB51277;
  v532 = BYTE2(v118);
  v122 = (v120 - ((2 * v120) & 0xBFCD7C7C) + 1608957502) ^ *(_DWORD *)&v79[4 * (BYTE2(v118) ^ 0xA)];
  v123 = (v122 - ((2 * v122) & 0x103854A4) + 136063570) ^ v116;
  *(_DWORD *)(v59 - 176) = v123;
  v123 ^= 0xF59FB0F8;
  v502 = v123 ^ v117;
  v497 = v123;
  v549 = v117 ^ v443;
  LODWORD(v64) = v117;
  v526 = v117;
  v124 = ((v123 ^ v117 ^ 0x5A137D54) - ((2 * (v123 ^ v117 ^ 0x5A137D54)) & 0xF1267AF0) - 124568200) ^ v117 ^ v443 ^ 0x2FA6B2F5;
  v125 = v124;
  *(_DWORD *)(v59 - 136) = v124;
  v126 = ((v124 ^ 0xAEC73C3D) - ((2 * (v124 ^ 0xAEC73C3D)) & 0xB86D11BA) + 1547077853) ^ v121 ^ 0x479AB031;
  v576 = (((v124 ^ 0x3D) - ((2 * (v124 ^ 0x3D)) & 0xBA) - 35) ^ v121);
  v596 = ((unsigned __int16)(((v124 ^ 0x3C3D) - ((2 * (v124 ^ 0x3C3D)) & 0x11BA) - 30499) ^ v121 ^ 0xB031) >> 8);
  v127 = *(_DWORD *)&v82[4 * (v596 ^ 0x3A)] ^ *(_DWORD *)(v78 + 4 * (v576 ^ 0xAAu)) ^ 0x809F2D68;
  v128 = BYTE2(v126);
  v129 = (v127 - ((2 * v127) & 0xBFCD7C7C) + 1608957502) ^ *(_DWORD *)&v79[4 * (BYTE2(v126) ^ 0x89)];
  v508 = HIBYTE(v126);
  LODWORD(v62) = (v129 - ((2 * v129) & 0xBC5733B2) - 567567911) ^ *(_DWORD *)&v80[4 * (HIBYTE(v126) ^ 0x1D)];
  v130 = v62 ^ v64;
  v131 = ((v62 ^ v64 ^ 0xA6C48CD5)
        - 2 * ((v62 ^ v64 ^ 0xA6C48CD5) & 0x5C3688DF ^ (v62 ^ v64) & 2)
        + 1547077853) ^ v121;
  v132 = ((unsigned __int16)((((unsigned __int16)v62 ^ v64 ^ 0x8CD5)
                                             - 2
                                             * (((unsigned __int16)v62 ^ v64 ^ 0x8CD5) & 0x88DF ^ ((unsigned __int16)v62 ^ v64) & 2)
                                             - 30499) ^ v121) >> 8);
  v133 = *(_DWORD *)&v80[4 * (HIBYTE(v131) ^ 5)] ^ *(_DWORD *)&v82[4 * (v132 ^ 0x6F)] ^ 0x82709F79;
  v134 = (v133 - ((2 * v133) & 0xB9885790) - 591123512) ^ *(_DWORD *)(v78 + 4 * (v131 ^ 0x25u));
  v135 = v123 ^ v62;
  LODWORD(v64) = v123 ^ v62 ^ *(_DWORD *)&v79[4 * (BYTE2(v131) ^ 0xA8)] ^ (v134
                                                                                       - ((2 * v134) & 0xBFCD7C7C)
                                                                                       + 1608957502);
  v136 = v125 ^ 0x2958E43D;
  LODWORD(v62) = v125 ^ 0x2958E43D ^ v64;
  *(_DWORD *)(v59 - 140) = (_DWORD)v62;
  v591 = ((unsigned __int16)((unsigned __int16)v62 ^ v131) >> 8);
  LODWORD(v82) = *(_DWORD *)&v82[4 * (v591 ^ 0x44)];
  v455 = (v62 ^ v131) >> 24;
  v137 = *(_DWORD *)&v80[4 * (v455 ^ 0x47)];
  v436 = v62 ^ v131;
  v471 = (v62 ^ v131);
  v446 = ((v62 ^ v131) >> 16);
  v138 = ((v137 ^ v82 ^ 0x82709F79)
        - 2 * ((v137 ^ v82 ^ 0x82709F79) & 0x5CC42BCA ^ (v137 ^ v82) & 2)
        - 591123512) ^ *(_DWORD *)(v78 + 4 * (v471 ^ 0xD5u));
  v139 = (v138 - ((2 * v138) & 0xBFCD7C7C) + 1608957502) ^ *(_DWORD *)&v79[4 * (v446 ^ 0xCB)];
  HIDWORD(v580) = v64 ^ 0x4909208B ^ (v139 - ((2 * v139) & 0x93FC1A44) - 906097374);
  v449 = v64 ^ v130;
  v451 = v64;
  LODWORD(v580) = v64 ^ v130 ^ 0x7AF90D47 ^ (HIDWORD(v580) - ((2 * HIDWORD(v580)) & 0xBCB784A6) + 1583071827);
  HIDWORD(v579) = v62 ^ 0x4018996 ^ v580;
  LODWORD(v78) = *(_DWORD *)(v59 - 132);
  v140 = (char *)*(&off_100180420 + (int)v78 - 69) - 8;
  v141 = (((v135 ^ 0x1B9155BD) >> 16)
        + 1926004682
        - ((2 * ((v135 ^ 0x1B9155BD) >> 16) + 160207960) & 0x80C033C)) ^ *(_DWORD *)&v140[4 * (((v135 ^ 0x1B9155BD) >> 16) ^ 0x2D)];
  v142 = ((BYTE2(v131) ^ 0x89) + 1926004682 - ((2 * (BYTE2(v131) ^ 0x89) + 160207960) & 0x80C033C)) ^ *(_DWORD *)&v140[4 * (BYTE2(v131) ^ 0xA4)];
  v143 = (char *)*(&off_100180420 + (int)(v78 ^ 0xB6)) - 8;
  LODWORD(v82) = (v141 - ((2 * v141) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (BYTE1(v135) ^ 0x47)];
  v144 = (char *)*(&off_100180420 + (int)v78 + 10) - 4;
  v145 = (v142 - ((2 * v142) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * (HIBYTE(v131) ^ 0xCC)];
  v146 = (char *)*(&off_100180420 + (int)v78 - 190) - 4;
  v147 = *(_DWORD *)&v146[4 * ((v136 ^ v130) ^ 0x53)];
  v441 = BYTE1(v136) ^ BYTE1(v130);
  v148 = *(_DWORD *)&v140[4 * (((v136 ^ v130) >> 16) ^ 0xAA)] ^ *(_DWORD *)&v144[4
                                                                                                * (((v136 ^ v130) >> 24) ^ 0x3E)] ^ ((((v136 ^ v130) >> 16) ^ 0x87) + 1926004682 - ((2 * (((v136 ^ v130) >> 16) ^ 0x87) + 160207960) & 0x80C033C)) ^ (181304767 * v147 - ((362609534 * v147 - 948913736) & 0xA4A3D44A) + 906643201);
  v149 = *(_DWORD *)&v146[4 * (v130 ^ 0x74)];
  v150 = ((~(362609534 * v149 + 124828088) | 0xE0B2281B) + 181304767 * v149 + 1935624399) ^ *(_DWORD *)&v143[4 * (BYTE1(v130) ^ 0x5A)];
  v574 = v150 - ((2 * v150) & 0xA4A3D44A);
  v569 = HIBYTE(v130) ^ 0xB2;
  v529 = BYTE2(v130);
  v589 = (BYTE2(v130) ^ 0x4C) + 1926004682 - ((2 * (BYTE2(v130) ^ 0x4C) + 160207960) & 0x80C033C);
  v543 = v132 ^ 0xB0;
  v560 = v145 - ((2 * v145) & 0x1F4DD7E4);
  v555 = v148 - ((2 * v148) & 0x1F4DD7E4);
  HIDWORD(v584) = ((_DWORD)v82 - ((2 * (_DWORD)v82) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4
                                                                                                * ((v135 ^ 0x1B9155BD) >> 24)] ^ (181304767 * *(_DWORD *)&v146[4 * (v135 ^ 0x7D)] + 1673026780);
  v151 = *(_DWORD *)(v59 - 168);
  v152 = *(_DWORD *)&v140[4 * (((v151 ^ 0xE9B45E6C) >> 16) ^ 0xF5)] ^ ((((v151 ^ 0xE9B45E6C) >> 16) ^ 0xD8)
                                                                                      + 1926004682
                                                                                      - ((2
                                                                                        * (((v151 ^ 0xE9B45E6C) >> 16) ^ 0xD8)
                                                                                        + 160207960) & 0x80C033C));
  LODWORD(v82) = *(_DWORD *)(v59 - 128) ^ 0x31676F78;
  v153 = *(_DWORD *)&v140[4 * (BYTE2(v82) ^ 0x7B)] ^ ((BYTE2(v82) ^ 0x56)
                                                    + 1926004682
                                                    - ((2 * (BYTE2(v82) ^ 0x56) + 160207960) & 0x80C033C));
  LODWORD(v82) = (v153 - ((2 * v153) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * (v82 >> 24)];
  v154 = *(_DWORD *)&v140[4 * (v516 ^ 0x93)] ^ ((v516 ^ 0xBE)
                                              + 1926004683
                                              + ((2 * (((v516 ^ 0xBE) + 44) & 0xFFFFFF9F ^ (v520 | 0x7FFFFFFE))) ^ 0x80C0003));
  v155 = (v154 - ((2 * v154) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (v513 ^ 5)];
  v517 = (_DWORD)v82 - ((2 * (_DWORD)v82) & 0x1F4DD7E4);
  v156 = *(_DWORD *)(v59 - 160);
  LODWORD(v82) = *(_DWORD *)&v146[4 * (v156 ^ 0xDF)];
  v521 = v155 - ((2 * v155) & 0xA4A3D44A);
  v157 = ((v156 ^ 0x5A18571Fu) >> 16);
  v158 = *(_DWORD *)&v144[4 * ((v156 ^ 0x5A18571Fu) >> 24)] ^ *(_DWORD *)&v140[4 * (v157 ^ 0xEC)] ^ ((v157 ^ 0xC1) + 1926004683 + ((2 * (((v157 ^ 0xC1) + 44) & 0xFFFFFF9F ^ (v157 ^ 0xC1 | 0x7FFFFFFE))) ^ 0x80C0003)) ^ (181304767 * (_DWORD)v82 - ((362609534 * (_DWORD)v82 - 948913736) & 0xA4A3D44A) + 906643201);
  v514 = v158 - ((2 * v158) & 0x1F4DD7E4);
  v159 = *(_DWORD *)&v144[4 * ((v151 ^ 0xE9B45E6C) >> 24)] ^ (v152 - ((2 * v152) & 0xA4A3D44A) - 766383579);
  v510 = v159 - ((2 * v159) & 0x1F4DD7E4);
  LOWORD(v147) = v502 ^ 0x8EA4;
  v160 = v502 ^ 0x35C48CD5;
  v161 = *(_DWORD *)&v140[4 * (v128 ^ 0xDE)] ^ ((v128 ^ 0xF3)
                                              + 1926004683
                                              + ((2 * (((v128 ^ 0xF3) + 44) & 0xFFFFFF9F ^ (v128 ^ 0xF3 | 0x7FFFFFFE))) ^ 0x80C0003));
  v162 = *(_DWORD *)&v140[4 * (((v502 ^ 0x35C48CD5u) >> 16) ^ 0xFE)] ^ ((((v502 ^ 0x35C48CD5u) >> 16) ^ 0xD3)
                                                                                       + 1926004682
                                                                                       - ((2
                                                                                         * (((v502 ^ 0x35C48CD5u) >> 16) ^ 0xD3)
                                                                                         + 160207960) & 0x80C033C));
  v163 = 181304767 * *(_DWORD *)&v146[4 * (v136 ^ 0xC5)];
  v164 = (v161 - ((2 * v161) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * (v508 ^ 0x36)];
  v165 = *(_DWORD *)(v59 - 176);
  v166 = *(_DWORD *)&v140[4 * (BYTE2(v165) ^ 0xB3)] ^ ((BYTE2(v165) ^ 0x9E)
                                                     + 1926004683
                                                     + ((2
                                                       * (((BYTE2(v165) ^ 0x9E) + 44) & 0xFFFFFF9F ^ (HIWORD(v165) | 0x7FFFFFFE))) ^ 0x80C0003));
  v167 = (v166 - ((2 * v166) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (HIBYTE(v497) ^ 0x8B)];
  v503 = v164 - ((2 * v164) & 0x1F4DD7E4);
  v509 = v167 - ((2 * v167) & 0xA4A3D44A);
  v168 = *(_DWORD *)(v59 - 136) ^ 0x4BC73C3D;
  v169 = *(_DWORD *)&v143[4 * (BYTE1(v168) ^ 0x20)] ^ ((BYTE2(v168) ^ 0xD7)
                                                     + 1926004683
                                                     + ((2
                                                       * (((BYTE2(v168) ^ 0xD7) + 44) & 0xFFFFFF9F ^ (BYTE2(v168) ^ 0xD7 | 0x7FFFFFFE))) ^ 0x80C0003)) ^ *(_DWORD *)&v140[4 * (BYTE2(v168) ^ 0xFA)] ^ (v163 - 2 * ((v163 + 62414044) & 0xFA6EBF3 ^ v163 & 1) + 1935624398);
  v170 = (v162 - ((2 * v162) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * HIBYTE(v160)] ^ (181304767
                                                                                              * *(_DWORD *)&v146[4 * (v147 ^ 0x99)]
                                                                                              + 1673026780);
  v474 = BYTE1(v147) ^ 0x14;
  v454 = v497 ^ 0xA3;
  v482 = v170 - ((2 * v170) & 0x1F4DD7E4);
  v498 = v169 - ((2 * v169) & 0xA4A3D44A);
  v171 = *(_DWORD *)(v59 - 192);
  v463 = BYTE1(v171) ^ 0xF5;
  v476 = v469 ^ 0x2BEAE26B;
  v172 = ((v469 ^ 0x2BEAE26B) >> 16);
  v173 = *(_DWORD *)&v140[4 * (v172 ^ 0xEC)] ^ ((v172 ^ 0xC1)
                                              + 1926004683
                                              + ((2 * (((v172 ^ 0xC1) + 44) & 0xFFFFFF9F ^ (v172 ^ 0xC1 | 0x7FFFFFFE))) ^ 0x80C0003)) ^ (181304767 * *(_DWORD *)&v146[4 * (v469 ^ 0x1E)] + 1673026780);
  v174 = (v173 - ((2 * v173) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (BYTE1(v469) ^ 8)];
  v175 = *(_DWORD *)&v140[4 * (v499 ^ 0xD7)] ^ ((v499 ^ 0xFA)
                                              + 1926004683
                                              + ((2 * (((v499 ^ 0xFA) + 44) & 0xFFFFFF9F ^ (HIWORD(v485) | 0x7FFFFFFE))) ^ 0x80C0003));
  v176 = *(_DWORD *)&v146[4 * (v465 ^ 0x55)];
  v500 = v174 - ((2 * v174) & 0xA4A3D44A);
  v445 = BYTE2(v171) ^ 0xF7;
  v486 = (BYTE2(v171) ^ 0xA7)
       + 1926004683
       + ((2 * (((BYTE2(v171) ^ 0xA7) + 44) & 0xFFFFFF9F ^ (HIWORD(v171) ^ 0xBAF7 | 0x7FFFFFFE))) ^ 0x80C0003);
  v177 = (v175 - ((2 * v175) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (v578 ^ 0xD0)] ^ (181304767
                                                                                               * *(_DWORD *)&v146[4 * (v505 ^ 0xFA)]
                                                                                               + 1673026780);
  v470 = v177 - ((2 * v177) & 0xA4A3D44A);
  v178 = *(_DWORD *)(v59 - 184);
  v179 = (181304767 * v176 - ((362609534 * v176 - 948913736) & 0xA4A3D44A) + 906643201) ^ ((BYTE2(v178) ^ 0xBA)
                                                                                         + 1926004682
                                                                                         - ((2 * (BYTE2(v178) ^ 0xBA)
                                                                                           + 160207960) & 0x80C033C)) ^ *(_DWORD *)&v144[4 * (HIBYTE(v178) ^ 0x2F)] ^ *(_DWORD *)&v140[4 * (BYTE2(v178) ^ 0x97)];
  v466 = v179 - ((2 * v179) & 0x1F4DD7E4);
  v180 = *(_DWORD *)&v140[4 * (BYTE2(v443) ^ 0xCB)] ^ ((BYTE2(v443) ^ 0xE6)
                                                     + 1926004683
                                                     + ((2
                                                       * (((BYTE2(v443) ^ 0xE6) + 44) & 0xFFFFFF9F ^ (HIWORD(v443) | 0x7FFFFFFE))) ^ 0x80C0003));
  v181 = *(_DWORD *)&v140[4 * (BYTE2(*(_DWORD *)(v59 - 200)) ^ 0x56)] ^ ((BYTE2(*(_DWORD *)(v59 - 200)) ^ 0x7B)
                                                                                        + 1926004682
                                                                                        - ((2
                                                                                          * (BYTE2(*(_DWORD *)(v59 - 200)) ^ 0x7B)
                                                                                          + 160207960) & 0x80C033C));
  v182 = (v180 - ((2 * v180) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (BYTE1(v443) ^ 0x28)] ^ (181304767 * *(_DWORD *)&v146[4 * (v443 ^ 0xD9)] + 1673026780);
  v183 = 181304767 * *(_DWORD *)&v146[4 * (v460 ^ 0xFB)];
  LODWORD(v82) = (v183 - 2 * ((v183 + 62414044) & 0xFA6EBF3 ^ v183 & 1) + 1935624398) ^ *(_DWORD *)&v143[4 * (BYTE1(v460) ^ 0xEF)];
  LODWORD(v444) = v182 - ((2 * v182) & 0xA4A3D44A);
  LODWORD(v442) = (_DWORD)v82 - ((2 * (_DWORD)v82) & 0xA4A3D44A);
  v184 = (v181 - ((2 * v181) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * (HIBYTE(*(_DWORD *)(v59 - 200)) ^ 0xD9)] ^ (181304767 * *(_DWORD *)&v146[4 * (*(_DWORD *)(v59 - 200) ^ 0x79)] + 1673026780);
  v185 = *(_DWORD *)&v140[4 * (v479 ^ 0x86)] ^ ((v479 ^ 0xAB)
                                              + 1926004683
                                              + ((2 * (((v479 ^ 0xAB) + 44) & 0xFFFFFF9F ^ (v479 ^ 0xAB | 0x7FFFFFFE))) ^ 0x80C0003));
  v186 = (v185 - ((2 * v185) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * v494];
  v438 = v487 ^ 0xEE;
  v488 = v186 - ((2 * v186) & 0x1F4DD7E4);
  v480 = v184 - ((2 * v184) & 0x1F4DD7E4);
  v491 = v493;
  v506 = (v491 ^ 0x65) + 1926004682 - ((2 * (v491 ^ 0x65) + 160207960) & 0x80C033C);
  LODWORD(v579) = (HIDWORD(v579) + 351737562 + (~(2 * HIDWORD(v579)) | 0xD611D24D)) ^ v436;
  v187 = *(_DWORD *)&v140[4 * (v446 ^ 0x8B)] ^ ((v446 ^ 0xA6)
                                              + 1926004683
                                              + ((2 * (((v446 ^ 0xA6) + 44) & 0xFFFFFF9F ^ (HIWORD(v436) | 0x7FFFFFFE))) ^ 0x80C0003));
  v447 = BYTE2(*(_DWORD *)(v59 - 140)) ^ 0x63;
  v495 = (v447 ^ 0xEC)
       + 1926004683
       + ((2 * (((v447 ^ 0xEC) + 44) & 0xFFFFFF9F ^ (HIWORD(*(_DWORD *)(v59 - 140)) ^ 0x4263 | 0x7FFFFFFE))) ^ 0x80C0003);
  v188 = v455 ^ 0x22;
  v189 = *(_DWORD *)&v140[4 * (BYTE2(v451) ^ 0xE8)] ^ ((BYTE2(v451) ^ 0xC5)
                                                     + 1926004683
                                                     + ((2
                                                       * (((BYTE2(v451) ^ 0xC5) + 44) & 0xFFFFFF9F ^ (BYTE2(v451) ^ 0xC5 | 0x7FFFFFFE))) ^ 0x80C0003));
  HIDWORD(v442) = v441 ^ 0x8E;
  v190 = (181304767 * *(_DWORD *)&v146[4 * (v451 ^ 0xCA)] + 1673026780) ^ *(_DWORD *)&v144[4 * (HIBYTE(v451) ^ 0x8E)] ^ (v189 - ((2 * v189) & 0xA4A3D44A) - 766383579);
  v456 = v449 ^ 0x44039AAA;
  LODWORD(v82) = (181304767 * *(_DWORD *)&v146[4 * (v449 ^ 0xDB)] + 1673026780) ^ (((v449 ^ 0x44039AAAu) >> 16)
                                                                                                  + 1926004682
                                                                                                  - ((2 * ((v449 ^ 0x44039AAAu) >> 16) + 160207960) & 0x80C033C)) ^ *(_DWORD *)&v140[4 * (((v449 ^ 0x44039AAAu) >> 16) ^ 0x2D)];
  v440 = BYTE1(v451) ^ 0x16;
  v452 = v190 - ((2 * v190) & 0x1F4DD7E4);
  LODWORD(v82) = ((_DWORD)v82 - ((2 * (_DWORD)v82) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4
                                                                                               * (BYTE1(v449) ^ 0xC0)];
  v191 = *(_DWORD *)&v144[4 * v188] ^ (181304767 * *(_DWORD *)&v146[4 * (v471 ^ 0xFE)] + 1673026780) ^ (v187 - ((2 * v187) & 0xA4A3D44A) - 766383579);
  v472 = (_DWORD)v82 - ((2 * (_DWORD)v82) & 0xA4A3D44A);
  v450 = v191 - ((2 * v191) & 0x1F4DD7E4);
  v192 = *(_DWORD *)&v146[4 * (v522 ^ 0xEC)];
  v193 = *(_DWORD *)&v140[4 * (v558 ^ 0x32)] ^ ((v558 ^ 0x1F)
                                              + 1926004683
                                              + ((2 * (((v558 ^ 0x1F) + 44) & 0xFFFFFF9F ^ (v558 ^ 0x1F | 0x7FFFFFFE))) ^ 0x80C0003));
  LODWORD(v82) = *(_DWORD *)&v146[4 * (v545 ^ 0xE6)];
  v194 = *(_DWORD *)&v144[4 * (HIBYTE(v522) ^ 0xCA)] ^ *(_DWORD *)&v140[4 * (BYTE2(v522) ^ 2)] ^ ((BYTE2(v522) ^ 0x2F)
                                                                                                + 1926004683
                                                                                                + ((2
                                                                                                  * (((BYTE2(v522) ^ 0x2F) + 44) & 0xFFFFFF9F ^ (HIWORD(v522) ^ 0x45E5 | 0x7FFFFFFE))) ^ 0x80C0003)) ^ (181304767 * v192 - ((362609534 * v192 - 948913736) & 0xA4A3D44A) + 906643201);
  v195 = (v193 - ((2 * v193) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (v571 ^ 0x8C)] ^ (181304767
                                                                                               * *(_DWORD *)&v146[4 * (v567 ^ 0xD9)]
                                                                                               + 1673026780);
  LODWORD(v82) = *(_DWORD *)&v144[4 * ((v545 ^ 0x49A657C7u) >> 24)] ^ ((((v545 ^ 0x49A657C7u) >> 16) ^ 0x35)
                                                                     + 1926004682
                                                                     - ((2
                                                                       * (((v545 ^ 0x49A657C7u) >> 16) ^ 0x35)
                                                                       + 160207960) & 0x80C033C)) ^ *(_DWORD *)&v140[4 * (((v545 ^ 0x49A657C7u) >> 16) ^ 0x18)] ^ ((~(362609534 * (_DWORD)v82 - 948913736) | 0x5B5C2BB5) + 181304767 * (_DWORD)v82 + 906643202);
  v196 = *(_DWORD *)(v59 - 152);
  v197 = *(_DWORD *)&v140[4 * (((v196 ^ 0xDF88996C) >> 16) ^ 0x2D)] ^ (((v196 ^ 0xDF88996C) >> 16)
                                                                                      + 1926004683
                                                                                      + ((2
                                                                                        * ((((v196 ^ 0xDF88996C) >> 16)
                                                                                          + 44) & 0xFFFFFF9F ^ (((v196 ^ 0xDF88996C) >> 16) | 0x7FFFFFFE))) ^ 0x80C0003));
  v572 = v583 ^ 0xAA;
  LODWORD(v584) = (v194 - ((2 * v194) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (BYTE1(v522) ^ 0x2E)];
  v568 = v195 - ((2 * v195) & 0xA4A3D44A);
  v523 = BYTE1(v545) ^ 0xB9;
  v198 = (v197 - ((2 * v197) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * ((v196 ^ 0xDF88996C) >> 24)] ^ (181304767 * *(_DWORD *)&v146[4 * (v196 ^ 0xFC)] + 1673026780);
  v559 = (_DWORD)v82 - ((2 * (_DWORD)v82) & 0x1F4DD7E4);
  v546 = v198 - ((2 * v198) & 0x1F4DD7E4);
  v199 = *(_DWORD *)&v140[4 * (v532 ^ 0xC1)] ^ ((v532 ^ 0xEC)
                                              + 1926004683
                                              + ((2 * (v532 ^ 0xEC) + 88) & 0x33C ^ 0xF7F3FFFF));
  v200 = (v199 - ((2 * v199) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4
                                                                         * ((v540 - ((2 * v535) & 0x166) + 179) ^ 0x54)] ^ (181304767 * *(_DWORD *)&v146[4 * (v564 ^ 0xE2)] + 1673026780);
  v201 = *(_DWORD *)&v146[4 * (v549 ^ 0xE4)];
  v533 = BYTE1(v553) ^ 0x77;
  v202 = (181304767 * v201 - ((362609534 * v201 - 948913736) & 0xA4A3D44A) + 906643201) ^ *(_DWORD *)&v144[4 * (HIBYTE(v549) ^ 0x69)];
  v434 = ((unsigned __int16)(v549 ^ 0xB2F5) >> 8) ^ 0xD;
  v565 = v200 - ((2 * v200) & 0xA4A3D44A);
  v437 = v202 - ((2 * v202) & 0x1F4DD7E4);
  v536 = v526 ^ 0xEEA2BFA8;
  v203 = *(_DWORD *)&v140[4 * (((v526 ^ 0xEEA2BFA8) >> 16) ^ 0x86)] ^ ((((v526 ^ 0xEEA2BFA8) >> 16) ^ 0xAB)
                                                                                      + 1926004682
                                                                                      - ((2
                                                                                        * (((v526 ^ 0xEEA2BFA8) >> 16) ^ 0xAB)
                                                                                        + 160207960) & 0x80C033C));
  v204 = (181304767 * *(_DWORD *)&v146[4 * (v526 ^ 0x68)] + 1673026780) ^ *(_DWORD *)&v143[4 * (BYTE1(v526) ^ 0x55)] ^ (v203 - ((2 * v203) & 0x1F4DD7E4) + 262597618);
  v527 = v553 ^ 0x231B9DB5;
  v205 = ((v553 ^ 0x231B9DB5) >> 16);
  v432 = v205 ^ 0xEC;
  v541 = (v205 ^ 0xC1) + 1926004683 + ((2 * (v205 ^ 0xC1) + 88) & 0x33C ^ 0xF7F3FFFF);
  HIDWORD(v433) = v204 - ((2 * v204) & 0xA4A3D44A);
  v430 = BYTE2(v549) ^ 0x55;
  v539 = (BYTE2(v549) ^ 0x78) + 1926004682 - ((2 * (BYTE2(v549) ^ 0x78) + 160207960) & 0x80C033C);
  LODWORD(v79) = v594 ^ 0x982356D6;
  LODWORD(v433) = v587 ^ 0x7B;
  LODWORD(v68) = *(_DWORD *)&v146[4 * (v585 ^ 0x74)];
  v206 = *(_DWORD *)(v59 - 128);
  v207 = v171;
  LODWORD(v78) = *(_DWORD *)&v146[4 * (v598 ^ 0x97)];
  v208 = *(_DWORD *)(v59 - 140);
  v209 = *(_DWORD *)&v146[4 * (v553 ^ 0x75)];
  v210 = *(_DWORD *)&v146[4 * (v594 ^ 0xEF)];
  v554 = 181304767 * *(_DWORD *)&v146[4 * (v131 ^ 0x60)] + 1673026780;
  v601 = 181304767 * *(_DWORD *)&v146[4 * (v600 ^ 0xFB)] + 1673026780;
  v595 = 181304767 * *(_DWORD *)&v146[4 * (v206 ^ 0xB8)] + 1673026780;
  v599 = 181304767 * *(_DWORD *)&v146[4 * (v151 ^ 0xAC)] + 1673026780;
  v550 = 181304767 * *(_DWORD *)&v146[4 * v454] + 1673026780;
  v551 = 181304767 * *(_DWORD *)&v146[4 * (v576 ^ 0xF0)] + 1673026780;
  v211 = 181304767 * *(_DWORD *)&v146[4 * (v171 ^ 0x57)] + 1673026780;
  v588 = 181304767 * v78 + 1673026780;
  HIDWORD(v453) = 181304767 * *(_DWORD *)&v146[4 * (v208 ^ 0x78)] + 1673026780;
  v459 = 181304767 * v209 + 1673026780;
  v586 = 181304767 * v210 + 1673026780;
  v212 = (181304767 * (_DWORD)v68 - ((362609534 * (_DWORD)v68 - 948913736) & 0xA4A3D44A) + 906643201) ^ *(_DWORD *)&v144[4 * v433];
  v213 = *(_DWORD *)&v140[4 * (BYTE2(v602) ^ 0xA8)] ^ ((BYTE2(v602) ^ 0x85)
                                                     + 1926004683
                                                     + ((2
                                                       * (((BYTE2(v602) ^ 0x85) + 44) & 0xFFFFFF9F ^ (BYTE2(v602) ^ 0x85 | 0x7FFFFFFE))) ^ 0x80C0003)) ^ (181304767 * *(_DWORD *)&v146[4 * (v602 ^ 0x51)] + 1673026780);
  v214 = (v213 - ((2 * v213) & 0x1F4DD7E4) + 262597618) ^ *(_DWORD *)&v143[4 * (BYTE1(v602) ^ 0x2B)];
  LODWORD(v82) = *(_DWORD *)&v140[4 * (BYTE2(v79) ^ 0x3C)] ^ ((BYTE2(v79) ^ 0x11)
                                                            + 1926004683
                                                            + ((2
                                                              * (((BYTE2(v79) ^ 0x11) + 44) & 0xFFFFFF9F ^ (BYTE2(v79) ^ 0x11 | 0x7FFFFFFE))) ^ 0x80C0003));
  v215 = (181304767 * *(_DWORD *)&v146[4 * (v603 ^ 0x2A)] + 1673026780) ^ ((BYTE2(v603) ^ 0x37)
                                                                                          + 1926004683
                                                                                          + ((2 * (BYTE2(v603) ^ 0x37)
                                                                                            + 88) & 0x33C ^ 0xF7F3FFFF)) ^ *(_DWORD *)&v140[4 * (BYTE2(v603) ^ 0x1A)];
  v216 = v212 - ((2 * v212) & 0x1F4DD7E4);
  LODWORD(v433) = *(_DWORD *)&v140[4 * (v529 ^ 0x61)];
  HIDWORD(v444) = *(_DWORD *)&v140[4 * (v445 ^ 0x7D)];
  v217 = (v215 - ((2 * v215) & 0xA4A3D44A) - 766383579) ^ *(_DWORD *)&v144[4 * (HIBYTE(v603) ^ 0xF9)];
  v530 = *(_DWORD *)&v140[4 * (v491 ^ 0x48)];
  LODWORD(v431) = *(_DWORD *)&v140[4 * (BYTE2(v208) ^ 0xA2)];
  LODWORD(v448) = *(_DWORD *)&v140[4 * v432];
  v492 = *(_DWORD *)&v140[4 * v430];
  LODWORD(v68) = *(_DWORD *)(v59 - 232);
  *(_DWORD *)(v59 - 232) = *(_DWORD *)&v140[4 * (v68 ^ 0x1A)];
  LODWORD(v140) = ((*(_DWORD *)(v59 - 256) >> 15) & 0x58 ^ 0x48) + (v68 ^ 0x4C64A1B);
  HIDWORD(v431) = *(_DWORD *)&v143[4 * v543];
  v544 = *(_DWORD *)&v143[4 * HIDWORD(v442)];
  *(_DWORD *)(v59 - 256) = *(_DWORD *)&v143[4 * (BYTE1(v206) ^ 0x85)];
  *(_DWORD *)(v59 - 160) = *(_DWORD *)&v143[4 * (BYTE1(*(_DWORD *)(v59 - 160)) ^ 0xBD)];
  *(_DWORD *)(v59 - 168) = *(_DWORD *)&v143[4 * (BYTE1(*(_DWORD *)(v59 - 168)) ^ 0xB4)];
  HIDWORD(v429) = *(_DWORD *)&v143[4 * (v596 ^ 0x1A)];
  LODWORD(v429) = *(_DWORD *)&v143[4 * v474];
  v597 = *(_DWORD *)&v143[4 * v463];
  *(_DWORD *)(v59 - 184) = *(_DWORD *)&v143[4 * (BYTE1(*(_DWORD *)(v59 - 184)) ^ 0xD6)];
  v475 = *(_DWORD *)&v143[4 * v438];
  HIDWORD(v442) = *(_DWORD *)&v143[4 * (BYTE1(*(_DWORD *)(v59 - 200)) ^ 0xD7)];
  HIDWORD(v428) = *(_DWORD *)&v143[4 * (BYTE1(v208) ^ 0x76)];
  v218 = *(_DWORD *)&v143[4 * v440];
  v464 = (_DWORD)v140
       + 1845900703
       + ((2 * ((unsigned __int16)v140 & 0x19F ^ (v68 ^ 0x4C64A1B | 0x7FFFFFFE))) ^ 0x80C0003);
  LODWORD(v428) = *(_DWORD *)&v143[4 * (v591 ^ 0xBE)];
  *(_DWORD *)(v59 - 200) = *(_DWORD *)&v143[4 * v523];
  *(_DWORD *)(v59 - 152) = *(_DWORD *)&v143[4 * (BYTE1(*(_DWORD *)(v59 - 152)) ^ 0x19)];
  v219 = v214 - ((2 * v214) & 0xA4A3D44A);
  v524 = *(_DWORD *)&v143[4 * v533];
  v534 = *(_DWORD *)&v143[4 * v434];
  *(_DWORD *)(v59 - 220) = *(_DWORD *)&v143[4 * (*(_DWORD *)(v59 - 220) ^ 0x84)];
  HIDWORD(v439) = *(_DWORD *)&v143[4 * (BYTE1(v603) ^ 0x2E)];
  v220 = *(_DWORD *)&v143[4 * (BYTE1(*(_DWORD *)(v59 - 248)) ^ 0xC8)];
  v561 = v560 + 262597618;
  v556 = v555 + 262597618;
  *(_DWORD *)(v59 - 248) = v517 + 262597618;
  LODWORD(v439) = v514 + 262597618;
  v604 = v510 + 262597618;
  LODWORD(v435) = v503 + 262597618;
  HIDWORD(v427) = v482 + 262597618;
  v592 = v466 + 262597618;
  v518 = v488 + 262597618;
  v467 = v480 + 262597618;
  v221 = v452 + 262597618;
  LODWORD(v426) = v450 + 262597618;
  v504 = v559 + 262597618;
  v489 = v546 + 262597618;
  LODWORD(v453) = v437 + 262597618;
  v511 = v216 + 262597618;
  v515 = v217 - ((2 * v217) & 0x1F4DD7E4) + 262597618;
  LODWORD(v427) = *(_DWORD *)&v144[4 * v569];
  *(_DWORD *)(v59 - 216) = *(_DWORD *)&v144[4 * (*(_DWORD *)(v59 - 216) ^ 7)];
  HIDWORD(v426) = *(_DWORD *)&v144[4 * (HIBYTE(*(_DWORD *)(v59 - 176)) ^ 0x19)];
  v547 = *(_DWORD *)&v144[4 * (HIBYTE(*(_DWORD *)(v59 - 136)) ^ 0x3C)];
  v483 = *(_DWORD *)&v144[4 * (HIBYTE(v207) ^ 0xB8)];
  v481 = *(_DWORD *)&v144[4 * HIBYTE(v476)];
  *(_DWORD *)(v59 - 208) = *(_DWORD *)&v144[4 * (*(_DWORD *)(v59 - 208) ^ 0x4B)];
  HIDWORD(v448) = *(_DWORD *)&v144[4 * (HIBYTE(v563) ^ 0xB9)];
  HIDWORD(v435) = *(_DWORD *)&v144[4 * (HIBYTE(v460) ^ 0xE8)];
  v222 = v220 ^ ((_DWORD)v82 - ((2 * (_DWORD)v82) & 0x1F4DD7E4) + 262597618);
  v223 = *(_DWORD *)&v144[4 * (HIBYTE(v208) ^ 0xA6)];
  v224 = *(_DWORD *)&v144[4 * HIBYTE(v456)];
  v477 = *(_DWORD *)&v144[4 * v572];
  v225 = HIBYTE(v536);
  *(_DWORD *)(v59 - 192) = *(_DWORD *)&v144[4 * HIBYTE(v527)];
  v537 = *(_DWORD *)&v144[4 * (*(_DWORD *)(v59 - 240) ^ 0x38)];
  v528 = *(_DWORD *)&v144[4 * v225];
  v457 = *(_DWORD *)&v144[4 * (HIBYTE(v602) ^ 0x4B)];
  *(_DWORD *)(v59 - 176) = *(_DWORD *)&v144[4 * (v79 >> 24)];
  v226 = v574 - 766383579;
  v461 = v521 - 766383579;
  *(_DWORD *)(v59 - 240) = v500 - 766383579;
  v227 = v568 - 766383579;
  v228 = v565 - 766383579;
  v229 = v219 - 766383579;
  v230 = v222 - ((2 * v222) & 0xA4A3D44A) - 766383579;
  v231 = HIDWORD(v584) ^ v584 ^ 0x6285F181;
  v232 = v221 ^ v218 ^ v231;
  v233 = *(_DWORD *)(v59 - 132);
  v234 = (char *)*(&off_100180420 + (v233 ^ 0x19)) - 4;
  v235 = (char *)*(&off_100180420 + v233 - 159) - 4;
  v236 = (char *)*(&off_100180420 + (v233 ^ 0xDC)) - 12;
  v237 = (char *)*(&off_100180420 + (v233 | 2)) - 4;
  v238 = *(unsigned __int8 *)(v59 - 112);
  v239 = (v237[*(unsigned __int8 *)(v59 - 109) ^ 0x41] ^ 0x56) & 0xFF00FFFF | (((v234[*(unsigned __int8 *)(v59 - 111) ^ 0x40] + 98) ^ 0x5A) << 16) | ((v236[*(unsigned __int8 *)(v59 - 110) ^ 0xBBLL] ^ 0xA8) << 8) | ((v235[v238 ^ 0x1E] ^ ((_DWORD)v238 - ((2 * (_DWORD)v238) & 0x55555555) + 42) ^ 0x84) << 24);
  v573 = v236;
  v575 = v235;
  v570 = v237;
  v240 = (v237[*(unsigned __int8 *)(v59 - 105) ^ 0xE4] ^ 0x60) & 0xFF00FFFF | ((v235[*(unsigned __int8 *)(v59 - 108) ^ 0x3ELL] ^ (*(unsigned __int8 *)(v59 - 108) - ((2 * *(unsigned __int8 *)(v59 - 108)) & 0x54) + 42) ^ 0xFFFFFFE1) << 24) | (((v234[*(unsigned __int8 *)(v59 - 107) ^ 0x27] + 98) ^ 0x96) << 16) | ((v236[*(unsigned __int8 *)(v59 - 106) ^ 9] ^ 0xAD) << 8);
  v577 = v234;
  v241 = (v237[*(unsigned __int8 *)(v59 - 101) ^ 0xF2] ^ 0xD9) & 0xFF00FFFF | ((v235[*(unsigned __int8 *)(v59 - 104) ^ 0xD3] ^ (*(unsigned __int8 *)(v59 - 104) - ((2 * *(unsigned __int8 *)(v59 - 104)) & 0x5555) + 42) ^ 0xE0) << 24) | ((v236[*(unsigned __int8 *)(v59 - 102) ^ 0xBELL] ^ 0xA) << 8) & 0xFF00FFFF | (((v234[*(unsigned __int8 *)(v59 - 103) ^ 0xE9] + 98) ^ 0x8A) << 16);
  v242 = v232 ^ 0x2497E332;
  if ((v232 & 0x80) != 0)
    v243 = -128;
  else
    v243 = 128;
  *(_DWORD *)(v59 - 128) = (v237[*(unsigned __int8 *)(v59 - 97) ^ 0x74] ^ 0xF1 | (((v234[*(unsigned __int8 *)(v59 - 99) ^ 0xF3] + 98) ^ 2) << 16) | ((v236[*(unsigned __int8 *)(v59 - 98) ^ 0x20] ^ 0x42) << 8) | ((v235[*(unsigned __int8 *)(v59 - 100) ^ 0xF3] ^ (*(unsigned __int8 *)(v59 - 100) - ((2 * *(unsigned __int8 *)(v59 - 100)) & 0x5555) + 42) ^ 0x85) << 24)) ^ 0xB2752A7C;
  *(_DWORD *)(v59 - 132) = v239 ^ 0x20B69626;
  *(_DWORD *)(v59 - 136) = v240 ^ 0x20955490;
  *(_DWORD *)(v59 - 140) = v241 ^ 0xAA7DEC48;
  HIDWORD(v566) = v426 ^ v428;
  LODWORD(v566) = v223 ^ HIDWORD(v428) ^ v431 ^ v495 ^ HIDWORD(v453);
  HIDWORD(v562) = (v472 - 766383579) ^ v224;
  LODWORD(v562) = v554 ^ HIDWORD(v431) ^ v561;
  HIDWORD(v557) = v556 ^ v544;
  LODWORD(v557) = v427 ^ v589 ^ v433 ^ v226;
  HIDWORD(v552) = HIDWORD(v427) ^ v429;
  LODWORD(v552) = v435 ^ HIDWORD(v429) ^ v551;
  HIDWORD(v548) = (v509 - 766383579) ^ HIDWORD(v426) ^ v550;
  LODWORD(v548) = (v498 - 766383579) ^ v547;
  HIDWORD(v542) = v524 ^ *(_DWORD *)(v59 - 192) ^ v541 ^ v448 ^ v459;
  LODWORD(v542) = v534 ^ v539 ^ v492 ^ v453;
  HIDWORD(v538) = (HIDWORD(v433) - 766383579) ^ v528;
  LODWORD(v538) = v228 ^ v537;
  HIDWORD(v531) = v467 ^ HIDWORD(v442);
  LODWORD(v531) = HIDWORD(v435) ^ v506 ^ v530 ^ (v442 - 766383579);
  HIDWORD(v525) = (v444 - 766383579) ^ HIDWORD(v448);
  LODWORD(v525) = v588 ^ v475 ^ v518;
  HIDWORD(v519) = v586 ^ *(_DWORD *)(v59 - 176) ^ v230;
  LODWORD(v519) = v515 ^ HIDWORD(v439);
  HIDWORD(v512) = v229 ^ v457;
  LODWORD(v512) = *(_DWORD *)(v59 - 220) ^ v464 ^ *(_DWORD *)(v59 - 232) ^ v511;
  HIDWORD(v507) = v227 ^ v477;
  LODWORD(v507) = *(_DWORD *)(v59 - 200) ^ v504;
  HIDWORD(v501) = v489 ^ *(_DWORD *)(v59 - 152);
  LODWORD(v501) = v439 ^ *(_DWORD *)(v59 - 160);
  HIDWORD(v496) = *(_DWORD *)(v59 - 248) ^ *(_DWORD *)(v59 - 256) ^ v595;
  LODWORD(v496) = v599 ^ *(_DWORD *)(v59 - 168) ^ v604;
  HIDWORD(v490) = v601 ^ *(_DWORD *)(v59 - 216) ^ v461;
  LODWORD(v490) = v592 ^ *(_DWORD *)(v59 - 184);
  HIDWORD(v484) = v597 ^ v483 ^ HIDWORD(v444) ^ v486 ^ v211;
  LODWORD(v484) = (v470 - 766383579) ^ *(_DWORD *)(v59 - 208);
  HIDWORD(v478) = *(_DWORD *)(v59 - 240) ^ v481;
  LODWORD(v478) = (v243 + v242) ^ v231;
  v244 = *(_DWORD *)(v59 - 120);
  HIDWORD(v473) = v244 ^ 0x471;
  LODWORD(v473) = v244 ^ 0x413;
  HIDWORD(v468) = v244 ^ 0x4B3;
  LODWORD(v468) = v244 ^ 0x43F;
  HIDWORD(v462) = v244 ^ 0x4C0;
  LODWORD(v462) = v244 ^ 0x484;
  HIDWORD(v458) = v244 ^ 0x481;
  LODWORD(v458) = v244 ^ 0x4A3;
  v245 = v244;
  *(_QWORD *)(v59 - 184) = 13;
  v246 = v234[a54[13] ^ 0xF3] + 98;
  v247 = ((v244 ^ 0xD3) + 780051030) ^ 0x2E7EA754u;
  *(_QWORD *)(v59 - 152) = v247;
  v248 = (v246 ^ 2) << 16;
  v249 = a54[v247] ^ 0x57;
  *(_QWORD *)(v59 - 160) = 10;
  v250 = a54[10] ^ 0xB6;
  v251 = ((v577[v249] + 98) ^ 0xF6) << 16;
  *(_QWORD *)(v59 - 192) = 4;
  v252 = (v573[v250] ^ 0x27) << 8;
  v253 = a54[4];
  v254 = v235[v253 ^ 0x9A];
  *(_QWORD *)(v59 - 232) = 7;
  LODWORD(v253) = v254 ^ (v253 - ((2 * v253) & 0x54) + 42) ^ 0xFFFFFFCF;
  v255 = a54[7] ^ 0xD6;
  *(_QWORD *)(v59 - 216) = 2;
  LODWORD(v253) = v570[v255] ^ 0x33 | ((_DWORD)v253 << 24);
  LODWORD(v255) = v573[a54[2]] ^ 0x35;
  *(_QWORD *)(v59 - 176) = 3;
  v256 = v251 | ((_DWORD)v255 << 8);
  LODWORD(v255) = v570[a54[3] ^ 0x74];
  *(_QWORD *)(v59 - 168) = 12;
  v257 = v256 | v255 ^ 0xF1;
  LODWORD(v255) = v235[a54[12] ^ 0x6ELL] ^ (a54[12] - ((2 * a54[12]) & 0x5555) + 42) ^ 0x51;
  *(_QWORD *)(v59 - 208) = 0;
  v258 = v257 | ((v235[*a54 ^ 0x15] ^ (*a54 + (~(2 * *a54) | 0xAB) + 43) ^ 0xAE) << 24);
  v259 = v252 | ((v235[a54[8] ^ 0x46] ^ (a54[8] - ((2 * a54[8]) & 0x54) + 42) ^ 0xFFFFFFE7) << 24);
  *(_QWORD *)(v59 - 200) = 14;
  v260 = v573[a54[14] ^ 0xD5] ^ 0xBD;
  *(_QWORD *)(v59 - 240) = 5;
  *(_QWORD *)(v59 - 256) = 11;
  *(_DWORD *)(v59 - 220) = 780052319;
  LODWORD(v253) = v253 & 0xFF00FFFF | (((v577[a54[5] ^ 0x9DLL] + 98) ^ 0xF7) << 16);
  v261 = a54[6] ^ 0xA4;
  v262 = (v570[a54[11] ^ 0xC2] ^ 0xD4 | v259) & 0xFF00FFFF | (((v577[a54[9] ^ 0x3ELL]
                                                                                                  + 98) ^ 0xDF) << 16);
  *(_QWORD *)(v59 - 248) = 15;
  v593 = v253 | ((v573[v261] ^ 0xED) << 8);
  v263 = (char *)*(&off_100180420 + v245 - 830) - 12;
  LODWORD(v253) = *(_DWORD *)&v263[4 * (((unsigned __int16)(v593 ^ v580) >> 8) ^ 0x21)] ^ ((((unsigned __int16)(v593 ^ v580) >> 8) ^ 0x4C) + 1520843255 - ((2 * (((v593 ^ v580) >> 8) ^ 0xB71C4C)) & 0x1EE));
  LODWORD(v261) = v253 + 513343004 - ((2 * v253) & 0x3D31FC38);
  v264 = (char *)*(&off_100180420 + SHIDWORD(v473)) - 8;
  v265 = v258 ^ HIDWORD(v580) ^ 0x730032AA;
  v266 = v261 ^ *(_DWORD *)&v264[4 * ((v258 ^ BYTE4(v580)) ^ 0xAA)];
  v590 = v570[a54[15] ^ 0x47] ^ 0xF1 | v248 | ((_DWORD)v255 << 24) | (v260 << 8);
  LODWORD(v261) = *(_DWORD *)&v263[4 * (((unsigned __int16)(v579 ^ v590) >> 8) ^ 0x1A)] ^ ((((unsigned __int16)(v579 ^ v590) >> 8) ^ 0x77) + 1520843255 - ((2 * (((v579 ^ v590) >> 8) ^ 0x420777)) & 0x1EE));
  v267 = v261 + 2111680599 - ((2 * v261) & 0xFBBB60AE);
  v268 = (char *)*(&off_100180420 + (int)v473) - 8;
  v269 = *(_DWORD *)&v268[4 * (((v262 ^ HIDWORD(v579)) >> 16) ^ 0x68)];
  HIDWORD(v271) = v269 ^ 0x1C5;
  LODWORD(v271) = v269 ^ 0xDB22D000;
  v270 = v271 >> 12;
  LODWORD(v255) = *(_DWORD *)&v268[4 * (BYTE2(v258) ^ BYTE6(v580))];
  HIDWORD(v271) = v255 ^ 0x1C5;
  LODWORD(v271) = v255 ^ 0xDB22D000;
  v272 = (char *)*(&off_100180420 + v245 - 870) - 8;
  v273 = *(_DWORD *)&v272[4 * (((v593 ^ v580) >> 24) ^ 0xB7)] ^ (v271 >> 12);
  v274 = *(_DWORD *)&v268[4 * (((v579 ^ v590) >> 16) ^ 7)];
  HIDWORD(v271) = v274 ^ 0x1C5;
  LODWORD(v271) = v274 ^ 0xDB22D000;
  v275 = v267 ^ v273;
  v276 = *(_DWORD *)&v264[4 * ((v593 ^ v580) ^ 0xFB)] ^ (BYTE1(v262) ^ BYTE5(v579)) ^ *(_DWORD *)&v263[4 * ((BYTE1(v262) ^ BYTE5(v579)) ^ 0x23)] ^ 0x443EC7A5 ^ (v271 >> 12);
  v277 = *(_DWORD *)&v268[4 * (((v593 ^ v580) >> 16) ^ 0x1C)];
  HIDWORD(v271) = v277 ^ 0x1C5;
  LODWORD(v271) = v277 ^ 0xDB22D000;
  v278 = *(_DWORD *)&v272[4 * (((v262 ^ HIDWORD(v579)) >> 24) ^ 0xF6)] ^ (BYTE1(v265)
                                                                        + 1520843255
                                                                        - ((v265 >> 7) & 0x1EE)) ^ *(_DWORD *)&v263[4 * (BYTE1(v265) ^ 0x6D)] ^ ((v271 >> 12) + 2111680599 - ((2 * (v271 >> 12)) & 0xFBBB60AE));
  v279 = *(_DWORD *)&v272[4 * HIBYTE(v265)];
  v280 = v426 ^ v428 ^ *(_DWORD *)&v272[4 * (((v579 ^ v590) >> 24) ^ 0x42)] ^ v270 ^ (v266
                                                                                                  + 2111680599
                                                                                                  - ((2 * v266) & 0xFBBB60AE));
  v281 = v566 ^ *(_DWORD *)&v264[4 * ((v579 ^ v590) ^ 0x96)] ^ (v278
                                                                               + 513343004
                                                                               - ((2 * v278) & 0x3D31FC38));
  v282 = HIDWORD(v562) ^ *(_DWORD *)&v264[4 * ((v262 ^ BYTE4(v579)) ^ 0x5F)] ^ (v275
                                                                                               + 513343004
                                                                                               - ((2 * v275) & 0x3D31FC38));
  v283 = v478 ^ v279 ^ (v276 + 2111680599 - ((2 * v276) & 0xFBBB60AE));
  v284 = ((unsigned __int16)(v478 ^ v279 ^ (v276 - 20393 - ((2 * v276) & 0x60AE))) >> 8) ^ 0x68;
  v285 = v280 ^ 0xF9388C2F;
  v286 = *(_DWORD *)&v268[4 * ((v280 ^ 0xF9388C2F) >> 16)];
  HIDWORD(v271) = v286 ^ 0x1C5;
  LODWORD(v271) = v286 ^ 0xDB22D000;
  v287 = v271 >> 12;
  v288 = *(_DWORD *)&v268[4 * (BYTE2(v281) ^ 0x8F)];
  HIDWORD(v271) = v288 ^ 0x1C5;
  LODWORD(v271) = v288 ^ 0xDB22D000;
  v289 = v271 >> 12;
  v290 = *(_DWORD *)&v268[4 * (BYTE2(v282) ^ 0x66)];
  HIDWORD(v271) = v290 ^ 0x1C5;
  LODWORD(v271) = v290 ^ 0xDB22D000;
  v291 = (v271 >> 12) ^ *(_DWORD *)&v263[4 * (v284 ^ 0x6D)] ^ (v284
                                                             + 1520843255
                                                             - ((2 * ((v283 >> 8) ^ 0x42BD68)) & 0x1EE));
  v292 = (v287 + 513343004 - ((2 * v287) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v282 ^ 0xB6)];
  v293 = (v291 + 513343004 - ((2 * v291) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v280 ^ 0x61)];
  v294 = (((unsigned __int16)(v280 ^ 0x8C2F) >> 8) + 1520843255 - (((v280 ^ 0xF9388C2F) >> 7) & 0x1EE)) ^ 0xD678EAEF ^ *(_DWORD *)&v263[4 * (((unsigned __int16)(v280 ^ 0x8C2F) >> 8) ^ 0x6D)];
  v295 = *(_DWORD *)&v272[4 * (HIBYTE(v282) ^ 0x43)] ^ 0xDFC7EBE9;
  v296 = v294 + v295;
  v297 = v294 & v295;
  v298 = *(_DWORD *)&v268[4 * (BYTE2(v283) ^ 0xBD)];
  HIDWORD(v271) = v298 ^ 0x1C5;
  LODWORD(v271) = v298 ^ 0xDB22D000;
  LODWORD(v247) = (v296 - 2 * v297) ^ (v271 >> 12);
  v299 = *(_DWORD *)&v272[4 * HIBYTE(v285)] ^ (v289 + 2111680599 - ((2 * v289) & 0xFBBB60AE));
  v300 = (v299 + 513343004 - ((2 * v299) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v283 ^ 0xAB)];
  v301 = *(_DWORD *)&v272[4 * (HIBYTE(v283) ^ 0x42)] ^ HIDWORD(v584) ^ *(_DWORD *)&v263[4 * (BYTE1(v281) ^ 0xF7)] ^ ((BYTE1(v281) ^ 0x9A) + 1520843255 - ((2 * ((v281 >> 8) ^ 0x88F9A)) & 0x1EE)) ^ (v292 + 2111680599 - ((2 * v292) & 0xFBBB60AE));
  v302 = v562 ^ *(_DWORD *)&v263[4 * (BYTE1(v282) ^ 0x39)] ^ (v300 + 1520843255 - ((2 * v300) & 0xB54C73EE));
  v303 = HIDWORD(v557) ^ *(_DWORD *)&v272[4 * (HIBYTE(v281) ^ 8)] ^ (v293 + 2111680599 - ((2 * v293) & 0xFBBB60AE));
  v304 = v557 ^ *(_DWORD *)&v264[4 * (v281 ^ 0xBF)] ^ (v247 + 513343004 - ((2 * v247) & 0x3D31FC38));
  LODWORD(v247) = *(_DWORD *)&v268[4 * (BYTE2(v304) ^ 0x79)];
  HIDWORD(v271) = v247 ^ 0x1C5;
  LODWORD(v271) = v247 ^ 0xDB22D000;
  BYTE1(v285) = ((unsigned __int16)(WORD2(v557) ^ *(_WORD *)&v272[4 * (HIBYTE(v281) ^ 8)] ^ (v293
                                                                                           - 20393
                                                                                           - ((2 * v293) & 0x60AE))) >> 8) ^ 0x68;
  v305 = ((v271 >> 12) + 2111680599 - ((2 * (v271 >> 12)) & 0xFBBB60AE)) ^ *(_DWORD *)&v272[4
                                                                                          * ((v303 ^ 0x2261685E) >> 24)];
  LODWORD(v247) = ((BYTE1(v304) ^ 0xD0) + 1520843255 - 2 * (BYTE1(v304) ^ 0xD0 ^ (v304 >> 8) & 8)) ^ *(_DWORD *)&v263[4 * (BYTE1(v304) ^ 0xBD)];
  LODWORD(v247) = (v247 + 513343004 - ((2 * v247) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v301 ^ 0x76)];
  v306 = ((BYTE1(v302) ^ 0xEC) + 1520843255 - ((2 * ((v302 >> 8) ^ 0xE5FEC)) & 0x1EE)) ^ *(_DWORD *)&v263[4 * (BYTE1(v302) ^ 0x81)];
  v307 = *(_DWORD *)&v268[4 * (BYTE2(v302) ^ 0x5F)];
  HIDWORD(v271) = v307 ^ 0x1C5;
  LODWORD(v271) = v307 ^ 0xDB22D000;
  v308 = v271 >> 12;
  HIDWORD(v271) = *(_DWORD *)&v264[4 * (v303 ^ 0x5E)] ^ 0xF78FD994;
  LODWORD(v271) = HIDWORD(v271);
  v309 = (v271 >> 28) ^ __ROR4__(*(_DWORD *)&v272[4 * (HIBYTE(v304) ^ 6)] ^ 0x7462B151 ^ (v306+ 2111680599- ((2 * v306) & 0xFBBB60AE)), 28);
  v310 = (v308 + 2111680599 - ((2 * v308) & 0xFBBB60AE)) ^ *(_DWORD *)&v272[4 * (HIBYTE(v301) ^ 0xD2)];
  v311 = *(_DWORD *)&v268[4 * (BYTE2(v303) ^ 0x1B)];
  v312 = (v310 + 513343004 - ((2 * v310) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v304 ^ 0x4C)];
  HIDWORD(v271) = v311 ^ 0x1C5;
  LODWORD(v271) = v311 ^ 0xDB22D000;
  v313 = v271 >> 12;
  v314 = *(_DWORD *)&v268[4 * (BYTE2(v301) ^ 0xCC)];
  HIDWORD(v271) = v314 ^ 0x1C5;
  LODWORD(v271) = v314 ^ 0xDB22D000;
  v315 = HIDWORD(v427) ^ v429 ^ (v271 >> 12) ^ __ROR4__(v309 ^ 0x78071371, 4);
  v316 = v552 ^ *(_DWORD *)&v272[4 * (HIBYTE(v302) ^ 0xE)] ^ v313 ^ (v247 + 2111680599 - ((2 * v247) & 0xFBBB60AE));
  LODWORD(v247) = BYTE1(v285);
  v317 = HIDWORD(v548) ^ *(_DWORD *)&v263[4 * (BYTE1(v285) ^ 0x6D)] ^ (v312 + 1520843255 - ((2 * v312) & 0xB54C73EE));
  v318 = v548 ^ ((BYTE1(v301) ^ 0xC0) + 1520843255 - ((2 * ((v301 >> 8) ^ 0xD2CCC0)) & 0x1EE)) ^ *(_DWORD *)&v264[4 * ((v302 ^ BYTE1(v282) ^ 0x54) ^ 0xCA)] ^ *(_DWORD *)&v263[4 * (BYTE1(v301) ^ 0xAD)] ^ (v305 + 513343004 - ((2 * v305) & 0x3D31FC38));
  v319 = ((unsigned __int16)(v548 ^ ((BYTE1(v301) ^ 0xC0)
                                                    + 14839
                                                    - ((2 * ((v301 >> 8) ^ 0xCCC0)) & 0x1EE)) ^ *(_WORD *)&v264[4 * ((v302 ^ BYTE1(v282) ^ 0x54) ^ 0xCA)] ^ *(_WORD *)&v263[4 * (BYTE1(v301) ^ 0xAD)] ^ (v305 - 484 - ((2 * v305) & 0xFC38))) >> 8) ^ 0xD9;
  LODWORD(v247) = v247 ^ 0x4552953C ^ v317;
  v320 = *(_DWORD *)&v268[4 * BYTE2(v247)];
  HIDWORD(v271) = v320 ^ 0x1C5;
  LODWORD(v271) = v320 ^ 0xDB22D000;
  v321 = v271 >> 12;
  v322 = *(_DWORD *)&v268[4 * ((v315 ^ 0x99FEE750) >> 16)];
  HIDWORD(v271) = v322 ^ 0x1C5;
  LODWORD(v271) = v322 ^ 0xDB22D000;
  v323 = BYTE1(v316) ^ 0x29;
  v324 = v323 + 1520843255 - ((2 * ((v316 >> 8) ^ 0xA73B29)) & 0x1EE);
  v325 = (BYTE1(v247) + 1520843255 - ((v247 >> 7) & 0x1EE)) ^ *(_DWORD *)&v264[4
                                                                                           * (v316 ^ 0x72)] ^ *(_DWORD *)&v263[4 * (BYTE1(v247) ^ 0x6D)] ^ ((v271 >> 12) + 513343004 - ((2 * (v271 >> 12)) & 0x3D31FC38));
  v326 = *(_DWORD *)&v268[4 * (BYTE2(v318) ^ 2)];
  HIDWORD(v271) = v326 ^ 0x1C5;
  LODWORD(v271) = v326 ^ 0xDB22D000;
  v327 = *(_DWORD *)&v272[4 * (HIBYTE(v316) ^ 0xA7)] ^ (v271 >> 12);
  v328 = *(_DWORD *)&v268[4 * (BYTE2(v316) ^ 0x3B)];
  HIDWORD(v271) = v328 ^ 0x1C5;
  LODWORD(v271) = v328 ^ 0xDB22D000;
  LODWORD(v247) = *(_DWORD *)&v264[4 * v247] ^ v327 ^ 0x63454E4B;
  v329 = HIDWORD(v542) ^ (v319 + 1520843255 - ((2 * ((v318 >> 8) ^ 0x9802D9)) & 0x1EE)) ^ *(_DWORD *)&v264[4 * (v315 ^ 0x1E)] ^ *(_DWORD *)&v263[4 * (v319 ^ 0x6D)] ^ (v271 >> 12) ^ *(_DWORD *)&v272[4 * (HIBYTE(v317) ^ 0x61)];
  v330 = v542 ^ *(_DWORD *)&v272[4 * (HIBYTE(v318) ^ 0x98)] ^ (v325 + 2111680599 - ((2 * v325) & 0xFBBB60AE));
  v331 = HIDWORD(v538) ^ *(_DWORD *)&v264[4 * (v318 ^ 0x3D)] ^ v324 ^ *(_DWORD *)&v272[4 * ((v315 ^ 0x99FEE750) >> 24)] ^ *(_DWORD *)&v263[4 * (v323 ^ 0x6D)] ^ v321;
  v332 = v538 ^ *(_DWORD *)&v263[4 * (((unsigned __int16)(v315 ^ 0xE750) >> 8) ^ 0x6D)] ^ (v247 + 1520843255 - ((2 * v247) & 0xB54C73EE));
  LODWORD(v247) = *(_DWORD *)&v268[4 * (BYTE2(v329) ^ 0x54)];
  HIDWORD(v271) = v247 ^ 0x1C5;
  LODWORD(v271) = v247 ^ 0xDB22D000;
  LODWORD(v247) = v271 >> 12;
  v333 = *(_DWORD *)&v268[4 * (BYTE2(v331) ^ 0xAD)];
  HIDWORD(v271) = v333 ^ 0x1C5;
  LODWORD(v271) = v333 ^ 0xDB22D000;
  v334 = BYTE1(v331);
  v335 = (BYTE1(v331) ^ 0xB1) + 1520843256 + ~(2 * (BYTE1(v331) ^ 0xB1 ^ (v331 >> 8) & 8));
  v336 = v329 ^ 0x282ED73C;
  v337 = *(_DWORD *)&v264[4 * ((v332 ^ ((unsigned __int16)(v315 ^ 0xE750) >> 8)) ^ 0x41)] ^ (((unsigned __int16)(v329 ^ 0xD73C) >> 8) + 1520843255 - (((v329 ^ 0x282ED73Cu) >> 7) & 0x1EE)) ^ *(_DWORD *)&v263[4 * (((unsigned __int16)(v329 ^ 0xD73C) >> 8) ^ 0x6D)] ^ ((v271 >> 12) + 513343004 - ((2 * (v271 >> 12)) & 0x3D31FC38));
  v338 = v337 + 2111680599 - ((2 * v337) & 0xFBBB60AE);
  v339 = *(_DWORD *)&v268[4 * (BYTE2(v332) ^ 0x81)];
  HIDWORD(v271) = v339 ^ 0x1C5;
  LODWORD(v271) = v339 ^ 0xDB22D000;
  v340 = ((v271 >> 12) + 2111680599 - ((2 * (v271 >> 12)) & 0xFBBB60AE)) ^ *(_DWORD *)&v272[4 * HIBYTE(v336)];
  v341 = (v340 + 513343005 + ~((2 * v340) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v331 ^ 0x4E)];
  v342 = *(_DWORD *)&v268[4 * (BYTE2(v330) ^ 0xC6)];
  LODWORD(v247) = ((BYTE1(v332) ^ 0xA0) + 1520843255 - 2 * (BYTE1(v332) ^ 0xA0 ^ (v332 >> 8) & 8)) ^ (v247 + 513343004 - ((2 * v247) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v330 ^ 0xFC)] ^ *(_DWORD *)&v263[4 * (BYTE1(v332) ^ 0xCD)];
  LODWORD(v271) = __ROR4__((v342 >> 12) ^ 0x2606F0F, 17) ^ 0xEE910136;
  HIDWORD(v271) = v271;
  v343 = HIDWORD(v531) ^ *(_DWORD *)&v263[4 * (BYTE1(v330) ^ 0x75)] ^ (v341 + 1520843255 - ((2 * v341) & 0xB54C73EE));
  v344 = v531 ^ *(_DWORD *)&v272[4 * (HIBYTE(v331) ^ 0xB6)] ^ (v247 + 2111680599 - ((2 * v247) & 0xFBBB60AE));
  LODWORD(v247) = *(_DWORD *)&v264[4 * v336];
  v345 = HIDWORD(v525) ^ *(_DWORD *)&v272[4 * (HIBYTE(v330) ^ 0x5A)] ^ v338;
  v346 = v525 ^ v335 ^ v247 ^ *(_DWORD *)&v272[4 * (HIBYTE(v332) ^ 0x68)] ^ *(_DWORD *)&v263[4 * (v334 ^ 0xDC)] ^ ((v271 >> 15) + (v342 << 20));
  LODWORD(v247) = ((BYTE1(v343) ^ 0x9D) + 1520843256 + (~(2 * ((v343 >> 8) ^ 0xC2489D)) | 0xFFFFFE11)) ^ *(_DWORD *)&v263[4 * (BYTE1(v343) ^ 0xF0)];
  v347 = *(_DWORD *)&v268[4 * (BYTE2(v344) ^ 0x8F)];
  LODWORD(v247) = *(_DWORD *)&v264[4 * (v346 ^ 0xC1)] ^ (v347 << 20) ^ (v347 >> 12) ^ 0x1C5DB22D ^ (v247 + 513343004 - ((2 * v247) & 0x3D31FC38));
  v348 = *(_DWORD *)&v268[4 * ((v345 ^ 0xCFB8D782) >> 16)];
  HIDWORD(v271) = v348 ^ 0x1C5;
  LODWORD(v271) = v348 ^ 0xDB22D000;
  v349 = ((v271 >> 12) + 513343004 - ((2 * (v271 >> 12)) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4
                                                                                         * ((v343 ^ BYTE1(v330)) ^ 0x3F)];
  v350 = v247 + 2111680599 - ((2 * v247) & 0xFBBB60AE);
  LODWORD(v247) = v349 + 2111680599 - ((2 * v349) & 0xFBBB60AE);
  v351 = *(_DWORD *)&v268[4 * (BYTE2(v343) ^ 0x48)];
  HIDWORD(v271) = v351 ^ 0x1C5;
  LODWORD(v271) = v351 ^ 0xDB22D000;
  v352 = ((BYTE1(v346) ^ 0x2E) + 1520843256 + (~(2 * ((v346 >> 8) ^ 0x599E2E)) | 0xFFFFFE11)) ^ *(_DWORD *)&v264[4 * (((v444 + 37) ^ BYTE4(v448) ^ v272[4 * (HIBYTE(v330) ^ 0x5A)] ^ v338) ^ 0xCC)] ^ *(_DWORD *)&v263[4 * (BYTE1(v346) ^ 0x43)] ^ ((v271 >> 12) + 513343005 + ~((2 * (v271 >> 12)) & 0x3D31FC38));
  v353 = *(_DWORD *)&v268[4 * (BYTE2(v346) ^ 0x9E)];
  HIDWORD(v271) = v353 ^ 0x1C5;
  LODWORD(v271) = v353 ^ 0xDB22D000;
  v354 = HIDWORD(v519) ^ (((unsigned __int16)(v345 ^ 0xD782) >> 8)
                        + 1520843255
                        - (((v345 ^ 0xCFB8D782) >> 7) & 0x1EE)) ^ *(_DWORD *)&v264[4 * (v344 ^ 0x50)] ^ *(_DWORD *)&v263[4 * (((unsigned __int16)(v345 ^ 0xD782) >> 8) ^ 0x6D)] ^ (v271 >> 12) ^ *(_DWORD *)&v272[4 * (HIBYTE(v343) ^ 0xC2)];
  v355 = v519 ^ *(_DWORD *)&v272[4 * (HIBYTE(v344) ^ 0xC7)] ^ (v352 + 2111680599 - ((2 * v352) & 0xFBBB60AE));
  v356 = HIDWORD(v512) ^ *(_DWORD *)&v272[4 * ((v345 ^ 0xCFB8D782) >> 24)] ^ v350;
  v357 = v512 ^ ((BYTE1(v344) ^ 0xD9) + 1520843255 - ((2 * ((v344 >> 8) ^ 0xC78FD9)) & 0x1EE)) ^ *(_DWORD *)&v263[4 * (BYTE1(v344) ^ 0xB4)] ^ *(_DWORD *)&v272[4 * (HIBYTE(v346) ^ 0x59)] ^ v247;
  v358 = ((unsigned __int16)(v519 ^ *(_WORD *)&v272[4 * (HIBYTE(v344) ^ 0xC7)] ^ (v352
                                                                                                 - 20393
                                                                                                 - ((2 * v352) & 0x60AE))) >> 8);
  v359 = (((unsigned __int16)(v357 ^ 0xCCA2) >> 8) + 1520843255 - (((v357 ^ 0x33C8CCA2) >> 7) & 0x1EE)) ^ *(_DWORD *)&v263[4 * (((unsigned __int16)(v357 ^ 0xCCA2) >> 8) ^ 0x6D)];
  v360 = *(_DWORD *)&v268[4 * (BYTE2(v355) ^ 0xE6)];
  HIDWORD(v271) = v360 ^ 0x1C5;
  LODWORD(v271) = v360 ^ 0xDB22D000;
  v361 = v271 >> 12;
  v362 = *(_DWORD *)&v268[4 * (BYTE2(v356) ^ 0x1C)];
  HIDWORD(v271) = v362 ^ 0x1C5;
  LODWORD(v271) = v362 ^ 0xDB22D000;
  LODWORD(v247) = (v271 >> 12) ^ *(_DWORD *)&v263[4 * (v358 ^ 0xD9)] ^ ((v358 ^ 0xB4)
                                                                      + 1520843255
                                                                      - 2 * (v358 ^ 0xB4 ^ (v355 >> 8) & 8));
  LODWORD(v247) = (v247 + 513343004 - ((2 * v247) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v354 ^ 0xA1)];
  v363 = (v359 + 513343004 - ((2 * v359) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4
                                                                         * ((BYTE4(v512) ^ v272[4 * ((v345 ^ 0xCFB8D782) >> 24)] ^ v350) ^ 0x3A)];
  v364 = *(_DWORD *)&v264[4 * (v357 ^ 0xA2)] ^ (((unsigned __int16)(v354 ^ 0x5AA1) >> 8)
                                                               + 1520843255
                                                               - (((v354 ^ 0x7A765AA1) >> 7) & 0x1EE)) ^ *(_DWORD *)&v263[4 * (((unsigned __int16)(v354 ^ 0x5AA1) >> 8) ^ 0x6D)] ^ (v361 + 513343004 - ((2 * v361) & 0x3D31FC38));
  HIDWORD(v271) = *(_DWORD *)&v264[4 * (v355 ^ 0x96)] ^ 0x1E98FE1C;
  LODWORD(v271) = *(_DWORD *)&v264[4 * (v355 ^ 0x96)];
  HIDWORD(v271) = (v271 >> 29) ^ 0x6615DA09;
  LODWORD(v271) = HIDWORD(v271);
  v365 = (v271 >> 3) + 1520843255 - ((2 * (v271 >> 3)) & 0xB54C73EE);
  v366 = *(_DWORD *)&v268[4 * ((v354 ^ 0x7A765AA1) >> 16)];
  HIDWORD(v271) = v366 ^ 0x1C5;
  LODWORD(v271) = v366 ^ 0xDB22D000;
  v367 = v271 >> 12;
  v368 = *(_DWORD *)&v268[4 * ((v357 ^ 0x33C8CCA2) >> 16)];
  HIDWORD(v271) = v368 ^ 0x1C5;
  LODWORD(v271) = v368 ^ 0xDB22D000;
  v369 = HIDWORD(v507) ^ *(_DWORD *)&v272[4 * (HIBYTE(v357) ^ 0x17)] ^ (v247 + 2111680599 - ((2 * v247) & 0xFBBB60AE));
  LODWORD(v247) = v365 ^ *(_DWORD *)&v263[4 * (BYTE1(v356) ^ 0xD1)] ^ (v271 >> 12);
  v370 = v507 ^ *(_DWORD *)&v272[4 * (HIBYTE(v355) ^ 0x4F)] ^ v367 ^ (v363 + 2111680600 + ~((2 * v363) & 0xFBBB60AE));
  v371 = HIDWORD(v501) ^ *(_DWORD *)&v272[4 * (HIBYTE(v356) ^ 0x1B)] ^ (v364 + 2111680599 - ((2 * v364) & 0xFBBB60AE));
  v372 = *(_DWORD *)&v268[4 * (BYTE2(v371) ^ 0x7E)];
  HIDWORD(v271) = v372 ^ 0x1C5;
  LODWORD(v271) = v372 ^ 0xDB22D000;
  v373 = v271 >> 12;
  v374 = *(_DWORD *)&v268[4 * (BYTE2(v370) ^ 1)];
  HIDWORD(v271) = v374 ^ 0x1C5;
  LODWORD(v271) = v374 ^ 0xDB22D000;
  v375 = *(_DWORD *)&v272[4 * (HIBYTE(v354) ^ 0x5E)] ^ v584 ^ (v247 + 2111680599 - ((2 * v247) & 0xFBBB60AE));
  LODWORD(v247) = ((v271 >> 12) + 513343004 - ((2 * (v271 >> 12)) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v369 ^ 0xC6)];
  v376 = ((BYTE1(v369) ^ 0x71) + 1520843255 - ((2 * ((v369 >> 8) ^ 0xF25B71)) & 0x1EE)) ^ *(_DWORD *)&v263[4 * (BYTE1(v369) ^ 0x1C)];
  v377 = (v376 + 2111680599 - ((2 * v376) & 0xFBBB60AE)) ^ *(_DWORD *)&v272[4 * (HIBYTE(v370) ^ 0x1F)];
  v378 = *(_DWORD *)&v268[4 * (BYTE2(v369) ^ 0x5B)];
  HIDWORD(v271) = v378 ^ 0x1C5;
  LODWORD(v271) = v378 ^ 0xDB22D000;
  v379 = v271 >> 12;
  v380 = BYTE1(v356) ^ 0x73F4E0AF ^ v375;
  v381 = *(_DWORD *)&v268[4 * BYTE2(v380)];
  HIDWORD(v271) = v381 ^ 0x1C5;
  LODWORD(v271) = v381 ^ 0xDB22D000;
  v382 = v271 >> 12;
  HIDWORD(v271) = v373 ^ ((BYTE1(v370) ^ 0x81) + 1520843255 - ((2 * ((v370 >> 8) ^ 0x1F0181)) & 0x1EE)) ^ 0xD678EAEF ^ *(_DWORD *)&v263[4 * (BYTE1(v370) ^ 0xEC)];
  LODWORD(v271) = HIDWORD(v271);
  LODWORD(v271) = (v271 >> 11) ^ __ROR4__(*(_DWORD *)&v272[4 * (HIBYTE(v369) ^ 0xF2)] ^ 0xDFC7EBE9, 11) ^ 0xD490839A;
  HIDWORD(v271) = v271;
  v383 = v501 ^ *(_DWORD *)&v264[4 * (v370 ^ 0xB8)] ^ ((BYTE1(v371) ^ 0xAA)
                                                                      + 1520843255
                                                                      - ((2 * ((v371 >> 8) ^ 0x967EAA)) & 0x1EE)) ^ *(_DWORD *)&v272[4 * (HIBYTE(v375) ^ 0x57)] ^ v379 ^ *(_DWORD *)&v263[4 * (BYTE1(v371) ^ 0xC7)];
  v384 = HIDWORD(v496) ^ (BYTE1(v380) + 1520843255 - ((v380 >> 7) & 0x1EE)) ^ *(_DWORD *)&v272[4 * (HIBYTE(v371) ^ 0x96)] ^ *(_DWORD *)&v263[4 * (BYTE1(v380) ^ 0x6D)] ^ (v247 + 2111680600 + ~((2 * v247) & 0xFBBB60AE));
  LODWORD(v247) = v496 ^ *(_DWORD *)&v264[4 * (v371 ^ 0x88)] ^ v382 ^ (v377
                                                                                      + 513343004
                                                                                      - ((2 * v377) & 0x3D31FC38));
  v385 = HIDWORD(v490) ^ *(_DWORD *)&v264[4 * (BYTE1(v356) ^ 0xAF ^ v375)] ^ ((v271 >> 21)
                                                                                             + 513343004
                                                                                             - ((2 * (v271 >> 21)) & 0x3D31FC38));
  v386 = *(_DWORD *)&v268[4 * (BYTE2(v383) ^ 0xAE)];
  HIDWORD(v271) = v386 ^ 0x1C5;
  LODWORD(v271) = v386 ^ 0xDB22D000;
  v387 = v271 >> 12;
  BYTE2(v377) = BYTE2(v247) ^ 0x4A;
  v388 = *(_DWORD *)&v263[4 * (BYTE1(v384) ^ 0x96)] ^ ((BYTE1(v384) ^ 0xFB)
                                                     + 1520843255
                                                     - ((2 * ((v384 >> 8) ^ 0x3EA2FB)) & 0x1EE));
  v389 = *(_DWORD *)&v268[4 * (BYTE2(v384) ^ 0xA2)];
  HIDWORD(v271) = v389 ^ 0x1C5;
  LODWORD(v271) = v389 ^ 0xDB22D000;
  v390 = (v388 + 513343004 - ((2 * v388) & 0x3D31FC38)) ^ *(_DWORD *)&v264[4 * (v247 ^ 0x75)];
  v391 = (((unsigned __int16)(v247 ^ 0xF075) >> 8)
        + 1520843255
        - (((v247 ^ 0xB54AF075) >> 7) & 0x1EE)) ^ (v271 >> 12) ^ *(_DWORD *)&v263[4
                                                                                              * (((unsigned __int16)(v247 ^ 0xF075) >> 8) ^ 0x6D)];
  v392 = (v391 + 2111680599 - ((2 * v391) & 0xFBBB60AE)) ^ *(_DWORD *)&v272[4 * (HIBYTE(v385) ^ 0xED)];
  LODWORD(v247) = *(_DWORD *)&v272[4 * (BYTE3(v247) ^ 0x91)];
  v393 = *(_DWORD *)&v272[4 * (HIBYTE(v384) ^ 0x3E)];
  LODWORD(v272) = *(_DWORD *)&v272[4 * (HIBYTE(v383) ^ 0xA4)];
  v385 ^= 0xC9AF1D8F;
  v394 = BYTE1(v385);
  v395 = BYTE1(v385) + 1520843255 - ((v385 >> 7) & 0x1EE);
  v396 = *(_DWORD *)&v264[4 * v385];
  v397 = *(_DWORD *)&v264[4 * (v384 ^ 0x9A)];
  LODWORD(v264) = *(_DWORD *)&v264[4 * (v383 ^ 0x24)];
  v398 = *(_DWORD *)&v268[4 * BYTE2(v385)];
  LODWORD(v268) = *(_DWORD *)&v268[4 * BYTE2(v377)];
  HIDWORD(v271) = v268 ^ 0x1C5;
  LODWORD(v271) = v268 ^ 0xDB22D000;
  LODWORD(v268) = (v383 >> 8) ^ 0xA4AE8E;
  v399 = *(_DWORD *)&v263[4 * (v394 ^ 0x6D)];
  v400 = *(_DWORD *)&v263[4 * (v268 ^ 0x6D)];
  v401 = v268 + 1520843255 - ((2 * (_DWORD)v268) & 0x1EE);
  LODWORD(v268) = v490 ^ v397 ^ v387 ^ v247 ^ v395 ^ v399;
  v402 = HIDWORD(v484) ^ v401 ^ v393 ^ v400 ^ (v271 >> 12) ^ v396;
  v403 = v484 ^ v264 ^ (v392 + 513343004 - ((2 * v392) & 0x3D31FC38));
  v404 = *(_DWORD *)(v59 - 120);
  v405 = (uint64_t)*(&off_100180420 + v404 - 953);
  v406 = (char *)*(&off_100180420 + v404 - 1062) - 12;
  LODWORD(v264) = *(_DWORD *)&v406[4 * (BYTE1(v268) ^ 0x3F)];
  v407 = HIDWORD(v478) ^ v272 ^ (v398 >> 12) ^ (v398 << 20) ^ (v390
                                                                           + 2111680599
                                                                           - ((2 * v390) & 0xFBBB60AE));
  LODWORD(v247) = *(_DWORD *)(v405 + 4 * (v403 ^ 7u)) ^ *(_DWORD *)&v406[4
                                                                                          * (((unsigned __int16)(WORD2(v478) ^ (unsigned __int16)v272 ^ (v398 >> 12) ^ (v390 - 20393 - ((2 * v390) & 0x60AE))) >> 8) ^ 0x91)] ^ 0xDC0A606D;
  v408 = *(_DWORD *)&v406[4 * ((unsigned __int16)(v403 ^ 0x6F07) >> 8)];
  v409 = *(_DWORD *)&v406[4 * (BYTE1(v402) ^ 0xA)];
  v410 = (char *)*(&off_100180420 + (int)v468) - 12;
  v411 = *(unsigned int *)&v410[4 * (HIBYTE(v403) ^ 0xEF)];
  LODWORD(v406) = *(_DWORD *)&v410[4 * (HIBYTE(v402) ^ 0x40)];
  v412 = *(_DWORD *)&v410[4 * (HIBYTE(v407) ^ 0x81)];
  LODWORD(v410) = *(_DWORD *)&v410[4 * ((v268 >> 24) ^ 0x52)];
  v413 = (char *)*(&off_100180420 + SHIDWORD(v468)) - 8;
  v414 = *(_DWORD *)&v413[4 * (BYTE2(v407) ^ 0xE1)];
  v415 = *(_DWORD *)&v413[4 * (BYTE2(v403) ^ 0x2A)];
  v416 = *(_DWORD *)&v413[4 * (BYTE2(v402) ^ 0x38)];
  LODWORD(v247) = v406 ^ (v247 - 1948903727 - ((2 * v247) & 0x17AC2DA2));
  LODWORD(v406) = *(_DWORD *)&v413[4 * (BYTE2(v268) ^ 0xCE)];
  LODWORD(v413) = *(_DWORD *)(v405 + 4 * (v268 ^ 0x97u));
  LODWORD(v247) = v406 ^ (v247 - 904186093 - ((2 * v247) & 0x94366E26));
  LODWORD(v406) = *(_DWORD *)(v405 + 4 * (v402 ^ 0xBBu));
  v417 = *(unsigned int *)(v405 + 4 * (v407 ^ 0xF6u));
  LODWORD(v405) = *(_DWORD *)(v59 - 140) ^ v581 ^ (v247 - ((2 * v247) & 0x51FEDD94) + 687828682);
  v418 = (char *)*(&off_100180420 + SHIDWORD(v462)) - 4;
  a54[8] = v418[BYTE3(v405) ^ 0xD7] ^ 0x7C;
  LODWORD(v247) = ((v414 ^ 0x324FF1A6 ^ v408) - 1948903727 - ((2 * (v414 ^ 0x324FF1A6 ^ v408)) & 0x17AC2DA2)) ^ v410;
  LODWORD(v247) = (v247 + 610182872 - ((2 * v247) & 0x48BD4DB0)) ^ v406;
  LODWORD(v247) = *(_DWORD *)(v59 - 136) ^ HIDWORD(v581) ^ (v247 - ((2 * v247) & 0x442FAC24) - 1575496174);
  v419 = (char *)*(&off_100180420 + (int)v462) - 8;
  a54[*(_QWORD *)(v59 - 232)] = (v419[v247 ^ 0xC7] - 112) ^ 0x5F;
  v420 = (uint64_t)*(&off_100180420 + SHIDWORD(v458));
  LODWORD(v410) = *(unsigned __int8 *)(v420 + (BYTE1(v247) ^ 0x13));
  HIDWORD(v271) = v410 ^ 0x20;
  LODWORD(v271) = (_DWORD)v410 << 24;
  a54[6] = (v271 >> 30) ^ 0x40;
  LODWORD(v410) = ((v413 ^ 0xEE4591CB ^ v415)
                 - 1948903727
                 - ((2 * (v413 ^ 0xEE4591CB ^ v415)) & 0x17AC2DA2)) ^ v412;
  LODWORD(v410) = ((_DWORD)v410 - ((2 * (_DWORD)v410) & 0xF0A98D6A) - 128661835) ^ v409;
  v421 = *(_DWORD *)(v59 - 132);
  v422 = v421 ^ HIDWORD(v582) ^ (v410 - ((2 * (_DWORD)v410) & 0x44682948) - 1573645148);
  LODWORD(v410) = *(unsigned __int8 *)(v420
                                     + ((unsigned __int16)(v421 ^ WORD2(v582) ^ ((_WORD)v410
                                                                                                - ((2 * (_WORD)v410) & 0x2948)
                                                                                                + 5284)) >> 8));
  HIDWORD(v271) = v410 ^ 0x20;
  LODWORD(v271) = (_DWORD)v410 << 24;
  a54[*(_QWORD *)(v59 - 216)] = (v271 >> 30) ^ 0x7E;
  v423 = (char *)*(&off_100180420 + (int)v458) - 12;
  a54[9] = v423[BYTE2(v405) ^ 0xFBLL] ^ 0xC9;
  LODWORD(v410) = ((v264 ^ 0x7382D064 ^ v411)
                 - 904186093
                 - ((2 * (v264 ^ 0x7382D064 ^ v411)) & 0x94366E26)) ^ v416;
  LODWORD(v410) = v417 ^ ((_DWORD)v410 + 610182872 - ((2 * (_DWORD)v410) & 0x48BD4DB0));
  LODWORD(v264) = *(_DWORD *)(v59 - 128) ^ v582 ^ ((_DWORD)v410 - ((2 * (_DWORD)v410) & 0x61EF50BA) + 821536861);
  a54[*(_QWORD *)(v59 - 184)] = v423[BYTE2(v264) ^ 0xB8] ^ 0x1A;
  a54[*(_QWORD *)(v59 - 256)] = (v419[v405 ^ 0x1BLL] - 112) ^ 0x7D;
  a54[*(_QWORD *)(v59 - 240)] = v423[BYTE2(v247) ^ 3] ^ 0x64;
  a54[*(_QWORD *)(v59 - 192)] = v418[BYTE3(v247) ^ 0x6DLL] ^ 0x84;
  LODWORD(v247) = *(unsigned __int8 *)(v420 + (BYTE1(v405) ^ 0x92));
  HIDWORD(v271) = v247 ^ 0x20;
  LODWORD(v271) = (_DWORD)v247 << 24;
  a54[*(_QWORD *)(v59 - 160)] = (v271 >> 30) ^ 0xD2;
  v424 = *(_QWORD *)(v59 - 208);
  a54[v424] = v418[BYTE3(v422) ^ 0x53] ^ 0x68;
  a54[*(_QWORD *)(v59 - 176)] = (v419[v422 ^ 0x95] - 112) ^ 0xAF;
  a54[*(_QWORD *)(v59 - 248)] = (v419[v264 ^ 0x64] - 112) ^ 0x27;
  a54[*(_QWORD *)(v59 - 168)] = v418[(v264 >> 24) ^ 0x6ELL] ^ 0xFE;
  LODWORD(v247) = *(unsigned __int8 *)(v420 + (BYTE1(v264) ^ 0x1FLL));
  HIDWORD(v271) = v247 ^ 0x20;
  LODWORD(v271) = (_DWORD)v247 << 24;
  a54[*(_QWORD *)(v59 - 200)] = (v271 >> 30) ^ 0x58;
  a54[*(_QWORD *)(v59 - 152)] = v423[BYTE2(v422) ^ 0xC8] ^ 0x4B;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, char *, char *, char *, char *, uint64_t, uint64_t, unint64_t, uint64_t, uint64_t, unsigned __int8 *))(*(_QWORD *)(a56 + 8 * ((1558 * ((((_DWORD)v424 + 780052325 - 2 * (((_DWORD)v424 + 16) & *(_DWORD *)(v59 - 220))) ^ 0x2E7EA755u) < a55)) ^ (v404 - 649))) - 8))(v420, 3390781203, v411, v417, 109, v422, 1220365744, 109, a9, v426, v427, v428, v429, v431, v433, v435, v439, v442, v444,
           v448,
           v453,
           a22,
           a23,
           v458,
           v462,
           v468,
           v473,
           v478,
           v484,
           v490,
           v496,
           v501,
           v507,
           v512,
           v519,
           v525,
           v531,
           v538,
           v542,
           v548,
           v552,
           v557,
           v562,
           v566,
           v570,
           v573,
           v575,
           v577,
           v579,
           v580,
           v581,
           v582,
           v584,
           a54);
}

void sub_100064568(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,int a57,int a58,int a59,int a60,int a61)
{
  uint64_t v61;

  *(_DWORD *)(v61 - 128) = a58 ^ 0xEBC5F371;
  *(_DWORD *)(v61 - 140) = a60 ^ 0x93A60F65;
  *(_DWORD *)(v61 - 132) = a61 ^ 0xD622DD5C;
  *(_DWORD *)(v61 - 136) = a59 ^ 0x5B4B490E;
  JUMPOUT(0x10006292CLL);
}

uint64_t sub_1000645BC(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * ((428 * (((a7 - 40) ^ (v7 == a3)) & 1)) ^ a7))
                            - 8))();
}

uint64_t sub_1000645F4(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(v5
                                                                                + 8
                                                                                * (int)((481
                                                                                       * ((((17
                                                                                           * (a4 & 0x99D0B67F ^ 0x274)) ^ 0x25B) & v4) != 0)) ^ a4 & 0x99D0B67F))
                                                                    - (((a4 & 0x99D0B67F) - 1130876251) & 0x4367CF2F)
                                                                    + 1064))(a1, a2, a3, (a2 - a3));
}

uint64_t sub_100064654(int a1, uint64_t a2, int a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56)
{
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  char v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  char v67;
  uint64_t v68;
  int8x16x4_t v70;

  *(_DWORD *)(v65 - 120) = v63;
  *(_DWORD *)(v65 - 132) = v59 & 0xFFFFFFF8;
  *(_DWORD *)(v65 - 128) = v59;
  v66 = -8 - a3;
  v67 = v62 + v61 + v60;
  v68 = (v62 + v61 + a1 + v66 + 8);
  v70.val[0].i64[0] = ((_BYTE)v62 + (_BYTE)v61 + (_BYTE)a1 + (_BYTE)v66 + 8) & 0xF;
  v70.val[0].i64[1] = (v67 + 84 + (_BYTE)v66 + 8) & 0xF;
  v70.val[1].i64[0] = (v67 + 83 + (_BYTE)v66 + 8) & 0xF;
  v70.val[1].i64[1] = (v67 + 82 + (_BYTE)v66 + 8) & 0xF;
  v70.val[2].i64[0] = (v67 + 81 + (_BYTE)v66 + 8) & 0xF;
  v70.val[2].i64[1] = (v67 + 80 + (_BYTE)v66 + 8) & 0xF;
  v70.val[3].i64[0] = (v67 + (_BYTE)v66 + ((a5 - 71) | 0x43) + 8) & 0xF;
  v70.val[3].i64[1] = (v67 + 78 + (_BYTE)v66 + 8) & 0xF;
  *(int8x8_t *)(v64 - 7 + v68) = vrev64_s8(veor_s8(veor_s8(vrev64_s8(veor_s8(veor_s8(*(int8x8_t *)(v64 - 7 + v68), *(int8x8_t *)(v58 + (v68 & 0xF) - 7)), veor_s8(*(int8x8_t *)(v57 + (v68 & 0xF) - 7), *(int8x8_t *)(v56 + (v68 & 0xF) - 7)))), (int8x8_t)0xFEFEFEFEFEFEFEFELL), vmul_s8((int8x8_t)*(_OWORD *)&vqtbl4q_s8(v70, (int8x16_t)xmmword_100151930), (int8x8_t)0x505050505050505)));
  return ((uint64_t (*)(__n128))(*(_QWORD *)(a56 + 8 * ((54 * (-(v59 & 0xFFFFFFF8) == v66)) ^ a5)) - 8))((__n128)xmmword_100151930);
}

void sub_1000647AC()
{
  JUMPOUT(0x1000646B8);
}

uint64_t sub_1000647B4(int a1)
{
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * (((((a1 + 473) | 4) - 1044) * (*(_DWORD *)(v1 - 128) != *(_DWORD *)(v1 - 132))) ^ a1))
                            - ((a1 + 477) ^ 0x428)))();
}

uint64_t sub_1000647F4(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, int a6)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = (a4 - 1949718532);
  *(_BYTE *)(v10 + v12) ^= *(_BYTE *)(v9 + (v12 & 0xF)) ^ *(_BYTE *)(v8 + (v12 & 0xF)) ^ *(_BYTE *)(v7 + (v12 & 0xF)) ^ (5 * (v12 & 0xF)) ^ 0xFE;
  return ((uint64_t (*)(void))(*(_QWORD *)(v11 + 8 * ((67 * (a4 - 1 == v6)) ^ (a6 - 544))) - 4))();
}

void sub_100064858()
{
  int v0;
  int v1;
  uint64_t v2;

  if (v0 == 1853153040)
    v1 = 489733862;
  else
    v1 = -489691842;
  *(_DWORD *)(v2 + 40) = v1;
}

void sub_1000648BC(uint64_t a1)
{
  int v1;
  BOOL v2;
  int v3;

  if (*(_QWORD *)(a1 + 24))
    v2 = *(_QWORD *)(a1 + 8) == 0x72F2C1D3322B87E8;
  else
    v2 = 1;
  v3 = v2;
  v1 = *(_DWORD *)(a1 + 32) ^ (1224239923 * (((a1 | 0xB7698061) - a1 + (a1 & 0x48967F9E)) ^ 0x45DA7DB6));
  __asm { BR              X8 }
}

_DWORD *sub_100064A04(_DWORD *result)
{
  int v1;

  *result = v1 - 4;
  return result;
}

uint64_t sub_100065FCC@<X0>(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  v5 = ((a1 ^ 0x622) + 120034823) & 0xF8D869CF;
  LODWORD(STACK[0x55C]) = STACK[0x2C0];
  LODWORD(STACK[0x4FC]) = STACK[0x2C8];
  STACK[0x308] = STACK[0x2A8];
  STACK[0x408] = STACK[0x2B0];
  STACK[0x4A8] = STACK[0x2B8];
  *(_DWORD *)(v1 + 52) = v5 + 142 + *(_DWORD *)(v1 + 52) - 348;
  LODWORD(STACK[0x49C]) = *(_DWORD *)(v1 + 360);
  STACK[0x528] = (v5 ^ 0x94F) + v2 + ((2 * (_DWORD)v5) ^ 0x20u) - 2878;
  LODWORD(STACK[0x4CC]) = v4;
  LODWORD(STACK[0x2C8]) = STACK[0x4FC];
  LODWORD(STACK[0x2C0]) = STACK[0x55C];
  return (*(uint64_t (**)(void))(v3 + 8 * (int)((1330 * (STACK[0x3E8] == 0)) ^ v5)))();
}

uint64_t sub_100066024@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, int a5@<W8>)
{
  uint64_t v5;
  int v6;

  LODWORD(STACK[0x55C]) = STACK[0x2C0];
  LODWORD(STACK[0x4FC]) = STACK[0x2C8];
  STACK[0x308] = STACK[0x2A8];
  STACK[0x408] = STACK[0x2B0];
  STACK[0x4A8] = STACK[0x2B8];
  LODWORD(STACK[0x56C]) = a5;
  STACK[0x528] = v5 + (v6 ^ 0x389u) + 2083 + 67 * (v6 ^ 0x2C5u) - 3571;
  LODWORD(STACK[0x4CC]) = a5;
  LODWORD(STACK[0x2C8]) = STACK[0x4FC];
  LODWORD(STACK[0x2C0]) = STACK[0x55C];
  return sub_10007184C(a1, a2, a3, a4, 3805275455);
}

void sub_10006606C()
{
  LODWORD(STACK[0x3DC]) = 627426522;
  JUMPOUT(0x100066078);
}

#error "100066468: call analysis failed (funcsize=120)"

uint64_t sub_10006646C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t (*a68)(uint64_t);
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  _DWORD *v72;
  unsigned int *v73;
  unint64_t v74;
  unint64_t v75;
  int v76;
  uint64_t v77;
  uint64_t (*v78)(uint64_t);

  LODWORD(STACK[0x248]) = a7;
  LODWORD(STACK[0x18D8]) = 1691917229;
  LODWORD(STACK[0x18DC]) = -36689038;
  v72 = *(_DWORD **)(v69 + 8 * (v68 - 926));
  STACK[0x240] = (unint64_t)v72;
  LODWORD(STACK[0x524]) = *v72;
  v73 = *(unsigned int **)(v69 + 8 * (v68 - 979));
  STACK[0x250] = (unint64_t)v73;
  v74 = (0x621F11AEB51988FCLL - ((v71 - 192) | 0x621F11AEB51988FCLL) + STACK[0x220]) ^ 0x955054AFDE4B3E5ALL;
  v75 = *v73 ^ (235795823 * v74);
  v76 = v68 + 496991283 - 235795823 * v74;
  *(_DWORD *)(v71 - 192) = v76;
  *(_DWORD *)(v71 - 184) = v76 - 8;
  *(_DWORD *)(v71 - 180) = 235795823 * v74;
  *(_DWORD *)(v71 - 176) = (v68 - 1689052641) ^ (235795823 * v74);
  *(_DWORD *)(v71 - 172) = ((v68 + 496991283) ^ 0x6B) - 235795823 * v74;
  *(_QWORD *)(v71 - 168) = -235795823 * v74;
  *(_QWORD *)(v71 - 160) = v75;
  v77 = a68(v71 - 192);
  v78 = (uint64_t (*)(uint64_t))(*(_QWORD *)(v70 + 8 * *(int *)(v71 - 188)) - 12);
  STACK[0x2E8] = *(_QWORD *)(v69 + 8 * (v68 - 950)) - 4;
  return v78(v77);
}

uint64_t sub_100066574(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,int a59,int a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t (*a65)(uint64_t, uint64_t);
  uint64_t v65;
  unsigned int *v66;
  uint64_t v67;
  unsigned int v68;

  STACK[0x2D8] = a65(a61, 2965982036);
  v68 = (*(uint64_t (**)(void))(v65 + 8 * a59))();
  *v66 = v68;
  v66[1] = 1812433253 * (v68 ^ (v68 >> 30)) + 1;
  return ((uint64_t (*)(void))(*(_QWORD *)(v67 + 8 * a60) - 12))();
}

uint64_t sub_1000665E4()
{
  unsigned int v0;
  unsigned int v1;
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  *(_DWORD *)(v5 + 4 * v0) = v0 + (v1 ^ (v1 >> 30)) * v3;
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * (((v0 > 0x26E) * v4) ^ v2)) - 12))();
}

uint64_t sub_100066610@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51)
{
  int v51;
  uint64_t v52;
  uint64_t (*v53)(void);
  _DWORD *v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  _DWORD *v59;
  uint64_t v60;
  int v61;
  uint64_t v62;

  v57 = 17 * (a1 ^ 0x1B2);
  LODWORD(STACK[0x524]) = v51;
  v58 = ((uint64_t (*)(uint64_t, _QWORD))*(&off_100180420 + a1 - 420))(a51, 0);
  v59 = (_DWORD *)STACK[0x2E0];
  v60 = *(_QWORD *)(STACK[0x2E0] + 16);
  v59[1] = *(_DWORD *)(STACK[0x2E0] + 24);
  v59[2] = v60;
  v59[3] = ((uint64_t (*)(uint64_t))v53)(v58);
  *v59 = v53();
  v54[1] = *(_DWORD *)STACK[0x2E0] + ((1664525 * (*v54 ^ (*v54 >> 30))) ^ v54[1]);
  v61 = (v57 + 273851501) ^ v52;
  *(_QWORD *)(v56 - 176) = STACK[0x2D0];
  *(_QWORD *)(v56 - 160) = v52 + 3722162716;
  *(_DWORD *)(v56 - 192) = v61;
  *(_DWORD *)(v56 - 188) = (v57 + 273851323) ^ v52;
  *(_DWORD *)(v56 - 152) = v52;
  *(_DWORD *)(v56 - 148) = v61 ^ 0x85;
  *(_DWORD *)(v56 - 184) = v52 + v57 + 2104631251;
  v62 = ((uint64_t (*)(uint64_t))STACK[0x2E8])(v56 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v55 + 8 * *(int *)(v56 - 168)) - 8))(v62);
}

uint64_t sub_100066748()
{
  uint64_t v0;
  unsigned int v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * ((215
                                          * (((v1 < 0xDDDBB21A) ^ (LODWORD(STACK[0x2F4]) + 26)) & 1)) ^ (LODWORD(STACK[0x2F4]) - 537)))
                            - 8))();
}

uint64_t sub_10006678C()
{
  uint64_t v0;
  unsigned int v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * ((215
                                          * (((v1 > 0xDDDBB489) ^ (LODWORD(STACK[0x2F4]) + 26)) & 1)) ^ (LODWORD(STACK[0x2F4]) - 537)))
                            - 8))();
}

uint64_t sub_1000667D4@<X0>(int a1@<W8>)
{
  int v1;
  uint64_t v2;
  int v3;
  _DWORD *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t v9;

  v7 = (a1 + 87939562) & 0xFAC227FB;
  *v4 = v4[623];
  v8 = (v7 + 1498927245) ^ v2;
  *(_DWORD *)(v6 - 192) = v8;
  *(_DWORD *)(v6 - 188) = v8 ^ v1;
  *(_DWORD *)(v6 - 184) = v2 + v7 + 2104631251;
  *(_DWORD *)(v6 - 152) = v2;
  *(_DWORD *)(v6 - 148) = v8 ^ 0x52;
  *(_QWORD *)(v6 - 160) = (v3 + 1145240305) + v2;
  *(_QWORD *)(v6 - 176) = STACK[0x2C8];
  v9 = ((uint64_t (*)(uint64_t))STACK[0x2E8])(v6 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v5 + 8 * *(int *)(v6 - 168)) - 4))(v9);
}

uint64_t sub_10006686C()
{
  uint64_t v0;
  unsigned int v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * (((2 * (v1 < LODWORD(STACK[0x2A0]) - 1630453543)) | (16
                                                                                             * (v1 < LODWORD(STACK[0x2A0]) - 1630453543))) ^ (LODWORD(STACK[0x2F4]) - 303)))
                            - 4))();
}

uint64_t sub_1000668B0@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  int *v6;
  int v7;

  v4 = (a1 + 1378570983) & 0xADD4A9F7;
  v5 = 4 * (v1 - 1519274746);
  v6 = (int *)(STACK[0x2D8] + v5);
  v7 = *v6;
  LODWORD(v6) = -1690040139
              * ((*(_DWORD *)(*(_QWORD *)STACK[0x2B8] + (*(_DWORD *)STACK[0x2B0] & 0xA0C7FB4)) ^ v6) & 0x7FFFFFFF);
  LODWORD(v6) = v6 ^ (v6 >> 16);
  *(_DWORD *)(STACK[0x2E0] + v5) ^= v7 ^ *((_DWORD *)*(&off_100180420 + (a1 ^ 0x5CF))
                                         + ((-1690040139 * (_DWORD)v6) >> 24)) ^ *((_DWORD *)*(&off_100180420 + (a1 ^ 0x520))
                                                                                               + ((-1690040139 * (_DWORD)v6) >> 24)
                                                                                               + (v4 ^ 0x1F5)
                                                                                               - 1) ^ *((_DWORD *)*(&off_100180420 + (a1 ^ 0x515)) + ((-1690040139 * (_DWORD)v6) >> 24) - 3) ^ (146079744 * (_DWORD)v6) ^ (-1690040139 * (_DWORD)v6) ^ (-697817803 * ((-1690040139 * (_DWORD)v6) >> 24));
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (int)((((v4 ^ 0xFFFFFE0E) + v2 == 1793424262) * (((v4 - 385) | 0x403) + 43)) ^ v4))
                            - 8))();
}

uint64_t sub_100066A84@<X0>(int a1@<W8>)
{
  _DWORD *v1;
  uint64_t v2;
  int v3;

  *v1 = v1[623];
  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8 * ((795 * (v3 - 1 == (((a1 + 655) | 0x10) ^ 0x20FBDB2B))) ^ (a1 + 923)))
                            - 8))();
}

uint64_t sub_100066AD0@<X0>(int a1@<W8>)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v6;
  uint64_t v7;

  *(_DWORD *)(v2 + 4 * (v1 - 176935977)) = 176935977
                                                         - v1
                                                         + ((1566083941
                                                           * (*(_DWORD *)(v2 + 4 * (v1 - 176935978)) ^ (*(_DWORD *)(v2 + 4 * (v1 - 176935978)) >> 30))) ^ *(_DWORD *)(v2 + 4 * (v1 - 176935977)));
  v5 = 69008221 * ((0x42AE60BEBBCAF560 - ((v4 - 192) | 0x42AE60BEBBCAF560) + STACK[0x2C0]) ^ 0xEFCDD9A297975895);
  v6 = a1 - 863035190 + v5;
  *(_DWORD *)(v4 - 188) = v5 ^ 1;
  *(_DWORD *)(v4 - 184) = v6 + 18;
  *(_QWORD *)(v4 - 176) = 974479474 - v5;
  *(_DWORD *)(v4 - 152) = v5 + a1 + 2021362638;
  *(_QWORD *)(v4 - 160) = (v1 + 797543498) - v5;
  *(_DWORD *)(v4 - 168) = ((a1 - 863035190) ^ 0x1B) - v5;
  *(_DWORD *)(v4 - 164) = v6;
  v7 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + a1 - 917) - 8))(v4 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v3 + 8 * *(int *)(v4 - 192)) - 4))(v7);
}

uint64_t sub_100066BF0()
{
  unsigned int v0;
  uint64_t v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (((v0 < ((LODWORD(STACK[0x2F4]) - 671) ^ 0x3A1561A6u))
                                          * (((LODWORD(STACK[0x2F4]) + 237) | 0xF) - 789)) ^ (LODWORD(STACK[0x2F4]) - 671)))
                            - 8))();
}

uint64_t sub_100066C2C()
{
  unsigned int v0;
  uint64_t v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (((v0 > (STACK[0x280] & 0xFFF7D76F ^ 0x3A15678E))
                                          * ((STACK[0x290] & 0x15F4D7FD) + 134)) ^ (LODWORD(STACK[0x2F4]) - 671)))
                            - 8))();
}

uint64_t sub_100066C84(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  char v7;
  int v8;
  int v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  _BYTE *v15;
  unsigned int v16;
  unint64_t v17;
  unint64_t v18;

  v15 = (_BYTE *)(v13 + ((v9 - 332) ^ 0xF2604FE0) + a7);
  v16 = -1690040139
      * ((*(_DWORD *)(*(_QWORD *)STACK[0x2B8] + (*(_DWORD *)STACK[0x2B0] & 0x30A5DB10)) ^ v15) & 0x7FFFFFFF);
  v17 = -1690040139 * (v16 ^ HIWORD(v16));
  v18 = v17 >> (((v9 + 83) & 0xD7u) + 3);
  LOBYTE(v18) = *(_BYTE *)(*(_QWORD *)(v10 + 8 * (v9 - 1640)) + v18 - 8) ^ ((v8 ^ v11) >> v7) ^ *(_BYTE *)(*(_QWORD *)(v10 + 8 * (v9 - 1673)) + v18 - 12) ^ *(_BYTE *)(*(_QWORD *)(v10 + 8 * (v9 - 1765)) + v18 - 7) ^ v17 ^ (-85 * v18);
  *v15 = v18;
  return ((uint64_t (*)(void))(*(_QWORD *)(v12 + 8 * ((21 * (a7 - (v18 != 0) != v14)) ^ v9)) - 4))();
}

void sub_100067198()
{
  JUMPOUT(0x10006640CLL);
}

uint64_t sub_1000671A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t (*a40)(void))
{
  unint64_t v40;

  STACK[0x370] = v40;
  STACK[0x4B0] = STACK[0x2D8];
  return a40();
}

uint64_t sub_1000671C8(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  unsigned int a70;
  char *a71;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  BOOL v76;
  int v77;

  v74 = (a3 - 1031);
  v75 = STACK[0x4D8];
  STACK[0x440] = *(_QWORD *)(v73 + 8 * (a3 - 1080));
  STACK[0x200] = ((2 * (_QWORD)&STACK[0x380]) & 0xC27BCA975B67BC30)
               + ((unint64_t)&STACK[0x380] ^ 0xE13DE54BADB3DE1FLL)
               + (v74 ^ 0x7FDFBFB5DFDFE590);
  a71 = (char *)&a9 - 0x611D9C9E8D6D6FELL;
  a70 = (a3 + 1708782411) & 0x9A260EDF;
  LODWORD(STACK[0x220]) = 13 * (a3 ^ 0x47C);
  LODWORD(STACK[0x278]) = a3 - 507153660;
  STACK[0x528] = ((67 * (((a3 - 1111) | 0x283) ^ 0x28Eu)) ^ 0x403) + v71;
  STACK[0x338] = v75;
  if (v75)
    v76 = v72 == 0;
  else
    v76 = 1;
  v77 = !v76;
  return (*(uint64_t (**)(uint64_t, uint64_t, __n128))(v73 + 8 * (int)((170 * v77) ^ v74)))(654, 67, (__n128)0);
}

uint64_t sub_1000672EC(__n128 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;

  v11 = (char *)&STACK[0x5E0] + v8 - 0x611D9C9E8D6DD45;
  *(_DWORD *)v11 = 1604277838;
  *((_QWORD *)v11 + 1) = 0;
  *((_DWORD *)v11 + 4) = 1899249408;
  *((_DWORD *)v11 + 6) = 1528691550;
  *((_QWORD *)v11 + 4) = 0;
  *((_DWORD *)v11 + 10) = 1528691550;
  STACK[0x4F0] = (unint64_t)(v11 + 40);
  *((_QWORD *)v11 + 6) = 0;
  STACK[0x578] = (unint64_t)(v11 + 48);
  *((_DWORD *)v11 + 14) = 1528691550;
  STACK[0x490] = (unint64_t)(v11 + 56);
  *((_QWORD *)v11 + 8) = 0;
  STACK[0x3E0] = (unint64_t)(v11 + 64);
  *((_DWORD *)v11 + 18) = 1528691550;
  STACK[0x550] = (unint64_t)(v11 + 72);
  *((_QWORD *)v11 + 10) = 0;
  STACK[0x500] = (unint64_t)(v11 + 80);
  v11[88] = 76;
  *(_DWORD *)v9 = 1604277838;
  *(__n128 *)(v9 + 4) = a1;
  *(_DWORD *)(v9 + 20) = 0;
  *(_DWORD *)(v9 + 24) = 1528691550;
  *(_DWORD *)(v9 + 28) = 260442285;
  STACK[0x250] = v9 + 28;
  *(_DWORD *)(v9 + 232) = 260442285;
  STACK[0x248] = v9 + 232;
  *(__n128 *)(v9 + 436) = a1;
  *(__n128 *)(v9 + 452) = a1;
  *(_QWORD *)(v9 + 468) = 0;
  *(_QWORD *)(v9 + 1128) = 0xFEFEFEFEFEFEFEFELL;
  *(_QWORD *)(v9 + 1136) = 0xFEFEFEFEFEFEFEFELL;
  *(_QWORD *)(v9 + 1144) = 4278124286;
  *(__n128 *)(v9 + 1152) = a1;
  *(__n128 *)(v9 + 1168) = a1;
  *(__n128 *)(v9 + 1184) = a1;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v10 + 8 * ((173 * (((214 * ((v7 - 109) ^ 0x236u)) ^ 0x378) != 256)) ^ (v7 - 109)))
                                                                                                - 8))(566, 214, a4, a5, a6, a7, 888);
}

uint64_t sub_10006742C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t (*a9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t)@<X8>, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
  int v58;
  uint64_t v59;
  uint64_t v60;

  STACK[0x528] = v60 - 112;
  STACK[0x2E8] = *(_QWORD *)(v59 + 8 * (v58 ^ 0x44B)) - 4;
  return a9(a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48,
           a49,
           a50,
           a51,
           a52,
           a53,
           a54,
           a55,
           a56,
           a57,
           a58);
}

uint64_t sub_100067458(__n128 a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  _BOOL4 v7;

  *(_DWORD *)(v3 + 1424) = 105312208;
  *(_DWORD *)(v3 + 1428) = 1373296671;
  *(_QWORD *)(v3 + 1432) = v2;
  *(_QWORD *)(v3 + 1440) = v2;
  *(_DWORD *)(v3 + 1448) = v4;
  *(__n128 *)(v3 + 1452) = a1;
  v7 = (v1 ^ 0x303u ^ v5) == 16;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v6 + 8 * (((2 * v7) | (32 * v7)) ^ v1)) - 12))(771);
}

void sub_1000674BC()
{
  JUMPOUT(0x100067484);
}

uint64_t sub_1000674C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a65;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  char *v75;
  int v76;
  _DWORD *v77;
  _BOOL4 v79;
  uint64_t v80;

  a65 = v67;
  v73 = ((_DWORD)v65 + 949) | 0x125u;
  *(_QWORD *)(v68 + 1516) = v66;
  *(_QWORD *)(v68 + 1524) = v66;
  *(_DWORD *)(v68 + 1532) = v69;
  *(_QWORD *)(v71 + 96) = v68;
  a63 = v68;
  *(_DWORD *)(v68 + 476) = 393861081;
  STACK[0x2D0] = STACK[0x338];
  STACK[0x2C8] = *(_QWORD *)(v72 + 8 * v65) + (v73 ^ 0xFFFFFFFFFFFFFACDLL);
  v74 = STACK[0x528];
  v75 = (char *)&a9 + STACK[0x528] - 0x611D9C9E8D6D765;
  STACK[0x2A0] = STACK[0x528];
  STACK[0x280] = v74 + 432;
  STACK[0x2D8] = (unint64_t)v75;
  STACK[0x240] = (unint64_t)(v75 + 392);
  STACK[0x210] = v71;
  STACK[0x290] = v71;
  v76 = v73 + 359;
  STACK[0x528] = STACK[0x280];
  LODWORD(STACK[0x468]) = -324345622;
  LODWORD(STACK[0x548]) = 1528691550;
  STACK[0x4A0] = 0;
  LODWORD(STACK[0x344]) = 1546372649;
  v77 = (_DWORD *)STACK[0x2D8];
  *v77 = a6;
  LODWORD(STACK[0x2C0]) = 84622533;
  LODWORD(STACK[0x2E0]) = 835750968;
  LODWORD(STACK[0x2E8]) = 262255941;
  LODWORD(STACK[0x2B0]) = (v76 ^ 0x51C6E670) + 1431412186;
  v79 = *v77 != (_DWORD)a6 || (_DWORD)a8 + 1 != (_DWORD)a8 + v76 - 508 - 1184;
  v80 = *(_QWORD *)(v72 + 8 * ((v79 * (17 * (v76 ^ 0x6DF) - 874)) ^ v76));
  LODWORD(STACK[0x2B8]) = -316789702;
  LODWORD(STACK[0x2A8]) = v70;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(v80 - 4))(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48,
           a49,
           a50,
           a51,
           a52,
           a53,
           a54,
           a55,
           a56,
           a57);
}

uint64_t sub_100067658(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  unsigned int v9;
  uint64_t v10;

  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8
                                              * (int)((((v9 + 2081776447) & 0x83EA9E73 ^ 0x54C) * (v8 == a8)) ^ v9))
                            - (v9 ^ 0x4A4)))();
}

uint64_t sub_1000676AC()
{
  int v0;
  int v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v2
                              + 8
                              * ((14
                                * (((v1 - 1528691547) & 0xFFFFFFFC) - LODWORD(STACK[0x2A8]) != ((3
                                                                                               * ((v0 + 745249052) & 0xD39466DB ^ 0x452)) ^ 0xA4E202E9))) ^ v0)))();
}

uint64_t sub_100067710(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v6;
  int v7;
  int v8;
  uint64_t v9;
  _BOOL4 v11;

  v11 = v6 != a6 && LODWORD(STACK[0x344]) - v8 == ((v7 - 1483) | 0x420) + 17679915;
  return (*(uint64_t (**)(void))(v9 + 8 * ((307 * v11) ^ v7)))();
}

uint64_t sub_100067754(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v6;
  int v7;
  uint64_t v8;

  return (*(uint64_t (**)(void))(v8 + 8 * ((307 * (v6 != a6 + v7 - 427 - 1184)) ^ v7)))();
}

uint64_t sub_100067784(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  _DWORD *v13;
  _DWORD *v14;
  int v15;

  v13 = (_DWORD *)STACK[0x2D8];
  *v13 = v8 - 1;
  v13 += 2;
  v14 = &v13[6 * ((v9 - 427) ^ 0x8788F284) + 6 * v8];
  v15 = *v14;
  STACK[0x2D0] = *((_QWORD *)v14 + 1);
  LODWORD(STACK[0x344]) = v13[6 * (v8 - 2021067228) + 4];
  return ((uint64_t (*)(void))(*(_QWORD *)(v11
                                        + 8
                                        * ((73 * (*(_DWORD *)(v12 + (v15 + a4) * (uint64_t)v10 + 36) == a8)) | (v9 - 427)))
                            - ((16 * (v9 - 427)) ^ 0x4BD8u)
                            + 468))();
}

uint64_t sub_10006784C()
{
  int v0;
  int v1;
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  int v5;
  _BOOL4 v6;

  v3 = LODWORD(STACK[0x344]) - 1235064947;
  v4 = v1 + ((59 * (v0 ^ 0x778)) ^ 0xB7703380);
  v5 = (v4 < 0x128E2DB6) ^ (v3 < 0x128E2DB6);
  v6 = v3 < v4;
  if (v5)
    v6 = v4 < 0x128E2DB6;
  return (*(uint64_t (**)(void))(v2 + 8 * ((240 * v6) ^ v0)))();
}

uint64_t sub_1000678BC()
{
  int v0;
  int v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  uint64_t v5;

  v4 = 460628867 * ((2120966109 - ((v3 - 192) | 0x7E6B5FDD) + ((v3 - 192) | 0x8194A022)) ^ 0xCD02225F);
  *(_QWORD *)(v3 - 144) = STACK[0x258];
  *(_QWORD *)(v3 - 192) = STACK[0x268];
  *(_QWORD *)(v3 - 152) = STACK[0x260];
  *(_QWORD *)(v3 - 160) = STACK[0x270];
  *(_DWORD *)(v3 - 164) = v0 - v4 - 89;
  *(_DWORD *)(v3 - 184) = v1 + v4 + ((24 * (v0 ^ 0x1CF) - 454555049) & 0x1B17F7F3 ^ 0xA942FDEC);
  *(_QWORD *)(v3 - 176) = STACK[0x2D0];
  v5 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + v0 - 461) - 4))(v3 - 192);
  return (*(uint64_t (**)(uint64_t, __n128))(v2 + 8 * ((61 * (*(_DWORD *)(v3 - 168) == 489733862)) ^ v0)))(v5, (__n128)0);
}

uint64_t sub_1000679E0(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(void))(*(_QWORD *)(v6
                                        + 8
                                        * ((v5 - 424) | 0x458 | (2
                                                               * (*(_DWORD *)(v8 + (v7 + a4) * (uint64_t)v4) != 17 * (((v5 - 424) | 0x458) ^ 0x49B) + 350555288))))
                            - (((v5 - 424) | 0x458u)
                             + 433)
                            + 1669))();
}

uint64_t sub_100067A4C()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((52 * (v0 == ((v1 - 534) ^ 0xEA1AEA86) + v2)) | v1))
                            - (v1 - 534)
                            + 1127))();
}

uint64_t sub_100067A84()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  return (*(uint64_t (**)(void))(v3
                              + 8
                              * ((573 * (((v0 ^ 0x47B) & *(_DWORD *)(v4 + v2 * (uint64_t)v1 + 40)) == 0)) ^ (v0 - 667))))();
}

uint64_t sub_100067AF0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  return ((uint64_t (*)(void))(*(_QWORD *)(v11
                                        + 8
                                        * (int)((47
                                               * (*(_DWORD *)(v12 + v10 * (uint64_t)v9 + 36) != (((v8 ^ 0x2EF) - 1220) ^ (a8 - 328)))) ^ v8 ^ 0x2EF))
                            - v8
                            + 1135))();
}

uint64_t sub_100067B34()
{
  int v0;
  uint64_t v1;
  int v2;
  _BOOL4 v4;

  v4 = v2 + 29781910 > (v0 ^ 0x5AB) - 1885228873 && v2 + 29781910 < SLODWORD(STACK[0x2E8]);
  return (*(uint64_t (**)(void))(v1 + 8 * ((844 * v4) ^ v0)))();
}

void sub_100067B78()
{
  JUMPOUT(0x100067A04);
}

uint64_t sub_100067B80@<X0>(int a1@<W3>, int a2@<W8>)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;

  return (*(uint64_t (**)(void))(v5
                              + 8
                              * (((*(_DWORD *)(v6 + ((((v3 ^ 0x5CE) - 271) ^ (a1 + 345)) + v2) * (uint64_t)v4 + 36) != a2)
                                * ((((v3 ^ 0x5CE) - 246) | 0x10) - 406)) ^ v3 ^ 0x5CE)))();
}

uint64_t sub_100067BDC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  int v9;
  uint64_t v10;
  int v11;
  int v12;
  _BOOL4 v14;

  v14 = v8 == (((v9 - 415) | 0x1C8) ^ (v12 + 88)) && v11 != a8;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * ((v14 * (v9 + 97)) ^ v9)) - 8))();
}

uint64_t sub_100067C24(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  int v5;
  uint64_t v6;
  int v7;
  uint64_t v8;

  return (*(uint64_t (**)(void))(v6
                              + 8
                              * ((((*(_DWORD *)(v8 + (v7 + a4) * (uint64_t)v5 + 40) & 8) == ((v4 + 487) ^ 0x3BF))
                                * (v4 + 944)) ^ v4)))();
}

uint64_t sub_100067C60@<X0>(int a1@<W7>, int a2@<W8>)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  _BOOL4 v8;
  int v9;

  v6 = *(_DWORD *)(v5 + v2 * (uint64_t)v3 + 36);
  v8 = v6 + 603276937 > ((a2 - 924) | 0x18C) - 1311733138 && v6 + 603276937 < SLODWORD(STACK[0x2E0]);
  v9 = !v8;
  if (v6 == a1)
    v9 = 1;
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((118 * v9) ^ a2)) - 8))();
}

uint64_t sub_100067CC8()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  int v4;
  int v5;

  if (v1)
    v5 = v4;
  else
    v5 = v2;
  return (*(uint64_t (**)(void))(v3 + 8 * (((v5 == v4) * (((v0 - 340) | 0x618) - 431)) ^ v0)))();
}

uint64_t sub_100067D30()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * ((((((v0 + 75460962) & 0xFB808FDA ^ 0x1DA) & v1) != 0) * (v0 ^ 0xA2)) ^ v0))
                            - 8))();
}

uint64_t sub_100067D7C@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;

  v7 = STACK[0x2D8];
  *(_DWORD *)(v7 + 392) = a1;
  *(_DWORD *)(v7 + 396) = STACK[0x548];
  *(_QWORD *)(v7 + 400) = STACK[0x4A0];
  *(_DWORD *)(v7 + 408) = 1604277838 - v2 + LODWORD(STACK[0x344]);
  *(_QWORD *)(v7 + 416) = STACK[0x2D0] + (v2 - 1546372649);
  v8 = (*(uint64_t (**)(unint64_t, unint64_t))(v6 + v4 * (uint64_t)v1 + 8))(STACK[0x290], STACK[0x240]);
  return (*(uint64_t (**)(__n128))(v5
                                           + 8
                                           * ((59
                                             * (v3 + 489734844 + v8 - ((((v3 + 616) | 0x33) + 979466585) & (2 * v8)) == 489735316)) ^ v3)))((__n128)0);
}

uint64_t sub_100067E58()
{
  int v0;
  uint64_t v1;
  int v2;

  v2 = ((LODWORD(STACK[0x548]) - 1528691550) ^ 0x2B76FF7F5FF94EAFLL)
     + ((2 * (LODWORD(STACK[0x548]) - 1528691550)) & 0xBFF29D5E)
     - 0x2B76FF7E9CB7C7F0 != 3275851455;
  return (*(uint64_t (**)(void))(v1 + 8 * ((v2 | (v2 << 7)) ^ v0)))();
}

uint64_t sub_100067EEC()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;

  v5 = *(unsigned __int8 *)STACK[0x4A0]
     - (*(_BYTE *)(*(_QWORD *)(v4 + v2 * (uint64_t)v1 + 24) - 0x79A92BD4195FBC68) - 25);
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * ((412
                                          * (((v5 << (((v0 - 19) | 2) - 114)) & 0x5EE26C96) + (v5 ^ 0x2F71364B) == 795948619)) ^ (v0 + 536)))
                            - 4))();
}

uint64_t sub_100067FA4()
{
  unint64_t v0;
  unint64_t v1;
  uint64_t v2;
  int v3;
  uint64_t v4;
  _BOOL4 v5;

  v5 = v0 < v1;
  if (v5 == (unint64_t)(v2 - 0x775C7B190AB8AB48) < 0xC34186BF)
    v5 = v2 - 0x775C7B190AB8AB48 < v0;
  return (*(uint64_t (**)(void))(v4 + 8 * ((((v3 ^ 0x5A9) - 227) * v5) ^ v3)))();
}

void sub_100068000()
{
  JUMPOUT(0x100067F30);
}

uint64_t sub_100068018@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  uint64_t v3;

  return (*(uint64_t (**)(void))(v3 + 8 * ((((v2 + 624) ^ (v2 + 667)) * (a1 - v1 == 928816085)) ^ v2)))();
}

uint64_t sub_10006805C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  return (*(uint64_t (**)(void))(v11
                              + 8
                              * ((97 * (*(_DWORD *)(v12 + v10 * (uint64_t)v8 + 32) != a8 + ((v9 - 1182) | 0xC8) - 472)) ^ v9)))();
}

uint64_t sub_100068094@<X0>(int a1@<W8>)
{
  uint64_t v1;

  return (*(uint64_t (**)(void))(v1
                              + 8
                              * ((((*(_DWORD *)STACK[0x2D8] - 2021067227) < 0x10)
                                * ((a1 - 1758509793) & 0x68D0BD7B ^ 0x7F7)) ^ a1)))();
}

uint64_t sub_1000680E8@<X0>(int a1@<W8>)
{
  int v1;
  unsigned int v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  int v7;
  _DWORD *v8;
  unint64_t v9;
  _BOOL4 v11;

  v7 = STACK[0x344];
  v8 = (_DWORD *)STACK[0x2D8];
  v9 = STACK[0x2D8] + 24 * v2;
  *(_DWORD *)(v9 + 8) = v6;
  *(_DWORD *)(v9 + 12) = v4;
  *(_QWORD *)(v9 + 16) = STACK[0x2D0];
  *(_DWORD *)(v9 + 24) = v7;
  *v8 = ((17 * (a1 ^ 0x19B)) ^ 0x472) + v1;
  v11 = v3 - 1724040937 > 655916715 || v3 - 1724040937 < SLODWORD(STACK[0x2B0]);
  return (*(uint64_t (**)(void))(v5 + 8 * (a1 ^ (790 * v11))))();
}

uint64_t sub_10006815C@<X0>(int a1@<W8>)
{
  uint64_t v1;
  int v2;

  STACK[0x2D0] = STACK[0x4A0];
  LODWORD(STACK[0x344]) = 1546372649;
  return (*(uint64_t (**)(void))(v1
                              + 8
                              * (((v2 == 489733862) * ((((a1 ^ 0x366) - 570) | 0x618) - 431)) ^ ((a1 ^ 0x366) - 230))))();
}

uint64_t sub_100068194()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  _BOOL4 v7;

  v5 = *(_DWORD *)(v4 + v2 * (uint64_t)v0 + 36) - 549263733;
  v7 = v5 < 1830693920 && v5 >= SLODWORD(STACK[0x2B8]);
  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((v7 * (((v1 - 197) ^ 0x9A) - 510)) ^ (v1 - 197)))
                            - ((v1 - 998) | 0x10u)
                            + 468))();
}

uint64_t sub_100068230(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, uint64_t a7, int a8)
{
  int v8;
  int v9;
  uint64_t v10;
  _BOOL4 v12;

  v12 = *(_DWORD *)STACK[0x2D8] != a6 || v9 != a8 + v8 - 508 - 1184;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10 + 8 * ((v12 * (17 * (v8 ^ 0x6DF) - 874)) ^ v8)) - 4))();
}

uint64_t sub_100068288()
{
  STACK[0x528] = STACK[0x2A0];
  return ((uint64_t (*)(void))STACK[0x2C8])();
}

uint64_t sub_100068298(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v4;
  int v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((a3 + 383) ^ (1009 * (v3 == v5))))
                            - ((a3 - 1050) ^ 0x51)))();
}

void sub_1000682C8()
{
  int v0;
  uint64_t v1;
  unint64_t *v2;

  v2 = (unint64_t *)STACK[0x578];
  STACK[0x290] = STACK[0x250];
  STACK[0x2D0] = *v2;
  STACK[0x2C8] = *(_QWORD *)(v1 + 8 * v0);
  JUMPOUT(0x10006756CLL);
}

uint64_t sub_100068370(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a65;
  int a70;
  uint64_t a71;
  uint64_t v71;
  unint64_t v72;

  *(_QWORD *)(a63 + 1560) = *(_QWORD *)STACK[0x500];
  *(_DWORD *)(a63 + 1552) = *(_DWORD *)STACK[0x550];
  v72 = STACK[0x210];
  *(_QWORD *)(*(_QWORD *)(STACK[0x210] + 96) + 488) = *(_QWORD *)(STACK[0x210] + 8);
  *(_DWORD *)(*(_QWORD *)(v72 + 96) + 480) = *(_DWORD *)v72;
  *(_BYTE *)(a71 + a65) = ((STACK[0x200] - 27) ^ 0xBA) * (STACK[0x200] - 10);
  return (*(uint64_t (**)(void))(v71 + 8 * a70))();
}

void sub_100068424()
{
  JUMPOUT(0x1000683E8);
}

uint64_t sub_10006842C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, uint64_t a9@<X8>, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58)
{
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t (*v61)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);

  STACK[0x380] = a9 + 104;
  v61 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))STACK[0x440];
  STACK[0x528] = v60 - 112;
  STACK[0x2E8] = *(_QWORD *)(v59 + 8 * ((v58 + 1031) ^ 0x44B)) - 4;
  return v61(a1, a2, a3, a4, a5, a6, a7, a8, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48,
           a49,
           a50,
           a51,
           a52,
           a53,
           a54,
           a55,
           a56,
           a57,
           a58);
}

uint64_t sub_100068460(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  uint64_t v4;
  int v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * (((LODWORD(STACK[0x220]) + 1741) * (v3 == v5)) ^ (a3 - 944))) - 4))();
}

uint64_t sub_10006848C()
{
  uint64_t v0;
  int v1;
  int v2;
  unsigned int v3;
  unint64_t v4;

  v1 = STACK[0x220];
  v2 = LODWORD(STACK[0x220]) + 944;
  v3 = (LODWORD(STACK[0x220]) + 1894018608) & 0x8F1B957F;
  v4 = STACK[0x3A8];
  STACK[0x470] = STACK[0x3A8];
  STACK[0x4B8] = 0;
  LODWORD(STACK[0x534]) = 1528691550;
  STACK[0x540] = 0;
  LODWORD(STACK[0x434]) = 1528691550;
  STACK[0x4C0] = 0;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * (int)((((v2 ^ 0x420) + v3) * (v4 != 0)) ^ v1)) - 4))();
}

uint64_t sub_100068504@<X0>(uint64_t a1@<X8>)
{
  int v1;
  uint64_t v2;

  return (*(uint64_t (**)(void))(v2
                              + 8
                              * ((((*(_BYTE *)(a1 + 32) - *((_BYTE *)*(&off_100180420 + v1 - 1022) - 8)) == 187)
                                * ((v1 ^ 0x73E) - 609)) ^ (v1 + 496))))();
}

uint64_t sub_100068584(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5, unint64_t a6)
{
  int v6;
  int v7;
  uint64_t v8;
  unsigned __int8 v9;

  return ((uint64_t (*)(void))(*(_QWORD *)(v8
                                        + 8 * (((v7 == ((((v6 - 77) | v9) - 59) & 0xFC)) * a5) ^ v6))
                            - (((v6 + 211) | a4) ^ a6)))();
}

uint64_t sub_1000685BC(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;

  return (*(uint64_t (**)(void))(v6
                              + 8
                              * ((((*(_BYTE *)(v4 + 1 + a3) - *(_BYTE *)(v3 + 1)) == 187)
                                * ((v5 ^ a2) - 609)) ^ (v5 + 496))))();
}

uint64_t sub_1000685F8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  int v3;
  uint64_t v4;
  int v5;

  v5 = ((v3 ^ 0xD7) - 37 + 6 * (v3 ^ 0xD7) + *(_BYTE *)(a3 + a2) - **(_BYTE **)(a1 + 8 * (v3 ^ 0x4A4))) == 227;
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((8 * v5) | (v5 << 6) | ((v3 ^ 0xAF) - 60))) - 8))();
}

uint64_t sub_1000687D0(uint64_t a1, uint64_t a2, uint64_t a3, int a4, char a5)
{
  int v5;
  int v6;
  uint64_t v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7
                                        + 8
                                        * (((v6 == ((17 * (v5 ^ a4)) ^ a5)) * ((v5 ^ a4) + 1889)) ^ v5))
                            - 8))();
}

void sub_1000687FC()
{
  JUMPOUT(0x100068784);
}

uint64_t sub_10006880C@<X0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  int v3;
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v5
                                                      + 8
                                                      * ((((*(_BYTE *)(a3 + a2)
                                                                           - **(_BYTE **)(a1 + 8
                                                                                             * ((v3 - 463) ^ 0x456))
                                                                           + (((v3 - 61) | 0x80) ^ 0x26)) != 94)
                                                        * v4) ^ (v3 - 279)))
                                          - 8))(769);
}

uint64_t sub_1000688AC(int a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  int v5;
  int v6;
  uint64_t v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * (((v6 == (v5 ^ a5)) * a1) ^ (v5 - 1007)))
                            - (v5 - 1043)
                            + 84))();
}

void sub_1000688DC()
{
  JUMPOUT(0x10006886CLL);
}

uint64_t sub_1000688E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t (*a64)(uint64_t, uint64_t);
  int v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;

  v66 = (4 * v64) ^ 0xE74;
  v67 = a64(1576, 2940923044);
  STACK[0x4C0] = v67;
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v65 + 8 * (((v67 == 0) * (((v66 - 86) | 0x650) ^ 0x6F9)) ^ v66)) - 4))(v67, v68, v69, v70, 3805275455, v71, v72, v73, a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19,
           a20,
           a21,
           a22,
           a23,
           a24,
           a25,
           a26,
           a27,
           a28,
           a29,
           a30,
           a31,
           a32,
           a33,
           a34,
           a35,
           a36,
           a37,
           a38,
           a39,
           a40,
           a41,
           a42,
           a43,
           a44,
           a45,
           a46,
           a47,
           a48,
           a49,
           a50,
           a51,
           a52,
           a53,
           a54,
           a55);
}

uint64_t sub_1000689A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t (*a64)(uint64_t, uint64_t);
  int v64;
  uint64_t v65;
  unint64_t v66;
  uint64_t v67;

  STACK[0x2A0] = v66;
  v67 = a64(1576, 3012117910);
  STACK[0x360] = v67;
  return ((uint64_t (*)(void))(*(_QWORD *)(v65 + 8 * ((245 * (v67 == 0)) ^ v64)) - (((v64 ^ 0x229u) + 109) ^ 0x4E8)))();
}

uint64_t sub_1000689F8()
{
  int v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((501 * (v0 != ((29 * (v2 ^ 0x4ED)) ^ 0x1777C551))) ^ v2))
                            - 204 * (v2 ^ 0x4E3u)
                            + 600))();
}

uint64_t sub_100068A64@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8 * ((11 * (v2 != (((a1 - 556) | 0x141) ^ v1 ^ ((a1 - 323) | 0x58)))) ^ a1))
                            - 12))();
}

uint64_t sub_100068ABC()
{
  int v0;
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((((v2 - 314) ^ 0x5D7) * (v1 == v0)) ^ v2)) - 12))();
}

uint64_t sub_100068AF4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  int v61;
  uint64_t v62;

  v61 = (((v59 | 0x173579D6) - (v59 & 0x173579D6)) ^ 0x69C129AA) * v53;
  *(_QWORD *)(v60 - 168) = a52;
  *(_QWORD *)(v60 - 160) = a53;
  *(_QWORD *)(v60 - 176) = v54;
  *(_DWORD *)(v60 - 192) = v57 - v61 - 145;
  *(_DWORD *)(v60 - 184) = v61 ^ 0x5769FB2C;
  v62 = ((uint64_t (*)(uint64_t))STACK[0x228])(v60 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v58
                                                      + 8
                                                      * (((*(_DWORD *)(v60 - 188) == v56 + (v57 ^ 0x146) - 63)
                                                        * (v55 ^ 0xC7)) ^ v57))
                                          - 12))(v62);
}

uint64_t sub_100068BAC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  int v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;

  v56 = 1543737703 * ((~((v55 - 192) | 0x395EF543) + ((v55 - 192) & 0x395EF543)) ^ 0xB8555AC0);
  *(_DWORD *)(v55 - 192) = v53 - v56 - 145;
  *(_DWORD *)(v55 - 184) = v56 ^ 0x5769FB2C;
  *(_QWORD *)(v55 - 176) = 0x4AB8828D926C7A6CLL;
  *(_QWORD *)(v55 - 168) = a52;
  *(_QWORD *)(v55 - 160) = a53;
  v57 = ((uint64_t (*)(uint64_t))STACK[0x228])(v55 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v54
                                                      + 8
                                                      * (int)(((*(_DWORD *)(v55 - 188) == 489733862)
                                                             * ((v53 + 1528650566) & 0xA4E2A37F ^ 0xC7)) ^ v53))
                                          - 12))(v57);
}

uint64_t sub_100068C9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53)
{
  int v53;
  uint64_t v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  uint64_t v59;

  v58 = ((v57 + 742264459 - 2 * ((v57 - 192) & 0x2C3E0F4B)) ^ 0x52CA5F37) * v53;
  *(_QWORD *)(v57 - 176) = v54;
  *(_QWORD *)(v57 - 168) = a52;
  *(_DWORD *)(v57 - 192) = v56 - v58 - 145;
  *(_DWORD *)(v57 - 184) = v58 ^ 0x5769FB2E;
  *(_QWORD *)(v57 - 160) = a53;
  v59 = ((uint64_t (*)(uint64_t))STACK[0x228])(v57 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v55
                                                      + 8
                                                      * (((*(_DWORD *)(v57 - 188) == 489733862) * (v56 ^ 0x181)) ^ v56))
                                          - 12))(v59);
}

uint64_t sub_100068D74@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44)
{
  uint64_t v44;
  int v45;
  uint64_t (*v46)(uint64_t);
  unint64_t v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  unsigned int v53;
  uint64_t v54;
  int v55;

  v53 = (((v51 | 0xD09C481E) - (v51 & 0xD09C481E)) ^ 0xAE681862) * v45;
  *(_QWORD *)(v52 - 176) = v44;
  *(_QWORD *)(v52 - 168) = a43;
  *(_DWORD *)(v52 - 184) = a1 ^ v53;
  *(_DWORD *)(v52 - 192) = v48 - v53 + 169;
  *(_QWORD *)(v52 - 160) = a44;
  v54 = v46(v52 - 192);
  v55 = *(_DWORD *)(v52 - 188);
  STACK[0x538] = v47;
  return ((uint64_t (*)(uint64_t, __n128))(*(_QWORD *)(v50 + 8 * ((1249 * (v55 == v49)) ^ v48))
                                                  - (((v48 - 63) | 0x473u) ^ 0x47FLL)))(v54, (__n128)0);
}

void sub_100068E4C()
{
  JUMPOUT(0x100068E5CLL);
}

void sub_100068E68(int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  STACK[0x440] = v1 + *(_QWORD *)(v2 + 8 * a1) - 112;
  JUMPOUT(0x1000672B0);
}

uint64_t sub_100068E9C()
{
  int v0;
  unint64_t v1;
  uint64_t v2;

  STACK[0x538] = v1;
  return ((uint64_t (*)(unint64_t))(*(_QWORD *)(v2
                                                               + 8
                                                               * ((55 * (STACK[0x540] != 0)) ^ (((v0 + 1057) | 0x13)
                                                                                              - 801)))
                                                   - 4))(STACK[0x540]);
}

uint64_t sub_1000698C8()
{
  int v0;
  uint64_t v1;

  ((void (*)(void))STACK[0x230])();
  return (*(uint64_t (**)(void))(v1 + 8 * ((119 * (STACK[0x4B8] == 0)) ^ (v0 + 451))))();
}

uint64_t sub_1000698F4()
{
  int v0;
  uint64_t v1;

  return (*(uint64_t (**)(void))(v1 + 8 * ((1178 * (STACK[0x4C0] != 0)) ^ (v0 - 281))))();
}

uint64_t sub_100069918()
{
  int v0;
  uint64_t v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((91 * (STACK[0x360] != 0)) ^ (v0 - 230))) - 4))();
}

uint64_t sub_10006994C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  int v5;
  uint64_t v6;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v6
                                                                                          + 8
                                                                                          * ((124
                                                                                            * (((v5 == 489733862) ^ (v4 + 80)) & 1)) ^ (v4 - 948)))
                                                                              - 4))(a1, a2, a3, a4, 3805275455);
}

uint64_t sub_10006998C()
{
  int v0;
  uint64_t v1;

  return (*(uint64_t (**)(void))(v1 + 8 * ((119 * (STACK[0x4B8] == 0)) ^ (v0 + 451))))();
}

uint64_t sub_1000699B0()
{
  int v0;
  uint64_t v1;

  ((void (*)(void))STACK[0x230])();
  return (*(uint64_t (**)(void))(v1 + 8 * ((1178 * (STACK[0x4C0] != 0)) ^ (v0 - 281))))();
}

uint64_t sub_1000699DC()
{
  int v0;
  uint64_t v1;

  ((void (*)(void))STACK[0x230])();
  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((91 * (STACK[0x360] != 0)) ^ (v0 - 230))) - 4))();
}

uint64_t sub_100069A18()
{
  int v0;
  int v1;
  uint64_t v2;
  uint64_t v3;

  v3 = ((uint64_t (*)(void))STACK[0x230])();
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v2
                                                      + 8
                                                      * ((124 * (((v1 == 489733862) ^ (v0 + 80)) & 1)) ^ (v0 - 948)))
                                          - 4))(v3);
}

uint64_t sub_100069A60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43)
{
  int v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  unint64_t v48;
  int v49;
  uint64_t v50;

  LODWORD(STACK[0x464]) = 1863051433;
  LODWORD(STACK[0x354]) = 128;
  v46 = STACK[0x3A8];
  v47 = STACK[0x510];
  v48 = STACK[0x428];
  v49 = 2078219279 * ((~((v45 - 192) | 0xAFF9E70E) + ((v45 - 192) & 0xAFF9E70E)) ^ 0x8AFC8E85);
  *(_DWORD *)(v45 - 132) = v49 + v43 + 925;
  *(_QWORD *)(v45 - 128) = v47;
  *(_QWORD *)(v45 - 184) = 0;
  *(_QWORD *)(v45 - 176) = a43;
  *(_QWORD *)(v45 - 152) = 0;
  *(_QWORD *)(v45 - 144) = v48;
  *(_DWORD *)(v45 - 168) = 726518907 - v49;
  *(_QWORD *)(v45 - 160) = v46 + 0x2DB44D49A49B034ELL;
  *(_QWORD *)(v45 - 192) = v46 + 0x2DB44D49A49B023ELL;
  v50 = ((uint64_t (*)(uint64_t))STACK[0x2E8])(v45 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v44
                                                      + 8
                                                      * (((*(_DWORD *)(v45 - 136) == 489733862) * ((v43 ^ 0xD2) + 1208)) ^ v43))
                                          - ((67 * (v43 ^ 0xD2u)) ^ 0x477)))(v50);
}

uint64_t sub_100069B70()
{
  uint64_t v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * (((v0 - STACK[0x4D0] > 0x1F) * ((v1 + 770) ^ 0x4C7)) ^ (v1 + 770)))
                            - ((2 * (v1 + 770)) ^ 0x4D8u)
                            + 762))();
}

uint64_t sub_100069BC4@<X0>(uint64_t a1@<X8>)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int8x16_t v6;
  int8x16_t v7;
  int8x16_t v8;
  int8x16_t v9;
  uint64_t v10;
  int8x16_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;

  v5 = v3 + 127 - v1;
  v6 = vrev64q_s8(*(int8x16_t *)(v5 - 15));
  v7 = vextq_s8(v6, v6, 8uLL);
  v8 = vrev64q_s8(*(int8x16_t *)(v5 - 31));
  v9 = vextq_s8(v8, v8, 8uLL);
  v10 = a1 + 127 - v1;
  v11.i64[0] = 0xFCFCFCFCFCFCFCFCLL;
  v11.i64[1] = 0xFCFCFCFCFCFCFCFCLL;
  v12.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v12.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v13 = vrev64q_s8(vaddq_s8(vsubq_s8(v7, vandq_s8(vaddq_s8(v7, v7), v11)), v12));
  *(int8x16_t *)(v10 - 15) = vextq_s8(v13, v13, 8uLL);
  v14 = vrev64q_s8(vaddq_s8(vsubq_s8(v9, vandq_s8(vaddq_s8(v9, v9), v11)), v12));
  *(int8x16_t *)(v10 - 31) = vextq_s8(v14, v14, 8uLL);
  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * (((v1 != 96) * ((v2 + 258) ^ 0x239)) ^ v2)) - 4))();
}

uint64_t sub_100069C58@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_BYTE *)(a1 + ((v1 << 6) ^ 0xFFFFFFFFBFF0DF04) + v3) = *(_BYTE *)(v5
                                                                                    + ((v1 << 6) ^ 0xFFFFFFFFBFF0DF04)
                                                                                    + v3)
                                                                         - ((2
                                                                           * *(_BYTE *)(v5
                                                                                      + ((v1 << 6) ^ 0xFFFFFFFFBFF0DF04)
                                                                                      + v3)) & 0xFC)
                                                                         - 2;
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * (((v3 - 1 != v4) * v2) ^ v1)) - 4))();
}

uint64_t sub_100069CA8()
{
  int v0;
  uint64_t v1;
  int v2;

  LODWORD(STACK[0x56C]) = v2;
  return (*(uint64_t (**)(void))(v1
                              + 8 * ((330 * (*(_DWORD *)(STACK[0x238] + 360) - 775263488 < (v0 ^ 0x73u) - 1141)) ^ v0)))();
}

uint64_t sub_100069CF8@<X0>(int a1@<W8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  char *v64;
  unint64_t v65;
  uint64_t (*v66)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  int v67;
  int v68;
  uint64_t v69;

  v54 = (*(uint64_t (**)(_QWORD, _QWORD, unint64_t))(v48 + 8 * (v49 ^ 0x421)))(LODWORD(STACK[0x54C]), (a1 + 1), STACK[0x408]);
  v61 = (v54 ^ 0x67FDECFF) + (v49 ^ 0xBD67D3DB) + ((2 * v54) & 0xCFFBD9FE);
  v62 = STACK[0x2F4];
  if (v61 == 627426522)
  {
    v64 = (char *)&STACK[0x5E0] + v52 + ((v62 - 103) | 0x280u) - 0x611D9C9E8D6DD45;
    v65 = (unint64_t)(v64 - 3500);
    STACK[0x388] = (unint64_t)(v64 - 3500);
    STACK[0x2D8] = (unint64_t)(v64 - 3272);
    LODWORD(STACK[0x414]) = 1071099136;
    v66 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v51 + 8 * ((3223 * (v64 != (char *)3252)) ^ (v62 + 106))) - ((271 * (v62 ^ 0x471u)) ^ 0x21ALL));
    STACK[0x528] = v52 - 192;
    STACK[0x318] = 0;
    LODWORD(STACK[0x51C]) = 1528691550;
    STACK[0x2C8] = STACK[0x4A8];
    STACK[0x2E0] = v65;
    return v66(v54, v55, v56, v57, 3805275455, v58, v59, v60, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12,
             a13,
             a14,
             a15,
             a16,
             a17,
             a18,
             a19,
             a20,
             a21,
             a22,
             a23,
             a24,
             a25,
             a26,
             a27,
             a28,
             a29,
             a30,
             a31,
             a32,
             a33,
             a34,
             a35,
             a36,
             a37,
             a38,
             a39,
             a40,
             a41,
             a42,
             a43,
             a44,
             a45,
             a46,
             a47,
             a48);
  }
  else if (v61 == 895861981)
  {
    LODWORD(STACK[0x56C]) = -489691682;
    return ((uint64_t (*)(void))(*(_QWORD *)(v51
                                          + 8
                                          * (((((v62 - 50) ^ (STACK[0x3C0] == 0)) & 1) * (v62 ^ 0x47F)) | (v62 - 818)))
                              - 8))();
  }
  else
  {
    v67 = 268847287 * ((((v53 - 192) | 0x51786A13) + (~(v53 - 192) | 0xAE8795EC)) ^ 0xAED27B3A);
    *(_DWORD *)(v53 - 192) = (v61 - ((2 * v61 + 892630604) & v50) - 137692660) ^ v67;
    *(_QWORD *)(v53 - 184) = a23;
    *(_DWORD *)(v53 - 176) = v67 + v62 + 893;
    v68 = v62;
    v69 = sub_100054A00((_DWORD *)(v53 - 192));
    return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v51
                                                        + 8
                                                        * (((((v68 - 50) ^ (STACK[0x3C0] == 0)) & 1)
                                                          * (v68 ^ 0x47F)) | (v68 - 818)))
                                            - 8))(v69);
  }
}

uint64_t sub_10006A448(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  int v63;
  int v64;
  uint64_t v65;
  uint64_t v66;

  v66 = ((uint64_t (*)(uint64_t))STACK[0x230])(a63);
  STACK[0x528] = STACK[0x2A0] - 1824;
  LODWORD(STACK[0x56C]) = v64;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v65
                                                      + 8
                                                      * (((((v63 - 50) ^ (STACK[0x3C0] == 0)) & 1)
                                                        * (v63 ^ 0x47F)) | (v63 - 818)))
                                          - 8))(v66);
}

uint64_t sub_10006A4B0()
{
  int v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * (((LODWORD(STACK[0x56C]) != v2) * ((v0 + 101) ^ 0x371)) ^ v0)) - 8))();
}

void sub_10006A4E8()
{
  JUMPOUT(0x10006A4F4);
}

uint64_t sub_10006A558(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,int a47,int a48,uint64_t a49,uint64_t a50)
{
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  uint64_t v55;
  int v56;

  v54 = 69008221 * ((((v53 - 192) | 0xE9AA6CBB) + (~(v53 - 192) | 0x16559344)) ^ 0x3A083EB0);
  *(_DWORD *)(v53 - 188) = LODWORD(STACK[0x49C]) - v54 - 294932327;
  *(_QWORD *)(v53 - 184) = a50;
  *(_DWORD *)(v53 - 152) = v54 + a48 - 837498797;
  *(_QWORD *)(v53 - 168) = a45;
  *(_QWORD *)(v53 - 160) = a46;
  *(_DWORD *)(v53 - 176) = (v50 + 88) ^ v54;
  v55 = (*(uint64_t (**)(uint64_t))(v51 + 8 * (v50 - 192)))(v53 - 192);
  v56 = *(_DWORD *)(v53 - 192);
  LODWORD(STACK[0x4CC]) = v56;
  return (*(uint64_t (**)(uint64_t))(v52 + 8 * (((v56 == 489733862) * (23 * (v50 ^ 0x154) + 421)) ^ v50)))(v55);
}

uint64_t sub_10006A644()
{
  int v0;
  uint64_t v1;

  STACK[0x3A0] = STACK[0x3E8];
  LODWORD(STACK[0x520]) = STACK[0x574];
  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (((LODWORD(STACK[0x49C]) - 775263487) < 2) ^ ((v0 + 189) | 0x32)))
                            - ((((((v0 + 189) | 0x32) - 178) | 0x51u) + 790) ^ 0x47FLL)))();
}

void sub_10006A6A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  LODWORD(STACK[0x4CC]) = a5 - 54;
  sub_10007184C(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

uint64_t sub_10006A6AC()
{
  int v0;
  uint64_t v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * (((LODWORD(STACK[0x49C]) - 775263487) < 2) ^ v0))
                            - ((((v0 - 178) | 0x51u) + 790) ^ 0x47FLL)))();
}

uint64_t sub_10006A6EC@<X0>(uint64_t a1@<X8>, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48)
{
  int v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  unint64_t v52;
  int v53;
  int v54;
  uint64_t v55;
  int v56;

  v52 = STACK[0x3A0];
  v53 = STACK[0x574];
  v54 = 268847287 * ((((v51 - 192) | 0x63168F3F) - ((v51 - 192) & 0x63168F3F)) ^ 0x9CBC9E17);
  *(_DWORD *)(v51 - 136) = v48 - v54 - ((((v49 + 741) | 0x31) + 2 * v48 + 596955537) & 0x51D99EAE) - 88655271;
  *(_QWORD *)(v51 - 144) = a48;
  *(_DWORD *)(v51 - 168) = -268847287 * ((((v51 - 192) | 0x63168F3F) - ((v51 - 192) & 0x63168F3F)) ^ 0x9CBC9E17)
                         + 1617030143 * v53
                         + 1155257572;
  *(_DWORD *)(v51 - 152) = v49 - v54 + 1695027103;
  *(_QWORD *)(v51 - 160) = v52;
  *(_QWORD *)(v51 - 192) = a47;
  *(_QWORD *)(v51 - 176) = a1;
  v55 = sub_100074978(v51 - 192);
  v56 = *(_DWORD *)(v51 - 184);
  LODWORD(STACK[0x4CC]) = v56;
  return (*(uint64_t (**)(uint64_t))(v50 + 8 * ((1735 * (v56 == 489733862)) ^ v49)))(v55);
}

uint64_t sub_10006A7FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,int a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49)
{
  uint64_t v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  int v55;
  uint64_t v56;
  int v57;

  v53 = STACK[0x520];
  v54 = *(_DWORD *)(STACK[0x238] + 52) + 1294313647;
  v55 = 1224239923 * ((((v52 - 192) | 0xAFEE53DD) - ((v52 - 192) & 0xAFEE53DD)) ^ 0x5D5DAE0A);
  *(_QWORD *)(v52 - 184) = a49;
  *(_DWORD *)(v52 - 176) = v54 ^ v55;
  *(_DWORD *)(v52 - 172) = v55 + v50 - 300;
  *(_DWORD *)(v52 - 148) = ((a42 ^ 0x9A17DFF1)
                          + 1941831152
                          + (((v50 + 755) | 0x23) ^ (2 * a42) & 0xBBE4AEBC ^ (((v50 + 755) ^ 0x717) - 1950351064))) ^ v55;
  *(_QWORD *)(v52 - 168) = &STACK[0x5D0];
  *(_QWORD *)(v52 - 160) = v49;
  *(_DWORD *)(v52 - 192) = (v53 ^ 0x75F7ABFF) - 272236544 + ((2 * v53) & 0xEBEF57FE) + v55 + 2744320;
  v56 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + v50 - 196) - 4))(v52 - 192);
  v57 = *(_DWORD *)(v52 - 152);
  LODWORD(STACK[0x4CC]) = v57;
  return (*(uint64_t (**)(uint64_t))(v51 + 8 * ((1197 * (v57 == 489733862)) ^ v50)))(v56);
}

uint64_t sub_10006A954()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * (((((v1 - 1305470937) & 0x4DCFE7F5) - 833)
                                          * ((v0 - 775263488) > 0xFFFFFFFD)) ^ v1))
                            - 12))();
}

void sub_10006A99C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,int a41,int a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,unsigned int *a62,void (*a63)(_QWORD, uint64_t, uint64_t))
{
  int v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  int v79;
  unint64_t v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  int v85;

  v69 = STACK[0x2C8];
  if (LODWORD(STACK[0x2C8]) == 360397997)
  {
    ((void (*)(void))(*(_QWORD *)(v67
                                + 8
                                * ((38 * (LODWORD(STACK[0x2C0]) - 183363313 < ((v63 + 330) ^ 0x5BEu))) | (v63 + 918)))
                    - 12))();
  }
  else if (v69 == 91962538)
  {
    v78 = v63 ^ 0x2BA;
    v79 = v63 - 193;
    a63(*a62, v64, v65);
    STACK[0x3A0] = 0;
    LODWORD(STACK[0x520]) = 0;
    v80 = STACK[0x508];
    v81 = *(_DWORD *)(STACK[0x238] + 52) + 1069122194;
    v82 = 3804331 * ((((2 * (v68 - 192)) | 0x4D2722E6) - (v68 - 192) + 1500278413) ^ 0xD846B485);
    v83 = v82 + (LODWORD(STACK[0x3BC]) ^ 0xBF7FCF1F) + ((2 * LODWORD(STACK[0x3BC])) & 0x7EFF9E3E) + 1306917871;
    *(_DWORD *)(v68 - 168) = LODWORD(STACK[0x2F4]) - v82 - 1054;
    *(_DWORD *)(v68 - 164) = v83;
    *(_DWORD *)(v68 - 152) = (v66 & 0xBA8EDEE2 ^ 0x8A8A1042)
                           - v82
                           + ((v78 + 2147481910) & a42 ^ 0x1AA2E7DE)
                           + 1727840192;
    *(_DWORD *)(v68 - 192) = v81 ^ v82;
    *(_QWORD *)(v68 - 160) = &STACK[0x1900];
    *(_QWORD *)(v68 - 184) = a49;
    *(_QWORD *)(v68 - 176) = v80;
    v84 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + LODWORD(STACK[0x2F4]) - 985) - 12))(v68 - 192);
    v85 = *(_DWORD *)(v68 - 188);
    LODWORD(STACK[0x4CC]) = v85;
    (*(void (**)(uint64_t))(v67 + 8 * ((1906 * (v85 == 489733862)) ^ v79)))(v84);
  }
  else
  {
    LODWORD(STACK[0x2C8]) = v69;
    v70 = 268847287 * ((((v68 - 192) | 0xB5A806F) - (v68 - 192) + ((v68 - 192) & 0xF4A57F90)) ^ 0xF4F09147);
    *(_DWORD *)(v68 - 176) = v70 + v63 + 893;
    *(_QWORD *)(v68 - 184) = a29;
    *(_DWORD *)(v68 - 192) = (v69 - ((2 * v69 + 889816748) & 0x3A617DCC) + 397771324) ^ v70;
    v71 = sub_100054A00((_DWORD *)(v68 - 192));
    sub_10007184C(v71, v72, v73, v74, 3805275455, v75, v76, v77, a9);
  }
}

uint64_t sub_10006DEAC()
{
  int v0;
  int v1;
  unsigned int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * (((v0 - 775263487 < (v1 ^ v2) - 1137) * ((2 * v1) ^ 0xDBE)) ^ v1))
                            - 4))();
}

uint64_t sub_10006DEE8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t (*a27)(uint64_t),uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55)
{
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unint64_t v60;
  int v61;
  uint64_t v62;
  int v63;

  v59 = v55 ^ 0xB7E;
  v60 = STACK[0x508];
  v61 = 2078219279 * ((v58 - 192 - 2 * ((v58 - 192) & 0x177082E3) + 393249507) ^ 0xCD8A1497);
  *(_DWORD *)(v58 - 132) = v61
                         + (((v55 ^ 0xB7E) - 1269050098) & 0x4BA427B7)
                         + (LODWORD(STACK[0x3BC]) ^ 0xEAFDFECF)
                         + ((2 * LODWORD(STACK[0x3BC])) & 0xD5FBFD9E)
                         + 1442526218;
  *(_DWORD *)(v58 - 128) = v61 + (v55 ^ 0xB7E) - 1337;
  *(_QWORD *)(v58 - 184) = v60;
  *(_QWORD *)(v58 - 176) = a54;
  *(_QWORD *)(v58 - 160) = a28;
  LOBYTE(STACK[0x1998]) = 15 * ((v58 + 64 - 2 * ((v58 + 64) & 0xE3) - 29) ^ 0x97) + 81;
  *(_QWORD *)(v58 - 144) = a42;
  *(_DWORD *)(v58 - 152) = (v56 + 939875877 + (v55 ^ 0xB7E) - 633) ^ v61;
  *(_QWORD *)(v58 - 192) = a55;
  v62 = a27(v58 - 192);
  v63 = *(_DWORD *)(v58 - 168);
  LODWORD(STACK[0x4CC]) = v63;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v57
                                                      + 8
                                                      * (((4 * (v63 != 489733862)) | (16 * (v63 != 489733862))) ^ v59))
                                          - 8))(v62);
}

uint64_t sub_10006E008(uint64_t a1)
{
  int v1;
  uint64_t v2;
  unint64_t v3;
  BOOL v4;

  v3 = STACK[0x508];
  v4 = LODWORD(STACK[0x3BC]) == 0;
  STACK[0x328] = LODWORD(STACK[0x3BC]);
  return ((uint64_t (*)(uint64_t, unint64_t))(*(_QWORD *)(v2
                                                                        + 8
                                                                        * ((v1 + 440) | (4
                                                                                       * ((v4 ^ (v1 + 63) ^ 0xDD) & 1))))
                                                            - 8))(a1, v3);
}

uint64_t sub_10006E044(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,unsigned int *a61,void (*a62)(_QWORD, uint64_t, _QWORD),uint64_t a63)
{
  uint64_t (*a68)(uint64_t);
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  int v75;
  uint64_t v76;

  v72 = v68 + 193;
  a62(*a61, a2, 0);
  v73 = LODWORD(STACK[0x4CC]);
  v74 = 235795823 * (v69 ^ 0x8B0BAFE94AD4959);
  *(_DWORD *)(v71 - 172) = ((v72 - 1962335484) & 0xBF2B3FA3) - v74;
  v75 = v72 - 1962335484 - v74;
  *(_DWORD *)(v71 - 192) = v75;
  *(_DWORD *)(v71 - 184) = v75 + 56;
  *(_DWORD *)(v71 - 180) = v74;
  *(_QWORD *)(v71 - 168) = v73 - v74;
  *(_QWORD *)(v71 - 160) = v74 ^ 0xE2CFE53CLL;
  *(_DWORD *)(v71 - 176) = (v72 - 1689052641) ^ v74;
  v76 = a68(v71 - 192);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v70 + 8 * *(int *)(v71 - 188)) - 12))(v76);
}

uint64_t sub_10006E200()
{
  int v0;
  uint64_t v1;
  int v2;

  v2 = *(_DWORD *)(STACK[0x238] + 56);
  *(_DWORD *)(STACK[0x238] + 56) = v2 + 1;
  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * ((1948 * (v2 - 733061818 < ((35 * (v0 ^ 0x477)) ^ 0xFFFFFF76))) ^ (v0 - 999)))
                            - 12))();
}

void sub_10006E258(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void (*a24)(uint64_t),uint64_t a25,uint64_t a26)
{
  int v26;
  int v27;
  uint64_t v28;

  *(_DWORD *)(v28 - 192) = (v26 - 2024873223) ^ (69008221
                                               * ((((v28 - 192) | 0x54517644) - ((v28 - 192) & 0x54517644)) ^ 0x87F3244E));
  sub_100074CEC((_DWORD *)(v28 - 192));
  *(_QWORD *)(v28 - 184) = a26;
  *(_QWORD *)(v28 - 168) = a25;
  *(_DWORD *)(v28 - 160) = (v26 + 883) ^ (((v28 - 192 - 2 * ((v28 - 192) & 0x9BD09A5) + 163383717) ^ 0xEE882BCD) * v27);
  LOBYTE(STACK[0x1970]) = ((v28 + 64 - 2 * ((v28 + 64) & 0xA5) - 91) ^ 0xCD) * v27 + 0x80;
  a24(v28 - 192);
  JUMPOUT(0x100065EF4);
}

uint64_t sub_10006E31C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,int a47,int a48)
{
  int v48;
  unsigned int v49;
  uint64_t v50;

  return (*(uint64_t (**)(void))(v50
                              + 8
                              * ((1390
                                * ((LODWORD(STACK[0x4E8]) ^ v48) != a48
                                                                  - 1683336269
                                                                  + ((67 * (v49 ^ 0x3A3) - 1105) | 0x451))) ^ v49)))();
}

void sub_10006E370()
{
  int v0;

  LODWORD(STACK[0x4CC]) = v0 - 135;
  JUMPOUT(0x10006E164);
}

uint64_t sub_10006E380@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8 * ((21 * (((a1 == v2) ^ (v1 + 108)) & 1)) | (v1 + 365)))
                            - 4))();
}

uint64_t sub_10006E3BC@<X0>(int a1@<W1>, char a2@<W8>)
{
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((4083 * ((a2 & 0x18) == a1 - 807 + a1 - 829 - 2300)) ^ a1)) - 8))();
}

uint64_t sub_10006E3F4@<X0>(uint64_t a1@<X0>, int a2@<W8>)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;

  *(_QWORD *)(a1 - 7 + (v3 + v2 + v4 - v5)) = *(_QWORD *)(v7 - 7 + (v3 + v2 + v4 - v5));
  return ((uint64_t (*)(void))(*(_QWORD *)(v8
                                        + 8
                                        * ((237 * (((((v6 - 1061) | 0x400) - 1132) & a2) - v5 != 8)) ^ ((v6 - 1061) | 0x400)))
                            - (((((v6 - 1061) | 0x400) - 836) | 0x44u) ^ 0x16CLL)))();
}

void sub_10006E460()
{
  JUMPOUT(0x10006E434);
}

uint64_t sub_10006E468@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3 + 8 * ((((v1 ^ 0x517) - 904) * (a1 != v2)) ^ v1)) - 12))();
}

void sub_10006E494(unint64_t a1)
{
  int v1;

  STACK[0x318] = a1;
  LODWORD(STACK[0x51C]) = v1;
  JUMPOUT(0x10006E4B0);
}

void sub_10006E56C()
{
  JUMPOUT(0x10006E530);
}

uint64_t sub_10006E574()
{
  int v0;
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;

  v3 = ((uint64_t (*)(void))STACK[0x230])();
  LODWORD(STACK[0x5A0]) = v0;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v1
                                                      + 8
                                                      * ((461
                                                        * (v0 == ((v2 - 1724976185) & 0x66D10DFF ^ 0x1D30BE00)
                                                               + v2
                                                               + 455)) ^ v2))
                                          - 12))(v3);
}

#error "10006F020: call analysis failed (funcsize=120)"

uint64_t sub_10006E5FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(unint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v5 + 8 * ((1815 * (STACK[0x3B0] != 0)) ^ (v4 - 597)))
                                                                                       - 4))(STACK[0x3B0], a2, a3, a4, 3805275455);
}

uint64_t sub_10006E634(uint64_t a1)
{
  int v1;
  int v2;
  uint64_t v3;
  uint64_t v4;

  *(_BYTE *)(a1 + (v2 - 1560111156)) = *(_BYTE *)(v3 + (v2 - 1560111156));
  return (*(uint64_t (**)(void))(v4 + 8 * (((v2 != 1560111156) * (((2 * v1) ^ 0x860) - 121)) ^ (v1 - 530))))();
}

uint64_t sub_10006E680()
{
  char v0;
  uint64_t v1;
  int v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((13 * ((v0 & 1) == ((5 * (v2 ^ 0x432)) ^ 0x145))) ^ (v2 + 914)))
                            - 4))();
}

uint64_t sub_10006E6BC@<X0>(int a1@<W8>)
{
  uint64_t v1;
  int v2;
  unsigned int v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * (((a1 ^ 0x14C) * ((v2 ^ v3) > 0x200)) ^ a1))
                            - (a1 + 814)
                            + 1135))();
}

uint64_t sub_10006E700@<X0>(int a1@<W8>)
{
  int v1;
  int v2;
  int v3;
  uint64_t v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * ((673 * ((a1 ^ 0x140u) * v3 + 4 == v2 + v1)) | a1 ^ 9)) - 4))();
}

uint64_t sub_10006E74C@<X0>(int a1@<W8>)
{
  int v1;
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  int v5;
  uint64_t v6;
  int v7;
  unint64_t v8;
  int v9;
  void (*v10)(uint64_t);
  int v11;
  int v12;
  unsigned int v13;
  unint64_t v14;
  void (*v15)(uint64_t);
  int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  void (*v20)(uint64_t);
  unsigned int v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  int v25;
  unsigned int v26;
  unint64_t v27;
  int v28;
  unint64_t v29;

  v7 = (a1 - 252) | 0x423;
  v2[31] = 0xE2E16C805CF9DD2;
  v2[32] = v2 + 33;
  v2[65] = 0xE2E16C805CF9DD2;
  v2[66] = v2 + 67;
  STACK[0x2A0] = (unint64_t)v2 + 0x2DB44D49A49B0236;
  v2[99] = 0xE2E16C805CF9DD2;
  v2[100] = v2 + 101;
  STACK[0x2B0] = (unint64_t)v2 + 0x2DB44D49A49B0346;
  v2[133] = 0xE2E16C805CF9DD2;
  v2[134] = v2 + 135;
  STACK[0x2B8] = (unint64_t)v2 + 0x2DB44D49A49B0456;
  v2[167] = 0xE2E16C805CF9DD2;
  v2[168] = v2 + 169;
  STACK[0x2C0] = (unint64_t)v2 + 0x2DB44D49A49B0566;
  v8 = STACK[0x318] + 4;
  STACK[0x290] = v8;
  LODWORD(STACK[0x2A8]) = v1;
  LODWORD(STACK[0x2E8]) = 2 * v5;
  LODWORD(STACK[0x2D0]) = a1 + 1009;
  v9 = 460628867 * ((v6 - 956244809 - 2 * ((v6 - 192) & 0xC700DD77)) ^ 0x8B965F0A);
  *(_DWORD *)(v6 - 192) = a1 + 1009 + v9;
  *(_DWORD *)(v6 - 184) = ((v5 ^ 0x8B4252D9) + 2142224360 + ((2 * v5) & 0x2CE5D87E ^ 0x2861584C)) ^ v9;
  *(_QWORD *)(v6 - 176) = v8;
  *(_QWORD *)(v6 - 168) = (char *)v2 + 0x2DB44D49A49B0126;
  v10 = (void (*)(uint64_t))((char *)*(&off_100180420 + (a1 ^ 0x165)) - 4);
  v10(v6 - 192);
  v11 = 460628867 * ((2 * ((v6 - 192) & 0x5BD9D9B8) - (v6 - 192) + 606479941) ^ 0x68B0A438);
  v12 = STACK[0x2D0];
  v13 = ((STACK[0x2E8] & 0xFECFDC5E ^ 0x3A415C4C) + (v5 ^ v7 ^ 0x625754BA) - 1766146568) ^ v11;
  *(_DWORD *)(v6 - 192) = LODWORD(STACK[0x2D0]) + v11;
  *(_DWORD *)(v6 - 184) = v13;
  v14 = STACK[0x290] + v3;
  STACK[0x290] = v14;
  *(_QWORD *)(v6 - 176) = v14;
  *(_QWORD *)(v6 - 168) = STACK[0x2A0];
  v10(v6 - 192);
  v15 = v10;
  LODWORD(v10) = STACK[0x2E8];
  v16 = 460628867 * ((-931669370 - ((v6 - 192) | 0xC877DA86) + ((v6 - 192) | 0x37882579)) ^ 0x7B1EA704);
  *(_DWORD *)(v6 - 184) = ((v5 ^ 0x42C250D9) - 1238385176 + (STACK[0x2E8] & 0xBFE5DC7E ^ 0x3A615C4C)) ^ v16;
  *(_DWORD *)(v6 - 192) = v12 + v16;
  v17 = STACK[0x290] + v3;
  STACK[0x2A0] = v17;
  v18 = STACK[0x2B0];
  *(_QWORD *)(v6 - 176) = v17;
  *(_QWORD *)(v6 - 168) = v18;
  v19 = v3;
  STACK[0x280] = v3;
  v20 = v15;
  v15(v6 - 192);
  v21 = (v5 ^ 0xAB0E4019) + 1608756520 + (v10 & 0x6C7DFDFE ^ 0x28617DCC);
  v22 = 460628867 * ((v6 + 1630206759 - 2 * ((v6 - 192) & 0x612AFBE7)) ^ 0x2DBC799A);
  LODWORD(v10) = STACK[0x2D0];
  *(_DWORD *)(v6 - 192) = LODWORD(STACK[0x2D0]) + v22;
  *(_DWORD *)(v6 - 184) = v21 ^ v22;
  v23 = STACK[0x2A0] + v19;
  v24 = STACK[0x2B8];
  *(_QWORD *)(v6 - 176) = v23;
  *(_QWORD *)(v6 - 168) = v24;
  v20(v6 - 192);
  v25 = 460628867 * ((((v6 - 192) | 0x37D75E9E) - (v6 - 192) + ((v6 - 192) & 0xC828A160)) ^ 0x7B41DCE3);
  v26 = ((v5 ^ 0xAA5F0191) + 1588784304 + (STACK[0x2E8] & 0x6EDF7EEE ^ 0x2A417CCC)) ^ v25;
  *(_DWORD *)(v6 - 192) = (_DWORD)v10 + v25;
  *(_DWORD *)(v6 - 184) = v26;
  v27 = STACK[0x2C0];
  *(_QWORD *)(v6 - 176) = v23 + STACK[0x280];
  *(_QWORD *)(v6 - 168) = v27;
  v20(v6 - 192);
  v28 = STACK[0x2A8];
  v29 = STACK[0x318];
  STACK[0x368] = LODWORD(STACK[0x2A8]) + ((2 * v7) ^ 0xE5Au) - 1528693274;
  return ((uint64_t (*)(unint64_t))(*(_QWORD *)(v4
                                                               + 8
                                                               * ((43 * (v28 + ((2 * v7) ^ 0xE5A) == 1528693274)) ^ (v7 - 874)))
                                                   - 12))(v29);
}

uint64_t sub_10006EBE0()
{
  int v0;
  uint64_t v1;

  ((void (*)(void))STACK[0x230])();
  return ((uint64_t (*)(void))(*(_QWORD *)(v1 + 8 * ((1815 * (STACK[0x3B0] != 0)) ^ (v0 - 597))) - 4))();
}

uint64_t sub_10006EC28()
{
  int v0;
  int v1;
  uint64_t v2;
  int v3;
  uint64_t v4;

  v3 = v0;
  v4 = ((uint64_t (*)(void))STACK[0x230])();
  STACK[0x528] -= 16;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v2
                                                      + 8
                                                      * (int)(((v3 == 489733862)
                                                             * ((v1 + 1099583943) & 0xBE75AFFF ^ 0x725)) ^ (v1 + 537)))
                                          - 4))(v4);
}

uint64_t sub_10006EC9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  int v69;

  v67 = 235795823 * ((((v66 - 192) | 0x56014207) + (~(v66 - 192) | 0xA9FEBDF8)) ^ 0xC2AC0B5F);
  *(_DWORD *)(v66 - 152) = v65 - v67 - 47;
  *(_DWORD *)(v66 - 148) = v67 ^ 0x3FD7AD00;
  *(_QWORD *)(v66 - 144) = 0;
  *(_QWORD *)(v66 - 136) = a60;
  *(_QWORD *)(v66 - 192) = v63;
  *(_QWORD *)(v66 - 184) = 0;
  *(_QWORD *)(v66 - 160) = a44;
  *(_QWORD *)(v66 - 176) = a63;
  v68 = ((uint64_t (*)(uint64_t))((char *)*(&off_100180420 + v65 - 1590) - 4))(v66 - 192);
  v69 = *(_DWORD *)(v66 - 168);
  LODWORD(STACK[0x5A4]) = v69;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v64
                                                      + 8
                                                      * ((182 * (((v65 + 69) ^ (v69 == 489733862)) & 1)) ^ v65))
                                          - (v65 - 455)
                                          + 1135))(v68);
}

void sub_10006ED84()
{
  JUMPOUT(0x10006EDACLL);
}

void sub_10006EF5C()
{
  JUMPOUT(0x10006EFACLL);
}

uint64_t sub_10006F024()
{
  unint64_t v0;
  unsigned int v1;
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;

  STACK[0x2E8] = v0;
  v5 = STACK[0x324];
  *(_DWORD *)(STACK[0x5C8] + ((v5 + v1) & 0xFFFFFFFC)) = v3;
  v6 = ((v4 + 178) ^ 0x521) + v5;
  LODWORD(STACK[0x324]) = v6;
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v2
                                                      + 8 * ((227 * (v6 + ((v4 - 1139) ^ v1) < 0x40)) ^ (v4 + 178)))
                                          - 8))(95);
}

uint64_t sub_100070794@<X0>(int a1@<W0>, uint64_t a2@<X8>)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  uint64_t v8;
  int v9;
  int v10;
  int v11;
  int v12;
  unint64_t v13;

  v10 = v7 + v4;
  v11 = *(_DWORD *)(a2 + 4 * (v10 - 8)) ^ *(_DWORD *)(a2 + 4 * (v10 - 3));
  v12 = *(_DWORD *)(a2 + 4 * (v10 - 16)) ^ *(_DWORD *)(a2 + 4 * (v10 - 14)) ^ (v11 + v9 - (v5 & (2 * v11)));
  HIDWORD(v13) = v12 ^ (v9 + (v2 ^ v6) * a1 - 855);
  LODWORD(v13) = v12;
  *(_DWORD *)(a2 + 4 * (v3 + v7)) = (v13 >> 31) + v9 - (v5 & (2 * (v13 >> 31)));
  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * ((124 * ((v3 + 1 + v7) > 0x4F)) ^ v2)) - 8))();
}

uint64_t sub_100070828()
{
  int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8 * ((105 * ((v1 + 745234000) < 0x14)) ^ (83 * (v0 ^ 0x35D))))
                            - 12))();
}

void sub_100070918()
{
  JUMPOUT(0x100070860);
}

uint64_t sub_100070930(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  int v5;
  uint64_t v6;

  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * ((874 * ((a4 + 1 + v5) > 0x27)) ^ v4)) - 8))();
}

uint64_t sub_1000709F4(uint64_t a1, int a2, uint64_t a3)
{
  int v3;
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v5 + 8 * ((459 * ((a2 + 1 + v4) > 0x3B)) ^ v3))
                                          - 8))(a3);
}

uint64_t sub_100070ABC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  int v5;
  int v6;
  uint64_t v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * ((161 * ((a5 + 1 + v6) > 0x4F)) ^ v5)) - 8))();
}

void sub_100070B90(int a1)
{
  int v1;
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  LODWORD(STACK[0x448]) = v1;
  LODWORD(STACK[0x44C]) = v4;
  LODWORD(STACK[0x4EC]) = v2;
  LODWORD(STACK[0x45C]) = v3;
  LODWORD(STACK[0x424]) = v5;
  LODWORD(STACK[0x324]) = v6 + 80;
  v8 = (*(_DWORD *)(STACK[0x5B8] - 0x73F39308AC2F35F7) ^ v7) + (v5 ^ v7);
  *(_DWORD *)(STACK[0x5B8] - 0x73F39308AC2F35F7) = v8 + v7 - (a1 & (2 * v8));
  JUMPOUT(0x100070BE8);
}

uint64_t sub_100070CD4(uint64_t a1)
{
  uint64_t v1;
  int v2;
  unint64_t v3;
  int v4;
  unint64_t v6;

  v3 = STACK[0x3D0];
  v4 = *(unsigned __int8 *)(STACK[0x3D0] - 0x73F39308AC2F35EFLL) ^ 0xE;
  if (v4 == 2)
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v1
                                                                                            + 8
                                                                                            * ((102
                                                                                              * (*(_DWORD *)(v3 - 0x73F39308AC2F35F3) != 1763403438)) ^ (v2 - 466)))
                                                                                - (v2 + 190)
                                                                                + 1325))(a1, 97, 46, 203, 3488707127);
  if (v4 == 1)
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v1
                                                                                   + 8
                                                                                   * ((26
                                                                                     * (*(_DWORD *)(v3
                                                                                                  - 0x73F39308AC2F35F3) == (LODWORD(STACK[0x278]) ^ 0x691B6386))) ^ (v2 + 859)))
                                                                       - 12))(a1, 97, 46, 203);
  v6 = STACK[0x2B0];
  STACK[0x400] = 91;
  *(_BYTE *)(v3 - 0x73F39308AC2F35F4) = (v6 ^ 0xBA) * (v6 + 17);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v1
                                                                                 + 8
                                                                                 * ((((v2 - 96) ^ (STACK[0x400] == 0)) & 1 | (2 * (((v2 - 96) ^ (STACK[0x400] == 0)) & 1))) ^ (v2 - 626)))
                                                                     - 8))(a1, 97, 46, 203);
}

void sub_1000715E4()
{
  JUMPOUT(0x1000715A0);
}

uint64_t sub_1000715EC()
{
  return ((uint64_t (*)(void))STACK[0x560])();
}

uint64_t sub_100071624()
{
  uint64_t v0;
  int v1;
  int v2;
  unsigned int v3;
  int v4;

  *(_DWORD *)(STACK[0x238] + 52) = ((((LODWORD(STACK[0x59C]) ^ v3) + (v1 ^ v3)) % 0x2710) ^ 0x5FBAFDDF)
                                 - 1529893184
                                 + (((((LODWORD(STACK[0x59C]) ^ v3) + (v1 ^ v3)) % 0x2710) << ((v2 - 117) & 0xB3 ^ 0xB3)) & 0x7BBE);
  v4 = STACK[0x5A4];
  STACK[0x528] -= 1616;
  LODWORD(STACK[0x56C]) = v4;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((1882 * (v4 == v3)) ^ (v2 - 705))) - 12))();
}

uint64_t sub_1000716D4@<X0>(int a1@<W8>)
{
  _DWORD *v1;
  uint64_t v2;

  *v1 = STACK[0x54C];
  v1[85] = STACK[0x464];
  v1[86] = STACK[0x398];
  v1[87] = STACK[0x47C];
  v1[88] = STACK[0x46C];
  return ((uint64_t (*)(void))(*(_QWORD *)(v2
                                        + 8
                                        * (((((a1 - 113) ^ (STACK[0x3C0] == 0)) & 1)
                                          * ((a1 - 1041720127) & 0x3E1765FF ^ 0x47F)) | (((a1 - 1041720127) & 0x3E1765FF)
                                                                                       - 818)))
                            - 8))();
}

uint64_t sub_100071758()
{
  uint64_t v0;
  int v1;

  STACK[0x528] -= 1616;
  LODWORD(STACK[0x56C]) = -489691695;
  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * (((((v1 - 50) ^ (STACK[0x3C0] == 0)) & 1) * (v1 ^ 0x47F)) | (v1 - 818)))
                            - 8))();
}

uint64_t sub_1000717BC@<X0>(uint64_t a1@<X1>, int a2@<W8>, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,unsigned int *a55,uint64_t (*a56)(_QWORD, uint64_t, _QWORD))
{
  uint64_t v56;
  int v57;
  uint64_t v58;

  v57 = a2 - 73;
  v58 = a56(*a55, a1, LODWORD(STACK[0x48C]));
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v56
                                                      + 8
                                                      * (((LODWORD(STACK[0x56C]) != 489733862) * ((v57 + 101) ^ 0x371)) ^ v57))
                                          - 8))(v58);
}

void sub_10007184C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  char *v10;

  v10 = (char *)&a9 + v9 - 0x611D9C9E8D6D765;
  STACK[0x2A8] = (unint64_t)(v10 + 2048);
  STACK[0x2B0] = (unint64_t)(v10 + 2176);
  STACK[0x2E8] = (unint64_t)v10;
  STACK[0x2B8] = (unint64_t)(v10 + 2304);
  LODWORD(STACK[0x2E0]) = 1466563369;
  JUMPOUT(0x100065728);
}

uint64_t sub_1000718B4@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v4 = (v2 - 1434);
  v5 = ((2 * (_QWORD)&STACK[0x368]) & 0xFDFF6FED5F7E1F80)
     + 0x67FF6DEDFDC9F7FELL
     + ((unint64_t)&STACK[0x368] ^ 0xFEFFB7F6AFBF0EE4 ^ v4);
  v6 = a2 - 1;
  STACK[0x368] = v6;
  *(_BYTE *)(a1 + v6) = ((v5 + 60) ^ 0xBA) * (v5 + 77);
  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (int)(((STACK[0x368] != 0) * (((v4 + 782279633) & 0xD15F5F7F) + 811)) ^ v4))
                            - 12))();
}

void sub_10007195C()
{
  JUMPOUT(0x100071918);
}

uint64_t sub_100071964()
{
  uint64_t v0;
  int v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0
                                        + 8
                                        * (((((v1 - 50) ^ (STACK[0x3C0] == 0)) & 1) * (v1 ^ 0x47F)) | (v1 - 818)))
                            - 8))();
}

void sub_1000719A8(uint64_t a1)
{
  __asm { BR              X8 }
}

void sub_100071ADC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  char v7;
  int v8;
  uint64_t v10;
  int v11;
  _BOOL4 v13;

  v11 = **(unsigned __int8 **)(v10 + 80) - (**(unsigned __int8 **)(a4 + 176) ^ (104 - v7));
  v13 = (v11 ^ 0x3FFFF7B7) + ((2 * v11) & 0x7FFFEF6E) - 4857856 == v8 && a7 != 4067136724;
  __asm { BR              X15 }
}

uint64_t sub_100072BDC@<X0>(int a1@<W0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;

  *(_BYTE *)(v3 + (a2 - 1156305090)) = *(_BYTE *)(a3 + (a2 - 1156305090));
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * ((1755 * (a2 - 1 == v4)) ^ (v5 + a1 + 132))) - 4))();
}

void sub_100072C24(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  BOOL v6;
  int v9;

  if (a3)
    v6 = a4 == 0;
  else
    v6 = 1;
  v9 = !v6 && a5 != 0 && a6 != 0;
  __asm { BR              X8 }
}

uint64_t sub_100072CBC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,unsigned int a22)
{
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;

  a22 = 1178560073
      * ((-68329684 - (&a21 ^ 0xA429BDE0 | 0xFBED5F2C) + (&a21 ^ 0xA429BDE0 | 0x412A0D3)) ^ 0x470E3F5B)
      - 1501685844;
  v25 = sub_100074AF8(&a21);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v23 + 8 * ((1458 * (a21 == v22)) ^ v24)) - 4))(v25);
}

uint64_t sub_100072D60(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,unint64_t *a21,unsigned int a22,int a23)
{
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  a22 = (831981571 * ((&a21 & 0xC67EF54C | ~(&a21 | 0xC67EF54C)) ^ 0xA020DA97)) ^ 0x87;
  a21 = &STACK[0x82D647BA4E6A001];
  sub_1000344DC((uint64_t)&a21);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)(v23 + 8 * ((4 * (a23 != 489733862)) | 0x2B1u)) - 4))(v24, v25, v26, v27, v28, v29, v30, v31, a9, a10, a11, a12, a13);
}

uint64_t sub_100072E2C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, int *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,unsigned int a24)
{
  _DWORD *v24;
  uint64_t v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v30 = 69008221 * ((&a21 & 0x60EEFFDA | ~(&a21 | 0x60EEFFDA)) ^ 0x4CB3522F);
  HIDWORD(a22) = v30 + v29 + 525;
  a24 = v30 ^ ((v26 ^ 0x5EEF8FFF) - 1376550983 + ((2 * v26) & 0xBDDF1FFE));
  a23 = a16;
  a21 = v25;
  ((void (*)(uint64_t *))(*(_QWORD *)(v27 + 8 * (int)(v29 - 456)) - 8))(&a21);
  v31 = 1224239923 * ((25684038 - (&a21 | 0x187E846) + (&a21 | 0xFE7817B9)) ^ 0xCCBEA6E);
  LODWORD(a21) = *v24 - v31 - 283258579 - ((2 * *v24) & 0xDE3BA25A);
  LODWORD(a23) = (v29 + 431) ^ v31;
  a22 = a16;
  sub_10004A21C((uint64_t)&a21);
  v32 = *a13;
  v33 = (*a13 << (63 * (v29 ^ 0xFE) + 76)) & 0xDE3BA25A;
  v34 = 1224239923 * ((((2 * &a21) | 0xC43AEF80) - &a21 + 501385280) ^ 0x10AE8A17);
  LODWORD(a23) = (v29 + 431) ^ v34;
  a22 = a16;
  LODWORD(a21) = v32 - v34 - 283258579 - v33;
  sub_10004A21C((uint64_t)&a21);
  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _DWORD *, uint64_t, int *, uint64_t, uint64_t))(*(_QWORD *)(v28 + 8 * ((1388 * (HIDWORD(a21) == 489733862)) ^ v29)) - 8))(v35, v36, v37, v38, v39, v40, v41, v42, a9, a10, v24, a12, a13, a14, a15);
}

uint64_t sub_100072FF8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,int a21,int a22,int a23,uint64_t a24,unint64_t *a25,int a26)
{
  int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  uint64_t v30;

  v29 = 1224239923 * ((419254032 - (&a21 | 0x18FD4F10) + (&a21 | 0xE702B0EF)) ^ 0x15B14D38);
  a21 = v29 ^ 0x12B68929;
  a22 = (v28 + 368399676) ^ v29;
  a24 = a16;
  a25 = &STACK[0x72F2C1D3322B8828];
  a23 = v29 ^ 0x15A744B0;
  v30 = sub_100074BB8((uint64_t)&a21);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v27
                                                      + 8
                                                      * (((a26 == (((v28 + 267) | 0x16) ^ (v26 - 246)))
                                                        * (9 * (v28 ^ 0x1B8) - 30)) ^ v28))
                                          - 8))(v30);
}

uint64_t sub_1000730D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unint64_t *a17, uint64_t a18, uint64_t a19, uint64_t a20,unint64_t *a21,unint64_t *a22,unint64_t *a23,unint64_t *a24)
{
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  a23 = &STACK[0x20BA795F69D3FFD];
  a24 = a17;
  a22 = &STACK[0x7F1325F673F67EA7];
  LODWORD(a21) = v24
               - 231789580
               - 2078219279 * (((&a21 | 0x4113E74D) + (~&a21 | 0xBEEC18B2)) ^ 0x9BE97138);
  sub_1000751F8((uint64_t)&a21);
  LODWORD(a21) = v24 - 231789580 - 2078219279 * (&a21 ^ 0xDAFA9674);
  a23 = &STACK[0x20BA795F69D400D];
  a24 = a17;
  a22 = &STACK[0x7F1325F673F67E87];
  sub_1000751F8((uint64_t)&a21);
  LODWORD(a23) = v24
               - 944348131 * ((((2 * &a21) | 0xA35E252C) - &a21 - 1370428054) ^ 0xF2B6B6D8)
               - 272;
  a21 = &STACK[0x20BA795F69D3FDD];
  a22 = a17;
  ((void (*)(unint64_t **))(*(_QWORD *)(v25 + 8 * (int)(v24 - 556)) - 8))(&a21);
  LODWORD(a22) = v24
               - 241568881
               * (((&a21 | 0xF5D823CD) - &a21 + (&a21 & 0xA27DC30)) ^ 0x23C9278F)
               - 208;
  a21 = a17;
  v27 = sub_10005A5D8((uint64_t)&a21);
  return ((uint64_t (*)(uint64_t))(*(_QWORD *)(v26 + 8 * ((1256 * (HIDWORD(a22) == 489733862)) | v24))
                                          - ((3 * (v24 ^ 0x3B1)) ^ 0x1FDLL)))(v27);
}

uint64_t sub_10007329C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, int a14, int a15)
{
  int v15;
  unsigned int v16;
  uint64_t v17;

  return ((uint64_t (*)(void))(*(_QWORD *)(v17 + 8 * ((1330 * (a15 == ((89 * (v16 ^ 0x319)) ^ (v15 - 789)))) ^ v16))
                            - 8))();
}

uint64_t sub_1000732E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, int a18, int a19)
{
  unsigned int v19;
  int v20;
  uint64_t v21;
  int v22;

  v22 = (a19 ^ v20) - (((v19 ^ 0x1F5) - 384928848) & (2 * (a19 ^ v20))) - 192463815;
  return (*(uint64_t (**)(void))(v21
                              + 8
                              * ((87
                                * (((2 * v22) & 0xDFBCBFFE ^ 0xC90C3872) + (v22 ^ 0x1B5963C6) + 1513619417 != 1242980312)) ^ v19)))();
}

uint64_t sub_100073380(uint64_t a1, uint64_t a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  uint64_t v6;

  return (*(uint64_t (**)(uint64_t))(v6
                                            + 8
                                            * ((38
                                              * (((a4 + a3 + ((a6 + 2077901815) & 0x6BE5B6EF ^ 0x7BE1A004) < 8) ^ (a6 - 1)) & 1)) ^ a6)))(2487222567);
}

uint64_t sub_1000733E4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  return ((uint64_t (*)(void))(*(_QWORD *)(v8
                                        + 8
                                        * ((a6 - 391989540) & 0x1D4C35 | ((unint64_t)(v6 - v7) > 0x1F) | (2 * ((unint64_t)(v6 - v7) > 0x1F))))
                            - 8))();
}

uint64_t sub_100073438(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  int v5;
  uint64_t v6;

  return ((uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, _QWORD, uint64_t))(*(_QWORD *)(v6 + 8 * (int)(((((a1 + v5 + 90) | 0x50) ^ 0xE28) * (a2 > 0x1F)) ^ (a1 + v5 + 1745)))
                                                                                               + 1807745025
                                                                                               - (((_DWORD)a1
                                                                                                 + v5
                                                                                                 + 2076785001) & 0xEFF6C56F)))(a1, a2, a3, a4, a5, 0, 270639104);
}

uint64_t sub_1000734A0(int a1, int a2, int a3, int a4, uint64_t a5, uint64_t a6, int a7)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  int8x16_t v13;
  uint64_t v14;
  uint64_t v15;
  int8x16_t v16;

  v12 = a4 + a3 + a7;
  v13.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v13.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v14 = v7 + v12;
  v15 = v9 + v12;
  v16 = veorq_s8(*(int8x16_t *)(v14 - 31), v13);
  *(int8x16_t *)(v15 - 15) = veorq_s8(*(int8x16_t *)(v14 - 15), v13);
  *(int8x16_t *)(v15 - 31) = v16;
  return ((uint64_t (*)(void))(*(_QWORD *)(v10
                                        + 8
                                        * ((((a2 & 0xFFFFFFE0) == 32) * (v8 ^ (v11 + 1699) ^ 0x344)) ^ (a1 + v8 + 341)))
                            - 12))();
}

void sub_10007350C()
{
  JUMPOUT(0x1000734B8);
}

uint64_t sub_100073518(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  int v6;
  uint64_t v7;

  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8
                                             * ((((((v6 - 1753233639) ^ (a2 == a6)) & 1) == 0) * (v6 - 1593)) ^ v6))
                            - 4))();
}

uint64_t sub_100073560(uint64_t a1, char a2)
{
  int v2;
  uint64_t v3;
  int v4;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * ((483 * ((a2 & 0x18) != ((v4 + ((v2 + 187809098) & 0xF4CE3DDE) - 470) ^ v4))) ^ (v2 - 1470)))
                            - 12))();
}

uint64_t sub_1000735B4(uint64_t a1, int a2, int a3, int a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  *(int8x8_t *)(v9 - 7 + (a4 + a3 + a7 - a6)) = veor_s8(*(int8x8_t *)(v8 - 7 + (a4 + a3 + a7 - a6)), (int8x8_t)0xFEFEFEFEFEFEFEFELL);
  return ((uint64_t (*)(void))(*(_QWORD *)(v10
                                        + 8
                                        * (((2 * (a6 - (a2 & 0xFFFFFFF8) == -8)) | (32 * (a6 - (a2 & 0xFFFFFFF8) == -8))) ^ a8))
                            - ((a8 - 231) ^ 0xE3)))();
}

void sub_100073618()
{
  JUMPOUT(0x1000735E8);
}

uint64_t sub_100073624(uint64_t a1, int a2, int a3)
{
  int v3;
  uint64_t v4;
  int v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v4 + 8 * (((a3 ^ (v5 + 229) ^ (v5 + 449)) * (a2 == v3)) ^ a3))
                            - (a3 + 979)
                            + 1206))();
}

uint64_t sub_10007365C@<X0>(int a1@<W0>, int a2@<W8>)
{
  int v2;
  uint64_t v3;
  int v4;
  uint64_t v5;
  int v6;
  uint64_t v7;

  *(_BYTE *)(v5 + (v4 + a2)) = *(_BYTE *)(v3 + (v4 + a2)) ^ 0xFE;
  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * ((29 * (((v6 + a1 + 918) ^ 0xFFFFFB3D) + v4 != v2)) ^ (v6 + a1)))
                            - 12))();
}

uint64_t sub_1000736A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, int a20,int a21)
{
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;

  *v29 = v28;
  v31 = (a21 ^ 0x1D30BEE6) + v24 - (((a21 ^ 0x1D30BEE6) << ((2 * a8) ^ 0x85)) & (v26 + 1310));
  return ((uint64_t (*)(void))(*(_QWORD *)(v30 + 8 * (((v22 & (2 * v31) ^ v23) + (v31 ^ v27) + v25 != v21) ^ a8)) - 12))();
}

uint64_t sub_10007370C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, int a8)
{
  int v8;
  int v9;
  uint64_t v10;

  return ((uint64_t (*)(void))(*(_QWORD *)(v10
                                        + 8 * ((680 * (v9 + v8 + (a8 ^ 0x94u) + 270639135 - 1140 > 7)) | a8 ^ 0x94))
                            - 12))();
}

uint64_t sub_100073758(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  int v7;
  uint64_t v8;

  return ((uint64_t (*)(void))(*(_QWORD *)(v8 + 8 * (v7 ^ (238 * ((unint64_t)(v6 - a6) > 0x1F)))) - 12))();
}

uint64_t sub_100073798()
{
  unsigned int v0;
  int v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((v1 - 448) ^ (63 * (v0 < 0x20))))
                            - (((v1 - 70839631) & 0x6FF8E8FDu)
                             - 1807744344)
                            + 677))();
}

uint64_t sub_1000737EC@<X0>(int a1@<W0>, uint64_t a2@<X5>, int a3@<W8>)
{
  uint64_t v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  int v8;
  int8x16_t v9;
  uint64_t v10;
  int8x16_t v11;
  int8x16_t v12;
  uint64_t v13;

  v9.i64[0] = 0xFEFEFEFEFEFEFEFELL;
  v9.i64[1] = 0xFEFEFEFEFEFEFEFELL;
  v10 = v4 + (v6 ^ (v8 + 1218) ^ (a3 + 1214));
  v11 = *(int8x16_t *)(v3 + v10 - 15);
  v12 = *(int8x16_t *)(v3 + v10 - 31);
  v13 = a2 + v10;
  *(int8x16_t *)(v13 - 15) = veorq_s8(v11, v9);
  *(int8x16_t *)(v13 - 31) = veorq_s8(v12, v9);
  return (*(uint64_t (**)(void))(v7 + 8 * ((1194 * ((v5 & 0xFFFFFFE0) == 32)) ^ (a1 + v6 + 512))))();
}

void sub_100073854()
{
  JUMPOUT(0x100073808);
}

uint64_t sub_100073860(uint64_t a1, uint64_t a2, int a3)
{
  int v3;
  int v4;
  uint64_t v5;

  return ((uint64_t (*)(void))(*(_QWORD *)(v5 + 8 * (((((a3 - 665) | 0x80) ^ 0xE2D) * (v3 != v4)) ^ a3)) - 12))();
}

uint64_t sub_100073890(int a1)
{
  char v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v2 + 8 * ((((5 * (a1 ^ 0x220)) ^ 0x5DB) * ((v1 & 0x18) == 0)) ^ a1))
                            - 7 * (a1 ^ 0x20Au)
                            + 1133))();
}

uint64_t sub_1000738D8@<X0>(uint64_t a1@<X5>, int a2@<W8>)
{
  uint64_t v2;
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  _BOOL4 v8;

  *(int8x8_t *)(a1 - 7 + (v3 + a2 - v5)) = veor_s8(*(int8x8_t *)(v2 - 7 + (v3 + a2 - v5)), (int8x8_t)0xFEFEFEFEFEFEFEFELL);
  v8 = v5 + ((v6 - 685) | 0x456) - 1102 == (v4 & 0xFFFFFFF8);
  return ((uint64_t (*)(void))(*(_QWORD *)(v7 + 8 * ((v8 | (2 * v8)) ^ v6)) - 8))();
}

uint64_t sub_100073934(int a1, int a2)
{
  int v2;
  uint64_t v3;

  return ((uint64_t (*)(void))(*(_QWORD *)(v3
                                        + 8
                                        * (((((a2 - 1995464992) & 0x76F05FDF) + ((a2 - 82) | 0x71) - 1783) * (v2 == a1)) ^ a2))
                            - 12))();
}

uint64_t sub_100073980@<X0>(uint64_t a1@<X5>, int a2@<W8>)
{
  int v2;
  uint64_t v3;
  int v4;
  int v5;
  uint64_t v6;

  *(_BYTE *)(a1 + (v5 + a2)) = *(_BYTE *)(v3 + (v5 + a2)) ^ 0xFE;
  return ((uint64_t (*)(void))(*(_QWORD *)(v6 + 8 * ((267 * (v5 - 1 == v2 + 395 * (v4 ^ 0x477) - 790)) ^ v4)) - 8))();
}

uint64_t sub_1000739CC()
{
  int v0;
  int v1;
  int v2;
  void (*v3)(unsigned int *);
  unsigned int v4;
  _DWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;

  *v6 = v0;
  v4 = (v1 + 436028577) & 0xE602BAFD;
  v10 = v8;
  v9 = (v1 - 638) ^ (69008221
                   * (((&v9 | 0x90C46521) - &v9 + (&v9 & 0x6F3B9AD8)) ^ 0x4366372B));
  v3(&v9);
  v10 = v7;
  v9 = (v4 - 541) ^ (69008221
                   * ((-128049727 - (&v9 | 0xF85E1DC1) + (&v9 | 0x7A1E23E)) ^ 0xD403B034));
  v3(&v9);
  return v2 ^ 0x1D30BEE6u;
}

void sub_100073AF0(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v5;

  v1 = *(_DWORD *)(a1 + 4) - 3804331 * ((2 * (a1 & 0x5C5A643E) - a1 - 1549427775) ^ 0xDD70BE37);
  v2 = *(_QWORD *)(a1 + 8);
  v5 = v1
     - 460628867 * ((-4722230 - (&v3 | 0xFFB7F1CA) + (&v3 | 0x480E35)) ^ 0x4CDE8C48)
     + 675;
  v3 = v2;
  sub_10002F264((uint64_t)&v3);
  __asm { BR              X9 }
}

uint64_t sub_100073C4C@<X0>(uint64_t a1@<X8>)
{
  int v1;
  unsigned int v2;
  int v3;
  int v4;
  unsigned int v5;
  _BOOL4 v6;

  v5 = (((v4 + v3) >> 4) & 0x75959AE ^ 0x7485824) + (((v4 + v3) >> 5) ^ 0xCC19D0CD);
  v6 = v5 + 506828023 < v2 - 371047986;
  if (v5 < 0xCBACACD7 != v2 > ((v1 - 1044051373) & 0x3E3AF64Fu) + 371046442)
    v6 = v2 > ((v1 - 1044051373) & 0x3E3AF64Fu) + 371046442;
  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * ((v6 * (v1 - 1125)) ^ v1)) - 8))();
}

uint64_t sub_100073CFC@<X0>(uint64_t a1@<X8>)
{
  char v1;
  int v2;

  return (*(uint64_t (**)(void))(a1 + 8 * (v2 ^ (((v1 & 0x1F) == 8) | (8 * ((v1 & 0x1F) == 8))))))();
}

uint64_t sub_100073D2C@<X0>(uint64_t a1@<X8>)
{
  int v1;
  int v2;
  int v3;
  _DWORD *v4;
  uint64_t v5;
  int v6;
  int v7;
  int v8;
  _BOOL4 v9;

  v6 = v1 + 1040184320;
  v7 = (v3 - 62) | 4;
  if (*v4 + 1909582136 < (v7 ^ 0x205))
    v6 = -715567698 - v1;
  *v4 = *v4 - 162308311 + v6;
  v8 = v2 - 1091837004;
  v9 = v8 < 1933522653;
  **(_DWORD **)(v5 - 0x2DB44D49A49B0026) = *(_DWORD *)(*(_QWORD *)(v5 - 0x2DB44D49A49B0026) + 4 * (v1 + 877876009));
  if (v8 < 1933522653)
    v9 = v8 > -213960994;
  return ((uint64_t (*)(void))(*(_QWORD *)(a1 + 8 * ((58 * v9) | v7)) - 8))();
}

void sub_100073E20()
{
  JUMPOUT(0x100073DD0);
}

void sub_100073E28()
{
  _DWORD *v0;

  *v0 = 237901512;
}

void sub_100074054(uint64_t a1)
{
  int v1;
  uint64_t v2;

  v1 = *(_DWORD *)(a1 + 8) ^ (235795823 * (((a1 | 0x87E968F1) - (a1 & 0x87E968F1)) ^ 0x134421A8));
  v2 = *(_QWORD *)a1;
  ((void (*)(_QWORD, void (*)()))*(&off_100180420 + (v1 ^ 0x562)))(*(&off_100180420 + (v1 ^ 0x5F3)), sub_1000746B0);
  __asm { BR              X11 }
}

uint64_t sub_100074118@<X0>(unsigned int a1@<W8>)
{
  uint64_t v1;
  uint64_t v2;

  return ((uint64_t (*)(void))(*(_QWORD *)(v1
                                        + 8
                                        * (int)((1845 * (**(_QWORD **)(v2 + 8 * (int)(a1 ^ 0x26C)) != 0)) ^ a1))
                            - (a1 ^ 0x2BBLL)))();
}

uint64_t sub_100074158()
{
  int v0;
  uint64_t v1;
  uint64_t v2;

  return (*(uint64_t (**)(uint64_t))(v2 + 8 * (v0 - 548)))(v1);
}

void sub_100074184(uint64_t a1, uint64_t a2)
{
  __asm { BR              X10 }
}

uint64_t sub_1000741E4()
{
  uint64_t v0;
  int v1;

  return ((uint64_t (*)(void))(*(_QWORD *)(v0 + 8 * ((1120 * (v1 != 1528691550)) ^ 0x39Bu)) - 12))();
}

uint64_t sub_100074210@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  unsigned int v3;
  int v4;
  uint64_t v5;
  unsigned int v6;
  _DWORD v8[2];
  uint64_t v9;
  uint64_t v10;
  int v11;

  v4 = (__PAIR64__(v3, **(unsigned __int8 **)(a2 + 8)) - 1) >> 32;
  *(_DWORD *)(*(_QWORD *)(a1 + 96) + 800) = 97492434;
  *(_DWORD *)(*(_QWORD *)(a1 + 96) + 804) = 237901512;
  *(_QWORD *)(*(_QWORD *)(a1 + 96) + 808) = *(_QWORD *)(a1 + 96) + 816;
  v5 = *(_QWORD *)(a2 + 8) + (*(_DWORD *)(a2 + 4) - v4);
  v6 = 831981571 * (((v8 | 0xE5A776CE) - v8 + (v8 & 0x1A588930)) ^ 0x7C06A6EA);
  v9 = *(_QWORD *)(a1 + 96) + 0x2DB44D49A49B034ELL;
  v10 = v5;
  v8[0] = (v4 - 1518483780) ^ v6;
  v8[1] = v6 + 1606;
  ((void (*)(_DWORD *))(*(_QWORD *)(a3 + 1056) - 4))(v8);
  return v11 ^ 0x8305C2D5;
}

void sub_10007434C()
{
  unint64_t v0;
  _BYTE v1[8];
  unsigned int v2;
  unsigned int v3;
  char *v4;

  v0 = (unint64_t)&v1[qword_1001A6C08 ^ qword_1001A6C68];
  qword_1001A6C68 = (45734839 * v0) ^ 0xA77260646F1BC58ALL;
  qword_1001A6C08 = 45734839 * (v0 ^ 0xA77260646F1BC58ALL);
  v3 = (3804331
      * (((&v2 | 0x175DD214) - &v2 + (&v2 & 0xE8A22DE8)) ^ 0x6988F7E2)) ^ 0x1EC;
  v4 = (char *)*(&off_100180420
               + ((-73 * ((qword_1001A6C08 + qword_1001A6C68) ^ 0x8A)) ^ byte_100161B20[byte_10015DEA0[(-73 * ((qword_1001A6C08 + qword_1001A6C68) ^ 0x8A))] ^ 0x1B])
               - 178)
     - 4;
  sub_10005A80C((uint64_t)&v2);
  v4 = (char *)*(&off_100180420
               + ((-73 * ((qword_1001A6C08 + qword_1001A6C68) ^ 0x8A)) ^ byte_100161A20[byte_10015DDA0[(-73 * ((qword_1001A6C08 + qword_1001A6C68) ^ 0x8A))] ^ 0x7A])
               + 76)
     - 4;
  v3 = (3804331 * ((1141020232 - (&v2 | 0x44029648) + (&v2 | 0xBBFD69B7)) ^ 0xC5284C41)) ^ 0x1EC;
  sub_10005A80C((uint64_t)&v2);
  v2 = 895 - 1178560073 * ((((2 * &v2) | 0x784A44C) - &v2 + 2084416986) ^ 0x64F7704E);
  LOBYTE(v3) = (73 * ((((2 * &v2) | 0x4C) - &v2 - 38) ^ 0x4E)) ^ 0x7F;
  sub_100048284(&v2);
}

uint64_t sub_100074584(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a1 + 64) = *(_QWORD *)(a2 + 8);
  return 0;
}

uint64_t sub_10007459C(uint64_t result)
{
  uint64_t v1;
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;
  int v6;
  int v7;
  _DWORD *v8;

  v1 = 235795823 * (result ^ 0x8B0BAFE94AD4959);
  v2 = *(_QWORD *)(result + 32) ^ v1;
  v3 = *(_QWORD *)(result + 24) + v1;
  v4 = v2 > v3;
  v5 = v2 == v3;
  v6 = v4;
  if (((*(_DWORD *)(result + 12) ^ v1) & 1) != 0)
    v7 = v6;
  else
    v7 = v5;
  if (v7)
    v8 = (_DWORD *)result;
  else
    v8 = (_DWORD *)(result + 8);
  *(_DWORD *)(result + 4) = (*v8 + v1) ^ (*(_DWORD *)(result + 20) + v1);
  return result;
}

uint64_t sub_10007460C(uint64_t result)
{
  unint64_t v1;
  int v2;
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;
  int v9;
  _BOOL4 v10;
  _BOOL4 v11;

  v1 = 69008221
     * (((result | 0xD11098B7B4482233) - (result | 0x2EEF67484BB7DDCCLL) + 0x2EEF67484BB7DDCCLL) ^ 0x838CDE5467EA7039);
  v2 = *(_DWORD *)(result + 28) - v1;
  v3 = *(_QWORD *)(result + 16);
  v4 = v3 + v1;
  v5 = *(_QWORD *)(result + 32);
  v6 = v5 + v1;
  v7 = *(_DWORD *)(result + 24) + v1;
  v8 = *(_DWORD *)(result + 4) ^ v1;
  v9 = *(_DWORD *)(result + 8) - v1;
  v10 = v3 == v5;
  v11 = v4 > v6;
  if ((v8 & 1) != 0)
    v10 = v11;
  if (!v10)
    v2 = v7;
  *(_DWORD *)result = v2 ^ v9;
  return result;
}

void sub_1000746B0()
{
  uint64_t v0;
  uint64_t v1;
  _BYTE v2[4];
  int v3;
  uint64_t v4;

  v0 = (qword_1001A6C08 ^ qword_1001A6C18) - (_QWORD)&v1;
  qword_1001A6C18 = (45734839 * v0) ^ 0xA77260646F1BC58ALL;
  qword_1001A6C08 = 45734839 * (v0 ^ 0xA77260646F1BC58ALL);
  v4 = (uint64_t)*(&off_100180420
                + ((-73 * ((-73 * v0) ^ qword_1001A6C08)) ^ byte_100161D20[byte_10015E0A0[(-73 * ((-73 * v0) ^ qword_1001A6C08))] ^ 0xC9])
                + 97);
  v3 = (3804331 * ((v2 + 117650343 - 2 * ((unint64_t)v2 & 0x70333A7)) ^ 0x79D61651)) ^ 0x1EC;
  sub_10005A80C((uint64_t)v2);
}

uint64_t sub_1000747D8(uint64_t a1, uint64_t a2)
{
  *(_BYTE *)(a1 + 88) = 76;
  *(_DWORD *)(a1 + 72) = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 8);
  return 0;
}

uint64_t sub_1000747F8(uint64_t a1)
{
  int v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD v5[2];
  unsigned int v6;

  v1 = *(_DWORD *)a1 + 235795823 * (a1 ^ 0x94AD4959);
  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a1 + 16);
  v6 = v1
     - 460628867 * ((1948750583 - (v5 | 0x742792F7) + (v5 | 0x8BD86D08)) ^ 0xC74EEF75)
     - 2138961703;
  v5[0] = v3;
  v5[1] = v2;
  return ((uint64_t (*)(_QWORD *))((char *)*(&off_100180420 + (int)(v1 & 0x8002009D)) - 8))(v5);
}

uint64_t sub_1000748D8(uint64_t result)
{
  unint64_t v1;
  _DWORD *v2;
  unint64_t v3;
  unint64_t v4;
  BOOL v5;
  _BOOL4 v6;
  int v7;
  int v8;

  v1 = 241568881
     * (((result ^ 0x9C42EF4B24AB98A7)
       - 2 * ((result ^ 0x9C42EF4B24AB98A7) & 0xDC1EF8D758FBB55ELL)
       - 0x23E10728A7044AA2) ^ 0x4F09C315AA4129BBLL);
  v2 = (_DWORD *)(result + 4);
  v3 = *(_QWORD *)(result + 16) - v1;
  v4 = *(_QWORD *)(result + 32) - v1;
  v5 = (uint64_t)v4 < (uint64_t)v3;
  v6 = v4 < v3;
  v7 = v5;
  if (((*(_DWORD *)(result + 40)
       - 241568881
       * (((result ^ 0x24AB98A7) - 2 * ((result ^ 0x24AB98A7) & 0x58FBB55E) + 1492890974) ^ 0xAA4129BB)) & 1) != 0)
    v8 = v7;
  else
    v8 = v6;
  if (v8)
    v2 = (_DWORD *)result;
  *(_DWORD *)(result + 24) = *(_DWORD *)(result + 44) ^ (241568881
                                                       * (((result ^ 0x24AB98A7)
                                                         - 2 * ((result ^ 0x24AB98A7) & 0x58FBB55E)
                                                         + 1492890974) ^ 0xAA4129BB)) ^ *v2 ^ (241568881
                                                                                             * (((result ^ 0x24AB98A7)
                                                                                               - 2
                                                                                               * ((result ^ 0x24AB98A7) & 0x58FBB55E)
                                                                                               + 1492890974) ^ 0xAA4129BB));
  return result;
}

uint64_t sub_100074978(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  unsigned int v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;

  v2 = 268847287 * (((a1 | 0x9AE06DE0) - (a1 & 0x9AE06DE0)) ^ 0x654A7CC8);
  v3 = *(_QWORD *)(a1 + 48);
  v4 = *(_QWORD *)a1;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 32);
  v7 = 772674559 * (*(_DWORD *)(a1 + 24) + v2) + 2076312804;
  v8 = *(_DWORD *)(a1 + 40) - 1695027331 + v2;
  v9 = 235795823
     * (((&v11 | 0x5FD02389) - &v11 + (&v11 & 0xA02FDC70)) ^ 0xCB7D6AD0);
  v16 = v9 ^ (v8 + 1817);
  v11 = v6;
  v12 = v9 + (v7 ^ 0xFBFEEFE9) + ((2 * v7) & 0xF7FDDFD2) + 2113929152;
  v17 = v4;
  v13 = v5;
  v14 = v3;
  result = ((uint64_t (*)(uint64_t *))((char *)*(&off_100180420 + v8) - 8))(&v11);
  *(_DWORD *)(a1 + 8) = v15;
  return result;
}

uint64_t sub_100074AE0(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 24) = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a2 + 8);
  return 0;
}

uint64_t sub_100074AF8(int *a1)
{
  unsigned int v2;
  uint64_t result;
  int v4;

  v2 = a1[1] - 1178560073 * (((a1 | 0xB64875FC) - (a1 & 0xB64875FC)) ^ 0x517D5794);
  result = ((uint64_t (*)(char *, char *))*(&off_100180420 + (int)(v2 ^ 0xA67E174C)))((char *)*(&off_100180420 + (int)(v2 ^ 0xA67E17FA)) - 8, (char *)*(&off_100180420 + (int)(v2 ^ 0xA67E17E7)) - 4);
  v4 = *(_DWORD *)*(&off_100180420 + (int)(v2 + 1501685931));
  if ((_DWORD)result)
    v4 = -489692072;
  *a1 = v4;
  return result;
}

uint64_t sub_100074BB8(uint64_t a1)
{
  int v2;
  int v3;
  int v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t result;
  int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  uint64_t v13;
  int v14;

  v2 = 1224239923 * ((-2 - ((a1 | 0xB4CFA43B) + (~(_DWORD)a1 | 0x4B305BC4))) ^ 0xB983A613);
  v3 = *(_DWORD *)(a1 + 4) ^ v2;
  v4 = *(_DWORD *)a1 ^ v2;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = v2 ^ *(_DWORD *)(a1 + 8) ^ 0x129A7B41;
  v3 -= 368400157;
  v7 = 1224239923 * ((((2 * &v9) | 0xD9CF7000) - &v9 + 320358400) ^ 0x1E5445D7);
  v10 = *(_QWORD *)(a1 + 24);
  v13 = v5;
  v14 = v7 ^ (v3 + 1119);
  v11 = v7 ^ (v4 + 1369382578);
  v12 = v6 - v7;
  result = ((uint64_t (*)(int *))*(&off_100180420 + v3))(&v9);
  *(_DWORD *)(a1 + 32) = v9;
  return result;
}

void sub_100074CEC(_DWORD *a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;

  v1 = *a1 ^ (69008221 * ((((2 * (_DWORD)a1) | 0xE6169F4E) - (_DWORD)a1 + 217362521) ^ 0x20A91DAD));
  v2 = *(_QWORD *)((char *)*(&off_100180420 + (int)(v1 ^ 0x874EE3C1)) - 4);
  v4 = (235795823 * (((&v3 | 0x234F2E8E) - (&v3 & 0x234F2E8E)) ^ 0xB7E267D7)) ^ (v1 + 2024874493);
  v3 = v2;
  sub_100074054((uint64_t)&v3);
}

_BYTE *sub_100074DE0(_BYTE *result, char a2, unint64_t a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;

  v3 = -(int)result & 7;
  if (v3 > a3)
    LODWORD(v3) = a3;
  switch((int)v3)
  {
    case 1:
      goto LABEL_10;
    case 2:
      goto LABEL_9;
    case 3:
      goto LABEL_8;
    case 4:
      goto LABEL_7;
    case 5:
      goto LABEL_6;
    case 6:
      goto LABEL_5;
    case 7:
      *result++ = a2;
LABEL_5:
      *result++ = a2;
LABEL_6:
      *result++ = a2;
LABEL_7:
      *result++ = a2;
LABEL_8:
      *result++ = a2;
LABEL_9:
      *result++ = a2;
LABEL_10:
      *result++ = a2;
      break;
    default:
      break;
  }
  v4 = a3 - v3;
  v6 = v4;
  v5 = v4 & 7;
  switch(v6)
  {
    case 0uLL:
      return result;
    case 1uLL:
      goto LABEL_20;
    case 2uLL:
      goto LABEL_19;
    case 3uLL:
      goto LABEL_18;
    case 4uLL:
      goto LABEL_17;
    case 5uLL:
      goto LABEL_16;
    case 6uLL:
      goto LABEL_15;
    case 7uLL:
      *result++ = a2;
LABEL_15:
      *result++ = a2;
LABEL_16:
      *result++ = a2;
LABEL_17:
      *result++ = a2;
LABEL_18:
      *result++ = a2;
LABEL_19:
      *result++ = a2;
LABEL_20:
      *result = a2;
      break;
    default:
      result = (_BYTE *)((uint64_t (*)(void))((char *)&loc_100074E70 + 4 * byte_100159377[(v5 >> 3) & 7]))();
      break;
  }
  return result;
}

uint64_t sub_100074ED4(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a1 + 40) = *(_DWORD *)(a2 + 4);
  *(_QWORD *)(a1 + 48) = *(_QWORD *)(a2 + 8);
  return 0;
}

uint64_t sub_100074EEC(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)a1 = *(_DWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 24);
  return 0;
}

uint64_t sub_100074F04(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v4 = qword_1001A6C08 - qword_1001A6C60 - (_QWORD)&v6;
  qword_1001A6C60 = 45734839 * v4 - 0x354AA8AFC6EBC5ALL;
  qword_1001A6C08 = 45734839 * (v4 ^ 0xA77260646F1BC58ALL);
  v7 = 1038 - 241568881 * (&v7 ^ 0xD6110442);
  v11 = a2;
  v12 = a3;
  v8 = a1;
  v9 = a4;
  ((void (*)(unsigned int *))((char *)*(&off_100180420
                                                 + ((-73 * ((-73 * v4 - 90) ^ 0x8A ^ qword_1001A6C08)) ^ byte_100154380[byte_100161C20[(-73 * ((-73 * v4 - 90) ^ 0x8A ^ qword_1001A6C08))] ^ 0xC3])
                                                 - 120)
                                       - 8))(&v7);
  return v10 ^ 0x1D30BEE6u;
}

uint64_t sub_100075024(uint64_t a1)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unsigned int v9;
  uint64_t result;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;

  v2 = 831981571 * ((a1 + 752367241 - 2 * (a1 & 0x2CD83689)) ^ 0xB579E6AD);
  v3 = *(_DWORD *)a1 + v2;
  v5 = *(_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 16);
  v6 = *(_QWORD *)(a1 + 24);
  v7 = *(_QWORD *)(a1 + 32);
  v8 = *(_DWORD *)(a1 + 44);
  v9 = 1224239923
     * (((&v11 | 0xF2B632B2) - &v11 + (&v11 & 0xD49CD48)) ^ 0x5CF65);
  v17 = v3 + v9 + 504208098;
  v11 = v7;
  v14 = v4;
  v15 = v5;
  v13 = v6;
  v12 = v8 - v2 - v9 - 479430144;
  result = ((uint64_t (*)(uint64_t *))*(&off_100180420 + (int)(v3 ^ 0xE1F2695A)))(&v11);
  *(_DWORD *)(a1 + 4) = v16;
  return result;
}

uint64_t sub_100075158(uint64_t result)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  BOOL v4;
  _BOOL4 v5;
  int v6;
  int v7;
  int v8;

  v1 = 460628867 * ((2 * (result & 0x6088BD7CEA4303EALL) - result - 0x6088BD7CEA4303EBLL) ^ 0xDDE80FED592A7E68);
  v2 = *(_QWORD *)(result + 32) + v1;
  v3 = *(_QWORD *)(result + 24) - v1;
  v4 = v3 >= v2;
  v5 = v3 != v2;
  v6 = v4;
  if (((*(_DWORD *)result ^ (460628867 * ((2 * (result & 0xEA4303EA) - (_DWORD)result + 364706837) ^ 0x592A7E68))) & 1) != 0)
    v7 = v6;
  else
    v7 = v5;
  if (v7)
    v8 = *(_DWORD *)(result + 20) + 460628867 * ((2 * (result & 0xEA4303EA) - result + 364706837) ^ 0x592A7E68);
  else
    v8 = *(_DWORD *)(result + 16) - 460628867 * ((2 * (result & 0xEA4303EA) - result + 364706837) ^ 0x592A7E68);
  *(_DWORD *)(result + 8) = v8 ^ (*(_DWORD *)(result + 12)
                                + 460628867 * ((2 * (result & 0xEA4303EA) - result + 364706837) ^ 0x592A7E68));
  return result;
}

uint64_t sub_1000751F8(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t result;
  _QWORD v8[2];
  int v9;
  unsigned int v10;
  int v11;
  uint64_t v12;

  v3 = *(_QWORD *)(a1 + 16);
  v2 = *(_QWORD *)(a1 + 24);
  v4 = *(_QWORD *)(a1 + 8);
  v5 = 1178560073 * (v8 ^ 0xE7352268);
  v6 = *(_DWORD *)a1 + 2078219279 * ((-2 - ((a1 | 0xC3B1469C) + (~(_DWORD)a1 | 0x3C4EB963))) ^ 0xE6B42F17) + 231788861;
  v9 = v6 - v5 + 380;
  v10 = 856161221 - v5;
  v12 = v2;
  v8[0] = v4;
  v8[1] = v3;
  result = ((uint64_t (*)(_QWORD *))((char *)*(&off_100180420 + v6) - 8))(v8);
  *(_DWORD *)(a1 + 4) = v11;
  return result;
}

void *sub_1000752F8(char **a1, int a2, int a3, int a4, _QWORD *a5, char a6, char a7)
{
  char **v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  size_t v17;
  void *v18;
  void *v19;
  char **v21;

  v13 = a1;
  v21 = 0;
  *a5 = 0;
  if (!a1 && (!sub_10008BFD4(&v21) || (v13 = v21) == 0 || !*((_DWORD *)v21 + 4)))
  {
    fwrite("Err: Finding internal NAND exporter failed for fetch tunnel buffer.\n", 0x44uLL, 1uLL, __stderrp);
LABEL_11:
    v19 = 0;
    goto LABEL_14;
  }
  v14 = a3;
  v15 = sub_10007549C((uint64_t)v13, a2, a3, a4, a7);
  if (!v15)
  {
    fprintf(__stderrp, "failed to get data size for cmd option %d\n", a2);
    goto LABEL_11;
  }
  v16 = v15;
  v17 = (vm_page_size + v15 - 1) / vm_page_size * vm_page_size;
  v18 = malloc_type_valloc(v17, 0x7C7CDE6BuLL);
  v19 = v18;
  if (v18)
  {
    bzero(v18, v17);
    if ((sub_100075560((uint64_t)v13, a2, v14, a4, v19, v17, a6, a7) & 1) != 0)
    {
      *a5 = v16;
    }
    else
    {
      free(v19);
      v19 = 0;
      *a5 = 0;
    }
  }
  else
  {
    fwrite("can't allocate buffer!\n", 0x17uLL, 1uLL, __stderrp);
  }
LABEL_14:
  if (v21)
    sub_10008C11C((uint64_t)v21);
  return v19;
}

uint64_t sub_10007549C(uint64_t a1, int a2, int a3, int a4, char a5)
{
  kern_return_t v7;
  uint64_t result;
  size_t outputStructCnt;
  unsigned int outputStruct;
  _DWORD inputStruct[3];
  uint64_t v12;
  int v13;

  v13 = 0;
  v12 = 0;
  outputStruct = 0;
  inputStruct[0] = a2;
  outputStructCnt = 4;
  inputStruct[2] = a4;
  inputStruct[1] = a3 | 1;
  v7 = IOConnectCallStructMethod(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 28), inputStruct, 0x18uLL, &outputStruct, &outputStructCnt);
  if (v7)
  {
    if ((a5 & 1) == 0)
      fprintf(__stderrp, "Error calling CoreDebugTunnel method! - 0x%X\n", v7);
    return 0;
  }
  else
  {
    result = outputStruct;
    if (!outputStruct && (a5 & 1) == 0)
    {
      fprintf(__stderrp, "SizeOnly for tunnel command 0x%x returned 0\n", a2);
      return outputStruct;
    }
  }
  return result;
}

uint64_t sub_100075560(uint64_t a1, int a2, int a3, int a4, void *outputStruct, size_t a6, char a7, char a8)
{
  uint64_t v9;
  kern_return_t v15;
  size_t v16;
  _DWORD inputStruct[3];
  uint64_t v19;
  int v20;
  size_t outputStructCnt;

  LOBYTE(v9) = a7;
  outputStructCnt = a6;
  v20 = 0;
  v19 = 0;
  while (1)
  {
    inputStruct[0] = a2;
    inputStruct[1] = a3;
    inputStruct[2] = a4;
    v15 = IOConnectCallStructMethod(*(_DWORD *)(a1 + 16), *(_DWORD *)(a1 + 28), inputStruct, 0x18uLL, outputStruct, &outputStructCnt);
    if (v15 != -536870211)
      break;
    if ((v9 & 1) == 0)
      goto LABEL_10;
    if ((a8 & 1) == 0)
      fprintf(__stderrp, "CoreDebugTunnel 0x%x returned kIOReturnNoMemory\n", a2);
    v16 = outputStructCnt;
    outputStructCnt = vm_page_size;
    v9 = 1;
    if (vm_page_size == v16)
      return v9;
  }
  if (!v15)
    return 1;
LABEL_10:
  if ((a8 & 1) == 0)
    fprintf(__stderrp, "Error calling CoreDebugTunnel method! - 0x%X\n", v15);
  return 0;
}

void *sub_100075680(int a1, _QWORD *a2)
{
  return sub_1000752F8(0, a1, 0, 0, a2, 0, 0);
}

void sub_1000756A0(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char __str[1024];

  bzero(__str, 0x400uLL);
  if (!qword_1001A99C0)
  {
    qword_1001A99C0 = (uint64_t)malloc_type_calloc(0x400uLL, 1uLL, 0x100004077774924uLL);
    vsnprintf(__str, 0x400uLL, a1, &a9);
    snprintf((char *)qword_1001A99C0, 0x400uLL, "%s", __str);
  }
}

uint64_t sub_10007576C(uint64_t a1, uint64_t *a2, unsigned int a3)
{
  uint64_t result;
  unsigned int v6;
  int v7;
  uint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t v13;
  uint64_t *v14;
  unsigned int v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  const char *v20;
  uint64_t v21;
  int v22;

  *(_DWORD *)(a1 + 36) = -1;
  if (a3 < 8)
    return 0;
  v6 = a3 >> 3;
  while (2)
  {
    v9 = *a2;
    v8 = a2 + 1;
    v7 = v9;
    v10 = HIDWORD(v9);
    v11 = v6 - 1;
    if (v9 > 0x30000000 || v11 < v10)
    {
      result = 0;
      *(_DWORD *)(a1 + 32) = 0;
      return result;
    }
    v13 = (v7 - 1);
    if (v13 <= 0x47)
      __asm { BR              X10 }
    v17 = (v7 - 73);
    if (v17 <= 0x46)
      __asm { BR              X10 }
    switch(v7)
    {
      case 144:
        v18 = *v8;
        v19 = "numMemExtreme";
        goto LABEL_13;
      case 145:
        v18 = *v8;
        v19 = "maxMemExtremeDuration";
        goto LABEL_13;
      case 146:
        v18 = *v8;
        v19 = "memExtremeDuration";
        goto LABEL_13;
      case 147:
        v18 = *v8;
        v19 = "bandGetsExtreme";
        goto LABEL_13;
      case 148:
        v18 = *v8;
        v19 = "bandGetsLow";
        goto LABEL_13;
      case 149:
        v18 = *v8;
        v19 = "numHostChoke";
        goto LABEL_13;
      case 152:
        v18 = *v8;
        v19 = "AbortSkip_ProgramError";
        goto LABEL_13;
      case 153:
        v18 = *v8;
        v19 = "AbortSkip_ReadErrorOpenBand";
        goto LABEL_13;
      case 154:
        v18 = *v8;
        v19 = "AbortSkip_FailedRebuildingParity";
        goto LABEL_13;
      case 155:
        v18 = *v8;
        v19 = "AbortPad_OpenRefreshBand";
        goto LABEL_13;
      case 156:
        v18 = *v8;
        v19 = "AbortPad_CloseBands";
        goto LABEL_13;
      case 157:
        v18 = *v8;
        v19 = "AbortPad_SetPhoto";
        goto LABEL_13;
      case 158:
        v18 = *v8;
        v19 = "AbortPad_GcNoSource";
        goto LABEL_13;
      case 159:
        v18 = *v8;
        v19 = "AbortPad_Format";
        goto LABEL_13;
      case 160:
        v18 = *v8;
        v19 = "nandDiscoveryDuration";
        goto LABEL_13;
      case 161:
        v18 = *v8;
        v19 = "coreCCEnableDuration";
        goto LABEL_13;
      case 163:
        v18 = *v8;
        v19 = "coreOpenDuration";
        goto LABEL_13;
      case 164:
        v18 = *v8;
        v19 = "coreWritableDuration";
        goto LABEL_13;
      case 165:
        v18 = *v8;
        v19 = "coreClogLoadDuration";
        goto LABEL_13;
      case 167:
        v18 = *v8;
        v19 = "bulkPFail";
        goto LABEL_13;
      case 169:
        v18 = *v8;
        v19 = "bulkRFail";
        goto LABEL_13;
      case 172:
        v18 = *v8;
        v19 = "raidSmartErrors";
        goto LABEL_13;
      case 182:
        v18 = *v8;
        v19 = "internalUeccs";
        goto LABEL_13;
      case 183:
        v18 = *v8;
        v19 = "e2eFail";
        goto LABEL_13;
      case 184:
        v18 = *v8;
        v19 = "TempSensorMax";
        goto LABEL_13;
      case 185:
        v18 = *v8;
        v19 = "TempSensorMin";
        goto LABEL_13;
      case 186:
        v18 = *v8;
        v19 = "powerUpFromDDR";
        goto LABEL_13;
      case 187:
        v18 = *v8;
        v19 = "numMemLow";
        goto LABEL_13;
      case 188:
        v18 = *v8;
        v19 = "maxMemLowDuration";
        goto LABEL_13;
      case 189:
        v18 = *v8;
        v19 = "memLowDuration";
        goto LABEL_13;
      case 190:
        v18 = *v8;
        v19 = "numFences";
        goto LABEL_13;
      case 191:
        v18 = *v8;
        v19 = "hostPassiveIO";
        goto LABEL_13;
      case 192:
        v18 = *v8;
        v19 = "odtsMax";
        goto LABEL_13;
      case 193:
        v18 = *v8;
        v19 = "defragMFromOrphans";
        goto LABEL_13;
      case 194:
        v18 = *v8;
        v19 = "defragMFromFragments";
        goto LABEL_13;
      case 195:
        v18 = *v8;
        v19 = "defragMTime";
        goto LABEL_13;
      case 196:
        v18 = *v8;
        v19 = "defragMMaxTime";
        goto LABEL_13;
      case 197:
        v18 = *v8;
        v19 = "raidFailedLbaMismatch";
        goto LABEL_13;
      case 198:
        v18 = *v8;
        v19 = "numSyscfgWrites";
        goto LABEL_13;
      case 199:
        v18 = *v8;
        v19 = "indmbUnitsXfer";
        goto LABEL_13;
      case 200:
        v18 = *v8;
        v19 = "indmbUnitsCache";
        goto LABEL_13;
      case 201:
        v18 = *v8;
        v19 = "indmbUnitsInd";
        goto LABEL_13;
      case 202:
        v18 = *v8;
        v19 = "wcacheFS_Mbytes";
        goto LABEL_13;
      case 203:
        v18 = *v8;
        v19 = "wcacheDS_Mbytes";
        goto LABEL_13;
      case 204:
        v18 = *v8;
        v19 = "powerOnSeconds";
        goto LABEL_13;
      case 205:
        v18 = *v8;
        v19 = "numUnknownTokenHostRead";
        goto LABEL_13;
      case 206:
        v18 = *v8;
        v19 = "numUnmmapedTokenHostRead";
        goto LABEL_13;
      case 207:
        v20 = "numOfThrottlingEntriesPerLevel";
        v21 = a1;
        v22 = 207;
LABEL_85:
        v14 = v8;
        v15 = 16;
        goto LABEL_12;
      case 208:
        v18 = *v8;
        v19 = "wcacheFS_MbytesMin";
        goto LABEL_13;
      case 209:
        v18 = *v8;
        v19 = "wcacheFS_MbytesMax";
        goto LABEL_13;
      case 210:
        v18 = *v8;
        v19 = "prepareForShutdownFailCounter";
        goto LABEL_13;
      case 211:
        v18 = *v8;
        v19 = "lpsrEntry";
        goto LABEL_13;
      case 212:
        v18 = *v8;
        v19 = "lpsrExit";
        goto LABEL_13;
      case 213:
        v20 = "crcInternalReadFail";
        v21 = a1;
        v22 = 213;
LABEL_23:
        v14 = v8;
        v15 = 8;
        goto LABEL_12;
      case 214:
        v18 = *v8;
        v19 = "wcacheFSEvictCnt";
        goto LABEL_13;
      case 215:
        v18 = *v8;
        v19 = "wcacheFSEvictSize";
        goto LABEL_13;
      case 216:
        v18 = *v8;
        v19 = "wcacheFSWr";
        goto LABEL_13;
      case 217:
        v18 = *v8;
        v19 = "wcacheDSWr";
        goto LABEL_13;
      case 218:
        v20 = "wcacheFSEvictSizeLogDist";
        v21 = a1;
        v22 = 218;
        goto LABEL_11;
      case 219:
        v18 = *v8;
        v19 = "prepareForShutdownTimeoutCounter";
        goto LABEL_13;
      case 220:
        v18 = *v8;
        v19 = "prepareForShutdownCancelCounter";
        goto LABEL_13;
      case 221:
        v18 = *v8;
        v19 = "RD_openBandCount";
        goto LABEL_13;
      case 222:
        v18 = *v8;
        v19 = "RD_openBandNops";
        goto LABEL_13;
      case 223:
        v18 = *v8;
        v19 = "RD_closedBandEvictCount";
LABEL_13:
        v16 = (_QWORD *)a1;
LABEL_14:
        sub_10008BE70(v16, "", v19, v18);
        goto LABEL_15;
      default:
        switch(v7)
        {
          case 224:
            v18 = *v8;
            v19 = "RD_closedBandEvictSectors";
            goto LABEL_13;
          case 225:
            v18 = *v8;
            v19 = "RD_closedBandFragmentCount";
            goto LABEL_13;
          case 226:
            v18 = *v8;
            v19 = "RD_closedBandFragmentSectors";
            goto LABEL_13;
          case 227:
            v20 = "wcacheFSOverWrLogSizeCnts";
            v21 = a1;
            v22 = 227;
            goto LABEL_11;
          case 228:
            v20 = "wcacheFSOverWrSizeByFlow";
            v21 = a1;
            v22 = 228;
            goto LABEL_22;
          case 229:
            v20 = "indmbXferCountTo";
            v21 = a1;
            v22 = 229;
            goto LABEL_20;
          case 230:
            v20 = "indmbAccumulatedTimeBetweenXfers";
            v21 = a1;
            v22 = 230;
LABEL_20:
            v14 = v8;
            v15 = 2;
            goto LABEL_12;
          case 231:
            v18 = *v8;
            v19 = "maxGracefulBootTimeMs";
            goto LABEL_13;
          case 232:
            v18 = *v8;
            v19 = "maxUngracefulBootTimeMs";
            goto LABEL_13;
          case 233:
            v18 = *v8;
            v19 = "averageGracefulBootTimeMs";
            goto LABEL_13;
          case 234:
            v18 = *v8;
            v19 = "averageUngracefulBootTimeMs";
            goto LABEL_13;
          case 235:
            v20 = "gracefulBootTimeLogMs";
            v21 = a1;
            v22 = 235;
            goto LABEL_23;
          case 236:
            v20 = "ungracefulBootTimeLogMs";
            v21 = a1;
            v22 = 236;
            goto LABEL_23;
          case 237:
            v20 = "CalibrationCount";
            v21 = a1;
            v22 = 237;
            goto LABEL_22;
          case 238:
            v18 = *v8;
            v19 = "CalibrationLastTmp";
            goto LABEL_13;
          case 239:
            v18 = *v8;
            v19 = "CalibrationMaxTmp";
            goto LABEL_13;
          case 240:
            v18 = *v8;
            v19 = "CalibrationMinTmp";
            goto LABEL_13;
          case 241:
            v18 = *v8;
            v19 = "ungracefulBootWorstIndicator";
            goto LABEL_13;
          case 242:
            v18 = *v8;
            v19 = "metaMismatchReread";
            goto LABEL_13;
          case 243:
            v18 = *v8;
            v19 = "numS3SleepOps";
            goto LABEL_13;
          case 244:
            v18 = *v8;
            v19 = "odtsCurrent";
            goto LABEL_13;
          case 245:
            v18 = *v8;
            v19 = "prefetchReads";
            goto LABEL_13;
          case 246:
            v18 = *v8;
            v19 = "prefetchHits";
            goto LABEL_13;
          case 247:
            v18 = *v8;
            v19 = "prefetchWritesInvalidation";
            goto LABEL_13;
          case 248:
            v18 = *v8;
            v19 = "indmbUnitsTotal";
            goto LABEL_13;
          case 249:
            v18 = *v8;
            v19 = "selfThrottlingEngage";
            goto LABEL_13;
          case 250:
            v18 = *v8;
            v19 = "selfThrottlingDisengage";
            goto LABEL_13;
          case 252:
            v18 = *v8;
            v19 = "AbortSkip_WlpMode";
            goto LABEL_13;
          case 253:
            v18 = *v8;
            v19 = "hostWritesWlpMode";
            goto LABEL_13;
          case 254:
            v18 = *v8;
            v19 = "numClogDoubleUnc";
            goto LABEL_13;
          case 256:
            v18 = *v8;
            v19 = "AbortPad_WlpMode";
            goto LABEL_13;
          case 257:
            v18 = *v8;
            v19 = "bonfireIntermediateBandErases";
            goto LABEL_13;
          case 258:
            v18 = *v8;
            v19 = "bonfireUserBandErases";
            goto LABEL_13;
          case 259:
            v18 = *v8;
            v19 = "bonfireIntermediateBandProgs";
            goto LABEL_13;
          case 260:
            v18 = *v8;
            v19 = "bonfireUserBandProgs";
            goto LABEL_13;
          case 261:
            v18 = *v8;
            v19 = "bonfireIntermediatePageReads";
            goto LABEL_13;
          case 262:
            v18 = *v8;
            v19 = "bonfireUserPageReads";
            goto LABEL_13;
          case 263:
            v18 = *v8;
            v19 = "refreshUtil00";
            goto LABEL_13;
          case 264:
            v18 = *v8;
            v19 = "failToReadUtil00";
            goto LABEL_13;
          case 265:
            v20 = "readCountHisto";
            v21 = a1;
            v22 = 265;
LABEL_19:
            v14 = v8;
            v15 = 5;
            goto LABEL_12;
          case 266:
            v20 = "readAmpHisto";
            v21 = a1;
            v22 = 266;
            goto LABEL_85;
          case 267:
            v18 = *v8;
            v19 = "totalReadAmp";
            goto LABEL_13;
          case 268:
            v20 = "nvmeModeSelect";
            v21 = a1;
            v22 = 268;
            goto LABEL_22;
          case 269:
            v20 = "numBootBlockRefreshSuccess";
            v21 = a1;
            v22 = 269;
            goto LABEL_23;
          case 270:
            v20 = "numBootBlockRefreshFail";
            v21 = a1;
            v22 = 270;
            goto LABEL_23;
          case 271:
            v18 = *v8;
            v19 = "numUnsupportedAsi";
            goto LABEL_13;
          case 272:
            v18 = *v8;
            v19 = "NumTerminatedProgramSegs";
            goto LABEL_13;
          case 273:
            v18 = *v8;
            v19 = "indParityPagesDrops";
            goto LABEL_13;
          case 274:
            v18 = *v8;
            v19 = "indFlowPrograms";
            goto LABEL_13;
          case 277:
            v20 = "powerBudgetSelect";
            v21 = a1;
            v22 = 277;
LABEL_22:
            v14 = v8;
            v15 = 4;
            goto LABEL_12;
          case 279:
            v18 = *v8;
            v19 = "RxBurnNandWrites";
            goto LABEL_13;
          case 280:
            v20 = "E2EDPErrorCounters";
            v21 = a1;
            v22 = 280;
LABEL_153:
            v14 = v8;
            v15 = 12;
            goto LABEL_12;
          case 281:
            v18 = *v8;
            v19 = "wcacheSectorsMax";
            goto LABEL_13;
          case 282:
            v18 = *v8;
            v19 = "wcacheSectorsMin";
            goto LABEL_13;
          case 283:
            v18 = *v8;
            v19 = "wcacheSectorsCur";
            goto LABEL_13;
          case 284:
            v18 = *v8;
            v19 = "wcacheDS_SectorsMax";
            goto LABEL_13;
          case 285:
            v18 = *v8;
            v19 = "wcacheDS_SectorsMin";
            goto LABEL_13;
          case 286:
            v18 = *v8;
            v19 = "wcacheDS_SectorsCur";
            goto LABEL_13;
          case 287:
            v18 = *v8;
            v19 = "wcacheFS_Reads";
            goto LABEL_13;
          case 288:
            v18 = *v8;
            v19 = "wcacheDS_Reads";
            goto LABEL_13;
          case 289:
            v20 = "mspBootBlockReadFail";
            v21 = a1;
            v22 = 289;
            goto LABEL_155;
          case 290:
            v20 = "mspBootBlockProgFail";
            v21 = a1;
            v22 = 290;
            goto LABEL_155;
          case 291:
            v20 = "mspBootBlockEraseFail";
            v21 = a1;
            v22 = 291;
LABEL_155:
            v14 = v8;
            v15 = 32;
            goto LABEL_12;
          case 292:
            v18 = *v8;
            v19 = "bandsRefreshedOnError";
            goto LABEL_13;
          default:
            switch(v7)
            {
              case 298:
                v20 = "perHostReads";
                v21 = a1;
                v22 = 298;
                goto LABEL_20;
              case 299:
                v20 = "perHostReadXacts";
                v21 = a1;
                v22 = 299;
                goto LABEL_20;
              case 300:
                v20 = "perHostWrites";
                v21 = a1;
                v22 = 300;
                goto LABEL_20;
              case 301:
                v20 = "perHostWriteXacts";
                v21 = a1;
                v22 = 301;
                goto LABEL_20;
              case 302:
                v20 = "perHostNumFlushes";
                v21 = a1;
                v22 = 302;
                goto LABEL_20;
              case 303:
                v20 = "perHostNumFences";
                v21 = a1;
                v22 = 303;
                goto LABEL_20;
              case 304:
                v20 = "commitPadSectorsPerFlow";
                v21 = a1;
                v22 = 304;
                goto LABEL_11;
              case 305:
                v20 = "wcacheDSOverWrLogSizeCnts";
                v21 = a1;
                v22 = 305;
                goto LABEL_11;
              case 306:
                v20 = "wcacheDSOverWrSizeByFlow";
                v21 = a1;
                v22 = 306;
                goto LABEL_22;
              case 307:
                v20 = "CmdRaisePrioiryEvents";
                v21 = a1;
                v22 = 307;
                goto LABEL_11;
              case 308:
                v18 = *v8;
                v19 = "utilNumVerification";
                goto LABEL_13;
              case 309:
                v18 = *v8;
                v19 = "utilRefreshes";
                goto LABEL_13;
              case 310:
                v18 = *v8;
                v19 = "utilBDRErrors";
                goto LABEL_13;
              case 311:
                v18 = *v8;
                v19 = "indBandsPerFlow";
                goto LABEL_13;
              case 312:
                v18 = *v8;
                v19 = "secsPerIndFlow";
                goto LABEL_13;
              case 313:
                v18 = *v8;
                v19 = "indDecodedECC";
                goto LABEL_13;
              case 314:
                v20 = "numBootBlockValidateSuccess";
                v21 = a1;
                v22 = 314;
                goto LABEL_23;
              case 315:
                v20 = "numBootBlockValidateFail";
                v21 = a1;
                v22 = 315;
                goto LABEL_23;
              case 316:
                v20 = "clogPagesFillingPercentage";
                v21 = a1;
                v22 = 316;
                goto LABEL_22;
              case 317:
                v18 = *v8;
                v19 = "bdrCalTimeAccFactor";
                goto LABEL_13;
              case 318:
                v18 = *v8;
                v19 = "bootChainRdError";
                goto LABEL_13;
              case 319:
                v18 = *v8;
                v19 = "bootChainBlankError";
                goto LABEL_13;
              case 320:
                v18 = *v8;
                v19 = "bootChainRefreshError";
                goto LABEL_13;
              case 321:
                v18 = *v8;
                v19 = "bootChainVersionError";
                goto LABEL_13;
              case 322:
                v18 = *v8;
                v19 = "mspBootBlockMismatch";
                goto LABEL_13;
              case 323:
                v18 = *v8;
                v19 = "mspBootBlockMismatchErr";
                goto LABEL_13;
              case 324:
                v20 = "bitflipAddr";
                v21 = a1;
                v22 = 324;
                goto LABEL_19;
              case 325:
                v20 = "bitflipCount";
                v21 = a1;
                v22 = 325;
                goto LABEL_19;
              case 326:
                v20 = "bitflipDupes";
                v21 = a1;
                v22 = 326;
                goto LABEL_19;
              case 327:
                v20 = "bandsMaxTempHisto";
                v21 = a1;
                v22 = 327;
                goto LABEL_217;
              case 328:
                v20 = "bandsMinTempHisto";
                v21 = a1;
                v22 = 328;
                goto LABEL_217;
              case 329:
                v20 = "bandsLifeTimeTempHisto";
                v21 = a1;
                v22 = 329;
                v14 = v8;
                v15 = 30;
                goto LABEL_12;
              case 330:
                v20 = "bandsDeltaTempHisto";
                v21 = a1;
                v22 = 330;
LABEL_217:
                v14 = v8;
                v15 = 22;
                goto LABEL_12;
              case 331:
                v20 = "bandsCrossTempHisto";
                v21 = a1;
                v22 = 331;
                v14 = v8;
                v15 = 45;
                goto LABEL_12;
              case 332:
                v20 = "wcacheWaitLogMs";
                v21 = a1;
                v22 = 332;
                goto LABEL_11;
              case 333:
                v20 = "wcacheDS_segsSortedLogSize";
                v21 = a1;
                v22 = 333;
                goto LABEL_11;
              case 334:
                v18 = *v8;
                v19 = "numFirmwareWrites";
                goto LABEL_13;
              case 335:
                v18 = *v8;
                v19 = "numBisWrites";
                goto LABEL_13;
              case 336:
                v18 = *v8;
                v19 = "numBootChainUpdates";
                goto LABEL_13;
              case 337:
                v18 = *v8;
                v19 = "cntCalTimeWentBackWard";
                goto LABEL_13;
              case 338:
                v18 = *v8;
                v19 = "indBoRecoveries";
                goto LABEL_13;
              case 340:
                v18 = *v8;
                v19 = "numCrossTempUecc";
                goto LABEL_13;
              case 341:
                v18 = *v8;
                v19 = "latencyMonitorError";
                goto LABEL_13;
              case 343:
                v18 = *v8;
                v19 = "utilUeccReads";
                goto LABEL_13;
              case 344:
                v18 = *v8;
                v19 = "numOfAvoidedGCDueToTemp";
                goto LABEL_13;
              case 345:
                v18 = *v8;
                v19 = "forceShutdowns";
                goto LABEL_13;
              case 346:
                v18 = *v8;
                v19 = "gcSlcDestinations";
                goto LABEL_13;
              case 347:
                v18 = *v8;
                v19 = "indReplayExtUsed";
                goto LABEL_13;
              case 348:
                v18 = *v8;
                v19 = "defectsPerPackageOverflow";
                goto LABEL_13;
              case 349:
                v18 = *v8;
                v19 = "RxBurnIntBandsProgrammed";
                goto LABEL_13;
              case 350:
                v18 = *v8;
                v19 = "RxBurnUsrBandsProgrammed";
                goto LABEL_13;
              case 351:
                v18 = *v8;
                v19 = "RxBurnIntNandWrites";
                goto LABEL_13;
              case 352:
                v18 = *v8;
                v19 = "RxBurnUsrNandWrites";
                goto LABEL_13;
              case 353:
                v18 = *v8;
                v19 = "clogLastStripeUeccs";
                goto LABEL_13;
              case 354:
                v18 = *v8;
                v19 = "GC_MidDestSrcSwitchSLC2TLC";
                goto LABEL_13;
              case 355:
                v18 = *v8;
                v19 = "GC_MidDestSrcSwitchTLC2SLC";
                goto LABEL_13;
              case 356:
                v18 = *v8;
                v19 = "nvme_stats_shutdown_count_host0_normal";
                goto LABEL_13;
              case 357:
                v18 = *v8;
                v19 = "nvme_stats_shutdown_count_host1_normal";
                goto LABEL_13;
              case 358:
                v18 = *v8;
                v19 = "nvme_stats_shutdown_count_host0_s2r";
                goto LABEL_13;
              case 359:
                v18 = *v8;
                v19 = "nvme_stats_shutdown_count_host1_s2r";
                goto LABEL_13;
              case 360:
                v20 = "gcPDusterIntrSrcValidityHisto";
                v21 = a1;
                v22 = 360;
                goto LABEL_85;
              case 361:
                v20 = "gcPDusterUserSrcValidityHisto";
                v21 = a1;
                v22 = 361;
                goto LABEL_85;
              case 362:
                v18 = *v8;
                v19 = "raidFailedReadParity";
                goto LABEL_13;
              case 364:
                v18 = *v8;
                v19 = "lhotNumSkipes";
                goto LABEL_13;
              default:
                switch(v7)
                {
                  case 365:
                    v18 = *v8;
                    v19 = "lhotNumIsHotCalls";
                    goto LABEL_13;
                  case 366:
                    v18 = *v8;
                    v19 = "lhotFullLap";
                    goto LABEL_13;
                  case 367:
                    v18 = *v8;
                    v19 = "lhotSkipPrecent";
                    goto LABEL_13;
                  case 368:
                    v18 = *v8;
                    v19 = "eraseSuspendEvents";
                    goto LABEL_13;
                  case 369:
                    v18 = *v8;
                    v19 = "eraseSuspendedStatuses";
                    goto LABEL_13;
                  case 370:
                    v18 = *v8;
                    v19 = "eraseSuspendedBands";
                    goto LABEL_13;
                  case 371:
                    v18 = *v8;
                    v19 = "eraseSuspendSituationsBelowThreshold";
                    goto LABEL_13;
                  case 372:
                    v18 = *v8;
                    v19 = "eraseSuspendSituationsAboveThreshold";
                    goto LABEL_13;
                  case 373:
                    v18 = *v8;
                    v19 = "eraseSuspendReadChainsProcessed";
                    goto LABEL_13;
                  case 374:
                    v18 = *v8;
                    v19 = "bdrLastDoneHr";
                    goto LABEL_13;
                  case 375:
                    v18 = *v8;
                    v19 = "bdrBackupThreshHrs";
                    goto LABEL_13;
                  case 376:
                    v18 = *v8;
                    v19 = "clogPortableProgBufs";
                    goto LABEL_13;
                  case 377:
                    v18 = *v8;
                    v19 = "clogPortableDropBufs";
                    goto LABEL_13;
                  case 378:
                    v18 = *v8;
                    v19 = "clogPortablePadSectors";
                    goto LABEL_13;
                  case 379:
                    v18 = *v8;
                    v19 = "numRetiredBlocks";
                    goto LABEL_13;
                  case 381:
                    v18 = *v8;
                    v19 = "numRefreshOnErrNandRefreshPerf";
                    goto LABEL_13;
                  case 382:
                    v18 = *v8;
                    v19 = "raidReconstructReads";
                    goto LABEL_13;
                  case 383:
                    v18 = *v8;
                    v19 = "gcReadsNoBlog";
                    goto LABEL_13;
                  case 384:
                    v18 = *v8;
                    v19 = "AbortSkip_MPBXReadVerifyClosedBand";
                    goto LABEL_13;
                  case 385:
                    v18 = *v8;
                    v19 = "openBandReadFail";
                    goto LABEL_13;
                  case 386:
                    v18 = *v8;
                    v19 = "AbortSkip_MPBXReadVerifyOpenBand";
                    goto LABEL_13;
                  case 387:
                    v18 = *v8;
                    v19 = "AbortSkip_MBPXFailedRebuildingParity";
                    goto LABEL_13;
                  case 388:
                    v18 = *v8;
                    v19 = "raidSuccessfulPMXReconstructionInternal";
                    goto LABEL_13;
                  case 389:
                    v18 = *v8;
                    v19 = "raidSuccessfulPMXReconstructionHost";
                    goto LABEL_13;
                  case 390:
                    v18 = *v8;
                    v19 = "raidFailedPMXReconstructionInternal";
                    goto LABEL_13;
                  case 391:
                    v18 = *v8;
                    v19 = "raidFailedPMXReconstructionHost";
                    goto LABEL_13;
                  case 392:
                    v18 = *v8;
                    v19 = "raidSuccessfulRMXReconstructionInternal";
                    goto LABEL_13;
                  case 393:
                    v18 = *v8;
                    v19 = "raidSuccessfulRMXReconstructionHost";
                    goto LABEL_13;
                  case 394:
                    v18 = *v8;
                    v19 = "raidFailedRMXReconstructionInternal";
                    goto LABEL_13;
                  case 395:
                    v18 = *v8;
                    v19 = "raidFailedRMXReconstructionHost";
                    goto LABEL_13;
                  case 396:
                    v18 = *v8;
                    v19 = "raidFailedReadParityInternal";
                    goto LABEL_13;
                  case 397:
                    v18 = *v8;
                    v19 = "raidFailedReadQParityInternal";
                    goto LABEL_13;
                  case 398:
                    v18 = *v8;
                    v19 = "raidFailedReadQParity";
                    goto LABEL_13;
                  case 399:
                    v18 = *v8;
                    v19 = "raidFailedReadQCopy";
                    goto LABEL_13;
                  case 400:
                    v18 = *v8;
                    v19 = "raidFailedReconstructionQParity";
                    goto LABEL_13;
                  case 401:
                    v18 = *v8;
                    v19 = "offlineBlocksCnt";
                    goto LABEL_13;
                  case 402:
                    v18 = *v8;
                    v19 = "bork0Revectors";
                    goto LABEL_13;
                  case 403:
                    v18 = *v8;
                    v19 = "raidFailedReadBlog";
                    goto LABEL_13;
                  case 404:
                    v18 = *v8;
                    v19 = "numReliabilityRefreshes";
                    goto LABEL_13;
                  case 405:
                    v18 = *v8;
                    v19 = "raidFailedReadQCopyInternal";
                    goto LABEL_13;
                  case 406:
                    v20 = "raidReconstructSuccessFlow";
                    v21 = a1;
                    v22 = 406;
                    goto LABEL_19;
                  case 407:
                    v20 = "raidReconstructFailFlow";
                    v21 = a1;
                    v22 = 407;
                    goto LABEL_19;
                  case 408:
                    v18 = *v8;
                    v19 = "raidReconstructFailP";
                    goto LABEL_13;
                  case 409:
                    v18 = *v8;
                    v19 = "raidReconstructFailQ";
                    goto LABEL_13;
                  case 410:
                    v18 = *v8;
                    v19 = "raidReconstructFailUECC";
                    goto LABEL_13;
                  case 411:
                    v18 = *v8;
                    v19 = "raidReconstructFailUnsupp";
                    goto LABEL_13;
                  case 412:
                    v18 = *v8;
                    v19 = "raidUECCOpenBand";
                    goto LABEL_13;
                  case 414:
                    v18 = *v8;
                    v19 = "ueccReads";
                    goto LABEL_13;
                  case 416:
                    v18 = *v8;
                    v19 = "raidSuccessfulVerify";
                    goto LABEL_13;
                  case 417:
                    v18 = *v8;
                    v19 = "raidFailedVerify";
                    goto LABEL_13;
                  case 418:
                    v18 = *v8;
                    v19 = "numBandsVerified";
                    goto LABEL_13;
                  case 419:
                    v18 = *v8;
                    v19 = "cache_heads";
                    goto LABEL_13;
                  case 420:
                    v18 = *v8;
                    v19 = "AbortSkip_RMXtoMPBX";
                    goto LABEL_13;
                  case 421:
                    v18 = *v8;
                    v19 = "s3eFwVer";
                    goto LABEL_13;
                  case 422:
                    v18 = *v8;
                    v19 = "readVerifyNative";
                    goto LABEL_13;
                  case 423:
                    v18 = *v8;
                    v19 = "reducedReadVerifyNative";
                    goto LABEL_13;
                  case 424:
                    v18 = *v8;
                    v19 = "readVerifySlc";
                    goto LABEL_13;
                  case 425:
                    v18 = *v8;
                    v19 = "reducedReadVerifySlc";
                    goto LABEL_13;
                  case 426:
                    v18 = *v8;
                    v19 = "RxBurnEvictions";
                    goto LABEL_13;
                  case 427:
                    v18 = *v8;
                    v19 = "directToTLCBands";
                    goto LABEL_13;
                  case 428:
                    v18 = *v8;
                    v19 = "nandDesc";
                    goto LABEL_13;
                  case 429:
                    v18 = *v8;
                    v19 = "fwUpdatesPercentUsed";
                    goto LABEL_13;
                  case 430:
                    v18 = *v8;
                    v19 = "slcPercentUsed";
                    goto LABEL_13;
                  case 431:
                    v18 = *v8;
                    v19 = "percentUsed";
                    goto LABEL_13;
                  default:
                    switch(v7)
                    {
                      case 432:
                        v18 = *v8;
                        v19 = "hostAutoWrites";
                        goto LABEL_13;
                      case 433:
                        v18 = *v8;
                        v19 = "hostAutoWriteXacts";
                        goto LABEL_13;
                      case 434:
                        v18 = *v8;
                        v19 = "gcDestDynamic";
                        goto LABEL_13;
                      case 435:
                        v18 = *v8;
                        v19 = "gcDestStatic";
                        goto LABEL_13;
                      case 436:
                        v18 = *v8;
                        v19 = "gcDestWearlevel";
                        goto LABEL_13;
                      case 437:
                        v18 = *v8;
                        v19 = "gcDestParity";
                        goto LABEL_13;
                      case 438:
                        v18 = *v8;
                        v19 = "AbortSkip_Format";
                        goto LABEL_13;
                      case 440:
                        v18 = *v8;
                        v19 = "raidSLCPadding";
                        goto LABEL_13;
                      case 441:
                        v18 = *v8;
                        v19 = "raidGCBands";
                        goto LABEL_13;
                      case 442:
                        v18 = *v8;
                        v19 = "raidGCSectors";
                        goto LABEL_13;
                      case 443:
                        v18 = *v8;
                        v19 = "raidGCPadding";
                        goto LABEL_13;
                      case 444:
                        v18 = *v8;
                        v19 = "raidSLCBandsPerHostFlow";
                        goto LABEL_13;
                      case 445:
                        v18 = *v8;
                        v19 = "raidSLCSecsPerHostFlow";
                        goto LABEL_13;
                      case 446:
                        v18 = *v8;
                        v19 = "rxBurnMinCycleRuns";
                        goto LABEL_13;
                      case 447:
                        v18 = *v8;
                        v19 = "clogNumFastCxt";
                        goto LABEL_13;
                      case 448:
                        v18 = *v8;
                        v19 = "clogNumRapidReboots";
                        goto LABEL_13;
                      case 449:
                        v18 = *v8;
                        v19 = "clogFastCxtAbvThr";
                        goto LABEL_13;
                      case 450:
                        v18 = *v8;
                        v19 = "rxBurnDiffModeRuns";
                        goto LABEL_13;
                      case 452:
                        v18 = *v8;
                        v19 = "indReadVerifyFail";
                        goto LABEL_13;
                      case 453:
                        v20 = "numOfThrottlingEntriesPerReadLevel";
                        v21 = a1;
                        v22 = 453;
                        goto LABEL_85;
                      case 454:
                        v20 = "numOfThrottlingEntriesPerWriteLevel";
                        v21 = a1;
                        v22 = 454;
                        goto LABEL_85;
                      case 456:
                        v20 = "slcFifoDepth";
                        v21 = a1;
                        v22 = 456;
                        goto LABEL_11;
                      case 457:
                        v18 = *v8;
                        v19 = "wcacheSectorsDirtyIdle";
                        goto LABEL_13;
                      case 458:
                        v18 = *v8;
                        v19 = "wcacheDS_SectorsDirtyIdle";
                        goto LABEL_13;
                      case 459:
                        v18 = *v8;
                        v19 = "wcacheFS_MbytesDirtyIdle";
                        goto LABEL_13;
                      case 460:
                        v20 = "CacheDepthVsThroughput";
                        v21 = a1;
                        v22 = 460;
                        v14 = v8;
                        v15 = 256;
                        goto LABEL_12;
                      case 461:
                        v18 = *v8;
                        v19 = "directToTLCSectors";
                        goto LABEL_13;
                      case 462:
                        v18 = *v8;
                        v19 = "fallbackToWaterfall";
                        goto LABEL_13;
                      case 463:
                        v20 = "balanceProportionBucketsHistogram";
                        v21 = a1;
                        v22 = 463;
LABEL_320:
                        v14 = v8;
                        v15 = 11;
                        goto LABEL_12;
                      case 464:
                        v18 = *v8;
                        v19 = "lockToTlc";
                        goto LABEL_13;
                      case 465:
                        v20 = "burstSizeHistogram";
                        v21 = a1;
                        v22 = 465;
                        goto LABEL_11;
                      case 466:
                        v20 = "qosDirectToTLC";
                        v21 = a1;
                        v22 = 466;
                        goto LABEL_342;
                      case 467:
                        v20 = "maxQosDirectToTLC";
                        v21 = a1;
                        v22 = 467;
                        goto LABEL_22;
                      case 468:
                        v20 = "wcacheDirtyAtFlush";
                        v21 = a1;
                        v22 = 468;
                        goto LABEL_85;
                      case 469:
                        v20 = "raidReconstructSuccessPartition";
                        v21 = a1;
                        v22 = 469;
                        goto LABEL_20;
                      case 470:
                        v20 = "raidReconstructFailPartition";
                        v21 = a1;
                        v22 = 470;
                        goto LABEL_20;
                      case 471:
                        v18 = *v8;
                        v19 = "raidUncleanBootBandFail";
                        goto LABEL_13;
                      case 472:
                        v18 = *v8;
                        v19 = "raidReconstructFailBandFlowHost";
                        goto LABEL_13;
                      case 473:
                        v18 = *v8;
                        v19 = "raidReconstructFailBandFlowGC";
                        goto LABEL_13;
                      case 476:
                        v20 = "raidSuccessfulRecoLbaRange";
                        v21 = a1;
                        v22 = 476;
                        goto LABEL_20;
                      case 477:
                        v20 = "raidFailedRecoLbaRange";
                        v21 = a1;
                        v22 = 477;
                        goto LABEL_20;
                      case 481:
                        v20 = "skinnyBandErases_481";
                        v21 = a1;
                        v22 = 481;
                        goto LABEL_155;
                      case 483:
                        v18 = *v8;
                        v19 = "tlcOverHeatWaterfall";
                        goto LABEL_13;
                      case 484:
                        v18 = *v8;
                        v19 = "skinnyCyclesConvert";
                        goto LABEL_13;
                      case 485:
                        v18 = *v8;
                        v19 = "non_proportional_directToTLCSectors";
                        goto LABEL_13;
                      case 486:
                        v18 = *v8;
                        v19 = "maxFailedFastCxtSync";
                        goto LABEL_13;
                      case 487:
                        v18 = *v8;
                        v19 = "numFormatUserArea";
                        goto LABEL_13;
                      case 488:
                        v18 = *v8;
                        v19 = "clogFastCxtSyncAborted";
                        goto LABEL_13;
                      case 489:
                        v20 = "clogOccupationSectors";
                        v21 = a1;
                        v22 = 489;
                        goto LABEL_19;
                      case 490:
                        v20 = "bdrTmpHist";
                        v21 = a1;
                        v22 = 490;
LABEL_342:
                        v14 = v8;
                        v15 = 64;
                        goto LABEL_12;
                      case 491:
                        v18 = *v8;
                        v19 = "numFWUpdates";
                        goto LABEL_13;
                      case 492:
                        v18 = *v8;
                        v19 = "numClogLoadFails";
                        goto LABEL_13;
                      case 493:
                        v18 = *v8;
                        v19 = "rxBurnNumForcedDiffMode";
                        goto LABEL_13;
                      case 494:
                        v18 = *v8;
                        v19 = "RD_numSaves";
                        goto LABEL_13;
                      case 495:
                        v18 = *v8;
                        v19 = "eanCompressWrites";
                        goto LABEL_13;
                      case 496:
                        v18 = *v8;
                        v19 = "eanHostWrites";
                        goto LABEL_13;
                      case 497:
                        v18 = *v8;
                        v19 = "bandPreErases";
                        goto LABEL_13;
                      case 498:
                        v18 = *v8;
                        v19 = "eanHostUnmaps";
                        goto LABEL_13;
                      case 499:
                        v18 = *v8;
                        v19 = "eanHostFlushes";
                        goto LABEL_13;
                      case 500:
                        v18 = *v8;
                        v19 = "eanFastWrites";
                        goto LABEL_13;
                      case 501:
                        v18 = *v8;
                        v19 = "autowriteDS2FSCollisions";
                        goto LABEL_13;
                      case 502:
                        v18 = *v8;
                        v19 = "autowriteWaitTransferTaskBlocks";
                        goto LABEL_13;
                      case 503:
                        v20 = "avgCycle";
                        v21 = a1;
                        v22 = 503;
                        goto LABEL_20;
                      case 504:
                        v18 = *v8;
                        v19 = "RD_DeferredClearsOverflowCnt";
                        goto LABEL_13;
                      default:
                        switch(v7)
                        {
                          case 505:
                            v18 = *v8;
                            v19 = "maxVerticsInBand";
                            goto LABEL_13;
                          case 506:
                            v18 = *v8;
                            v19 = "numVertics";
                            goto LABEL_13;
                          case 507:
                            v18 = *v8;
                            v19 = "exceededCVertics";
                            goto LABEL_13;
                          case 510:
                            v18 = *v8;
                            v19 = "raidReconstructFailMismatch";
                            goto LABEL_13;
                          case 511:
                            v20 = "mspbootBlockRefreshCnt";
                            v21 = a1;
                            v22 = 511;
                            goto LABEL_155;
                          case 516:
                            v20 = "mspBootBlockRefreshTime";
                            v21 = a1;
                            v22 = 516;
                            goto LABEL_155;
                          case 517:
                            v18 = *v8;
                            v19 = "mspBootBlockCountPerMsp";
                            goto LABEL_13;
                          case 518:
                            v18 = *v8;
                            v19 = "skinnyRevectorSLC";
                            goto LABEL_13;
                          case 519:
                            v18 = *v8;
                            v19 = "skinnyRevectorTLC";
                            goto LABEL_13;
                          case 520:
                            v18 = *v8;
                            v19 = "perfSetupAttempts";
                            goto LABEL_13;
                          case 521:
                            v18 = *v8;
                            v19 = "perfSetupSuccesses";
                            goto LABEL_13;
                          case 522:
                            v18 = *v8;
                            v19 = "perfWriteAttempts";
                            goto LABEL_13;
                          case 523:
                            v18 = *v8;
                            v19 = "perfWriteSuccesses";
                            goto LABEL_13;
                          case 524:
                            v18 = *v8;
                            v19 = "perfReadAttempts";
                            goto LABEL_13;
                          case 525:
                            v18 = *v8;
                            v19 = "perfReadSuccesses";
                            goto LABEL_13;
                          case 526:
                            v18 = *v8;
                            v19 = "perfCleanupAttempts";
                            goto LABEL_13;
                          case 527:
                            v18 = *v8;
                            v19 = "perfCleanupSuccesses";
                            goto LABEL_13;
                          case 530:
                            v18 = *v8;
                            v19 = "firstFailedDieId";
                            goto LABEL_13;
                          case 531:
                            v18 = *v8;
                            v19 = "numDieFailures";
                            goto LABEL_13;
                          case 532:
                            v18 = *v8;
                            v19 = "spareAvailablePercent";
                            goto LABEL_13;
                          case 533:
                            v18 = *v8;
                            v19 = "dataFabricErr";
                            goto LABEL_13;
                          case 534:
                            v18 = *v8;
                            v19 = "downlinkFabricErr";
                            goto LABEL_13;
                          case 535:
                            v18 = *v8;
                            v19 = "prpAccTimeoutErr";
                            goto LABEL_13;
                          case 537:
                            v18 = *v8;
                            v19 = "uplinkFabricErr";
                            goto LABEL_13;
                          case 538:
                            v18 = *v8;
                            v19 = "skinnyBandsGBB";
                            goto LABEL_13;
                          case 539:
                            v18 = *v8;
                            v19 = "AbortPad_GcMustPadBand";
                            goto LABEL_13;
                          case 540:
                            v18 = *v8;
                            v19 = "AbortPad_GcMustPadSkinny";
                            goto LABEL_13;
                          case 541:
                            v18 = *v8;
                            v19 = "bdrHostPingInitial";
                            goto LABEL_13;
                          case 542:
                            v18 = *v8;
                            v19 = "bdrHostPingMoreNeeded";
                            goto LABEL_13;
                          case 543:
                            v18 = *v8;
                            v19 = "bandParityAllocationFailed";
                            goto LABEL_13;
                          case 544:
                            v18 = *v8;
                            v19 = "fastHwBurstToSlc";
                            goto LABEL_13;
                          case 545:
                            v18 = *v8;
                            v19 = "slowHwToTlc";
                            goto LABEL_13;
                          case 546:
                            v20 = "slcDemandBurstSizeDetected";
                            v21 = a1;
                            v22 = 546;
                            goto LABEL_11;
                          case 547:
                            v20 = "slcDemandBurstDur";
                            v21 = a1;
                            v22 = 547;
                            goto LABEL_11;
                          case 548:
                            v18 = *v8;
                            v19 = "fastHwToTlcBurst";
                            goto LABEL_13;
                          case 549:
                            v20 = "slcDemandBurstSizeSlc";
                            v21 = a1;
                            v22 = 549;
                            goto LABEL_11;
                          case 551:
                            v20 = "balanceProportionBucketsHistogramTlc";
                            v21 = a1;
                            v22 = 551;
                            goto LABEL_320;
                          case 553:
                            v18 = *v8;
                            v19 = "slowHwFlushToSlc";
                            goto LABEL_13;
                          case 557:
                            v18 = *v8;
                            v19 = "slowHwToSlc";
                            goto LABEL_13;
                          case 558:
                            v18 = *v8;
                            v19 = "flushNwToSlc";
                            goto LABEL_13;
                          case 559:
                            v18 = *v8;
                            v19 = "flushNwToTlc";
                            goto LABEL_13;
                          case 560:
                            v18 = *v8;
                            v19 = "oslcHw";
                            goto LABEL_13;
                          case 561:
                            v18 = *v8;
                            v19 = "oslcTransitions";
                            goto LABEL_13;
                          case 563:
                            v18 = *v8;
                            v19 = "slcDemandFlushCount";
                            goto LABEL_13;
                          case 564:
                            v18 = *v8;
                            v19 = "slcDemandBurstCount";
                            goto LABEL_13;
                          case 565:
                            v18 = *v8;
                            v19 = "oslcBaseAvgPE";
                            goto LABEL_13;
                          case 566:
                            v18 = *v8;
                            v19 = "raidReconstructFailNoSPBX";
                            goto LABEL_13;
                          case 567:
                            v18 = *v8;
                            v19 = "raidReconstructFailDouble";
                            goto LABEL_13;
                          case 568:
                            v18 = *v8;
                            v19 = "oslcFastWAmpUOnOff";
                            goto LABEL_13;
                          case 569:
                            v18 = *v8;
                            v19 = "oslcSlowWAmpUOnOff";
                            goto LABEL_13;
                          case 570:
                            v18 = *v8;
                            v19 = "raidReconstructFailInvalid";
                            goto LABEL_13;
                          case 572:
                            v18 = *v8;
                            v19 = "oslcLastWAmpUx10";
                            goto LABEL_13;
                          case 573:
                            v18 = *v8;
                            v19 = "raidFailedReadNoBlog";
                            goto LABEL_13;
                          case 574:
                            v18 = *v8;
                            v19 = "raidReconstructFailBlank";
                            goto LABEL_13;
                          case 575:
                            v18 = *v8;
                            v19 = "oslcHotTLCOnOff";
                            goto LABEL_13;
                          case 576:
                            v18 = *v8;
                            v19 = "gcVPackDestinations";
                            goto LABEL_13;
                          case 581:
                            v18 = *v8;
                            v19 = "averageTLCPECycles";
                            goto LABEL_13;
                          case 582:
                            v18 = *v8;
                            v19 = "averageSLCPECycles";
                            goto LABEL_13;
                          case 583:
                            v18 = *v8;
                            v19 = "numAtomicBoots";
                            goto LABEL_13;
                          case 584:
                            v18 = *v8;
                            v19 = "clogMinorMismatch";
                            goto LABEL_13;
                          case 586:
                            v18 = *v8;
                            v19 = "raidExpectedFailRMXReconstructionInternal";
                            goto LABEL_13;
                          case 587:
                            v18 = *v8;
                            v19 = "raidExpectedFailRMXReconstructionHost";
                            goto LABEL_13;
                          case 588:
                            v18 = *v8;
                            v19 = "oslcGCinvalidations";
                            goto LABEL_13;
                          case 589:
                            v18 = *v8;
                            v19 = "oslcGCActivateReason";
                            goto LABEL_13;
                          default:
                            switch(v7)
                            {
                              case 590:
                                v18 = *v8;
                                v19 = "oslcLowCleanBandsUOnOff";
                                goto LABEL_13;
                              case 591:
                                v18 = *v8;
                                v19 = "oslcTooManyGCMustOnOff";
                                goto LABEL_13;
                              case 592:
                                v18 = *v8;
                                v19 = "oslcBaseHostWrites";
                                goto LABEL_13;
                              case 593:
                                v18 = *v8;
                                v19 = "oslcBaseBandErases";
                                goto LABEL_13;
                              case 594:
                                v18 = *v8;
                                v19 = "oslcBdrBands";
                                goto LABEL_13;
                              case 595:
                                v18 = *v8;
                                v19 = "oslcBdrValid";
                                goto LABEL_13;
                              case 596:
                                v18 = *v8;
                                v19 = "unexpectedBlanks";
                                goto LABEL_13;
                              case 597:
                                v18 = *v8;
                                v19 = "unexpectedBlanksOnRV";
                                goto LABEL_13;
                              case 601:
                                v18 = *v8;
                                v19 = "waterfallLockSectors";
                                goto LABEL_13;
                              case 602:
                                v18 = *v8;
                                v19 = "oslcGCActiveWrites";
                                goto LABEL_13;
                              case 603:
                                v18 = *v8;
                                v19 = "chipIdTemperatureSample";
                                goto LABEL_13;
                              case 604:
                                v18 = *v8;
                                v19 = "gcVPackWrites";
                                goto LABEL_13;
                              case 605:
                                v20 = "gcActiveReasons";
                                v21 = a1;
                                v22 = 605;
                                goto LABEL_11;
                              case 606:
                                v18 = *v8;
                                v19 = "eanMaxInitTimeMs";
                                goto LABEL_13;
                              case 607:
                                v18 = *v8;
                                v19 = "eanMinToFirstReadTimeMs";
                                goto LABEL_13;
                              case 608:
                                v18 = *v8;
                                v19 = "skinnyAPGMRetire";
                                goto LABEL_13;
                              case 609:
                                v18 = *v8;
                                v19 = "unexpectedBlanksHost";
                                goto LABEL_13;
                              case 610:
                                v20 = "pcieAerCounters";
                                v21 = a1;
                                v22 = 610;
                                goto LABEL_342;
                              case 611:
                                v18 = *v8;
                                v19 = "fastHwToTlcBalance";
                                goto LABEL_13;
                              case 612:
                                v18 = *v8;
                                v19 = "perfOSLCRuns";
                                goto LABEL_13;
                              case 613:
                                v18 = *v8;
                                v19 = "slcDemandBurstWritesInGC";
                                goto LABEL_13;
                              case 614:
                                v18 = *v8;
                                v19 = "slcDemandBurstWritesInTT";
                                goto LABEL_13;
                              case 615:
                                v18 = *v8;
                                v19 = "slcDemandBurstWritesInNRP";
                                goto LABEL_13;
                              case 616:
                                v18 = *v8;
                                v19 = "perfTotalDmaMb";
                                goto LABEL_13;
                              case 617:
                                v18 = *v8;
                                v19 = "eanAvgInitTimeMs";
                                goto LABEL_13;
                              case 618:
                                v18 = *v8;
                                v19 = "eanAvgToFirstReadTimeMs";
                                goto LABEL_13;
                              case 619:
                                v18 = *v8;
                                v19 = "eanMaxBootReadTimeMs";
                                goto LABEL_13;
                              case 620:
                                v18 = *v8;
                                v19 = "eanAvgBootReadTimeMs";
                                goto LABEL_13;
                              case 621:
                                v20 = "eanBootReadsHist";
                                v21 = a1;
                                v22 = 621;
                                goto LABEL_11;
                              case 622:
                                v18 = *v8;
                                v19 = "maxBgInitTimeMs";
                                goto LABEL_13;
                              case 623:
                                v18 = *v8;
                                v19 = "avgBgInitTimeMs";
                                goto LABEL_13;
                              case 624:
                                v20 = "clogFailReason";
                                v21 = a1;
                                v22 = 624;
                                goto LABEL_85;
                              case 625:
                                v18 = *v8;
                                v19 = "eanMinBootReadMBPerSec";
                                goto LABEL_13;
                              case 626:
                                v18 = *v8;
                                v19 = "eanAvgBootReadMBPerSec";
                                goto LABEL_13;
                              case 627:
                                v18 = *v8;
                                v19 = "minSkinnyPECycles";
                                goto LABEL_13;
                              case 628:
                                v18 = *v8;
                                v19 = "maxSkinnyPECycles";
                                goto LABEL_13;
                              case 629:
                                v18 = *v8;
                                v19 = "averageSkinnyPECycles";
                                goto LABEL_13;
                              case 630:
                                v20 = "raidSuccessfulRecoEAN";
                                v21 = a1;
                                v22 = 630;
                                goto LABEL_463;
                              case 631:
                                v20 = "raidFailedRecoEAN";
                                v21 = a1;
                                v22 = 631;
                                goto LABEL_463;
                              case 632:
                                v20 = "eanFirstReadMode";
                                v21 = a1;
                                v22 = 632;
LABEL_463:
                                v14 = v8;
                                v15 = 6;
                                goto LABEL_12;
                              case 635:
                                v18 = *v8;
                                v19 = "oslcHwGC";
                                goto LABEL_13;
                              case 636:
                                v18 = *v8;
                                v19 = "oslcHwTT";
                                goto LABEL_13;
                              case 637:
                                v18 = *v8;
                                v19 = "oslcHwNRP";
                                goto LABEL_13;
                              case 638:
                                v20 = "oslcDemandBurstSize";
                                v21 = a1;
                                v22 = 638;
                                goto LABEL_11;
                              case 639:
                                v18 = *v8;
                                v19 = "raidReconstructSuccessBandFlowOslc";
                                goto LABEL_13;
                              case 640:
                                v18 = *v8;
                                v19 = "raidReconstructFailBandFlowOslc";
                                goto LABEL_13;
                              case 641:
                                v18 = *v8;
                                v19 = "raidFailSectors";
                                goto LABEL_13;
                              case 642:
                                v18 = *v8;
                                v19 = "eanFailSectors";
                                goto LABEL_13;
                              case 643:
                                v18 = *v8;
                                v19 = "bdrTimeMode";
                                goto LABEL_13;
                              case 644:
                                v18 = *v8;
                                v19 = "raidParityNotSavedP";
                                goto LABEL_13;
                              case 645:
                                v18 = *v8;
                                v19 = "raidParityNotSavedQ";
                                goto LABEL_13;
                              case 646:
                                v18 = *v8;
                                v19 = "raidParityInvalid";
                                goto LABEL_13;
                              case 647:
                                v18 = *v8;
                                v19 = "raidParityUnknown";
                                goto LABEL_13;
                              case 648:
                                v18 = *v8;
                                v19 = "raidParityUnmapped";
                                goto LABEL_13;
                              case 649:
                                v18 = *v8;
                                v19 = "raidParityGCUnc";
                                goto LABEL_13;
                              case 657:
                                v18 = *v8;
                                v19 = "AbortSkip_MPBXProbational";
                                goto LABEL_13;
                              case 659:
                                v18 = *v8;
                                v19 = "raidVerificationReads";
                                goto LABEL_13;
                              case 666:
                                v18 = *v8;
                                v19 = "nofDies";
                                goto LABEL_13;
                              case 671:
                                v18 = *v8;
                                v19 = "skinnyBandsNum";
                                goto LABEL_13;
                              case 672:
                                v18 = *v8;
                                v19 = "skinnyBandsNumDips";
                                goto LABEL_13;
                              case 674:
                                v20 = "oslcNoVotesHw";
                                v21 = a1;
                                v22 = 674;
                                goto LABEL_23;
                              case 675:
                                v18 = *v8;
                                v19 = "totalLbas";
                                goto LABEL_13;
                              case 676:
                                v18 = *v8;
                                v19 = "bdrHostPingExtra";
                                goto LABEL_13;
                              case 677:
                                v18 = *v8;
                                v19 = "magazineInstanceMeta";
                                goto LABEL_13;
                              default:
                                switch(v7)
                                {
                                  case 680:
                                    v20 = "magazineFWVersion";
                                    v21 = a1;
                                    v22 = 680;
                                    goto LABEL_21;
                                  case 681:
                                    v18 = *v8;
                                    v19 = "raidReconstructFailPMXUnsup";
                                    goto LABEL_13;
                                  case 682:
                                    v18 = *v8;
                                    v19 = "raidReconstructFailBMXUnsup";
                                    goto LABEL_13;
                                  case 683:
                                    v18 = *v8;
                                    v19 = "iBootNANDResets";
                                    goto LABEL_13;
                                  case 684:
                                    v18 = *v8;
                                    v19 = "pcieClkreqHighTimeout";
                                    goto LABEL_13;
                                  case 687:
                                    v20 = "cbdrInitSent";
                                    v21 = a1;
                                    v22 = 687;
LABEL_21:
                                    v14 = v8;
                                    v15 = 3;
                                    goto LABEL_12;
                                  case 688:
                                    v18 = *v8;
                                    v19 = "cbdrPauseSent";
                                    goto LABEL_13;
                                  case 689:
                                    v18 = *v8;
                                    v19 = "cbdrResumeSent";
                                    goto LABEL_13;
                                  case 690:
                                    v18 = *v8;
                                    v19 = "cbdrGetResultSent";
                                    goto LABEL_13;
                                  case 691:
                                    v18 = *v8;
                                    v19 = "cbdrEarlyExits";
                                    goto LABEL_13;
                                  case 694:
                                    v20 = "cbdrRefreshGrades";
                                    v21 = a1;
                                    v22 = 694;
                                    goto LABEL_11;
                                  case 695:
                                    v18 = *v8;
                                    v19 = "cbdrNotEnoughReads";
                                    goto LABEL_13;
                                  case 696:
                                    v18 = *v8;
                                    v19 = "cbdrAborts";
                                    goto LABEL_13;
                                  case 697:
                                    v18 = *v8;
                                    v19 = "TurboRaidHostClassifications";
                                    goto LABEL_13;
                                  case 698:
                                    v18 = *v8;
                                    v19 = "TurboRaidInternalClassifications";
                                    goto LABEL_13;
                                  case 699:
                                    v18 = *v8;
                                    v19 = "cbdrFullyDone";
                                    goto LABEL_13;
                                  case 702:
                                    v20 = "vcurve";
                                    v21 = a1;
                                    v22 = 702;
                                    goto LABEL_155;
                                  case 703:
                                    v20 = "injDepth";
                                    v21 = a1;
                                    v22 = 703;
                                    goto LABEL_153;
                                  case 704:
                                    v18 = *v8;
                                    v19 = "logical_disk_occupied_promiles";
                                    goto LABEL_13;
                                  case 711:
                                    v18 = *v8;
                                    v19 = "raidPrevFailedReconstructSkip";
                                    goto LABEL_13;
                                  case 712:
                                    v18 = *v8;
                                    v19 = "TurboRaidSuccessfulHostAuxReads";
                                    goto LABEL_13;
                                  case 713:
                                    v18 = *v8;
                                    v19 = "TurboRaidSuccessfulInternalAuxReads";
                                    goto LABEL_13;
                                  case 714:
                                    v18 = *v8;
                                    v19 = "turboRaidClassificationReliabilityHost";
                                    goto LABEL_13;
                                  case 715:
                                    v18 = *v8;
                                    v19 = "turboRaidClassificationReliabilityInternal";
                                    goto LABEL_13;
                                  case 716:
                                    v18 = *v8;
                                    v19 = "turboRaidClassificationQualityHost";
                                    goto LABEL_13;
                                  case 717:
                                    v18 = *v8;
                                    v19 = "turboRaidClassificationQualityInternal";
                                    goto LABEL_13;
                                  case 719:
                                    v18 = *v8;
                                    v19 = "skinnyBandErases";
                                    goto LABEL_13;
                                  case 721:
                                    v18 = *v8;
                                    v19 = "gcPDusterDestinations";
                                    goto LABEL_13;
                                  case 722:
                                    v18 = *v8;
                                    v19 = "gcPDusterWrites";
                                    goto LABEL_13;
                                  case 730:
                                    v18 = *v8;
                                    v19 = "rvFails";
                                    goto LABEL_13;
                                  case 737:
                                    v18 = *v8;
                                    v19 = "TurboRaidFailedHostAuxReads";
                                    goto LABEL_13;
                                  case 738:
                                    v18 = *v8;
                                    v19 = "TurboRaidFailedInternalAuxReads";
                                    goto LABEL_13;
                                  case 741:
                                    v18 = *v8;
                                    v19 = "autoSkipTriggers";
                                    goto LABEL_13;
                                  case 742:
                                    v18 = *v8;
                                    v19 = "autoSkipPlanes";
                                    goto LABEL_13;
                                  case 744:
                                    v20 = "raidReconstructDurationHisto";
                                    v21 = a1;
                                    v22 = 744;
                                    goto LABEL_23;
                                  case 745:
                                    v20 = "failsOnReconstructHisto";
                                    v21 = a1;
                                    v22 = 745;
                                    goto LABEL_23;
                                  case 746:
                                    v18 = *v8;
                                    v19 = "bandKill_userFlattenExcessive";
                                    goto LABEL_13;
                                  case 747:
                                    v18 = *v8;
                                    v19 = "bandKill_IntFlattenExcessive";
                                    goto LABEL_13;
                                  case 748:
                                    v18 = *v8;
                                    v19 = "bandKill_userFlattenBalance";
                                    goto LABEL_13;
                                  case 749:
                                    v18 = *v8;
                                    v19 = "bandKill_intFlattenBalance";
                                    goto LABEL_13;
                                  case 750:
                                    v18 = *v8;
                                    v19 = "bandKill_formatVertExcessive";
                                    goto LABEL_13;
                                  case 751:
                                    v18 = *v8;
                                    v19 = "bandKill_formatVertBalance";
                                    goto LABEL_13;
                                  case 753:
                                    v18 = *v8;
                                    v19 = "cbdrNumSlowRefreshes";
                                    goto LABEL_13;
                                  case 754:
                                    v18 = *v8;
                                    v19 = "cbdrNumFastRefreshes";
                                    goto LABEL_13;
                                  case 755:
                                    v18 = *v8;
                                    v19 = "cbdrTotalRefreshValidity";
                                    goto LABEL_13;
                                  case 756:
                                    v20 = "cbdrRefreshedAges";
                                    v21 = a1;
                                    v22 = 756;
                                    goto LABEL_544;
                                  case 758:
                                    v18 = *v8;
                                    v19 = "cbdrSkippedBlocks";
                                    goto LABEL_13;
                                  case 759:
                                    v20 = "cbdrScanPct";
                                    v21 = a1;
                                    v22 = 759;
                                    goto LABEL_19;
                                  case 760:
                                    v18 = *v8;
                                    v19 = "raidSuccessfulBMXReconstructionInternal";
                                    goto LABEL_13;
                                  case 761:
                                    v18 = *v8;
                                    v19 = "raidSuccessfulBMXReconstructionHost";
                                    goto LABEL_13;
                                  case 762:
                                    v18 = *v8;
                                    v19 = "raidFailedBMXReconstructionInternal";
                                    goto LABEL_13;
                                  case 763:
                                    v18 = *v8;
                                    v19 = "raidFailedBMXReconstructionHost";
                                    goto LABEL_13;
                                  case 764:
                                    v18 = *v8;
                                    v19 = "ricSPRVFail";
                                    goto LABEL_13;
                                  case 765:
                                    v18 = *v8;
                                    v19 = "ricMPRVFail";
                                    goto LABEL_13;
                                  case 768:
                                    v20 = "cbdrRefreshedAgesSLC";
                                    v21 = a1;
                                    v22 = 768;
LABEL_544:
                                    v14 = v8;
                                    v15 = 9;
                                    goto LABEL_12;
                                  case 770:
                                    v20 = "cpuBurstLength";
                                    v21 = a1;
                                    v22 = 770;
                                    goto LABEL_23;
                                  case 771:
                                    v18 = *v8;
                                    v19 = "autoSkipRaidRecoFail";
                                    goto LABEL_13;
                                  case 772:
                                    v20 = "dmReasonsSlc";
                                    v21 = a1;
                                    v22 = 772;
                                    goto LABEL_155;
                                  case 773:
                                    v20 = "dmReasonsTlc";
                                    v21 = a1;
                                    v22 = 773;
                                    goto LABEL_155;
                                  case 774:
                                    v18 = *v8;
                                    v19 = "raidReconstructFailBMXAbort";
                                    goto LABEL_13;
                                  case 775:
                                    v18 = *v8;
                                    v19 = "bandKill_fatBindingNoBlocks";
                                    goto LABEL_13;
                                  case 776:
                                    v18 = *v8;
                                    v19 = "bandKill_fatBindingFewBlocks";
                                    goto LABEL_13;
                                  case 777:
                                    v18 = *v8;
                                    v19 = "numBadBootBlocks";
                                    goto LABEL_13;
                                  case 778:
                                    v18 = *v8;
                                    v19 = "snapshotCPUHigh";
                                    goto LABEL_13;
                                  default:
                                    switch(v7)
                                    {
                                      case 779:
                                        v18 = *v8;
                                        v19 = "snapshotCPULow";
                                        goto LABEL_13;
                                      case 780:
                                        v18 = *v8;
                                        v19 = "gcWithoutBMs";
                                        goto LABEL_13;
                                      case 781:
                                        v20 = "gcSearchTimeHistory";
                                        v21 = a1;
                                        v22 = 781;
                                        goto LABEL_11;
                                      case 785:
                                        v20 = "gcSearchPortion";
                                        v21 = a1;
                                        v22 = 785;
                                        goto LABEL_85;
                                      case 786:
                                        v18 = *v8;
                                        v19 = "raidReconstructFailBmxMp";
                                        goto LABEL_13;
                                      case 787:
                                        v18 = *v8;
                                        v19 = "raidReconstructFailBmx";
                                        goto LABEL_13;
                                      case 788:
                                        v18 = *v8;
                                        v19 = "raidReconstructFailBMXUECC";
                                        goto LABEL_13;
                                      case 789:
                                        v18 = *v8;
                                        v19 = "raidReconstructFailBMXBlank";
                                        goto LABEL_13;
                                      case 790:
                                        v18 = *v8;
                                        v19 = "raidPrevFailedReconstructBmxMpSkip";
                                        goto LABEL_13;
                                      case 792:
                                        v18 = *v8;
                                        v19 = "numTLCFatBands";
                                        goto LABEL_13;
                                      case 793:
                                        v18 = *v8;
                                        v19 = "fatValidity";
                                        goto LABEL_13;
                                      case 794:
                                        v18 = *v8;
                                        v19 = "fatTotal";
                                        goto LABEL_13;
                                      case 798:
                                        v20 = "raidBMXFailP";
                                        v21 = a1;
                                        v22 = 798;
                                        goto LABEL_22;
                                      case 799:
                                        v20 = "raidBMXFailUECC";
                                        v21 = a1;
                                        v22 = 799;
                                        goto LABEL_22;
                                      case 804:
                                        v20 = "raidBMXFailNoSPBX";
                                        v21 = a1;
                                        v22 = 804;
                                        goto LABEL_22;
                                      case 806:
                                        v20 = "raidBMXFailBlank";
                                        v21 = a1;
                                        v22 = 806;
                                        goto LABEL_22;
                                      case 809:
                                        v20 = "raidBMXFailUnsup";
                                        v21 = a1;
                                        v22 = 809;
                                        goto LABEL_22;
                                      case 811:
                                        v20 = "raidBMXFailMpSkip";
                                        v21 = a1;
                                        v22 = 811;
                                        goto LABEL_22;
                                      case 812:
                                        v20 = "raidBMXFailAbort";
                                        v21 = a1;
                                        v22 = 812;
                                        goto LABEL_22;
                                      case 813:
                                        v18 = *v8;
                                        v19 = "TurboRaidIsEnabled";
                                        goto LABEL_13;
                                      case 814:
                                        v20 = "raidBMXFailOther";
                                        v21 = a1;
                                        v22 = 814;
                                        goto LABEL_22;
                                      case 815:
                                        v20 = "raidBMXSuccess";
                                        v21 = a1;
                                        v22 = 815;
                                        goto LABEL_22;
                                      case 816:
                                        v18 = *v8;
                                        v19 = "skinnyBandsExtraDip";
                                        goto LABEL_13;
                                      case 821:
                                        v18 = *v8;
                                        v19 = "writeAmp";
                                        goto LABEL_13;
                                      case 822:
                                        v18 = *v8;
                                        v19 = "ricMaxClogOnlyPages";
                                        goto LABEL_13;
                                      case 823:
                                        v20 = "readClassifyStatusesHisto";
                                        v21 = a1;
                                        v22 = 823;
                                        goto LABEL_21;
                                      case 824:
                                        v20 = "readWithAuxStatusesHisto";
                                        v21 = a1;
                                        v22 = 824;
                                        goto LABEL_11;
                                      case 825:
                                        v20 = "readReconstructStatusesHisto";
                                        v21 = a1;
                                        v22 = 825;
                                        goto LABEL_11;
                                      case 826:
                                        v18 = *v8;
                                        v19 = "bdrBackupChecks";
                                        goto LABEL_13;
                                      case 827:
                                        v18 = *v8;
                                        v19 = "ricExceedClogOnlyPagesTH";
                                        goto LABEL_13;
                                      case 828:
                                        v18 = *v8;
                                        v19 = "numDipFailures";
                                        goto LABEL_13;
                                      case 862:
                                        v18 = *v8;
                                        v19 = "raidSuccessfulSkip";
                                        goto LABEL_13;
                                      case 863:
                                        v18 = *v8;
                                        v19 = "raidFailedSkip";
                                        goto LABEL_13;
                                      case 864:
                                        v18 = *v8;
                                        v19 = "raidSkipAttempts";
                                        goto LABEL_13;
                                      case 865:
                                        v20 = "timeOfThrottlingPerLevel";
                                        v21 = a1;
                                        v22 = 865;
                                        goto LABEL_85;
                                      case 866:
                                        v20 = "timeOfThrottlingPerReadLevel";
                                        v21 = a1;
                                        v22 = 866;
                                        goto LABEL_85;
                                      case 867:
                                        v20 = "timeOfThrottlingPerWriteLevel";
                                        v21 = a1;
                                        v22 = 867;
                                        goto LABEL_85;
                                      case 868:
                                        v20 = "dmReasonsSlc_1bc";
                                        v21 = a1;
                                        v22 = 868;
                                        goto LABEL_155;
                                      case 869:
                                        v20 = "dmReasonsTlc_1bc";
                                        v21 = a1;
                                        v22 = 869;
                                        goto LABEL_155;
                                      case 870:
                                        v20 = "dmReasonsSlc_1bc_he";
                                        v21 = a1;
                                        v22 = 870;
                                        goto LABEL_155;
                                      case 871:
                                        v20 = "dmReasonsTlc_1bc_he";
                                        v21 = a1;
                                        v22 = 871;
                                        goto LABEL_155;
                                      case 876:
                                        v20 = "dmReasonsSlc_mbc";
                                        v21 = a1;
                                        v22 = 876;
                                        goto LABEL_155;
                                      case 877:
                                        v20 = "dmReasonsTlc_mbc";
                                        v21 = a1;
                                        v22 = 877;
                                        goto LABEL_155;
                                      case 883:
                                        v18 = *v8;
                                        v19 = "clogEmptyProgramms";
                                        goto LABEL_13;
                                      case 884:
                                        v18 = *v8;
                                        v19 = "oslcHwCloseBand";
                                        goto LABEL_13;
                                      case 891:
                                        v20 = "turboRaidSuccessAuxPartition";
                                        v21 = a1;
                                        v22 = 891;
                                        goto LABEL_20;
                                      case 892:
                                        v20 = "turboRaidFailAuxPartition";
                                        v21 = a1;
                                        v22 = 892;
                                        goto LABEL_20;
                                      case 893:
                                        v20 = "turboRaidClassifyQualPartition";
                                        v21 = a1;
                                        v22 = 893;
                                        goto LABEL_20;
                                      case 894:
                                        v20 = "turboRaidClassifyRelPartition";
                                        v21 = a1;
                                        v22 = 894;
                                        goto LABEL_20;
                                      case 895:
                                        v18 = *v8;
                                        v19 = "IND_pool_freeMinSilo";
                                        goto LABEL_13;
                                      case 896:
                                        v18 = *v8;
                                        v19 = "autoSweepBlocks";
                                        goto LABEL_13;
                                      case 897:
                                        v20 = "wcWrFragSizes";
                                        v21 = a1;
                                        v22 = 897;
                                        goto LABEL_85;
                                      case 898:
                                        v20 = "indStateAcrossGcDidNoL";
                                        v21 = a1;
                                        v22 = 898;
                                        goto LABEL_85;
                                      case 899:
                                        v20 = "indStateAcrossGcDidL";
                                        v21 = a1;
                                        v22 = 899;
                                        goto LABEL_85;
                                      case 900:
                                        v18 = *v8;
                                        v19 = "turboRaidNoClassifyDueToWasRetire";
                                        goto LABEL_13;
                                      case 901:
                                        v18 = *v8;
                                        v19 = "turboRaidNoClassifyDueToOpenBand";
                                        goto LABEL_13;
                                      case 902:
                                        v18 = *v8;
                                        v19 = "turboRaidNoClassifyDueToQualityBlock";
                                        goto LABEL_13;
                                      case 903:
                                        v18 = *v8;
                                        v19 = "turboRaidGbbOpenBand";
                                        goto LABEL_13;
                                      case 904:
                                        v18 = *v8;
                                        v19 = "turboRaidGbbShouldRetireOnRefresh";
                                        goto LABEL_13;
                                      case 905:
                                        v20 = "turboRaidRelPerBlock";
                                        v21 = a1;
                                        v22 = 905;
                                        goto LABEL_85;
                                      case 906:
                                        v20 = "turboRaidRelBetweenRefreshesPerBlock";
                                        v21 = a1;
                                        v22 = 906;
                                        goto LABEL_85;
                                      case 907:
                                        v20 = "turboRaidMaxRelBetweenRefreshesPerBlock";
                                        v21 = a1;
                                        v22 = 907;
                                        goto LABEL_85;
                                      case 908:
                                        v20 = "turboRaidMinRelBetweenRefreshesPerBlock";
                                        v21 = a1;
                                        v22 = 908;
                                        goto LABEL_85;
                                      case 918:
                                        v20 = "turboRaidMaxCyclesBetweenRel";
                                        v21 = a1;
                                        v22 = 918;
                                        goto LABEL_85;
                                      default:
                                        if (v7 <= 1039)
                                        {
                                          switch(v7)
                                          {
                                            case 919:
                                              v20 = "turboRaidMinCyclesBetweenRel";
                                              v21 = a1;
                                              v22 = 919;
                                              goto LABEL_85;
                                            case 920:
                                              v20 = "turboRaidAuxPerBlock";
                                              v21 = a1;
                                              v22 = 920;
                                              goto LABEL_85;
                                            case 921:
                                              v20 = "turboRaidAuxBetweenRefreshesPerBlock";
                                              v21 = a1;
                                              v22 = 921;
                                              goto LABEL_85;
                                            case 922:
                                              v18 = *v8;
                                              v19 = "turboRaidRelLockMark";
                                              goto LABEL_13;
                                            case 923:
                                              v18 = *v8;
                                              v19 = "turboRaidAuxLockMark";
                                              goto LABEL_13;
                                            case 924:
                                            case 925:
                                            case 926:
                                            case 927:
                                            case 928:
                                            case 929:
                                            case 936:
                                            case 941:
                                            case 945:
                                            case 946:
                                            case 947:
                                            case 949:
                                            case 950:
                                            case 952:
                                            case 954:
                                            case 955:
                                            case 956:
                                            case 957:
                                            case 958:
                                            case 959:
                                            case 960:
                                            case 963:
                                            case 964:
                                            case 965:
                                            case 966:
                                            case 968:
                                            case 969:
                                            case 970:
                                              goto LABEL_696;
                                            case 930:
                                              v20 = "turboRaidMaxCyclesBetweenAux";
                                              v21 = a1;
                                              v22 = 930;
                                              goto LABEL_85;
                                            case 931:
                                              v20 = "turboRaidMinCyclesBetweenAux";
                                              v21 = a1;
                                              v22 = 931;
                                              goto LABEL_85;
                                            case 932:
                                              v20 = "turboRaidLastRelPECycles";
                                              v21 = a1;
                                              v22 = 932;
                                              goto LABEL_85;
                                            case 933:
                                              v20 = "turboRaidRelQualPECycles";
                                              v21 = a1;
                                              v22 = 933;
                                              goto LABEL_85;
                                            case 934:
                                              v20 = "turboRaidLastAuxPECycles";
                                              v21 = a1;
                                              v22 = 934;
                                              goto LABEL_85;
                                            case 935:
                                              v20 = "turboRaidAuxQualPECycles";
                                              v21 = a1;
                                              v22 = 935;
                                              goto LABEL_85;
                                            case 937:
                                              v18 = *v8;
                                              v19 = "turboRaidPEFailAfterRel";
                                              goto LABEL_13;
                                            case 938:
                                              v18 = *v8;
                                              v19 = "turboRaidPEFailAfterAux";
                                              goto LABEL_13;
                                            case 939:
                                              v18 = *v8;
                                              v19 = "dvfmVotesCPU";
                                              goto LABEL_13;
                                            case 940:
                                              v18 = *v8;
                                              v19 = "dvfmVotesBandwidth";
                                              goto LABEL_13;
                                            case 942:
                                              v18 = *v8;
                                              v19 = "maxSLCEndurance";
                                              goto LABEL_13;
                                            case 943:
                                              v18 = *v8;
                                              v19 = "maxMixedEndurance";
                                              goto LABEL_13;
                                            case 944:
                                              v18 = *v8;
                                              v19 = "maxNativeEndurance";
                                              goto LABEL_13;
                                            case 948:
                                              v20 = "assertHistory";
                                              v21 = a1;
                                              v22 = 948;
                                              v14 = v8;
                                              v15 = 40;
                                              goto LABEL_12;
                                            case 951:
                                              v18 = *v8;
                                              v19 = "asp3Support";
                                              goto LABEL_13;
                                            case 953:
                                              v18 = *v8;
                                              v19 = "numCrossTempRaidUecc";
                                              goto LABEL_13;
                                            case 961:
                                              v18 = *v8;
                                              v19 = "osBuildStr";
                                              goto LABEL_13;
                                            case 962:
                                              v18 = *v8;
                                              v19 = "raidConfig";
                                              goto LABEL_13;
                                            case 967:
                                              v20 = "indTrimFrags";
                                              v21 = a1;
                                              v22 = 967;
                                              goto LABEL_153;
                                            case 971:
                                              v20 = "indUsedFrags";
                                              v21 = a1;
                                              v22 = 971;
                                              goto LABEL_153;
                                            default:
                                              switch(v7)
                                              {
                                                case 996:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "clogFindFail";
                                                  goto LABEL_14;
                                                case 997:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "clogFindBlank";
                                                  goto LABEL_14;
                                                case 998:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "clogFindUnc";
                                                  goto LABEL_14;
                                                case 999:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "clogFindUnexpected";
                                                  goto LABEL_14;
                                                case 1001:
                                                  v21 = a1;
                                                  v22 = 1001;
                                                  v20 = "clogReplayFailReason";
                                                  goto LABEL_23;
                                                case 1002:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "clogReplayTransientError";
                                                  goto LABEL_14;
                                                case 1003:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "clogReplaySpfError";
                                                  goto LABEL_14;
                                                case 1015:
                                                  v21 = a1;
                                                  v22 = 1015;
                                                  v20 = "eanEarlyBootUeccPage";
                                                  goto LABEL_22;
                                                case 1016:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "eanEarlyBootNumUeccPages";
                                                  goto LABEL_14;
                                                case 1017:
                                                  v18 = *v8;
                                                  v16 = (_QWORD *)a1;
                                                  v19 = "eanEarlyBootUeccMultiplane";
                                                  goto LABEL_14;
                                                default:
                                                  goto LABEL_696;
                                              }
                                          }
                                        }
                                        if (v7 > 1146)
                                        {
                                          switch(v7)
                                          {
                                            case 1147:
                                              v21 = a1;
                                              v22 = 1147;
                                              v20 = "gc_concurrent_dw_gc12";
                                              goto LABEL_713;
                                            case 1148:
                                              v21 = a1;
                                              v22 = 1148;
                                              v20 = "gc_concurrent_dw_gc1";
                                              goto LABEL_713;
                                            case 1149:
                                              v21 = a1;
                                              v22 = 1149;
                                              v20 = "gc_concurrent_dw_gc2";
LABEL_713:
                                              v14 = v8;
                                              v15 = 24;
                                              goto LABEL_12;
                                            case 1150:
                                            case 1151:
                                            case 1152:
                                            case 1153:
                                            case 1154:
                                            case 1155:
                                            case 1156:
                                            case 1159:
                                            case 1160:
                                            case 1161:
                                            case 1162:
                                            case 1163:
                                            case 1164:
                                            case 1165:
                                            case 1166:
                                            case 1167:
                                            case 1170:
                                            case 1173:
                                            case 1174:
                                            case 1175:
                                            case 1176:
                                            case 1177:
                                            case 1178:
                                            case 1186:
                                            case 1187:
                                            case 1188:
                                              goto LABEL_696;
                                            case 1157:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "eanMaxForceROTimeMs";
                                              goto LABEL_14;
                                            case 1158:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "eanMaxForceRORecoTimeMs";
                                              goto LABEL_14;
                                            case 1168:
                                              v21 = a1;
                                              v22 = 1168;
                                              v20 = "poDetectPERemovalTotalCost";
                                              goto LABEL_20;
                                            case 1169:
                                              v21 = a1;
                                              v22 = 1169;
                                              v20 = "poDetectEmptySpotRemovalTotalCost";
                                              goto LABEL_20;
                                            case 1171:
                                              v21 = a1;
                                              v22 = 1171;
                                              v20 = "poDetectEmptySpotRemovalAge";
                                              break;
                                            case 1172:
                                              v21 = a1;
                                              v22 = 1172;
                                              v20 = "poDetectGBBedMostSevereCost";
                                              goto LABEL_21;
                                            case 1179:
                                              v21 = a1;
                                              v22 = 1179;
                                              v20 = "gc_cur_dw_gc1";
                                              goto LABEL_22;
                                            case 1180:
                                              v21 = a1;
                                              v22 = 1180;
                                              v20 = "gc_cur_dw_gc2";
                                              goto LABEL_22;
                                            case 1181:
                                              v21 = a1;
                                              v22 = 1181;
                                              v20 = "gc_cur_dw_gc3";
                                              goto LABEL_22;
                                            case 1182:
                                              v21 = a1;
                                              v22 = 1182;
                                              v20 = "gc_tot_dw_gc1";
                                              goto LABEL_22;
                                            case 1183:
                                              v21 = a1;
                                              v22 = 1183;
                                              v20 = "gc_tot_dw_gc2";
                                              goto LABEL_22;
                                            case 1184:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "unhappy_state";
                                              goto LABEL_14;
                                            case 1185:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "unhappy_level";
                                              goto LABEL_14;
                                            case 1189:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "lastLbaFormatTime";
                                              goto LABEL_14;
                                            case 1190:
                                              v21 = a1;
                                              v22 = 1190;
                                              v20 = "powerDownTime";
                                              goto LABEL_153;
                                            default:
                                              if (v7 == 1196)
                                              {
                                                v21 = a1;
                                                v22 = 1196;
                                                v20 = "poDetectGBBedTotalCost";
                                                goto LABEL_19;
                                              }
                                              if (v7 != 1197)
                                                goto LABEL_696;
                                              v21 = a1;
                                              v22 = 1197;
                                              v20 = "poDetectGBBedAge";
                                              break;
                                          }
LABEL_11:
                                          v14 = v8;
                                          v15 = 10;
                                          goto LABEL_12;
                                        }
                                        if (v7 > 1104)
                                        {
                                          if (v7 <= 1115)
                                          {
                                            if (v7 == 1105)
                                            {
                                              v21 = a1;
                                              v22 = 1105;
                                              v20 = "hostReadSequential";
                                              goto LABEL_705;
                                            }
                                            if (v7 == 1106)
                                            {
                                              v21 = a1;
                                              v22 = 1106;
                                              v20 = "GCReadSequential";
LABEL_705:
                                              v14 = v8;
                                              v15 = 14;
                                              goto LABEL_12;
                                            }
                                          }
                                          else
                                          {
                                            switch(v7)
                                            {
                                              case 1116:
                                                v21 = a1;
                                                v22 = 1116;
                                                v20 = "gcwamp";
                                                goto LABEL_155;
                                              case 1137:
                                                v18 = *v8;
                                                v16 = (_QWORD *)a1;
                                                v19 = "numOfToUnhappySwitches";
                                                goto LABEL_14;
                                              case 1138:
                                                v18 = *v8;
                                                v16 = (_QWORD *)a1;
                                                v19 = "numOfToHappySwitches";
                                                goto LABEL_14;
                                            }
                                          }
                                          goto LABEL_696;
                                        }
                                        if (v7 <= 1041)
                                        {
                                          v21 = a1;
                                          if (v7 == 1040)
                                          {
                                            v22 = 1040;
                                            v20 = "bandsAgeBinsV2";
                                          }
                                          else
                                          {
                                            v22 = 1041;
                                            v20 = "bandsAgeBinsSnapshot";
                                          }
                                          v14 = v8;
                                          v15 = 31;
                                          goto LABEL_12;
                                        }
                                        if (v7 == 1042)
                                        {
                                          v21 = a1;
                                          v22 = 1042;
                                          v20 = "bandsAgeBinsReadSectors";
                                          v14 = v8;
                                          v15 = 15;
LABEL_12:
                                          sub_10007A2C8(v21, v22, v20, v14, v15);
                                          goto LABEL_15;
                                        }
                                        if (v7 == 1080)
                                        {
                                          v18 = *v8;
                                          v16 = (_QWORD *)a1;
                                          v19 = "raidForceClogLoad";
                                          goto LABEL_14;
                                        }
LABEL_696:
                                        if (v7 > 1231)
                                        {
                                          switch(v7)
                                          {
                                            case 1232:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "eanFastSize";
                                              goto LABEL_14;
                                            case 1233:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "eanNumSlcEvictions";
                                              goto LABEL_14;
                                            case 1234:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "eanNumForcedCompress";
                                              goto LABEL_14;
                                            case 1241:
                                              v21 = a1;
                                              v22 = 1241;
                                              v20 = "s2rTimeHisto";
                                              goto LABEL_11;
                                            case 1244:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "calendarTimeWentBackward";
                                              goto LABEL_14;
                                            case 1246:
                                              v21 = a1;
                                              v22 = 1246;
                                              v20 = "bandsUeccCrossTempHisto";
                                              goto LABEL_23;
                                            default:
                                              break;
                                          }
                                        }
                                        else
                                        {
                                          switch(v7)
                                          {
                                            case 1198:
                                              v21 = a1;
                                              v22 = 1198;
                                              v20 = "poDetectPERemovalMostSevereCost";
                                              goto LABEL_21;
                                            case 1199:
                                              v18 = *v8;
                                              v16 = (_QWORD *)a1;
                                              v19 = "poDetectCurrentSize";
                                              goto LABEL_14;
                                            case 1200:
                                              break;
                                            case 1201:
                                              v21 = a1;
                                              v22 = 1201;
                                              v20 = "gcVerticalSuccssfulAlignments";
                                              goto LABEL_22;
                                            case 1202:
                                              v21 = a1;
                                              v22 = 1202;
                                              v20 = "gcVerticalNoAlignmentDueToMissingSegs";
                                              goto LABEL_22;
                                            default:
                                              switch(v7)
                                              {
                                                case 1216:
                                                  v21 = a1;
                                                  v22 = 1216;
                                                  v20 = "tlcWLPerDipAvgPEC";
                                                  goto LABEL_713;
                                                case 1217:
                                                  v21 = a1;
                                                  v22 = 1217;
                                                  v20 = "tlcWLPerDipMaxPEC";
                                                  goto LABEL_713;
                                                case 1218:
                                                  v21 = a1;
                                                  v22 = 1218;
                                                  v20 = "tlcWLPerDipMinPEC";
                                                  goto LABEL_713;
                                                case 1219:
                                                case 1220:
                                                case 1221:
                                                case 1222:
                                                case 1223:
                                                  goto LABEL_15;
                                                case 1224:
                                                  v21 = a1;
                                                  v22 = 1224;
                                                  v20 = "apfsValidLbaOvershoot";
                                                  v14 = v8;
                                                  v15 = 20;
                                                  goto LABEL_12;
                                                default:
                                                  if (v7 != 1211)
                                                    goto LABEL_15;
                                                  v21 = a1;
                                                  v22 = 1211;
                                                  v20 = "forcedAllocationSmallEraseQ";
                                                  break;
                                              }
                                              goto LABEL_713;
                                          }
                                        }
LABEL_15:
                                        a2 = &v8[v10];
                                        v6 = v11 - v10;
                                        if (v11 != (_DWORD)v10)
                                          continue;
                                        return 1;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
  }
}

uint64_t sub_10007A2C8(uint64_t result, int a2, const char *a3, uint64_t *a4, unsigned int a5)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char __str[101];

  v7 = (_QWORD *)result;
  v8 = *a4;
  if (a2 <= 44)
  {
    switch(a2)
    {
      case 4:
        *(_QWORD *)(result + 72) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      case 5:
      case 6:
      case 8:
      case 9:
      case 10:
      case 11:
      case 14:
      case 15:
      case 16:
        goto LABEL_41;
      case 7:
        *(_QWORD *)(result + 64) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      case 12:
        *(_QWORD *)(result + 144) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      case 13:
        *(_QWORD *)(result + 152) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      case 17:
        *(_QWORD *)(result + 88) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      case 18:
        *(_QWORD *)(result + 104) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      case 19:
        *(_QWORD *)(result + 96) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      case 20:
        *(_QWORD *)(result + 112) = v8;
        if (a5)
          goto LABEL_42;
        return result;
      default:
        if (a2 != 28)
          goto LABEL_41;
        *(_QWORD *)(result + 168) = v8;
        if (!a5)
          return result;
        goto LABEL_42;
    }
  }
  switch(a2)
  {
    case '-':
      *(_QWORD *)(result + 176) = v8;
      if (a5)
        goto LABEL_42;
      return result;
    case '.':
    case '/':
    case '6':
    case '7':
      goto LABEL_41;
    case '0':
      *(_QWORD *)(result + 80) = v8;
      if (!a5)
        return result;
      goto LABEL_42;
    case '1':
      *(_DWORD *)(result + 56) = v8;
      if (!a5)
        return result;
      goto LABEL_42;
    case '2':
      *(_DWORD *)(result + 52) = v8;
      if (!a5)
        return result;
      goto LABEL_42;
    case '3':
      *(_DWORD *)(result + 48) = v8;
      if (!a5)
        return result;
      goto LABEL_42;
    case '4':
      *(_DWORD *)(result + 44) = v8;
      if (!a5)
        return result;
      goto LABEL_42;
    case '5':
      *(_DWORD *)(result + 32) = v8;
      goto LABEL_41;
    case '8':
      *(_QWORD *)(result + 160) = v8;
      if (!a5)
        return result;
      goto LABEL_42;
    default:
      if (a2 != 265)
        goto LABEL_41;
      if (a5)
      {
        v9 = a5;
        v10 = (_QWORD *)(result + 184);
        v11 = a4;
        do
        {
          v12 = *v11++;
          *v10++ = v12;
          --v9;
        }
        while (v9);
LABEL_41:
        if (a5)
        {
LABEL_42:
          if (a5 == 1)
          {
            return sub_10008BE70((_QWORD *)result, "", a3, v8);
          }
          else
          {
            v13 = 0;
            v14 = a5;
            do
            {
              snprintf(__str, 0x64uLL, "%d", v13);
              __str[100] = 0;
              result = sub_10008BE70(v7, a3, __str, a4[v13++]);
            }
            while (v14 != v13);
          }
        }
      }
      return result;
  }
}

double sub_10007A510(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  double result;

  v2 = *(_QWORD **)a1;
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)v2[14];
      free(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(_QWORD **)(a1 + 16);
  if (v4)
  {
    do
    {
      v5 = (_QWORD *)v4[14];
      free(v4);
      v4 = v5;
    }
    while (v5);
  }
  result = 0.0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  return result;
}

uint64_t sub_10007A580(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v8;
  uint64_t v10;
  unsigned int v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  unsigned int v20;
  const char *v22;
  char v23;
  char __str[16];
  __int128 v25;

  v8 = (unint64_t *)a2;
  v10 = 0;
  v11 = a3 >> 3;
  *(_OWORD *)__str = 0u;
  v25 = 0u;
  do
  {
LABEL_2:
    if (!v11)
      return v10;
    v13 = *v8++;
    v12 = v13;
    v14 = HIDWORD(v13);
    --v11;
  }
  while (!HIDWORD(v13));
  if (v12 == 0xFFFF || v12 > 0x30000000 || v11 < v14)
    return v10;
  v17 = (v12 - 1);
  if (v17 <= 0x47)
    __asm { BR              X9 }
  v18 = (v12 - 73);
  if (v18 <= 0x46)
    __asm { BR              X9 }
  switch(v12)
  {
    case 144:
      if ((sub_100085260(a1, "numMemExtreme", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: numMemExtreme(144) cannot add 1 element to context";
      goto LABEL_15;
    case 145:
      if ((sub_100085260(a1, "maxMemExtremeDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: maxMemExtremeDuration(145) cannot add 1 element to context";
      goto LABEL_15;
    case 146:
      if ((sub_100085260(a1, "memExtremeDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: memExtremeDuration(146) cannot add 1 element to context";
      goto LABEL_15;
    case 147:
      if ((sub_100085260(a1, "bandGetsExtreme", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: bandGetsExtreme(147) cannot add 1 element to context";
      goto LABEL_15;
    case 148:
      if ((sub_100085260(a1, "bandGetsLow", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: bandGetsLow(148) cannot add 1 element to context";
      goto LABEL_15;
    case 149:
      if ((sub_100085260(a1, "numHostChoke", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: numHostChoke(149) cannot add 1 element to context";
      goto LABEL_15;
    case 152:
      if ((sub_100085260(a1, "AbortSkip_ProgramError", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortSkip_ProgramError(152) cannot add 1 element to context";
      goto LABEL_15;
    case 153:
      if ((sub_100085260(a1, "AbortSkip_ReadErrorOpenBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortSkip_ReadErrorOpenBand(153) cannot add 1 element to context";
      goto LABEL_15;
    case 154:
      if ((sub_100085260(a1, "AbortSkip_FailedRebuildingParity", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortSkip_FailedRebuildingParity(154) cannot add 1 element to context";
      goto LABEL_15;
    case 155:
      if ((sub_100085260(a1, "AbortPad_OpenRefreshBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortPad_OpenRefreshBand(155) cannot add 1 element to context";
      goto LABEL_15;
    case 156:
      if ((sub_100085260(a1, "AbortPad_CloseBands", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortPad_CloseBands(156) cannot add 1 element to context";
      goto LABEL_15;
    case 157:
      if ((sub_100085260(a1, "AbortPad_SetPhoto", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortPad_SetPhoto(157) cannot add 1 element to context";
      goto LABEL_15;
    case 158:
      if ((sub_100085260(a1, "AbortPad_GcNoSource", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortPad_GcNoSource(158) cannot add 1 element to context";
      goto LABEL_15;
    case 159:
      if ((sub_100085260(a1, "AbortPad_Format", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: AbortPad_Format(159) cannot add 1 element to context";
      goto LABEL_15;
    case 160:
      if ((sub_100085260(a1, "nandDiscoveryDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: nandDiscoveryDuration(160) cannot add 1 element to context";
      goto LABEL_15;
    case 161:
      if ((sub_100085260(a1, "coreCCEnableDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: coreCCEnableDuration(161) cannot add 1 element to context";
      goto LABEL_15;
    case 163:
      if ((sub_100085260(a1, "coreOpenDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: coreOpenDuration(163) cannot add 1 element to context";
      goto LABEL_15;
    case 164:
      if ((sub_100085260(a1, "coreWritableDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: coreWritableDuration(164) cannot add 1 element to context";
      goto LABEL_15;
    case 165:
      if ((sub_100085260(a1, "coreClogLoadDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: coreClogLoadDuration(165) cannot add 1 element to context";
      goto LABEL_15;
    case 167:
      if ((sub_100085260(a1, "bulkPFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: bulkPFail(167) cannot add 1 element to context";
      goto LABEL_15;
    case 169:
      if ((sub_100085260(a1, "bulkRFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: bulkRFail(169) cannot add 1 element to context";
      goto LABEL_15;
    case 172:
      if ((sub_100085260(a1, "raidSmartErrors", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: raidSmartErrors(172) cannot add 1 element to context";
      goto LABEL_15;
    case 182:
      if ((sub_100085260(a1, "internalUeccs", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: internalUeccs(182) cannot add 1 element to context";
      goto LABEL_15;
    case 183:
      if ((sub_100085260(a1, "e2eFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: e2eFail(183) cannot add 1 element to context";
      goto LABEL_15;
    case 184:
      if ((sub_100085260(a1, "TempSensorMax", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: TempSensorMax(184) cannot add 1 element to context";
      goto LABEL_15;
    case 185:
      if ((sub_100085260(a1, "TempSensorMin", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: TempSensorMin(185) cannot add 1 element to context";
      goto LABEL_15;
    case 186:
      if ((sub_100085260(a1, "powerUpFromDDR", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: powerUpFromDDR(186) cannot add 1 element to context";
      goto LABEL_15;
    case 187:
      if ((sub_100085260(a1, "numMemLow", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: numMemLow(187) cannot add 1 element to context";
      goto LABEL_15;
    case 188:
      if ((sub_100085260(a1, "maxMemLowDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: maxMemLowDuration(188) cannot add 1 element to context";
      goto LABEL_15;
    case 189:
      if ((sub_100085260(a1, "memLowDuration", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: memLowDuration(189) cannot add 1 element to context";
      goto LABEL_15;
    case 190:
      if ((sub_100085260(a1, "numFences", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: numFences(190) cannot add 1 element to context";
      goto LABEL_15;
    case 191:
      if ((sub_100085260(a1, "hostPassiveIO", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: hostPassiveIO(191) cannot add 1 element to context";
      goto LABEL_15;
    case 192:
      if ((sub_100085260(a1, "odtsMax", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: odtsMax(192) cannot add 1 element to context";
      goto LABEL_15;
    case 193:
      if ((sub_100085260(a1, "defragMFromOrphans", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: defragMFromOrphans(193) cannot add 1 element to context";
      goto LABEL_15;
    case 194:
      if ((sub_100085260(a1, "defragMFromFragments", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: defragMFromFragments(194) cannot add 1 element to context";
      goto LABEL_15;
    case 195:
      if ((sub_100085260(a1, "defragMTime", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: defragMTime(195) cannot add 1 element to context";
      goto LABEL_15;
    case 196:
      if ((sub_100085260(a1, "defragMMaxTime", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: defragMMaxTime(196) cannot add 1 element to context";
      goto LABEL_15;
    case 197:
      if ((sub_100085260(a1, "raidFailedLbaMismatch", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: raidFailedLbaMismatch(197) cannot add 1 element to context";
      goto LABEL_15;
    case 198:
      if ((sub_100085260(a1, "numSyscfgWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: numSyscfgWrites(198) cannot add 1 element to context";
      goto LABEL_15;
    case 199:
      if ((sub_100085260(a1, "indmbUnitsXfer", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: indmbUnitsXfer(199) cannot add 1 element to context";
      goto LABEL_15;
    case 200:
      if ((sub_100085260(a1, "indmbUnitsCache", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: indmbUnitsCache(200) cannot add 1 element to context";
      goto LABEL_15;
    case 201:
      if ((sub_100085260(a1, "indmbUnitsInd", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: indmbUnitsInd(201) cannot add 1 element to context";
      goto LABEL_15;
    case 202:
      if ((sub_100085260(a1, "wcacheFS_Mbytes", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheFS_Mbytes(202) cannot add 1 element to context";
      goto LABEL_15;
    case 203:
      if ((sub_100085260(a1, "wcacheDS_Mbytes", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheDS_Mbytes(203) cannot add 1 element to context";
      goto LABEL_15;
    case 204:
      if ((sub_100085260(a1, "powerOnSeconds", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: powerOnSeconds(204) cannot add 1 element to context";
      goto LABEL_15;
    case 205:
      if ((sub_100085260(a1, "numUnknownTokenHostRead", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: numUnknownTokenHostRead(205) cannot add 1 element to context";
      goto LABEL_15;
    case 206:
      if ((sub_100085260(a1, "numUnmmapedTokenHostRead", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: numUnmmapedTokenHostRead(206) cannot add 1 element to context";
      goto LABEL_15;
    case 207:
      if ((_DWORD)v14 != 16)
        sub_1000756A0("ASPFTLParseBufferToCxt: numOfThrottlingEntriesPerLevel(207): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
      if (v14 >= 0x10)
        v20 = 16;
      else
        v20 = v14;
      if ((sub_100085260(a1, "numOfThrottlingEntriesPerLevel_", (uint64_t)v8, 8u, v20) & 1) != 0)
        goto LABEL_14;
      v22 = "ASPFTLParseBufferToCxt: numOfThrottlingEntriesPerLevel(207): Cannot add 16 elements to context";
      goto LABEL_2228;
    case 208:
      if ((sub_100085260(a1, "wcacheFS_MbytesMin", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheFS_MbytesMin(208) cannot add 1 element to context";
      goto LABEL_15;
    case 209:
      if ((sub_100085260(a1, "wcacheFS_MbytesMax", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheFS_MbytesMax(209) cannot add 1 element to context";
      goto LABEL_15;
    case 210:
      if ((sub_100085260(a1, "prepareForShutdownFailCounter", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: prepareForShutdownFailCounter(210) cannot add 1 element to context";
      goto LABEL_15;
    case 211:
      if ((sub_100085260(a1, "lpsrEntry", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: lpsrEntry(211) cannot add 1 element to context";
      goto LABEL_15;
    case 212:
      if ((sub_100085260(a1, "lpsrExit", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: lpsrExit(212) cannot add 1 element to context";
      goto LABEL_15;
    case 213:
      if ((_DWORD)v14 != 8)
        sub_1000756A0("ASPFTLParseBufferToCxt: crcInternalReadFail(213): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
      if (v14 >= 8)
        v20 = 8;
      else
        v20 = v14;
      if ((sub_100085260(a1, "crcInternalReadFail_", (uint64_t)v8, 8u, v20) & 1) != 0)
        goto LABEL_14;
      v22 = "ASPFTLParseBufferToCxt: crcInternalReadFail(213): Cannot add 8 elements to context";
      goto LABEL_2228;
    case 214:
      if ((sub_100085260(a1, "wcacheFSEvictCnt", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheFSEvictCnt(214) cannot add 1 element to context";
      goto LABEL_15;
    case 215:
      if ((sub_100085260(a1, "wcacheFSEvictSize", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheFSEvictSize(215) cannot add 1 element to context";
      goto LABEL_15;
    case 216:
      if ((sub_100085260(a1, "wcacheFSWr", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheFSWr(216) cannot add 1 element to context";
      goto LABEL_15;
    case 217:
      if ((sub_100085260(a1, "wcacheDSWr", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: wcacheDSWr(217) cannot add 1 element to context";
      goto LABEL_15;
    case 218:
      if ((_DWORD)v14 != 10)
        sub_1000756A0("ASPFTLParseBufferToCxt: wcacheFSEvictSizeLogDist(218): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
      if (v14 >= 0xA)
        v20 = 10;
      else
        v20 = v14;
      if ((sub_100085260(a1, "wcacheFSEvictSizeLogDist_", (uint64_t)v8, 8u, v20) & 1) != 0)
        goto LABEL_14;
      v22 = "ASPFTLParseBufferToCxt: wcacheFSEvictSizeLogDist(218): Cannot add 10 elements to context";
      goto LABEL_2228;
    case 219:
      if ((sub_100085260(a1, "prepareForShutdownTimeoutCounter", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: prepareForShutdownTimeoutCounter(219) cannot add 1 element to context";
      goto LABEL_15;
    case 220:
      if ((sub_100085260(a1, "prepareForShutdownCancelCounter", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: prepareForShutdownCancelCounter(220) cannot add 1 element to context";
      goto LABEL_15;
    case 221:
      if ((sub_100085260(a1, "RD_openBandCount", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: RD_openBandCount(221) cannot add 1 element to context";
      goto LABEL_15;
    case 222:
      if ((sub_100085260(a1, "RD_openBandNops", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: RD_openBandNops(222) cannot add 1 element to context";
      goto LABEL_15;
    case 223:
      if ((sub_100085260(a1, "RD_closedBandEvictCount", (uint64_t)v8, 8u, 1u) & 1) != 0)
        goto LABEL_16;
      v19 = "ASPFTLParseBufferToCxt: RD_closedBandEvictCount(223) cannot add 1 element to context";
      goto LABEL_15;
    default:
      switch(v12)
      {
        case 224:
          if ((sub_100085260(a1, "RD_closedBandEvictSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: RD_closedBandEvictSectors(224) cannot add 1 element to context";
          goto LABEL_15;
        case 225:
          if ((sub_100085260(a1, "RD_closedBandFragmentCount", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: RD_closedBandFragmentCount(225) cannot add 1 element to context";
          goto LABEL_15;
        case 226:
          if ((sub_100085260(a1, "RD_closedBandFragmentSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: RD_closedBandFragmentSectors(226) cannot add 1 element to context";
          goto LABEL_15;
        case 227:
          if ((_DWORD)v14 != 10)
            sub_1000756A0("ASPFTLParseBufferToCxt: wcacheFSOverWrLogSizeCnts(227): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 0xA)
            v20 = 10;
          else
            v20 = v14;
          if ((sub_100085260(a1, "wcacheFSOverWrLogSizeCnts_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: wcacheFSOverWrLogSizeCnts(227): Cannot add 10 elements to context";
          goto LABEL_2228;
        case 228:
          if ((_DWORD)v14 != 4)
            sub_1000756A0("ASPFTLParseBufferToCxt: wcacheFSOverWrSizeByFlow(228): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 4)
            v20 = 4;
          else
            v20 = v14;
          if ((sub_100085260(a1, "wcacheFSOverWrSizeByFlow_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: wcacheFSOverWrSizeByFlow(228): Cannot add 4 elements to context";
          goto LABEL_2228;
        case 229:
          if ((_DWORD)v14 != 2)
            sub_1000756A0("ASPFTLParseBufferToCxt: indmbXferCountTo(229): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 2)
            v20 = 2;
          else
            v20 = v14;
          if ((sub_100085260(a1, "indmbXferCountTo_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: indmbXferCountTo(229): Cannot add 2 elements to context";
          goto LABEL_2228;
        case 230:
          if ((_DWORD)v14 != 2)
            sub_1000756A0("ASPFTLParseBufferToCxt: indmbAccumulatedTimeBetweenXfers(230): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 2)
            v20 = 2;
          else
            v20 = v14;
          if ((sub_100085260(a1, "indmbAccumulatedTimeBetweenXfers_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: indmbAccumulatedTimeBetweenXfers(230): Cannot add 2 elements to context";
          goto LABEL_2228;
        case 231:
          if ((sub_100085260(a1, "maxGracefulBootTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: maxGracefulBootTimeMs(231) cannot add 1 element to context";
          goto LABEL_15;
        case 232:
          if ((sub_100085260(a1, "maxUngracefulBootTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: maxUngracefulBootTimeMs(232) cannot add 1 element to context";
          goto LABEL_15;
        case 233:
          if ((sub_100085260(a1, "averageGracefulBootTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: averageGracefulBootTimeMs(233) cannot add 1 element to context";
          goto LABEL_15;
        case 234:
          if ((sub_100085260(a1, "averageUngracefulBootTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: averageUngracefulBootTimeMs(234) cannot add 1 element to context";
          goto LABEL_15;
        case 235:
          if ((_DWORD)v14 != 8)
            sub_1000756A0("ASPFTLParseBufferToCxt: gracefulBootTimeLogMs(235): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 8)
            v20 = 8;
          else
            v20 = v14;
          if ((sub_100085260(a1, "gracefulBootTimeLogMs_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: gracefulBootTimeLogMs(235): Cannot add 8 elements to context";
          goto LABEL_2228;
        case 236:
          if ((_DWORD)v14 != 8)
            sub_1000756A0("ASPFTLParseBufferToCxt: ungracefulBootTimeLogMs(236): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 8)
            v20 = 8;
          else
            v20 = v14;
          if ((sub_100085260(a1, "ungracefulBootTimeLogMs_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: ungracefulBootTimeLogMs(236): Cannot add 8 elements to context";
          goto LABEL_2228;
        case 237:
          if ((_DWORD)v14 != 4)
            sub_1000756A0("ASPFTLParseBufferToCxt: CalibrationCount(237): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 4)
            v20 = 4;
          else
            v20 = v14;
          if ((sub_100085260(a1, "CalibrationCount_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: CalibrationCount(237): Cannot add 4 elements to context";
          goto LABEL_2228;
        case 238:
          if ((sub_100085260(a1, "CalibrationLastTmp", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: CalibrationLastTmp(238) cannot add 1 element to context";
          goto LABEL_15;
        case 239:
          if ((sub_100085260(a1, "CalibrationMaxTmp", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: CalibrationMaxTmp(239) cannot add 1 element to context";
          goto LABEL_15;
        case 240:
          if ((sub_100085260(a1, "CalibrationMinTmp", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: CalibrationMinTmp(240) cannot add 1 element to context";
          goto LABEL_15;
        case 241:
          if ((sub_100085260(a1, "ungracefulBootWorstIndicator", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: ungracefulBootWorstIndicator(241) cannot add 1 element to context";
          goto LABEL_15;
        case 242:
          if ((sub_100085260(a1, "metaMismatchReread", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: metaMismatchReread(242) cannot add 1 element to context";
          goto LABEL_15;
        case 243:
          if ((sub_100085260(a1, "numS3SleepOps", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: numS3SleepOps(243) cannot add 1 element to context";
          goto LABEL_15;
        case 244:
          if ((sub_100085260(a1, "odtsCurrent", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: odtsCurrent(244) cannot add 1 element to context";
          goto LABEL_15;
        case 245:
          if ((sub_100085260(a1, "prefetchReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: prefetchReads(245) cannot add 1 element to context";
          goto LABEL_15;
        case 246:
          if ((sub_100085260(a1, "prefetchHits", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: prefetchHits(246) cannot add 1 element to context";
          goto LABEL_15;
        case 247:
          if ((sub_100085260(a1, "prefetchWritesInvalidation", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: prefetchWritesInvalidation(247) cannot add 1 element to context";
          goto LABEL_15;
        case 248:
          if ((sub_100085260(a1, "indmbUnitsTotal", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: indmbUnitsTotal(248) cannot add 1 element to context";
          goto LABEL_15;
        case 249:
          if ((sub_100085260(a1, "selfThrottlingEngage", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: selfThrottlingEngage(249) cannot add 1 element to context";
          goto LABEL_15;
        case 250:
          if ((sub_100085260(a1, "selfThrottlingDisengage", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: selfThrottlingDisengage(250) cannot add 1 element to context";
          goto LABEL_15;
        case 252:
          if ((sub_100085260(a1, "AbortSkip_WlpMode", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: AbortSkip_WlpMode(252) cannot add 1 element to context";
          goto LABEL_15;
        case 253:
          if ((sub_100085260(a1, "hostWritesWlpMode", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: hostWritesWlpMode(253) cannot add 1 element to context";
          goto LABEL_15;
        case 254:
          if ((sub_100085260(a1, "numClogDoubleUnc", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: numClogDoubleUnc(254) cannot add 1 element to context";
          goto LABEL_15;
        case 256:
          if ((sub_100085260(a1, "AbortPad_WlpMode", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: AbortPad_WlpMode(256) cannot add 1 element to context";
          goto LABEL_15;
        case 257:
          if ((sub_100085260(a1, "bonfireIntermediateBandErases", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: bonfireIntermediateBandErases(257) cannot add 1 element to context";
          goto LABEL_15;
        case 258:
          if ((sub_100085260(a1, "bonfireUserBandErases", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: bonfireUserBandErases(258) cannot add 1 element to context";
          goto LABEL_15;
        case 259:
          if ((sub_100085260(a1, "bonfireIntermediateBandProgs", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: bonfireIntermediateBandProgs(259) cannot add 1 element to context";
          goto LABEL_15;
        case 260:
          if ((sub_100085260(a1, "bonfireUserBandProgs", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: bonfireUserBandProgs(260) cannot add 1 element to context";
          goto LABEL_15;
        case 261:
          if ((sub_100085260(a1, "bonfireIntermediatePageReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: bonfireIntermediatePageReads(261) cannot add 1 element to context";
          goto LABEL_15;
        case 262:
          if ((sub_100085260(a1, "bonfireUserPageReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: bonfireUserPageReads(262) cannot add 1 element to context";
          goto LABEL_15;
        case 263:
          if ((sub_100085260(a1, "refreshUtil00", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: refreshUtil00(263) cannot add 1 element to context";
          goto LABEL_15;
        case 264:
          if ((sub_100085260(a1, "failToReadUtil00", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: failToReadUtil00(264) cannot add 1 element to context";
          goto LABEL_15;
        case 265:
          if ((_DWORD)v14 != 5)
            sub_1000756A0("ASPFTLParseBufferToCxt: readCountHisto(265): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 5)
            v20 = 5;
          else
            v20 = v14;
          if ((sub_100085260(a1, "readCountHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: readCountHisto(265): Cannot add 5 elements to context";
          goto LABEL_2228;
        case 266:
          if ((_DWORD)v14 != 16)
            sub_1000756A0("ASPFTLParseBufferToCxt: readAmpHisto(266): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 0x10)
            v20 = 16;
          else
            v20 = v14;
          if ((sub_100085260(a1, "readAmpHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: readAmpHisto(266): Cannot add 16 elements to context";
          goto LABEL_2228;
        case 267:
          if ((sub_100085260(a1, "totalReadAmp", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: totalReadAmp(267) cannot add 1 element to context";
          goto LABEL_15;
        case 268:
          if ((_DWORD)v14 != 4)
            sub_1000756A0("ASPFTLParseBufferToCxt: nvmeModeSelect(268): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 4)
            v20 = 4;
          else
            v20 = v14;
          if ((sub_100085260(a1, "nvmeModeSelect_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: nvmeModeSelect(268): Cannot add 4 elements to context";
          goto LABEL_2228;
        case 269:
          if ((_DWORD)v14 != 8)
            sub_1000756A0("ASPFTLParseBufferToCxt: numBootBlockRefreshSuccess(269): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 8)
            v20 = 8;
          else
            v20 = v14;
          if ((sub_100085260(a1, "numBootBlockRefreshSuccess_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: numBootBlockRefreshSuccess(269): Cannot add 8 elements to context";
          goto LABEL_2228;
        case 270:
          if ((_DWORD)v14 != 8)
            sub_1000756A0("ASPFTLParseBufferToCxt: numBootBlockRefreshFail(270): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 8)
            v20 = 8;
          else
            v20 = v14;
          if ((sub_100085260(a1, "numBootBlockRefreshFail_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: numBootBlockRefreshFail(270): Cannot add 8 elements to context";
          goto LABEL_2228;
        case 271:
          if ((sub_100085260(a1, "numUnsupportedAsi", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: numUnsupportedAsi(271) cannot add 1 element to context";
          goto LABEL_15;
        case 272:
          if ((sub_100085260(a1, "NumTerminatedProgramSegs", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: NumTerminatedProgramSegs(272) cannot add 1 element to context";
          goto LABEL_15;
        case 273:
          if ((sub_100085260(a1, "indParityPagesDrops", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: indParityPagesDrops(273) cannot add 1 element to context";
          goto LABEL_15;
        case 274:
          if ((sub_100085260(a1, "indFlowPrograms", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: indFlowPrograms(274) cannot add 1 element to context";
          goto LABEL_15;
        case 277:
          if ((_DWORD)v14 != 4)
            sub_1000756A0("ASPFTLParseBufferToCxt: powerBudgetSelect(277): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 4)
            v20 = 4;
          else
            v20 = v14;
          if ((sub_100085260(a1, "powerBudgetSelect_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: powerBudgetSelect(277): Cannot add 4 elements to context";
          goto LABEL_2228;
        case 279:
          if ((sub_100085260(a1, "RxBurnNandWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: RxBurnNandWrites(279) cannot add 1 element to context";
          goto LABEL_15;
        case 280:
          if ((_DWORD)v14 != 12)
            sub_1000756A0("ASPFTLParseBufferToCxt: E2EDPErrorCounters(280): (#12) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 0xC)
            v20 = 12;
          else
            v20 = v14;
          if ((sub_100085260(a1, "E2EDPErrorCounters_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: E2EDPErrorCounters(280): Cannot add 12 elements to context";
          goto LABEL_2228;
        case 281:
          if ((sub_100085260(a1, "wcacheSectorsMax", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheSectorsMax(281) cannot add 1 element to context";
          goto LABEL_15;
        case 282:
          if ((sub_100085260(a1, "wcacheSectorsMin", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheSectorsMin(282) cannot add 1 element to context";
          goto LABEL_15;
        case 283:
          if ((sub_100085260(a1, "wcacheSectorsCur", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheSectorsCur(283) cannot add 1 element to context";
          goto LABEL_15;
        case 284:
          if ((sub_100085260(a1, "wcacheDS_SectorsMax", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheDS_SectorsMax(284) cannot add 1 element to context";
          goto LABEL_15;
        case 285:
          if ((sub_100085260(a1, "wcacheDS_SectorsMin", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheDS_SectorsMin(285) cannot add 1 element to context";
          goto LABEL_15;
        case 286:
          if ((sub_100085260(a1, "wcacheDS_SectorsCur", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheDS_SectorsCur(286) cannot add 1 element to context";
          goto LABEL_15;
        case 287:
          if ((sub_100085260(a1, "wcacheFS_Reads", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheFS_Reads(287) cannot add 1 element to context";
          goto LABEL_15;
        case 288:
          if ((sub_100085260(a1, "wcacheDS_Reads", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: wcacheDS_Reads(288) cannot add 1 element to context";
          goto LABEL_15;
        case 289:
          if ((_DWORD)v14 != 32)
            sub_1000756A0("ASPFTLParseBufferToCxt: mspBootBlockReadFail(289): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 0x20)
            v20 = 32;
          else
            v20 = v14;
          if ((sub_100085260(a1, "mspBootBlockReadFail_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: mspBootBlockReadFail(289): Cannot add 32 elements to context";
          goto LABEL_2228;
        case 290:
          if ((_DWORD)v14 != 32)
            sub_1000756A0("ASPFTLParseBufferToCxt: mspBootBlockProgFail(290): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 0x20)
            v20 = 32;
          else
            v20 = v14;
          if ((sub_100085260(a1, "mspBootBlockProgFail_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: mspBootBlockProgFail(290): Cannot add 32 elements to context";
          goto LABEL_2228;
        case 291:
          if ((_DWORD)v14 != 32)
            sub_1000756A0("ASPFTLParseBufferToCxt: mspBootBlockEraseFail(291): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
          if (v14 >= 0x20)
            v20 = 32;
          else
            v20 = v14;
          if ((sub_100085260(a1, "mspBootBlockEraseFail_", (uint64_t)v8, 8u, v20) & 1) != 0)
            goto LABEL_14;
          v22 = "ASPFTLParseBufferToCxt: mspBootBlockEraseFail(291): Cannot add 32 elements to context";
          goto LABEL_2228;
        case 292:
          if ((sub_100085260(a1, "bandsRefreshedOnError", (uint64_t)v8, 8u, 1u) & 1) != 0)
            goto LABEL_16;
          v19 = "ASPFTLParseBufferToCxt: bandsRefreshedOnError(292) cannot add 1 element to context";
          goto LABEL_15;
        default:
          switch(v12)
          {
            case 298:
              if ((_DWORD)v14 != 2)
                sub_1000756A0("ASPFTLParseBufferToCxt: perHostReads(298): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 2)
                v20 = 2;
              else
                v20 = v14;
              if ((sub_100085260(a1, "perHostReads_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: perHostReads(298): Cannot add 2 elements to context";
              goto LABEL_2228;
            case 299:
              if ((_DWORD)v14 != 2)
                sub_1000756A0("ASPFTLParseBufferToCxt: perHostReadXacts(299): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 2)
                v20 = 2;
              else
                v20 = v14;
              if ((sub_100085260(a1, "perHostReadXacts_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: perHostReadXacts(299): Cannot add 2 elements to context";
              goto LABEL_2228;
            case 300:
              if ((_DWORD)v14 != 2)
                sub_1000756A0("ASPFTLParseBufferToCxt: perHostWrites(300): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 2)
                v20 = 2;
              else
                v20 = v14;
              if ((sub_100085260(a1, "perHostWrites_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: perHostWrites(300): Cannot add 2 elements to context";
              goto LABEL_2228;
            case 301:
              if ((_DWORD)v14 != 2)
                sub_1000756A0("ASPFTLParseBufferToCxt: perHostWriteXacts(301): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 2)
                v20 = 2;
              else
                v20 = v14;
              if ((sub_100085260(a1, "perHostWriteXacts_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: perHostWriteXacts(301): Cannot add 2 elements to context";
              goto LABEL_2228;
            case 302:
              if ((_DWORD)v14 != 2)
                sub_1000756A0("ASPFTLParseBufferToCxt: perHostNumFlushes(302): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 2)
                v20 = 2;
              else
                v20 = v14;
              if ((sub_100085260(a1, "perHostNumFlushes_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: perHostNumFlushes(302): Cannot add 2 elements to context";
              goto LABEL_2228;
            case 303:
              if ((_DWORD)v14 != 2)
                sub_1000756A0("ASPFTLParseBufferToCxt: perHostNumFences(303): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 2)
                v20 = 2;
              else
                v20 = v14;
              if ((sub_100085260(a1, "perHostNumFences_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: perHostNumFences(303): Cannot add 2 elements to context";
              goto LABEL_2228;
            case 304:
              if ((_DWORD)v14 != 10)
                sub_1000756A0("ASPFTLParseBufferToCxt: commitPadSectorsPerFlow(304): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0xA)
                v20 = 10;
              else
                v20 = v14;
              if ((sub_100085260(a1, "commitPadSectorsPerFlow_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: commitPadSectorsPerFlow(304): Cannot add 10 elements to context";
              goto LABEL_2228;
            case 305:
              if ((_DWORD)v14 != 10)
                sub_1000756A0("ASPFTLParseBufferToCxt: wcacheDSOverWrLogSizeCnts(305): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0xA)
                v20 = 10;
              else
                v20 = v14;
              if ((sub_100085260(a1, "wcacheDSOverWrLogSizeCnts_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: wcacheDSOverWrLogSizeCnts(305): Cannot add 10 elements to context";
              goto LABEL_2228;
            case 306:
              if ((_DWORD)v14 != 4)
                sub_1000756A0("ASPFTLParseBufferToCxt: wcacheDSOverWrSizeByFlow(306): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 4)
                v20 = 4;
              else
                v20 = v14;
              if ((sub_100085260(a1, "wcacheDSOverWrSizeByFlow_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: wcacheDSOverWrSizeByFlow(306): Cannot add 4 elements to context";
              goto LABEL_2228;
            case 307:
              if ((_DWORD)v14 != 10)
                sub_1000756A0("ASPFTLParseBufferToCxt: CmdRaisePrioiryEvents(307): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0xA)
                v20 = 10;
              else
                v20 = v14;
              if ((sub_100085260(a1, "CmdRaisePrioiryEvents_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: CmdRaisePrioiryEvents(307): Cannot add 10 elements to context";
              goto LABEL_2228;
            case 308:
              if ((sub_100085260(a1, "utilNumVerification", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: utilNumVerification(308) cannot add 1 element to context";
              goto LABEL_15;
            case 309:
              if ((sub_100085260(a1, "utilRefreshes", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: utilRefreshes(309) cannot add 1 element to context";
              goto LABEL_15;
            case 310:
              if ((sub_100085260(a1, "utilBDRErrors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: utilBDRErrors(310) cannot add 1 element to context";
              goto LABEL_15;
            case 311:
              if ((sub_100085260(a1, "indBandsPerFlow", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: indBandsPerFlow(311) cannot add 1 element to context";
              goto LABEL_15;
            case 312:
              if ((sub_100085260(a1, "secsPerIndFlow", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: secsPerIndFlow(312) cannot add 1 element to context";
              goto LABEL_15;
            case 313:
              if ((sub_100085260(a1, "indDecodedECC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: indDecodedECC(313) cannot add 1 element to context";
              goto LABEL_15;
            case 314:
              if ((_DWORD)v14 != 8)
                sub_1000756A0("ASPFTLParseBufferToCxt: numBootBlockValidateSuccess(314): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 8)
                v20 = 8;
              else
                v20 = v14;
              if ((sub_100085260(a1, "numBootBlockValidateSuccess_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: numBootBlockValidateSuccess(314): Cannot add 8 elements to context";
              goto LABEL_2228;
            case 315:
              if ((_DWORD)v14 != 8)
                sub_1000756A0("ASPFTLParseBufferToCxt: numBootBlockValidateFail(315): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 8)
                v20 = 8;
              else
                v20 = v14;
              if ((sub_100085260(a1, "numBootBlockValidateFail_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: numBootBlockValidateFail(315): Cannot add 8 elements to context";
              goto LABEL_2228;
            case 316:
              if ((_DWORD)v14 != 4)
                sub_1000756A0("ASPFTLParseBufferToCxt: clogPagesFillingPercentage(316): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 4)
                v20 = 4;
              else
                v20 = v14;
              if ((sub_100085260(a1, "clogPagesFillingPercentage_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: clogPagesFillingPercentage(316): Cannot add 4 elements to context";
              goto LABEL_2228;
            case 317:
              if ((sub_100085260(a1, "bdrCalTimeAccFactor", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: bdrCalTimeAccFactor(317) cannot add 1 element to context";
              goto LABEL_15;
            case 318:
              if ((sub_100085260(a1, "bootChainRdError", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: bootChainRdError(318) cannot add 1 element to context";
              goto LABEL_15;
            case 319:
              if ((sub_100085260(a1, "bootChainBlankError", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: bootChainBlankError(319) cannot add 1 element to context";
              goto LABEL_15;
            case 320:
              if ((sub_100085260(a1, "bootChainRefreshError", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: bootChainRefreshError(320) cannot add 1 element to context";
              goto LABEL_15;
            case 321:
              if ((sub_100085260(a1, "bootChainVersionError", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: bootChainVersionError(321) cannot add 1 element to context";
              goto LABEL_15;
            case 322:
              if ((sub_100085260(a1, "mspBootBlockMismatch", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: mspBootBlockMismatch(322) cannot add 1 element to context";
              goto LABEL_15;
            case 323:
              if ((sub_100085260(a1, "mspBootBlockMismatchErr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: mspBootBlockMismatchErr(323) cannot add 1 element to context";
              goto LABEL_15;
            case 324:
              if ((_DWORD)v14 != 5)
                sub_1000756A0("ASPFTLParseBufferToCxt: bitflipAddr(324): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 5)
                v20 = 5;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bitflipAddr_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bitflipAddr(324): Cannot add 5 elements to context";
              goto LABEL_2228;
            case 325:
              if ((_DWORD)v14 != 5)
                sub_1000756A0("ASPFTLParseBufferToCxt: bitflipCount(325): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 5)
                v20 = 5;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bitflipCount_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bitflipCount(325): Cannot add 5 elements to context";
              goto LABEL_2228;
            case 326:
              if ((_DWORD)v14 != 5)
                sub_1000756A0("ASPFTLParseBufferToCxt: bitflipDupes(326): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 5)
                v20 = 5;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bitflipDupes_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bitflipDupes(326): Cannot add 5 elements to context";
              goto LABEL_2228;
            case 327:
              if ((_DWORD)v14 != 22)
                sub_1000756A0("ASPFTLParseBufferToCxt: bandsMaxTempHisto(327): (#22) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0x16)
                v20 = 22;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bandsMaxTempHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bandsMaxTempHisto(327): Cannot add 22 elements to context";
              goto LABEL_2228;
            case 328:
              if ((_DWORD)v14 != 22)
                sub_1000756A0("ASPFTLParseBufferToCxt: bandsMinTempHisto(328): (#22) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0x16)
                v20 = 22;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bandsMinTempHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bandsMinTempHisto(328): Cannot add 22 elements to context";
              goto LABEL_2228;
            case 329:
              if ((_DWORD)v14 != 30)
                sub_1000756A0("ASPFTLParseBufferToCxt: bandsLifeTimeTempHisto(329): (#30) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0x1E)
                v20 = 30;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bandsLifeTimeTempHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bandsLifeTimeTempHisto(329): Cannot add 30 elements to context";
              goto LABEL_2228;
            case 330:
              if ((_DWORD)v14 != 22)
                sub_1000756A0("ASPFTLParseBufferToCxt: bandsDeltaTempHisto(330): (#22) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0x16)
                v20 = 22;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bandsDeltaTempHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bandsDeltaTempHisto(330): Cannot add 22 elements to context";
              goto LABEL_2228;
            case 331:
              if ((_DWORD)v14 != 45)
                sub_1000756A0("ASPFTLParseBufferToCxt: bandsCrossTempHisto(331): (#45) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0x2D)
                v20 = 45;
              else
                v20 = v14;
              if ((sub_100085260(a1, "bandsCrossTempHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: bandsCrossTempHisto(331): Cannot add 45 elements to context";
              goto LABEL_2228;
            case 332:
              if ((_DWORD)v14 != 10)
                sub_1000756A0("ASPFTLParseBufferToCxt: wcacheWaitLogMs(332): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0xA)
                v20 = 10;
              else
                v20 = v14;
              if ((sub_100085260(a1, "wcacheWaitLogMs_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: wcacheWaitLogMs(332): Cannot add 10 elements to context";
              goto LABEL_2228;
            case 333:
              if ((_DWORD)v14 != 10)
                sub_1000756A0("ASPFTLParseBufferToCxt: wcacheDS_segsSortedLogSize(333): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0xA)
                v20 = 10;
              else
                v20 = v14;
              if ((sub_100085260(a1, "wcacheDS_segsSortedLogSize_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: wcacheDS_segsSortedLogSize(333): Cannot add 10 elements to context";
              goto LABEL_2228;
            case 334:
              if ((sub_100085260(a1, "numFirmwareWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: numFirmwareWrites(334) cannot add 1 element to context";
              goto LABEL_15;
            case 335:
              if ((sub_100085260(a1, "numBisWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: numBisWrites(335) cannot add 1 element to context";
              goto LABEL_15;
            case 336:
              if ((sub_100085260(a1, "numBootChainUpdates", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: numBootChainUpdates(336) cannot add 1 element to context";
              goto LABEL_15;
            case 337:
              if ((sub_100085260(a1, "cntCalTimeWentBackWard", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: cntCalTimeWentBackWard(337) cannot add 1 element to context";
              goto LABEL_15;
            case 338:
              if ((sub_100085260(a1, "indBoRecoveries", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: indBoRecoveries(338) cannot add 1 element to context";
              goto LABEL_15;
            case 340:
              if ((sub_100085260(a1, "numCrossTempUecc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: numCrossTempUecc(340) cannot add 1 element to context";
              goto LABEL_15;
            case 341:
              if ((sub_100085260(a1, "latencyMonitorError", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: latencyMonitorError(341) cannot add 1 element to context";
              goto LABEL_15;
            case 343:
              if ((sub_100085260(a1, "utilUeccReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: utilUeccReads(343) cannot add 1 element to context";
              goto LABEL_15;
            case 344:
              if ((sub_100085260(a1, "numOfAvoidedGCDueToTemp", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: numOfAvoidedGCDueToTemp(344) cannot add 1 element to context";
              goto LABEL_15;
            case 345:
              if ((sub_100085260(a1, "forceShutdowns", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: forceShutdowns(345) cannot add 1 element to context";
              goto LABEL_15;
            case 346:
              if ((sub_100085260(a1, "gcSlcDestinations", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: gcSlcDestinations(346) cannot add 1 element to context";
              goto LABEL_15;
            case 347:
              if ((sub_100085260(a1, "indReplayExtUsed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: indReplayExtUsed(347) cannot add 1 element to context";
              goto LABEL_15;
            case 348:
              if ((sub_100085260(a1, "defectsPerPackageOverflow", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: defectsPerPackageOverflow(348) cannot add 1 element to context";
              goto LABEL_15;
            case 349:
              if ((sub_100085260(a1, "RxBurnIntBandsProgrammed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: RxBurnIntBandsProgrammed(349) cannot add 1 element to context";
              goto LABEL_15;
            case 350:
              if ((sub_100085260(a1, "RxBurnUsrBandsProgrammed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: RxBurnUsrBandsProgrammed(350) cannot add 1 element to context";
              goto LABEL_15;
            case 351:
              if ((sub_100085260(a1, "RxBurnIntNandWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: RxBurnIntNandWrites(351) cannot add 1 element to context";
              goto LABEL_15;
            case 352:
              if ((sub_100085260(a1, "RxBurnUsrNandWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: RxBurnUsrNandWrites(352) cannot add 1 element to context";
              goto LABEL_15;
            case 353:
              if ((sub_100085260(a1, "clogLastStripeUeccs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: clogLastStripeUeccs(353) cannot add 1 element to context";
              goto LABEL_15;
            case 354:
              if ((sub_100085260(a1, "GC_MidDestSrcSwitchSLC2TLC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: GC_MidDestSrcSwitchSLC2TLC(354) cannot add 1 element to context";
              goto LABEL_15;
            case 355:
              if ((sub_100085260(a1, "GC_MidDestSrcSwitchTLC2SLC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: GC_MidDestSrcSwitchTLC2SLC(355) cannot add 1 element to context";
              goto LABEL_15;
            case 356:
              if ((sub_100085260(a1, "nvme_stats_shutdown_count_host0_normal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: nvme_stats_shutdown_count_host0_normal(356) cannot add 1 element to context";
              goto LABEL_15;
            case 357:
              if ((sub_100085260(a1, "nvme_stats_shutdown_count_host1_normal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: nvme_stats_shutdown_count_host1_normal(357) cannot add 1 element to context";
              goto LABEL_15;
            case 358:
              if ((sub_100085260(a1, "nvme_stats_shutdown_count_host0_s2r", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: nvme_stats_shutdown_count_host0_s2r(358) cannot add 1 element to context";
              goto LABEL_15;
            case 359:
              if ((sub_100085260(a1, "nvme_stats_shutdown_count_host1_s2r", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: nvme_stats_shutdown_count_host1_s2r(359) cannot add 1 element to context";
              goto LABEL_15;
            case 360:
              if ((_DWORD)v14 != 16)
                sub_1000756A0("ASPFTLParseBufferToCxt: gcPDusterIntrSrcValidityHisto(360): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0x10)
                v20 = 16;
              else
                v20 = v14;
              if ((sub_100085260(a1, "gcPDusterIntrSrcValidityHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: gcPDusterIntrSrcValidityHisto(360): Cannot add 16 elements to context";
              goto LABEL_2228;
            case 361:
              if ((_DWORD)v14 != 16)
                sub_1000756A0("ASPFTLParseBufferToCxt: gcPDusterUserSrcValidityHisto(361): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
              if (v14 >= 0x10)
                v20 = 16;
              else
                v20 = v14;
              if ((sub_100085260(a1, "gcPDusterUserSrcValidityHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                goto LABEL_14;
              v22 = "ASPFTLParseBufferToCxt: gcPDusterUserSrcValidityHisto(361): Cannot add 16 elements to context";
              goto LABEL_2228;
            case 362:
              if ((sub_100085260(a1, "raidFailedReadParity", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: raidFailedReadParity(362) cannot add 1 element to context";
              goto LABEL_15;
            case 364:
              if ((sub_100085260(a1, "lhotNumSkipes", (uint64_t)v8, 8u, 1u) & 1) != 0)
                goto LABEL_16;
              v19 = "ASPFTLParseBufferToCxt: lhotNumSkipes(364) cannot add 1 element to context";
              goto LABEL_15;
            default:
              switch(v12)
              {
                case 365:
                  if ((sub_100085260(a1, "lhotNumIsHotCalls", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: lhotNumIsHotCalls(365) cannot add 1 element to context";
                  goto LABEL_15;
                case 366:
                  if ((sub_100085260(a1, "lhotFullLap", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: lhotFullLap(366) cannot add 1 element to context";
                  goto LABEL_15;
                case 367:
                  if ((sub_100085260(a1, "lhotSkipPrecent", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: lhotSkipPrecent(367) cannot add 1 element to context";
                  goto LABEL_15;
                case 368:
                  if ((sub_100085260(a1, "eraseSuspendEvents", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: eraseSuspendEvents(368) cannot add 1 element to context";
                  goto LABEL_15;
                case 369:
                  if ((sub_100085260(a1, "eraseSuspendedStatuses", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: eraseSuspendedStatuses(369) cannot add 1 element to context";
                  goto LABEL_15;
                case 370:
                  if ((sub_100085260(a1, "eraseSuspendedBands", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: eraseSuspendedBands(370) cannot add 1 element to context";
                  goto LABEL_15;
                case 371:
                  if ((sub_100085260(a1, "eraseSuspendSituationsBelowThreshold", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: eraseSuspendSituationsBelowThreshold(371) cannot add 1 element to context";
                  goto LABEL_15;
                case 372:
                  if ((sub_100085260(a1, "eraseSuspendSituationsAboveThreshold", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: eraseSuspendSituationsAboveThreshold(372) cannot add 1 element to context";
                  goto LABEL_15;
                case 373:
                  if ((sub_100085260(a1, "eraseSuspendReadChainsProcessed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: eraseSuspendReadChainsProcessed(373) cannot add 1 element to context";
                  goto LABEL_15;
                case 374:
                  if ((sub_100085260(a1, "bdrLastDoneHr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: bdrLastDoneHr(374) cannot add 1 element to context";
                  goto LABEL_15;
                case 375:
                  if ((sub_100085260(a1, "bdrBackupThreshHrs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: bdrBackupThreshHrs(375) cannot add 1 element to context";
                  goto LABEL_15;
                case 376:
                  if ((sub_100085260(a1, "clogPortableProgBufs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: clogPortableProgBufs(376) cannot add 1 element to context";
                  goto LABEL_15;
                case 377:
                  if ((sub_100085260(a1, "clogPortableDropBufs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: clogPortableDropBufs(377) cannot add 1 element to context";
                  goto LABEL_15;
                case 378:
                  if ((sub_100085260(a1, "clogPortablePadSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: clogPortablePadSectors(378) cannot add 1 element to context";
                  goto LABEL_15;
                case 379:
                  if ((sub_100085260(a1, "numRetiredBlocks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: numRetiredBlocks(379) cannot add 1 element to context";
                  goto LABEL_15;
                case 381:
                  if ((sub_100085260(a1, "numRefreshOnErrNandRefreshPerf", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: numRefreshOnErrNandRefreshPerf(381) cannot add 1 element to context";
                  goto LABEL_15;
                case 382:
                  if ((sub_100085260(a1, "raidReconstructReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidReconstructReads(382) cannot add 1 element to context";
                  goto LABEL_15;
                case 383:
                  if ((sub_100085260(a1, "gcReadsNoBlog", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: gcReadsNoBlog(383) cannot add 1 element to context";
                  goto LABEL_15;
                case 384:
                  if ((sub_100085260(a1, "AbortSkip_MPBXReadVerifyClosedBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: AbortSkip_MPBXReadVerifyClosedBand(384) cannot add 1 element to context";
                  goto LABEL_15;
                case 385:
                  if ((sub_100085260(a1, "openBandReadFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: openBandReadFail(385) cannot add 1 element to context";
                  goto LABEL_15;
                case 386:
                  if ((sub_100085260(a1, "AbortSkip_MPBXReadVerifyOpenBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: AbortSkip_MPBXReadVerifyOpenBand(386) cannot add 1 element to context";
                  goto LABEL_15;
                case 387:
                  if ((sub_100085260(a1, "AbortSkip_MBPXFailedRebuildingParity", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: AbortSkip_MBPXFailedRebuildingParity(387) cannot add 1 element to context";
                  goto LABEL_15;
                case 388:
                  if ((sub_100085260(a1, "raidSuccessfulPMXReconstructionInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidSuccessfulPMXReconstructionInternal(388) cannot add 1 element to context";
                  goto LABEL_15;
                case 389:
                  if ((sub_100085260(a1, "raidSuccessfulPMXReconstructionHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidSuccessfulPMXReconstructionHost(389) cannot add 1 element to context";
                  goto LABEL_15;
                case 390:
                  if ((sub_100085260(a1, "raidFailedPMXReconstructionInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedPMXReconstructionInternal(390) cannot add 1 element to context";
                  goto LABEL_15;
                case 391:
                  if ((sub_100085260(a1, "raidFailedPMXReconstructionHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedPMXReconstructionHost(391) cannot add 1 element to context";
                  goto LABEL_15;
                case 392:
                  if ((sub_100085260(a1, "raidSuccessfulRMXReconstructionInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidSuccessfulRMXReconstructionInternal(392) cannot add 1 element to context";
                  goto LABEL_15;
                case 393:
                  if ((sub_100085260(a1, "raidSuccessfulRMXReconstructionHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidSuccessfulRMXReconstructionHost(393) cannot add 1 element to context";
                  goto LABEL_15;
                case 394:
                  if ((sub_100085260(a1, "raidFailedRMXReconstructionInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedRMXReconstructionInternal(394) cannot add 1 element to context";
                  goto LABEL_15;
                case 395:
                  if ((sub_100085260(a1, "raidFailedRMXReconstructionHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedRMXReconstructionHost(395) cannot add 1 element to context";
                  goto LABEL_15;
                case 396:
                  if ((sub_100085260(a1, "raidFailedReadParityInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedReadParityInternal(396) cannot add 1 element to context";
                  goto LABEL_15;
                case 397:
                  if ((sub_100085260(a1, "raidFailedReadQParityInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedReadQParityInternal(397) cannot add 1 element to context";
                  goto LABEL_15;
                case 398:
                  if ((sub_100085260(a1, "raidFailedReadQParity", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedReadQParity(398) cannot add 1 element to context";
                  goto LABEL_15;
                case 399:
                  if ((sub_100085260(a1, "raidFailedReadQCopy", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedReadQCopy(399) cannot add 1 element to context";
                  goto LABEL_15;
                case 400:
                  if ((sub_100085260(a1, "raidFailedReconstructionQParity", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedReconstructionQParity(400) cannot add 1 element to context";
                  goto LABEL_15;
                case 401:
                  if ((sub_100085260(a1, "offlineBlocksCnt", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: offlineBlocksCnt(401) cannot add 1 element to context";
                  goto LABEL_15;
                case 402:
                  if ((sub_100085260(a1, "bork0Revectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: bork0Revectors(402) cannot add 1 element to context";
                  goto LABEL_15;
                case 403:
                  if ((sub_100085260(a1, "raidFailedReadBlog", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedReadBlog(403) cannot add 1 element to context";
                  goto LABEL_15;
                case 404:
                  if ((sub_100085260(a1, "numReliabilityRefreshes", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: numReliabilityRefreshes(404) cannot add 1 element to context";
                  goto LABEL_15;
                case 405:
                  if ((sub_100085260(a1, "raidFailedReadQCopyInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedReadQCopyInternal(405) cannot add 1 element to context";
                  goto LABEL_15;
                case 406:
                  if ((_DWORD)v14 != 5)
                    sub_1000756A0("ASPFTLParseBufferToCxt: raidReconstructSuccessFlow(406): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                  if (v14 >= 5)
                    v20 = 5;
                  else
                    v20 = v14;
                  if ((sub_100085260(a1, "raidReconstructSuccessFlow_", (uint64_t)v8, 8u, v20) & 1) != 0)
                    goto LABEL_14;
                  v22 = "ASPFTLParseBufferToCxt: raidReconstructSuccessFlow(406): Cannot add 5 elements to context";
                  goto LABEL_2228;
                case 407:
                  if ((_DWORD)v14 != 5)
                    sub_1000756A0("ASPFTLParseBufferToCxt: raidReconstructFailFlow(407): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                  if (v14 >= 5)
                    v20 = 5;
                  else
                    v20 = v14;
                  if ((sub_100085260(a1, "raidReconstructFailFlow_", (uint64_t)v8, 8u, v20) & 1) != 0)
                    goto LABEL_14;
                  v22 = "ASPFTLParseBufferToCxt: raidReconstructFailFlow(407): Cannot add 5 elements to context";
                  goto LABEL_2228;
                case 408:
                  if ((sub_100085260(a1, "raidReconstructFailP", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidReconstructFailP(408) cannot add 1 element to context";
                  goto LABEL_15;
                case 409:
                  if ((sub_100085260(a1, "raidReconstructFailQ", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidReconstructFailQ(409) cannot add 1 element to context";
                  goto LABEL_15;
                case 410:
                  if ((sub_100085260(a1, "raidReconstructFailUECC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidReconstructFailUECC(410) cannot add 1 element to context";
                  goto LABEL_15;
                case 411:
                  if ((sub_100085260(a1, "raidReconstructFailUnsupp", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidReconstructFailUnsupp(411) cannot add 1 element to context";
                  goto LABEL_15;
                case 412:
                  if ((sub_100085260(a1, "raidUECCOpenBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidUECCOpenBand(412) cannot add 1 element to context";
                  goto LABEL_15;
                case 414:
                  if ((sub_100085260(a1, "ueccReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: ueccReads(414) cannot add 1 element to context";
                  goto LABEL_15;
                case 416:
                  if ((sub_100085260(a1, "raidSuccessfulVerify", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidSuccessfulVerify(416) cannot add 1 element to context";
                  goto LABEL_15;
                case 417:
                  if ((sub_100085260(a1, "raidFailedVerify", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: raidFailedVerify(417) cannot add 1 element to context";
                  goto LABEL_15;
                case 418:
                  if ((sub_100085260(a1, "numBandsVerified", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: numBandsVerified(418) cannot add 1 element to context";
                  goto LABEL_15;
                case 419:
                  if ((sub_100085260(a1, "cache_heads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: cache_heads(419) cannot add 1 element to context";
                  goto LABEL_15;
                case 420:
                  if ((sub_100085260(a1, "AbortSkip_RMXtoMPBX", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: AbortSkip_RMXtoMPBX(420) cannot add 1 element to context";
                  goto LABEL_15;
                case 421:
                  if ((sub_100085260(a1, "s3eFwVer", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: s3eFwVer(421) cannot add 1 element to context";
                  goto LABEL_15;
                case 422:
                  if ((sub_100085260(a1, "readVerifyNative", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: readVerifyNative(422) cannot add 1 element to context";
                  goto LABEL_15;
                case 423:
                  if ((sub_100085260(a1, "reducedReadVerifyNative", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: reducedReadVerifyNative(423) cannot add 1 element to context";
                  goto LABEL_15;
                case 424:
                  if ((sub_100085260(a1, "readVerifySlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: readVerifySlc(424) cannot add 1 element to context";
                  goto LABEL_15;
                case 425:
                  if ((sub_100085260(a1, "reducedReadVerifySlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: reducedReadVerifySlc(425) cannot add 1 element to context";
                  goto LABEL_15;
                case 426:
                  if ((sub_100085260(a1, "RxBurnEvictions", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: RxBurnEvictions(426) cannot add 1 element to context";
                  goto LABEL_15;
                case 427:
                  if ((sub_100085260(a1, "directToTLCBands", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: directToTLCBands(427) cannot add 1 element to context";
                  goto LABEL_15;
                case 428:
                  if ((sub_100085260(a1, "nandDesc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: nandDesc(428) cannot add 1 element to context";
                  goto LABEL_15;
                case 429:
                  if ((sub_100085260(a1, "fwUpdatesPercentUsed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: fwUpdatesPercentUsed(429) cannot add 1 element to context";
                  goto LABEL_15;
                case 430:
                  if ((sub_100085260(a1, "slcPercentUsed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: slcPercentUsed(430) cannot add 1 element to context";
                  goto LABEL_15;
                case 431:
                  if ((sub_100085260(a1, "percentUsed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                    goto LABEL_16;
                  v19 = "ASPFTLParseBufferToCxt: percentUsed(431) cannot add 1 element to context";
                  goto LABEL_15;
                default:
                  switch(v12)
                  {
                    case 432:
                      if ((sub_100085260(a1, "hostAutoWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: hostAutoWrites(432) cannot add 1 element to context";
                      goto LABEL_15;
                    case 433:
                      if ((sub_100085260(a1, "hostAutoWriteXacts", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: hostAutoWriteXacts(433) cannot add 1 element to context";
                      goto LABEL_15;
                    case 434:
                      if ((sub_100085260(a1, "gcDestDynamic", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: gcDestDynamic(434) cannot add 1 element to context";
                      goto LABEL_15;
                    case 435:
                      if ((sub_100085260(a1, "gcDestStatic", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: gcDestStatic(435) cannot add 1 element to context";
                      goto LABEL_15;
                    case 436:
                      if ((sub_100085260(a1, "gcDestWearlevel", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: gcDestWearlevel(436) cannot add 1 element to context";
                      goto LABEL_15;
                    case 437:
                      if ((sub_100085260(a1, "gcDestParity", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: gcDestParity(437) cannot add 1 element to context";
                      goto LABEL_15;
                    case 438:
                      if ((sub_100085260(a1, "AbortSkip_Format", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: AbortSkip_Format(438) cannot add 1 element to context";
                      goto LABEL_15;
                    case 440:
                      if ((sub_100085260(a1, "raidSLCPadding", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidSLCPadding(440) cannot add 1 element to context";
                      goto LABEL_15;
                    case 441:
                      if ((sub_100085260(a1, "raidGCBands", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidGCBands(441) cannot add 1 element to context";
                      goto LABEL_15;
                    case 442:
                      if ((sub_100085260(a1, "raidGCSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidGCSectors(442) cannot add 1 element to context";
                      goto LABEL_15;
                    case 443:
                      if ((sub_100085260(a1, "raidGCPadding", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidGCPadding(443) cannot add 1 element to context";
                      goto LABEL_15;
                    case 444:
                      if ((sub_100085260(a1, "raidSLCBandsPerHostFlow", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidSLCBandsPerHostFlow(444) cannot add 1 element to context";
                      goto LABEL_15;
                    case 445:
                      if ((sub_100085260(a1, "raidSLCSecsPerHostFlow", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidSLCSecsPerHostFlow(445) cannot add 1 element to context";
                      goto LABEL_15;
                    case 446:
                      if ((sub_100085260(a1, "rxBurnMinCycleRuns", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: rxBurnMinCycleRuns(446) cannot add 1 element to context";
                      goto LABEL_15;
                    case 447:
                      if ((sub_100085260(a1, "clogNumFastCxt", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: clogNumFastCxt(447) cannot add 1 element to context";
                      goto LABEL_15;
                    case 448:
                      if ((sub_100085260(a1, "clogNumRapidReboots", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: clogNumRapidReboots(448) cannot add 1 element to context";
                      goto LABEL_15;
                    case 449:
                      if ((sub_100085260(a1, "clogFastCxtAbvThr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: clogFastCxtAbvThr(449) cannot add 1 element to context";
                      goto LABEL_15;
                    case 450:
                      if ((sub_100085260(a1, "rxBurnDiffModeRuns", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: rxBurnDiffModeRuns(450) cannot add 1 element to context";
                      goto LABEL_15;
                    case 452:
                      if ((sub_100085260(a1, "indReadVerifyFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: indReadVerifyFail(452) cannot add 1 element to context";
                      goto LABEL_15;
                    case 453:
                      if ((_DWORD)v14 != 16)
                        sub_1000756A0("ASPFTLParseBufferToCxt: numOfThrottlingEntriesPerReadLevel(453): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0x10)
                        v20 = 16;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "numOfThrottlingEntriesPerReadLevel_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: numOfThrottlingEntriesPerReadLevel(453): Cannot add 16 elements to context";
                      goto LABEL_2228;
                    case 454:
                      if ((_DWORD)v14 != 16)
                        sub_1000756A0("ASPFTLParseBufferToCxt: numOfThrottlingEntriesPerWriteLevel(454): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0x10)
                        v20 = 16;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "numOfThrottlingEntriesPerWriteLevel_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: numOfThrottlingEntriesPerWriteLevel(454): Cannot add 16 elements to context";
                      goto LABEL_2228;
                    case 456:
                      if ((_DWORD)v14 != 10)
                        sub_1000756A0("ASPFTLParseBufferToCxt: slcFifoDepth(456): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0xA)
                        v20 = 10;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "slcFifoDepth_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: slcFifoDepth(456): Cannot add 10 elements to context";
                      goto LABEL_2228;
                    case 457:
                      if ((sub_100085260(a1, "wcacheSectorsDirtyIdle", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: wcacheSectorsDirtyIdle(457) cannot add 1 element to context";
                      goto LABEL_15;
                    case 458:
                      if ((sub_100085260(a1, "wcacheDS_SectorsDirtyIdle", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: wcacheDS_SectorsDirtyIdle(458) cannot add 1 element to context";
                      goto LABEL_15;
                    case 459:
                      if ((sub_100085260(a1, "wcacheFS_MbytesDirtyIdle", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: wcacheFS_MbytesDirtyIdle(459) cannot add 1 element to context";
                      goto LABEL_15;
                    case 460:
                      if ((_DWORD)v14 != 256)
                        sub_1000756A0("ASPFTLParseBufferToCxt: CacheDepthVsThroughput(460): (#256) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0x100)
                        v20 = 256;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "CacheDepthVsThroughput_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: CacheDepthVsThroughput(460): Cannot add 256 elements to context";
                      goto LABEL_2228;
                    case 461:
                      if ((sub_100085260(a1, "directToTLCSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: directToTLCSectors(461) cannot add 1 element to context";
                      goto LABEL_15;
                    case 462:
                      if ((sub_100085260(a1, "fallbackToWaterfall", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: fallbackToWaterfall(462) cannot add 1 element to context";
                      goto LABEL_15;
                    case 463:
                      if ((_DWORD)v14 != 11)
                        sub_1000756A0("ASPFTLParseBufferToCxt: balanceProportionBucketsHistogram(463): (#11) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0xB)
                        v20 = 11;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "balanceProportionBucketsHistogram_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: balanceProportionBucketsHistogram(463): Cannot add 11 elements to context";
                      goto LABEL_2228;
                    case 464:
                      if ((sub_100085260(a1, "lockToTlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: lockToTlc(464) cannot add 1 element to context";
                      goto LABEL_15;
                    case 465:
                      if ((_DWORD)v14 != 10)
                        sub_1000756A0("ASPFTLParseBufferToCxt: burstSizeHistogram(465): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0xA)
                        v20 = 10;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "burstSizeHistogram_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: burstSizeHistogram(465): Cannot add 10 elements to context";
                      goto LABEL_2228;
                    case 466:
                      if ((_DWORD)v14 != 64)
                        sub_1000756A0("ASPFTLParseBufferToCxt: qosDirectToTLC(466): (#64) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0x40)
                        v20 = 64;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "qosDirectToTLC_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: qosDirectToTLC(466): Cannot add 64 elements to context";
                      goto LABEL_2228;
                    case 467:
                      if ((_DWORD)v14 != 4)
                        sub_1000756A0("ASPFTLParseBufferToCxt: maxQosDirectToTLC(467): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 4)
                        v20 = 4;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "maxQosDirectToTLC_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: maxQosDirectToTLC(467): Cannot add 4 elements to context";
                      goto LABEL_2228;
                    case 468:
                      if ((_DWORD)v14 != 16)
                        sub_1000756A0("ASPFTLParseBufferToCxt: wcacheDirtyAtFlush(468): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0x10)
                        v20 = 16;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "wcacheDirtyAtFlush_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: wcacheDirtyAtFlush(468): Cannot add 16 elements to context";
                      goto LABEL_2228;
                    case 469:
                      if ((_DWORD)v14 != 2)
                        sub_1000756A0("ASPFTLParseBufferToCxt: raidReconstructSuccessPartition(469): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 2)
                        v20 = 2;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "raidReconstructSuccessPartition_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: raidReconstructSuccessPartition(469): Cannot add 2 elements to context";
                      goto LABEL_2228;
                    case 470:
                      if ((_DWORD)v14 != 2)
                        sub_1000756A0("ASPFTLParseBufferToCxt: raidReconstructFailPartition(470): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 2)
                        v20 = 2;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "raidReconstructFailPartition_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: raidReconstructFailPartition(470): Cannot add 2 elements to context";
                      goto LABEL_2228;
                    case 471:
                      if ((sub_100085260(a1, "raidUncleanBootBandFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidUncleanBootBandFail(471) cannot add 1 element to context";
                      goto LABEL_15;
                    case 472:
                      if ((sub_100085260(a1, "raidReconstructFailBandFlowHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBandFlowHost(472) cannot add 1 element to context";
                      goto LABEL_15;
                    case 473:
                      if ((sub_100085260(a1, "raidReconstructFailBandFlowGC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBandFlowGC(473) cannot add 1 element to context";
                      goto LABEL_15;
                    case 476:
                      if ((_DWORD)v14 != 2)
                        sub_1000756A0("ASPFTLParseBufferToCxt: raidSuccessfulRecoLbaRange(476): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 2)
                        v20 = 2;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "raidSuccessfulRecoLbaRange_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: raidSuccessfulRecoLbaRange(476): Cannot add 2 elements to context";
                      goto LABEL_2228;
                    case 477:
                      if ((_DWORD)v14 != 2)
                        sub_1000756A0("ASPFTLParseBufferToCxt: raidFailedRecoLbaRange(477): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 2)
                        v20 = 2;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "raidFailedRecoLbaRange_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: raidFailedRecoLbaRange(477): Cannot add 2 elements to context";
                      goto LABEL_2228;
                    case 481:
                      if ((_DWORD)v14 != 32)
                        sub_1000756A0("ASPFTLParseBufferToCxt: skinnyBandErases_481(481): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0x20)
                        v20 = 32;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "skinnyBandErases_481_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: skinnyBandErases_481(481): Cannot add 32 elements to context";
                      goto LABEL_2228;
                    case 483:
                      if ((sub_100085260(a1, "tlcOverHeatWaterfall", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: tlcOverHeatWaterfall(483) cannot add 1 element to context";
                      goto LABEL_15;
                    case 484:
                      if ((sub_100085260(a1, "skinnyCyclesConvert", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: skinnyCyclesConvert(484) cannot add 1 element to context";
                      goto LABEL_15;
                    case 485:
                      if ((sub_100085260(a1, "non_proportional_directToTLCSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: non_proportional_directToTLCSectors(485) cannot add 1 element to context";
                      goto LABEL_15;
                    case 486:
                      if ((sub_100085260(a1, "maxFailedFastCxtSync", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: maxFailedFastCxtSync(486) cannot add 1 element to context";
                      goto LABEL_15;
                    case 487:
                      if ((sub_100085260(a1, "numFormatUserArea", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: numFormatUserArea(487) cannot add 1 element to context";
                      goto LABEL_15;
                    case 488:
                      if ((sub_100085260(a1, "clogFastCxtSyncAborted", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: clogFastCxtSyncAborted(488) cannot add 1 element to context";
                      goto LABEL_15;
                    case 489:
                      if ((_DWORD)v14 != 5)
                        sub_1000756A0("ASPFTLParseBufferToCxt: clogOccupationSectors(489): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 5)
                        v20 = 5;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "clogOccupationSectors_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: clogOccupationSectors(489): Cannot add 5 elements to context";
                      goto LABEL_2228;
                    case 490:
                      if ((_DWORD)v14 != 64)
                        sub_1000756A0("ASPFTLParseBufferToCxt: bdrTmpHist(490): (#64) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 0x40)
                        v20 = 64;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "bdrTmpHist_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: bdrTmpHist(490): Cannot add 64 elements to context";
                      goto LABEL_2228;
                    case 491:
                      if ((sub_100085260(a1, "numFWUpdates", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: numFWUpdates(491) cannot add 1 element to context";
                      goto LABEL_15;
                    case 492:
                      if ((sub_100085260(a1, "numClogLoadFails", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: numClogLoadFails(492) cannot add 1 element to context";
                      goto LABEL_15;
                    case 493:
                      if ((sub_100085260(a1, "rxBurnNumForcedDiffMode", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: rxBurnNumForcedDiffMode(493) cannot add 1 element to context";
                      goto LABEL_15;
                    case 494:
                      if ((sub_100085260(a1, "RD_numSaves", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: RD_numSaves(494) cannot add 1 element to context";
                      goto LABEL_15;
                    case 495:
                      if ((sub_100085260(a1, "eanCompressWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: eanCompressWrites(495) cannot add 1 element to context";
                      goto LABEL_15;
                    case 496:
                      if ((sub_100085260(a1, "eanHostWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: eanHostWrites(496) cannot add 1 element to context";
                      goto LABEL_15;
                    case 497:
                      if ((sub_100085260(a1, "bandPreErases", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: bandPreErases(497) cannot add 1 element to context";
                      goto LABEL_15;
                    case 498:
                      if ((sub_100085260(a1, "eanHostUnmaps", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: eanHostUnmaps(498) cannot add 1 element to context";
                      goto LABEL_15;
                    case 499:
                      if ((sub_100085260(a1, "eanHostFlushes", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: eanHostFlushes(499) cannot add 1 element to context";
                      goto LABEL_15;
                    case 500:
                      if ((sub_100085260(a1, "eanFastWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: eanFastWrites(500) cannot add 1 element to context";
                      goto LABEL_15;
                    case 501:
                      if ((sub_100085260(a1, "autowriteDS2FSCollisions", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: autowriteDS2FSCollisions(501) cannot add 1 element to context";
                      goto LABEL_15;
                    case 502:
                      if ((sub_100085260(a1, "autowriteWaitTransferTaskBlocks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: autowriteWaitTransferTaskBlocks(502) cannot add 1 element to context";
                      goto LABEL_15;
                    case 503:
                      if ((_DWORD)v14 != 2)
                        sub_1000756A0("ASPFTLParseBufferToCxt: avgCycle(503): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                      if (v14 >= 2)
                        v20 = 2;
                      else
                        v20 = v14;
                      if ((sub_100085260(a1, "avgCycle_", (uint64_t)v8, 8u, v20) & 1) != 0)
                        goto LABEL_14;
                      v22 = "ASPFTLParseBufferToCxt: avgCycle(503): Cannot add 2 elements to context";
                      goto LABEL_2228;
                    case 504:
                      if ((sub_100085260(a1, "RD_DeferredClearsOverflowCnt", (uint64_t)v8, 8u, 1u) & 1) != 0)
                        goto LABEL_16;
                      v19 = "ASPFTLParseBufferToCxt: RD_DeferredClearsOverflowCnt(504) cannot add 1 element to context";
                      goto LABEL_15;
                    default:
                      switch(v12)
                      {
                        case 505:
                          if ((sub_100085260(a1, "maxVerticsInBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: maxVerticsInBand(505) cannot add 1 element to context";
                          goto LABEL_15;
                        case 506:
                          if ((sub_100085260(a1, "numVertics", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: numVertics(506) cannot add 1 element to context";
                          goto LABEL_15;
                        case 507:
                          if ((sub_100085260(a1, "exceededCVertics", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: exceededCVertics(507) cannot add 1 element to context";
                          goto LABEL_15;
                        case 510:
                          if ((sub_100085260(a1, "raidReconstructFailMismatch", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidReconstructFailMismatch(510) cannot add 1 element to context";
                          goto LABEL_15;
                        case 511:
                          if ((_DWORD)v14 != 32)
                            sub_1000756A0("ASPFTLParseBufferToCxt: mspbootBlockRefreshCnt(511): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                          if (v14 >= 0x20)
                            v20 = 32;
                          else
                            v20 = v14;
                          if ((sub_100085260(a1, "mspbootBlockRefreshCnt_", (uint64_t)v8, 8u, v20) & 1) != 0)
                            goto LABEL_14;
                          v22 = "ASPFTLParseBufferToCxt: mspbootBlockRefreshCnt(511): Cannot add 32 elements to context";
                          goto LABEL_2228;
                        case 516:
                          if ((_DWORD)v14 != 32)
                            sub_1000756A0("ASPFTLParseBufferToCxt: mspBootBlockRefreshTime(516): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                          if (v14 >= 0x20)
                            v20 = 32;
                          else
                            v20 = v14;
                          if ((sub_100085260(a1, "mspBootBlockRefreshTime_", (uint64_t)v8, 8u, v20) & 1) != 0)
                            goto LABEL_14;
                          v22 = "ASPFTLParseBufferToCxt: mspBootBlockRefreshTime(516): Cannot add 32 elements to context";
                          goto LABEL_2228;
                        case 517:
                          if ((sub_100085260(a1, "mspBootBlockCountPerMsp", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: mspBootBlockCountPerMsp(517) cannot add 1 element to context";
                          goto LABEL_15;
                        case 518:
                          if ((sub_100085260(a1, "skinnyRevectorSLC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: skinnyRevectorSLC(518) cannot add 1 element to context";
                          goto LABEL_15;
                        case 519:
                          if ((sub_100085260(a1, "skinnyRevectorTLC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: skinnyRevectorTLC(519) cannot add 1 element to context";
                          goto LABEL_15;
                        case 520:
                          if ((sub_100085260(a1, "perfSetupAttempts", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfSetupAttempts(520) cannot add 1 element to context";
                          goto LABEL_15;
                        case 521:
                          if ((sub_100085260(a1, "perfSetupSuccesses", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfSetupSuccesses(521) cannot add 1 element to context";
                          goto LABEL_15;
                        case 522:
                          if ((sub_100085260(a1, "perfWriteAttempts", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfWriteAttempts(522) cannot add 1 element to context";
                          goto LABEL_15;
                        case 523:
                          if ((sub_100085260(a1, "perfWriteSuccesses", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfWriteSuccesses(523) cannot add 1 element to context";
                          goto LABEL_15;
                        case 524:
                          if ((sub_100085260(a1, "perfReadAttempts", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfReadAttempts(524) cannot add 1 element to context";
                          goto LABEL_15;
                        case 525:
                          if ((sub_100085260(a1, "perfReadSuccesses", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfReadSuccesses(525) cannot add 1 element to context";
                          goto LABEL_15;
                        case 526:
                          if ((sub_100085260(a1, "perfCleanupAttempts", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfCleanupAttempts(526) cannot add 1 element to context";
                          goto LABEL_15;
                        case 527:
                          if ((sub_100085260(a1, "perfCleanupSuccesses", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: perfCleanupSuccesses(527) cannot add 1 element to context";
                          goto LABEL_15;
                        case 530:
                          if ((sub_100085260(a1, "firstFailedDieId", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: firstFailedDieId(530) cannot add 1 element to context";
                          goto LABEL_15;
                        case 531:
                          if ((sub_100085260(a1, "numDieFailures", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: numDieFailures(531) cannot add 1 element to context";
                          goto LABEL_15;
                        case 532:
                          if ((sub_100085260(a1, "spareAvailablePercent", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: spareAvailablePercent(532) cannot add 1 element to context";
                          goto LABEL_15;
                        case 533:
                          if ((sub_100085260(a1, "dataFabricErr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: dataFabricErr(533) cannot add 1 element to context";
                          goto LABEL_15;
                        case 534:
                          if ((sub_100085260(a1, "downlinkFabricErr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: downlinkFabricErr(534) cannot add 1 element to context";
                          goto LABEL_15;
                        case 535:
                          if ((sub_100085260(a1, "prpAccTimeoutErr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: prpAccTimeoutErr(535) cannot add 1 element to context";
                          goto LABEL_15;
                        case 537:
                          if ((sub_100085260(a1, "uplinkFabricErr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: uplinkFabricErr(537) cannot add 1 element to context";
                          goto LABEL_15;
                        case 538:
                          if ((sub_100085260(a1, "skinnyBandsGBB", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: skinnyBandsGBB(538) cannot add 1 element to context";
                          goto LABEL_15;
                        case 539:
                          if ((sub_100085260(a1, "AbortPad_GcMustPadBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: AbortPad_GcMustPadBand(539) cannot add 1 element to context";
                          goto LABEL_15;
                        case 540:
                          if ((sub_100085260(a1, "AbortPad_GcMustPadSkinny", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: AbortPad_GcMustPadSkinny(540) cannot add 1 element to context";
                          goto LABEL_15;
                        case 541:
                          if ((sub_100085260(a1, "bdrHostPingInitial", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: bdrHostPingInitial(541) cannot add 1 element to context";
                          goto LABEL_15;
                        case 542:
                          if ((sub_100085260(a1, "bdrHostPingMoreNeeded", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: bdrHostPingMoreNeeded(542) cannot add 1 element to context";
                          goto LABEL_15;
                        case 543:
                          if ((sub_100085260(a1, "bandParityAllocationFailed", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: bandParityAllocationFailed(543) cannot add 1 element to context";
                          goto LABEL_15;
                        case 544:
                          if ((sub_100085260(a1, "fastHwBurstToSlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: fastHwBurstToSlc(544) cannot add 1 element to context";
                          goto LABEL_15;
                        case 545:
                          if ((sub_100085260(a1, "slowHwToTlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: slowHwToTlc(545) cannot add 1 element to context";
                          goto LABEL_15;
                        case 546:
                          if ((_DWORD)v14 != 10)
                            sub_1000756A0("ASPFTLParseBufferToCxt: slcDemandBurstSizeDetected(546): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                          if (v14 >= 0xA)
                            v20 = 10;
                          else
                            v20 = v14;
                          if ((sub_100085260(a1, "slcDemandBurstSizeDetected_", (uint64_t)v8, 8u, v20) & 1) != 0)
                            goto LABEL_14;
                          v22 = "ASPFTLParseBufferToCxt: slcDemandBurstSizeDetected(546): Cannot add 10 elements to context";
                          goto LABEL_2228;
                        case 547:
                          if ((_DWORD)v14 != 10)
                            sub_1000756A0("ASPFTLParseBufferToCxt: slcDemandBurstDur(547): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                          if (v14 >= 0xA)
                            v20 = 10;
                          else
                            v20 = v14;
                          if ((sub_100085260(a1, "slcDemandBurstDur_", (uint64_t)v8, 8u, v20) & 1) != 0)
                            goto LABEL_14;
                          v22 = "ASPFTLParseBufferToCxt: slcDemandBurstDur(547): Cannot add 10 elements to context";
                          goto LABEL_2228;
                        case 548:
                          if ((sub_100085260(a1, "fastHwToTlcBurst", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: fastHwToTlcBurst(548) cannot add 1 element to context";
                          goto LABEL_15;
                        case 549:
                          if ((_DWORD)v14 != 10)
                            sub_1000756A0("ASPFTLParseBufferToCxt: slcDemandBurstSizeSlc(549): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                          if (v14 >= 0xA)
                            v20 = 10;
                          else
                            v20 = v14;
                          if ((sub_100085260(a1, "slcDemandBurstSizeSlc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                            goto LABEL_14;
                          v22 = "ASPFTLParseBufferToCxt: slcDemandBurstSizeSlc(549): Cannot add 10 elements to context";
                          goto LABEL_2228;
                        case 551:
                          if ((_DWORD)v14 != 11)
                            sub_1000756A0("ASPFTLParseBufferToCxt: balanceProportionBucketsHistogramTlc(551): (#11) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                          if (v14 >= 0xB)
                            v20 = 11;
                          else
                            v20 = v14;
                          if ((sub_100085260(a1, "balanceProportionBucketsHistogramTlc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                            goto LABEL_14;
                          v22 = "ASPFTLParseBufferToCxt: balanceProportionBucketsHistogramTlc(551): Cannot add 11 elements to context";
                          goto LABEL_2228;
                        case 553:
                          if ((sub_100085260(a1, "slowHwFlushToSlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: slowHwFlushToSlc(553) cannot add 1 element to context";
                          goto LABEL_15;
                        case 557:
                          if ((sub_100085260(a1, "slowHwToSlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: slowHwToSlc(557) cannot add 1 element to context";
                          goto LABEL_15;
                        case 558:
                          if ((sub_100085260(a1, "flushNwToSlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: flushNwToSlc(558) cannot add 1 element to context";
                          goto LABEL_15;
                        case 559:
                          if ((sub_100085260(a1, "flushNwToTlc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: flushNwToTlc(559) cannot add 1 element to context";
                          goto LABEL_15;
                        case 560:
                          if ((sub_100085260(a1, "oslcHw", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcHw(560) cannot add 1 element to context";
                          goto LABEL_15;
                        case 561:
                          if ((sub_100085260(a1, "oslcTransitions", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcTransitions(561) cannot add 1 element to context";
                          goto LABEL_15;
                        case 563:
                          if ((sub_100085260(a1, "slcDemandFlushCount", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: slcDemandFlushCount(563) cannot add 1 element to context";
                          goto LABEL_15;
                        case 564:
                          if ((sub_100085260(a1, "slcDemandBurstCount", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: slcDemandBurstCount(564) cannot add 1 element to context";
                          goto LABEL_15;
                        case 565:
                          if ((sub_100085260(a1, "oslcBaseAvgPE", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcBaseAvgPE(565) cannot add 1 element to context";
                          goto LABEL_15;
                        case 566:
                          if ((sub_100085260(a1, "raidReconstructFailNoSPBX", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidReconstructFailNoSPBX(566) cannot add 1 element to context";
                          goto LABEL_15;
                        case 567:
                          if ((sub_100085260(a1, "raidReconstructFailDouble", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidReconstructFailDouble(567) cannot add 1 element to context";
                          goto LABEL_15;
                        case 568:
                          if ((sub_100085260(a1, "oslcFastWAmpUOnOff", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcFastWAmpUOnOff(568) cannot add 1 element to context";
                          goto LABEL_15;
                        case 569:
                          if ((sub_100085260(a1, "oslcSlowWAmpUOnOff", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcSlowWAmpUOnOff(569) cannot add 1 element to context";
                          goto LABEL_15;
                        case 570:
                          if ((sub_100085260(a1, "raidReconstructFailInvalid", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidReconstructFailInvalid(570) cannot add 1 element to context";
                          goto LABEL_15;
                        case 572:
                          if ((sub_100085260(a1, "oslcLastWAmpUx10", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcLastWAmpUx10(572) cannot add 1 element to context";
                          goto LABEL_15;
                        case 573:
                          if ((sub_100085260(a1, "raidFailedReadNoBlog", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidFailedReadNoBlog(573) cannot add 1 element to context";
                          goto LABEL_15;
                        case 574:
                          if ((sub_100085260(a1, "raidReconstructFailBlank", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBlank(574) cannot add 1 element to context";
                          goto LABEL_15;
                        case 575:
                          if ((sub_100085260(a1, "oslcHotTLCOnOff", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcHotTLCOnOff(575) cannot add 1 element to context";
                          goto LABEL_15;
                        case 576:
                          if ((sub_100085260(a1, "gcVPackDestinations", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: gcVPackDestinations(576) cannot add 1 element to context";
                          goto LABEL_15;
                        case 581:
                          if ((sub_100085260(a1, "averageTLCPECycles", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: averageTLCPECycles(581) cannot add 1 element to context";
                          goto LABEL_15;
                        case 582:
                          if ((sub_100085260(a1, "averageSLCPECycles", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: averageSLCPECycles(582) cannot add 1 element to context";
                          goto LABEL_15;
                        case 583:
                          if ((sub_100085260(a1, "numAtomicBoots", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: numAtomicBoots(583) cannot add 1 element to context";
                          goto LABEL_15;
                        case 584:
                          if ((sub_100085260(a1, "clogMinorMismatch", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: clogMinorMismatch(584) cannot add 1 element to context";
                          goto LABEL_15;
                        case 586:
                          if ((sub_100085260(a1, "raidExpectedFailRMXReconstructionInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidExpectedFailRMXReconstructionInternal(586) cannot add 1 element to context";
                          goto LABEL_15;
                        case 587:
                          if ((sub_100085260(a1, "raidExpectedFailRMXReconstructionHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: raidExpectedFailRMXReconstructionHost(587) cannot add 1 element to context";
                          goto LABEL_15;
                        case 588:
                          if ((sub_100085260(a1, "oslcGCinvalidations", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcGCinvalidations(588) cannot add 1 element to context";
                          goto LABEL_15;
                        case 589:
                          if ((sub_100085260(a1, "oslcGCActivateReason", (uint64_t)v8, 8u, 1u) & 1) != 0)
                            goto LABEL_16;
                          v19 = "ASPFTLParseBufferToCxt: oslcGCActivateReason(589) cannot add 1 element to context";
                          goto LABEL_15;
                        default:
                          switch(v12)
                          {
                            case 590:
                              if ((sub_100085260(a1, "oslcLowCleanBandsUOnOff", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcLowCleanBandsUOnOff(590) cannot add 1 element to context";
                              goto LABEL_15;
                            case 591:
                              if ((sub_100085260(a1, "oslcTooManyGCMustOnOff", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcTooManyGCMustOnOff(591) cannot add 1 element to context";
                              goto LABEL_15;
                            case 592:
                              if ((sub_100085260(a1, "oslcBaseHostWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcBaseHostWrites(592) cannot add 1 element to context";
                              goto LABEL_15;
                            case 593:
                              if ((sub_100085260(a1, "oslcBaseBandErases", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcBaseBandErases(593) cannot add 1 element to context";
                              goto LABEL_15;
                            case 594:
                              if ((sub_100085260(a1, "oslcBdrBands", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcBdrBands(594) cannot add 1 element to context";
                              goto LABEL_15;
                            case 595:
                              if ((sub_100085260(a1, "oslcBdrValid", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcBdrValid(595) cannot add 1 element to context";
                              goto LABEL_15;
                            case 596:
                              if ((sub_100085260(a1, "unexpectedBlanks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: unexpectedBlanks(596) cannot add 1 element to context";
                              goto LABEL_15;
                            case 597:
                              if ((sub_100085260(a1, "unexpectedBlanksOnRV", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: unexpectedBlanksOnRV(597) cannot add 1 element to context";
                              goto LABEL_15;
                            case 601:
                              if ((sub_100085260(a1, "waterfallLockSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: waterfallLockSectors(601) cannot add 1 element to context";
                              goto LABEL_15;
                            case 602:
                              if ((sub_100085260(a1, "oslcGCActiveWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcGCActiveWrites(602) cannot add 1 element to context";
                              goto LABEL_15;
                            case 603:
                              if ((sub_100085260(a1, "chipIdTemperatureSample", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: chipIdTemperatureSample(603) cannot add 1 element to context";
                              goto LABEL_15;
                            case 604:
                              if ((sub_100085260(a1, "gcVPackWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: gcVPackWrites(604) cannot add 1 element to context";
                              goto LABEL_15;
                            case 605:
                              if ((_DWORD)v14 != 10)
                                sub_1000756A0("ASPFTLParseBufferToCxt: gcActiveReasons(605): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 0xA)
                                v20 = 10;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "gcActiveReasons_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: gcActiveReasons(605): Cannot add 10 elements to context";
                              goto LABEL_2228;
                            case 606:
                              if ((sub_100085260(a1, "eanMaxInitTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanMaxInitTimeMs(606) cannot add 1 element to context";
                              goto LABEL_15;
                            case 607:
                              if ((sub_100085260(a1, "eanMinToFirstReadTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanMinToFirstReadTimeMs(607) cannot add 1 element to context";
                              goto LABEL_15;
                            case 608:
                              if ((sub_100085260(a1, "skinnyAPGMRetire", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: skinnyAPGMRetire(608) cannot add 1 element to context";
                              goto LABEL_15;
                            case 609:
                              if ((sub_100085260(a1, "unexpectedBlanksHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: unexpectedBlanksHost(609) cannot add 1 element to context";
                              goto LABEL_15;
                            case 610:
                              if ((_DWORD)v14 != 64)
                                sub_1000756A0("ASPFTLParseBufferToCxt: pcieAerCounters(610): (#64) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 0x40)
                                v20 = 64;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "pcieAerCounters_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: pcieAerCounters(610): Cannot add 64 elements to context";
                              goto LABEL_2228;
                            case 611:
                              if ((sub_100085260(a1, "fastHwToTlcBalance", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: fastHwToTlcBalance(611) cannot add 1 element to context";
                              goto LABEL_15;
                            case 612:
                              if ((sub_100085260(a1, "perfOSLCRuns", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: perfOSLCRuns(612) cannot add 1 element to context";
                              goto LABEL_15;
                            case 613:
                              if ((sub_100085260(a1, "slcDemandBurstWritesInGC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: slcDemandBurstWritesInGC(613) cannot add 1 element to context";
                              goto LABEL_15;
                            case 614:
                              if ((sub_100085260(a1, "slcDemandBurstWritesInTT", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: slcDemandBurstWritesInTT(614) cannot add 1 element to context";
                              goto LABEL_15;
                            case 615:
                              if ((sub_100085260(a1, "slcDemandBurstWritesInNRP", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: slcDemandBurstWritesInNRP(615) cannot add 1 element to context";
                              goto LABEL_15;
                            case 616:
                              if ((sub_100085260(a1, "perfTotalDmaMb", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: perfTotalDmaMb(616) cannot add 1 element to context";
                              goto LABEL_15;
                            case 617:
                              if ((sub_100085260(a1, "eanAvgInitTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanAvgInitTimeMs(617) cannot add 1 element to context";
                              goto LABEL_15;
                            case 618:
                              if ((sub_100085260(a1, "eanAvgToFirstReadTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanAvgToFirstReadTimeMs(618) cannot add 1 element to context";
                              goto LABEL_15;
                            case 619:
                              if ((sub_100085260(a1, "eanMaxBootReadTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanMaxBootReadTimeMs(619) cannot add 1 element to context";
                              goto LABEL_15;
                            case 620:
                              if ((sub_100085260(a1, "eanAvgBootReadTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanAvgBootReadTimeMs(620) cannot add 1 element to context";
                              goto LABEL_15;
                            case 621:
                              if ((_DWORD)v14 != 10)
                                sub_1000756A0("ASPFTLParseBufferToCxt: eanBootReadsHist(621): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 0xA)
                                v20 = 10;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "eanBootReadsHist_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: eanBootReadsHist(621): Cannot add 10 elements to context";
                              goto LABEL_2228;
                            case 622:
                              if ((sub_100085260(a1, "maxBgInitTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: maxBgInitTimeMs(622) cannot add 1 element to context";
                              goto LABEL_15;
                            case 623:
                              if ((sub_100085260(a1, "avgBgInitTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: avgBgInitTimeMs(623) cannot add 1 element to context";
                              goto LABEL_15;
                            case 624:
                              if ((_DWORD)v14 != 16)
                                sub_1000756A0("ASPFTLParseBufferToCxt: clogFailReason(624): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 0x10)
                                v20 = 16;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "clogFailReason_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: clogFailReason(624): Cannot add 16 elements to context";
                              goto LABEL_2228;
                            case 625:
                              if ((sub_100085260(a1, "eanMinBootReadMBPerSec", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanMinBootReadMBPerSec(625) cannot add 1 element to context";
                              goto LABEL_15;
                            case 626:
                              if ((sub_100085260(a1, "eanAvgBootReadMBPerSec", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanAvgBootReadMBPerSec(626) cannot add 1 element to context";
                              goto LABEL_15;
                            case 627:
                              if ((sub_100085260(a1, "minSkinnyPECycles", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: minSkinnyPECycles(627) cannot add 1 element to context";
                              goto LABEL_15;
                            case 628:
                              if ((sub_100085260(a1, "maxSkinnyPECycles", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: maxSkinnyPECycles(628) cannot add 1 element to context";
                              goto LABEL_15;
                            case 629:
                              if ((sub_100085260(a1, "averageSkinnyPECycles", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: averageSkinnyPECycles(629) cannot add 1 element to context";
                              goto LABEL_15;
                            case 630:
                              if ((_DWORD)v14 != 6)
                                sub_1000756A0("ASPFTLParseBufferToCxt: raidSuccessfulRecoEAN(630): (#6) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 6)
                                v20 = 6;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "raidSuccessfulRecoEAN_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: raidSuccessfulRecoEAN(630): Cannot add 6 elements to context";
                              goto LABEL_2228;
                            case 631:
                              if ((_DWORD)v14 != 6)
                                sub_1000756A0("ASPFTLParseBufferToCxt: raidFailedRecoEAN(631): (#6) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 6)
                                v20 = 6;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "raidFailedRecoEAN_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: raidFailedRecoEAN(631): Cannot add 6 elements to context";
                              goto LABEL_2228;
                            case 632:
                              if ((_DWORD)v14 != 6)
                                sub_1000756A0("ASPFTLParseBufferToCxt: eanFirstReadMode(632): (#6) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 6)
                                v20 = 6;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "eanFirstReadMode_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: eanFirstReadMode(632): Cannot add 6 elements to context";
                              goto LABEL_2228;
                            case 635:
                              if ((sub_100085260(a1, "oslcHwGC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcHwGC(635) cannot add 1 element to context";
                              goto LABEL_15;
                            case 636:
                              if ((sub_100085260(a1, "oslcHwTT", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcHwTT(636) cannot add 1 element to context";
                              goto LABEL_15;
                            case 637:
                              if ((sub_100085260(a1, "oslcHwNRP", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: oslcHwNRP(637) cannot add 1 element to context";
                              goto LABEL_15;
                            case 638:
                              if ((_DWORD)v14 != 10)
                                sub_1000756A0("ASPFTLParseBufferToCxt: oslcDemandBurstSize(638): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 0xA)
                                v20 = 10;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "oslcDemandBurstSize_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: oslcDemandBurstSize(638): Cannot add 10 elements to context";
                              goto LABEL_2228;
                            case 639:
                              if ((sub_100085260(a1, "raidReconstructSuccessBandFlowOslc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidReconstructSuccessBandFlowOslc(639) cannot add 1 element to context";
                              goto LABEL_15;
                            case 640:
                              if ((sub_100085260(a1, "raidReconstructFailBandFlowOslc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBandFlowOslc(640) cannot add 1 element to context";
                              goto LABEL_15;
                            case 641:
                              if ((sub_100085260(a1, "raidFailSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidFailSectors(641) cannot add 1 element to context";
                              goto LABEL_15;
                            case 642:
                              if ((sub_100085260(a1, "eanFailSectors", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: eanFailSectors(642) cannot add 1 element to context";
                              goto LABEL_15;
                            case 643:
                              if ((sub_100085260(a1, "bdrTimeMode", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: bdrTimeMode(643) cannot add 1 element to context";
                              goto LABEL_15;
                            case 644:
                              if ((sub_100085260(a1, "raidParityNotSavedP", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidParityNotSavedP(644) cannot add 1 element to context";
                              goto LABEL_15;
                            case 645:
                              if ((sub_100085260(a1, "raidParityNotSavedQ", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidParityNotSavedQ(645) cannot add 1 element to context";
                              goto LABEL_15;
                            case 646:
                              if ((sub_100085260(a1, "raidParityInvalid", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidParityInvalid(646) cannot add 1 element to context";
                              goto LABEL_15;
                            case 647:
                              if ((sub_100085260(a1, "raidParityUnknown", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidParityUnknown(647) cannot add 1 element to context";
                              goto LABEL_15;
                            case 648:
                              if ((sub_100085260(a1, "raidParityUnmapped", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidParityUnmapped(648) cannot add 1 element to context";
                              goto LABEL_15;
                            case 649:
                              if ((sub_100085260(a1, "raidParityGCUnc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidParityGCUnc(649) cannot add 1 element to context";
                              goto LABEL_15;
                            case 657:
                              if ((sub_100085260(a1, "AbortSkip_MPBXProbational", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: AbortSkip_MPBXProbational(657) cannot add 1 element to context";
                              goto LABEL_15;
                            case 659:
                              if ((sub_100085260(a1, "raidVerificationReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: raidVerificationReads(659) cannot add 1 element to context";
                              goto LABEL_15;
                            case 666:
                              if ((sub_100085260(a1, "nofDies", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: nofDies(666) cannot add 1 element to context";
                              goto LABEL_15;
                            case 671:
                              if ((sub_100085260(a1, "skinnyBandsNum", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: skinnyBandsNum(671) cannot add 1 element to context";
                              goto LABEL_15;
                            case 672:
                              if ((sub_100085260(a1, "skinnyBandsNumDips", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: skinnyBandsNumDips(672) cannot add 1 element to context";
                              goto LABEL_15;
                            case 674:
                              if ((_DWORD)v14 != 8)
                                sub_1000756A0("ASPFTLParseBufferToCxt: oslcNoVotesHw(674): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                              if (v14 >= 8)
                                v20 = 8;
                              else
                                v20 = v14;
                              if ((sub_100085260(a1, "oslcNoVotesHw_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                goto LABEL_14;
                              v22 = "ASPFTLParseBufferToCxt: oslcNoVotesHw(674): Cannot add 8 elements to context";
                              goto LABEL_2228;
                            case 675:
                              if ((sub_100085260(a1, "totalLbas", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: totalLbas(675) cannot add 1 element to context";
                              goto LABEL_15;
                            case 676:
                              if ((sub_100085260(a1, "bdrHostPingExtra", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: bdrHostPingExtra(676) cannot add 1 element to context";
                              goto LABEL_15;
                            case 677:
                              if ((sub_100085260(a1, "magazineInstanceMeta", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                goto LABEL_16;
                              v19 = "ASPFTLParseBufferToCxt: magazineInstanceMeta(677) cannot add 1 element to context";
                              goto LABEL_15;
                            default:
                              switch(v12)
                              {
                                case 680:
                                  if ((_DWORD)v14 != 3)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: magazineFWVersion(680): (#3) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 3)
                                    v20 = 3;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "magazineFWVersion_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: magazineFWVersion(680): Cannot add 3 elements to context";
                                  goto LABEL_2228;
                                case 681:
                                  if ((sub_100085260(a1, "raidReconstructFailPMXUnsup", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidReconstructFailPMXUnsup(681) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 682:
                                  if ((sub_100085260(a1, "raidReconstructFailBMXUnsup", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBMXUnsup(682) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 683:
                                  if ((sub_100085260(a1, "iBootNANDResets", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: iBootNANDResets(683) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 684:
                                  if ((sub_100085260(a1, "pcieClkreqHighTimeout", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: pcieClkreqHighTimeout(684) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 687:
                                  if ((_DWORD)v14 != 3)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: cbdrInitSent(687): (#3) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 3)
                                    v20 = 3;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "cbdrInitSent_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: cbdrInitSent(687): Cannot add 3 elements to context";
                                  goto LABEL_2228;
                                case 688:
                                  if ((sub_100085260(a1, "cbdrPauseSent", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrPauseSent(688) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 689:
                                  if ((sub_100085260(a1, "cbdrResumeSent", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrResumeSent(689) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 690:
                                  if ((sub_100085260(a1, "cbdrGetResultSent", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrGetResultSent(690) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 691:
                                  if ((sub_100085260(a1, "cbdrEarlyExits", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrEarlyExits(691) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 694:
                                  if ((_DWORD)v14 != 10)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: cbdrRefreshGrades(694): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 0xA)
                                    v20 = 10;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "cbdrRefreshGrades_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: cbdrRefreshGrades(694): Cannot add 10 elements to context";
                                  goto LABEL_2228;
                                case 695:
                                  if ((sub_100085260(a1, "cbdrNotEnoughReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrNotEnoughReads(695) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 696:
                                  if ((sub_100085260(a1, "cbdrAborts", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrAborts(696) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 697:
                                  if ((sub_100085260(a1, "TurboRaidHostClassifications", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: TurboRaidHostClassifications(697) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 698:
                                  if ((sub_100085260(a1, "TurboRaidInternalClassifications", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: TurboRaidInternalClassifications(698) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 699:
                                  if ((sub_100085260(a1, "cbdrFullyDone", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrFullyDone(699) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 702:
                                  if ((_DWORD)v14 != 32)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: vcurve(702): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 0x20)
                                    v20 = 32;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "vcurve_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: vcurve(702): Cannot add 32 elements to context";
                                  goto LABEL_2228;
                                case 703:
                                  if ((_DWORD)v14 != 12)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: injDepth(703): (#12) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 0xC)
                                    v20 = 12;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "injDepth_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: injDepth(703): Cannot add 12 elements to context";
                                  goto LABEL_2228;
                                case 704:
                                  if ((sub_100085260(a1, "logical_disk_occupied_promiles", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: logical_disk_occupied_promiles(704) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 711:
                                  if ((sub_100085260(a1, "raidPrevFailedReconstructSkip", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidPrevFailedReconstructSkip(711) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 712:
                                  if ((sub_100085260(a1, "TurboRaidSuccessfulHostAuxReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: TurboRaidSuccessfulHostAuxReads(712) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 713:
                                  if ((sub_100085260(a1, "TurboRaidSuccessfulInternalAuxReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: TurboRaidSuccessfulInternalAuxReads(713) cannot add 1 el"
                                        "ement to context";
                                  goto LABEL_15;
                                case 714:
                                  if ((sub_100085260(a1, "turboRaidClassificationReliabilityHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: turboRaidClassificationReliabilityHost(714) cannot add 1"
                                        " element to context";
                                  goto LABEL_15;
                                case 715:
                                  if ((sub_100085260(a1, "turboRaidClassificationReliabilityInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: turboRaidClassificationReliabilityInternal(715) cannot a"
                                        "dd 1 element to context";
                                  goto LABEL_15;
                                case 716:
                                  if ((sub_100085260(a1, "turboRaidClassificationQualityHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: turboRaidClassificationQualityHost(716) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 717:
                                  if ((sub_100085260(a1, "turboRaidClassificationQualityInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: turboRaidClassificationQualityInternal(717) cannot add 1"
                                        " element to context";
                                  goto LABEL_15;
                                case 719:
                                  if ((sub_100085260(a1, "skinnyBandErases", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: skinnyBandErases(719) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 721:
                                  if ((sub_100085260(a1, "gcPDusterDestinations", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: gcPDusterDestinations(721) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 722:
                                  if ((sub_100085260(a1, "gcPDusterWrites", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: gcPDusterWrites(722) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 730:
                                  if ((sub_100085260(a1, "rvFails", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: rvFails(730) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 737:
                                  if ((sub_100085260(a1, "TurboRaidFailedHostAuxReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: TurboRaidFailedHostAuxReads(737) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 738:
                                  if ((sub_100085260(a1, "TurboRaidFailedInternalAuxReads", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: TurboRaidFailedInternalAuxReads(738) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 741:
                                  if ((sub_100085260(a1, "autoSkipTriggers", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: autoSkipTriggers(741) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 742:
                                  if ((sub_100085260(a1, "autoSkipPlanes", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: autoSkipPlanes(742) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 744:
                                  if ((_DWORD)v14 != 8)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: raidReconstructDurationHisto(744): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 8)
                                    v20 = 8;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "raidReconstructDurationHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: raidReconstructDurationHisto(744): Cannot add 8 elements to context";
                                  goto LABEL_2228;
                                case 745:
                                  if ((_DWORD)v14 != 8)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: failsOnReconstructHisto(745): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 8)
                                    v20 = 8;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "failsOnReconstructHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: failsOnReconstructHisto(745): Cannot add 8 elements to context";
                                  goto LABEL_2228;
                                case 746:
                                  if ((sub_100085260(a1, "bandKill_userFlattenExcessive", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_userFlattenExcessive(746) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 747:
                                  if ((sub_100085260(a1, "bandKill_IntFlattenExcessive", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_IntFlattenExcessive(747) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 748:
                                  if ((sub_100085260(a1, "bandKill_userFlattenBalance", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_userFlattenBalance(748) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 749:
                                  if ((sub_100085260(a1, "bandKill_intFlattenBalance", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_intFlattenBalance(749) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 750:
                                  if ((sub_100085260(a1, "bandKill_formatVertExcessive", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_formatVertExcessive(750) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 751:
                                  if ((sub_100085260(a1, "bandKill_formatVertBalance", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_formatVertBalance(751) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 753:
                                  if ((sub_100085260(a1, "cbdrNumSlowRefreshes", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrNumSlowRefreshes(753) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 754:
                                  if ((sub_100085260(a1, "cbdrNumFastRefreshes", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrNumFastRefreshes(754) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 755:
                                  if ((sub_100085260(a1, "cbdrTotalRefreshValidity", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrTotalRefreshValidity(755) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 756:
                                  if ((_DWORD)v14 != 9)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: cbdrRefreshedAges(756): (#9) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 9)
                                    v20 = 9;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "cbdrRefreshedAges_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: cbdrRefreshedAges(756): Cannot add 9 elements to context";
                                  goto LABEL_2228;
                                case 758:
                                  if ((sub_100085260(a1, "cbdrSkippedBlocks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: cbdrSkippedBlocks(758) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 759:
                                  if ((_DWORD)v14 != 5)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: cbdrScanPct(759): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 5)
                                    v20 = 5;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "cbdrScanPct_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: cbdrScanPct(759): Cannot add 5 elements to context";
                                  goto LABEL_2228;
                                case 760:
                                  if ((sub_100085260(a1, "raidSuccessfulBMXReconstructionInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidSuccessfulBMXReconstructionInternal(760) cannot add "
                                        "1 element to context";
                                  goto LABEL_15;
                                case 761:
                                  if ((sub_100085260(a1, "raidSuccessfulBMXReconstructionHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidSuccessfulBMXReconstructionHost(761) cannot add 1 el"
                                        "ement to context";
                                  goto LABEL_15;
                                case 762:
                                  if ((sub_100085260(a1, "raidFailedBMXReconstructionInternal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidFailedBMXReconstructionInternal(762) cannot add 1 el"
                                        "ement to context";
                                  goto LABEL_15;
                                case 763:
                                  if ((sub_100085260(a1, "raidFailedBMXReconstructionHost", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidFailedBMXReconstructionHost(763) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 764:
                                  if ((sub_100085260(a1, "ricSPRVFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: ricSPRVFail(764) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 765:
                                  if ((sub_100085260(a1, "ricMPRVFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: ricMPRVFail(765) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 768:
                                  if ((_DWORD)v14 != 9)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: cbdrRefreshedAgesSLC(768): (#9) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 9)
                                    v20 = 9;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "cbdrRefreshedAgesSLC_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: cbdrRefreshedAgesSLC(768): Cannot add 9 elements to context";
                                  goto LABEL_2228;
                                case 770:
                                  if ((_DWORD)v14 != 8)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: cpuBurstLength(770): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 8)
                                    v20 = 8;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "cpuBurstLength_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: cpuBurstLength(770): Cannot add 8 elements to context";
                                  goto LABEL_2228;
                                case 771:
                                  if ((sub_100085260(a1, "autoSkipRaidRecoFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: autoSkipRaidRecoFail(771) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 772:
                                  if ((_DWORD)v14 != 32)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsSlc(772): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 0x20)
                                    v20 = 32;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "dmReasonsSlc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: dmReasonsSlc(772): Cannot add 32 elements to context";
                                  goto LABEL_2228;
                                case 773:
                                  if ((_DWORD)v14 != 32)
                                    sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsTlc(773): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                  if (v14 >= 0x20)
                                    v20 = 32;
                                  else
                                    v20 = v14;
                                  if ((sub_100085260(a1, "dmReasonsTlc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                    goto LABEL_14;
                                  v22 = "ASPFTLParseBufferToCxt: dmReasonsTlc(773): Cannot add 32 elements to context";
                                  goto LABEL_2228;
                                case 774:
                                  if ((sub_100085260(a1, "raidReconstructFailBMXAbort", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBMXAbort(774) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 775:
                                  if ((sub_100085260(a1, "bandKill_fatBindingNoBlocks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_fatBindingNoBlocks(775) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 776:
                                  if ((sub_100085260(a1, "bandKill_fatBindingFewBlocks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: bandKill_fatBindingFewBlocks(776) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 777:
                                  if ((sub_100085260(a1, "numBadBootBlocks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: numBadBootBlocks(777) cannot add 1 element to context";
                                  goto LABEL_15;
                                case 778:
                                  if ((sub_100085260(a1, "snapshotCPUHigh", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                    goto LABEL_16;
                                  v19 = "ASPFTLParseBufferToCxt: snapshotCPUHigh(778) cannot add 1 element to context";
                                  goto LABEL_15;
                                default:
                                  switch(v12)
                                  {
                                    case 779:
                                      if ((sub_100085260(a1, "snapshotCPULow", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: snapshotCPULow(779) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 780:
                                      if ((sub_100085260(a1, "gcWithoutBMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: gcWithoutBMs(780) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 781:
                                      if ((_DWORD)v14 != 10)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: gcSearchTimeHistory(781): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0xA)
                                        v20 = 10;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "gcSearchTimeHistory_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: gcSearchTimeHistory(781): Cannot add 10 elements to context";
                                      goto LABEL_2228;
                                    case 785:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: gcSearchPortion(785): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "gcSearchPortion_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: gcSearchPortion(785): Cannot add 16 elements to context";
                                      goto LABEL_2228;
                                    case 786:
                                      if ((sub_100085260(a1, "raidReconstructFailBmxMp", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBmxMp(786) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 787:
                                      if ((sub_100085260(a1, "raidReconstructFailBmx", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBmx(787) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 788:
                                      if ((sub_100085260(a1, "raidReconstructFailBMXUECC", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBMXUECC(788) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 789:
                                      if ((sub_100085260(a1, "raidReconstructFailBMXBlank", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidReconstructFailBMXBlank(789) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 790:
                                      if ((sub_100085260(a1, "raidPrevFailedReconstructBmxMpSkip", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidPrevFailedReconstructBmxMpSkip(790) cannot add 1"
                                            " element to context";
                                      goto LABEL_15;
                                    case 792:
                                      if ((sub_100085260(a1, "numTLCFatBands", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: numTLCFatBands(792) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 793:
                                      if ((sub_100085260(a1, "fatValidity", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: fatValidity(793) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 794:
                                      if ((sub_100085260(a1, "fatTotal", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: fatTotal(794) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 798:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailP(798): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailP_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailP(798): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 799:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailUECC(799): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailUECC_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailUECC(799): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 804:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailNoSPBX(804): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailNoSPBX_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailNoSPBX(804): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 806:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailBlank(806): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailBlank_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailBlank(806): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 809:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailUnsup(809): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailUnsup_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailUnsup(809): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 811:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailMpSkip(811): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailMpSkip_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailMpSkip(811): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 812:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailAbort(812): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailAbort_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailAbort(812): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 813:
                                      if ((sub_100085260(a1, "TurboRaidIsEnabled", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: TurboRaidIsEnabled(813) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 814:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXFailOther(814): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXFailOther_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXFailOther(814): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 815:
                                      if ((_DWORD)v14 != 4)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: raidBMXSuccess(815): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 4)
                                        v20 = 4;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "raidBMXSuccess_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: raidBMXSuccess(815): Cannot add 4 elements to context";
                                      goto LABEL_2228;
                                    case 816:
                                      if ((sub_100085260(a1, "skinnyBandsExtraDip", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: skinnyBandsExtraDip(816) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 821:
                                      if ((sub_100085260(a1, "writeAmp", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: writeAmp(821) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 822:
                                      if ((sub_100085260(a1, "ricMaxClogOnlyPages", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: ricMaxClogOnlyPages(822) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 823:
                                      if ((_DWORD)v14 != 3)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: readClassifyStatusesHisto(823): (#3) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 3)
                                        v20 = 3;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "readClassifyStatusesHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: readClassifyStatusesHisto(823): Cannot add 3 elements to context";
                                      goto LABEL_2228;
                                    case 824:
                                      if ((_DWORD)v14 != 10)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: readWithAuxStatusesHisto(824): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0xA)
                                        v20 = 10;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "readWithAuxStatusesHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: readWithAuxStatusesHisto(824): Cannot add 10 elements to context";
                                      goto LABEL_2228;
                                    case 825:
                                      if ((_DWORD)v14 != 10)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: readReconstructStatusesHisto(825): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0xA)
                                        v20 = 10;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "readReconstructStatusesHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: readReconstructStatusesHisto(825): Cannot add 10 ele"
                                            "ments to context";
                                      goto LABEL_2228;
                                    case 826:
                                      if ((sub_100085260(a1, "bdrBackupChecks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: bdrBackupChecks(826) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 827:
                                      if ((sub_100085260(a1, "ricExceedClogOnlyPagesTH", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: ricExceedClogOnlyPagesTH(827) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 828:
                                      if ((sub_100085260(a1, "numDipFailures", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: numDipFailures(828) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 862:
                                      if ((sub_100085260(a1, "raidSuccessfulSkip", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidSuccessfulSkip(862) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 863:
                                      if ((sub_100085260(a1, "raidFailedSkip", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidFailedSkip(863) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 864:
                                      if ((sub_100085260(a1, "raidSkipAttempts", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: raidSkipAttempts(864) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 865:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: timeOfThrottlingPerLevel(865): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "timeOfThrottlingPerLevel_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: timeOfThrottlingPerLevel(865): Cannot add 16 elements to context";
                                      goto LABEL_2228;
                                    case 866:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: timeOfThrottlingPerReadLevel(866): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "timeOfThrottlingPerReadLevel_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: timeOfThrottlingPerReadLevel(866): Cannot add 16 ele"
                                            "ments to context";
                                      goto LABEL_2228;
                                    case 867:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: timeOfThrottlingPerWriteLevel(867): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "timeOfThrottlingPerWriteLevel_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: timeOfThrottlingPerWriteLevel(867): Cannot add 16 el"
                                            "ements to context";
                                      goto LABEL_2228;
                                    case 868:
                                      if ((_DWORD)v14 != 32)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsSlc_1bc(868): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x20)
                                        v20 = 32;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "dmReasonsSlc_1bc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: dmReasonsSlc_1bc(868): Cannot add 32 elements to context";
                                      goto LABEL_2228;
                                    case 869:
                                      if ((_DWORD)v14 != 32)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsTlc_1bc(869): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x20)
                                        v20 = 32;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "dmReasonsTlc_1bc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: dmReasonsTlc_1bc(869): Cannot add 32 elements to context";
                                      goto LABEL_2228;
                                    case 870:
                                      if ((_DWORD)v14 != 32)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsSlc_1bc_he(870): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x20)
                                        v20 = 32;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "dmReasonsSlc_1bc_he_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: dmReasonsSlc_1bc_he(870): Cannot add 32 elements to context";
                                      goto LABEL_2228;
                                    case 871:
                                      if ((_DWORD)v14 != 32)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsTlc_1bc_he(871): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x20)
                                        v20 = 32;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "dmReasonsTlc_1bc_he_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: dmReasonsTlc_1bc_he(871): Cannot add 32 elements to context";
                                      goto LABEL_2228;
                                    case 876:
                                      if ((_DWORD)v14 != 32)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsSlc_mbc(876): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x20)
                                        v20 = 32;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "dmReasonsSlc_mbc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: dmReasonsSlc_mbc(876): Cannot add 32 elements to context";
                                      goto LABEL_2228;
                                    case 877:
                                      if ((_DWORD)v14 != 32)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: dmReasonsTlc_mbc(877): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x20)
                                        v20 = 32;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "dmReasonsTlc_mbc_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: dmReasonsTlc_mbc(877): Cannot add 32 elements to context";
                                      goto LABEL_2228;
                                    case 883:
                                      if ((sub_100085260(a1, "clogEmptyProgramms", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: clogEmptyProgramms(883) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 884:
                                      if ((sub_100085260(a1, "oslcHwCloseBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: oslcHwCloseBand(884) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 891:
                                      if ((_DWORD)v14 != 2)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidSuccessAuxPartition(891): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 2)
                                        v20 = 2;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidSuccessAuxPartition_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidSuccessAuxPartition(891): Cannot add 2 elements to context";
                                      goto LABEL_2228;
                                    case 892:
                                      if ((_DWORD)v14 != 2)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidFailAuxPartition(892): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 2)
                                        v20 = 2;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidFailAuxPartition_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidFailAuxPartition(892): Cannot add 2 elements to context";
                                      goto LABEL_2228;
                                    case 893:
                                      if ((_DWORD)v14 != 2)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidClassifyQualPartition(893): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 2)
                                        v20 = 2;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidClassifyQualPartition_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidClassifyQualPartition(893): Cannot add 2 el"
                                            "ements to context";
                                      goto LABEL_2228;
                                    case 894:
                                      if ((_DWORD)v14 != 2)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidClassifyRelPartition(894): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 2)
                                        v20 = 2;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidClassifyRelPartition_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidClassifyRelPartition(894): Cannot add 2 ele"
                                            "ments to context";
                                      goto LABEL_2228;
                                    case 895:
                                      if ((sub_100085260(a1, "IND_pool_freeMinSilo", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: IND_pool_freeMinSilo(895) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 896:
                                      if ((sub_100085260(a1, "autoSweepBlocks", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: autoSweepBlocks(896) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 897:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: wcWrFragSizes(897): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "wcWrFragSizes_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: wcWrFragSizes(897): Cannot add 16 elements to context";
                                      goto LABEL_2228;
                                    case 898:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: indStateAcrossGcDidNoL(898): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "indStateAcrossGcDidNoL_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: indStateAcrossGcDidNoL(898): Cannot add 16 elements to context";
                                      goto LABEL_2228;
                                    case 899:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: indStateAcrossGcDidL(899): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "indStateAcrossGcDidL_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: indStateAcrossGcDidL(899): Cannot add 16 elements to context";
                                      goto LABEL_2228;
                                    case 900:
                                      if ((sub_100085260(a1, "turboRaidNoClassifyDueToWasRetire", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: turboRaidNoClassifyDueToWasRetire(900) cannot add 1 "
                                            "element to context";
                                      goto LABEL_15;
                                    case 901:
                                      if ((sub_100085260(a1, "turboRaidNoClassifyDueToOpenBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: turboRaidNoClassifyDueToOpenBand(901) cannot add 1 e"
                                            "lement to context";
                                      goto LABEL_15;
                                    case 902:
                                      if ((sub_100085260(a1, "turboRaidNoClassifyDueToQualityBlock", (uint64_t)v8, 8u, 1u) & 1) != 0)goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: turboRaidNoClassifyDueToQualityBlock(902) cannot add"
                                            " 1 element to context";
                                      goto LABEL_15;
                                    case 903:
                                      if ((sub_100085260(a1, "turboRaidGbbOpenBand", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: turboRaidGbbOpenBand(903) cannot add 1 element to context";
                                      goto LABEL_15;
                                    case 904:
                                      if ((sub_100085260(a1, "turboRaidGbbShouldRetireOnRefresh", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                        goto LABEL_16;
                                      v19 = "ASPFTLParseBufferToCxt: turboRaidGbbShouldRetireOnRefresh(904) cannot add 1 "
                                            "element to context";
                                      goto LABEL_15;
                                    case 905:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidRelPerBlock(905): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidRelPerBlock_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidRelPerBlock(905): Cannot add 16 elements to context";
                                      goto LABEL_2228;
                                    case 906:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidRelBetweenRefreshesPerBlock(906): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidRelBetweenRefreshesPerBlock_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidRelBetweenRefreshesPerBlock(906): Cannot ad"
                                            "d 16 elements to context";
                                      goto LABEL_2228;
                                    case 907:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidMaxRelBetweenRefreshesPerBlock(907): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidMaxRelBetweenRefreshesPerBlock_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidMaxRelBetweenRefreshesPerBlock(907): Cannot"
                                            " add 16 elements to context";
                                      goto LABEL_2228;
                                    case 908:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidMinRelBetweenRefreshesPerBlock(908): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidMinRelBetweenRefreshesPerBlock_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidMinRelBetweenRefreshesPerBlock(908): Cannot"
                                            " add 16 elements to context";
                                      goto LABEL_2228;
                                    case 918:
                                      if ((_DWORD)v14 != 16)
                                        sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidMaxCyclesBetweenRel(918): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                      if (v14 >= 0x10)
                                        v20 = 16;
                                      else
                                        v20 = v14;
                                      if ((sub_100085260(a1, "turboRaidMaxCyclesBetweenRel_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                        goto LABEL_14;
                                      v22 = "ASPFTLParseBufferToCxt: turboRaidMaxCyclesBetweenRel(918): Cannot add 16 ele"
                                            "ments to context";
                                      goto LABEL_2228;
                                    default:
                                      if (v12 <= 1039)
                                      {
                                        switch(v12)
                                        {
                                          case 919:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidMinCyclesBetweenRel(919): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidMinCyclesBetweenRel_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidMinCyclesBetweenRel(919): Cannot add "
                                                  "16 elements to context";
                                            goto LABEL_2228;
                                          case 920:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidAuxPerBlock(920): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidAuxPerBlock_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidAuxPerBlock(920): Cannot add 16 elements to context";
                                            goto LABEL_2228;
                                          case 921:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidAuxBetweenRefreshesPerBlock(921): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidAuxBetweenRefreshesPerBlock_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidAuxBetweenRefreshesPerBlock(921): Can"
                                                  "not add 16 elements to context";
                                            goto LABEL_2228;
                                          case 922:
                                            if ((sub_100085260(a1, "turboRaidRelLockMark", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: turboRaidRelLockMark(922) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 923:
                                            if ((sub_100085260(a1, "turboRaidAuxLockMark", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: turboRaidAuxLockMark(923) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 924:
                                          case 925:
                                          case 926:
                                          case 927:
                                          case 928:
                                          case 929:
                                          case 936:
                                          case 941:
                                          case 945:
                                          case 946:
                                          case 947:
                                          case 949:
                                          case 950:
                                          case 952:
                                          case 954:
                                          case 955:
                                          case 956:
                                          case 957:
                                          case 958:
                                          case 959:
                                          case 960:
                                          case 963:
                                          case 964:
                                          case 965:
                                          case 966:
                                          case 968:
                                          case 969:
                                          case 970:
                                            goto LABEL_2116;
                                          case 930:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidMaxCyclesBetweenAux(930): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidMaxCyclesBetweenAux_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidMaxCyclesBetweenAux(930): Cannot add "
                                                  "16 elements to context";
                                            goto LABEL_2228;
                                          case 931:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidMinCyclesBetweenAux(931): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidMinCyclesBetweenAux_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidMinCyclesBetweenAux(931): Cannot add "
                                                  "16 elements to context";
                                            goto LABEL_2228;
                                          case 932:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidLastRelPECycles(932): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidLastRelPECycles_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidLastRelPECycles(932): Cannot add 16 e"
                                                  "lements to context";
                                            goto LABEL_2228;
                                          case 933:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidRelQualPECycles(933): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidRelQualPECycles_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidRelQualPECycles(933): Cannot add 16 e"
                                                  "lements to context";
                                            goto LABEL_2228;
                                          case 934:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidLastAuxPECycles(934): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidLastAuxPECycles_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidLastAuxPECycles(934): Cannot add 16 e"
                                                  "lements to context";
                                            goto LABEL_2228;
                                          case 935:
                                            if ((_DWORD)v14 != 16)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: turboRaidAuxQualPECycles(935): (#16) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x10)
                                              v20 = 16;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "turboRaidAuxQualPECycles_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: turboRaidAuxQualPECycles(935): Cannot add 16 e"
                                                  "lements to context";
                                            goto LABEL_2228;
                                          case 937:
                                            if ((sub_100085260(a1, "turboRaidPEFailAfterRel", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: turboRaidPEFailAfterRel(937) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 938:
                                            if ((sub_100085260(a1, "turboRaidPEFailAfterAux", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: turboRaidPEFailAfterAux(938) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 939:
                                            if ((sub_100085260(a1, "dvfmVotesCPU", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: dvfmVotesCPU(939) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 940:
                                            if ((sub_100085260(a1, "dvfmVotesBandwidth", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: dvfmVotesBandwidth(940) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 942:
                                            if ((sub_100085260(a1, "maxSLCEndurance", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: maxSLCEndurance(942) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 943:
                                            if ((sub_100085260(a1, "maxMixedEndurance", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: maxMixedEndurance(943) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 944:
                                            if ((sub_100085260(a1, "maxNativeEndurance", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: maxNativeEndurance(944) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 948:
                                            if ((_DWORD)v14 != 40)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: assertHistory(948): (#40) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0x28)
                                              v20 = 40;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "assertHistory_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: assertHistory(948): Cannot add 40 elements to context";
                                            goto LABEL_2228;
                                          case 951:
                                            if ((sub_100085260(a1, "asp3Support", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: asp3Support(951) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 953:
                                            if ((sub_100085260(a1, "numCrossTempRaidUecc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: numCrossTempRaidUecc(953) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 961:
                                            if ((sub_100085260(a1, "osBuildStr", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: osBuildStr(961) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 962:
                                            if ((sub_100085260(a1, "raidConfig", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: raidConfig(962) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 967:
                                            if ((_DWORD)v14 != 12)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: indTrimFrags(967): (#12) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0xC)
                                              v20 = 12;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "indTrimFrags_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: indTrimFrags(967): Cannot add 12 elements to context";
                                            goto LABEL_2228;
                                          case 971:
                                            if ((_DWORD)v14 != 12)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: indUsedFrags(971): (#12) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0xC)
                                              v20 = 12;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "indUsedFrags_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: indUsedFrags(971): Cannot add 12 elements to context";
                                            goto LABEL_2228;
                                          default:
                                            switch(v12)
                                            {
                                              case 996:
                                                if ((sub_100085260(a1, "clogFindFail", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                  goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: clogFindFail(996) cannot add 1 element to context";
                                                goto LABEL_15;
                                              case 997:
                                                if ((sub_100085260(a1, "clogFindBlank", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                  goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: clogFindBlank(997) cannot add 1 element to context";
                                                goto LABEL_15;
                                              case 998:
                                                if ((sub_100085260(a1, "clogFindUnc", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                  goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: clogFindUnc(998) cannot add 1 element to context";
                                                goto LABEL_15;
                                              case 999:
                                                if ((sub_100085260(a1, "clogFindUnexpected", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                  goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: clogFindUnexpected(999) cannot add 1 element to context";
                                                goto LABEL_15;
                                              case 1001:
                                                if ((_DWORD)v14 != 8)
                                                  sub_1000756A0("ASPFTLParseBufferToCxt: clogReplayFailReason(1001): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                                if (v14 >= 8)
                                                  v20 = 8;
                                                else
                                                  v20 = v14;
                                                if ((sub_100085260(a1, "clogReplayFailReason_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                                  goto LABEL_14;
                                                v22 = "ASPFTLParseBufferToCxt: clogReplayFailReason(1001): Cannot add 8 e"
                                                      "lements to context";
                                                goto LABEL_2228;
                                              case 1002:
                                                if ((sub_100085260(a1, "clogReplayTransientError", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                  goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: clogReplayTransientError(1002) cannot add "
                                                      "1 element to context";
                                                goto LABEL_15;
                                              case 1003:
                                                if ((sub_100085260(a1, "clogReplaySpfError", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                  goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: clogReplaySpfError(1003) cannot add 1 element to context";
                                                goto LABEL_15;
                                              case 1015:
                                                if ((_DWORD)v14 != 4)
                                                  sub_1000756A0("ASPFTLParseBufferToCxt: eanEarlyBootUeccPage(1015): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                                if (v14 >= 4)
                                                  v20 = 4;
                                                else
                                                  v20 = v14;
                                                if ((sub_100085260(a1, "eanEarlyBootUeccPage_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                                  goto LABEL_14;
                                                v22 = "ASPFTLParseBufferToCxt: eanEarlyBootUeccPage(1015): Cannot add 4 e"
                                                      "lements to context";
                                                goto LABEL_2228;
                                              case 1016:
                                                if ((sub_100085260(a1, "eanEarlyBootNumUeccPages", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                  goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: eanEarlyBootNumUeccPages(1016) cannot add "
                                                      "1 element to context";
                                                goto LABEL_15;
                                              case 1017:
                                                if ((sub_100085260(a1, "eanEarlyBootUeccMultiplane", (uint64_t)v8, 8u, 1u) & 1) != 0)goto LABEL_16;
                                                v19 = "ASPFTLParseBufferToCxt: eanEarlyBootUeccMultiplane(1017) cannot ad"
                                                      "d 1 element to context";
                                                goto LABEL_15;
                                              default:
                                                goto LABEL_2116;
                                            }
                                        }
                                      }
                                      if (v12 <= 1146)
                                      {
                                        if (v12 <= 1104)
                                        {
                                          if (v12 <= 1041)
                                          {
                                            if (v12 == 1040)
                                            {
                                              if ((_DWORD)v14 != 31)
                                                sub_1000756A0("ASPFTLParseBufferToCxt: bandsAgeBinsV2(1040): (#31) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                              if (v14 >= 0x1F)
                                                v20 = 31;
                                              else
                                                v20 = v14;
                                              if ((sub_100085260(a1, "bandsAgeBinsV2_", (uint64_t)v8, 8u, v20) & 1) == 0)
                                              {
                                                v22 = "ASPFTLParseBufferToCxt: bandsAgeBinsV2(1040): Cannot add 31 elements to context";
                                                goto LABEL_2228;
                                              }
                                            }
                                            else
                                            {
                                              if ((_DWORD)v14 != 31)
                                                sub_1000756A0("ASPFTLParseBufferToCxt: bandsAgeBinsSnapshot(1041): (#31) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                              if (v14 >= 0x1F)
                                                v20 = 31;
                                              else
                                                v20 = v14;
                                              if ((sub_100085260(a1, "bandsAgeBinsSnapshot_", (uint64_t)v8, 8u, v20) & 1) == 0)
                                              {
                                                v22 = "ASPFTLParseBufferToCxt: bandsAgeBinsSnapshot(1041): Cannot add 31 "
                                                      "elements to context";
                                                goto LABEL_2228;
                                              }
                                            }
                                            goto LABEL_14;
                                          }
                                          if (v12 == 1042)
                                          {
                                            if ((_DWORD)v14 != 15)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: bandsAgeBinsReadSectors(1042): (#15) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0xF)
                                              v20 = 15;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "bandsAgeBinsReadSectors_", (uint64_t)v8, 8u, v20) & 1) == 0)
                                            {
                                              v22 = "ASPFTLParseBufferToCxt: bandsAgeBinsReadSectors(1042): Cannot add 15"
                                                    " elements to context";
                                              goto LABEL_2228;
                                            }
                                            goto LABEL_14;
                                          }
                                          if (v12 == 1080)
                                          {
                                            if ((sub_100085260(a1, "raidForceClogLoad", (uint64_t)v8, 8u, 1u) & 1) == 0)
                                            {
                                              v19 = "ASPFTLParseBufferToCxt: raidForceClogLoad(1080) cannot add 1 element to context";
LABEL_15:
                                              sub_1000756A0(v19, a2, a3, a4, a5, a6, a7, a8, v23);
                                            }
LABEL_16:
                                            v10 = (v10 + 1);
                                            goto LABEL_17;
                                          }
                                        }
                                        else if (v12 <= 1115)
                                        {
                                          if (v12 == 1105)
                                          {
                                            if ((_DWORD)v14 != 14)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: hostReadSequential(1105): (#14) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0xE)
                                              v20 = 14;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "hostReadSequential_", (uint64_t)v8, 8u, v20) & 1) == 0)
                                            {
                                              v22 = "ASPFTLParseBufferToCxt: hostReadSequential(1105): Cannot add 14 elements to context";
                                              goto LABEL_2228;
                                            }
                                            goto LABEL_14;
                                          }
                                          if (v12 == 1106)
                                          {
                                            if ((_DWORD)v14 != 14)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: GCReadSequential(1106): (#14) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0xE)
                                              v20 = 14;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "GCReadSequential_", (uint64_t)v8, 8u, v20) & 1) == 0)
                                            {
                                              v22 = "ASPFTLParseBufferToCxt: GCReadSequential(1106): Cannot add 14 elements to context";
                                              goto LABEL_2228;
                                            }
                                            goto LABEL_14;
                                          }
                                        }
                                        else
                                        {
                                          switch(v12)
                                          {
                                            case 1116:
                                              if ((_DWORD)v14 != 32)
                                                sub_1000756A0("ASPFTLParseBufferToCxt: gcwamp(1116): (#32) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                              if (v14 >= 0x20)
                                                v20 = 32;
                                              else
                                                v20 = v14;
                                              if ((sub_100085260(a1, "gcwamp_", (uint64_t)v8, 8u, v20) & 1) == 0)
                                              {
                                                v22 = "ASPFTLParseBufferToCxt: gcwamp(1116): Cannot add 32 elements to context";
                                                goto LABEL_2228;
                                              }
                                              goto LABEL_14;
                                            case 1137:
                                              if ((sub_100085260(a1, "numOfToUnhappySwitches", (uint64_t)v8, 8u, 1u) & 1) == 0)
                                              {
                                                v19 = "ASPFTLParseBufferToCxt: numOfToUnhappySwitches(1137) cannot add 1 "
                                                      "element to context";
                                                goto LABEL_15;
                                              }
                                              goto LABEL_16;
                                            case 1138:
                                              if ((sub_100085260(a1, "numOfToHappySwitches", (uint64_t)v8, 8u, 1u) & 1) == 0)
                                              {
                                                v19 = "ASPFTLParseBufferToCxt: numOfToHappySwitches(1138) cannot add 1 el"
                                                      "ement to context";
                                                goto LABEL_15;
                                              }
                                              goto LABEL_16;
                                          }
                                        }
LABEL_2116:
                                        if (v12 <= 1231)
                                        {
                                          switch(v12)
                                          {
                                            case 1198:
                                              if ((_DWORD)v14 != 3)
                                                sub_1000756A0("ASPFTLParseBufferToCxt: poDetectPERemovalMostSevereCost(1198): (#3) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                              if (v14 >= 3)
                                                v20 = 3;
                                              else
                                                v20 = v14;
                                              if ((sub_100085260(a1, "poDetectPERemovalMostSevereCost_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                              v22 = "ASPFTLParseBufferToCxt: poDetectPERemovalMostSevereCost(1198): Canno"
                                                    "t add 3 elements to context";
                                              goto LABEL_2228;
                                            case 1199:
                                              if ((sub_100085260(a1, "poDetectCurrentSize", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                                goto LABEL_16;
                                              v19 = "ASPFTLParseBufferToCxt: poDetectCurrentSize(1199) cannot add 1 element to context";
                                              goto LABEL_15;
                                            case 1200:
                                              goto LABEL_2166;
                                            case 1201:
                                              if ((_DWORD)v14 != 4)
                                                sub_1000756A0("ASPFTLParseBufferToCxt: gcVerticalSuccssfulAlignments(1201): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                              if (v14 >= 4)
                                                v20 = 4;
                                              else
                                                v20 = v14;
                                              if ((sub_100085260(a1, "gcVerticalSuccssfulAlignments_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                              v22 = "ASPFTLParseBufferToCxt: gcVerticalSuccssfulAlignments(1201): Cannot "
                                                    "add 4 elements to context";
                                              goto LABEL_2228;
                                            case 1202:
                                              if ((_DWORD)v14 != 4)
                                                sub_1000756A0("ASPFTLParseBufferToCxt: gcVerticalNoAlignmentDueToMissingSegs(1202): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                              if (v14 >= 4)
                                                v20 = 4;
                                              else
                                                v20 = v14;
                                              if ((sub_100085260(a1, "gcVerticalNoAlignmentDueToMissingSegs_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                              v22 = "ASPFTLParseBufferToCxt: gcVerticalNoAlignmentDueToMissingSegs(1202):"
                                                    " Cannot add 4 elements to context";
                                              goto LABEL_2228;
                                            default:
                                              switch(v12)
                                              {
                                                case 1216:
                                                  if ((_DWORD)v14 != 24)
                                                    sub_1000756A0("ASPFTLParseBufferToCxt: tlcWLPerDipAvgPEC(1216): (#24) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                                  if (v14 >= 0x18)
                                                    v20 = 24;
                                                  else
                                                    v20 = v14;
                                                  if ((sub_100085260(a1, "tlcWLPerDipAvgPEC_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                                    goto LABEL_14;
                                                  v22 = "ASPFTLParseBufferToCxt: tlcWLPerDipAvgPEC(1216): Cannot add 24 e"
                                                        "lements to context";
                                                  goto LABEL_2228;
                                                case 1217:
                                                  if ((_DWORD)v14 != 24)
                                                    sub_1000756A0("ASPFTLParseBufferToCxt: tlcWLPerDipMaxPEC(1217): (#24) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                                  if (v14 >= 0x18)
                                                    v20 = 24;
                                                  else
                                                    v20 = v14;
                                                  if ((sub_100085260(a1, "tlcWLPerDipMaxPEC_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                                    goto LABEL_14;
                                                  v22 = "ASPFTLParseBufferToCxt: tlcWLPerDipMaxPEC(1217): Cannot add 24 e"
                                                        "lements to context";
                                                  goto LABEL_2228;
                                                case 1218:
                                                  if ((_DWORD)v14 != 24)
                                                    sub_1000756A0("ASPFTLParseBufferToCxt: tlcWLPerDipMinPEC(1218): (#24) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                                  if (v14 >= 0x18)
                                                    v20 = 24;
                                                  else
                                                    v20 = v14;
                                                  if ((sub_100085260(a1, "tlcWLPerDipMinPEC_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                                    goto LABEL_14;
                                                  v22 = "ASPFTLParseBufferToCxt: tlcWLPerDipMinPEC(1218): Cannot add 24 e"
                                                        "lements to context";
                                                  goto LABEL_2228;
                                                case 1219:
                                                case 1220:
                                                case 1221:
                                                case 1222:
                                                case 1223:
                                                  goto LABEL_2166;
                                                case 1224:
                                                  if ((_DWORD)v14 != 20)
                                                    sub_1000756A0("ASPFTLParseBufferToCxt: apfsValidLbaOvershoot(1224): (#20) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                                  if (v14 >= 0x14)
                                                    v20 = 20;
                                                  else
                                                    v20 = v14;
                                                  if ((sub_100085260(a1, "apfsValidLbaOvershoot_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                                  v22 = "ASPFTLParseBufferToCxt: apfsValidLbaOvershoot(1224): Cannot add "
                                                        "20 elements to context";
                                                  goto LABEL_2228;
                                                default:
                                                  if (v12 != 1211)
                                                    goto LABEL_2166;
                                                  if ((_DWORD)v14 != 24)
                                                    sub_1000756A0("ASPFTLParseBufferToCxt: forcedAllocationSmallEraseQ(1211): (#24) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                                  if (v14 >= 0x18)
                                                    v20 = 24;
                                                  else
                                                    v20 = v14;
                                                  if ((sub_100085260(a1, "forcedAllocationSmallEraseQ_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                                  v22 = "ASPFTLParseBufferToCxt: forcedAllocationSmallEraseQ(1211): Canno"
                                                        "t add 24 elements to context";
                                                  break;
                                              }
                                              goto LABEL_2228;
                                          }
                                        }
                                        switch(v12)
                                        {
                                          case 1232:
                                            if ((sub_100085260(a1, "eanFastSize", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: eanFastSize(1232) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 1233:
                                            if ((sub_100085260(a1, "eanNumSlcEvictions", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: eanNumSlcEvictions(1233) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 1234:
                                            if ((sub_100085260(a1, "eanNumForcedCompress", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: eanNumForcedCompress(1234) cannot add 1 element to context";
                                            goto LABEL_15;
                                          case 1241:
                                            if ((_DWORD)v14 != 10)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: s2rTimeHisto(1241): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 0xA)
                                              v20 = 10;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "s2rTimeHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: s2rTimeHisto(1241): Cannot add 10 elements to context";
                                            goto LABEL_2228;
                                          case 1244:
                                            if ((sub_100085260(a1, "calendarTimeWentBackward", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                              goto LABEL_16;
                                            v19 = "ASPFTLParseBufferToCxt: calendarTimeWentBackward(1244) cannot add 1 el"
                                                  "ement to context";
                                            goto LABEL_15;
                                          case 1246:
                                            if ((_DWORD)v14 != 8)
                                              sub_1000756A0("ASPFTLParseBufferToCxt: bandsUeccCrossTempHisto(1246): (#8) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                            if (v14 >= 8)
                                              v20 = 8;
                                            else
                                              v20 = v14;
                                            if ((sub_100085260(a1, "bandsUeccCrossTempHisto_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                              goto LABEL_14;
                                            v22 = "ASPFTLParseBufferToCxt: bandsUeccCrossTempHisto(1246): Cannot add 8 el"
                                                  "ements to context";
                                            goto LABEL_2228;
                                          default:
LABEL_2166:
                                            if (v14 <= 1)
                                              snprintf(__str, 0x20uLL, "Stat_%d");
                                            else
                                              snprintf(__str, 0x20uLL, "Stat_%d_");
                                            if ((sub_100085260(a1, __str, (uint64_t)v8, 8u, v14) & 1) == 0)
                                            {
                                              sub_1000756A0("ASPFTLParseBufferToCxt %d: Cannot add %d elements to context", a2, a3, a4, a5, a6, a7, a8, v12);
                                              return v10;
                                            }
                                            v10 = (v10 + v14);
                                            break;
                                        }
LABEL_17:
                                        v8 += v14;
                                        v11 -= v14;
                                        goto LABEL_2;
                                      }
                                      switch(v12)
                                      {
                                        case 1147:
                                          if ((_DWORD)v14 != 24)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_concurrent_dw_gc12(1147): (#24) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 0x18)
                                            v20 = 24;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_concurrent_dw_gc12_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_concurrent_dw_gc12(1147): Cannot add 24 elements to context";
                                          goto LABEL_2228;
                                        case 1148:
                                          if ((_DWORD)v14 != 24)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_concurrent_dw_gc1(1148): (#24) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 0x18)
                                            v20 = 24;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_concurrent_dw_gc1_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_concurrent_dw_gc1(1148): Cannot add 24 elements to context";
                                          goto LABEL_2228;
                                        case 1149:
                                          if ((_DWORD)v14 != 24)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_concurrent_dw_gc2(1149): (#24) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 0x18)
                                            v20 = 24;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_concurrent_dw_gc2_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_concurrent_dw_gc2(1149): Cannot add 24 elements to context";
                                          goto LABEL_2228;
                                        case 1150:
                                        case 1151:
                                        case 1152:
                                        case 1153:
                                        case 1154:
                                        case 1155:
                                        case 1156:
                                        case 1159:
                                        case 1160:
                                        case 1161:
                                        case 1162:
                                        case 1163:
                                        case 1164:
                                        case 1165:
                                        case 1166:
                                        case 1167:
                                        case 1170:
                                        case 1173:
                                        case 1174:
                                        case 1175:
                                        case 1176:
                                        case 1177:
                                        case 1178:
                                        case 1186:
                                        case 1187:
                                        case 1188:
                                          goto LABEL_2116;
                                        case 1157:
                                          if ((sub_100085260(a1, "eanMaxForceROTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                            goto LABEL_16;
                                          v19 = "ASPFTLParseBufferToCxt: eanMaxForceROTimeMs(1157) cannot add 1 element to context";
                                          goto LABEL_15;
                                        case 1158:
                                          if ((sub_100085260(a1, "eanMaxForceRORecoTimeMs", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                            goto LABEL_16;
                                          v19 = "ASPFTLParseBufferToCxt: eanMaxForceRORecoTimeMs(1158) cannot add 1 element to context";
                                          goto LABEL_15;
                                        case 1168:
                                          if ((_DWORD)v14 != 2)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: poDetectPERemovalTotalCost(1168): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 2)
                                            v20 = 2;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "poDetectPERemovalTotalCost_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: poDetectPERemovalTotalCost(1168): Cannot add 2 e"
                                                "lements to context";
                                          goto LABEL_2228;
                                        case 1169:
                                          if ((_DWORD)v14 != 2)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: poDetectEmptySpotRemovalTotalCost(1169): (#2) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 2)
                                            v20 = 2;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "poDetectEmptySpotRemovalTotalCost_", (uint64_t)v8, 8u, v20) & 1) != 0)goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: poDetectEmptySpotRemovalTotalCost(1169): Cannot "
                                                "add 2 elements to context";
                                          goto LABEL_2228;
                                        case 1171:
                                          if ((_DWORD)v14 != 10)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: poDetectEmptySpotRemovalAge(1171): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 0xA)
                                            v20 = 10;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "poDetectEmptySpotRemovalAge_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: poDetectEmptySpotRemovalAge(1171): Cannot add 10"
                                                " elements to context";
                                          goto LABEL_2228;
                                        case 1172:
                                          if ((_DWORD)v14 != 3)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: poDetectGBBedMostSevereCost(1172): (#3) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 3)
                                            v20 = 3;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "poDetectGBBedMostSevereCost_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: poDetectGBBedMostSevereCost(1172): Cannot add 3 "
                                                "elements to context";
                                          goto LABEL_2228;
                                        case 1179:
                                          if ((_DWORD)v14 != 4)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_cur_dw_gc1(1179): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 4)
                                            v20 = 4;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_cur_dw_gc1_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_cur_dw_gc1(1179): Cannot add 4 elements to context";
                                          goto LABEL_2228;
                                        case 1180:
                                          if ((_DWORD)v14 != 4)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_cur_dw_gc2(1180): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 4)
                                            v20 = 4;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_cur_dw_gc2_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_cur_dw_gc2(1180): Cannot add 4 elements to context";
                                          goto LABEL_2228;
                                        case 1181:
                                          if ((_DWORD)v14 != 4)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_cur_dw_gc3(1181): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 4)
                                            v20 = 4;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_cur_dw_gc3_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_cur_dw_gc3(1181): Cannot add 4 elements to context";
                                          goto LABEL_2228;
                                        case 1182:
                                          if ((_DWORD)v14 != 4)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_tot_dw_gc1(1182): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 4)
                                            v20 = 4;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_tot_dw_gc1_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_tot_dw_gc1(1182): Cannot add 4 elements to context";
                                          goto LABEL_2228;
                                        case 1183:
                                          if ((_DWORD)v14 != 4)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: gc_tot_dw_gc2(1183): (#4) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 4)
                                            v20 = 4;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "gc_tot_dw_gc2_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: gc_tot_dw_gc2(1183): Cannot add 4 elements to context";
                                          goto LABEL_2228;
                                        case 1184:
                                          if ((sub_100085260(a1, "unhappy_state", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                            goto LABEL_16;
                                          v19 = "ASPFTLParseBufferToCxt: unhappy_state(1184) cannot add 1 element to context";
                                          goto LABEL_15;
                                        case 1185:
                                          if ((sub_100085260(a1, "unhappy_level", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                            goto LABEL_16;
                                          v19 = "ASPFTLParseBufferToCxt: unhappy_level(1185) cannot add 1 element to context";
                                          goto LABEL_15;
                                        case 1189:
                                          if ((sub_100085260(a1, "lastLbaFormatTime", (uint64_t)v8, 8u, 1u) & 1) != 0)
                                            goto LABEL_16;
                                          v19 = "ASPFTLParseBufferToCxt: lastLbaFormatTime(1189) cannot add 1 element to context";
                                          goto LABEL_15;
                                        case 1190:
                                          if ((_DWORD)v14 != 12)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: powerDownTime(1190): (#12) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 0xC)
                                            v20 = 12;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "powerDownTime_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                            goto LABEL_14;
                                          v22 = "ASPFTLParseBufferToCxt: powerDownTime(1190): Cannot add 12 elements to context";
                                          goto LABEL_2228;
                                        default:
                                          if (v12 != 1196)
                                          {
                                            if (v12 == 1197)
                                            {
                                              if ((_DWORD)v14 != 10)
                                                sub_1000756A0("ASPFTLParseBufferToCxt: poDetectGBBedAge(1197): (#10) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                              if (v14 >= 0xA)
                                                v20 = 10;
                                              else
                                                v20 = v14;
                                              if ((sub_100085260(a1, "poDetectGBBedAge_", (uint64_t)v8, 8u, v20) & 1) == 0)
                                              {
                                                v22 = "ASPFTLParseBufferToCxt: poDetectGBBedAge(1197): Cannot add 10 elements to context";
                                                goto LABEL_2228;
                                              }
                                              goto LABEL_14;
                                            }
                                            goto LABEL_2116;
                                          }
                                          if ((_DWORD)v14 != 5)
                                            sub_1000756A0("ASPFTLParseBufferToCxt: poDetectGBBedTotalCost(1196): (#5) cfg elements != (%d) buffer elements", a2, a3, a4, a5, a6, a7, a8, v14);
                                          if (v14 >= 5)
                                            v20 = 5;
                                          else
                                            v20 = v14;
                                          if ((sub_100085260(a1, "poDetectGBBedTotalCost_", (uint64_t)v8, 8u, v20) & 1) != 0)
                                          {
LABEL_14:
                                            v10 = v20 + v10;
                                            goto LABEL_17;
                                          }
                                          v22 = "ASPFTLParseBufferToCxt: poDetectGBBedTotalCost(1196): Cannot add 5 elements to context";
LABEL_2228:
                                          sub_1000756A0(v22, a2, a3, a4, a5, a6, a7, a8, v23);
                                          return v10;
                                      }
                                  }
                              }
                          }
                      }
                  }
              }
          }
      }
  }
}

uint64_t sub_100085260(uint64_t a1, const char *a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v5;
  int v11;
  int v12;
  uint64_t v14;
  char __str[101];

  v14 = 0;
  v5 = 1;
  if (a4 && a5)
  {
    if (a5 == 1)
    {
      if (a4 <= 8)
      {
        __memmove_chk(&v14, a3, a4, 8);
        return sub_10008BCF4(a1, "", a2, v14);
      }
      else
      {
        return 0;
      }
    }
    else
    {
      v11 = 0;
      v12 = 0;
      do
      {
        v14 = 0;
        if (a4 <= 8)
        {
          __memmove_chk(&v14, a3 + v11 * a4, a4, 8);
          snprintf(__str, 0x64uLL, "%d", v11);
          __str[100] = 0;
          v5 = sub_10008BCF4(a1, a2, __str, v14) & v5;
        }
        else
        {
          v5 = 0;
        }
        v11 = (unsigned __int16)++v12;
      }
      while ((unsigned __int16)v12 < a5);
    }
  }
  return v5;
}

uint64_t sub_1000853C0(uint64_t a1, unint64_t *a2, unsigned int a3)
{
  uint64_t v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char __str[16];
  __int128 v22;

  v5 = 0;
  v6 = a3 >> 3;
  *(_OWORD *)__str = 0u;
  v22 = 0u;
LABEL_2:
  v7 = -v6;
  while (v7)
  {
    v9 = *a2++;
    v8 = v9;
    v10 = HIDWORD(v9);
    ++v7;
    if (HIDWORD(v9))
    {
      if (v8 != 0xFFFF && v8 <= 0x30000000 && -v7 >= v10)
      {
        if (v10 <= 1)
          snprintf(__str, 0x20uLL, "Stat_%d");
        else
          snprintf(__str, 0x20uLL, "Stat_%d_");
        if ((sub_100085260(a1, __str, (uint64_t)a2, 8u, v10) & 1) != 0)
        {
          v5 = (v5 + v10);
          a2 += v10;
          v6 = -v7 - v10;
          goto LABEL_2;
        }
        sub_1000756A0("ASPFTLParseBufferToCxt %d: Cannot add %d elements to context", v13, v14, v15, v16, v17, v18, v19, v8);
      }
      return v5;
    }
  }
  return v5;
}

uint64_t sub_1000854E8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  const char *v9;
  unsigned int v10;
  uint64_t v11;
  __int16 *v13;
  const char *v14;
  unsigned __int16 *v15;
  uint64_t v16;
  int v17;
  const char *v19;
  __int16 *v20;
  unsigned int v21;
  unsigned int v22;
  char v24;

  v8 = 0;
  v9 = "ASPMSPParseBufferToCxt: Passed in invalid buffer or empty buffer";
  if (!a2)
    goto LABEL_1981;
  v10 = a3;
  if (!(_DWORD)a3)
    goto LABEL_1981;
  v11 = a2;
  v8 = 0;
  v13 = &jpt_10008963C;
  v14 = "ASPMSPParseBufferToCxt: fs1_4b_fail(4279): Error adding 4 elements to context";
  v9 = "ASPMSPParseBufferToCxt: cbdr_step_5(4256): Error adding 10 elements to context";
  while (1)
  {
    do
    {
      if (!v10)
        return v8;
      v15 = (unsigned __int16 *)v11;
      v16 = *(unsigned __int16 *)(v11 + 2);
      v11 += 4;
      v10 -= 4;
    }
    while (!(_DWORD)v16);
    v17 = *v15;
    if (v17 != 12286)
      break;
LABEL_461:
    v11 += v16;
    v10 -= v16;
  }
  if (v17 == 12287 || v10 < v16)
    return v8;
  switch(v17)
  {
    case 4096:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: passWithTmodeHard(4096): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "passWithTmodeHard", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: passWithTmodeHard(4096): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4097:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: passWithTmodeFS1_2b(4097): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "passWithTmodeFS1_2b", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: passWithTmodeFS1_2b(4097): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4098:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: passWithTmodeFS1_4b(4098): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "passWithTmodeFS1_4b", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: passWithTmodeFS1_4b(4098): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4099:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: passWithTmodeHard_fast(4099): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "passWithTmodeHard_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: passWithTmodeHard_fast(4099): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4100:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: passWithTmodeFS1_2b_fast(4100): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "passWithTmodeFS1_2b_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: passWithTmodeFS1_2b_fast(4100): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4101:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: passWithTmodeFS1_4b_fast(4101): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "passWithTmodeFS1_4b_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: passWithTmodeFS1_4b_fast(4101): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4102:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: numOfCwFailedInTmodeFS2_EOL(4102): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "numOfCwFailedInTmodeFS2_EOL", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: numOfCwFailedInTmodeFS2_EOL(4102): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4103:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: numOfCwFailedInTmodeFS2_DSP_EOL(4103): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "numOfCwFailedInTmodeFS2_DSP_EOL", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: numOfCwFailedInTmodeFS2_DSP_EOL(4103): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4104:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithHardAfterAcq(4104): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithHardAfterAcq", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithHardAfterAcq(4104): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4105:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: firstReadWasHardWithDefaultBDBFastRead(4105): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "firstReadWasHardWithDefaultBDBFastRead", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: firstReadWasHardWithDefaultBDBFastRead(4105): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4106:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithDS1(4106): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithDS1", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithDS1(4106): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4107:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithDYCE1(4107): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithDYCE1", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithDYCE1(4107): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4108:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithDS2(4108): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithDS2", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithDS2(4108): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4109:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithDYCE2(4109): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithDYCE2", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithDYCE2(4109): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4110:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: firstReadWasHardWithAcq(4110): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "firstReadWasHardWithAcq", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: firstReadWasHardWithAcq(4110): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4111:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_LSB(4111): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDynamicMovedToEOL_LSB", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_LSB(4111): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4112:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_MSB(4112): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDynamicMovedToEOL_MSB", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_MSB(4112): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4113:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_USB(4113): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDynamicMovedToEOL_USB", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_USB(4113): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4114:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_LSB(4114): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDynamicMovedToSOL_LSB", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_LSB(4114): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4115:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_MSB(4115): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDynamicMovedToSOL_MSB", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_MSB(4115): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4116:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_USB(4116): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDynamicMovedToSOL_USB", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_USB(4116): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4117:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: firstReadWasHardWithDefaultBDB(4117): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "firstReadWasHardWithDefaultBDB", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: firstReadWasHardWithDefaultBDB(4117): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4118:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughSyndSumAcquisition(4118): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughSyndSumAcquisition", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughSyndSumAcquisition(4118): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4119:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughSlip(4119): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughSlip", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughSlip(4119): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4120:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 44)
        sub_1000756A0("ASPMSPParseBufferToCxt: FS2decodedBitFlips(4120): cfg 11 elements; (11*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 0x30)
        v21 = 11;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "FS2decodedBitFlips", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: FS2decodedBitFlips(4120): Error adding 11 elements to context";
      goto LABEL_1981;
    case 4121:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 16)
        sub_1000756A0("ASPMSPParseBufferToCxt: slipTrackingAfterFs1ForceFailChangedVthInTicksHist(4121): cfg 4 elements; (4*4) cfg by"
          "tes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 0x14)
        v21 = 4;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "slipTrackingAfterFs1ForceFailChangedVthInTicksHist", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: slipTrackingAfterFs1ForceFailChangedVthInTicksHist(4121): Error adding 4 elements to context";
      goto LABEL_1981;
    case 4122:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS2_4b_fast(4122): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS2_4b_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS2_4b_fast(4122): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4123:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithHardAfterSlip_fast(4123): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithHardAfterSlip_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithHardAfterSlip_fast(4123): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4124:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS12BitAfterSlip_fast(4124): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS12BitAfterSlip_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS12BitAfterSlip_fast(4124): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4125:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS14BitAfterSlip_fast(4125): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS14BitAfterSlip_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS14BitAfterSlip_fast(4125): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4126:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS3_fast(4126): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS3_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS3_fast(4126): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4127:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 40)
        sub_1000756A0("ASPMSPParseBufferToCxt: deepSoft1Decoded(4127): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 0x2C)
        v21 = 10;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "deepSoft1Decoded", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: deepSoft1Decoded(4127): Error adding 10 elements to context";
      goto LABEL_1981;
    case 4128:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 40)
        sub_1000756A0("ASPMSPParseBufferToCxt: deepSoft2Decoded(4128): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 0x2C)
        v21 = 10;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "deepSoft2Decoded", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: deepSoft2Decoded(4128): Error adding 10 elements to context";
      goto LABEL_1981;
    case 4129:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_2b_fast(4129): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughFS2_2b_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_2b_fast(4129): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4130:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_4b_fast(4130): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughFS2_4b_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_4b_fast(4130): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4131:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughSlip_fast(4131): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughSlip_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughSlip_fast(4131): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4132:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughFS3_fast(4132): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughFS3_fast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughFS3_fast(4132): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4133:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithEXH(4133): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithEXH", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithEXH(4133): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4134:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 44)
        sub_1000756A0("ASPMSPParseBufferToCxt: FS1decodedbitflips(4134): cfg 11 elements; (11*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 0x30)
        v21 = 11;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "FS1decodedbitflips", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: FS1decodedbitflips(4134): Error adding 11 elements to context";
      goto LABEL_1981;
    case 4135:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readZeroPage(4135): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readZeroPage", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readZeroPage(4135): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4136:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readErasedPage(4136): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readErasedPage", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readErasedPage(4136): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4137:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readFail(4137): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readFail", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readFail(4137): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4138:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 20)
        sub_1000756A0("ASPMSPParseBufferToCxt: numOfSensesWereSentDuringSyndSumAcq(4138): cfg 5 elements; (5*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 0x18)
        v21 = 5;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "numOfSensesWereSentDuringSyndSumAcq", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: numOfSensesWereSentDuringSyndSumAcq(4138): Error adding 5 elements to context";
      goto LABEL_1981;
    case 4139:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 12)
        sub_1000756A0("ASPMSPParseBufferToCxt: numOfSensesWereSentDuringMiniAcq(4139): cfg 3 elements; (3*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 0x10)
        v21 = 3;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "numOfSensesWereSentDuringMiniAcq", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: numOfSensesWereSentDuringMiniAcq(4139): Error adding 3 elements to context";
      goto LABEL_1981;
    case 4140:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDefaultMoveFastToNormal(4140): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDefaultMoveFastToNormal", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDefaultMoveFastToNormal(4140): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4141:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: bdbDefaultMoveNormalToFast(4141): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "bdbDefaultMoveNormalToFast", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: bdbDefaultMoveNormalToFast(4141): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4142:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithEXH_DSP(4142): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithEXH_DSP", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithEXH_DSP(4142): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4143:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithDS1_DSP(4143): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithDS1_DSP", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithDS1_DSP(4143): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4144:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readalgoPassWithDYCE1_DSP(4144): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readalgoPassWithDYCE1_DSP", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readalgoPassWithDYCE1_DSP(4144): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4145:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: firstReadWasFS2EOL_DSP(4145): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "firstReadWasFS2EOL_DSP", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: firstReadWasFS2EOL_DSP(4145): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4146:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: firstReadWasFS2EOL(4146): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "firstReadWasFS2EOL", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: firstReadWasFS2EOL(4146): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4147:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_4b(4147): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughFS2_4b", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_4b(4147): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4148:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS2_4b(4148): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS2_4b", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS2_4b(4148): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4149:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_2b(4149): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughFS2_2b", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughFS2_2b(4149): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4150:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughFS3(4150): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughFS3", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughFS3(4150): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4151:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughDS1(4151): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughDS1", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughDS1(4151): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4152:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughDS2(4152): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughDS2", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughDS2(4152): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4153:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithHardAfterSlip(4153): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithHardAfterSlip", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithHardAfterSlip(4153): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4154:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS12BitAfterSlip(4154): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS12BitAfterSlip", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS12BitAfterSlip(4154): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4155:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS14BitAfterSlip(4155): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS14BitAfterSlip", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS14BitAfterSlip(4155): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4156:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS3(4156): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS3", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS3(4156): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4157:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughSyndSumAcquisition_DSP(4157): cfg 1 elements; (1*4) cfg bytes != "
          "(%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassedThroughSyndSumAcquisition_DSP", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughSyndSumAcquisition_DSP(4157): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4158:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS12BitAfterAcq(4158): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS12BitAfterAcq", v11, 4u, v21))
        goto LABEL_460;
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS12BitAfterAcq(4158): Error adding 1 elements to context";
      goto LABEL_1981;
    case 4159:
      v19 = v14;
      v20 = v13;
      if ((_DWORD)v16 != 4)
        sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassWithFS14BitAfterAcq(4159): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
          a2,
          a3,
          a4,
          a5,
          a6,
          a7,
          a8,
          v16);
      if (v16 >= 8)
        v21 = 1;
      else
        v21 = v16 >> 2;
      if (sub_100085260(a1, "readAlgoPassWithFS14BitAfterAcq", v11, 4u, v21))
      {
LABEL_460:
        v8 = v8 + v21;
        v13 = v20;
        v14 = v19;
        goto LABEL_461;
      }
      v9 = "ASPMSPParseBufferToCxt: readAlgoPassWithFS14BitAfterAcq(4159): Error adding 1 elements to context";
LABEL_1981:
      sub_1000756A0(v9, a2, a3, a4, a5, a6, a7, a8, v24);
      return v8;
    default:
      switch(v17)
      {
        case 4160:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: readAlgoPassedThroughDS1_DSP(4160): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readAlgoPassedThroughDS1_DSP", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readAlgoPassedThroughDS1_DSP(4160): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4161:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: numOfSlipTracking(4161): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "numOfSlipTracking", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: numOfSlipTracking(4161): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4162:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_QSB(4162): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "bdbDynamicMovedToEOL_QSB", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToEOL_QSB(4162): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4163:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_QSB(4163): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "bdbDynamicMovedToSOL_QSB", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: bdbDynamicMovedToSOL_QSB(4163): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4196:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails100(4196): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails100", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails100(4196): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4197:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails101(4197): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails101", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails101(4197): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4198:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage100(4198): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage100", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage100(4198): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4199:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage101(4199): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage101", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage101(4199): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4200:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage100(4200): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "initialReadStage100", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: initialReadStage100(4200): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4201:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage102(4201): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage102", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage102(4201): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4202:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage101(4202): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "initialReadStage101", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: initialReadStage101(4202): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4203:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: nandStageOfLife100(4203): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "nandStageOfLife100", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: nandStageOfLife100(4203): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4204:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: nandStageOfLife101(4204): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "nandStageOfLife101", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: nandStageOfLife101(4204): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4205:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails102(4205): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails102", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails102(4205): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4206:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage102(4206): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "initialReadStage102", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: initialReadStage102(4206): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4207:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage103(4207): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage103", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage103(4207): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4208:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage104(4208): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage104", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage104(4208): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4209:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage105(4209): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage105", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage105(4209): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4210:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage106(4210): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage106", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage106(4210): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4211:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter100(4211): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter100", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter100(4211): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4212:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter101(4212): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter101", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter101(4212): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4213:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage103(4213): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "initialReadStage103", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: initialReadStage103(4213): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4214:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage104(4214): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "initialReadStage104", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: initialReadStage104(4214): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4215:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage107(4215): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage107", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage107(4215): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4216:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage108(4216): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage108", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage108(4216): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4217:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: nandStageOfLife102(4217): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "nandStageOfLife102", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: nandStageOfLife102(4217): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4218:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: nandStageOfLife103(4218): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "nandStageOfLife103", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: nandStageOfLife103(4218): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4219:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: nandStageOfLife104(4219): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "nandStageOfLife104", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: nandStageOfLife104(4219): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4220:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter102(4220): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter102", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter102(4220): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4221:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter103(4221): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter103", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter103(4221): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4222:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter104(4222): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter104", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter104(4222): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4223:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter105(4223): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter105", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter105(4223): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4224:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter106(4224): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter106", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter106(4224): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4225:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter107(4225): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter107", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter107(4225): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4226:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter108(4226): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter108", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter108(4226): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4227:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter109(4227): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter109", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter109(4227): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4228:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter110(4228): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter110", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter110(4228): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4229:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter111(4229): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter111", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter111(4229): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4230:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter112(4230): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter112", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter112(4230): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4231:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter113(4231): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter113", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter113(4231): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4232:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 256)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails108(4232): cfg 64 elements; (64*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x104)
            v21 = 64;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails108", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails108(4232): Error adding 64 elements to context";
          goto LABEL_1981;
        case 4233:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 256)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails103(4233): cfg 64 elements; (64*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x104)
            v21 = 64;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails103", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails103(4233): Error adding 64 elements to context";
          goto LABEL_1981;
        case 4234:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails104(4234): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails104", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails104(4234): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4235:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails105(4235): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails105", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails105(4235): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4236:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails106(4236): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails106", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails106(4236): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4237:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails107(4237): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfFails107", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails107(4237): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4238:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage109(4238): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage109", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage109(4238): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4239:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 16)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStage110(4239): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x14)
            v21 = 4;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStage110", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStage110(4239): Error adding 4 elements to context";
          goto LABEL_1981;
        case 4240:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 80)
            sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfErrorsBin100(4240): cfg 20 elements; (20*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x54)
            v21 = 20;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "readStageNumOfErrorsBin100", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: readStageNumOfErrorsBin100(4240): Error adding 20 elements to context";
          goto LABEL_1981;
        case 4241:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 80)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter114(4241): cfg 20 elements; (20*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x54)
            v21 = 20;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter114", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter114(4241): Error adding 20 elements to context";
          goto LABEL_1981;
        case 4242:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter115(4242): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter115", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter115(4242): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4243:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter116(4243): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter116", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter116(4243): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4244:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter117(4244): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter117", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter117(4244): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4245:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter118(4245): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter118", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter118(4245): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4246:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter119(4246): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter119", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter119(4246): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4247:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter120(4247): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter120", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter120(4247): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4248:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter121(4248): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "dspExceptionParameter121", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter121(4248): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4249:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_ref_1(4249): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "cbdr_ref_1", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: cbdr_ref_1(4249): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4250:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_ref_2(4250): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "cbdr_ref_2", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: cbdr_ref_2(4250): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4251:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 4)
            sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_outlier(4251): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 8)
            v21 = 1;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "cbdr_outlier", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: cbdr_outlier(4251): Error adding 1 elements to context";
          goto LABEL_1981;
        case 4252:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 40)
            sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_step_1(4252): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x2C)
            v21 = 10;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "cbdr_step_1", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: cbdr_step_1(4252): Error adding 10 elements to context";
          goto LABEL_1981;
        case 4253:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 40)
            sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_step_2(4253): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x2C)
            v21 = 10;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "cbdr_step_2", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: cbdr_step_2(4253): Error adding 10 elements to context";
          goto LABEL_1981;
        case 4254:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 40)
            sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_step_3(4254): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x2C)
            v21 = 10;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "cbdr_step_3", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: cbdr_step_3(4254): Error adding 10 elements to context";
          goto LABEL_1981;
        case 4255:
          v19 = v14;
          v20 = v13;
          if ((_DWORD)v16 != 40)
            sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_step_4(4255): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
              a2,
              a3,
              a4,
              a5,
              a6,
              a7,
              a8,
              v16);
          if (v16 >= 0x2C)
            v21 = 10;
          else
            v21 = v16 >> 2;
          if (sub_100085260(a1, "cbdr_step_4", v11, 4u, v21))
            goto LABEL_460;
          v9 = "ASPMSPParseBufferToCxt: cbdr_step_4(4255): Error adding 10 elements to context";
          goto LABEL_1981;
        default:
          switch(v17)
          {
            case 12288:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails200(12288): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStageNumOfFails200", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails200(12288): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12289:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage200(12289): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage200", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage200(12289): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12290:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage201(12290): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage201", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage201(12290): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12291:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails201(12291): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStageNumOfFails201", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails201(12291): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12292:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage202(12292): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage202", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage202(12292): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12293:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage203(12293): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage203", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage203(12293): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12294:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails202(12294): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStageNumOfFails202", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails202(12294): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12295:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStageNumOfFails203(12295): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStageNumOfFails203", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStageNumOfFails203(12295): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12296:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage204(12296): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage204", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage204(12296): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12297:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage205(12297): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage205", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage205(12297): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12298:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage206(12298): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage206", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage206(12298): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12299:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage207(12299): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage207", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage207(12299): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12300:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage208(12300): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage208", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage208(12300): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12301:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage209(12301): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage209", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage209(12301): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12302:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage200(12302): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage200", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage200(12302): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12303:
              if ((_DWORD)v16 != 32)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage201(12303): cfg 4 elements; (4*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x28)
                v22 = 4;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage201", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage201(12303): Error adding 4 elements to context";
              goto LABEL_1981;
            case 12304:
              if ((_DWORD)v16 != 32)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage202(12304): cfg 4 elements; (4*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x28)
                v22 = 4;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage202", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage202(12304): Error adding 4 elements to context";
              goto LABEL_1981;
            case 12305:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage210(12305): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage210", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage210(12305): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12306:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage211(12306): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage211", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage211(12306): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12307:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage203(12307): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage203", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage203(12307): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12308:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage204(12308): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage204", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage204(12308): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12309:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage205(12309): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage205", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage205(12309): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12310:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage206(12310): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage206", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage206(12310): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12311:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage207(12311): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage207", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage207(12311): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12312:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage208(12312): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage208", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage208(12312): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12313:
              if ((_DWORD)v16 != 32)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage209(12313): cfg 4 elements; (4*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x28)
                v22 = 4;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage209", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage209(12313): Error adding 4 elements to context";
              goto LABEL_1981;
            case 12314:
              if ((_DWORD)v16 != 32)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage210(12314): cfg 4 elements; (4*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x28)
                v22 = 4;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage210", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage210(12314): Error adding 4 elements to context";
              goto LABEL_1981;
            case 12315:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage212(12315): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage212", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage212(12315): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12316:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStage213(12316): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "initialReadStage213", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: initialReadStage213(12316): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12317:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage211(12317): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage211", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage211(12317): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12318:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage212(12318): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage212", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage212(12318): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12319:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage213(12319): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage213", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage213(12319): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12320:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage214(12320): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage214", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage214(12320): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12321:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: readStage215(12321): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "readStage215", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: readStage215(12321): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12322:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter142(12322): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "dspExceptionParameter142", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter142(12322): Error adding 1 elements to context";
              goto LABEL_1981;
            case 12323:
              if ((_DWORD)v16 != 8)
                sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter143(12323): cfg 1 elements; (1*8) cfg bytes != (%d) buffer bytes",
                  a2,
                  a3,
                  a4,
                  a5,
                  a6,
                  a7,
                  a8,
                  v16);
              if (v16 >= 0x10)
                v22 = 1;
              else
                v22 = v16 >> 3;
              if (sub_100085260(a1, "dspExceptionParameter143", v11, 8u, v22))
                goto LABEL_1372;
              v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter143(12323): Error adding 1 elements to context";
              goto LABEL_1981;
            default:
              switch(v17)
              {
                case 4256:
                  if ((_DWORD)v16 != 40)
                    sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_step_5(4256): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x2C)
                    v22 = 10;
                  else
                    v22 = v16 >> 2;
                  if (!sub_100085260(a1, "cbdr_step_5", v11, 4u, v22))
                    goto LABEL_1981;
                  goto LABEL_1372;
                case 4257:
                  if ((_DWORD)v16 != 40)
                    sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_step_6(4257): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x2C)
                    v22 = 10;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "cbdr_step_6", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: cbdr_step_6(4257): Error adding 10 elements to context";
                  goto LABEL_1981;
                case 4258:
                  if ((_DWORD)v16 != 40)
                    sub_1000756A0("ASPMSPParseBufferToCxt: cbdr_step_7(4258): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x2C)
                    v22 = 10;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "cbdr_step_7", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: cbdr_step_7(4258): Error adding 10 elements to context";
                  goto LABEL_1981;
                case 4259:
                  if ((_DWORD)v16 != 80)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter122(4259): cfg 20 elements; (20*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x54)
                    v22 = 20;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter122", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter122(4259): Error adding 20 elements to context";
                  goto LABEL_1981;
                case 4260:
                  if ((_DWORD)v16 != 32)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter123(4260): cfg 8 elements; (8*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x24)
                    v22 = 8;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter123", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter123(4260): Error adding 8 elements to context";
                  goto LABEL_1981;
                case 4261:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter124(4261): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter124", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter124(4261): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4262:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter125(4262): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter125", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter125(4262): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4263:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter126(4263): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter126", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter126(4263): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4264:
                  if ((_DWORD)v16 != 16)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter127(4264): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x14)
                    v22 = 4;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter127", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter127(4264): Error adding 4 elements to context";
                  goto LABEL_1981;
                case 4265:
                  if ((_DWORD)v16 != 16)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter128(4265): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x14)
                    v22 = 4;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter128", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter128(4265): Error adding 4 elements to context";
                  goto LABEL_1981;
                case 4266:
                  if ((_DWORD)v16 != 16)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter129(4266): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x14)
                    v22 = 4;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter129", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter129(4266): Error adding 4 elements to context";
                  goto LABEL_1981;
                case 4267:
                  if ((_DWORD)v16 != 16)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter130(4267): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x14)
                    v22 = 4;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter130", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter130(4267): Error adding 4 elements to context";
                  goto LABEL_1981;
                case 4268:
                  if ((_DWORD)v16 != 16)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter131(4268): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x14)
                    v22 = 4;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter131", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter131(4268): Error adding 4 elements to context";
                  goto LABEL_1981;
                case 4269:
                  if ((_DWORD)v16 != 40)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter132(4269): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x2C)
                    v22 = 10;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter132", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter132(4269): Error adding 10 elements to context";
                  goto LABEL_1981;
                case 4270:
                  if ((_DWORD)v16 != 40)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter133(4270): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x2C)
                    v22 = 10;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter133", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter133(4270): Error adding 10 elements to context";
                  goto LABEL_1981;
                case 4271:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter134(4271): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter134", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter134(4271): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4272:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter135(4272): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter135", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter135(4272): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4273:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter136(4273): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter136", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter136(4273): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4274:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter137(4274): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter137", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter137(4274): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4275:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter138(4275): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter138", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter138(4275): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4276:
                  if ((_DWORD)v16 != 16)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter139(4276): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 0x14)
                    v22 = 4;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter139", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter139(4276): Error adding 4 elements to context";
                  goto LABEL_1981;
                case 4277:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter140(4277): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter140", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter140(4277): Error adding 1 elements to context";
                  goto LABEL_1981;
                case 4278:
                  if ((_DWORD)v16 != 4)
                    sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter141(4278): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                      a2,
                      a3,
                      a4,
                      a5,
                      a6,
                      a7,
                      a8,
                      v16);
                  if (v16 >= 8)
                    v22 = 1;
                  else
                    v22 = v16 >> 2;
                  if (sub_100085260(a1, "dspExceptionParameter141", v11, 4u, v22))
                    goto LABEL_1372;
                  v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter141(4278): Error adding 1 elements to context";
                  goto LABEL_1981;
                default:
                  switch(v17)
                  {
                    case 4164:
                      if ((_DWORD)v16 != 4)
                        sub_1000756A0("ASPMSPParseBufferToCxt: syndSumAcqConvergedToStaticWalls(4164): cfg 1 elements; (1*4) cfg byte"
                          "s != (%d) buffer bytes",
                          a2,
                          a3,
                          a4,
                          a5,
                          a6,
                          a7,
                          a8,
                          v16);
                      if (v16 >= 8)
                        v22 = 1;
                      else
                        v22 = v16 >> 2;
                      if (sub_100085260(a1, "syndSumAcqConvergedToStaticWalls", v11, 4u, v22))
                        goto LABEL_1372;
                      v9 = "ASPMSPParseBufferToCxt: syndSumAcqConvergedToStaticWalls(4164): Error adding 1 elements to context";
                      goto LABEL_1981;
                    case 4165:
                      if ((_DWORD)v16 != 60)
                        sub_1000756A0("ASPMSPParseBufferToCxt: DYCE1_Decoded_Bitflips(4165): cfg 15 elements; (15*4) cfg bytes != (%d) buffer bytes",
                          a2,
                          a3,
                          a4,
                          a5,
                          a6,
                          a7,
                          a8,
                          v16);
                      if (v16 >= 0x40)
                        v22 = 15;
                      else
                        v22 = v16 >> 2;
                      if (sub_100085260(a1, "DYCE1_Decoded_Bitflips", v11, 4u, v22))
                        goto LABEL_1372;
                      v9 = "ASPMSPParseBufferToCxt: DYCE1_Decoded_Bitflips(4165): Error adding 15 elements to context";
                      goto LABEL_1981;
                    case 4166:
                      if ((_DWORD)v16 != 80)
                        sub_1000756A0("ASPMSPParseBufferToCxt: DYCE1_Target_Bitflips(4166): cfg 20 elements; (20*4) cfg bytes != (%d) buffer bytes",
                          a2,
                          a3,
                          a4,
                          a5,
                          a6,
                          a7,
                          a8,
                          v16);
                      if (v16 >= 0x54)
                        v22 = 20;
                      else
                        v22 = v16 >> 2;
                      if (sub_100085260(a1, "DYCE1_Target_Bitflips", v11, 4u, v22))
                        goto LABEL_1372;
                      v9 = "ASPMSPParseBufferToCxt: DYCE1_Target_Bitflips(4166): Error adding 20 elements to context";
                      goto LABEL_1981;
                    case 4167:
                      if ((_DWORD)v16 != 60)
                        sub_1000756A0("ASPMSPParseBufferToCxt: DYCE2_Decoded_Bitflips(4167): cfg 15 elements; (15*4) cfg bytes != (%d) buffer bytes",
                          a2,
                          a3,
                          a4,
                          a5,
                          a6,
                          a7,
                          a8,
                          v16);
                      if (v16 >= 0x40)
                        v22 = 15;
                      else
                        v22 = v16 >> 2;
                      if (sub_100085260(a1, "DYCE2_Decoded_Bitflips", v11, 4u, v22))
                        goto LABEL_1372;
                      v9 = "ASPMSPParseBufferToCxt: DYCE2_Decoded_Bitflips(4167): Error adding 15 elements to context";
                      goto LABEL_1981;
                    case 4168:
                      if ((_DWORD)v16 != 80)
                        sub_1000756A0("ASPMSPParseBufferToCxt: DYCE2_Target_Bitflips(4168): cfg 20 elements; (20*4) cfg bytes != (%d) buffer bytes",
                          a2,
                          a3,
                          a4,
                          a5,
                          a6,
                          a7,
                          a8,
                          v16);
                      if (v16 >= 0x54)
                        v22 = 20;
                      else
                        v22 = v16 >> 2;
                      if (sub_100085260(a1, "DYCE2_Target_Bitflips", v11, 4u, v22))
                        goto LABEL_1372;
                      v9 = "ASPMSPParseBufferToCxt: DYCE2_Target_Bitflips(4168): Error adding 20 elements to context";
                      goto LABEL_1981;
                    default:
                      if (v17 <= 12323)
                      {
                        switch(v17)
                        {
                          case 8193:
                            if ((_DWORD)v16 != 20)
                              sub_1000756A0("ASPMSPParseBufferToCxt: avg_rd_window_size(8193): cfg 5 elements; (5*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x18)
                              v22 = 5;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "avg_rd_window_size", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: avg_rd_window_size(8193): Error adding 5 elements to context";
                            break;
                          case 8194:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: num_zq_failures(8194): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "num_zq_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: num_zq_failures(8194): Error adding 1 elements to context";
                            break;
                          case 8195:
                            if ((_DWORD)v16 != 64)
                              sub_1000756A0("ASPMSPParseBufferToCxt: lower_die_temperature(8195): cfg 16 elements; (16*4) cfg bytes !"
                                "= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x44)
                              v22 = 16;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "lower_die_temperature", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: lower_die_temperature(8195): Error adding 16 elements to context";
                            break;
                          case 8196:
                            if ((_DWORD)v16 != 64)
                              sub_1000756A0("ASPMSPParseBufferToCxt: higher_die_temperature(8196): cfg 16 elements; (16*4) cfg bytes "
                                "!= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x44)
                              v22 = 16;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "higher_die_temperature", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: higher_die_temperature(8196): Error adding 16 elements to context";
                            break;
                          case 8197:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: number_of_sram_flips(8197): cfg 1 elements; (1*4) cfg bytes != ("
                                "%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "number_of_sram_flips", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: number_of_sram_flips(8197): Error adding 1 elements to context";
                            break;
                          case 8198:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: number_of_reset_failures(8198): cfg 1 elements; (1*4) cfg bytes "
                                "!= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "number_of_reset_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: number_of_reset_failures(8198): Error adding 1 elements to context";
                            break;
                          case 8199:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: device_config(8199): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "device_config", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: device_config(8199): Error adding 1 elements to context";
                            break;
                          case 8200:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: number_of_throttling_events(8200): cfg 1 elements; (1*4) cfg byt"
                                "es != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "number_of_throttling_events", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: number_of_throttling_events(8200): Error adding 1 elements to context";
                            break;
                          case 8201:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: link_speed_recoveries(8201): cfg 1 elements; (1*4) cfg bytes != "
                                "(%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "link_speed_recoveries", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: link_speed_recoveries(8201): Error adding 1 elements to context";
                            break;
                          case 8202:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: fw_updates(8202): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "fw_updates", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: fw_updates(8202): Error adding 1 elements to context";
                            break;
                          case 8203:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: maintenance_backup_to_main(8203): cfg 1 elements; (1*4) cfg byte"
                                "s != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "maintenance_backup_to_main", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: maintenance_backup_to_main(8203): Error adding 1 elements to context";
                            break;
                          case 8204:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: maintenance_main_to_backup(8204): cfg 1 elements; (1*4) cfg byte"
                                "s != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "maintenance_main_to_backup", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: maintenance_main_to_backup(8204): Error adding 1 elements to context";
                            break;
                          case 8205:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_block_erase_failures(8205): cfg 1 elements; (1*4) cfg bytes"
                                " != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_block_erase_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_block_erase_failures(8205): Error adding 1 elements to context";
                            break;
                          case 8206:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_block_program_failures(8206): cfg 1 elements; (1*4) cfg byt"
                                "es != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_block_program_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_block_program_failures(8206): Error adding 1 elements to context";
                            break;
                          case 8207:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_block_read_verify_failures(8207): cfg 1 elements; (1*4) cfg"
                                " bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_block_read_verify_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_block_read_verify_failures(8207): Error adding 1 elements to context";
                            break;
                          case 8208:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_block_read_failures(8208): cfg 1 elements; (1*4) cfg bytes "
                                "!= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_block_read_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_block_read_failures(8208): Error adding 1 elements to context";
                            break;
                          case 8209:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_block_refresh(8209): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_block_refresh", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_block_refresh(8209): Error adding 1 elements to context";
                            break;
                          case 8210:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_block_convert_to_main(8210): cfg 1 elements; (1*4) cfg byte"
                                "s != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_block_convert_to_main", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_block_convert_to_main(8210): Error adding 1 elements to context";
                            break;
                          case 8211:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_block_read_source_changed(8211): cfg 1 elements; (1*4) cfg "
                                "bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_block_read_source_changed", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_block_read_source_changed(8211): Error adding 1 elements to context";
                            break;
                          case 8212:
                            if ((_DWORD)v16 != 16)
                              sub_1000756A0("ASPMSPParseBufferToCxt: open_blocks_hist(8212): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x14)
                              v22 = 4;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "open_blocks_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: open_blocks_hist(8212): Error adding 4 elements to context";
                            break;
                          case 8213:
                            if ((_DWORD)v16 != 24)
                              sub_1000756A0("ASPMSPParseBufferToCxt: random_read_hit_ratio_hist(8213): cfg 6 elements; (6*4) cfg byte"
                                "s != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x1C)
                              v22 = 6;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "random_read_hit_ratio_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: random_read_hit_ratio_hist(8213): Error adding 6 elements to context";
                            break;
                          case 8214:
                            if ((_DWORD)v16 != 20)
                              sub_1000756A0("ASPMSPParseBufferToCxt: active_time_hist(8214): cfg 5 elements; (5*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x18)
                              v22 = 5;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "active_time_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: active_time_hist(8214): Error adding 5 elements to context";
                            break;
                          case 8215:
                            if ((_DWORD)v16 != 8)
                              sub_1000756A0("ASPMSPParseBufferToCxt: rd_retraining_failures(8215): cfg 2 elements; (2*4) cfg bytes !="
                                " (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0xC)
                              v22 = 2;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "rd_retraining_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: rd_retraining_failures(8215): Error adding 2 elements to context";
                            break;
                          case 8216:
                            if ((_DWORD)v16 != 8)
                              sub_1000756A0("ASPMSPParseBufferToCxt: wr_retraining_failures(8216): cfg 2 elements; (2*4) cfg bytes !="
                                " (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0xC)
                              v22 = 2;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "wr_retraining_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: wr_retraining_failures(8216): Error adding 2 elements to context";
                            break;
                          case 8217:
                            if ((_DWORD)v16 != 20)
                              sub_1000756A0("ASPMSPParseBufferToCxt: auto_skip(8217): cfg 5 elements; (5*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x18)
                              v22 = 5;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "auto_skip", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: auto_skip(8217): Error adding 5 elements to context";
                            break;
                          case 8218:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: number_of_dcc_pass_after_retry(8218): cfg 1 elements; (1*4) cfg "
                                "bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "number_of_dcc_pass_after_retry", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: number_of_dcc_pass_after_retry(8218): Error adding 1 elements to context";
                            break;
                          case 8219:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: number_of_dcc_failures(8219): cfg 1 elements; (1*4) cfg bytes !="
                                " (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "number_of_dcc_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: number_of_dcc_failures(8219): Error adding 1 elements to context";
                            break;
                          case 8220:
                            if ((_DWORD)v16 != 28)
                              sub_1000756A0("ASPMSPParseBufferToCxt: open_blocks_hist(8220): cfg 7 elements; (7*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x20)
                              v22 = 7;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "open_blocks_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: open_blocks_hist(8220): Error adding 7 elements to context";
                            break;
                          case 8221:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: max_size_open_blocks_list(8221): cfg 1 elements; (1*4) cfg bytes"
                                " != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "max_size_open_blocks_list", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: max_size_open_blocks_list(8221): Error adding 1 elements to context";
                            break;
                          case 8222:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: gps_max_num_of_failures(8222): cfg 1 elements; (1*4) cfg bytes !"
                                "= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "gps_max_num_of_failures", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: gps_max_num_of_failures(8222): Error adding 1 elements to context";
                            break;
                          case 8223:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: gps_num_of_failures_max_overflow(8223): cfg 1 elements; (1*4) cf"
                                "g bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "gps_num_of_failures_max_overflow", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: gps_num_of_failures_max_overflow(8223): Error adding 1 elements to context";
                            break;
                          case 8224:
                            if ((_DWORD)v16 != 32)
                              sub_1000756A0("ASPMSPParseBufferToCxt: active_time_hist(8224): cfg 8 elements; (8*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x24)
                              v22 = 8;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "active_time_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: active_time_hist(8224): Error adding 8 elements to context";
                            break;
                          case 8225:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: num_auto_program_cache_terminations(8225): cfg 1 elements; (1*4)"
                                " cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "num_auto_program_cache_terminations", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: num_auto_program_cache_terminations(8225): Error adding 1 elements to context";
                            break;
                          case 8226:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: number_of_read_cache_auto_terminations(8226): cfg 1 elements; (1"
                                "*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "number_of_read_cache_auto_terminations", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: number_of_read_cache_auto_terminations(8226): Error adding 1 el"
                                 "ements to context";
                            break;
                          case 8227:
                            if ((_DWORD)v16 != 28)
                              sub_1000756A0("ASPMSPParseBufferToCxt: external_etags_usage_hist(8227): cfg 7 elements; (7*4) cfg bytes"
                                " != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x20)
                              v22 = 7;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "external_etags_usage_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: external_etags_usage_hist(8227): Error adding 7 elements to context";
                            break;
                          case 8228:
                            if ((_DWORD)v16 != 16)
                              sub_1000756A0("ASPMSPParseBufferToCxt: internal_etags_usage_hist(8228): cfg 4 elements; (4*4) cfg bytes"
                                " != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x14)
                              v22 = 4;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "internal_etags_usage_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: internal_etags_usage_hist(8228): Error adding 4 elements to context";
                            break;
                          case 8229:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: max_heap_usage(8229): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "max_heap_usage", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: max_heap_usage(8229): Error adding 1 elements to context";
                            break;
                          case 8230:
                            if ((_DWORD)v16 != 24)
                              sub_1000756A0("ASPMSPParseBufferToCxt: rom_num_hard_resets(8230): cfg 6 elements; (6*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x1C)
                              v22 = 6;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "rom_num_hard_resets", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: rom_num_hard_resets(8230): Error adding 6 elements to context";
                            break;
                          case 8231:
                            if ((_DWORD)v16 != 64)
                              sub_1000756A0("ASPMSPParseBufferToCxt: lower_die_temperature(8231): cfg 16 elements; (16*4) cfg bytes !"
                                "= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x44)
                              v22 = 16;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "lower_die_temperature", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: lower_die_temperature(8231): Error adding 16 elements to context";
                            break;
                          case 8232:
                            if ((_DWORD)v16 != 64)
                              sub_1000756A0("ASPMSPParseBufferToCxt: higher_die_temperature(8232): cfg 16 elements; (16*4) cfg bytes "
                                "!= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x44)
                              v22 = 16;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "higher_die_temperature", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: higher_die_temperature(8232): Error adding 16 elements to context";
                            break;
                          case 8233:
                            if ((_DWORD)v16 != 24)
                              sub_1000756A0("ASPMSPParseBufferToCxt: random_read_hit_ratio_hist(8233): cfg 6 elements; (6*4) cfg byte"
                                "s != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x1C)
                              v22 = 6;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "random_read_hit_ratio_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: random_read_hit_ratio_hist(8233): Error adding 6 elements to context";
                            break;
                          case 8234:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: msp_number_sram_flips(8234): cfg 1 elements; (1*4) cfg bytes != "
                                "(%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "msp_number_sram_flips", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: msp_number_sram_flips(8234): Error adding 1 elements to context";
                            break;
                          case 8235:
                            if ((_DWORD)v16 != 28)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_time_normal_power(8235): cfg 7 elements; (7*4) cfg bytes !="
                                " (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x20)
                              v22 = 7;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_time_normal_power", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_time_normal_power(8235): Error adding 7 elements to context";
                            break;
                          case 8236:
                            if ((_DWORD)v16 != 28)
                              sub_1000756A0("ASPMSPParseBufferToCxt: boot_time_low_power(8236): cfg 7 elements; (7*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x20)
                              v22 = 7;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "boot_time_low_power", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: boot_time_low_power(8236): Error adding 7 elements to context";
                            break;
                          case 8237:
                            if ((_DWORD)v16 != 40)
                              sub_1000756A0("ASPMSPParseBufferToCxt: active_time_bw_pg_hist(8237): cfg 10 elements; (10*4) cfg bytes "
                                "!= (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x2C)
                              v22 = 10;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "active_time_bw_pg_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: active_time_bw_pg_hist(8237): Error adding 10 elements to context";
                            break;
                          case 8238:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: active_time_bw_pg_min(8238): cfg 1 elements; (1*4) cfg bytes != "
                                "(%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "active_time_bw_pg_min", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: active_time_bw_pg_min(8238): Error adding 1 elements to context";
                            break;
                          case 8239:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: active_time_bw_pg_max(8239): cfg 1 elements; (1*4) cfg bytes != "
                                "(%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "active_time_bw_pg_max", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: active_time_bw_pg_max(8239): Error adding 1 elements to context";
                            break;
                          case 8240:
                            if ((_DWORD)v16 != 20)
                              sub_1000756A0("ASPMSPParseBufferToCxt: mdll_relative_offset(8240): cfg 5 elements; (5*4) cfg bytes != ("
                                "%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x18)
                              v22 = 5;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "mdll_relative_offset", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: mdll_relative_offset(8240): Error adding 5 elements to context";
                            break;
                          case 8241:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: num_pg_regrets(8241): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "num_pg_regrets", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: num_pg_regrets(8241): Error adding 1 elements to context";
                            break;
                          case 8242:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: spi_image_overall_duration_acc(8242): cfg 1 elements; (1*4) cfg "
                                "bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "spi_image_overall_duration_acc", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: spi_image_overall_duration_acc(8242): Error adding 1 elements to context";
                            break;
                          case 8243:
                            if ((_DWORD)v16 != 4)
                              sub_1000756A0("ASPMSPParseBufferToCxt: spi_image_cw_fetch_duration_acc(8243): cfg 1 elements; (1*4) cfg"
                                " bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 8)
                              v22 = 1;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "spi_image_cw_fetch_duration_acc", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: spi_image_cw_fetch_duration_acc(8243): Error adding 1 elements to context";
                            break;
                          case 8244:
                            if ((_DWORD)v16 != 20)
                              sub_1000756A0("ASPMSPParseBufferToCxt: spi_image_cw_fetch_duration_hist(8244): cfg 5 elements; (5*4) cf"
                                "g bytes != (%d) buffer bytes",
                                a2,
                                a3,
                                a4,
                                a5,
                                a6,
                                a7,
                                a8,
                                v16);
                            if (v16 >= 0x18)
                              v22 = 5;
                            else
                              v22 = v16 >> 2;
                            if (sub_100085260(a1, "spi_image_cw_fetch_duration_hist", v11, 4u, v22))
                              goto LABEL_1372;
                            v9 = "ASPMSPParseBufferToCxt: spi_image_cw_fetch_duration_hist(8244): Error adding 5 elements to context";
                            break;
                          default:
                            switch(v17)
                            {
                              case 4279:
                                if ((_DWORD)v16 != 16)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: fs1_4b_fail(4279): cfg 4 elements; (4*4) cfg bytes != (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x14)
                                  v22 = 4;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "fs1_4b_fail_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = v14;
                                break;
                              case 4280:
                                if ((_DWORD)v16 != 16)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: fs1_4b_fast_fail(4280): cfg 4 elements; (4*4) cfg bytes != ("
                                    "%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x14)
                                  v22 = 4;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "fs1_4b_fast_fail_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: fs1_4b_fast_fail(4280): Error adding 4 elements to context";
                                break;
                              case 4281:
                                if ((_DWORD)v16 != 40)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: dyce_decoded_bit_flips(4281): cfg 10 elements; (10*4) cfg by"
                                    "tes != (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x2C)
                                  v22 = 10;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "dyce_decoded_bit_flips_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: dyce_decoded_bit_flips(4281): Error adding 10 elements to context";
                                break;
                              case 4282:
                                if ((_DWORD)v16 != 60)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: slip_bch(4282): cfg 15 elements; (15*4) cfg bytes != (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x40)
                                  v22 = 15;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "slip_bch_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: slip_bch(4282): Error adding 15 elements to context";
                                break;
                              case 4283:
                                if ((_DWORD)v16 != 40)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: read_fail(4283): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x2C)
                                  v22 = 10;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "read_fail_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: read_fail(4283): Error adding 10 elements to context";
                                break;
                              case 4284:
                                if ((_DWORD)v16 != 40)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: tr_read_fail(4284): cfg 10 elements; (10*4) cfg bytes != (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x2C)
                                  v22 = 10;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "tr_read_fail_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: tr_read_fail(4284): Error adding 10 elements to context";
                                break;
                              case 4285:
                                if ((_DWORD)v16 != 40)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: tr_aux_bfs_percent(4285): cfg 10 elements; (10*4) cfg bytes "
                                    "!= (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x2C)
                                  v22 = 10;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "tr_aux_bfs_percent_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: tr_aux_bfs_percent(4285): Error adding 10 elements to context";
                                break;
                              case 4286:
                                if ((_DWORD)v16 != 20)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: tr_reconstruct_pass_step(4286): cfg 5 elements; (5*4) cfg by"
                                    "tes != (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 0x18)
                                  v22 = 5;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "tr_reconstruct_pass_step_", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: tr_reconstruct_pass_step(4286): Error adding 5 elements to context";
                                break;
                              case 4287:
                                if ((_DWORD)v16 != 4)
                                  sub_1000756A0("ASPMSPParseBufferToCxt: tr_reconstruct_num(4287): cfg 1 elements; (1*4) cfg bytes !="
                                    " (%d) buffer bytes",
                                    a2,
                                    a3,
                                    a4,
                                    a5,
                                    a6,
                                    a7,
                                    a8,
                                    v16);
                                if (v16 >= 8)
                                  v22 = 1;
                                else
                                  v22 = v16 >> 2;
                                if (sub_100085260(a1, "tr_reconstruct_num", v11, 4u, v22))
                                  goto LABEL_1372;
                                v9 = "ASPMSPParseBufferToCxt: tr_reconstruct_num(4287): Error adding 1 elements to context";
                                break;
                              default:
                                goto LABEL_1404;
                            }
                            goto LABEL_1981;
                        }
                        goto LABEL_1981;
                      }
                      switch(v17)
                      {
                        case 12326:
                          if ((_DWORD)v16 != 8)
                            sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStageParameter2(12326): cfg 1 elements; (1*8) cfg bytes"
                              " != (%d) buffer bytes",
                              a2,
                              a3,
                              a4,
                              a5,
                              a6,
                              a7,
                              a8,
                              v16);
                          if (v16 >= 0x10)
                            v22 = 1;
                          else
                            v22 = v16 >> 3;
                          if (!sub_100085260(a1, "initialReadStageParameter2", v11, 8u, v22))
                          {
                            v9 = "ASPMSPParseBufferToCxt: initialReadStageParameter2(12326): Error adding 1 elements to context";
                            goto LABEL_1981;
                          }
                          break;
                        case 12325:
                          if ((_DWORD)v16 != 8)
                            sub_1000756A0("ASPMSPParseBufferToCxt: initialReadStageParameter1(12325): cfg 1 elements; (1*8) cfg bytes"
                              " != (%d) buffer bytes",
                              a2,
                              a3,
                              a4,
                              a5,
                              a6,
                              a7,
                              a8,
                              v16);
                          if (v16 >= 0x10)
                            v22 = 1;
                          else
                            v22 = v16 >> 3;
                          if (!sub_100085260(a1, "initialReadStageParameter1", v11, 8u, v22))
                          {
                            v9 = "ASPMSPParseBufferToCxt: initialReadStageParameter1(12325): Error adding 1 elements to context";
                            goto LABEL_1981;
                          }
                          break;
                        case 12324:
                          if ((_DWORD)v16 != 8)
                            sub_1000756A0("ASPMSPParseBufferToCxt: dspExceptionParameter144(12324): cfg 1 elements; (1*8) cfg bytes !"
                              "= (%d) buffer bytes",
                              a2,
                              a3,
                              a4,
                              a5,
                              a6,
                              a7,
                              a8,
                              v16);
                          if (v16 >= 0x10)
                            v22 = 1;
                          else
                            v22 = v16 >> 3;
                          if (!sub_100085260(a1, "dspExceptionParameter144", v11, 8u, v22))
                          {
                            v9 = "ASPMSPParseBufferToCxt: dspExceptionParameter144(12324): Error adding 1 elements to context";
                            goto LABEL_1981;
                          }
                          break;
                        default:
LABEL_1404:
                          switch(v17)
                          {
                            case 8245:
                              if ((_DWORD)v16 != 4)
                                sub_1000756A0("ASPMSPParseBufferToCxt: spi_num_uses(8245): cfg 1 elements; (1*4) cfg bytes != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 8)
                                v22 = 1;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "spi_num_uses", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: spi_num_uses(8245): Error adding 1 elements to context";
                              break;
                            case 8246:
                              if ((_DWORD)v16 != 20)
                                sub_1000756A0("ASPMSPParseBufferToCxt: e2e_error_count_tmode(8246): cfg 5 elements; (5*4) cfg bytes !"
                                  "= (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0x18)
                                v22 = 5;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "e2e_error_count_tmode", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: e2e_error_count_tmode(8246): Error adding 5 elements to context";
                              break;
                            case 8247:
                              if ((_DWORD)v16 != 36)
                                sub_1000756A0("ASPMSPParseBufferToCxt: rd_window_dist(8247): cfg 9 elements; (9*4) cfg bytes != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0x28)
                                v22 = 9;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "rd_window_dist", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: rd_window_dist(8247): Error adding 9 elements to context";
                              break;
                            case 8248:
                              if ((_DWORD)v16 != 36)
                                sub_1000756A0("ASPMSPParseBufferToCxt: extended_rd_window_diff_dist(8248): cfg 9 elements; (9*4) cfg "
                                  "bytes != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0x28)
                                v22 = 9;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "extended_rd_window_diff_dist", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: extended_rd_window_diff_dist(8248): Error adding 9 elements to context";
                              break;
                            case 8249:
                              if ((_DWORD)v16 != 8)
                                sub_1000756A0("ASPMSPParseBufferToCxt: rd_retraining_failures_v2(8249): cfg 2 elements; (2*4) cfg byt"
                                  "es != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0xC)
                                v22 = 2;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "rd_retraining_failures_v2", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: rd_retraining_failures_v2(8249): Error adding 2 elements to context";
                              break;
                            case 8250:
                              if ((_DWORD)v16 != 120)
                                sub_1000756A0("ASPMSPParseBufferToCxt: lower_die_temperature(8250): cfg 30 elements; (30*4) cfg bytes"
                                  " != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0x7C)
                                v22 = 30;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "lower_die_temperature", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: lower_die_temperature(8250): Error adding 30 elements to context";
                              break;
                            case 8251:
                              if ((_DWORD)v16 != 120)
                                sub_1000756A0("ASPMSPParseBufferToCxt: higher_die_temperature(8251): cfg 30 elements; (30*4) cfg byte"
                                  "s != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0x7C)
                                v22 = 30;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "higher_die_temperature", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: higher_die_temperature(8251): Error adding 30 elements to context";
                              break;
                            case 8252:
                              if ((_DWORD)v16 != 36)
                                sub_1000756A0("ASPMSPParseBufferToCxt: rd_window_dist_single_die(8252): cfg 9 elements; (9*4) cfg byt"
                                  "es != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0x28)
                                v22 = 9;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "rd_window_dist_single_die", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: rd_window_dist_single_die(8252): Error adding 9 elements to context";
                              break;
                            case 8253:
                              if ((_DWORD)v16 != 16)
                                sub_1000756A0("ASPMSPParseBufferToCxt: parallel_slip_drops_hist(8253): cfg 4 elements; (4*4) cfg byte"
                                  "s != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0x14)
                                v22 = 4;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "parallel_slip_drops_hist", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: parallel_slip_drops_hist(8253): Error adding 4 elements to context";
                              break;
                            case 8254:
                              if ((_DWORD)v16 != 4)
                                sub_1000756A0("ASPMSPParseBufferToCxt: sys_halt_max_latency(8254): cfg 1 elements; (1*4) cfg bytes !="
                                  " (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 8)
                                v22 = 1;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "sys_halt_max_latency", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: sys_halt_max_latency(8254): Error adding 1 elements to context";
                              break;
                            case 8255:
                              if ((_DWORD)v16 != 4)
                                sub_1000756A0("ASPMSPParseBufferToCxt: sys_halt_max_latency_opcode(8255): cfg 1 elements; (1*4) cfg b"
                                  "ytes != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 8)
                                v22 = 1;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "sys_halt_max_latency_opcode", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: sys_halt_max_latency_opcode(8255): Error adding 1 elements to context";
                              break;
                            case 8256:
                              if ((_DWORD)v16 != 4)
                                sub_1000756A0("ASPMSPParseBufferToCxt: channel_halt_max_latency(8256): cfg 1 elements; (1*4) cfg byte"
                                  "s != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 8)
                                v22 = 1;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "channel_halt_max_latency", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: channel_halt_max_latency(8256): Error adding 1 elements to context";
                              break;
                            case 8257:
                              if ((_DWORD)v16 != 8)
                                sub_1000756A0("ASPMSPParseBufferToCxt: max_heap_usage_v2(8257): cfg 2 elements; (2*4) cfg bytes != (%d) buffer bytes",
                                  a2,
                                  a3,
                                  a4,
                                  a5,
                                  a6,
                                  a7,
                                  a8,
                                  v16);
                              if (v16 >= 0xC)
                                v22 = 2;
                              else
                                v22 = v16 >> 2;
                              if (sub_100085260(a1, "max_heap_usage_v2", v11, 4u, v22))
                                goto LABEL_1372;
                              v9 = "ASPMSPParseBufferToCxt: max_heap_usage_v2(8257): Error adding 2 elements to context";
                              break;
                            default:
                              switch(v17)
                              {
                                case 16384:
                                  if ((_DWORD)v16 != 8)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: fw_version_identifier(16384): cfg 1 elements; (1*8) cfg by"
                                      "tes != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x10)
                                    v22 = 1;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "fw_version_identifier", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: fw_version_identifier(16384): Error adding 1 elements to context";
                                  break;
                                case 16385:
                                  if ((_DWORD)v16 != 40)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: random_read_size_ratio(16385): cfg 5 elements; (5*8) cfg b"
                                      "ytes != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x30)
                                    v22 = 5;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "random_read_size_ratio", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: random_read_size_ratio(16385): Error adding 5 elements to context";
                                  break;
                                case 16386:
                                  if ((_DWORD)v16 != 8)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: number_gracefull_read_terminations(16386): cfg 1 elements;"
                                      " (1*8) cfg bytes != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x10)
                                    v22 = 1;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "number_gracefull_read_terminations", v11, 8u, v22))goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: number_gracefull_read_terminations(16386): Error adding 1"
                                       " elements to context";
                                  break;
                                case 16387:
                                  if ((_DWORD)v16 != 8)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: active_time_bw_pg_acc(16387): cfg 1 elements; (1*8) cfg by"
                                      "tes != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x10)
                                    v22 = 1;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "active_time_bw_pg_acc", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: active_time_bw_pg_acc(16387): Error adding 1 elements to context";
                                  break;
                                case 16388:
                                  if ((_DWORD)v16 != 8)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: num_pg_events(16388): cfg 1 elements; (1*8) cfg bytes != ("
                                      "%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x10)
                                    v22 = 1;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "num_pg_events", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: num_pg_events(16388): Error adding 1 elements to context";
                                  break;
                                case 16389:
                                  if ((_DWORD)v16 != 128)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: algo_queue_depth(16389): cfg 16 elements; (16*8) cfg bytes"
                                      " != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x88)
                                    v22 = 16;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "algo_queue_depth", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: algo_queue_depth(16389): Error adding 16 elements to context";
                                  break;
                                case 16390:
                                  if ((_DWORD)v16 != 128)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: parallel_slip_hist(16390): cfg 16 elements; (16*8) cfg byt"
                                      "es != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x88)
                                    v22 = 16;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "parallel_slip_hist", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: parallel_slip_hist(16390): Error adding 16 elements to context";
                                  break;
                                case 16391:
                                  if ((_DWORD)v16 != 48)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: sys_halt_latency_hist(16391): cfg 6 elements; (6*8) cfg by"
                                      "tes != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x38)
                                    v22 = 6;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "sys_halt_latency_hist", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: sys_halt_latency_hist(16391): Error adding 6 elements to context";
                                  break;
                                case 16392:
                                  if ((_DWORD)v16 != 48)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: channel_halt_latency_hist(16392): cfg 6 elements; (6*8) cf"
                                      "g bytes != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x38)
                                    v22 = 6;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "channel_halt_latency_hist", v11, 8u, v22))
                                    goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: channel_halt_latency_hist(16392): Error adding 6 elements to context";
                                  break;
                                case 16393:
                                  if ((_DWORD)v16 != 8)
                                    sub_1000756A0("ASPMSPParseBufferToCxt: num_idle_die_read_cache_terminate(16393): cfg 1 elements; "
                                      "(1*8) cfg bytes != (%d) buffer bytes",
                                      a2,
                                      a3,
                                      a4,
                                      a5,
                                      a6,
                                      a7,
                                      a8,
                                      v16);
                                  if (v16 >= 0x10)
                                    v22 = 1;
                                  else
                                    v22 = v16 >> 3;
                                  if (sub_100085260(a1, "num_idle_die_read_cache_terminate", v11, 8u, v22))goto LABEL_1372;
                                  v9 = "ASPMSPParseBufferToCxt: num_idle_die_read_cache_terminate(16393): Error adding 1 "
                                       "elements to context";
                                  break;
                                default:
                                  goto LABEL_1373;
                              }
                              goto LABEL_1981;
                          }
                          goto LABEL_1981;
                      }
LABEL_1372:
                      v8 = v8 + v22;
LABEL_1373:
                      v13 = &jpt_10008963C;
                      break;
                  }
                  break;
              }
              break;
          }
          break;
      }
      goto LABEL_461;
  }
}

uint64_t sub_10008BCF4(uint64_t result, const char *a2, const char *a3, uint64_t a4)
{
  _QWORD *v7;
  char *v8;
  _BYTE *v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  char **v13;

  if (result)
  {
    v7 = (_QWORD *)result;
    v8 = (char *)malloc_type_calloc(1uLL, 0x78uLL, 0x102004060B2607BuLL);
    v9 = malloc_type_calloc(1uLL, 0x78uLL, 0x102004060B2607BuLL);
    v10 = v9;
    if (v8 && v9)
    {
      v11 = v7[1];
      if (v11 && (v12 = v7[3]) != 0)
      {
        *(_QWORD *)(v11 + 112) = v9;
        v13 = (char **)(v12 + 112);
      }
      else
      {
        *v7 = v9;
        v13 = (char **)(v7 + 2);
      }
      *v13 = v8;
      v7[1] = v9;
      v7[3] = v8;
      *((_QWORD *)v8 + 14) = 0;
      *((_QWORD *)v9 + 14) = 0;
      snprintf(v9, 0x63uLL, "%s%s", a2, a3);
      v10[99] = 0;
      snprintf(v8, 0x63uLL, "%llu", a4);
      v8[99] = 0;
      *((_QWORD *)v8 + 13) = a4;
      return 1;
    }
    else
    {
      if (v8)
        free(v8);
      if (v10)
        free(v10);
      return 0;
    }
  }
  return result;
}

double sub_10008BE18(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  double result;

  if (a1)
  {
    v2 = *(_QWORD **)a1;
    if (v2)
    {
      do
      {
        v3 = (_QWORD *)v2[14];
        free(v2);
        v2 = v3;
      }
      while (v3);
    }
    v4 = *(_QWORD **)(a1 + 16);
    if (v4)
    {
      do
      {
        v5 = (_QWORD *)v4[14];
        free(v4);
        v4 = v5;
      }
      while (v5);
    }
    result = 0.0;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  return result;
}

uint64_t sub_10008BE70(_QWORD *a1, const char *a2, const char *a3, uint64_t a4)
{
  char *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  char **v13;
  uint64_t result;

  v8 = (char *)malloc_type_malloc(0x78uLL, 0x102004060B2607BuLL);
  v9 = malloc_type_malloc(0x78uLL, 0x102004060B2607BuLL);
  v10 = v9;
  v11 = a1[1];
  if (v11 && (v12 = a1[3]) != 0)
  {
    *(_QWORD *)(v11 + 112) = v9;
    v13 = (char **)(v12 + 112);
  }
  else
  {
    *a1 = v9;
    v13 = (char **)(a1 + 2);
  }
  *v13 = v8;
  a1[1] = v9;
  a1[3] = v8;
  *((_QWORD *)v8 + 14) = 0;
  v9[14] = 0;
  snprintf((char *)v9, 0x63uLL, "%s%s", a2, a3);
  *((_BYTE *)v10 + 99) = 0;
  result = snprintf(v8, 0x63uLL, "%llu", a4);
  v8[99] = 0;
  *((_QWORD *)v8 + 13) = a4;
  return result;
}

void *sub_10008BF5C()
{
  return &unk_1001A6E90;
}

void *sub_10008BF68()
{
  return &unk_1001A6E98;
}

void *sub_10008BF74()
{
  return &unk_1001A6EA0;
}

void *sub_10008BF80()
{
  return &unk_1001A6EB0;
}

void *sub_10008BF8C()
{
  return &unk_1001A6EB8;
}

void *sub_10008BF98()
{
  return &unk_1001A6EC0;
}

void *sub_10008BFA4()
{
  return &unk_1001A6EC8;
}

void *sub_10008BFB0()
{
  return &unk_1001A6ED0;
}

void *sub_10008BFBC()
{
  return &unk_1001A6EA8;
}

void *sub_10008BFC8()
{
  return &unk_1001A6ED8;
}

char *sub_10008BFD4(char ***a1)
{
  int v2;
  int *v3;
  char *result;
  char **v5;
  const __CFDictionary *v6;
  io_service_t MatchingService;
  io_object_t v8;
  const char *v9;
  io_connect_t connect;

  connect = 0;
  *a1 = 0;
  v2 = pthread_mutex_trylock(&stru_1001A6EE0);
  if (v2)
  {
    if (v2 != 16
      || (syslog(3, "Error: NANDInfo: NANDExporter: serializeAccess already locked. waiting for lock !\n"),
          pthread_mutex_lock(&stru_1001A6EE0)))
    {
      v3 = __error();
      syslog(3, "Error: NANDInfo: NANDExporter: pthread_mutex_trylock() (%d) failed \n", *v3);
      return 0;
    }
  }
  syslog(5, "NANDInfo: NANDExporter object locked ! \n");
  v5 = &off_1001A6F20;
  result = off_1001A6F20;
  if (!off_1001A6F20)
  {
LABEL_11:
    v8 = 0;
    goto LABEL_12;
  }
  while (1)
  {
    v6 = IOServiceMatching(result);
    if (!v6)
      goto LABEL_10;
    MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v6);
    if (!MatchingService)
      goto LABEL_10;
    v8 = MatchingService;
    if (!IOServiceOpen(MatchingService, mach_task_self_, 0, &connect))
      break;
    IOServiceClose(connect);
    connect = 0;
    IOObjectRelease(v8);
LABEL_10:
    v9 = v5[21];
    v5 += 21;
    result = (char *)v9;
    if (!v9)
      goto LABEL_11;
  }
  syslog(5, "NANDInfo: findNandExporter_tunnel: Controller found: %s\n", *v5);
  result = (char *)1;
LABEL_12:
  *((_DWORD *)v5 + 4) = connect;
  *((_DWORD *)v5 + 5) = v8;
  *a1 = v5;
  return result;
}

uint64_t sub_10008C11C(uint64_t a1)
{
  io_connect_t v2;
  io_object_t v3;

  v2 = *(_DWORD *)(a1 + 16);
  if (v2)
  {
    IOServiceClose(v2);
    *(_DWORD *)(a1 + 16) = 0;
  }
  v3 = *(_DWORD *)(a1 + 20);
  if (v3)
  {
    IOObjectRelease(v3);
    *(_DWORD *)(a1 + 20) = 0;
  }
  syslog(5, "NANDInfo: NANDExporter object unlocked ! \n");
  return pthread_mutex_unlock(&stru_1001A6EE0);
}

CFDataRef gather_nand_info()
{
  UInt8 *v0;
  CFDataRef v1;
  CFDataRef result;
  CFIndex length;

  length = 0;
  v0 = (UInt8 *)sub_100075680(13, &length);
  if (v0 && length)
  {
    v1 = CFDataCreate(0, v0, length);
    if (!v1)
      fwrite("Could not create CFData", 0x17uLL, 1uLL, __stderrp);
  }
  else
  {
    v1 = 0;
    result = 0;
    if (!v0)
      return result;
  }
  free(v0);
  return v1;
}

void *acm_mem_alloc_data(size_t size)
{
  void *result;

  result = malloc_type_calloc(1uLL, size, 0xCB62F0E9uLL);
  if (result)
    qword_1001A8158 += size;
  return result;
}

void acm_mem_free_data(void *a1, rsize_t __n)
{
  uint64_t v4;

  if (a1)
  {
    memset_s(a1, __n, 0, __n);
    free(a1);
    v4 = qword_1001A8158 - __n;
    if (qword_1001A8158 < __n)
      v4 = 0;
    qword_1001A8158 = v4;
  }
}

const char *acm_mem_alloc_info(const char *result, const void *a2, uint64_t a3, const char *a4, int a5, const char *a6)
{
  const char *v6;
  const char *v7;
  const char *v8;

  if (a2)
    qword_1001A8150 += a3;
  if (gACMLoggingLevel <= 0x1Eu)
  {
    v6 = "NULL";
    if (result)
      v7 = result;
    else
      v7 = "NULL";
    if (a4)
      v8 = a4;
    else
      v8 = "NULL";
    if (a6)
      v6 = a6;
    return (const char *)printf("%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n", "ACM", "acm_mem_alloc_info", v7, a2, a3, qword_1001A8150, 0, qword_1001A8158, qword_1001A8160, v8, a5, v6);
  }
  return result;
}

const char *acm_mem_free_info(const char *result, const void *a2, unint64_t a3, const char *a4, int a5, const char *a6)
{
  uint64_t v6;
  const char *v7;
  const char *v8;
  const char *v9;

  if (a2)
  {
    v6 = qword_1001A8150 - a3;
    if (qword_1001A8150 < a3)
      v6 = 0;
    qword_1001A8150 = v6;
  }
  if (gACMLoggingLevel <= 0x1Eu)
  {
    v7 = "NULL";
    if (result)
      v8 = result;
    else
      v8 = "NULL";
    if (a4)
      v9 = a4;
    else
      v9 = "NULL";
    if (a6)
      v7 = a6;
    return (const char *)printf("%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n", "ACM", "acm_mem_free_info", v8, a2, a3, qword_1001A8150, 0, qword_1001A8158, qword_1001A8160, v9, a5, v7);
  }
  return result;
}

uint64_t LibCall_ACMKernelControl_Block(uint64_t (*a1)(uint64_t, uint64_t, _QWORD, char *, size_t, uint64_t, uint64_t), uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t v12;
  _BYTE *v13;
  unsigned int v14;
  uint64_t v16;
  _BYTE v17[8192];

  if (gACMLoggingLevel <= 0xAu)
    printf("%s: %s: called.\n", "ACM", "LibCall_ACMKernelControl_Block");
  v16 = 0x2000;
  v12 = LibCall_ACMKernelControl(a1, a2, a3, a4, a5, (uint64_t)v17, (uint64_t)&v16);
  if (a6)
  {
    if (v16)
      v13 = v17;
    else
      v13 = 0;
    (*(void (**)(uint64_t, _BYTE *))(a6 + 16))(a6, v13);
  }
  if ((_DWORD)v12)
    v14 = 70;
  else
    v14 = 10;
  if (v14 >= gACMLoggingLevel)
    printf("%s: %s: returning, err = %ld.\n", "ACM", "LibCall_ACMKernelControl_Block", (int)v12);
  return v12;
}

uint64_t sub_10008C538(uint64_t *a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v18;
  const char *v19;
  __int16 v20;
  const char *v21;
  __int16 v22;
  uint64_t v23;

  if (byte_1001A7269 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v18 = 136315394;
    v19 = "ACMLib";
    v20 = 2080;
    v21 = "ioKitTransport";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v18, 0x16u);
  }
  if (a1)
  {
    v14 = sub_10008C714();
    v15 = 70;
    if ((_DWORD)v14)
    {
      v16 = v14;
    }
    else
    {
      v16 = sub_10008C8F4(*a1, a2, a3, a4, a5, a6, a7);
      if ((_DWORD)v16)
        v15 = 70;
      else
        v15 = 10;
    }
  }
  else
  {
    v15 = 70;
    v16 = 4294967293;
  }
  if (v15 >= byte_1001A7269 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v18 = 136315650;
    v19 = "ACMLib";
    v20 = 2080;
    v21 = "ioKitTransport";
    v22 = 2048;
    v23 = (int)v16;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", (uint8_t *)&v18, 0x20u);
  }
  return v16;
}

uint64_t sub_10008C714()
{
  uint64_t v0;
  const __CFDictionary *v1;
  io_service_t MatchingService;
  io_object_t v3;
  unsigned int v4;
  int v6;
  const char *v7;
  __int16 v8;
  const char *v9;
  __int16 v10;
  uint64_t v11;

  if (byte_1001A7269 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v6 = 136315394;
    v7 = "ACMLib";
    v8 = 2080;
    v9 = "init";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v6, 0x16u);
  }
  if ((byte_1001A816C & 1) != 0)
  {
    v0 = 0;
  }
  else
  {
    v1 = IOServiceMatching("AppleCredentialManager");
    MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v1);
    if (!MatchingService)
    {
      v4 = 70;
      v0 = 4294967291;
      goto LABEL_10;
    }
    v3 = MatchingService;
    v0 = IOServiceOpen(MatchingService, mach_task_self_, 0, (io_connect_t *)&dword_1001A8168);
    if ((_DWORD)v0)
    {
      v4 = 70;
      goto LABEL_10;
    }
    IOObjectRelease(v3);
    byte_1001A816C = 1;
  }
  v4 = 10;
LABEL_10:
  if (v4 >= byte_1001A7269 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    v6 = 136315650;
    v7 = "ACMLib";
    v8 = 2080;
    v9 = "init";
    v10 = 2048;
    v11 = (int)v0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", (uint8_t *)&v6, 0x20u);
  }
  return v0;
}

uint64_t sub_10008C8F4(uint64_t a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  _BYTE *v14;
  void *v15;
  size_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  unsigned int v20;
  size_t v22;
  size_t inputStructCnt;
  uint8_t buf[4];
  const char *v25;
  __int16 v26;
  const char *v27;
  __int16 v28;
  _BYTE v29[10];
  __int16 v30;
  int v31;
  __int16 v32;
  int v33;

  if (byte_1001A7269 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v25 = "ACMLib";
    v26 = 2080;
    v27 = "performCommand";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  inputStructCnt = 0;
  v14 = LibCall_BuildCommand(a2, 0, a3, a4, a5, &inputStructCnt);
  if (v14)
  {
    v15 = v14;
    if (!a6 && a7)
    {
      v18 = 4294967293;
    }
    else
    {
      if (a7)
        v16 = *a7;
      else
        v16 = 0;
      v22 = v16;
      v17 = IOConnectCallStructMethod(dword_1001A8168, 0, v14, inputStructCnt, a6, &v22);
      v18 = v17;
      if (a1)
        LODWORD(a1) = *(_DWORD *)(a1 + 16);
      if ((_DWORD)v17)
      {
        if (byte_1001A7269 <= 0x46u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136316418;
          v25 = "ACMLib";
          v26 = 2080;
          v27 = "performCommand";
          v28 = 1024;
          *(_DWORD *)v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          v30 = 1024;
          v31 = v18;
          v32 = 1024;
          v33 = v18;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: cmd(%u) on CS[%u] -> err 0x%x (%d).\n", buf, 0x2Eu);
        }
      }
      else
      {
        if (byte_1001A7269 <= 0x28u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)buf = 136315906;
          v25 = "ACMLib";
          v26 = 2080;
          v27 = "performCommand";
          v28 = 1024;
          *(_DWORD *)v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: cmd(%u) on CS[%u] -> ok.\n", buf, 0x22u);
        }
        v18 = 0;
        if (a7)
          *a7 = v22;
      }
    }
    v19 = inputStructCnt;
    acm_mem_free_info("<data>", v15, inputStructCnt, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c", 134, "performCommand");
    acm_mem_free_data(v15, v19);
    if ((_DWORD)v18)
      v20 = 70;
    else
      v20 = 10;
  }
  else
  {
    v20 = 70;
    v18 = 4294967291;
  }
  if (v20 >= byte_1001A7269 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315650;
    v25 = "ACMLib";
    v26 = 2080;
    v27 = "performCommand";
    v28 = 2048;
    *(_QWORD *)v29 = (int)v18;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld.\n", buf, 0x20u);
  }
  return v18;
}

uint64_t ACMKernelControl(int a1, const void *a2, size_t a3, uint64_t a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v11;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  const char *v15;
  __int16 v16;
  uint64_t v17;
  __int16 v18;
  int v19;

  if (byte_1001A7269 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315394;
    v13 = "ACMLib";
    v14 = 2080;
    v15 = "ACMKernelControl";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  v11 = 0;
  v8 = LibCall_ACMKernelControl_Block((uint64_t (*)(uint64_t, uint64_t, _QWORD, char *, size_t, uint64_t, uint64_t))sub_10008C538, (uint64_t)&v11, a1, a2, a3, a4);
  if ((_DWORD)v8)
    v9 = 70;
  else
    v9 = 10;
  if (v9 >= byte_1001A7269 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 136315906;
    v13 = "ACMLib";
    v14 = 2080;
    v15 = "ACMKernelControl";
    v16 = 2048;
    v17 = (int)v8;
    v18 = 1024;
    v19 = a1;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, err = %ld, code=%u.\n", buf, 0x26u);
  }
  return v8;
}

_BYTE *LibCall_BuildCommand(char a1, char a2, char a3, const void *a4, size_t a5, _QWORD *a6)
{
  _BYTE *v12;
  BOOL v13;

  if (gACMLoggingLevel <= 0xAu)
    printf("%s: %s: called.\n", "ACM", "LibCall_BuildCommand");
  v12 = 0;
  if (a5)
    v13 = a4 == 0;
  else
    v13 = 0;
  if (!v13 && a6)
  {
    if (a5 >= 0xFFFFFFFFFFFFFFF8)
    {
      v12 = 0;
    }
    else
    {
      v12 = acm_mem_alloc_data(a5 + 8);
      acm_mem_alloc_info("<data>", v12, a5 + 8, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 22, "LibCall_BuildCommand");
      if (v12)
      {
        *a6 = a5 + 8;
        *(_DWORD *)v12 = 1396920900;
        v12[4] = a1;
        v12[5] = a2;
        v12[6] = a3;
        if (a5)
          memcpy(v12 + 8, a4, a5);
      }
    }
  }
  if (gACMLoggingLevel <= 0xAu)
    printf("%s: %s: returning.\n", "ACM", "LibCall_BuildCommand");
  return v12;
}

uint64_t LibCall_ACMKernelControl(uint64_t (*a1)(uint64_t, uint64_t, _QWORD, char *, size_t, uint64_t, uint64_t), uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t (*v13)(uint64_t, uint64_t, _QWORD, char *, size_t, uint64_t, uint64_t);
  BOOL v14;
  _DWORD *v15;
  _DWORD *v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v20;

  v13 = a1;
  if (gACMLoggingLevel <= 0xAu)
    a1 = (uint64_t (*)(uint64_t, uint64_t, _QWORD, char *, size_t, uint64_t, uint64_t))printf("%s: %s: called.\n", "ACM", "LibCall_ACMKernelControl");
  if (!v13)
    goto LABEL_16;
  v14 = a5 != 0;
  if (a4)
    v14 = a5 - 4097 < 0xFFFFFFFFFFFFF000;
  if (v14)
  {
LABEL_16:
    v18 = 70;
    v17 = 4294967293;
  }
  else
  {
    v20 = (uint64_t)&v20;
    __chkstk_darwin(a1);
    v15 = (_DWORD *)((char *)&v20 - ((a5 + 19) & 0xFFFFFFFFFFFFFFF0));
    *v15 = a3;
    v16 = v15 + 1;
    if (a5)
    {
      memcpy(v15 + 1, a4, a5);
      v16 = (_DWORD *)((char *)v16 + a5);
    }
    if (v16 != (_DWORD *)((char *)v15 + a5 + 4))
      sub_10008D13C();
    v17 = v13(a2, 26, 0, (char *)&v20 - ((a5 + 19) & 0xFFFFFFFFFFFFFFF0), a5 + 4, a6, a7);
    if ((_DWORD)v17)
      v18 = 70;
    else
      v18 = 10;
  }
  if (v18 >= gACMLoggingLevel)
    printf("%s: %s: returning, err = %ld.\n", "ACM", "LibCall_ACMKernelControl", (int)v17);
  return v17;
}

void sub_10008D13C()
{
  __assert_rtn("LibCall_ACMKernelControl", "LibCall.c", 373, "commandCursor == commandBuffer + sizeof(commandBuffer)");
}

void image3Discard(uint64_t *a1)
{
  uint64_t v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      if (*(_QWORD *)v2)
      {
        if ((*(_BYTE *)(v2 + 10) & 4) != 0)
        {
          image3Free(*(void **)v2);
          v2 = *a1;
        }
      }
      image3Free((void *)v2);
      *a1 = 0;
    }
  }
}

uint64_t image3InstantiateNew(_QWORD *a1, size_t a2, unsigned int a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = image3Malloc(0x28uLL);
  if (!v6)
    return 12;
  v7 = v6;
  if (a2 <= 0x14)
    a2 = 20;
  v8 = image3Malloc(a2);
  *v7 = v8;
  if (!v8)
  {
    image3Free(v7);
    return 12;
  }
  *v8 = 0;
  v8[1] = 0;
  *((_DWORD *)v8 + 4) = 0;
  v9 = (_DWORD *)*v7;
  *v9 = 1231906611;
  v9[4] = a3;
  v7[2] = a2;
  v7[3] = 0xFFFFFFFF00000000;
  *((_DWORD *)v7 + 2) = 0x40000;
  v7[4] = 0;
  if (a3 == 1667592820 || (v10 = image3SetTagUnsignedNumber((char **)v7, 1415139397, a3), !(_DWORD)v10))
  {
    v11 = 0;
    *a1 = v7;
  }
  else
  {
    v11 = v10;
    image3Free((void *)*v7);
    image3Free(v7);
  }
  return v11;
}

uint64_t image3SetTagUnsignedNumber(char **a1, int a2, unint64_t a3)
{
  uint64_t *v3;
  size_t v4;
  unint64_t v6;
  int v7;

  v7 = 0;
  v6 = 0;
  if (HIDWORD(a3))
  {
    v6 = a3;
    v3 = (uint64_t *)&v6;
    v4 = 8;
  }
  else
  {
    v7 = a3;
    v3 = (uint64_t *)&v7;
    v4 = 4;
  }
  return image3SetTagStructure(a1, a2, v3, v4, 0);
}

uint64_t image3Finalize(uint64_t a1, char **a2, _QWORD *a3, int a4, uint64_t a5)
{
  uint64_t result;
  char *v10;
  unsigned int v11;
  const void *v12;
  CC_LONG v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[2];
  int v17;
  unint64_t v18;
  int8x16_t v19;
  int v20;

  v18 = 0;
  v19 = 0uLL;
  v20 = 0;
  v16[0] = 0;
  v16[1] = 0;
  v17 = 0;
  if (!a4)
    goto LABEL_8;
  result = image3AdvanceCursorWithZeroPad((char **)a1, (56 - *(_DWORD *)(a1 + 24)) & 0x3F);
  if (!(_DWORD)result)
  {
    v10 = *(char **)a1;
    v11 = *(_DWORD *)(a1 + 24);
    *((_DWORD *)v10 + 3) = v11 + a5;
    v12 = v10 + 12;
    v13 = v11 + 8;
    if (a5)
    {
      v18 = __PAIR64__(v11, a5);
      image3SHA1Partial(v12, v13, &v19);
    }
    else
    {
      image3SHA1Generate(v12, v13, (unsigned __int8 *)v16);
    }
    result = image3PKISignHash();
    if (!(_DWORD)result)
    {
      *(_DWORD *)(a1 + 8) |= 0x20000u;
LABEL_8:
      result = 0;
      v14 = *(char **)a1;
      *((_DWORD *)v14 + 2) = *(_DWORD *)(a1 + 24);
      v15 = (*(_DWORD *)(a1 + 24) + 20);
      *((_DWORD *)v14 + 1) = v15;
      *a2 = v14;
      *a3 = v15;
    }
  }
  return result;
}

uint64_t image3AdvanceCursorWithZeroPad(char **a1, int a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  unint64_t v7;
  uint64_t result;

  if ((*((_BYTE *)a1 + 10) & 2) != 0)
    return 30;
  v4 = *((int *)a1 + 6);
  v3 = *((int *)a1 + 7);
  LODWORD(v5) = v4 + a2;
  *((_DWORD *)a1 + 6) = v4 + a2;
  v6 = *a1;
  if ((_DWORD)v3 != -1)
  {
    *(_DWORD *)&v6[v3 + 24] = v5 - v3;
    LODWORD(v5) = *((_DWORD *)a1 + 6);
  }
  v5 = (int)v5;
  v7 = (int)v5 + 20;
  if (v7 <= (unint64_t)a1[2])
    goto LABEL_7;
  v6 = (char *)realloc(v6, (int)v5 + 20);
  if (v6)
  {
    *a1 = v6;
    a1[2] = (char *)v7;
    v5 = *((int *)a1 + 6);
LABEL_7:
    bzero(&v6[v4 + 20], v5 - v4);
    result = 0;
    *((_DWORD *)*a1 + 2) = *((_DWORD *)a1 + 6);
    return result;
  }
  return 12;
}

uint64_t image3SetTagStructure(char **a1, int a2, void *__src, size_t __n, int a5)
{
  uint64_t v9;
  int v10;
  char *v11;
  uint64_t result;
  size_t v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  int v17;
  int v18;
  int v19;

  if ((*((_BYTE *)a1 + 10) & 2) != 0)
    return 30;
  if (a5)
  {
    v9 = *((int *)a1 + 7);
    v10 = (a5 + *((_DWORD *)a1 + 6) / a5 * a5 - *((_DWORD *)a1 + 6)) % a5 + *((_DWORD *)a1 + 6);
    *((_DWORD *)a1 + 6) = v10;
    v11 = *a1;
    if ((_DWORD)v9 != -1)
      *(_DWORD *)&v11[v9 + 24] = v10 - v9;
  }
  else
  {
    v11 = *a1;
  }
  if ((__n & 0xF) != 0)
    v13 = 16 - (__n & 0xF);
  else
    v13 = 0;
  v14 = *((int *)a1 + 6);
  v15 = __n + v13 + v14 + 32;
  if (v15 > (unint64_t)a1[2])
  {
    v11 = (char *)realloc(v11, __n + v13 + v14 + 32);
    if (!v11)
      return 12;
    *a1 = v11;
    a1[2] = (char *)v15;
    v14 = *((int *)a1 + 6);
  }
  v16 = &v11[v14];
  if ((((_DWORD)v13 + (_DWORD)__n) & 3) != 0)
    v17 = ((v13 + __n) & 0xFFFFFFFC) + 16;
  else
    v17 = v13 + __n + 12;
  *((_DWORD *)v16 + 5) = a2;
  *((_DWORD *)v16 + 6) = v17;
  *((_DWORD *)v16 + 7) = __n;
  memcpy(v16 + 32, __src, __n);
  bzero(&v16[__n + 32], v13);
  result = 0;
  v18 = *((_DWORD *)a1 + 6);
  *((_DWORD *)a1 + 7) = v18;
  v19 = *((_DWORD *)v16 + 6) + v18;
  *((_DWORD *)a1 + 6) = v19;
  *((_DWORD *)*a1 + 2) = v19;
  return result;
}

uint64_t image3InstantiateFromBuffer(_QWORD *a1, _DWORD *a2, unint64_t a3, char a4)
{
  uint64_t result;
  unint64_t v6;
  _QWORD *v10;
  _QWORD *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  size_t v16;
  void *v17;

  if (a3 < 0x14)
    return 22;
  if (*a2 != 1231906611)
    return 22;
  v6 = a2[2];
  if (a3 - 20 < v6 || a2[3] > v6 || v6 + 20 > a2[1])
    return 22;
  v10 = image3Malloc(0x28uLL);
  if (!v10)
    return 12;
  v11 = v10;
  *((_DWORD *)v10 + 2) = 1;
  v10[4] = 0;
  if (a2[3])
  {
    *((_DWORD *)v10 + 2) = 131073;
    if ((a4 & 1) == 0)
    {
      *v10 = a2;
      v10[2] = a3;
LABEL_21:
      result = 0;
      *a1 = v11;
      return result;
    }
    goto LABEL_19;
  }
  *((_DWORD *)v10 + 6) = a2[2];
  *((_DWORD *)v10 + 7) = -1;
  v12 = a2[2];
  if (!v12)
  {
LABEL_19:
    v16 = a2[2] + 20;
    v11[2] = v16;
    v17 = image3Malloc(v16);
    *v11 = v17;
    if (v17)
    {
      memcpy(v17, a2, v11[2]);
      *((_DWORD *)v11 + 2) |= 0x40000u;
      goto LABEL_21;
    }
    image3Free(v11);
    return 12;
  }
  v13 = 0;
  while (1)
  {
    v14 = v13;
    v15 = *(_DWORD *)((char *)a2 + v13 + 24);
    v13 += v15;
    if (v13 > v12 || v15 <= 0xB)
      break;
    if (v13 == v12)
    {
      *((_DWORD *)v10 + 7) = v14;
      goto LABEL_19;
    }
  }
  image3Free(v10);
  return 22;
}

uint64_t image3GetTagStruct(uint64_t a1, int a2, _QWORD *a3, _QWORD *a4, int a5)
{
  uint64_t v5;
  _DWORD *v6;
  unint64_t v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t result;

  v5 = *(unsigned int *)(*(_QWORD *)a1 + 8);
  if (!(_DWORD)v5)
    return 2;
  v6 = (_DWORD *)(*(_QWORD *)a1 + 20);
  v7 = (unint64_t)v6 + v5;
  while (1)
  {
    v8 = v6 + 3;
    if ((unint64_t)(v6 + 3) > v7)
      return 22;
    v9 = v6[2];
    if ((unint64_t)v8 + v9 > v7)
      return 22;
    if (a2 == -1 || *v6 == a2)
      break;
LABEL_9:
    v10 = v6[1];
    if (v9 + 12 > v10)
      return 22;
    v6 = (_DWORD *)((char *)v6 + v10);
    if ((unint64_t)v6 >= v7)
      return 2;
  }
  if (a5)
  {
    --a5;
    goto LABEL_9;
  }
  if (a4)
  {
    if (*a4 && *a4 != v9)
      return 22;
    *a4 = v9;
  }
  result = 0;
  *a3 = v8;
  return result;
}

uint64_t image3GetTagUnsignedNumber(uint64_t a1, int a2, _QWORD *a3, int a4)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;

  v7 = 0;
  v8 = 0;
  result = image3GetTagStruct(a1, a2, &v8, &v7, a4);
  if (!(_DWORD)result)
  {
    if (v7 == 8)
    {
      v6 = *(_QWORD *)v8;
      goto LABEL_6;
    }
    if (v7 == 4)
    {
      v6 = *v8;
LABEL_6:
      result = 0;
      *a3 = v6;
      return result;
    }
    return 22;
  }
  return result;
}

void sub_10008D9D4(uint64_t a1)
{
  uint64_t step_desc;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  char v11;
  char v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  int should_retry;
  char v33;
  NSObject *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  id v43;
  unsigned int v44;

  step_desc = checkpoint_closure_context_get_step_desc((uint64_t)objc_msgSend(*(id *)(a1 + 32), "checkpoint_closure_context"));
  ramrod_log_msg("[AsyncCP][Start] Checkpoint %s start running.\n", v3, v4, v5, v6, v7, v8, v9, *(_QWORD *)(step_desc + 8));
  v10 = objc_msgSend(*(id *)(a1 + 32), "workQueue");
  dispatch_queue_set_specific(v10, kCheckpointAsyncStepContextKey, objc_msgSend(*(id *)(a1 + 32), "checkpoint_closure_context"), 0);
  v11 = 0;
  v12 = 1;
  do
  {
    while (1)
    {
      v44 = 0;
      v43 = 0;
      if ((v11 & 1) != 0)
      {
        v13 = (uint64_t *)objc_msgSend(*(id *)(a1 + 32), "checkpoint_closure_context");
        if (checkpoint_closure_context_handle_simulator_actions(v13, 1, (int *)&v44, (const void **)&v43, v14, v15, v16, v17))goto LABEL_4;
      }
      else if ((v12 & 1) != 0)
      {
LABEL_4:
        (*(void (**)(void))(*(_QWORD *)(a1 + 40) + 16))();
        v44 = objc_msgSend(*(id *)(a1 + 32), "result");
        v43 = objc_msgSend(*(id *)(a1 + 32), "error");
        v12 = 1;
        goto LABEL_7;
      }
      v12 = 0;
LABEL_7:
      v18 = (uint64_t *)objc_msgSend(*(id *)(a1 + 32), "checkpoint_closure_context");
      if (checkpoint_closure_context_handle_simulator_actions(v18, 0, (int *)&v44, (const void **)&v43, v19, v20, v21, v22))
      {
        v23 = (uint64_t *)objc_msgSend(*(id *)(a1 + 32), "checkpoint_closure_context");
        v31 = checkpoint_closure_context_handle_simulator_match_name(v23, v24, v25, v26, v27, v28, v29, v30) != 0;
      }
      else
      {
        v31 = 0;
      }
      objc_msgSend(*(id *)(a1 + 32), "setResult:", v44);
      objc_msgSend(*(id *)(a1 + 32), "setError:", v43);
      if (!v44 || v31)
        break;
      should_retry = checkpoint_closure_context_should_retry((uint64_t)objc_msgSend(*(id *)(a1 + 32), "checkpoint_closure_context"));
      v11 = 1;
      if (!should_retry)
        goto LABEL_18;
    }
    if (v44)
      v33 = 1;
    else
      v33 = v31;
    v11 = 1;
  }
  while ((v33 & 1) != 0);
LABEL_18:
  v34 = objc_msgSend(*(id *)(a1 + 32), "workQueue");
  dispatch_queue_set_specific(v34, kCheckpointAsyncStepContextKey, 0, 0);
  v35 = *(_QWORD *)(step_desc + 8);
  objc_msgSend(*(id *)(a1 + 32), "result");
  ramrod_log_msg("[AsyncCP][End] Checkpoint %s finished with result: %d.\n", v36, v37, v38, v39, v40, v41, v42, v35);
}

void sub_10008DB7C(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 3);
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 7);
}

void sub_10008DBB8(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 7);
  _Block_object_dispose(*(const void **)(a1 + 32), 3);
}

uint64_t wait_for_io_service_matching_dict(CFTypeRef cf, unsigned int a2)
{
  unsigned int v4;
  uint64_t MatchingService;
  unsigned int v6;
  const __CFString *v7;
  char CStringPtr;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v4 = 0;
  do
  {
    CFRetain(cf);
    MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, (CFDictionaryRef)cf);
    if ((_DWORD)MatchingService)
      break;
    v6 = a2 - v4 >= 3 ? 3 : a2 - v4;
    v7 = CFCopyDescription(cf);
    CStringPtr = CFStringGetCStringPtr(v7, 0);
    ramrod_log_msg("waiting for matching IOKit service: %s\n", v9, v10, v11, v12, v13, v14, v15, CStringPtr);
    sleep(v6);
    v4 += v6;
    CFRelease(v7);
  }
  while (v4 < a2);
  CFRelease(cf);
  return MatchingService;
}

uint64_t wait_for_io_service_matching_resource_with_timeout(const char *a1, unsigned int a2)
{
  CFMutableDictionaryRef v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  __CFDictionary *v12;
  CFStringRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFStringRef v21;
  char v23;

  v4 = IOServiceMatching("IOResources");
  if (v4)
  {
    v12 = v4;
    v13 = CFStringCreateWithCString(kCFAllocatorDefault, a1, 0x8000100u);
    if (v13)
    {
      v21 = v13;
      CFDictionarySetValue(v12, CFSTR("IOResourceMatch"), v13);
      CFRelease(v21);
      return wait_for_io_service_matching_dict(v12, a2);
    }
    ramrod_log_msg("unable to convert resource name to CFString\n", v14, v15, v16, v17, v18, v19, v20, v23);
  }
  else
  {
    ramrod_log_msg("unable to create matching dictionary for resource '%s'\n", v5, v6, v7, v8, v9, v10, v11, (char)a1);
  }
  return 0;
}

BOOL ramrod_check_NVRAM_access()
{
  io_object_t v0;
  io_object_t v1;

  v0 = wait_for_io_service_matching_resource_with_timeout("IONVRAM", 0);
  v1 = v0;
  if (v0)
    IOObjectRelease(v0);
  return v1 != 0;
}

uint64_t ramrod_delete_NVRAM_variable()
{
  return 1;
}

uint64_t ramrod_copy_NVRAM_variable()
{
  return 0;
}

CFTypeRef ramrod_copy_NVRAM_variable_from_devicetree(CFStringRef theString)
{
  const __CFString *Copy;
  io_registry_entry_t v2;
  CFTypeRef CFProperty;
  io_registry_entry_t v5;

  Copy = CFStringCreateCopy(0, theString);
  v2 = atomic_load((unsigned int *)&unk_1001A8170);
  if (!v2)
  {
    v5 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/options");
    if (v5)
    {
      while (1)
      {
        v2 = __ldaxr((unsigned int *)&unk_1001A8170);
        if (v2)
          break;
        if (!__stlxr(v5, (unsigned int *)&unk_1001A8170))
        {
          v2 = v5;
          goto LABEL_2;
        }
      }
      __clrex();
      IOObjectRelease(v5);
    }
    else
    {
      v2 = 0;
    }
  }
LABEL_2:
  CFProperty = IORegistryEntryCreateCFProperty(v2, Copy, 0, 0);
  CFRelease(Copy);
  return CFProperty;
}

uint64_t image3SHA1Generate(const void *a1, CC_LONG a2, unsigned __int8 *a3)
{
  CC_SHA1_CTX v7;

  memset(&v7, 0, sizeof(v7));
  CC_SHA1_Init(&v7);
  CC_SHA1_Update(&v7, a1, a2);
  return CC_SHA1_Final(a3, &v7);
}

uint64_t image3PKISignHash()
{
  return 0xFFFFFFFFLL;
}

int8x16_t image3SHA1Partial(const void *a1, CC_LONG a2, int8x16_t *a3)
{
  int8x16_t result;
  CC_SHA1_CTX v7;

  memset(&v7, 0, sizeof(v7));
  CC_SHA1_Init(&v7);
  CC_SHA1_Update(&v7, a1, a2);
  result = vrev32q_s8(*(int8x16_t *)&v7.h0);
  *a3 = result;
  a3[1].i32[0] = bswap32(v7.h4);
  return result;
}

uint64_t ramrod_ticket_create_img3(CFDataRef *a1, CFErrorRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  char **v16;
  UInt8 *BytePtr;
  size_t Length;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  CFDataRef v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  char v27;
  char **v28;
  CFIndex v29;
  const UInt8 *v30;

  v28 = 0;
  if (!qword_1001A8178 || byte_1001A8180 != 1)
    return 1;
  v29 = 0;
  v30 = 0;
  if (image3InstantiateNew(&v28, 0, 0x53434142u))
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: unable to create img3 ticket"), v4, v5, v6, (char)"ramrod_ticket_create_img3");
    v14 = "failed to create img3\n";
LABEL_10:
    ramrod_log_msg(v14, v7, v8, v9, v10, v11, v12, v13, v27);
LABEL_11:
    v15 = 0;
    goto LABEL_12;
  }
  v16 = v28;
  BytePtr = (UInt8 *)CFDataGetBytePtr((CFDataRef)qword_1001A8178);
  Length = CFDataGetLength((CFDataRef)qword_1001A8178);
  if (image3SetTagStructure(v16, 1145132097, BytePtr, Length, 32))
  {
    v14 = "failed to create data tag for ticket";
    goto LABEL_10;
  }
  if (image3Finalize((uint64_t)v28, (char **)&v30, &v29, 0, 0))
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: unable to create CFData for img3 ticket"), v19, v20, v21, (char)"ramrod_ticket_create_img3");
    v14 = "could not finalize ticket img3";
    goto LABEL_10;
  }
  v23 = CFDataCreate(kCFAllocatorDefault, v30, v29);
  if (!v23)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: unable to create CFData for img3 ticket"), v24, v25, v26, (char)"ramrod_ticket_create_img3");
    goto LABEL_11;
  }
  *a1 = v23;
  v15 = 1;
LABEL_12:
  if (v28)
    image3Discard((uint64_t *)&v28);
  return v15;
}

uint64_t get_BOOLean_option(const __CFDictionary *a1, const __CFString *a2, uint64_t a3)
{
  uint64_t v3;
  const __CFBoolean *Value;
  const __CFBoolean *v6;
  CFTypeID v7;
  CFTypeID v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int8 valuePtr;
  char buffer[16];
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;

  v3 = a3;
  valuePtr = a3;
  if (a1)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
    if (Value)
    {
      v6 = Value;
      v7 = CFGetTypeID(Value);
      if (v7 == CFBooleanGetTypeID())
        return CFBooleanGetValue(v6);
      v9 = CFGetTypeID(v6);
      if (v9 == CFNumberGetTypeID())
      {
        CFNumberGetValue(v6, kCFNumberIntType, &valuePtr);
        return valuePtr;
      }
      else
      {
        v32 = 0u;
        v33 = 0u;
        v30 = 0u;
        v31 = 0u;
        v28 = 0u;
        v29 = 0u;
        v26 = 0u;
        v27 = 0u;
        v24 = 0u;
        v25 = 0u;
        v22 = 0u;
        v23 = 0u;
        v20 = 0u;
        v21 = 0u;
        *(_OWORD *)buffer = 0u;
        v19 = 0u;
        CFStringGetCString(a2, buffer, 255, 0x8000100u);
        ramrod_log_msg("%s: option '%s' has non-BOOLean value, using default\n", v10, v11, v12, v13, v14, v15, v16, (char)"get_BOOLean_option");
      }
    }
  }
  return v3;
}

uint64_t ramrod_log_msg_to_fd(uint64_t a1, uint64_t a2, int __fd)
{
  uint64_t result;
  uint64_t v7;
  ssize_t v8;

  result = 0;
  if (a1 && a2)
  {
    v7 = 0;
    while (1)
    {
      v8 = write(__fd, (const void *)(a1 + v7), a2 - v7);
      if (v8 == -1)
        break;
      v7 += v8;
      if (v7 == a2)
        return 0;
    }
    return *__error();
  }
  return result;
}

uint64_t sub_10008E544(int a1)
{
  int v1;
  BOOL v2;
  uint64_t *v3;
  __CFSet *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  int *v7;
  uint64_t v8;
  FILE *v9;
  int v10;
  char *v11;
  FILE *v12;
  const char *v13;
  size_t v14;
  stat v16;
  int valuePtr;

  valuePtr = a1;
  memset(&v16, 0, sizeof(v16));
  v1 = fstat(a1, &v16);
  v2 = (__int16)v16.st_mode <= -1 && v1 == 0;
  v3 = &qword_1001A81A8;
  if (v2)
    v3 = &qword_1001A81A0;
  v4 = (__CFSet *)*v3;
  if (!*v3)
  {
    v12 = __stderrp;
    v13 = "can't remove logging fd since none were added";
    v14 = 45;
LABEL_13:
    fwrite(v13, v14, 1uLL, v12);
    return 0xFFFFFFFFLL;
  }
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  if (!v5)
  {
    v12 = __stderrp;
    v13 = "failed to convert fd to number";
    v14 = 30;
    goto LABEL_13;
  }
  v6 = v5;
  CFSetRemoveValue(v4, v5);
  if (close(valuePtr))
  {
    v7 = __error();
    v8 = *v7;
    v9 = __stderrp;
    v10 = valuePtr;
    v11 = strerror(*v7);
    fprintf(v9, "failed to close file descriptor '%d', error:%s", v10, v11);
  }
  else
  {
    v8 = 0;
  }
  CFRelease(v6);
  return v8;
}

uint64_t ramrod_log_msg_to_all_fds(uint64_t a1, uint64_t a2)
{
  CFIndex Count;
  CFIndex v5;
  CFIndex i;
  const __CFNumber *ValueAtIndex;
  int valuePtr;
  __int128 context;
  CFArrayRef theArray[2];

  context = 0u;
  *(_OWORD *)theArray = 0u;
  valuePtr = -1;
  pthread_mutex_lock(&stru_1001A72B0);
  if (a1 && xmmword_1001A81A0 != 0)
  {
    *(_QWORD *)&context = a1;
    *((_QWORD *)&context + 1) = a2;
    theArray[0] = 0;
    LOBYTE(theArray[1]) = 0;
    if (*((_QWORD *)&xmmword_1001A81A0 + 1))
      CFSetApplyFunction(*((CFSetRef *)&xmmword_1001A81A0 + 1), (CFSetApplierFunction)sub_10008E7C8, &context);
    qword_1001A81B0 += a2;
    if (qword_1001A81B0)
    {
      LOBYTE(theArray[1]) = 1;
      qword_1001A81B0 = 0;
    }
    if ((_QWORD)xmmword_1001A81A0)
      CFSetApplyFunction((CFSetRef)xmmword_1001A81A0, (CFSetApplierFunction)sub_10008E7C8, &context);
    if (theArray[0])
    {
      Count = CFArrayGetCount(theArray[0]);
      if (Count >= 1)
      {
        v5 = Count;
        for (i = 0; i != v5; ++i)
        {
          ValueAtIndex = (const __CFNumber *)CFArrayGetValueAtIndex(theArray[0], i);
          if (CFNumberGetValue(ValueAtIndex, kCFNumberIntType, &valuePtr))
            sub_10008E544(valuePtr);
          else
            fwrite("Failed to convert CFNumberRef into int value\n", 0x2DuLL, 1uLL, __stderrp);
        }
      }
      CFRelease(theArray[0]);
    }
  }
  pthread_mutex_unlock(&stru_1001A72B0);
  return 0;
}

void sub_10008E7C8(const void *a1, uint64_t a2)
{
  __CFArray *Mutable;
  FILE *v5;
  const char *v6;
  size_t v7;
  int valuePtr;

  valuePtr = -1;
  if (!a1)
  {
    v5 = __stderrp;
    v6 = "NULL fd num in fd set, weird.\n";
    v7 = 30;
LABEL_11:
    fwrite(v6, v7, 1uLL, v5);
    return;
  }
  if (!a2)
  {
    v5 = __stderrp;
    v6 = "Missing logging context.\n";
    v7 = 25;
    goto LABEL_11;
  }
  if (*(_QWORD *)a2)
  {
    if (CFNumberGetValue((CFNumberRef)a1, kCFNumberIntType, &valuePtr))
    {
      if (ramrod_log_msg_to_fd(*(_QWORD *)a2, *(_QWORD *)(a2 + 8), valuePtr))
      {
        fprintf(__stderrp, "Removing file descriptor %d since it failed to be written to.\n", valuePtr);
        Mutable = *(__CFArray **)(a2 + 16);
        if (!Mutable)
        {
          Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 1, &kCFTypeArrayCallBacks);
          *(_QWORD *)(a2 + 16) = Mutable;
        }
        CFArrayAppendValue(Mutable, a1);
      }
      else if (*(_BYTE *)(a2 + 24))
      {
        fsync(valuePtr);
      }
    }
    else
    {
      fwrite("Failed to convert num to int\n", 0x1DuLL, 1uLL, __stderrp);
    }
  }
}

void ramrod_log_msg(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_10008EA2C(1, a1, &a9);
}

void ramrod_log_msg_cf(CFStringRef format, ...)
{
  const __CFString *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFString *v9;
  const char *CStringPtr;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  CFIndex Length;
  CFIndex v20;
  char *v21;
  char *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v30;
  va_list va;

  va_start(va, format);
  v1 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
  if (!v1)
  {
    ramrod_log_msg("(Failed to format log message)\n", v2, v3, v4, v5, v6, v7, v8, v30);
    return;
  }
  v9 = v1;
  CStringPtr = CFStringGetCStringPtr(v1, 0x8000100u);
  if (CStringPtr)
  {
    v30 = (char)CStringPtr;
    v18 = "%s";
  }
  else
  {
    Length = CFStringGetLength(v9);
    v20 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
    v21 = (char *)malloc(v20);
    if (v21)
    {
      v22 = v21;
      if (CFStringGetCString(v9, v21, v20, 0x8000100u))
        ramrod_log_msg("%s", v23, v24, v25, v26, v27, v28, v29, (char)v22);
      else
        ramrod_log_msg("(Failed to alloc and convert log message)\n", v23, v24, v25, v26, v27, v28, v29, v30);
      free(v22);
      goto LABEL_12;
    }
    v18 = "(Failed to alloc and convert log message)\n";
  }
  ramrod_log_msg(v18, v11, v12, v13, v14, v15, v16, v17, v30);
LABEL_12:
  CFRelease(v9);
}

void sub_10008EA2C(int a1, const char *a2, va_list a3)
{
  size_t v4;
  char *v5;
  char v6;
  char *v7;
  char *v8;
  uint64_t v9;
  char *v10;
  int v11;
  char *__s;

  __s = 0;
  if (vasprintf(&__s, a2, a3) != -1)
  {
    pthread_mutex_lock(&stru_1001A7270);
    if (a1 == 1)
    {
      fputs(__s, __stdoutp);
      if (off_1001A81B8)
        off_1001A81B8(__s);
    }
    v4 = strlen(__s);
    ramrod_log_msg_to_all_fds((uint64_t)__s, v4);
    if (!byte_1001A72F0)
      goto LABEL_23;
    v5 = (char *)qword_1001A8198;
    if (!qword_1001A8198)
    {
      v5 = (char *)malloc(0x100000uLL);
      qword_1001A8198 = (uint64_t)v5;
      if (!v5)
      {
        fprintf(__stderrp, "unable to allocate %lu bytes for log buffer\n", 0x100000);
LABEL_23:
        pthread_mutex_unlock(&stru_1001A7270);
        goto LABEL_24;
      }
      qword_1001A8188 = (uint64_t)v5;
      qword_1001A8190 = (uint64_t)v5;
    }
    v6 = *__s;
    if (*__s)
    {
      v7 = v5 + 0x100000;
      v8 = (char *)qword_1001A8190;
      v9 = qword_1001A8188;
      v10 = __s + 1;
      do
      {
        *v8 = v6;
        if (v8 + 1 == v7)
          v8 = v5;
        else
          ++v8;
        qword_1001A8190 = (uint64_t)v8;
        if ((char *)v9 == v8)
        {
          if (v8 + 1 == v7)
            v9 = (uint64_t)v5;
          else
            v9 = (uint64_t)(v8 + 1);
          qword_1001A8188 = v9;
        }
        v11 = *v10++;
        v6 = v11;
      }
      while (v11);
    }
    goto LABEL_23;
  }
  fwrite("unable to allocate storage for log message\n", 0x2BuLL, 1uLL, __stderrp);
LABEL_24:
  free(__s);
}

CFStringRef sub_10008EBA4()
{
  return CFStringCreateWithFormat(0, 0, CFSTR("UNKNOWN"));
}

CFStringRef sub_10008EBB8(uint64_t a1, const char **a2)
{
  const char *v2;
  size_t v3;

  if (!a2)
    return 0;
  v2 = *a2;
  if (!*a2)
    return 0;
  v3 = strlen(*a2);
  if (v3 > 0x100)
    return CFStringCreateWithFormat(0, 0, CFSTR("~%s"), &v2[v3 - 255]);
  else
    return CFStringCreateWithFormat(0, 0, CFSTR("%s"), v2);
}

CFStringRef sub_10008EC2C(uint64_t a1, unsigned int *a2)
{
  uint64_t v3;
  size_t v4;

  if (!a2)
    return 0;
  v3 = *((_QWORD *)a2 + 1);
  if (!v3)
    return 0;
  v4 = strlen(*((const char **)a2 + 1));
  if (v4 > 0xF2)
    return CFStringCreateWithFormat(0, 0, CFSTR("{0x%08X:\"~%s\"}"), *a2, v4 + v3 - 241);
  else
    return CFStringCreateWithFormat(0, 0, CFSTR("{0x%08X:\"%s\"}"), *a2, v3);
}

CFStringRef sub_10008ECAC(uint64_t a1, _QWORD *a2)
{
  if (a2)
    return CFStringCreateWithFormat(0, 0, CFSTR("%ld"), *a2);
  else
    return 0;
}

CFStringRef sub_10008ECEC(uint64_t a1, const __CFString *a2)
{
  CFStringRef v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  char v10;
  char v11;
  const char *v12;
  char v14;
  int v15;
  char *v16;

  v2 = a2;
  if (a2)
  {
    v16 = 0;
    asprintf(&v16, "{");
    v8 = v16;
    if (v16)
    {
      v9 = 0;
      v15 = 0;
      v10 = 1;
      do
      {
        v11 = v10;
        v12 = (const char *)*((_QWORD *)&v2->isa + v9);
        if (v12)
        {
          v8 = sub_1000915AC(v8, off_100180D20[v9], v12, &v15);
          v16 = v8;
        }
        v10 = 0;
        v9 = 1;
      }
      while ((v11 & 1) != 0);
      v16 = sub_100091698(v8, "}", (uint64_t)v12, v3, v4, v5, v6, v7, v14);
      v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v16);
      if (v16)
        free(v16);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFStringRef sub_10008EDB8(uint64_t a1, const __CFString *a2)
{
  CFStringRef v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  const char *v10;
  char v12;
  int v13;
  char *v14;

  v2 = a2;
  if (a2)
  {
    v14 = 0;
    asprintf(&v14, "{");
    v8 = v14;
    if (v14)
    {
      v9 = 0;
      v13 = 0;
      do
      {
        v10 = *(const char **)((char *)&v2->info + v9);
        if (v10)
        {
          v8 = sub_100091734(v8, *(_DWORD *)((char *)&v2->isa + v9), v10, &v13);
          v14 = v8;
        }
        v9 += 16;
      }
      while (v9 != 128);
      v14 = sub_100091698(v8, "}", (uint64_t)v10, v3, v4, v5, v6, v7, v12);
      v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v14);
      if (v14)
        free(v14);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFStringRef sub_10008EE70(uint64_t a1, const __CFString *a2)
{
  CFStringRef v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v11;
  char *v12;
  int v13;
  char *v14;

  v2 = a2;
  if (a2)
  {
    v14 = 0;
    asprintf(&v14, "{");
    if (v14)
    {
      v9 = 0;
      v13 = 0;
      do
      {
        if (*(_DWORD *)((char *)&v2->isa + v9))
        {
          v12 = 0;
          asprintf(&v12, "%d", *(_DWORD *)((char *)&v2->isa + v9 + 4));
          v3 = v12;
          if (v12)
          {
            v14 = sub_100091734(v14, *(_DWORD *)((char *)&v2->isa + v9), v12, &v13);
            if (v12)
              free(v12);
          }
        }
        v9 += 8;
      }
      while (v9 != 64);
      v14 = sub_100091698(v14, "}", (uint64_t)v3, v4, v5, v6, v7, v8, v11);
      v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v14);
      if (v14)
        free(v14);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFStringRef sub_10008EF6C(uint64_t a1, const __CFString *a2)
{
  CFStringRef v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *p_info;
  int *v11;
  uint64_t v12;
  const char *v13;
  char *v14;
  char *v15;
  char v17;
  int v18;
  char *v19;
  char *v20;
  int v21;
  char *v22;

  v2 = a2;
  if (a2)
  {
    v19 = 0;
    asprintf(&v19, "{");
    if (v19)
    {
      v9 = 0;
      v18 = 0;
      p_info = &v2->info;
      do
      {
        v11 = (int *)v2 + 18 * v9;
        if (*v11)
        {
          v22 = 0;
          asprintf(&v22, "{");
          if (v22)
          {
            v12 = 0;
            v21 = 0;
            do
            {
              v13 = (const char *)p_info[v12];
              if (v13)
              {
                v20 = 0;
                asprintf(&v20, "\"%s\"", v13);
                v3 = v20;
                if (v20)
                {
                  v22 = sub_1000917A8(v22, v12, v20, &v21);
                  if (v20)
                    free(v20);
                }
              }
              ++v12;
            }
            while (v12 != 8);
            v14 = sub_100091698(v22, "}", (uint64_t)v3, v4, v5, v6, v7, v8, v17);
            if (v14)
            {
              v15 = v14;
              v19 = sub_100091734(v19, *v11, v14, &v18);
              free(v15);
            }
          }
        }
        ++v9;
        p_info += 9;
      }
      while (v9 != 8);
      v19 = sub_100091698(v19, "}", (uint64_t)v3, v4, v5, v6, v7, v8, v17);
      v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v19);
      if (v19)
        free(v19);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

CFStringRef sub_10008F100(uint64_t a1, const __CFString *a2)
{
  CFStringRef v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFStringRef v10;
  int *v11;
  uint64_t v12;
  char *v13;
  char *v14;
  char v16;
  int v17;
  char *v18;
  char *v19;
  int v20;
  char *v21;

  v2 = a2;
  if (a2)
  {
    v18 = 0;
    asprintf(&v18, "{");
    if (v18)
    {
      v9 = 0;
      v17 = 0;
      v10 = v2;
      do
      {
        v11 = (int *)v2 + 11 * v9;
        if (*v11)
        {
          v21 = 0;
          asprintf(&v21, "{");
          if (v21)
          {
            v12 = 0;
            v20 = 0;
            do
            {
              if (*((_BYTE *)&v10[1].isa + v12 + 4))
              {
                v19 = 0;
                asprintf(&v19, "%d", *((_DWORD *)&v10->isa + v12 + 1));
                v3 = v19;
                if (v19)
                {
                  v21 = sub_1000917A8(v21, v12, v19, &v20);
                  if (v19)
                    free(v19);
                }
              }
              ++v12;
            }
            while (v12 != 8);
            v13 = sub_100091698(v21, "}", (uint64_t)v3, v4, v5, v6, v7, v8, v16);
            if (v13)
            {
              v14 = v13;
              v18 = sub_100091734(v18, *v11, v13, &v17);
              free(v14);
            }
          }
        }
        ++v9;
        v10 = (CFStringRef)((char *)v10 + 44);
      }
      while (v9 != 8);
      v18 = sub_100091698(v18, "}", (uint64_t)v3, v4, v5, v6, v7, v8, v16);
      v2 = CFStringCreateWithFormat(0, 0, CFSTR("%s"), v18);
      if (v18)
        free(v18);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

uint64_t sub_10008F2A0(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const __CFString **v13;
  uint64_t v14;
  int v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  const __CFString *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int *v39;
  int v40;
  int v41;
  unsigned int *v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int *v52;
  const __CFString *v53;
  int v54;
  const __CFString *v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int *v64;
  const __CFString *v65;
  const __CFString *v66;
  uint64_t v67;
  uint64_t v68;
  const __CFString *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _QWORD *v74;
  int *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t i;
  const __CFString **v80;
  unsigned int v81;
  char v82;
  char v83[1024];

  v8 = a3;
  v10 = *(_DWORD *)(a1 + 664);
  if (!v10)
    goto LABEL_160;
  if (v10 == 1)
  {
    v11 = 1;
    goto LABEL_20;
  }
  v11 = 0;
  if (a2)
  {
    if (v10 == 2)
    {
LABEL_160:
      if (ramrod_check_NVRAM_access())
      {
        if (*(_BYTE *)(a1 + 2272))
        {
          if (!*(_BYTE *)(a1 + 2273))
          {
LABEL_24:
            v17 = *(_DWORD *)(a1 + 664);
            if (*(_BYTE *)(a1 + 669))
            {
LABEL_149:
              v11 = 1;
              *(_DWORD *)(a1 + 664) = 1;
              if (!v8)
              {
                if (v17)
                  sub_10008FB94(a1, 2, 1, 0, 256, "NVRAM access has become available", 0, 0, 0);
                else
                  sub_10008FB94(a1, 2, 1, 0, 256, "NVRAM access available on initial check", 0, 0, 0);
              }
              goto LABEL_20;
            }
            v18 = *(_DWORD *)a1 == 1 && v17 == 2;
            v19 = 8;
            if (v18)
              v19 = 400;
            v20 = a1 + v19;
            v21 = (_QWORD *)(v20 + 664);
            if (*(_BYTE *)(v20 + 668))
              ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): first available indication when already collected\n", v12, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_handle_first_available");
            else
              sub_10009065C((int *)a1, (uint64_t)v21, a3, a4, a5, a6, a7, a8);
            if (*(_DWORD *)a1 == 1)
            {
              v29 = *(_DWORD *)(a1 + 88);
              if (*(_DWORD *)(a1 + 96))
              {
                if (v29 == 2)
                  v39 = (unsigned int *)&unk_1001633E4;
                else
                  v39 = (unsigned int *)&unk_10016352C;
              }
              else
              {
                if (v29 == 2)
                {
                  v31 = sub_100091BB4(a1, (uint64_t)v21, dword_100163154, v24, v25, v26, v27, v28);
                  sub_100091DE8(a1, (uint64_t)v21);
                  goto LABEL_53;
                }
                v39 = (unsigned int *)&unk_1001632D4;
              }
              v31 = sub_100091BB4(a1, (uint64_t)v21, v39, v24, v25, v26, v27, v28);
LABEL_53:
              v43 = v21[6];
              if (!v43)
              {
LABEL_110:
                if (!(_DWORD)v43 && v31 && !*(_BYTE *)(a1 + 106) && !*(_BYTE *)(a1 + 100) && !*(_BYTE *)(a1 + 104))
                  sub_100090818(a1, v32, "[monitor_aware]pre-existing NVRAM implied reboot-retry but values were inconsistent");
LABEL_116:
                if (*(_BYTE *)(a1 + 104))
                {
                  if (v17 == 2)
                  {
                    v73 = 0;
                    v74 = (_QWORD *)(a1 + 1496);
                    v75 = &dword_100180D40;
LABEL_119:
                    v76 = *v75;
                    if (v73 != v76)
                    {
                      v77 = a1 + 16 * (int)v76;
                      *(_BYTE *)(v77 + 1492) = *((_BYTE *)v74 - 4);
                      *((_BYTE *)v74 - 4) = 0;
                      v78 = *v74;
                      *v74 = *(_QWORD *)(v77 + 1496);
                      *(_QWORD *)(v77 + 1496) = v78;
                    }
                    while (v73 != 47)
                    {
                      v74 += 2;
                      v75 += 8;
                      ++v73;
                      if (*(_BYTE *)(a1 + 104))
                        goto LABEL_119;
                    }
                  }
                }
                else if (*(_DWORD *)a1 != 1 && *(_DWORD *)(a1 + 88) == 2)
                {
                  ramrod_log_msg("%s\n", v32, v33, v34, v35, v36, v37, v38, (char)"void clear_stale_ota_nvram(void)");
                  sub_100091F98(CFSTR("boot-breadcrumbs"));
                  sub_100091F98(CFSTR("OTA-pre-conversion"));
                  sub_100091F98(CFSTR("OTA-post-conversion"));
                  sub_100091F98(CFSTR("ota-conv-panic-indicator"));
                  sub_100091F98(CFSTR("OTA-fsck-metrics"));
                  sub_100091F98(CFSTR("OTA-sealvolume-metrics"));
                  sub_100091F98(CFSTR("OTA-migrator-metrics"));
                  for (i = 0; i != 28; ++i)
                  {
                    v80 = (const __CFString **)&off_100180D30[4 * dword_100163A64[i]];
                    sub_100091F98(v80[1]);
                    sub_100091F98(*v80);
                  }
                }
                if (*(_DWORD *)(a1 + 96))
                {
                  if (*(_BYTE *)(a1 + 101))
                  {
                    if (*(_BYTE *)(a1 + 104))
                    {
                      if (*(_BYTE *)(a1 + 106))
                      {
                        v81 = 9;
                      }
                      else if (*(_BYTE *)(a1 + 105))
                      {
                        v81 = 12;
                      }
                      else if (*(_BYTE *)(a1 + 100))
                      {
                        v81 = 10;
                      }
                      else
                      {
                        v81 = 11;
                      }
                    }
                    else if (*(_BYTE *)(a1 + 103))
                    {
                      v81 = 10;
                    }
                    else
                    {
                      v81 = 3;
                    }
                  }
                  else if (*(_BYTE *)(a1 + 102))
                  {
                    if (*(_BYTE *)(a1 + 104))
                      v81 = 7;
                    else
                      v81 = 6;
                  }
                  else
                  {
                    v81 = 2;
                  }
                  sub_1000908B4(a1, v81, v33, v34, v35, v36, v37, v38);
                }
                else
                {
                  sub_10009181C(a1, 1, v33, v34, v35, v36, v37, v38);
                }
                *(_BYTE *)(a1 + 669) = 1;
                goto LABEL_149;
              }
              v44 = sub_1000907A0(a1, (uint64_t)v21, v33, v34, v35, v36, v37, v38);
              if (v44 < 0x22)
              {
                v52 = &dword_100163AD4[3 * v44];
              }
              else
              {
                ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid outcome=%d\n", v45, v46, v47, v48, v49, v50, v51, (char)"checkpoint_get_outcome_attributes");
                v52 = dword_100163AD4;
              }
              v53 = (const __CFString *)v21[6];
              bzero(v83, 0x400uLL);
              if (*v52 == 2)
              {
                v54 = *((unsigned __int8 *)v52 + 8);
                if (*((_BYTE *)v52 + 8))
                  *(_BYTE *)(a1 + 106) = 1;
                if (*((_BYTE *)v52 + 7))
                {
                  v31 = 0;
                  *(_BYTE *)(a1 + 102) = 1;
                }
                if (!*((_BYTE *)v52 + 5))
                {
                  if (!*((_BYTE *)v52 + 4) || !*((_BYTE *)v52 + 6))
                  {
                    LODWORD(v43) = 0;
                    goto LABEL_110;
                  }
                  if (v54)
                  {
                    LODWORD(v43) = 0;
                    *(_BYTE *)(a1 + 101) = 1;
                    goto LABEL_110;
                  }
                  v43 = v21[8];
                  if (!v43)
                    goto LABEL_110;
LABEL_98:
                  v69 = (const __CFString *)v21[7];
                  *(_BYTE *)(a1 + 101) = 1;
                  if (v69 && CFStringCompare(v69, CFSTR("true"), 0) == kCFCompareEqualTo)
                  {
                    *(_BYTE *)(a1 + 100) = 1;
                    LODWORD(v43) = *((unsigned __int8 *)v52 + 5);
                    if (!*((_BYTE *)v52 + 5))
                    {
                      *(_BYTE *)(a1 + 103) = 1;
                      goto LABEL_110;
                    }
                    LODWORD(v43) = 0;
                    goto LABEL_65;
                  }
                  goto LABEL_100;
                }
                if (v54)
                {
                  LODWORD(v43) = 0;
                  *(_BYTE *)(a1 + 101) = 1;
LABEL_65:
                  *(_WORD *)(a1 + 104) = 257;
                  goto LABEL_110;
                }
                v43 = v21[8];
                if (v43)
                  goto LABEL_98;
              }
              else
              {
                LODWORD(v43) = *((unsigned __int8 *)v52 + 5);
                if (!*((_BYTE *)v52 + 5))
                  goto LABEL_110;
                if (!v21[8])
                {
                  sub_100090A3C(v53, v83);
                  sub_100090818(a1, v71, "[monitor_aware]outcome=%s(reboot_retry_not_in_zone)");
                  goto LABEL_102;
                }
                v55 = (const __CFString *)v21[7];
                if (!v55 || CFStringCompare(v55, CFSTR("true"), 0))
                {
LABEL_100:
                  sub_100090A3C(v53, v83);
                  sub_100090818(a1, v70, "[monitor_aware]outcome=%s(reboot_retry_disabled)");
LABEL_102:
                  LODWORD(v43) = 1;
                  goto LABEL_110;
                }
                LODWORD(v43) = 0;
              }
              *(_BYTE *)(a1 + 104) = 1;
              goto LABEL_110;
            }
            v30 = (const __CFString *)v21[7];
            if (v30 && CFStringCompare(v30, CFSTR("true"), 0) == kCFCompareEqualTo)
              *(_BYTE *)(a1 + 100) = 1;
            else
              ramrod_log_msg("AP nonce will not be touched\n", v22, v23, v24, v25, v26, v27, v28, v82);
            v40 = *(_DWORD *)(a1 + 88);
            if (*(_DWORD *)(a1 + 96))
            {
              if (v40 == 2)
              {
                v41 = sub_100091BB4(a1, (uint64_t)v21, dword_1001637CC, v24, v25, v26, v27, v28);
                sub_100091DE8(a1, (uint64_t)v21);
                goto LABEL_72;
              }
              v42 = (unsigned int *)&unk_100163954;
            }
            else if (v40 == 2)
            {
              v42 = (unsigned int *)&unk_10016360C;
            }
            else
            {
              v42 = (unsigned int *)&unk_100163724;
            }
            v41 = sub_100091BB4(a1, (uint64_t)v21, v42, v24, v25, v26, v27, v28);
LABEL_72:
            if (!v21[6])
            {
              *(_BYTE *)(a1 + 1456) = 1;
              *(_QWORD *)(a1 + 1464) = "access now enabled";
              if (*(_DWORD *)(a1 + 88) == 2)
              {
                if (v21[8])
                  sub_10009093C(a1, 7, 0, 0, v35, v36, v37, v38);
                v65 = (const __CFString *)v21[3];
                if (v65 && CFStringCompare(v65, CFSTR("recover"), 0))
                  sub_10009093C(a1, 2, 1, 0, v35, v36, v37, v38);
                if (v21[4])
                  sub_10009093C(a1, 3, 1, 0, v35, v36, v37, v38);
              }
              goto LABEL_105;
            }
            v56 = sub_1000907A0(a1, (uint64_t)v21, v33, v34, v35, v36, v37, v38);
            if (v56 < 0x22)
            {
              v64 = &dword_100163AD4[3 * v56];
            }
            else
            {
              ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid outcome=%d\n", v57, v58, v59, v60, v61, v62, v63, (char)"checkpoint_get_outcome_attributes");
              v64 = dword_100163AD4;
            }
            v66 = (const __CFString *)v21[6];
            bzero(v83, 0x400uLL);
            if (*v64 != 1)
            {
              if (*((_BYTE *)v64 + 6))
              {
                if (v21[8])
                {
                  sub_100091EC4((_BYTE *)a1, v66, v33, v34, v35, v36, v37, v38, v82);
                }
                else
                {
                  sub_100090A3C(v66, v83);
                  sub_100090818(a1, v72, "[chassis_aware]outcome=%s(pre_existing_reboot_retry_not_in_zone)", v83);
                }
              }
              *(_BYTE *)(a1 + 1456) = 1;
              *(_QWORD *)(a1 + 1464) = "access now enabled";
              goto LABEL_105;
            }
            v67 = v21[8];
            if (*((_BYTE *)v64 + 5))
            {
              if (!v67)
              {
                sub_100090A3C(v66, v83);
                sub_100090818(a1, v68, "[chassis_aware]outcome=%s(pre_existing_reboot_retry_not_in_zone)", v83);
LABEL_105:
                if (v41 && !*(_BYTE *)(a1 + 104))
                  sub_100090818(a1, v32, "[chassis_aware]pre-existing NVRAM implied reboot-retry but values were inconsistent");
                goto LABEL_116;
              }
            }
            else if (!v67)
            {
              goto LABEL_105;
            }
            sub_100091EC4((_BYTE *)a1, v66, v33, v34, v35, v36, v37, v38, v82);
            goto LABEL_105;
          }
        }
        else
        {
          sub_1000918D0(a1, 1u, 0x2Fu, (const __CFString **)(a1 + 1056));
          if (!*(_QWORD *)(a1 + 1056))
          {
            *(_BYTE *)(a1 + 2272) = 1;
            goto LABEL_24;
          }
          if (*(_DWORD *)a1 == 2)
            sub_10009093C(a1, 47, 0, 0, a5, a6, a7, a8);
          *(_BYTE *)(a1 + 2273) = 1;
          *(_BYTE *)(a1 + 668) = 0;
          v13 = (const __CFString **)(a1 + 992);
          v14 = -4;
          do
            sub_1000918D0(a1, 1u, v14 + 43, v13++);
          while (!__CFADD__(v14++, 1));
          *(_BYTE *)(a1 + 2272) = 1;
        }
      }
      *(_DWORD *)(a1 + 664) = 2;
      if (!v8)
        sub_10008FB94(a1, 2, 1, 0, 256, "NVRAM access is not currently available", 0, 0, 0);
      v11 = 0;
    }
  }
LABEL_20:
  if (!*(_DWORD *)(a1 + 96))
    sub_10009181C(a1, v11, a3, a4, a5, a6, a7, a8);
  return v11;
}

_QWORD *sub_10008FB94(uint64_t a1, int a2, int a3, int a4, int a5, const char *a6, int a7, int a8, const void *a9)
{
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  int v27;
  __CFError *v28;
  CFIndex Code;
  const __CFString *Domain;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int *v41;
  unint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  int v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD *v52;
  unint64_t v53;
  int v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  unint64_t v60;
  int *v61;
  int v62;
  _QWORD *v63;
  void *v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unsigned int v72;
  _QWORD **v73;
  _QWORD *v74;
  _QWORD *v75;
  void *v76;
  const void *v77;
  uint64_t v78;
  const char *v79;
  char *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned int v87;
  char *v88;
  int v89;
  char *v90;
  int v91;
  char *v92;
  int v93;
  char *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  char *v100;
  char *v101;
  uint64_t v102;
  const char *v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  char v111;
  char *v112;
  char v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  char *v122;
  _QWORD *v123;
  _QWORD *v124;
  int v125;
  uint64_t v127;
  char v128;
  char v129;
  char *v130;
  char *v131[2];
  size_t v132;
  tm buffer[18];
  int v134[2];

  v17 = calloc(1uLL, 0x78uLL);
  if (!v17)
    return v17;
  v130 = 0;
  asprintf(&v130, "%s", a6);
  if (!v130)
  {
    free(v17);
    return 0;
  }
  *((_DWORD *)v17 + 2) = a2;
  v17[2] = time(0);
  gettimeofday((timeval *)(v17 + 3), 0);
  *((_DWORD *)v17 + 10) = getpid();
  *((_DWORD *)v17 + 11) = getppid();
  *((_DWORD *)v17 + 12) = a3;
  *((_DWORD *)v17 + 13) = a4;
  *((_DWORD *)v17 + 14) = a5;
  v17[8] = v130;
  *((_DWORD *)v17 + 18) = a7;
  *((_DWORD *)v17 + 19) = a8;
  if (a9)
  {
    v17[10] = a9;
    CFRetain(a9);
    a5 = *((_DWORD *)v17 + 14);
  }
  *((_DWORD *)v17 + 22) = a5 | (*((_DWORD *)v17 + 2) << 16) | 0x11000000;
  *(_QWORD *)v134 = 0x1500000001;
  v131[0] = 0;
  v131[1] = 0;
  v132 = 16;
  if (sysctl(v134, 2u, v131, &v132, 0, 0))
    v25 = -1;
  else
    v25 = v17[2] - (unint64_t)v131[0];
  v26 = *((_DWORD *)v17 + 2);
  switch(v26)
  {
    case 1:
      sub_1000921C0(a1, 10, *((unsigned int *)v17 + 22), (const char *)v17[8], v21, v22, v23, v24);
      goto LABEL_69;
    case 2:
      goto LABEL_69;
    case 3:
      if (!*((_DWORD *)v17 + 18))
      {
        v38 = 23;
        if (!*(_BYTE *)(a1 + 104))
          v38 = 11;
        v39 = *(_DWORD *)(a1 + 1472) + 1;
        *(_DWORD *)(a1 + 1472) = v39;
        v40 = *((unsigned int *)v17 + 22);
        v41 = *(int **)(a1 + 16 * v38 + 1496);
        if (!v41)
          goto LABEL_28;
        v42 = 0;
        do
        {
          v44 = *v41;
          v41 += 2;
          v43 = v44;
          if (v42 > 6)
            break;
          ++v42;
        }
        while (v43);
        if (!v43)
        {
          *(v41 - 2) = v40;
          *(v41 - 1) = v39;
          *(_BYTE *)(a1 + 16 * v38 + 1492) = 1;
        }
        else
        {
LABEL_28:
          v45 = *(_DWORD *)(a1 + 1476);
          if (!v45)
          {
            ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on store [%s]\n", v18, v40, v20, v21, v22, v23, v24, (char)"checkpoint_nvram_store_lost");
            v45 = *(_DWORD *)(a1 + 1476);
            v40 = *((unsigned int *)v17 + 22);
          }
          *(_DWORD *)(a1 + 1476) = v45 + 1;
        }
        sub_1000921C0(a1, 12, v40, (const char *)v17[8], v21, v22, v23, v24);
      }
      goto LABEL_68;
    case 4:
    case 7:
      goto LABEL_15;
    case 5:
      goto LABEL_13;
    case 6:
      sub_100092530(a1, 14, *((unsigned int *)v17 + 22), *((unsigned int *)v17 + 18), (const char *)v17[8], v22, v23, v24);
      goto LABEL_69;
    default:
      if (v26 == 32)
      {
LABEL_15:
        sub_1000923E0(a1, 13, *((_DWORD *)v17 + 14) | 0x11070000u, *((unsigned int *)v17 + 18), *((unsigned int *)v17 + 19), v22, v23, v24);
        v28 = (__CFError *)v17[10];
        if (v28)
        {
          Code = CFErrorGetCode(v28);
          Domain = CFErrorGetDomain((CFErrorRef)v17[10]);
          v31 = sub_100090C3C((CFErrorRef)v17[10]);
          sub_1000923E0(a1, 15, *((unsigned int *)v17 + 22), *((unsigned int *)v17 + 18), Code, v32, v33, v34);
          if (Domain)
          {
            bzero(buffer, 0x400uLL);
            CFStringGetCString(Domain, (char *)buffer, 1024, 0x8000100u);
            sub_100092530(a1, 16, *((unsigned int *)v17 + 22), *((unsigned int *)v17 + 18), (const char *)buffer, v35, v36, v37);
          }
          if (v31)
          {
            sub_1000921C0(a1, 17, *((unsigned int *)v17 + 22), v31, v21, v22, v23, v24);
            free(v31);
          }
        }
        goto LABEL_68;
      }
      if (v26 != 33)
        goto LABEL_69;
LABEL_13:
      v20 = *((unsigned int *)v17 + 18);
      v27 = *((_DWORD *)v17 + 14);
      if ((_DWORD)v20)
      {
        sub_1000923E0(a1, 13, v27 | 0x11070000u, v20, 0, v22, v23, v24);
        goto LABEL_68;
      }
      v46 = 23;
      if (!*(_BYTE *)(a1 + 104))
        v46 = 11;
      v47 = a1 + 16 * v46;
      v48 = *(_QWORD **)(v47 + 1496);
      if (!v48)
        goto LABEL_45;
      v49 = v27 | 0x11030000;
      if (*(_DWORD *)v48 == v49)
      {
        v50 = 0;
        *v48 = 0;
LABEL_37:
        v51 = v50;
        do
        {
          v48[v51] = v48[v51 + 1];
          ++v51;
        }
        while (v51 != 7);
        goto LABEL_39;
      }
      v52 = v48 + 1;
      v53 = -1;
      while (v53 != 6)
      {
        v54 = *v52;
        v52 += 2;
        ++v53;
        if (v54 == v49)
        {
          *((_QWORD *)v52 - 1) = 0;
          if (v53 <= 5)
          {
            v50 = v53 + 1;
            goto LABEL_37;
          }
LABEL_39:
          v48[7] = 0;
          *(_BYTE *)(v47 + 1492) = 1;
          goto LABEL_48;
        }
      }
LABEL_45:
      v55 = *(_DWORD *)(a1 + 1480);
      if (!v55)
      {
        ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on remove [%s]\n", v18, v19, v20, v21, v22, v23, v24, (char)"checkpoint_nvram_remove_lost");
        v55 = *(_DWORD *)(a1 + 1480);
      }
      *(_DWORD *)(a1 + 1480) = v55 + 1;
LABEL_48:
      v56 = 24;
      if (!*(_BYTE *)(a1 + 104))
        v56 = 12;
      if (((0x1001100uLL >> v56) & 1) == 0)
        goto LABEL_63;
      v57 = a1 + 16 * v56;
      v58 = *(_QWORD *)(v57 + 1496);
      if (!v58)
        goto LABEL_63;
      v59 = *((_DWORD *)v17 + 14) | 0x11030000;
      if (*(_DWORD *)v58 == v59)
      {
        v60 = 0;
LABEL_57:
        v63 = (_QWORD *)(v58 + 16 * v60);
        v64 = (void *)v63[1];
        if (v64)
          free(v64);
        *v63 = 0;
        v63[1] = 0;
        if (v60 <= 6)
        {
          v65 = 16 * v60;
          do
          {
            *(_OWORD *)(v58 + v65) = *(_OWORD *)(v58 + v65 + 16);
            v65 += 16;
          }
          while (v65 != 112);
        }
        *(_QWORD *)(v58 + 112) = 0;
        *(_QWORD *)(v58 + 120) = 0;
        *(_BYTE *)(v57 + 1492) = 1;
      }
      else
      {
        v60 = 0;
        v61 = (int *)(v58 + 16);
        while (v60 != 7)
        {
          ++v60;
          v62 = *v61;
          v61 += 4;
          if (v62 == v59)
            goto LABEL_57;
        }
LABEL_63:
        v66 = *(_DWORD *)(a1 + 1480);
        if (!v66)
        {
          ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on remove [%s]\n", v18, v19, v20, v21, v22, v23, v24, (char)"checkpoint_nvram_remove_lost");
          v66 = *(_DWORD *)(a1 + 1480);
        }
        *(_DWORD *)(a1 + 1480) = v66 + 1;
      }
LABEL_68:
      sub_1000922FC(a1, 18, v25, v20, v21, v22, v23, v24);
      sub_1000922FC(a1, 21, (uint64_t)*((double *)v17 + 14), v67, v68, v69, v70, v71);
LABEL_69:
      *v17 = 0;
      **(_QWORD **)(a1 + 192) = v17;
      *(_QWORD *)(a1 + 192) = v17;
      v72 = *(_DWORD *)(a1 + 200) + 1;
      *(_DWORD *)(a1 + 200) = v72;
      if (v72 >= 0x201)
      {
        v73 = (_QWORD **)(a1 + 184);
        do
        {
          v74 = *v73;
          v75 = (_QWORD *)**v73;
          *v73 = v75;
          if (!v75)
            *(_QWORD *)(a1 + 192) = v73;
          *(_DWORD *)(a1 + 200) = v72 - 1;
          v76 = (void *)v74[8];
          if (v76)
          {
            free(v76);
            v74[8] = 0;
          }
          v77 = (const void *)v74[10];
          if (v77)
            CFRelease(v77);
          free(v74);
          v72 = *(_DWORD *)(a1 + 200);
        }
        while (v72 > 0x200);
      }
      memset(buffer, 0, 56);
      v131[0] = 0;
      gmtime_r(v17 + 2, buffer);
      v78 = *((unsigned int *)v17 + 2);
      if (v78 > 0x21)
        v79 = "GENERAL";
      else
        v79 = off_1001813B8[v78];
      asprintf(v131, "[%02u:%02u:%02u.%04u-GMT]{%u>%u} CHECKPOINT %s", buffer[0].tm_hour, buffer[0].tm_min, buffer[0].tm_sec, *((_DWORD *)v17 + 8) / 1000, *((_DWORD *)v17 + 11), *((_DWORD *)v17 + 10), v79);
      v80 = v131[0];
      *(_QWORD *)&buffer[0].tm_sec = 0;
      if (*((_DWORD *)v17 + 19))
      {
        asprintf((char **)buffer, "(FAILURE:%d) ");
      }
      else
      {
        v87 = *((_DWORD *)v17 + 2);
        if (v87 <= 0x1C && ((1 << v87) & 0x18000080) != 0)
          asprintf((char **)buffer, "(SUCCESS) ", v127);
        else
          asprintf((char **)buffer, " ", v127);
      }
      v88 = *(char **)&buffer[0].tm_sec;
      if (!v80 || !*(_QWORD *)&buffer[0].tm_sec)
        goto LABEL_149;
      *(_QWORD *)&buffer[0].tm_sec = 0;
      if (*((_DWORD *)v17 + 14))
      {
        v89 = *((_DWORD *)v17 + 2);
        if (v89 == 28 || v89 == 1)
        {
          asprintf((char **)buffer, "[0x%04X] %s");
        }
        else if (*((_DWORD *)v17 + 12) == 1)
        {
          asprintf((char **)buffer, "%s");
        }
        else
        {
          asprintf((char **)buffer, "%s:[0x%04X] %s");
        }
        v90 = *(char **)&buffer[0].tm_sec;
      }
      else
      {
        v90 = 0;
      }
      v131[0] = 0;
      v91 = *((_DWORD *)v17 + 2);
      if (v91 == 28)
      {
        *(_QWORD *)&buffer[0].tm_sec = 0;
        if (!*((_DWORD *)v17 + 19))
        {
          asprintf((char **)buffer, "... %s");
          goto LABEL_122;
        }
        v94 = sub_100092730(a1, 9, v81, v82, v83, v84, v85, v86);
        v100 = sub_1000927DC(a1, a1 + 1064, 12, v95, v96, v97, v98, v99);
        v101 = v100;
        v102 = *(unsigned int *)(a1 + 108);
        if (v102 > 6)
          v103 = "GENERAL";
        else
          v103 = off_1001815B0[v102];
        if (v94)
        {
          if (!v100)
          {
            asprintf((char **)buffer, "[%s] %s", v103, v94);
            v112 = v94;
            goto LABEL_121;
          }
          asprintf((char **)buffer, "[%s] %s %s", v103, v100, v94);
          free(v94);
        }
        else
        {
          if (!v100)
          {
            asprintf((char **)buffer, "[%s]");
LABEL_122:
            v92 = *(char **)&buffer[0].tm_sec;
            if (v90)
              goto LABEL_106;
            goto LABEL_123;
          }
          asprintf((char **)buffer, "[%s] %s", v103, v100);
        }
        v112 = v101;
LABEL_121:
        free(v112);
        goto LABEL_122;
      }
      if (v91 == 27)
      {
        v92 = sub_100092730(a1, 13, v81, v82, v83, v84, v85, v86);
        v93 = strcmp(v92, "{}");
        if (v92 && !v93)
        {
          free(v92);
          if (!v90)
            goto LABEL_125;
LABEL_108:
          asprintf(v131, "%s:%s%s", v80, v88, v90);
          v111 = 0;
          v92 = 0;
          goto LABEL_127;
        }
      }
      else
      {
        v92 = sub_100090C3C((CFErrorRef)v17[10]);
      }
      if (v90)
      {
LABEL_106:
        if (v92)
        {
          asprintf(v131, "%s:%s%s %s", v80, v88, v90, v92);
          v111 = 0;
          goto LABEL_127;
        }
        goto LABEL_108;
      }
LABEL_123:
      if (v92)
      {
        asprintf(v131, "%s:%s %s", v80, v88, v92);
        goto LABEL_126;
      }
LABEL_125:
      asprintf(v131, "%s:%s", v80, v88);
      v92 = 0;
LABEL_126:
      v111 = 1;
LABEL_127:
      v113 = (char)v131[0];
      if (v131[0])
      {
        v129 = v111;
        if (*((_DWORD *)v17 + 2) == 28)
        {
          if (*(_DWORD *)(a1 + 88) == 2)
            v114 = 1;
          else
            v114 = 3;
        }
        else
        {
          v114 = 1;
        }
        while (1)
        {
          ramrod_log_msg("%s\n", v104, v105, v106, v107, v108, v109, v110, v113);
          if (*((_DWORD *)v17 + 2) == 28)
            ramrod_log_msg("\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n", v115, v116, v117, v118, v119, v120, v121, v128);
          if (v114 < 2)
            break;
          --v114;
          sleep(1u);
        }
        v122 = v131[0];
        v123 = calloc(1uLL, 0x10uLL);
        if (v123)
        {
          v124 = v123;
          v123[1] = v122;
          if (*(_DWORD *)a1 == 1)
          {
            *v123 = 0;
            **(_QWORD **)(a1 + 480) = v123;
            *(_QWORD *)(a1 + 480) = v123;
          }
          else
          {
            pthread_mutex_lock((pthread_mutex_t *)(a1 + 232));
            v125 = *(_DWORD *)a1;
            *v124 = 0;
            **(_QWORD **)(a1 + 480) = v124;
            *(_QWORD *)(a1 + 480) = v124;
            if (v125 != 1)
              pthread_mutex_unlock((pthread_mutex_t *)(a1 + 232));
          }
          *(_BYTE *)(a1 + 208) = 1;
          v111 = v129;
        }
        else if (v122)
        {
          free(v122);
        }
      }
      if ((v111 & 1) == 0)
        free(v90);
      if (v92)
        free(v92);
LABEL_149:
      if (v80)
        free(v80);
      if (v88)
        free(v88);
      return v17;
  }
}

void sub_10009065C(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString **v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  const __CFString *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23[1024];

  if (*(_BYTE *)(a2 + 4))
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): first available indication when already collected\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_collect");
    return;
  }
  v10 = (const __CFString **)(a2 + 8);
  for (i = 1; i != 49; ++i)
  {
    sub_1000918D0((uint64_t)a1, *(_DWORD *)a2, i - 1, v10);
    v16 = *a1;
    if ((i - 40) <= 3 && v16 == 2)
    {
      if (*(_QWORD *)(a2 + 8 * i))
        goto LABEL_12;
    }
    else if ((i - 44) <= 3 && v16 == 2)
    {
      v17 = *(const __CFString **)(a2 + 8 * i);
      if (v17)
      {
        bzero(v23, 0x400uLL);
        sub_100090A3C(v17, v23);
        sub_100090A84((uint64_t)a1, (i - 5), v23, v18, v19, v20, v21, v22);
LABEL_12:
        sub_10009093C((uint64_t)a1, i - 1, 0, 0, v12, v13, v14, v15);
      }
    }
    ++v10;
  }
  *(_BYTE *)(a2 + 4) = 1;
}

uint64_t sub_1000907A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;

  v8 = sub_1000927DC(a1, a2, 5, a4, a5, a6, a7, a8);
  if (!v8)
    return 0;
  v9 = v8;
  v10 = 0;
  do
  {
    if (!strcmp(v9, off_1001815E8[v10]))
      v11 = v10;
    else
      v11 = 0;
    if ((_DWORD)v11)
      break;
  }
  while (v10++ < 0x21);
  free(v9);
  return v11;
}

void sub_100090818(uint64_t a1, uint64_t a2, char *a3, ...)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8[2];
  va_list va;

  va_start(va, a3);
  v8[0] = 0;
  va_copy((va_list)&v8[1], va);
  vasprintf(v8, a3, va);
  if (v8[0])
  {
    sub_10008FB94(a1, 30, 1, 0, 260, v8[0], 0, 0, 0);
    sub_1000921C0(a1, 8, *(unsigned int *)(a1 + 120), v8[0], v4, v5, v6, v7);
    if (v8[0])
    {
      free(v8[0]);
      v8[0] = 0;
    }
  }
  ++*(_DWORD *)(a1 + 120);
}

void sub_1000908B4(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v12;
  const char *v13;

  v8 = *(unsigned int *)(a1 + 96);
  v9 = (uint64_t)*(&off_1001816F8 + v8);
  if (*(_DWORD *)(v9 + 4 * a2))
  {
    *(_DWORD *)(a1 + 92) = v8;
    v12 = *(unsigned int *)(v9 + 4 * a2);
    *(_DWORD *)(a1 + 96) = v12;
    if (v12 > 0x21)
      v13 = "unknown";
    else
      v13 = off_1001815E8[v12];
    sub_100090A84(a1, 5, v13, a4, a5, a6, a7, a8);
    sub_100092058(a1, a2);
  }
}

void sub_10009093C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFString **v9;
  CFStringRef *v10;
  const __CFString *v11;
  char buffer[1024];

  if (a2 < 0x30)
  {
    v9 = &off_100180D30[4 * a2];
    if ((_DWORD)a3 || (*((_DWORD *)v9 + 6) - 5) < 0xFFFFFFFD)
    {
      bzero(buffer, 0x400uLL);
      if (*(_DWORD *)(a1 + 88) == 1)
        v10 = (CFStringRef *)v9;
      else
        v10 = (CFStringRef *)(v9 + 1);
      v11 = *v10;
      CFStringGetCString(*v10, buffer, 1024, 0x8000100u);
      sub_100091F98(v11);
    }
    else
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid delete of BOOT-CONTROL NVRAM ID %u\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_delete_var");
    }
  }
  else
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid delete of NVRAM ID %u\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_delete_var");
  }
}

char *sub_100090A3C(const __CFString *a1, char *a2)
{
  if (a1)
    CFStringGetCString(a1, a2, 1024, 0x8000100u);
  else
    bzero(a2, 0x400uLL);
  return a2;
}

void sub_100090A84(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  void **v11;
  int v12;

  if (*(_BYTE *)(a1 + 104))
  {
    if (a2 > 0x2F)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_adjust_id");
      v10 = 0;
      goto LABEL_7;
    }
    a2 = LODWORD(off_100180D30[4 * a2 + 2]);
  }
  if (a2 > 0x2F)
    goto LABEL_12;
  v10 = a2;
LABEL_7:
  if (((0xFFFC000000FEuLL >> v10) & 1) != 0)
  {
    v11 = *(void ***)(a1 + 16 * v10 + 1496);
    if (v11)
    {
      if (*v11)
      {
        free(*v11);
        *v11 = 0;
      }
      sub_10009268C(a1 + 1456, (char **)v11, a3, a4, a5, a6, a7, a8);
      *(_BYTE *)(a1 + 16 * v10 + 1492) = 1;
      return;
    }
  }
LABEL_12:
  v12 = *(_DWORD *)(a1 + 1476);
  if (!v12)
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on store [%s]\n", a2, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_store_lost");
    v12 = *(_DWORD *)(a1 + 1476);
  }
  *(_DWORD *)(a1 + 1476) = v12 + 1;
}

void sub_100090B9C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)a1 != 1)
      pthread_mutex_lock((pthread_mutex_t *)(a1 + 8));
  }
  else
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): checkpoint context not initialized\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_access_obtain");
  }
}

void sub_100090BEC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (*(_DWORD *)a1 != 1)
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 8));
  }
  else
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): checkpoint context not initialized\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_access_yield");
  }
}

char *sub_100090C3C(CFErrorRef err)
{
  __CFError *v1;
  char *v2;
  unsigned int v3;
  const __CFDictionary *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const __CFString *Value;
  char *v12;
  const __CFString *v13;
  char *v14;
  const __CFString *v15;
  char *v16;
  const __CFString *v17;
  size_t v19;
  char *v21;
  char v22;

  if (!err)
    return 0;
  v1 = err;
  v2 = 0;
  v3 = 0;
  do
  {
    v4 = CFErrorCopyUserInfo(v1);
    v2 = sub_100091698(v2, "[%d]", v5, v6, v7, v8, v9, v10, v3);
    if (!v4)
      break;
    v22 = 0;
    Value = (const __CFString *)CFDictionaryGetValue(v4, kCFErrorLocalizedRecoverySuggestionKey);
    v12 = sub_1000928D0(v2, (char)"RS", Value, &v22);
    v13 = (const __CFString *)CFDictionaryGetValue(v4, kCFErrorLocalizedDescriptionKey);
    v14 = sub_1000928D0(v12, (char)"LD", v13, &v22);
    v15 = (const __CFString *)CFDictionaryGetValue(v4, kCFErrorDescriptionKey);
    v16 = sub_1000928D0(v14, (char)"D", v15, &v22);
    v17 = (const __CFString *)CFDictionaryGetValue(v4, kCFErrorLocalizedFailureReasonKey);
    v2 = sub_1000928D0(v16, (char)"FR", v17, &v22);
    v1 = (__CFError *)CFDictionaryGetValue(v4, kCFErrorUnderlyingErrorKey);
    CFRelease(v4);
    if (!v1)
      break;
  }
  while (v3++ < 0xF);
  v19 = strlen(v2);
  if (v19 >= 0xF3)
  {
    v21 = 0;
    asprintf(&v21, "%s", &v2[v19 - 242]);
    if (v2)
      free(v2);
    return v21;
  }
  return v2;
}

uint64_t checkpoint_closure_context_get_step_desc(uint64_t result)
{
  if (result)
    return *(_QWORD *)result;
  return result;
}

uint64_t checkpoint_closure_context_should_retry(uint64_t result)
{
  int v1;

  if (result)
  {
    v1 = *(_DWORD *)(result + 40);
    *(_DWORD *)(result + 40) = v1 + 1;
    return !*(_BYTE *)(result + 11) && v1 < *(_DWORD *)(*(_QWORD *)result + 28);
  }
  return result;
}

uint64_t checkpoint_closure_context_handle_simulator_actions(uint64_t *a1, uint64_t a2, int *a3, const void **a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (qword_1001A81C0)
      return sub_100090EE4(qword_1001A81C0, *a1, a2, a3, a4, a6, a7, a8);
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): %s called too early, checkpoint_chassis_context == NULL\n", a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (char)"checkpoint_closure_context_handle_simulator_actions");
  }
  else
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): closure context is NULL\n", a2, (uint64_t)a3, (uint64_t)a4, a5, a6, a7, a8, (char)"checkpoint_closure_context_handle_simulator_actions");
  }
  return a2;
}

uint64_t sub_100090EE4(uint64_t a1, uint64_t a2, uint64_t a3, int *a4, const void **a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v10;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFStringRef v28;
  CFIndex Count;
  CFIndex v30;
  const __CFString *ValueAtIndex;
  CFIndex v32;
  CFIndex v33;
  const __CFString *v34;
  CFComparisonResult v35;
  _BOOL4 v36;
  int v37;
  _BOOL4 v38;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  int v47;
  uint64_t i;
  mach_port_t v49;
  int v50;
  int v51;
  char *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  char v92;
  pthread_mutexattr_t v93;
  pthread_mutex_t v94;

  v10 = a3;
  v13 = a3;
  sub_100090B9C(a1, a2, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  sub_1000929A0(a1, v14, v15, v16, v17, v18, v19, v20);
  if (!*(_DWORD *)(a1 + 2276) || !*(_QWORD *)(a1 + 2288))
    goto LABEL_14;
  v28 = CFStringCreateWithCString(kCFAllocatorDefault, *(const char **)(a2 + 8), 0x8000100u);
  Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 2288));
  if (Count < 1)
  {
    v36 = 0;
    if (!v28)
      goto LABEL_10;
    goto LABEL_9;
  }
  v30 = Count;
  ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 2288), 0);
  if (CFStringCompare(v28, ValueAtIndex, 0) == kCFCompareEqualTo)
  {
    v36 = 1;
    if (!v28)
      goto LABEL_10;
LABEL_9:
    CFRelease(v28);
    goto LABEL_10;
  }
  v32 = 1;
  do
  {
    v33 = v32;
    if (v30 == v32)
      break;
    v34 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 2288), v32);
    v35 = CFStringCompare(v28, v34, 0);
    v32 = v33 + 1;
  }
  while (v35);
  v36 = v33 < v30;
  if (v28)
    goto LABEL_9;
LABEL_10:
  if (!v36)
  {
LABEL_14:
    sub_100090BEC(a1, v21, v22, v23, v24, v25, v26, v27);
    v38 = 0;
    goto LABEL_15;
  }
  v37 = *(_DWORD *)(a1 + 2284);
  if (v37)
  {
    if (!v13)
      *(_DWORD *)(a1 + 2284) = v37 - 1;
    goto LABEL_14;
  }
  if (v13)
    sub_10008FB94(a1, *(_DWORD *)(a1 + 2276), 1, 0, *(_DWORD *)a2, *(const char **)(a2 + 8), *(_DWORD *)(a1 + 2280), *a4, *a5);
  sub_100090BEC(a1, v21, v22, v23, v24, v25, v26, v27);
  v38 = 0;
  v47 = 0;
  switch(*(_DWORD *)(a1 + 2276))
  {
    case 9:
      goto LABEL_80;
    case 0xA:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
      {
        *a4 = 181;
        ramrod_create_error_cf((CFErrorRef *)a5, CFSTR("CheckpointErrorDomain"), 181, 0, CFSTR("checkpoint simulator error"), v44, v45, v46, v92);
      }
      goto LABEL_76;
    case 0xB:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
        abort();
      goto LABEL_76;
    case 0xC:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
        exit(182);
      goto LABEL_76;
    case 0xD:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
        _exit(183);
      goto LABEL_76;
    case 0xE:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
      {
        for (i = 0; ; i += 4)
          ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): simulator signal executing after dereference of %p [%d]\n", v40, v41, v42, v43, v44, v45, v46, (char)"checkpoint_simulator_action");
      }
      goto LABEL_76;
    case 0xF:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
      {
        while (1)
          ;
      }
      goto LABEL_76;
    case 0x10:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
      {
        memset(&v94, 0, sizeof(v94));
        v93.__sig = 0;
        *(_QWORD *)v93.__opaque = 0;
        pthread_mutexattr_init(&v93);
        pthread_mutex_init(&v94, &v93);
        pthread_mutex_lock(&v94);
        pthread_mutex_lock(&v94);
      }
      goto LABEL_76;
    case 0x11:
      if (*(unsigned __int8 *)(a1 + 2275) != v10)
        goto LABEL_76;
      v49 = mach_host_self();
      v50 = 0;
      goto LABEL_45;
    case 0x12:
      if (*(unsigned __int8 *)(a1 + 2275) != v10)
        goto LABEL_76;
      v49 = mach_host_self();
      v50 = 4096;
LABEL_45:
      host_reboot(v49, v50);
LABEL_76:
      v38 = 0;
      goto LABEL_77;
    case 0x13:
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): simulator PAUSE not supported\n", v40, v41, v42, v43, v44, v45, v46, (char)"checkpoint_simulator_action");
      goto LABEL_76;
    case 0x14:
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): simulator RESUME not supported\n", v40, v41, v42, v43, v44, v45, v46, (char)"checkpoint_simulator_action");
      goto LABEL_76;
    case 0x15:
      if (*(unsigned __int8 *)(a1 + 2275) != v10)
        goto LABEL_76;
      __break(1u);
LABEL_50:
      v38 = v10 == 0;
LABEL_77:
      v47 = v13;
LABEL_78:
      if (!v13)
        goto LABEL_80;
      v13 = v47;
      if (!v47)
        goto LABEL_80;
      goto LABEL_15;
    case 0x16:
      goto LABEL_50;
    case 0x17:
      v38 = 0;
      v51 = *(unsigned __int8 *)(a1 + 2275);
      if (v51 == v10)
        v47 = 0;
      else
        v47 = v10;
      if (v13 || v51 != v10)
        goto LABEL_78;
      if (!*a4)
      {
        ramrod_log_msg("CHECKPOINT_SIMULATOR_NOTICE(%s): checkpoint simulator to ignore error on step %s, but step was successful\n", v40, v41, v42, v43, v44, v45, v46, (char)"checkpoint_simulator_action");
        goto LABEL_70;
      }
      ramrod_log_msg("CHECKPOINT_SIMULATOR_NOTICE(%s): checkpoint simulator ignoring error on step %s result: %d\n", v40, v41, v42, v43, v44, v45, v46, (char)"checkpoint_simulator_action");
      *a4 = 0;
      if (!*a5)
      {
LABEL_70:
        v38 = 0;
        v47 = 0;
        goto LABEL_80;
      }
      v52 = sub_100090C3C((CFErrorRef)*a5);
      if (v52)
      {
        v60 = v52;
        ramrod_log_msg("CHECKPOINT_SIMULATOR_NOTICE(%s): checkpoint simulator ignoring error on step %s error: %s\n", v53, v54, v55, v56, v57, v58, v59, (char)"checkpoint_simulator_action");
        free(v60);
      }
      CFRelease(*a5);
      v38 = 0;
      v47 = 0;
      *a5 = 0;
LABEL_80:
      v90 = *(_DWORD *)(a1 + 2280);
      if (v90)
      {
        v91 = v90 - 1;
        *(_DWORD *)(a1 + 2280) = v91;
        if (!v91)
          *(_DWORD *)(a1 + 2276) = 0;
      }
      v13 = v47;
LABEL_15:
      if (v10)
        return v13;
      else
        return v38;
    case 0x18:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
      {
        sub_100092BB8();
        ramrod_log_msg("CHECKPOINT_SIMULATOR_NOTICE(%s): returned from checkpoint jetsam attempt; continuing engine\n",
          v61,
          v62,
          v63,
          v64,
          v65,
          v66,
          v67,
          (char)"checkpoint_simulator_action");
      }
      goto LABEL_76;
    case 0x19:
      if (*(unsigned __int8 *)(a1 + 2275) == v10)
      {
        v68 = fork();
        if (v68 < 1)
        {
          if (!v68)
          {
            sub_100092BB8();
            exit(0);
          }
          __error();
          ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): error %d attempting to fork jetsam child\n", v76, v77, v78, v79, v80, v81, v82, (char)"checkpoint_simulator_action");
        }
        else
        {
          LODWORD(v94.__sig) = 0;
          if (waitpid(v68, (int *)&v94, 0) < 0)
          {
            __error();
            ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): error %d waiting for jetsam child\n", v83, v84, v85, v86, v87, v88, v89, (char)"checkpoint_simulator_action");
          }
          else if ((v94.__sig & 0x7F) == 0x7F)
          {
            ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): unexpected status of jetsam child: %d\n", v69, v70, v71, v72, v73, v74, v75, (char)"checkpoint_simulator_action");
          }
          else if ((v94.__sig & 0x7F) != 0)
          {
            ramrod_log_msg("CHECKPOINT_SIMULATOR_NOTICE(%s): jetsam child signalled: %d\n", v69, v70, v71, v72, v73, v74, v75, (char)"checkpoint_simulator_action");
          }
          else
          {
            ramrod_log_msg("CHECKPOINT_SIMULATOR_NOTICE(%s): jetsam child exited: %d\n", v69, v70, v71, v72, v73, v74, v75, (char)"checkpoint_simulator_action");
          }
        }
      }
      goto LABEL_76;
    default:
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): unknown simulator command ignored\n", v40, v41, v42, v43, v44, v45, v46, (char)"checkpoint_simulator_action");
      v38 = 0;
      v47 = 1;
      goto LABEL_78;
  }
}

uint64_t checkpoint_closure_context_handle_simulator_match_name(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a1)
  {
    if (qword_1001A81C0)
      return sub_1000914D8(qword_1001A81C0, *a1, a3, a4, a5, a6, a7, a8);
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): %s called too early, checkpoint_chassis_context == NULL\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_closure_context_handle_simulator_match_name");
  }
  else
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): closure context is NULL\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_closure_context_handle_simulator_match_name");
  }
  return 0;
}

uint64_t sub_1000914D8(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFIndex Count;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  CFIndex v33;
  const __CFString *ValueAtIndex;
  uint64_t v35;

  sub_100090B9C(a1, a2, a3, a4, a5, a6, a7, a8);
  sub_1000929A0(a1, v10, v11, v12, v13, v14, v15, v16);
  if (*(_DWORD *)(a1 + 2276))
  {
    Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 2288));
    v32 = CFStringCreateWithCString(kCFAllocatorDefault, *(const char **)(a2 + 8), 0x8000100u);
    if (Count < 1)
    {
LABEL_6:
      v35 = 0;
    }
    else
    {
      v33 = 0;
      while (1)
      {
        ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 2288), v33);
        if (CFStringCompare(v32, ValueAtIndex, 0) == kCFCompareEqualTo)
          break;
        if (Count == ++v33)
          goto LABEL_6;
      }
      v35 = 1;
    }
    sub_100090BEC(a1, v25, v26, v27, v28, v29, v30, v31);
    if (v32)
      CFRelease(v32);
  }
  else
  {
    sub_100090BEC(a1, v17, v18, v19, v20, v21, v22, v23);
    return 0;
  }
  return v35;
}

char *sub_1000915AC(char *a1, const char *a2, const char *a3, int *a4)
{
  char *v6;
  size_t v7;
  size_t v8;
  uint64_t v9;
  char *v11;
  char *v12;

  v11 = 0;
  v12 = 0;
  asprintf(&v12, "%s:%s", a2, a3);
  v6 = v12;
  if (!v12)
    return a1;
  if (!a1)
    return v12;
  v7 = strlen(a1);
  v8 = strlen(v12);
  v9 = 1;
  if (*a4 > 0)
    v9 = 2;
  if (v8 + v7 + v9 >= 0x81)
  {
    v11 = a1;
LABEL_13:
    free(v6);
    return v11;
  }
  if (*a4 <= 0)
    asprintf(&v11, "%s%s");
  else
    asprintf(&v11, "%s;%s");
  ++*a4;
  free(a1);
  v6 = v12;
  if (v12)
    goto LABEL_13;
  return v11;
}

char *sub_100091698(char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v11;
  char *v12[2];

  v11 = 0;
  v12[0] = 0;
  v12[1] = &a9;
  vasprintf(v12, a2, &a9);
  if (!v12[0])
    return a1;
  if (!a1)
    return v12[0];
  asprintf(&v11, "%s%s", a1, v12[0]);
  if (v11)
    free(a1);
  else
    v11 = a1;
  if (v12[0])
  {
    free(v12[0]);
    v12[0] = 0;
  }
  return v11;
}

char *sub_100091734(char *a1, int a2, const char *a3, int *a4)
{
  char *v8;

  v8 = 0;
  asprintf(&v8, "0x%08X", a2);
  if (v8)
  {
    a1 = sub_1000915AC(a1, v8, a3, a4);
    if (v8)
      free(v8);
  }
  return a1;
}

char *sub_1000917A8(char *a1, int a2, const char *a3, int *a4)
{
  char *v8;

  v8 = 0;
  asprintf(&v8, "%d", a2);
  if (v8)
  {
    a1 = sub_1000915AC(a1, v8, a3, a4);
    if (v8)
      free(v8);
  }
  return a1;
}

void sub_10009181C(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  BOOL v10;

  if (*(_DWORD *)a1 == 1)
  {
    if (a2)
    {
      if (*(_BYTE *)(a1 + 104))
      {
        v9 = 17;
        goto LABEL_14;
      }
      v10 = *(_BYTE *)(a1 + 101) == 0;
      v9 = 5;
    }
    else
    {
      v10 = *(_DWORD *)(a1 + 88) == 2;
      v9 = 1;
    }
  }
  else if (a2)
  {
    if (*(_BYTE *)(a1 + 104))
    {
      v9 = 19;
      goto LABEL_14;
    }
    v10 = *(_BYTE *)(a1 + 101) == 0;
    v9 = 7;
  }
  else
  {
    v10 = *(_DWORD *)(a1 + 88) == 2;
    v9 = 3;
  }
  if (!v10)
    ++v9;
LABEL_14:
  *(_DWORD *)(a1 + 96) = v9;
  sub_100090A84(a1, 5, off_1001815E8[v9], a4, a5, a6, a7, a8);
  sub_100092058(a1, 1);
}

void sub_1000918D0(uint64_t a1, unsigned int a2, unsigned int a3, const __CFString **a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFString *v15;
  __CFString **v16;
  const __CFString *v17;
  CFTypeID v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFString *v26;
  const char *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  const __CFString *v42;
  const char *v43;
  char *valuePtr;
  CFTypeRef cf;
  char v46[1024];
  char buffer[1024];

  cf = 0;
  bzero(buffer, 0x400uLL);
  bzero(v46, 0x400uLL);
  if (a3 < 0x30)
  {
    if (*(_DWORD *)(a1 + 88) == 1)
      v16 = &off_100180D30[4 * a3];
    else
      v16 = &off_100180D30[4 * a3 + 1];
    CFStringGetCString(*v16, buffer, 1024, 0x8000100u);
    v17 = (const __CFString *)ramrod_copy_NVRAM_variable();
    if (!v17)
      return;
    v15 = v17;
    v18 = CFGetTypeID(v17);
    if (v18 == CFStringGetTypeID())
    {
      CFStringGetCString(v15, v46, 1024, 0x8000100u);
      *a4 = v15;
      v15 = 0;
      goto LABEL_22;
    }
    if (v18 == CFNumberGetTypeID())
    {
      LODWORD(valuePtr) = 0;
      if (!CFNumberGetValue((CFNumberRef)v15, kCFNumberIntType, &valuePtr))
      {
        v27 = "CHECKPOINT_INTERNAL_ERROR(%s): number that is not an int %s\n";
        goto LABEL_29;
      }
      v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%d"), valuePtr);
      if (!v26)
      {
        v27 = "CHECKPOINT_INTERNAL_ERROR(%s): failed to get valid number for %s\n";
LABEL_29:
        ramrod_log_msg(v27, v19, v20, v21, v22, v23, v24, v25, (char)"checkpoint_nvram_collect_var");
        goto LABEL_3;
      }
    }
    else
    {
      if (v18 != CFDataGetTypeID())
      {
        ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): unsupported nvram variable type for %s\n", v28, v29, v30, v31, v32, v33, v34, (char)"checkpoint_nvram_collect_var");
        goto LABEL_3;
      }
      v26 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, (CFDataRef)v15, 0x8000100u);
      if (!v26)
      {
        ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): failed to get string from data %s\n", v35, v36, v37, v38, v39, v40, v41, (char)"checkpoint_nvram_collect_var");
        goto LABEL_3;
      }
    }
    v42 = v26;
    CFStringGetCString(v26, v46, 1024, 0x8000100u);
    *a4 = v42;
LABEL_22:
    valuePtr = 0;
    if (a2 > 2)
      v43 = "Unknown";
    else
      v43 = off_100181330[a2];
    asprintf(&valuePtr, "%s NVRAM variable: %s=%s", v43, buffer, v46);
    if (valuePtr)
    {
      sub_10008FB94(a1, 2, 1, 0, 257, valuePtr, 0, 0, 0);
      free(valuePtr);
    }
    goto LABEL_3;
  }
  ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable id=%u\n", v8, v9, v10, v11, v12, v13, v14, (char)"checkpoint_nvram_collect_var");
  v15 = 0;
LABEL_3:
  if (cf)
    CFRelease(cf);
  if (v15)
    CFRelease(v15);
}

uint64_t sub_100091BB4(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v10;
  unsigned __int8 v11;
  char v12;
  _DWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v36[1024];
  char buffer[1024];
  _OWORD v38[3];

  memset(v38, 0, sizeof(v38));
  v10 = *a3;
  if (*a3)
  {
    v11 = 0;
    v12 = 0;
    v13 = a3 + 2;
    do
    {
      v14 = v10;
      *((_BYTE *)v38 + v10) = 1;
      if (*(_QWORD *)(a2 + 8 * v10 + 8))
      {
        if (*((_BYTE *)v13 - 3))
          v11 = 1;
        if (*((_BYTE *)v13 - 2))
          v12 = 1;
        if (*((_BYTE *)v13 - 1))
        {
          v15 = v10 <= 0x2F && (LODWORD(off_100180D30[4 * v10 + 3]) - 2) < 3;
          sub_10009093C(a1, v10, v15, 1, a5, a6, a7, a8);
        }
      }
      else if (*((_BYTE *)v13 - 4))
      {
        bzero(buffer, 0x400uLL);
        sub_100091E3C(a1, v14, buffer, v16, v17, v18, v19, v20);
        sub_100090818(a1, v21, "[check_collection]%s(does_not_exist)", buffer);
      }
      v22 = *v13;
      v13 += 2;
      v10 = v22;
    }
    while (v22);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  v23 = 0;
  v24 = a2 + 16;
  do
  {
    if (!*((_BYTE *)v38 + v23 + 1) && *(_QWORD *)(v24 + 8 * v23))
    {
      bzero(buffer, 0x400uLL);
      bzero(v36, 0x400uLL);
      sub_100091E3C(a1, (v23 + 1), buffer, v25, v26, v27, v28, v29);
      sub_100090A3C(*(const __CFString **)(v24 + 8 * v23), v36);
      sub_100090818(a1, v30, "[check_collection]%s=%s(exists_when_not_expected)", buffer, v36);
      sub_10009093C(a1, (v23 + 1), 0, 1, v31, v32, v33, v34);
    }
    ++v23;
  }
  while (v23 != 47);
  if (v12)
    sub_10008FB94(a1, 2, 1, 0, 262, "Old restore failure indication(s)", 0, 0, 0);
  return v11;
}

void sub_100091DE8(uint64_t a1, uint64_t a2)
{
  const __CFString *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v3 = *(const __CFString **)(a2 + 24);
  if (v3)
  {
    if (CFStringCompare(v3, CFSTR("upgrade"), 0) == kCFCompareEqualTo)
      sub_10009093C(a1, 2, 1, 0, v4, v5, v6, v7);
  }
}

char *sub_100091E3C(uint64_t a1, uint64_t a2, char *buffer, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFString **v10;

  if (a2 >= 0x30)
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, (uint64_t)buffer, a4, a5, a6, a7, a8, (char)"checkpoint_get_nvram_name");
    LODWORD(a2) = 0;
  }
  if (*(_DWORD *)(a1 + 88) == 1)
    v10 = &off_100180D30[4 * a2];
  else
    v10 = &off_100180D30[4 * a2 + 1];
  CFStringGetCString(*v10, buffer, 1024, 0x8000100u);
  return buffer;
}

void sub_100091EC4(_BYTE *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v11;
  char v12[1024];

  if (a1[100])
  {
    a1[104] = 1;
    a1[101] = 1;
    ramrod_log_msg("AP nonce will not be touched\n", (uint64_t)a2, a3, a4, a5, a6, a7, a8, a9);
  }
  else
  {
    bzero(v12, 0x400uLL);
    sub_100090A3C(a2, v12);
    sub_100090818((uint64_t)a1, v11, "[reboot_retry_chassis]outcome=%s(pre_existing_reboot_retry_disabled)", v12);
  }
}

void sub_100091F98(const __CFString *a1)
{
  char buffer[1024];

  bzero(buffer, 0x400uLL);
  CFStringGetCString(a1, buffer, 1024, 0x8000100u);
  ramrod_delete_NVRAM_variable();
}

void sub_100092058(uint64_t a1, int a2)
{
  uint64_t v3;
  const char *v4;
  uint64_t v5;
  const char *v6;
  char *v7;

  v7 = 0;
  v3 = *(unsigned int *)(a1 + 92);
  if (v3 > 0x21)
    v4 = "unknown";
  else
    v4 = off_1001815E8[v3];
  v5 = *(unsigned int *)(a1 + 96);
  if (v5 > 0x21)
    v6 = "unknown";
  else
    v6 = off_1001815E8[v5];
  asprintf(&v7, "%s (%s) -> (%s)", off_100181348[a2], v4, v6);
  if (v7)
  {
    sub_10008FB94(a1, 29, 1, 0, 260, v7, 0, 0, 0);
    if (v7)
      free(v7);
  }
}

uint64_t sub_10009211C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;

  if (*(_BYTE *)(a1 + 104))
  {
    if (a2 > 0x2F)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_adjust_id");
      LODWORD(a2) = 0;
      goto LABEL_7;
    }
    LODWORD(a2) = off_100180D30[4 * a2 + 2];
  }
  if (a2 < 0x30)
  {
LABEL_7:
    v10 = a2;
    v9 = HIDWORD(off_100180D30[4 * a2 + 2]);
    return ((uint64_t (*)(uint64_t, _QWORD))checkpoint_nvram_encoder[v9])(a1, *(_QWORD *)(a1 + 16 * v10 + 1496));
  }
  v9 = 0;
  v10 = a2;
  return ((uint64_t (*)(uint64_t, _QWORD))checkpoint_nvram_encoder[v9])(a1, *(_QWORD *)(a1 + 16 * v10 + 1496));
}

void sub_1000921C0(uint64_t a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  int v14;
  int v15;
  BOOL v16;
  int v17;

  v9 = a3;
  if (*(_BYTE *)(a1 + 104))
  {
    if (a2 > 0x2F)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"checkpoint_nvram_adjust_id");
      v11 = 0;
      goto LABEL_7;
    }
    a2 = LODWORD(off_100180D30[4 * a2 + 2]);
  }
  if (a2 > 0x2F)
    goto LABEL_18;
  v11 = a2;
LABEL_7:
  if (((0x20420400uLL >> v11) & 1) != 0)
  {
    a2 = *(_QWORD *)(a1 + 16 * v11 + 1496);
    if (a2)
      goto LABEL_21;
  }
  if (((0x1001100uLL >> v11) & 1) != 0)
  {
    v12 = *(_QWORD *)(a1 + 16 * v11 + 1496);
    if (v12)
    {
      v13 = 0;
      a2 = v12 - 16;
      do
      {
        v15 = *(_DWORD *)(a2 + 16);
        a2 += 16;
        v14 = v15;
        if (v15)
          v16 = v13 >= 7;
        else
          v16 = 1;
        ++v13;
      }
      while (!v16);
      if (!v14)
      {
LABEL_21:
        *(_DWORD *)a2 = v9;
        sub_10009268C(a1 + 1456, (char **)(a2 + 8), a4, (uint64_t)a4, a5, a6, a7, a8);
        *(_BYTE *)(a1 + 16 * v11 + 1492) = 1;
        return;
      }
    }
  }
LABEL_18:
  v17 = *(_DWORD *)(a1 + 1476);
  if (!v17)
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on store [%s]\n", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"checkpoint_nvram_store_lost");
    v17 = *(_DWORD *)(a1 + 1476);
  }
  *(_DWORD *)(a1 + 1476) = v17 + 1;
}

void sub_1000922FC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;

  if (*(_BYTE *)(a1 + 104))
  {
    if (a2 > 0x2F)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_adjust_id");
      v10 = 0;
      goto LABEL_7;
    }
    a2 = LODWORD(off_100180D30[4 * a2 + 2]);
  }
  if (a2 > 0x2F)
    goto LABEL_10;
  v10 = a2;
LABEL_7:
  if (((0x3C03C0000uLL >> v10) & 1) != 0)
  {
    v11 = a1 + 16 * v10;
    v12 = *(uint64_t **)(v11 + 1496);
    if (v12)
    {
      *v12 = a3;
      *(_BYTE *)(v11 + 1492) = 1;
      return;
    }
  }
LABEL_10:
  v13 = *(_DWORD *)(a1 + 1476);
  if (!v13)
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on store [%s]\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_store_lost");
    v13 = *(_DWORD *)(a1 + 1476);
  }
  *(_DWORD *)(a1 + 1476) = v13 + 1;
}

void sub_1000923E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  int v9;
  int v10;
  uint64_t v12;
  int v13;
  _DWORD *v14;
  unint64_t v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  int v19;
  BOOL v20;
  BOOL v21;

  v8 = a5;
  v9 = a4;
  v10 = a3;
  if (*(_BYTE *)(a1 + 104))
  {
    if (a2 > 0x2F)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_adjust_id");
      v12 = 0;
      goto LABEL_7;
    }
    a2 = LODWORD(off_100180D30[4 * a2 + 2]);
  }
  if (a2 > 0x2F)
    goto LABEL_8;
  v12 = a2;
LABEL_7:
  if (((0xA00A000uLL >> v12) & 1) != 0 && v9 <= 7)
  {
    v14 = *(_DWORD **)(a1 + 16 * v12 + 1496);
    if (v14)
    {
      v15 = 0;
      v16 = 0;
      v17 = *(_DWORD **)(a1 + 16 * v12 + 1496);
      do
      {
        v19 = *v17;
        v17 += 11;
        v18 = v19;
        if (v19)
          v20 = 1;
        else
          v20 = v10 == 0;
        if (!v20)
          v16 = v14;
        v21 = v18 == v10 || v15++ >= 7;
        v14 = v17;
      }
      while (!v21);
      if (v18 == v10)
        v16 = v17 - 11;
      if (v16)
      {
        *v16 = v10;
        v16[v9 + 1] = v8;
        *((_BYTE *)v16 + v9 + 36) = 1;
        *(_BYTE *)(a1 + 16 * v12 + 1492) = 1;
        return;
      }
    }
  }
LABEL_8:
  v13 = *(_DWORD *)(a1 + 1476);
  if (!v13)
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on store [%s]\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_store_lost");
    v13 = *(_DWORD *)(a1 + 1476);
  }
  *(_DWORD *)(a1 + 1476) = v13 + 1;
}

void sub_100092530(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  int v10;
  uint64_t v12;
  int v13;
  _DWORD *v14;
  unint64_t v15;
  _DWORD *v16;
  _DWORD *v17;
  int v18;
  int v19;
  BOOL v20;
  BOOL v21;

  v9 = a4;
  v10 = a3;
  if (*(_BYTE *)(a1 + 104))
  {
    if (a2 > 0x2F)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (char)"checkpoint_nvram_adjust_id");
      v12 = 0;
      goto LABEL_7;
    }
    a2 = LODWORD(off_100180D30[4 * a2 + 2]);
  }
  if (a2 > 0x2F)
    goto LABEL_8;
  v12 = a2;
LABEL_7:
  if (((0x14014000uLL >> v12) & 1) != 0 && v9 <= 7)
  {
    v14 = *(_DWORD **)(a1 + 16 * v12 + 1496);
    if (v14)
    {
      v15 = 0;
      v16 = 0;
      v17 = *(_DWORD **)(a1 + 16 * v12 + 1496);
      do
      {
        v19 = *v17;
        v17 += 18;
        v18 = v19;
        if (v19)
          v20 = 1;
        else
          v20 = v10 == 0;
        if (!v20)
          v16 = v14;
        v21 = v18 == v10 || v15++ >= 7;
        v14 = v17;
      }
      while (!v21);
      if (v18 == v10)
        v16 = v17 - 18;
      if (v16)
      {
        *v16 = v10;
        sub_10009268C(a1 + 1456, (char **)&v16[2 * v9 + 2], a5, a4, (uint64_t)a5, a6, a7, a8);
        *(_BYTE *)(a1 + 16 * v12 + 1492) = 1;
        return;
      }
    }
  }
LABEL_8:
  v13 = *(_DWORD *)(a1 + 1476);
  if (!v13)
  {
    ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on store [%s]\n", a2, a3, a4, (uint64_t)a5, a6, a7, a8, (char)"checkpoint_nvram_store_lost");
    v13 = *(_DWORD *)(a1 + 1476);
  }
  *(_DWORD *)(a1 + 1476) = v13 + 1;
}

void sub_10009268C(uint64_t a1, char **a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v11;

  if (a2)
  {
    if (*a2)
    {
      free(*a2);
      *a2 = 0;
    }
    if (a3)
      asprintf(a2, "%s", a3);
  }
  else
  {
    v11 = *(_DWORD *)(a1 + 20);
    if (!v11)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): {%s} tracking information lost on store [%s]\n", 0, (uint64_t)a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_store_lost");
      v11 = *(_DWORD *)(a1 + 20);
    }
    *(_DWORD *)(a1 + 20) = v11 + 1;
  }
}

char *sub_100092730(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *result;
  const __CFString *v9;
  char *v10;
  char buffer[1024];

  result = (char *)sub_10009211C(a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = 0;
  if (result)
  {
    v9 = (const __CFString *)result;
    bzero(buffer, 0x400uLL);
    CFStringGetCString(v9, buffer, 1024, 0x8000100u);
    asprintf(&v10, "%s", buffer);
    CFRelease(v9);
    return v10;
  }
  return result;
}

char *sub_1000927DC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  char *v11;
  char buffer[1024];

  v11 = 0;
  if (*(_BYTE *)(a1 + 104))
  {
    if (a3 > 0x2F)
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): invalid variable ID=%d\n", a2, a3, a4, a5, a6, a7, a8, (char)"checkpoint_nvram_adjust_id");
      LODWORD(a3) = 0;
    }
    else
    {
      LODWORD(a3) = off_100180D30[4 * a3 + 2];
    }
  }
  v9 = *(const __CFString **)(a2 + 8 * a3 + 8);
  if (!v9)
    return 0;
  bzero(buffer, 0x400uLL);
  CFStringGetCString(v9, buffer, 1024, 0x8000100u);
  asprintf(&v11, "%s", buffer);
  return v11;
}

char *sub_1000928D0(char *a1, char a2, const __CFString *a3, _BYTE *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  char buffer[1024];

  if (a3)
  {
    bzero(buffer, 0x400uLL);
    CFStringGetCString(a3, buffer, 1024, 0x8000100u);
    if (*a4)
      v14 = "|%s(%s)";
    else
      v14 = "%s(%s)";
    a1 = sub_100091698(a1, v14, v8, v9, v10, v11, v12, v13, a2);
    *a4 = 1;
  }
  return a1;
}

void sub_1000929A0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v9;
  size_t v10;
  size_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *v20;
  const __CFArray *ArrayBySeparatingStrings;
  CFIndex Count;
  CFIndex v23;
  CFIndex i;
  const __CFString *ValueAtIndex;
  const __CFString *v26;
  const __CFString *v27;
  char v28[1024];
  char __s[5];
  _BYTE v30[3];

  if (!*(_BYTE *)(a1 + 2274) && sub_10008F2A0(a1, 0, 0, a4, a5, a6, a7, a8))
  {
    v9 = *(const __CFString **)(a1 + 992);
    if (!v9)
      goto LABEL_23;
    bzero(&v28[4], 0x3FCuLL);
    *(_DWORD *)(a1 + 2276) = 0;
    *(_QWORD *)(a1 + 2288) = 0;
    bzero(v30, 0x3FBuLL);
    strcpy(__s, "SIM_");
    v10 = strlen(__s);
    CFStringGetCString(v9, &__s[v10], 1024 - v10, 0x8000100u);
    strcpy(v28, "SIM");
    v11 = strlen(v28);
    CFStringGetCString(*(CFStringRef *)(a1 + 992), &v28[v11], 1024 - v11, 0x8000100u);
    v12 = 0;
    while (1)
    {
      v13 = off_1001813B8[v12];
      if (!strncasecmp(__s, v13, 0x400uLL))
      {
        *(_DWORD *)(a1 + 2276) = v12;
        goto LABEL_11;
      }
      if (!strncasecmp(v28, v13, 0x400uLL))
        break;
      if (++v12 == 34)
      {
        LODWORD(v12) = *(_DWORD *)(a1 + 2276);
        goto LABEL_11;
      }
    }
    *(_DWORD *)(a1 + 2276) = v12;
    *(_BYTE *)(a1 + 2275) = 1;
LABEL_11:
    if (!(_DWORD)v12)
      goto LABEL_23;
    v20 = *(const __CFString **)(a1 + 1016);
    if (v20)
    {
      ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, v20, CFSTR(","));
      *(_QWORD *)(a1 + 2288) = ArrayBySeparatingStrings;
      if (ArrayBySeparatingStrings)
      {
        Count = CFArrayGetCount(ArrayBySeparatingStrings);
        if (Count >= 1)
        {
          v23 = Count;
          for (i = 0; i != v23; ++i)
          {
            ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 2288), i);
            CFStringGetCStringPtr(ValueAtIndex, 0x8000100u);
          }
        }
        v26 = *(const __CFString **)(a1 + 1000);
        if (v26)
          *(_DWORD *)(a1 + 2280) = CFStringGetIntValue(v26);
        v27 = *(const __CFString **)(a1 + 1008);
        if (v27)
          *(_DWORD *)(a1 + 2284) = CFStringGetIntValue(v27);
        goto LABEL_23;
      }
    }
    else
    {
      ramrod_log_msg("CHECKPOINT_INTERNAL_ERROR(%s): simulator command without stepName\n", 0, v14, v15, v16, v17, v18, v19, (char)"checkpoint_simulator_configure");
    }
    *(_DWORD *)(a1 + 2276) = 0;
LABEL_23:
    *(_BYTE *)(a1 + 2274) = 1;
  }
}

_QWORD *sub_100092BB8()
{
  void **v0;
  size_t v1;
  void *v2;
  _QWORD *result;
  _QWORD *v4;
  void *v5;

  v5 = 0;
  v0 = &v5;
  v1 = 0x100000;
  do
  {
    v2 = malloc(v1);
    *v0 = v2;
    if (v2)
    {
      bzero(v2, v1);
      v0 = (void **)*v0;
    }
    else
    {
      v1 >>= 1;
    }
  }
  while ((int)v1 > 4095);
  result = v5;
  if (v5)
  {
    do
    {
      v4 = (_QWORD *)*result;
      free(result);
      result = v4;
    }
    while (v4);
  }
  return result;
}

uint64_t ramrod_hardware_partition_supports_bics()
{
  return sub_100092C34((uint64_t)CFSTR("SupportsBurninMitigation"));
}

uint64_t sub_100092C34(uint64_t a1)
{
  const __CFBoolean *v1;
  const __CFBoolean *v2;
  CFTypeID v3;
  uint64_t Value;

  v1 = (const __CFBoolean *)MGCopyAnswer(a1, 0);
  if (!v1)
    return 0;
  v2 = v1;
  v3 = CFGetTypeID(v1);
  if (v3 == CFBooleanGetTypeID())
    Value = CFBooleanGetValue(v2);
  else
    Value = 0;
  CFRelease(v2);
  return Value;
}

uint64_t ramrod_device_has_baseband()
{
  return 0;
}

const __CFDictionary *ramrod_device_has_stockholm()
{
  const __CFDictionary *result;

  result = IOServiceMatching("AppleStockholmControl");
  if (result)
  {
    result = (const __CFDictionary *)IOServiceGetMatchingService(kIOMasterPortDefault, result);
    if ((_DWORD)result)
    {
      IOObjectRelease((io_object_t)result);
      return (const __CFDictionary *)1;
    }
  }
  return result;
}

uint64_t _ramrod_device_has_sandcat()
{
  if (qword_1001A8208 != -1)
    dispatch_once(&qword_1001A8208, &stru_100181808);
  return byte_1001A8200;
}

void sub_100092D20(id a1)
{
  io_registry_entry_t v1;

  v1 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/arm-io/sep/iop-sep-nub/Sandcat");
  if (v1)
  {
    byte_1001A8200 = 1;
    IOObjectRelease(v1);
  }
}

uint64_t ramrod_connect_to_ioservice(const char *a1, io_service_t *a2, io_connect_t *a3)
{
  char v5;
  const __CFDictionary *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  io_service_t MatchingService;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  io_service_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char v31;
  io_connect_t connect;

  v5 = (char)a1;
  v6 = IOServiceMatching(a1);
  if (v6)
  {
    MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
    if (MatchingService)
    {
      v22 = MatchingService;
      connect = 0;
      if (!IOServiceOpen(MatchingService, mach_task_self_, 0, &connect))
      {
        *a2 = v22;
        *a3 = connect;
        return 1;
      }
      ramrod_log_msg("IOServiceOpen failed for class '%s'\n", v23, v24, v25, v26, v27, v28, v29, v5);
    }
    else
    {
      ramrod_log_msg("IOServiceGetMatchingService failed\n", v15, v16, v17, v18, v19, v20, v21, v31);
    }
  }
  else
  {
    ramrod_log_msg("IOServiceMatching failed for %s\n", v7, v8, v9, v10, v11, v12, v13, v5);
  }
  return 0;
}

uint64_t ramrod_generate_apslot_copy_nonce(_DWORD *a1, CFDataRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  mach_port_t v11;
  mach_error_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  int v21;
  CFDataRef v22;
  uint64_t v23;
  mach_error_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char outputStruct;
  size_t v34;
  size_t v35;
  mach_port_t connection[2];
  UInt8 bytes[16];
  __int128 v38;

  v35 = 4;
  *(_QWORD *)connection = 0;
  v34 = 32;
  *(_OWORD *)bytes = 0u;
  v38 = 0u;
  if (!ramrod_connect_to_ioservice("AppleMobileApNonce", &connection[1], connection))
  {
    ramrod_log_msg("Failed to connect to AppleMobileApNonce to generate AP nonce slot.\n", v4, v5, v6, v7, v8, v9, v10, outputStruct);
    goto LABEL_5;
  }
  v11 = connection[0];
  v12 = IOConnectCallMethod(connection[0], 0xC8u, 0, 0, 0, 0, 0, 0, bytes, &v34);
  if (v12)
  {
    mach_error_string(v12);
    ramrod_log_msg("IOConnectCallMethod(%s,%u) failed: %s\n", v13, v14, v15, v16, v17, v18, v19, (char)"AppleMobileApNonce");
LABEL_5:
    v20 = 0;
    goto LABEL_6;
  }
  v20 = (int *)calloc(1uLL, 4uLL);
  v25 = IOConnectCallMethod(v11, 0xCBu, 0, 0, 0, 0, 0, 0, v20, &v35);
  if (v25)
  {
    mach_error_string(v25);
    ramrod_log_msg("IOConnectCallMethod(%s,%u) failed: %s\n", v26, v27, v28, v29, v30, v31, v32, (char)"AppleMobileApNonce");
LABEL_6:
    v21 = 0;
    v22 = 0;
    v23 = 0;
    if (!a1)
      goto LABEL_8;
    goto LABEL_7;
  }
  v21 = *v20;
  v22 = CFDataCreate(kCFAllocatorDefault, bytes, 32);
  v23 = 1;
  if (a1)
LABEL_7:
    *a1 = v21;
LABEL_8:
  if (a2)
  {
    *a2 = v22;
  }
  else if (v22)
  {
    CFRelease(v22);
  }
  if (v20)
    free(v20);
  if (connection[1])
    IOObjectRelease(connection[1]);
  if (connection[0])
    IOObjectRelease(connection[0]);
  return v23;
}

uint64_t ramrod_generate_sepslot_copy_nonce(_DWORD *a1, CFDataRef *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  io_object_t v11;
  mach_error_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  CFDataRef v22;
  char outputStruct;
  uint32_t outputCnt;
  CFIndex length;
  mach_port_t connection[2];
  uint64_t output;
  UInt8 bytes[8];
  uint64_t v30;
  int v31;

  *(_QWORD *)bytes = 0;
  v30 = 0;
  v31 = 0;
  length = 20;
  *(_QWORD *)connection = 0;
  output = 0;
  outputCnt = 1;
  if (ramrod_connect_to_ioservice("AppleSEPManager", &connection[1], connection))
  {
    v11 = connection[0];
    v12 = IOConnectCallMethod(connection[0], 0x53u, 0, 0, 0, 0, &output, &outputCnt, bytes, (size_t *)&length);
    if (v12)
    {
      mach_error_string(v12);
      ramrod_log_msg("IOConnectCallMethod(%s,%u) failed: %s\n", v13, v14, v15, v16, v17, v18, v19, (char)"AppleSEPManager");
      v20 = 0;
      v21 = 0;
      v22 = 0;
    }
    else
    {
      v21 = output;
      v22 = CFDataCreate(kCFAllocatorDefault, bytes, length);
      v20 = 1;
    }
    if (connection[1])
      IOObjectRelease(connection[1]);
    if (v11)
      IOObjectRelease(v11);
    if (a1)
      *a1 = v21;
    if (a2)
    {
      *a2 = v22;
    }
    else if (v22)
    {
      CFRelease(v22);
    }
  }
  else
  {
    ramrod_log_msg("Failed to connect to AppleSEPManager to generate sep nonce.\n", v4, v5, v6, v7, v8, v9, v10, outputStruct);
    return 0;
  }
  return v20;
}

uint64_t ramrod_should_do_legacy_restored_behaviors()
{
  return 0;
}

uint64_t ramrod_should_do_legacy_restored_internal_behaviors()
{
  return 0;
}

void ramrod_create_error_cf(CFErrorRef *a1, const __CFString *a2, CFIndex a3, const void *a4, const __CFString *a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  sub_10009319C(a1, a2, a3, a4, a5, &a9);
}

void sub_10009319C(CFErrorRef *a1, const __CFString *a2, CFIndex a3, const void *a4, const __CFString *a5, va_list a6)
{
  CFMutableDictionaryRef Mutable;
  __CFDictionary *v13;
  CFStringRef v14;
  CFStringRef v15;

  if (a1)
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      v13 = Mutable;
      v14 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, a5, a6);
      if (v14)
      {
        v15 = v14;
        CFDictionaryAddValue(v13, kCFErrorDescriptionKey, v14);
        CFRelease(v15);
      }
      if (a4)
        CFDictionaryAddValue(v13, kCFErrorUnderlyingErrorKey, a4);
      *a1 = CFErrorCreate(kCFAllocatorDefault, a2, a3, v13);
      CFRelease(v13);
    }
  }
}

const __CFDictionary *ramrod_should_update_stockholm(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!a1)
    return ramrod_device_has_stockholm();
  ramrod_log_msg("Skipping checking stockholm for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t ramrod_copy_updater_functions(void *a1, const char *a2, __CFDictionary *(***a3)(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4), CFErrorRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFDictionary *(**v12)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  __CFDictionary *(**v16)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *);
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  __CFDictionary *(*v21)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *);
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __CFDictionary *(*v26)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *);
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  __CFDictionary *(*v31)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *);

  if (!a2 || !a3)
  {
    ramrod_create_error_cf(a4, CFSTR("RamrodErrorDomain"), 3, 0, CFSTR("%s: invalid parameters"), a6, a7, a8, (char)"ramrod_copy_updater_functions");
    return 0;
  }
  *a3 = 0;
  v12 = (__CFDictionary *(**)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))malloc(0x18uLL);
  if (!v12)
  {
    ramrod_create_error_cf(a4, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: failed to allocate tmp update_functions struct"), v13, v14, v15, (char)"ramrod_copy_updater_functions");
    return 0;
  }
  v16 = v12;
  *v12 = 0;
  v12[1] = 0;
  v12[2] = 0;
  if (!strcmp(a2, "Canary"))
  {
    *v16 = sub_10009355C;
    v16[1] = (__CFDictionary *(*)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))sub_10009366C;
    v16[2] = (__CFDictionary *(*)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))sub_100093690;
  }
  else
  {
    v21 = (__CFDictionary *(*)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))sub_10009343C(a1, (uint64_t)a2, (uint64_t)"UpdaterCreate", a4, v17, v18, v19, v20);
    *v16 = v21;
    if (!v21
      || (v26 = (__CFDictionary *(*)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))sub_10009343C(a1, (uint64_t)a2, (uint64_t)"UpdaterIsDone", a4, v22, v23, v24, v25),
          (v16[1] = v26) == 0)
      || (v31 = (__CFDictionary *(*)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))sub_10009343C(a1, (uint64_t)a2, (uint64_t)"UpdaterExecCommand", a4, v27, v28, v29, v30),
          (v16[2] = v31) == 0))
    {
      free(v16);
      return 0;
    }
  }
  *a3 = v16;
  return 1;
}

void *sub_10009343C(void *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char __symbol[16];
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  if (a1 && a3)
  {
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    v17 = 0u;
    v18 = 0u;
    *(_OWORD *)__symbol = 0u;
    v16 = 0u;
    __strlcpy_chk(__symbol, a2, 128, 128);
    __strlcat_chk(__symbol, a3, 128, 128);
    result = dlsym(a1, __symbol);
    if (result)
      return result;
    dlerror();
    ramrod_create_error_cf(a4, CFSTR("RamrodErrorDomain"), 1012, 0, CFSTR("%s: unable to find %s: %s"), v12, v13, v14, (char)"load_function");
  }
  else
  {
    ramrod_create_error_cf(a4, CFSTR("RamrodErrorDomain"), 3, 0, CFSTR("%s: invalid parameters"), a6, a7, a8, (char)"load_function");
  }
  return 0;
}

__CFDictionary *sub_10009355C(const __CFDictionary *a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __CFDictionary *Mutable;
  const void *Value;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    if (a1)
    {
      Value = CFDictionaryGetValue(a1, CFSTR("Options"));
      if (Value)
        CFDictionarySetValue(Mutable, CFSTR("Options"), Value);
    }
    CFDictionarySetValue(Mutable, CFSTR("IsDone"), kCFBooleanFalse);
    CFDictionarySetValue(Mutable, CFSTR("Loop0"), kCFBooleanTrue);
    CFDictionarySetValue(Mutable, CFSTR("QueryLoop0"), kCFBooleanTrue);
  }
  else
  {
    ramrod_create_error_cf(a4, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: state allocation failed"), v6, v7, v8, (char)"_CanaryUpdaterCreate");
  }
  return Mutable;
}

const __CFDictionary *sub_10009366C(const __CFDictionary *result)
{
  const __CFBoolean *Value;

  if (result)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(result, CFSTR("IsDone"));
    return (const __CFDictionary *)CFBooleanGetValue(Value);
  }
  return result;
}

uint64_t sub_100093690(const __CFDictionary *a1, CFStringRef theString1, uint64_t a3, CFMutableDictionaryRef *a4, CFErrorRef *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFString *v12;
  CFMutableDictionaryRef Mutable;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const void *v18;
  __CFDictionary *v19;
  const void *v20;
  const __CFString *v21;
  __CFDictionary *v22;
  CFBooleanRef v23;
  const void *Value;

  if (!a1)
  {
    v12 = CFSTR("%s: state is NULL");
    goto LABEL_7;
  }
  if (!theString1)
  {
    v12 = CFSTR("%s: command is NULL");
    goto LABEL_7;
  }
  if (!a4)
  {
    v12 = CFSTR("%s: output is NULL");
    goto LABEL_7;
  }
  if (CFStringCompare(theString1, CFSTR("queryInfo"), 0))
  {
    if (CFStringCompare(theString1, CFSTR("performNextStage"), 0))
    {
      v12 = CFSTR("%s: %@ invalid command");
LABEL_7:
      ramrod_create_error_cf(a5, CFSTR("RamrodErrorDomain"), 3, 0, v12, a6, a7, a8, (char)"_CanaryUpdaterExecCmd");
      return 0;
    }
    Value = CFDictionaryGetValue(a1, CFSTR("Loop0"));
    AMSupportLogInternal(6, "_CanaryUpdaterExecCmd", "PerformNextStage Running, Loop0=%@.", Value);
    if (CFDictionaryGetValue(a1, CFSTR("Loop0")) == kCFBooleanFalse)
      CFDictionarySetValue(a1, CFSTR("IsDone"), kCFBooleanTrue);
    v21 = CFSTR("Loop0");
    v22 = a1;
    v23 = kCFBooleanFalse;
  }
  else
  {
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *a4 = Mutable;
    if (!Mutable)
    {
      ramrod_create_error_cf(a5, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: *output allocation failed"), v15, v16, v17, (char)"_CanaryUpdaterExecCmd");
      return 0;
    }
    v18 = CFDictionaryGetValue(a1, CFSTR("QueryLoop0"));
    AMSupportLogInternal(6, "_CanaryUpdaterExecCmd", "QueryInfo Running, Loop0=%@.", v18);
    CFDictionarySetValue(*a4, CFSTR("ECID"), CFSTR("1234567890"));
    v19 = *a4;
    v20 = CFDictionaryGetValue(a1, CFSTR("QueryLoop0"));
    CFDictionarySetValue(v19, CFSTR("QueryLoop0"), v20);
    CFDictionarySetValue(*a4, CFSTR("LocalSigningID"), kCFBooleanTrue);
    if (CFDictionaryGetValue(a1, CFSTR("QueryLoop0")) == kCFBooleanFalse)
      CFDictionarySetValue(a1, CFSTR("IsDone"), kCFBooleanTrue);
    v21 = CFSTR("QueryLoop0");
    v22 = a1;
    v23 = kCFBooleanFalse;
  }
  CFDictionarySetValue(v22, v21, v23);
  return 1;
}

uint64_t ramrod_update_nvram_overrides(const char *a1, __CFDictionary *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *CStringPtr;
  const __CFData *v11;
  const __CFString *v12;
  const char *v13;
  CFStringRef v15;
  CFTypeID v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CFTypeID v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const char *v32;
  char v33;

  if (!a2)
  {
    v32 = "options is NULL\n";
LABEL_21:
    ramrod_log_msg(v32, (uint64_t)a2, a3, a4, a5, a6, a7, a8, v33);
    v11 = 0;
    v12 = 0;
    goto LABEL_7;
  }
  if (!a1)
  {
    v32 = "updaterName is NULL\n";
    goto LABEL_21;
  }
  CStringPtr = CFStringGetCStringPtr(CFSTR("T200"), 0x8000100u);
  if (!strcmp(a1, CStringPtr))
  {
    v11 = (const __CFData *)ramrod_copy_NVRAM_variable_from_devicetree(CFSTR("VeridianForceUpdate"));
    if (v11)
    {
      v15 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v11, 0x8000100u);
      v12 = v15;
      if (v15)
      {
        v16 = CFGetTypeID(v15);
        if (v16 == CFStringGetTypeID() && CFStringCompare(v12, CFSTR("yes"), 1uLL) == kCFCompareEqualTo)
        {
          ramrod_log_msg("Setting %s=false due to nvram variable %s=yes\n", v17, v18, v19, v20, v21, v22, v23, (char)"SkipSameVersion");
          CFDictionarySetValue(a2, CFSTR("SkipSameVersion"), kCFBooleanFalse);
          CFDictionarySetValue(a2, CFSTR("RestoreInternal"), kCFBooleanTrue);
        }
      }
      goto LABEL_6;
    }
  }
  else
  {
    v11 = 0;
  }
  v12 = 0;
LABEL_6:
  v13 = CFStringGetCStringPtr(CFSTR("AppleTCON"), 0x8000100u);
  if (!strcmp(a1, v13))
  {
    v11 = (const __CFData *)ramrod_copy_NVRAM_variable_from_devicetree(CFSTR("AppleTCONForceUpdate"));
    if (v11)
      v12 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v11, 0x8000100u);
    if (v12)
    {
      v24 = CFGetTypeID(v12);
      if (v24 == CFStringGetTypeID() && CFStringCompare(v12, CFSTR("yes"), 1uLL) == kCFCompareEqualTo)
      {
        ramrod_log_msg("Setting %s=false due to nvram variable %s=yes\n", v25, v26, v27, v28, v29, v30, v31, (char)"SkipSameVersion");
        CFDictionarySetValue(a2, CFSTR("SkipSameVersion"), kCFBooleanFalse);
        CFDictionarySetValue(a2, CFSTR("RestoreInternal"), kCFBooleanTrue);
      }
    }
  }
LABEL_7:
  AMSupportSafeRelease(v12);
  return AMSupportSafeRelease(v11);
}

__CFString **sub_100093B9C(const __CFString *a1)
{
  uint64_t v2;
  const char *v3;
  const __CFString *v4;

  sub_100096708();
  if (a1)
  {
    v2 = 0;
    v3 = "Updater entry is NULL, defaulting to TRUE";
    while (1)
    {
      v4 = off_1001A75E8[v2];
      if (!v4)
        break;
      if (CFStringCompare(a1, v4, 0) == kCFCompareEqualTo)
        return &off_1001A75E8[v2];
      v2 += 6;
      if (v2 == 72)
        return 0;
    }
  }
  else
  {
    v3 = "updaterName is NULL";
  }
  AMSupportLogInternal(3, "_updater_named", v3);
  return 0;
}

__CFString *ramrod_update_get_dylib(const __CFString *a1)
{
  __CFString **v2;

  if (a1)
  {
    v2 = sub_100093B9C(a1);
    if (v2)
      return v2[3];
    AMSupportLogInternal(3, "ramrod_update_get_dylib", "updaterName %@ not found", a1);
  }
  else
  {
    AMSupportLogInternal(3, "ramrod_update_get_dylib", "updaterName is NULL");
  }
  return 0;
}

CFDictionaryRef ramrod_update_copy_ap_parameters_generating_nonces(CFDictionaryRef theDict)
{
  __CFDictionary *MutableCopy;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const __CFDictionary *v9;
  CFDictionaryRef updated;
  char v12;

  if (theDict)
    MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
  else
    MutableCopy = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v9 = MutableCopy;
  if (MutableCopy)
  {
    CFDictionarySetValue(MutableCopy, CFSTR("GenerateNonces"), kCFBooleanTrue);
    updated = ramrod_update_copy_ap_parameters(v9);
    CFRelease(v9);
    return updated;
  }
  else
  {
    ramrod_log_msg("Failed to allocate ap options dictionary.\n", v2, v3, v4, v5, v6, v7, v8, v12);
    return 0;
  }
}

CFDictionaryRef ramrod_update_copy_ap_parameters(const __CFDictionary *a1)
{
  int BOOLean_option;
  __CFDictionary *Mutable;
  io_registry_entry_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  io_object_t v11;
  const __CFData *CFProperty;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const __CFData *v20;
  CFTypeID v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const UInt8 *BytePtr;
  CFNumberRef v30;
  const char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  CFNumberRef v39;
  CFNumberRef v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  CFNumberRef v48;
  CFNumberRef v49;
  CFDictionaryRef Copy;
  char v52;
  CFTypeRef cf;
  void *value;
  int v55;
  int valuePtr;

  BOOLean_option = get_BOOLean_option(a1, CFSTR("GenerateNonces"), 0);
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    AMSupportLogInternal(3, "ramrod_update_copy_ap_parameters", "apParameters failed to allocate");
    v30 = 0;
    Copy = 0;
    goto LABEL_29;
  }
  v3 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/chosen");
  if (v3)
  {
    v11 = v3;
    CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v3, CFSTR("esdm-fuses"), kCFAllocatorDefault, 0);
    if (CFProperty)
    {
      v20 = CFProperty;
      v21 = CFGetTypeID(CFProperty);
      if (v21 == CFDataGetTypeID())
      {
        BytePtr = CFDataGetBytePtr(v20);
        v30 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, BytePtr);
        if (v30)
          goto LABEL_12;
        v31 = "could not create CFNumber for esdm-fuses\n";
      }
      else
      {
        v31 = "esdm-fuses property is not a CFData\n";
      }
      ramrod_log_msg(v31, v22, v23, v24, v25, v26, v27, v28, v52);
      v30 = 0;
LABEL_12:
      CFRelease(v20);
      IOObjectRelease(v11);
      if (v30)
        CFDictionarySetValue(Mutable, CFSTR("ApSikaFuse"), v30);
      goto LABEL_14;
    }
    ramrod_log_msg("unable to lookup esdm-fuses property\n", v13, v14, v15, v16, v17, v18, v19, v52);
    IOObjectRelease(v11);
  }
  else
  {
    ramrod_log_msg("unable to find 'chosen' registry entry\n", v4, v5, v6, v7, v8, v9, v10, v52);
  }
  v30 = 0;
LABEL_14:
  if (BOOLean_option && _ramrod_device_has_sandcat())
  {
    v55 = 2;
    valuePtr = 0;
    cf = 0;
    value = 0;
    if (ramrod_generate_apslot_copy_nonce(&valuePtr, (CFDataRef *)&value))
    {
      v39 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      if (v39)
      {
        v40 = v39;
        CFDictionarySetValue(Mutable, CFSTR("ApNonceSlotID"), v39);
        CFRelease(v40);
      }
      if (value)
      {
        CFDictionarySetValue(Mutable, CFSTR("ApNonce"), value);
        CFRelease(value);
      }
    }
    else
    {
      ramrod_log_msg("unable to read the AP slot id will not set.\n", v32, v33, v34, v35, v36, v37, v38, v52);
    }
    if (ramrod_generate_sepslot_copy_nonce(&v55, (CFDataRef *)&cf))
    {
      v48 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &v55);
      if (v48)
      {
        v49 = v48;
        CFDictionarySetValue(Mutable, CFSTR("SepNonceSlotID"), v48);
        CFRelease(v49);
      }
      if (cf)
      {
        CFDictionarySetValue(Mutable, CFSTR("SepNonce"), cf);
        CFRelease(cf);
      }
    }
    else
    {
      ramrod_log_msg("unable to read the SEP slot id will not set.\n", v41, v42, v43, v44, v45, v46, v47, v52);
    }
  }
  Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, Mutable);
LABEL_29:
  AMSupportSafeRelease(Mutable);
  AMSupportSafeRelease(v30);
  return Copy;
}

__CFDictionary *ramrod_update_copy_deviceinfo_with_options(const __CFDictionary *a1, CFErrorRef *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFMutableDictionaryRef Mutable;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFMutableDictionaryRef v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  CFMutableDictionaryRef v17;
  __CFDictionary *v18;
  CFDictionaryRef updated;
  const void *Value;
  CFBooleanRef v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const __CFString *v25;
  BOOL v26;
  uint64_t v27;
  __CFDictionary *v28;
  CFMutableArrayRef v29;
  __CFDictionary *v30;
  CFMutableDictionaryRef MutableCopy;
  const char *v32;
  CFStringRef *v33;
  uint64_t v34;
  const __CFString *v35;
  const __CFArray *v36;
  const __CFArray *v37;
  CFIndex v38;
  const __CFString *ValueAtIndex;
  const __CFString *v40;
  CFTypeID v41;
  const char *v42;
  __CFString **v43;
  __CFString *v44;
  __CFString **v45;
  __CFString *v46;
  const __CFAllocator *v47;
  char v48;
  const char *CStringPtr;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  const char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  __CFDictionary *v79;
  int v80;
  int v81;
  __CFString **v82;
  int v83;
  int v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  CFTypeID TypeID;
  unint64_t v97;
  CFMutableArrayRef v98;
  __CFDictionary *v99;
  const char *v100;
  char v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  __CFDictionary *result;
  char v109;
  const void **v110;
  _BYTE *v111;
  __CFDictionary *v112;
  CFDictionaryRef v113;
  CFMutableDictionaryRef v114;
  __CFDictionary *v115;
  __CFDictionary *cf;
  const void **v117;
  CFMutableDictionaryRef v118;
  _BYTE *v119;
  _BOOL4 v120;
  int key;
  void *keya;
  __CFDictionary *theDict;
  BOOL v125;
  __CFDictionary *v126;
  const __CFDictionary *v127;
  __CFDictionary *(**v128)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *);
  __CFDictionary *v129;
  const void *v130[2];

  v129 = 0;
  v130[0] = 0;
  v128 = 0;
  sub_100096708();
  cf = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!cf)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: Failed to allocate outDict"), v3, v4, v5, (char)"ramrod_update_copy_deviceinfo_with_options");
    Mutable = 0;
LABEL_150:
    v13 = 0;
LABEL_152:
    v17 = 0;
LABEL_156:
    v126 = 0;
LABEL_157:
    theDict = 0;
    v113 = 0;
    MutableCopy = 0;
    updated = 0;
LABEL_158:
    v30 = 0;
    v29 = 0;
    v28 = 0;
    v101 = 1;
    goto LABEL_140;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: Failed to allocate deviceInfo"), v6, v7, v8, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_150;
  }
  v13 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v13)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: Failed to allocate disabledInfo"), v10, v11, v12, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_152;
  }
  v17 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v17)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, 0, CFSTR("%s: Failed to allocate checkpointDict"), v14, v15, v16, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_156;
  }
  if (!a1)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 2, 0, CFSTR("%s: options is NULL"), v14, v15, v16, (char)"ramrod_update_copy_deviceinfo_with_options");
    goto LABEL_156;
  }
  v126 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v126)
  {
    AMSupportLogInternal(4, "ramrod_update_copy_deviceinfo_with_options", "updaterOptions failed to allocate");
    goto LABEL_156;
  }
  theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!theDict)
  {
    AMSupportLogInternal(4, "ramrod_update_copy_deviceinfo_with_options", "subOptions failed to allocate");
    goto LABEL_157;
  }
  v18 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  updated = v18;
  if (!v18)
  {
    AMSupportLogInternal(4, "ramrod_update_copy_deviceinfo_with_options", "restoreOptions failed to allocate");
    v113 = 0;
    MutableCopy = 0;
    goto LABEL_158;
  }
  CFDictionarySetValue(v18, CFSTR("CreateFilesystemPartitions"), kCFBooleanFalse);
  v113 = updated;
  CFDictionarySetValue(v126, CFSTR("RestoreOptions"), updated);
  if (CFDictionaryContainsKey(a1, CFSTR("PreflightRequired")))
  {
    Value = CFDictionaryGetValue(a1, CFSTR("PreflightRequired"));
    CFDictionarySetValue(theDict, CFSTR("PreflightRequired"), Value);
  }
  v118 = v17;
  v114 = v13;
  if (CFDictionaryContainsKey(a1, CFSTR("BootedUpdate")))
  {
    v21 = (CFBooleanRef)CFDictionaryGetValue(a1, CFSTR("BootedUpdate"));
    CFDictionarySetValue(theDict, CFSTR("BootedUpdate"), v21);
    v120 = v21 == kCFBooleanTrue;
  }
  else
  {
    v120 = 0;
  }
  v115 = Mutable;
  v127 = a1;
  if (CFDictionaryContainsKey(a1, CFSTR("PreflightContext")))
  {
    v25 = (const __CFString *)CFDictionaryGetValue(a1, CFSTR("PreflightContext"));
    CFDictionarySetValue(theDict, CFSTR("PreflightContext"), v25);
    v26 = CFStringCompare(v25, CFSTR("Limited"), 0) != kCFCompareEqualTo;
  }
  else
  {
    v26 = 1;
  }
  v27 = 0;
  v28 = 0;
  v29 = 0;
  v30 = 0;
  MutableCopy = 0;
  if (v120)
    v26 = 1;
  v125 = v26;
  v32 = "ramrod_update_copy_deviceinfo_with_options";
  while (1)
  {
    if (v28)
      CFRelease(v28);
    if (v129)
    {
      CFRelease(v129);
      v129 = 0;
    }
    if (v29)
      CFRelease(v29);
    if (v30)
      CFRelease(v30);
    if (v130[0])
    {
      CFRelease(v130[0]);
      v130[0] = 0;
    }
    if (MutableCopy)
      CFRelease(MutableCopy);
    if (v128)
    {
      free(v128);
      v128 = 0;
    }
    v33 = (CFStringRef *)&off_1001A75E8[6 * v27];
    if (!*v33)
    {
      ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, v130[0], CFSTR("%s: Updater Name is NULL at index %d"), v22, v23, v24, (char)v32);
LABEL_129:
      MutableCopy = 0;
LABEL_131:
      updated = 0;
      v30 = 0;
      v29 = 0;
      goto LABEL_137;
    }
    v34 = v27 + 1;
    AMSupportLogInternal(6, v32, "Preflight loop %d for updater %@..", v27 + 1, *v33);
    v35 = *v33;
    if (!*v33)
      break;
    v36 = (const __CFArray *)CFDictionaryGetValue(v127, CFSTR("SkipUpdaters"));
    if (!v36)
      break;
    v37 = v36;
    if (CFArrayGetCount(v36) < 1)
      break;
    v38 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(v37, v38);
      if (ValueAtIndex)
      {
        v40 = ValueAtIndex;
        v41 = CFGetTypeID(ValueAtIndex);
        if (v41 == CFStringGetTypeID() && CFStringCompare(v35, v40, 0) == kCFCompareEqualTo)
          break;
      }
      if (++v38 >= CFArrayGetCount(v37))
        goto LABEL_43;
    }
    AMSupportLogInternal(6, v32, "Skipping updater %@", *v33);
    MutableCopy = 0;
    v30 = 0;
    v29 = 0;
    v28 = 0;
LABEL_71:
    v27 = v34;
    if (v34 == 12)
    {
      updated = ramrod_update_copy_ap_parameters(v127);
      Mutable = v115;
      CFDictionaryAddValue(cf, CFSTR("DeviceInfo"), v115);
      v13 = v114;
      CFDictionaryAddValue(cf, CFSTR("DeviceInfoDisabled"), v114);
      v17 = v118;
      CFDictionaryAddValue(cf, CFSTR("DeviceInfoFailures"), v118);
      CFDictionaryAddValue(cf, CFSTR("ApParameters"), updated);
      v101 = 0;
      goto LABEL_140;
    }
  }
LABEL_43:
  v42 = v32;
  v43 = &off_1001A75E8[6 * v27];
  v46 = v43[2];
  v45 = v43 + 2;
  v44 = v46;
  if (!v46)
    goto LABEL_55;
  if (v125)
  {
    v47 = kCFAllocatorDefault;
    goto LABEL_49;
  }
  v47 = kCFAllocatorDefault;
  if (((unsigned int (*)(uint64_t))v44)(1))
  {
    v48 = 0;
    goto LABEL_51;
  }
  v44 = *v45;
LABEL_49:
  if (!((unsigned int (*)(_BOOL4))v44)(v120))
  {
LABEL_55:
    v32 = v42;
    AMSupportLogInternal(6, v42, "Updater %@ not supported on this device..", *v33);
    MutableCopy = 0;
    v30 = 0;
    v29 = 0;
    goto LABEL_70;
  }
  v48 = 1;
LABEL_51:
  CStringPtr = CFStringGetCStringPtr(*v33, 0x8000100u);
  if (!CStringPtr)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, v130[0], CFSTR("%s: failed convert updaterName %@"), v50, v51, v52, (char)v42);
    goto LABEL_129;
  }
  v53 = CStringPtr;
  MutableCopy = CFDictionaryCreateMutableCopy(v47, 0, theDict);
  if (!MutableCopy)
  {
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, v130[0], CFSTR("%s: Failed to copy subOptions for %s"), v54, v55, v56, (char)v42);
    goto LABEL_131;
  }
  CFDictionarySetValue(v126, CFSTR("Options"), MutableCopy);
  ramrod_update_nvram_overrides(v53, MutableCopy, v57, v58, v59, v60, v61, v62);
  if (AMAuthInstallUpdaterTwoStageEnabled(*v33))
  {
    ramrod_log_msg("%s Updater configured for two-stage update. DeferredCommit: YES.\n", v63, v64, v65, v66, v67, v68, v69, (char)v53);
    CFDictionarySetValue(MutableCopy, CFSTR("DeferredCommit"), kCFBooleanTrue);
  }
  else
  {
    ramrod_log_msg("%s Updater: Legacy / single-stage updater.\n", v63, v64, v65, v66, v67, v68, v69, (char)v53);
  }
  if (BYTE4(off_1001A75E8[6 * v27 + 4]))
  {
    v29 = CFArrayCreateMutable(v47, 0, &kCFTypeArrayCallBacks);
    if (v29)
    {
      if ((v48 & 1) == 0)
        goto LABEL_60;
      goto LABEL_61;
    }
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 6, v130[0], CFSTR("%s: Failed to create queryResults array for %s"), v70, v71, v72, (char)v42);
LABEL_136:
    updated = 0;
    v30 = 0;
LABEL_137:
    v28 = 0;
LABEL_138:
    v101 = 1;
    Mutable = v115;
    goto LABEL_139;
  }
  v29 = 0;
  if ((v48 & 1) == 0)
  {
LABEL_60:
    AMSupportLogInternal(6, v42, "overriding updater context to BootedOS for %sUpdater", v53);
    CFDictionarySetValue(MutableCopy, CFSTR("PreflightContext"), CFSTR("BootedOS"));
  }
LABEL_61:
  v73 = dlopen((const char *)off_1001A75E8[6 * v27 + 3], 261);
  if (!v73)
  {
    dlerror();
    v32 = v42;
    AMSupportLogInternal(6, v42, "Failed to open updater library on device that should have %s: %s");
LABEL_69:
    v30 = 0;
LABEL_70:
    v28 = 0;
    goto LABEL_71;
  }
  if (!ramrod_copy_updater_functions(v73, v53, &v128, a2, v74, v75, v76, v77))
  {
    AMSupportLogInternal(3, "ramrod_update_copy_deviceinfo_with_options", "ramrod_copy_updater_functions failed on %s");
    goto LABEL_136;
  }
  v32 = v42;
  v78 = ((uint64_t (*)(_QWORD, const void **))v128[1])(0, v130);
  if (v130[0])
  {
    AMSupportLogInternal(3, "ramrod_update_copy_deviceinfo_with_options", "%sUpdater fp_isDone returned error: %@", v53, v130[0]);
    goto LABEL_136;
  }
  if (v78)
  {
    AMSupportLogInternal(6, v42, "Updater %s returned isDone(NULL)=true (ie: module should skip), continuing.");
    goto LABEL_69;
  }
  AMSupportLogInternal(6, v42, "creating %sUpdater obj", v53);
  v79 = (*v128)(v126, (uint64_t)sub_100094E54, (uint64_t)v53, (CFErrorRef *)v130);
  v28 = v79;
  if (!v79)
  {
    AMSupportLogInternal(3, v42, "fp_create failed on %s. error=%@", v53, v130[0]);
    ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 1013, v130[0], CFSTR("%s: Preflight Create failed on %s"), v105, v106, v107, (char)v42);
LABEL_126:
    updated = 0;
    v30 = 0;
    goto LABEL_138;
  }
  v80 = ((uint64_t (*)(__CFDictionary *, const void **))v128[1])(v79, v130);
  if (v130[0])
  {
    AMSupportLogInternal(3, "ramrod_update_copy_deviceinfo_with_options", "%sUpdater fp_isDone returned error: %@", v53, v130[0]);
    goto LABEL_126;
  }
  if (v80)
  {
    AMSupportLogInternal(6, v42, "Updater %s returned isDone(obj)=true (ie: module should skip), continuing.", v53);
    v30 = 0;
    goto LABEL_71;
  }
  v81 = 0;
  v112 = 0;
  v82 = &off_1001A75E8[6 * v27];
  v119 = (char *)v82 + 33;
  v117 = (const void **)(v82 + 1);
  v110 = (const void **)(v82 + 5);
  v111 = (char *)v82 + 34;
  while (2)
  {
    if (v81 <= 1024)
      v83 = 1024;
    else
      v83 = v81;
    key = v83;
    v84 = v81 - 1;
    while (2)
    {
      if (v129)
      {
        CFRelease(v129);
        v129 = 0;
      }
      if (key == v84 + 1)
      {
        AMSupportLogInternal(3, v42, "Exceeded maximum loops (%d) for %s. error=%@", 1024, v53);
        ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 1016, v130[0], CFSTR("%s: Exceeded maximum loops for %s"), v102, v103, v104, (char)v42);
LABEL_123:
        updated = 0;
        v101 = 1;
        Mutable = v115;
        goto LABEL_124;
      }
      if (!v29)
        goto LABEL_89;
      AMSupportLogInternal(6, v42, "Calling %sUpdater fp_isDone", v53);
      v85 = ((uint64_t (*)(__CFDictionary *, const void **))v128[1])(v28, v130);
      if (v130[0])
      {
        AMSupportLogInternal(3, "ramrod_update_copy_deviceinfo_with_options", "%sUpdater fp_isDone returned error: %@", v53, v130[0]);
        goto LABEL_123;
      }
      if (v85)
        goto LABEL_121;
LABEL_89:
      AMSupportLogInternal(6, v42, "Calling %sUpdater fp_ExecCmd", v53);
      if (!((unsigned int (*)(__CFDictionary *, const __CFString *, _QWORD, __CFDictionary **, const void **))v128[2])(v28, CFSTR("queryInfo"), 0, &v129, v130))
      {
        AMSupportLogInternal(3, v42, "fp_ExecCmd failed on %s, continuing to next updater.", v53);
        if (*v119 == 1)
        {
          ramrod_log_msg("%s updater failed but not reporting error since it is best effort\n", v86, v87, v88, v89, v90, v91, v92, (char)v53);
        }
        else
        {
          CFDictionarySetValue(v118, *v33, *v117);
          ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 1016, v130[0], CFSTR("%s: Preflight QueryInfo failed on %s"), v93, v94, v95, (char)v42);
        }
        ++v84;
        if (!v29)
          goto LABEL_121;
        continue;
      }
      break;
    }
    if (!v129)
    {
      Mutable = v115;
      goto LABEL_103;
    }
    TypeID = CFDictionaryGetTypeID();
    Mutable = v115;
    if (TypeID != CFGetTypeID(v129) || CFDictionaryGetValue(v127, CFSTR("PreflightRequired")) != kCFBooleanFalse)
    {
LABEL_103:
      v97 = (unint64_t)v129;
      if (v29)
      {
        CFArrayAppendValue(v29, v129);
        v97 = (unint64_t)v129;
      }
      if (v97 && !v130[0])
      {
        AMSupportLogInternal(6, v42, "Populated deviceinfo for %s, continuing.", v53);
        if (v29)
          v98 = v29;
        else
          v98 = v129;
        if (*v111)
          v99 = Mutable;
        else
          v99 = v114;
        CFDictionarySetValue(v99, *v33, v98);
        goto LABEL_120;
      }
      if (!(v97 | (unint64_t)v130[0]))
      {
        AMSupportLogInternal(6, v42, "Updater %s returned no personalization info (ie: module should skip), continuing.", v53);
        goto LABEL_120;
      }
      v100 = "NULL";
      if (v97)
        v100 = "NOT-NULL";
      AMSupportLogInternal(6, v42, "Updater %s QueryInfo succeeded, but bad results. Results=%s, Error=%@", v53, v100, v130[0]);
      if (!*v111)
      {
LABEL_120:
        v81 = v84 + 2;
        if (v29)
          continue;
LABEL_121:
        v32 = v42;
        v30 = v112;
        goto LABEL_71;
      }
      ramrod_create_error_cf(a2, CFSTR("RamrodErrorDomain"), 1016, v130[0], CFSTR("%s: Preflight QueryInfo succeeded, but improper results on %s"), v22, v23, v24, (char)v42);
      updated = 0;
      v101 = 1;
LABEL_124:
      v13 = v114;
      v17 = v118;
      v30 = v112;
      goto LABEL_140;
    }
    break;
  }
  v112 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v129);
  if (v112)
  {
    if (*v110)
    {
      keya = (void *)*v110;
      if (CFDictionaryContainsKey(v112, *v110))
      {
        AMSupportLogInternal(3, v42, "Removing updater reference from DeviceInfo to avoid serialization failures.");
        CFDictionaryRemoveValue(v112, keya);
        CFRelease(v129);
        v129 = v112;
        v112 = 0;
      }
    }
    goto LABEL_103;
  }
  updated = 0;
  v30 = 0;
  v101 = 1;
LABEL_139:
  v13 = v114;
  v17 = v118;
LABEL_140:
  AMSupportSafeRelease(v28);
  AMSupportSafeRelease(v30);
  AMSupportSafeRelease(v129);
  AMSupportSafeRelease(v29);
  AMSupportSafeRelease(v130[0]);
  AMSupportSafeRelease(v126);
  AMSupportSafeRelease(theDict);
  AMSupportSafeRelease(v113);
  AMSupportSafeRelease(Mutable);
  AMSupportSafeRelease(v13);
  AMSupportSafeRelease(v17);
  AMSupportSafeRelease(MutableCopy);
  AMSupportSafeRelease(updated);
  if (v128)
  {
    free(v128);
    v128 = 0;
  }
  result = cf;
  v109 = v101 ^ 1;
  if (!cf)
    v109 = 1;
  if ((v109 & 1) == 0)
  {
    CFRelease(cf);
    return 0;
  }
  return result;
}

void sub_100094E54(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2)
    ramrod_log_msg("updater_log: %s", a2, a3, a4, a5, a6, a7, a8, a2);
}

__CFDictionary *ramrod_update_copy_deviceinfo(int a1, CFErrorRef *a2)
{
  __CFDictionary *Mutable;
  __CFDictionary *v5;
  const void **v6;
  __CFDictionary *updated;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v5 = Mutable;
  if (Mutable)
  {
    v6 = (const void **)&kCFBooleanTrue;
    if (!a1)
      v6 = (const void **)&kCFBooleanFalse;
    CFDictionarySetValue(Mutable, CFSTR("PreflightRequired"), *v6);
    CFDictionarySetValue(v5, CFSTR("PreflightContext"), CFSTR("BootedOS"));
    updated = ramrod_update_copy_deviceinfo_with_options(v5, a2);
  }
  else
  {
    AMSupportLogInternal(3, "ramrod_update_copy_deviceinfo", "Failed allocate options");
    updated = 0;
  }
  AMSupportSafeRelease(v5);
  return updated;
}

BOOL ramrod_should_update_rose(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL8 v8;
  const char *v9;
  int has_rose;
  char v12;

  if (a1)
  {
    v8 = 0;
    v9 = "Skipping checking Rose for booted update\n";
  }
  else
  {
    has_rose = ramrod_device_has_rose();
    v8 = has_rose != 0;
    if (has_rose)
      v9 = "Rose is present. Will update\n";
    else
      v9 = "Rose not present\n";
  }
  ramrod_log_msg(v9, a2, a3, a4, a5, a6, a7, a8, v12);
  return v8;
}

uint64_t ramrod_device_has_rose()
{
  const __CFDictionary *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  io_service_t MatchingService;
  const __CFString *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFString *v17;
  CFTypeID v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFNumber *v26;
  const __CFNumber *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFNumber *v35;
  CFTypeID v36;
  const __CFNumber *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  const __CFNumber *v45;
  CFTypeID v46;
  const char *v47;
  const char *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v58;
  char v59;
  char v60;
  char valuePtr;

  v0 = IOServiceNameMatching("rose");
  MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v0);
  if (!MatchingService)
  {
    ramrod_log_msg("Service does not exist\n", v1, v2, v3, v4, v5, v6, v7, v59);
    v49 = 0;
    v17 = 0;
    v26 = 0;
    v35 = 0;
LABEL_31:
    v45 = 0;
    goto LABEL_20;
  }
  if (!ramrod_should_do_legacy_restored_internal_behaviors())
  {
    v17 = 0;
LABEL_17:
    v26 = 0;
LABEL_18:
    v35 = 0;
    v45 = 0;
    goto LABEL_19;
  }
  valuePtr = 0;
  v9 = (const __CFString *)MGCopyAnswer(CFSTR("HWModelStr"), 0);
  v17 = v9;
  if (!v9)
  {
    v48 = "Failed to get HW model\n";
    goto LABEL_16;
  }
  v18 = CFGetTypeID(v9);
  if (v18 != CFStringGetTypeID())
  {
    v48 = "HW model is not a string\n";
    goto LABEL_16;
  }
  if (!CFStringHasSuffix(v17, CFSTR("DEV")))
  {
    v48 = "Not a DEV board\n";
LABEL_16:
    ramrod_log_msg(v48, v10, v11, v12, v13, v14, v15, v16, v59);
    goto LABEL_17;
  }
  ramrod_log_msg("DEV board\n", v10, v11, v12, v13, v14, v15, v16, v59);
  v26 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt8Type, &valuePtr);
  if (!v26)
  {
    ramrod_log_msg("Failed to create zero\n", v19, v20, v21, v22, v23, v24, v25, v60);
    goto LABEL_18;
  }
  v27 = (const __CFNumber *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", CFSTR("ECID"), kCFAllocatorDefault, 1u);
  v35 = v27;
  if (!v27)
  {
    v58 = "ECID property does not exist\n";
LABEL_30:
    ramrod_log_msg(v58, v28, v29, v30, v31, v32, v33, v34, v60);
    v49 = 0;
    goto LABEL_31;
  }
  v36 = CFGetTypeID(v27);
  if (v36 != CFNumberGetTypeID())
  {
    v58 = "ECID property is not a number\n";
    goto LABEL_30;
  }
  if (CFNumberCompare(v26, v35, 0) == kCFCompareEqualTo)
  {
    v58 = "ECID property is zero\n";
    goto LABEL_30;
  }
  v37 = (const __CFNumber *)IORegistryEntrySearchCFProperty(MatchingService, "IOService", CFSTR("ChipID"), kCFAllocatorDefault, 1u);
  v45 = v37;
  if (!v37)
  {
    v47 = "ChipID property does not exist\n";
    goto LABEL_34;
  }
  v46 = CFGetTypeID(v37);
  if (v46 != CFNumberGetTypeID())
  {
    v47 = "ChipID property is not a number\n";
    goto LABEL_34;
  }
  if (CFNumberCompare(v26, v45, 0))
  {
LABEL_19:
    v49 = 1;
    goto LABEL_20;
  }
  v47 = "ChipID property is zero\n";
LABEL_34:
  ramrod_log_msg(v47, v38, v39, v40, v41, v42, v43, v44, v60);
  v49 = 0;
LABEL_20:
  AMSupportSafeRelease(v45);
  AMSupportSafeRelease(v35);
  AMSupportSafeRelease(v26);
  AMSupportSafeRelease(v17);
  if (MatchingService)
    IOObjectRelease(MatchingService);
  ramrod_log_msg("result: %u\n", v50, v51, v52, v53, v54, v55, v56, v49);
  return v49;
}

const __CFString *ramrod_update_supported(CFStringRef theString, const __CFString *a2)
{
  const __CFString *v2;
  const char *CStringPtr;
  __CFString *dylib;
  __CFDictionary *Mutable;
  void *v7;
  CFMutableDictionaryRef v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  uint64_t v15;
  CFTypeID v16;
  CFErrorRef v17;
  const __CFString *v18;
  char *v20;
  const __CFString *v21;
  CFErrorRef err;
  void *v23;
  uint64_t v24;
  CFTypeRef cf;

  v2 = theString;
  v24 = 0;
  cf = 0;
  v23 = 0;
  if (!theString)
  {
    AMSupportLogInternal(3, "_ramrod_update_supported", "ERROR updater NULL.");
    v7 = 0;
    Mutable = 0;
    v8 = 0;
    CStringPtr = 0;
    goto LABEL_28;
  }
  CStringPtr = CFStringGetCStringPtr(theString, 0x8000100u);
  if (!CStringPtr)
  {
    AMSupportLogInternal(3, "_ramrod_update_supported", "Failed to convert %@ name to C String.. skipping update.", v2);
    v7 = 0;
    Mutable = 0;
    v8 = 0;
    goto LABEL_16;
  }
  dylib = ramrod_update_get_dylib(v2);
  Mutable = (__CFDictionary *)dylib;
  if (!dylib)
  {
    AMSupportLogInternal(3, "_ramrod_update_supported", "ramrod_update_get_dylib returned NULL for %@, skipping update.", v2);
LABEL_38:
    v7 = 0;
    goto LABEL_39;
  }
  v7 = dlopen((const char *)dylib, 261);
  if (!v7)
  {
    v20 = dlerror();
    AMSupportLogInternal(3, "_ramrod_update_supported", "%@ dylib missing, skipping update: %s: %s", v2, Mutable, v20);
    Mutable = 0;
LABEL_39:
    v8 = 0;
    goto LABEL_15;
  }
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    AMSupportLogInternal(4, "_ramrod_update_supported", "updaterOptions failed to allocate");
    goto LABEL_38;
  }
  v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v8)
  {
    AMSupportLogInternal(4, "_ramrod_update_supported", "subOptions failed to allocate");
LABEL_41:
    v7 = 0;
    goto LABEL_15;
  }
  CFDictionarySetValue(Mutable, CFSTR("Options"), v8);
  CFDictionarySetValue(v8, CFSTR("PreflightRequired"), kCFBooleanTrue);
  if (!ramrod_copy_updater_functions(v7, CStringPtr, (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v23, 0, v9, v10, v11, v12)|| !*((_QWORD *)v23 + 2)|| !*((_QWORD *)v23 + 1)|| !*(_QWORD *)v23)
  {
    goto LABEL_41;
  }
  v13 = (*(uint64_t (**)(__CFDictionary *, void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), const char *, uint64_t *))v23)(Mutable, sub_100094E54, CStringPtr, &v24);
  v7 = (void *)v13;
  if (!v13)
  {
    AMSupportLogInternal(3, "_ramrod_update_supported", "Failed to create %s obj, error=%@", CStringPtr, v24);
    goto LABEL_15;
  }
  err = 0;
  if ((*((unsigned int (**)(uint64_t, _QWORD))v23 + 1))(v13, 0))
  {
    v21 = v2;
    v14 = "%@ instructed us not to attempt OTA (via isDone)";
LABEL_14:
    AMSupportLogInternal(4, "_ramrod_update_supported", v14, v21);
LABEL_15:
    CStringPtr = 0;
LABEL_16:
    v2 = 0;
    goto LABEL_28;
  }
  v15 = (*((uint64_t (**)(void *, const __CFString *, _QWORD, CFTypeRef *, CFErrorRef *))v23 + 2))(v7, CFSTR("queryInfo"), 0, &cf, &err);
  if ((_DWORD)v15 == 1 && !err)
  {
    if (!cf || (v16 = CFGetTypeID(cf), v16 == CFDictionaryGetTypeID()) && !CFDictionaryGetCount((CFDictionaryRef)cf))
    {
      v21 = v2;
      v14 = "%@ instructed us not to attempt OTA (via QueryInfo)";
      goto LABEL_14;
    }
  }
  CStringPtr = 0;
  v17 = err;
  if (a2 && err)
  {
    v18 = CFErrorCopyDescription(err);
    CStringPtr = (const char *)v18;
    if (v18 && CFStringCompare(v18, a2, 0) == kCFCompareEqualTo)
    {
      AMSupportLogInternal(4, "_ramrod_update_supported", "%@ instructed us not to attempt update (via QueryInfo Error string match)", v2);
      goto LABEL_16;
    }
    AMSupportLogInternal(4, "_ramrod_update_supported", "%@ returned error, but no indication to skip update: %@", v2, err);
    v17 = err;
  }
  AMSupportLogInternal(6, "_ramrod_update_supported", "%@ tells us to attempt Update.  success=%d, error=%d, result=%d.", v2, v15, v17 != 0, cf != 0);
  v2 = (const __CFString *)1;
LABEL_28:
  AMSupportSafeRelease(cf);
  AMSupportSafeRelease(Mutable);
  AMSupportSafeRelease(v8);
  AMSupportSafeRelease(v24);
  AMSupportSafeRelease(v7);
  AMSupportSafeRelease(CStringPtr);
  if (v23)
    free(v23);
  return v2;
}

BOOL ramrod_device_has_savage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  unsigned int (*v15)(_QWORD, _QWORD);
  _BOOL8 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v25;

  v25 = 0;
  ramrod_log_msg("opening %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"/usr/lib/updaters/libSavageUpdater_iOS.dylib");
  v8 = dlopen("/usr/lib/updaters/libSavageUpdater_iOS.dylib", 261);
  if (!v8)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v17, v18, v19, v20, v21, v22, v23, (char)"/usr/lib/updaters/libSavageUpdater_iOS.dylib");
    return 0;
  }
  v13 = ramrod_copy_updater_functions(v8, "Savage", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v9, v10, v11, v12);
  v14 = v25;
  if (!v13)
  {
    v16 = 0;
    if (!v25)
      return v16;
    goto LABEL_5;
  }
  v15 = (unsigned int (*)(_QWORD, _QWORD))*((_QWORD *)v25 + 1);
  if (!v15)
  {
    v16 = 0;
    goto LABEL_5;
  }
  v16 = v15(0, 0) == 0;
  v14 = v25;
  if (v25)
LABEL_5:
    free(v14);
  return v16;
}

BOOL ramrod_should_update_savage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!(_DWORD)a1)
    return ramrod_device_has_savage(a1, a2, a3, a4, a5, a6, a7, a8);
  ramrod_log_msg("Skipping checking Savage for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t ramrod_device_has_veridian()
{
  const __CFDictionary *v0;
  io_service_t MatchingService;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  io_object_t v9;
  const __CFString *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFString *v18;
  CFTypeID v19;
  __CFDictionary *v20;
  CFDictionaryRef v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  CFDictionaryRef v29;
  io_service_t v30;
  io_object_t v31;
  const __CFString *CFProperty;
  CFTypeID v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const char *v50;
  const char *v51;
  char v52;
  void *keys;

  v0 = IOServiceMatching("AppleGasGaugeUpdate");
  MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v0);
  if (MatchingService)
  {
    v9 = MatchingService;
    if (ramrod_should_do_legacy_restored_internal_behaviors())
    {
      v10 = (const __CFString *)MGCopyAnswer(CFSTR("HWModelStr"), 0);
      v18 = v10;
      if (v10)
      {
        v19 = CFGetTypeID(v10);
        if (v19 == CFStringGetTypeID())
        {
          if (CFStringHasSuffix(v18, CFSTR("DEV")))
          {
            keys = CFSTR("built-in");
            v20 = IOServiceMatching("IOPMPowerSource");
            v21 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&kCFBooleanTrue, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            v29 = v21;
            if (v20)
            {
              if (v21)
              {
                CFDictionarySetValue(v20, CFSTR("IOPropertyMatch"), v21);
                v30 = IOServiceGetMatchingService(kIOMasterPortDefault, v20);
                if (v30)
                {
                  v31 = v30;
                  CFProperty = (const __CFString *)IORegistryEntryCreateCFProperty(v30, CFSTR("Serial"), kCFAllocatorDefault, 0);
                  IOObjectRelease(v31);
                  AMSupportSafeRelease(v29);
                  if (CFProperty)
                  {
                    v33 = CFGetTypeID(CFProperty);
                    if (v33 == CFStringGetTypeID())
                    {
                      if (!CFStringGetLength(CFProperty))
                      {
                        ramrod_log_msg("Dev board with no Veridian attached - pretending we don't support Veridian.\n", v41, v42, v43, v44, v45, v46, v47, v52);
                        v48 = 0;
LABEL_17:
                        IOObjectRelease(v9);
                        goto LABEL_18;
                      }
                    }
                    else
                    {
                      ramrod_log_msg("Veridian Serial not a string - not expected\n", v34, v35, v36, v37, v38, v39, v40, v52);
                    }
LABEL_16:
                    v48 = 1;
                    goto LABEL_17;
                  }
                  goto LABEL_25;
                }
                v51 = "unable to find IOPMPowerSource service\n";
              }
              else
              {
                v51 = "Failed to allocate properties\n";
              }
            }
            else
            {
              v51 = "Failed to allocate matching\n";
            }
            ramrod_log_msg(v51, v22, v23, v24, v25, v26, v27, v28, v52);
            AMSupportSafeRelease(v29);
LABEL_25:
            v50 = "Veridian Serial is NULL - not expected\n";
            goto LABEL_26;
          }
LABEL_15:
          CFProperty = 0;
          goto LABEL_16;
        }
        v50 = "HW model is not a string\n";
      }
      else
      {
        v50 = "Failed to get HW model\n";
      }
LABEL_26:
      ramrod_log_msg(v50, v11, v12, v13, v14, v15, v16, v17, v52);
      goto LABEL_15;
    }
    v18 = 0;
    goto LABEL_15;
  }
  ramrod_log_msg("Not a Veridian device.\n", v2, v3, v4, v5, v6, v7, v8, v52);
  CFProperty = 0;
  v18 = 0;
  v48 = 0;
LABEL_18:
  AMSupportSafeRelease(v18);
  AMSupportSafeRelease(CFProperty);
  return v48;
}

BOOL ramrod_device_ota_veridian(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!a1)
    return ramrod_device_has_veridian() != 0;
  ramrod_log_msg("Skipping checking Veridian for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t ramrod_device_has_appletcon(uint64_t a1)
{
  io_registry_entry_t v2;
  io_object_t v3;
  CFTypeRef CFProperty;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  CFTypeID TypeID;
  CFIndex Length;
  CFIndex v14;
  size_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  io_registry_entry_t v32;
  io_object_t v33;
  CFTypeRef v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  CFTypeID v42;
  const UInt8 *BytePtr;
  int v44;
  uint64_t updated;
  const char *v46;
  const char *v48;
  const char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char v57;
  char v58;
  CFRange v59;

  v2 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/product");
  if (!v2)
  {
    CFProperty = 0;
LABEL_19:
    v34 = 0;
    v24 = 0;
LABEL_20:
    updated = 0;
    goto LABEL_21;
  }
  v3 = v2;
  CFProperty = IORegistryEntryCreateCFProperty(v2, CFSTR("tcon-path"), kCFAllocatorDefault, 0);
  IOObjectRelease(v3);
  if (!CFProperty)
  {
    v46 = "tcon-path pointer not found.\n";
LABEL_18:
    ramrod_log_msg(v46, v5, v6, v7, v8, v9, v10, v11, v57);
    goto LABEL_19;
  }
  TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(CFProperty))
  {
    v46 = "IORegistryEntryCreateCFProperty returned non CFDataRef\n";
    goto LABEL_18;
  }
  Length = CFDataGetLength((CFDataRef)CFProperty);
  if (!Length)
  {
    v46 = "tcon-path contains invalid string\n";
    goto LABEL_18;
  }
  v14 = Length;
  v15 = Length + 15;
  v16 = (char *)malloc(Length + 15);
  v24 = v16;
  if (!v16)
  {
    v49 = "malloc returned NULL\n";
LABEL_31:
    ramrod_log_msg(v49, v17, v18, v19, v20, v21, v22, v23, v57);
    goto LABEL_32;
  }
  if (snprintf(v16, v15, "%s", "IODeviceTree:/") != 14)
  {
    v49 = "overflow";
    goto LABEL_31;
  }
  v59.length = CFDataGetLength((CFDataRef)CFProperty);
  v59.location = 0;
  CFDataGetBytes((CFDataRef)CFProperty, v59, (UInt8 *)v24 + 14);
  v24[v14 + 14] = 0;
  ramrod_log_msg("Looking for entry under %s\n", v25, v26, v27, v28, v29, v30, v31, (char)v24);
  v32 = IORegistryEntryFromPath(kIOMasterPortDefault, v24);
  if (!v32)
  {
    v49 = "tcon-path points to non-existent node\n";
    goto LABEL_31;
  }
  v33 = v32;
  v34 = IORegistryEntryCreateCFProperty(v32, CFSTR("firmware"), kCFAllocatorDefault, 0);
  IOObjectRelease(v33);
  if (!v34)
  {
    v48 = "No 'firmware' property found.\n";
LABEL_23:
    ramrod_log_msg(v48, v35, v36, v37, v38, v39, v40, v41, v57);
    goto LABEL_20;
  }
  v42 = CFDataGetTypeID();
  if (v42 != CFGetTypeID(v34))
  {
    v48 = "IORegistryEntryCreateCFProperty returned non CFDataRef\n";
    goto LABEL_23;
  }
  if (CFDataGetLength((CFDataRef)v34) != 4)
  {
    v58 = CFDataGetLength((CFDataRef)v34);
    ramrod_log_msg("version_data wrong length (%lu bytes)\n", v50, v51, v52, v53, v54, v55, v56, v58);
    goto LABEL_20;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)v34);
  if (!BytePtr)
  {
    v48 = "CFDataGetBytePtr returned NULL\n";
    goto LABEL_23;
  }
  v44 = *(_DWORD *)BytePtr;
  ramrod_log_msg("AppleTCON flashable node found. (firmware=%d)\n", v35, v36, v37, v38, v39, v40, v41, *(_DWORD *)BytePtr);
  CFRelease(v34);
  if (!v44)
  {
LABEL_32:
    v34 = 0;
    goto LABEL_20;
  }
  if (a1
    && (const CFBooleanRef)AMSupportGetValueForKeyPathInDict(kCFAllocatorDefault, a1, CFSTR("AppleTCONOptions.FuseSDOM")) == kCFBooleanTrue)
  {
    v34 = 0;
    updated = 1;
  }
  else
  {
    updated = (uint64_t)ramrod_update_supported(CFSTR("AppleTCON"), CFSTR("AppleTCONUpdaterErrorDomain: AppleTCONUpdaterExecCommand - execCommand error"));
    v34 = 0;
  }
LABEL_21:
  AMSupportSafeRelease(CFProperty);
  AMSupportSafeRelease(v34);
  AMSupportSafeFree(v24);
  return updated;
}

BOOL ramrod_device_ota_appletcon(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!a1)
    return ramrod_device_has_appletcon(0) != 0;
  ramrod_log_msg("Skipping checking TCON for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_device_has_appletconuarp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  unsigned int (*v15)(_QWORD, _QWORD);
  _BOOL8 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v25;

  v25 = 0;
  ramrod_log_msg("opening %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"/usr/lib/updaters/libTconUpdaterUARP.dylib");
  v8 = dlopen("/usr/lib/updaters/libTconUpdaterUARP.dylib", 261);
  if (!v8)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v17, v18, v19, v20, v21, v22, v23, (char)"/usr/lib/updaters/libTconUpdaterUARP.dylib");
    return 0;
  }
  v13 = ramrod_copy_updater_functions(v8, "AppleTconUARP", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v9, v10, v11, v12);
  v14 = v25;
  if (!v13)
  {
    v16 = 0;
    if (!v25)
      return v16;
    goto LABEL_5;
  }
  v15 = (unsigned int (*)(_QWORD, _QWORD))*((_QWORD *)v25 + 1);
  if (!v15)
  {
    v16 = 0;
    goto LABEL_5;
  }
  v16 = v15(0, 0) == 0;
  v14 = v25;
  if (v25)
LABEL_5:
    free(v14);
  return v16;
}

BOOL ramrod_should_update_appletconuarp(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!(_DWORD)a1)
    return ramrod_device_has_appletconuarp(a1, a2, a3, a4, a5, a6, a7, a8);
  ramrod_log_msg("Skipping checking AppleTconUARP for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t _ramrod_device_has_usbcretimer_callback(_DWORD *a1, io_iterator_t iterator)
{
  io_object_t v3;

  v3 = IOIteratorNext(iterator);
  if (v3)
    ++*a1;
  return IOObjectRelease(v3);
}

BOOL _ramrod_device_has_usbcretimer(const __CFString *a1)
{
  NSMutableArray *v2;
  NSMutableArray *v3;
  io_registry_entry_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const char *v19;
  _BOOL8 v20;
  io_object_t v22;
  io_registry_entry_t v23;
  const __CFData *CFProperty;
  const __CFData *v25;
  CFTypeID TypeID;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const __CFString *v34;
  const __CFString *v35;
  const char *v36;
  char v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  IONotificationPort *v45;
  NSMutableArray *v46;
  id v47;
  id v48;
  uint64_t v49;
  void *i;
  void *v51;
  CFMutableDictionaryRef v52;
  NSDictionary *v53;
  const __CFDictionary *v54;
  kern_return_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  io_object_t v63;
  __CFRunLoop *Current;
  __CFRunLoop *v65;
  id v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  id v75;
  id v76;
  uint64_t v77;
  void *j;
  char v79;
  __CFRunLoopSource *source;
  io_registry_entry_t v81;
  NSMutableArray *v82;
  __int128 v83;
  __int128 v84;
  __int128 v85;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  uint64_t entryID;
  int refCon;
  io_iterator_t iterator;
  _BYTE v94[128];
  const __CFString *v95;
  CFTypeRef v96;
  _BYTE v97[128];

  iterator = 0;
  v2 = objc_opt_new(NSMutableArray);
  v3 = objc_opt_new(NSMutableArray);
  v4 = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/arm-io");
  refCon = 0;
  ramrod_log_msg("entering %s\n", v5, v6, v7, v8, v9, v10, v11, (char)"_ramrod_device_has_usbcretimer");
  if (ramrod_should_do_legacy_restored_internal_behaviors())
  {
    entryID = 0;
    if (os_parse_boot_arg_int("ramrod_disable_usbcretimer", &entryID))
    {
      if (entryID)
      {
        v19 = "ramrod_disable_usbcretimer set in boot-args, disabling hardware support and not waiting for retimers\n";
LABEL_9:
        ramrod_log_msg(v19, v12, v13, v14, v15, v16, v17, v18, v79);
        v20 = 0;
        goto LABEL_10;
      }
    }
  }
  if (!v4)
  {
    v19 = "Failed to create DT node for IODeviceTree\n";
    goto LABEL_9;
  }
  if (IORegistryEntryCreateIterator(v4, "IODeviceTree", 1u, &iterator))
  {
    v19 = "Failed to create iterator for DeviceTree.\n";
    goto LABEL_9;
  }
  v82 = v3;
  v22 = IOIteratorNext(iterator);
  if (v22)
  {
    v23 = v22;
    while (1)
    {
      CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(v23, CFSTR("name"), kCFAllocatorDefault, 0);
      if (CFProperty)
        break;
LABEL_25:
      IOObjectRelease(v23);
      v23 = IOIteratorNext(iterator);
      if (!v23)
        goto LABEL_26;
    }
    v25 = CFProperty;
    entryID = 0;
    IORegistryEntryGetRegistryEntryID(v23, &entryID);
    TypeID = CFDataGetTypeID();
    if (TypeID == CFGetTypeID(v25))
    {
      v34 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, v25, 0x8000100u);
      if (v34)
      {
        v35 = v34;
        if (CFStringHasPrefix(v34, a1))
          -[NSMutableArray addObject:](v2, "addObject:", +[NSNumber numberWithLongLong:](NSNumber, "numberWithLongLong:", entryID));
        CFRelease(v35);
        goto LABEL_24;
      }
      v36 = "nameString NULL\n";
    }
    else
    {
      v36 = "nameData not CFDataRef\n";
    }
    ramrod_log_msg(v36, v27, v28, v29, v30, v31, v32, v33, v79);
LABEL_24:
    CFRelease(v25);
    goto LABEL_25;
  }
LABEL_26:
  if (iterator)
    IOObjectRelease(iterator);
  iterator = 0;
  if (-[NSMutableArray count](v2, "count"))
  {
    v81 = v4;
    v37 = -[NSMutableArray count](v2, "count");
    ramrod_log_msg("Found %lu nodes in the device tree. Waiting some (small) amount of time for them to register as an IOSerivce\n", v38, v39, v40, v41, v42, v43, v44, v37);
    v45 = IONotificationPortCreate(kIOMasterPortDefault);
    source = IONotificationPortGetRunLoopSource(v45);
    v87 = 0u;
    v88 = 0u;
    v89 = 0u;
    v90 = 0u;
    v46 = v2;
    v47 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v2, "countByEnumeratingWithState:objects:count:", &v87, v97, 16);
    if (v47)
    {
      v48 = v47;
      v49 = *(_QWORD *)v88;
      do
      {
        for (i = 0; i != v48; i = (char *)i + 1)
        {
          if (*(_QWORD *)v88 != v49)
            objc_enumerationMutation(v2);
          v51 = *(void **)(*((_QWORD *)&v87 + 1) + 8 * (_QWORD)i);
          LODWORD(entryID) = 0;
          v95 = CFSTR("IOParentMatch");
          v52 = IORegistryEntryIDMatching((uint64_t)objc_msgSend(v51, "longLongValue"));
          v96 = (id)CFMakeCollectable(v52);
          v53 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v96, &v95, 1);
          if (v53)
            v54 = (const __CFDictionary *)CFRetain(v53);
          else
            v54 = 0;
          v55 = IOServiceAddMatchingNotification(v45, "IOServiceFirstMatch", v54, (IOServiceMatchingCallback)_ramrod_device_has_usbcretimer_callback, &refCon, (io_iterator_t *)&entryID);
          if (v55)
          {
            ramrod_log_msg("IOServiceAddMatchingNotification() failed with return %d", v56, v57, v58, v59, v60, v61, v62, v55);
          }
          else
          {
            -[NSMutableArray addObject:](v82, "addObject:", +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", entryID));
            v63 = IOIteratorNext(entryID);
            if (v63)
              ++refCon;
            IOObjectRelease(v63);
          }
        }
        v48 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v2, "countByEnumeratingWithState:objects:count:", &v87, v97, 16);
      }
      while (v48);
    }
    Current = CFRunLoopGetCurrent();
    CFRunLoopAddSource(Current, source, kCFRunLoopDefaultMode);
    CFRunLoopRunInMode(kCFRunLoopDefaultMode, 5.0, 0);
    v65 = CFRunLoopGetCurrent();
    CFRunLoopRemoveSource(v65, source, kCFRunLoopDefaultMode);
    IONotificationPortDestroy(v45);
    v66 = (id)refCon;
    if (-[NSMutableArray count](v2, "count") != v66)
    {
      v67 = refCon;
      -[NSMutableArray count](v2, "count");
      ramrod_log_msg("Found only %d when we should have found %d\n", v68, v69, v70, v71, v72, v73, v74, v67);
    }
    v85 = 0u;
    v86 = 0u;
    v83 = 0u;
    v84 = 0u;
    v3 = v82;
    v75 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v82, "countByEnumeratingWithState:objects:count:", &v83, v94, 16);
    if (v75)
    {
      v76 = v75;
      v77 = *(_QWORD *)v84;
      do
      {
        for (j = 0; j != v76; j = (char *)j + 1)
        {
          if (*(_QWORD *)v84 != v77)
            objc_enumerationMutation(v82);
          IOObjectRelease((io_object_t)objc_msgSend(*(id *)(*((_QWORD *)&v83 + 1) + 8 * (_QWORD)j), "unsignedIntValue"));
        }
        v76 = -[NSMutableArray countByEnumeratingWithState:objects:count:](v82, "countByEnumeratingWithState:objects:count:", &v83, v94, 16);
      }
      while (v76);
    }
    v20 = refCon != 0;
    v2 = v46;
    v4 = v81;
  }
  else
  {
    v20 = 0;
  }
LABEL_10:

  if (v4)
    IOObjectRelease(v4);
  return v20;
}

BOOL ramrod_device_has_usbcretimer()
{
  return _ramrod_device_has_usbcretimer(CFSTR("atcrt")) || _ramrod_device_has_usbcretimer(CFSTR("uatcrt"));
}

BOOL ramrod_should_update_usbcretimer(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!a1)
    return ramrod_device_has_usbcretimer();
  ramrod_log_msg("Skipping checking retimer for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_should_update_usbcretimer_uarp(int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!a1)
    return _ramrod_device_has_usbcretimer(CFSTR("uatcrt"));
  ramrod_log_msg("Skipping checking retimer for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_device_has_ace3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *v14;
  unsigned int (*v15)(_QWORD, _QWORD);
  _BOOL8 v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  void *v25;

  v25 = 0;
  ramrod_log_msg("opening %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"/usr/lib/updaters/libAce3Updater.dylib");
  v8 = dlopen("/usr/lib/updaters/libAce3Updater.dylib", 261);
  if (!v8)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v17, v18, v19, v20, v21, v22, v23, (char)"/usr/lib/updaters/libAce3Updater.dylib");
    return 0;
  }
  v13 = ramrod_copy_updater_functions(v8, "Ace3", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v9, v10, v11, v12);
  v14 = v25;
  if (!v13)
  {
    v16 = 0;
    if (!v25)
      return v16;
    goto LABEL_5;
  }
  v15 = (unsigned int (*)(_QWORD, _QWORD))*((_QWORD *)v25 + 1);
  if (!v15)
  {
    v16 = 0;
    goto LABEL_5;
  }
  v16 = v15(0, 0) == 0;
  v14 = v25;
  if (v25)
LABEL_5:
    free(v14);
  return v16;
}

BOOL ramrod_should_update_ace3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!(_DWORD)a1)
    return ramrod_device_has_ace3(a1, a2, a3, a4, a5, a6, a7, a8);
  ramrod_log_msg("Skipping checking Ace3 for booted update\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

uint64_t ramrod_device_has_manta_mcu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const __CFDictionary *v8;
  io_service_t MatchingService;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  io_object_t v17;
  const __CFData *CFProperty;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFData *v26;
  CFTypeID TypeID;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  const char *v36;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  UInt8 v45;
  char Length;

  ramrod_log_msg("entering %s\n", a2, a3, a4, a5, a6, a7, a8, (char)"ramrod_device_has_manta_mcu");
  v8 = IOServiceNameMatching("manta-b");
  MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v8);
  if (MatchingService)
  {
    v17 = MatchingService;
    CFProperty = (const __CFData *)IORegistryEntryCreateCFProperty(MatchingService, CFSTR("supports-mcu-restore"), kCFAllocatorDefault, 0);
    if (CFProperty)
    {
      v26 = CFProperty;
      TypeID = CFDataGetTypeID();
      if (TypeID == CFGetTypeID(v26))
      {
        if (CFDataGetLength(v26) <= 0)
        {
          Length = CFDataGetLength(v26);
          ramrod_log_msg("supports-mcu-restore wrong length (%lu bytes)\n", v38, v39, v40, v41, v42, v43, v44, Length);
          goto LABEL_12;
        }
        if (*CFDataGetBytePtr(v26) == 1)
        {
          v35 = 1;
LABEL_13:
          IOObjectRelease(v17);
          CFRelease(v26);
          return v35;
        }
        v45 = *CFDataGetBytePtr(v26);
        v36 = "supports-mcu-restore is %u, the device does not support manta mcu restore time firmware update.\n";
      }
      else
      {
        v36 = "IORegistryEntryCreateCFProperty returned non CFDataRef for supports-mcu-restore property.\n";
      }
      ramrod_log_msg(v36, v28, v29, v30, v31, v32, v33, v34, v45);
LABEL_12:
      v35 = 0;
      goto LABEL_13;
    }
    ramrod_log_msg("manta-b ioregistry entry does not have supports-mcu-restore property, the device does not support manta mcu restore time firmware update.\n", v19, v20, v21, v22, v23, v24, v25, v45);
    IOObjectRelease(v17);
  }
  else
  {
    ramrod_log_msg("Could not find manta-b ioregistry entry, the device does not support manta mcu.\n", v10, v11, v12, v13, v14, v15, v16, v45);
  }
  return 0;
}

BOOL ramrod_should_update_manta_mcu(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char vars0;

  if (!(_DWORD)a1)
    return ramrod_device_has_manta_mcu(a1, a2, a3, a4, a5, a6, a7, a8) != 0;
  ramrod_log_msg("Skipping checking manta mcu for booted update.\n", a2, a3, a4, a5, a6, a7, a8, vars0);
  return 0;
}

BOOL ramrod_device_has_vinyl()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  void *v13;
  unsigned int (*v14)(_QWORD, uint64_t *);
  _BOOL8 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v24;
  void *v25;

  v24 = 0;
  v25 = 0;
  if (!ramrod_device_has_baseband())
    return 0;
  ramrod_log_msg("opening %s\n", v0, v1, v2, v3, v4, v5, v6, (char)"/usr/lib/updaters/libVinylUpdater.dylib");
  v7 = dlopen("/usr/lib/updaters/libVinylUpdater.dylib", 261);
  if (!v7)
  {
    dlerror();
    ramrod_log_msg("unable to open %s. %s, skipping step\n", v16, v17, v18, v19, v20, v21, v22, (char)"/usr/lib/updaters/libVinylUpdater.dylib");
    return 0;
  }
  v12 = ramrod_copy_updater_functions(v7, "Vinyl", (__CFDictionary *(***)(const __CFDictionary *, uint64_t, uint64_t, CFErrorRef *))&v25, 0, v8, v9, v10, v11);
  v13 = v25;
  if (!v12)
  {
    v15 = 0;
    if (!v25)
      return v15;
    goto LABEL_6;
  }
  v14 = (unsigned int (*)(_QWORD, uint64_t *))*((_QWORD *)v25 + 1);
  if (!v14)
  {
    v15 = 0;
    goto LABEL_6;
  }
  v15 = v14(0, &v24) == 0;
  v13 = v25;
  if (v25)
LABEL_6:
    free(v13);
  return v15;
}

BOOL ramrod_should_update_vinyl(int a1)
{
  return !a1 && ramrod_device_has_vinyl();
}

void sub_100096708()
{
  if ((ramrod_should_do_legacy_restored_behaviors() & 1) == 0 && qword_1001A8210 != -1)
    dispatch_once(&qword_1001A8210, &stru_100181830);
}

void sub_100096748(id a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  const char *v10;
  char v11;

  for (i = 0; i != 72; i += 6)
  {
    if (CFEqual(off_1001A75E8[i + 1], CFSTR("update_rose")))
    {
      v9 = os_variant_uses_ephemeral_storage("com.apple.MobileSoftwareUpdate");
      if (v9)
        v10 = "ramrod_update running in limited environment\n";
      else
        v10 = "ramrod_update running in normal env\n";
      ramrod_log_msg(v10, v2, v3, v4, v5, v6, v7, v8, v11);
      if (v9)
        BYTE1(off_1001A75E8[i + 4]) = 1;
    }
  }
}

uint64_t AMRestorePartitionFWCopyTagData(const __CFURL *a1, const __CFString *a2, CFTypeRef *a3, off_t *a4, CFTypeRef *a5, off_t *a6)
{
  void *v6;
  int v11;
  int v12;
  ssize_t v13;
  ssize_t v14;
  off_t v15;
  unsigned int v16;
  const __CFString *v17;
  int v18;
  void *v19;
  off_t v20;
  ssize_t v21;
  CFIndex v22;
  int v23;
  uint64_t v24;
  CFDataRef v25;
  off_t v27;
  int *v28;
  uint64_t v29;
  uint64_t v30;
  off_t *v31;
  CFTypeRef *v32;
  off_t *v33;
  off_t v34;
  char v35;
  CFDataRef cf;
  __int16 v38;
  size_t __size;
  _OWORD v40[6];
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  uint64_t v63;

  v6 = a1;
  __size = 0;
  v63 = 0;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  v43 = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  memset(v40, 0, sizeof(v40));
  if (!a1)
  {
    AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "inURL is NULL");
    v19 = 0;
LABEL_53:
    v25 = 0;
    v17 = 0;
    v24 = 99;
    goto LABEL_46;
  }
  v11 = sub_100096F34(a1, 0);
  if (!v11)
  {
    AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Unable to open inURL %@", v6);
    v19 = 0;
    v6 = 0;
    goto LABEL_53;
  }
  v12 = v11;
  v6 = malloc(0x8000uLL);
  if (v6)
  {
    v13 = read(v12, v6, 0x8000uLL);
    if (v13)
    {
      v14 = v13;
      v32 = a3;
      v33 = a6;
      v31 = a4;
      v35 = 0;
      v34 = 0;
      v15 = 0;
      v16 = 0;
      cf = 0;
      v17 = 0;
      while (1)
      {
        __size = 0;
        v18 = Img4DecodeParseLengthFromBuffer(v6, v14, &__size);
        if (v18 || !__size)
          break;
        v19 = malloc(__size);
        if (!v19)
        {
          AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "failed to allocate IMG4buffer", v29, v30);
          goto LABEL_25;
        }
        v20 = lseek(v12, v15, 0);
        if (v20 != v15)
        {
          v27 = v20;
          v28 = __error();
          AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Unable to rewind to start of IMG4 segment lseek=%ll, errno=%d.", v27, *v28);
          goto LABEL_25;
        }
        v21 = read(v12, v19, __size);
        if (!v21)
        {
          __error();
          AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "0 bytes read, IMG4 image hit end of block device? - fail errno=%d..");
          goto LABEL_25;
        }
        v22 = v21;
        if (v21 != __size)
        {
          AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Bytes read didn't match derLen.");
          goto LABEL_25;
        }
        v23 = Img4DecodeInit(v19, v21, v40);
        if (v23)
        {
          AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Item %02d, der.length=%8d, Bad Img4 inside valid DER sequence. (derstat=%d)", v16 + 1, v22, v23);
        }
        else
        {
          AMSupportSafeRelease(v17);
          v17 = CFStringCreateWithBytes(kCFAllocatorDefault, *((const UInt8 **)&v41 + 1), v42, 0x8000100u, 0);
          AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Item %02d, offset=%8d, der.length=%8d, img4Tag=[%@]", v16 + 1, v15, v22, v17);
          if (a2 && CFStringCompare(a2, v17, 0) == kCFCompareEqualTo)
          {
            AMSupportLogInternal(6, "AMRestorePartitionFWCopyTagData", "   ^^ Found requested tag.", v16 + 1, v22, v17);
            if (a5)
            {
              if (!cf)
              {
                cf = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)v19, v22);
                if (!cf)
                {
                  AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Failed to allocate Img4Data");
                  v25 = 0;
                  goto LABEL_60;
                }
              }
            }
            v35 = 1;
            v34 = v15;
          }
        }
        v15 += __size;
        AMSupportSafeFree(v19);
        v14 = read(v12, v6, 0x8000uLL);
        ++v16;
        if (!v14)
          goto LABEL_27;
      }
      AMSupportLogInternal(6, "AMRestorePartitionFWCopyTagData", "No more segments. (derstat=%d)", v18);
      if (!v16)
        goto LABEL_23;
LABEL_27:
      if (v16 >= 0x21)
      {
        AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Too Many DER segments!", v29, v30);
        goto LABEL_24;
      }
      if (lseek(v12, v15, 0) != v15)
      {
        __error();
        AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Unable to seek to terminator segment errno=%d.");
        goto LABEL_24;
      }
      v38 = -1;
      if (read(v12, &v38, 2uLL) != 2)
      {
        AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Failed to read terminator bytes.", v29, v30);
        goto LABEL_24;
      }
      if (v38 | HIBYTE(v38))
      {
        AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "Invalid termination bytes: [0x%02x, 0x%02x]");
        goto LABEL_24;
      }
      if ((a2 == 0) | v35 & 1)
        v24 = 0;
      else
        v24 = 8;
      if (v33)
        *v33 = v15;
      if (v31)
        *v31 = v34;
      v25 = cf;
      if (v32 && v17)
        *v32 = CFRetain(v17);
      v19 = 0;
      if (a5 && cf)
      {
        v19 = 0;
        *a5 = CFRetain(cf);
      }
    }
    else
    {
      cf = 0;
      v17 = 0;
LABEL_23:
      AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "No DER segments found.");
LABEL_24:
      v19 = 0;
LABEL_25:
      v24 = 99;
      v25 = cf;
    }
  }
  else
  {
    AMSupportLogInternal(3, "AMRestorePartitionFWCopyTagData", "failed to allocate DER chunk buffer");
    v17 = 0;
    v25 = 0;
    v19 = 0;
LABEL_60:
    v24 = 99;
  }
  if (v12 >= 1)
    close(v12);
LABEL_46:
  AMSupportSafeFree(v6);
  AMSupportSafeFree(v19);
  AMSupportSafeRelease(v17);
  AMSupportSafeRelease(v25);
  return v24;
}

uint64_t sub_100096F34(const __CFURL *a1, int a2)
{
  uint64_t v4;
  uint64_t v5;
  int *v7;
  char *v8;
  uint64_t v9;
  UInt8 buffer[1024];

  bzero(buffer, 0x400uLL);
  if (!CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
  {
    AMSupportLogInternal(3, "_AMRestorePartitionOpenFileWithURL", "failed to convert url to file system representation");
    AMSupportLogInternal(7, "_AMRestorePartitionOpenFileWithURL", "%@", a1);
    return 0xFFFFFFFFLL;
  }
  v4 = open((const char *)buffer, a2);
  v5 = v4;
  if ((int)v4 <= 0)
  {
    v7 = __error();
    v8 = strerror(*v7);
    AMSupportLogInternal(3, "_AMRestorePartitionOpenFileWithURL", "open() returned %d, %s", v5, v8);
    return v5;
  }
  if (fcntl(v4, 48, 1))
  {
    AMSupportLogInternal(3, "_AMRestorePartitionOpenFileWithURL", "Unable to set F_NOCACHE on firmware storage", v9);
    return 0xFFFFFFFFLL;
  }
  return v5;
}

void sub_1000976CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_1000976F4(unsigned int *a1)
{
  uint64_t result;
  uint64_t v2;
  _OWORD v3[5];

  result = *a1;
  if ((_DWORD)result)
  {
    result = IOObjectRelease(result);
    if ((_DWORD)result)
      sub_1000F9B18(&v2, v3);
  }
  return result;
}

uint64_t sub_10009786C(char *a1, const __CFString *a2)
{
  const __CFData *v4;
  const __CFData *v5;
  CFTypeID v6;
  const UInt8 *BytePtr;
  size_t Length;
  uint64_t v9;
  const char *v10;

  v4 = (const __CFData *)sub_100098134(a1, a2);
  if (v4)
  {
    v5 = v4;
    v6 = CFGetTypeID(v4);
    if (v6 != CFDataGetTypeID()
      || (BytePtr = CFDataGetBytePtr(v5), (Length = CFDataGetLength(v5)) != 0)
      && (Length > 4 || !memcmp(BytePtr, &unk_100163C78, Length)))
    {
      v9 = 0;
      v10 = "NO";
    }
    else
    {
      v9 = 1;
      v10 = "YES";
    }
    ramrod_log_msg_cf(CFSTR("Boot Firmware Updater: property_is_nonzero(%s, %@) = %s (%@)\n"), a1, a2, v10, v5);
    CFRelease(v5);
  }
  else
  {
    ramrod_log_msg_cf(CFSTR("Boot Firmware Updater: property_is_nonzero(%s, %@) = %s (%@)\n"), a1, a2, "NO", 0);
    return 0;
  }
  return v9;
}

BOOL sub_1000979B4(const __CFString *a1)
{
  CFTypeRef v2;
  CFTypeRef v3;
  const char *v4;

  v2 = sub_100098134("IODeviceTree:/defaults", a1);
  v3 = v2;
  if (v2)
  {
    CFRelease(v2);
    v4 = "YES";
  }
  else
  {
    v4 = "NO";
  }
  ramrod_log_msg_cf(CFSTR("Boot Firmware Updater: property_exists(%s, %@) = %s\n"), "IODeviceTree:/defaults", a1, v4);
  return v3 != 0;
}

void sub_100097F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a34, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100097F94(uint64_t a1, uint64_t a2, uint64_t a3, _BYTE *a4)
{
  uint64_t v7;
  uint64_t result;

  v7 = objc_opt_class(NSData);
  result = objc_opt_isKindOfClass(a2, v7);
  if ((result & 1) == 0)
  {
    *a4 = 1;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 0;
  }
  return result;
}

void sub_100097FF0(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 8);
}

void sub_100098000(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 32), 8);
}

CFTypeRef sub_100098134(char *path, const __CFString *a2)
{
  io_registry_entry_t v3;
  io_object_t v4;
  CFTypeRef CFProperty;

  v3 = IORegistryEntryFromPath(kIOMasterPortDefault, path);
  if (!v3)
    return 0;
  v4 = v3;
  CFProperty = IORegistryEntryCreateCFProperty(v3, a2, kCFAllocatorDefault, 0);
  IOObjectRelease(v4);
  return CFProperty;
}

uint64_t MSUBootFirmwareFindNamespace(io_registry_entry_t a1, uint64_t a2)
{
  CFMutableDictionaryRef v4;
  CFTypeRef v5;
  NSDictionary *v6;
  const __CFDictionary *v7;
  uint64_t entryID;
  uint64_t v10;
  NSNumber *v11;
  _QWORD v12[2];
  _QWORD v13[2];

  entryID = 0;
  IORegistryEntryGetRegistryEntryID(a1, &entryID);
  IOServiceWaitQuiet(a1, 0);
  v12[0] = CFSTR("IOParentMatch");
  v4 = IORegistryEntryIDMatching(entryID);
  v5 = (id)CFMakeCollectable(v4);
  v12[1] = CFSTR("IOPropertyMatch");
  v13[0] = v5;
  v10 = a2;
  v11 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 1);
  v13[1] = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", &v11, &v10, 1);
  v6 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v13, v12, 2);
  if (v6)
    v7 = (const __CFDictionary *)CFRetain(v6);
  else
    v7 = 0;
  return IOServiceGetMatchingService(kIOMasterPortDefault, v7);
}

uint64_t sub_10009A44C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  return _os_log_send_and_compose_impl(a1, v6, v5, 80, a5, v7, 16);
}

BOOL sub_10009A464()
{
  NSObject *v0;

  return os_log_type_enabled(v0, OS_LOG_TYPE_ERROR);
}

void sub_10009A588(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_10009A5B0(unsigned int *a1)
{
  uint64_t result;
  uint64_t v2;
  _OWORD v3[5];

  result = *a1;
  if ((_DWORD)result)
  {
    result = IOObjectRelease(result);
    if ((_DWORD)result)
      sub_1000F9C38(&v2, v3);
  }
  return result;
}

void sub_10009A970(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t sub_10009A998(unsigned int *a1)
{
  uint64_t result;
  uint64_t v2;
  _OWORD v3[5];

  result = *a1;
  if ((_DWORD)result)
  {
    result = IOServiceClose(result);
    if ((_DWORD)result)
      sub_1000F9D3C(&v2, v3);
  }
  return result;
}

double sub_10009AA40(_QWORD *a1, _OWORD *a2)
{
  double result;

  *a1 = 0;
  result = 0.0;
  a2[3] = 0u;
  a2[4] = 0u;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  return result;
}

uint64_t sub_10009AA58(uint64_t a1)
{
  _QWORD *v1;

  return _os_crash_msg(*v1, a1);
}

void iBU_LOG_real(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v10;
  void *v11;
  const char *v12;

  v10 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", a1, &a9);
  v11 = v10;
  if (off_1001A8218)
  {
    v12 = (const char *)objc_msgSend(v10, "UTF8String");
    off_1001A8218("%s: %s\n", a2, v12);
  }
  else
  {
    NSLog(CFSTR("%s: %@"), a2, v10);
  }

}

NSError *MSUBootFirmwareError(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  id v11;
  id *v12;
  NSErrorUserInfoKey *v13;
  uint64_t v14;
  NSErrorUserInfoKey v16;
  id v17;
  NSErrorUserInfoKey v18;
  NSErrorUserInfoKey v19;
  id v20;
  uint64_t v21;

  v11 = objc_msgSend(objc_alloc((Class)NSString), "initWithFormat:arguments:", a3, &a9);
  if (a2)
  {
    v18 = NSLocalizedDescriptionKey;
    v19 = NSUnderlyingErrorKey;
    v20 = v11;
    v21 = a2;
    v12 = &v20;
    v13 = &v18;
    v14 = 2;
  }
  else
  {
    v16 = NSLocalizedDescriptionKey;
    v17 = v11;
    v12 = &v17;
    v13 = &v16;
    v14 = 1;
  }
  return +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", CFSTR("MSUFirmwareUpdaterErrorDomain"), a1, +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v12, v13, v14, &a9, v16, v17, v18, v19, v20, v21));
}

BOOL sub_10009AD54(io_registry_entry_t a1)
{
  CFTypeRef CFProperty;
  CFTypeRef v2;

  CFProperty = IORegistryEntryCreateCFProperty(a1, CFSTR("low-level-fw-device-info"), 0, 0);
  v2 = CFProperty;
  if (CFProperty)
    CFRelease(CFProperty);
  return v2 != 0;
}

void sub_10009E1C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, int a9, unsigned int a10)
{
  sub_10009E1E4(&a10);
  _Unwind_Resume(a1);
}

uint64_t sub_10009E1E4(unsigned int *a1)
{
  uint64_t result;
  uint64_t v2;
  _OWORD v3[5];

  result = *a1;
  if ((_DWORD)result)
  {
    result = IOObjectRelease(result);
    if ((_DWORD)result)
      sub_1000F9E48(&v2, v3);
  }
  return result;
}

void sub_10009E2E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, int a10, char a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t DERDecodeItem(uint64_t a1, unint64_t *a2)
{
  return DERDecodeItemPartialBufferGetLength(a1, a2, 0);
}

uint64_t DERDecodeItemPartialBufferGetLength(uint64_t result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  _BYTE *v4;
  _BYTE *v5;
  unsigned __int8 *v6;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  BOOL v10;
  unint64_t v11;
  char *v12;
  unsigned __int8 v13;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unsigned int v24;
  BOOL v25;
  char v26;
  unint64_t v27;
  _BYTE *v28;

  v3 = *(_QWORD *)(result + 8);
  if (v3 < 2)
    return 3;
  v4 = *(_BYTE **)result;
  if (*(_QWORD *)result == -1)
    goto LABEL_68;
  v5 = &v4[v3];
  v6 = v4 + 1;
  v7 = v3 - 1;
  v8 = *v4 & 0x1F;
  if ((*v4 & 0x1F) != 0x1F)
  {
    v12 = v4 + 1;
LABEL_20:
    *a2 = v8 | ((unint64_t)(*v4 & 0xE0) << 56);
    if (v12 != (char *)-1)
    {
      if (v12 >= v5 || v12 < v4)
        goto LABEL_69;
      v14 = v12 + 1;
      v15 = *v12;
      v16 = v7 - 1;
      if ((*v12 & 0x80000000) == 0)
      {
        if (a3 || v16 >= v15)
        {
          if (v16 >= v15)
            v17 = *v12;
          else
            v17 = v7 - 1;
          v10 = v5 >= v14;
          v18 = v5 - v14;
          if (v10 && v4 <= v14 && v17 <= v18)
          {
            a2[1] = (unint64_t)v14;
            a2[2] = v17;
            if (!a3)
              return 0;
LABEL_34:
            result = 0;
            *a3 = v15;
            return result;
          }
LABEL_69:
          __break(0x5519u);
LABEL_70:
          __break(0x5515u);
          return result;
        }
        return 3;
      }
      v19 = v15 & 0x7F;
      if ((v15 & 0x7F) > 8)
        return 3;
      if ((v15 & 0x7F) == 0 || v16 < v19)
        return 3;
      if (v14 >= v5 || v14 < v4)
        goto LABEL_69;
      if (!*v14)
        return 3;
      v15 = 0;
      v21 = (v19 - 1);
      v22 = v7 - v21 - 2;
      v23 = (unint64_t)&v12[v21 + 2];
      while (v14 != (_BYTE *)-1)
      {
        if (v14 >= v5)
          goto LABEL_69;
        v10 = v16-- != 0;
        if (!v10)
          goto LABEL_70;
        v24 = *v14++;
        v15 = (v15 << 8) | v24;
        LODWORD(v19) = v19 - 1;
        if (!(_DWORD)v19)
        {
          if (a3)
            v25 = 0;
          else
            v25 = v15 > v22;
          v26 = v25;
          result = 3;
          if (v15 < 0x80 || (v26 & 1) != 0)
            return result;
          if (v15 >= v22)
            v27 = v22;
          else
            v27 = v15;
          v10 = (unint64_t)v5 >= v23;
          v28 = &v5[-v23];
          if (!v10 || (unint64_t)v4 > v23 || v27 > (unint64_t)v28)
            goto LABEL_69;
          a2[1] = v23;
          a2[2] = v27;
          if (a3)
            goto LABEL_34;
          return 0;
        }
      }
    }
LABEL_68:
    __break(0x5513u);
    goto LABEL_69;
  }
  v9 = *v6;
  v10 = v9 != 128 && v9 >= 0x1F;
  if (!v10)
    return 3;
  v8 = 0;
  result = 3;
  while (v7 >= 2)
  {
    v11 = v8;
    if (v8 >> 57)
      break;
    if (v6 == (unsigned __int8 *)-1)
      goto LABEL_68;
    if (v6 >= v5 || v6 < v4)
      goto LABEL_69;
    v12 = (char *)(v6 + 1);
    --v7;
    v13 = *v6;
    v8 = *v6++ & 0x7F | (v8 << 7);
    if ((v13 & 0x80) == 0)
    {
      if (v11 >> 54)
        return 3;
      goto LABEL_20;
    }
  }
  return result;
}

uint64_t DERParseBoolean(unsigned __int8 **a1, BOOL *a2)
{
  int v2;
  uint64_t result;

  if (a1[1] != (unsigned __int8 *)1)
    return 3;
  v2 = **a1;
  if (v2 != 255 && v2 != 0)
    return 3;
  result = 0;
  *a2 = v2 != 0;
  return result;
}

uint64_t DERParseInteger(char **a1, _DWORD *a2)
{
  uint64_t result;
  unint64_t v4;

  v4 = 0xAAAAAAAAAAAAAAAALL;
  result = DERParseInteger64(a1, &v4);
  if (!(_DWORD)result)
  {
    if (HIDWORD(v4))
    {
      return 7;
    }
    else
    {
      result = 0;
      *a2 = v4;
    }
  }
  return result;
}

uint64_t DERParseInteger64(char **a1, unint64_t *a2)
{
  unint64_t v2;
  unsigned __int8 *v3;
  uint64_t result;
  unint64_t v5;
  unsigned int v6;

  v2 = (unint64_t)a1[1];
  if (!v2)
    return 3;
  v3 = (unsigned __int8 *)*a1;
  if (**a1 < 0)
    return 3;
  if (**a1)
  {
    if (v2 > 8)
      return 7;
    goto LABEL_10;
  }
  if (v2 >= 2)
  {
    if (((char)v3[1] & 0x80000000) == 0)
      return 3;
    if (v2 > 9)
      return 7;
  }
LABEL_10:
  v5 = 0;
  do
  {
    v6 = *v3++;
    v5 = v6 | (v5 << 8);
    --v2;
  }
  while (v2);
  result = 0;
  *a2 = v5;
  return result;
}

uint64_t DERDecodeSeqInit(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  uint64_t result;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8[3];

  memset(v8, 170, sizeof(v8));
  result = DERDecodeItemPartialBufferGetLength(a1, v8, 0);
  if (!(_DWORD)result)
  {
    v6 = v8[0];
    *a2 = v8[0];
    if (v6 >> 1 == 0x1000000000000008)
    {
      if (__CFADD__(v8[1], v8[2]))
      {
        __break(0x5513u);
      }
      else
      {
        v7 = v8[1] + v8[2];
        if (v8[1] <= v8[1] + v8[2])
        {
          result = 0;
          *a3 = v8[1];
          a3[1] = v7;
          return result;
        }
      }
      __break(0x5519u);
    }
    else
    {
      return 2;
    }
  }
  return result;
}

unint64_t *DERDecodeSeqContentInit(unint64_t *result, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = *result;
  v3 = result[1];
  if (__CFADD__(*result, v3))
  {
    __break(0x5513u);
  }
  else
  {
    v4 = v2 + v3;
    if (v2 <= v4)
    {
      *a2 = v2;
      a2[1] = v4;
      return 0;
    }
  }
  __break(0x5519u);
  return result;
}

uint64_t DERDecodeSeqNext(unint64_t *a1, unint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD v10[2];

  v10[0] = 0;
  v2 = *a1;
  v3 = a1[1];
  if (*a1 >= v3)
    return 1;
  v10[0] = *a1;
  v10[1] = v3 - v2;
  result = DERDecodeItemPartialBufferGetLength((uint64_t)v10, a2, 0);
  if (!(_DWORD)result)
  {
    v8 = a2[1];
    v7 = a2[2];
    if (!__CFADD__(v8, v7))
    {
      v9 = v8 + v7;
      if (v9 <= a1[1] && *a1 <= v9)
      {
        result = 0;
        *a1 = v9;
        return result;
      }
      __break(0x5519u);
    }
    __break(0x5513u);
  }
  return result;
}

uint64_t DERParseSequenceToObject(uint64_t a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  uint64_t result;
  unint64_t v12[3];

  memset(v12, 170, sizeof(v12));
  result = DERDecodeItemPartialBufferGetLength(a1, v12, 0);
  if (!(_DWORD)result)
  {
    if (v12[0] == 0x2000000000000010)
      return DERParseSequenceContentToObject(&v12[1], a2, a3, a4, a5, a6);
    else
      return 2;
  }
  return result;
}

uint64_t DERParseSequenceContentToObject(unint64_t *a1, unsigned int a2, uint64_t a3, unint64_t a4, unint64_t a5, size_t a6)
{
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int16 v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t result;
  unsigned __int16 v17;
  __int16 v18;
  unint64_t v19;
  char *v21;
  uint64_t v23;
  unint64_t v24;
  __int16 *v25;
  unint64_t v26;
  __int16 v27;
  unint64_t v28;
  char *v29;
  unint64_t v31[3];
  unint64_t v32;
  unint64_t v33;

  v32 = 0;
  if (a6)
  {
    if (a6 > a5)
      goto LABEL_59;
    bzero((void *)a4, a6);
  }
  v10 = *a1;
  v11 = a1[1];
  if (__CFADD__(*a1, v11))
    goto LABEL_58;
  v12 = v10 + v11;
  if (v10 > v12)
LABEL_59:
    __break(0x5519u);
  v32 = *a1;
  v33 = v12;
  if (a2)
  {
    v13 = 0;
    v29 = (char *)(a4 + a5);
    while (1)
    {
      memset(v31, 170, sizeof(v31));
      v15 = v32;
      v14 = v33;
      result = DERDecodeSeqNext(&v32, v31);
      if ((_DWORD)result)
        break;
      if (a2 <= v13)
        return 2;
      while (1)
      {
        if (24 * (__int16)v13 > (unint64_t)~a3)
          goto LABEL_58;
        v17 = v13;
        v18 = *(_WORD *)(a3 + 24 * v13 + 16);
        if ((v18 & 2) != 0 || v31[0] == *(_QWORD *)(a3 + 24 * v13 + 8))
          break;
        result = 2;
        if ((v18 & 1) != 0)
        {
          ++v13;
          if (a2 > (unsigned __int16)(v17 + 1))
            continue;
        }
        return result;
      }
      if ((v18 & 4) == 0)
      {
        v19 = *(_QWORD *)(a3 + 24 * v13);
        if (v19 > 0xFFFFFFFFFFFFFFEFLL || v19 + 16 > a5)
          return 7;
        if (v19 > ~a4)
          goto LABEL_58;
        v21 = (char *)(a4 + v19);
        if (v21 >= v29 || (unint64_t)v21 < a4)
          goto LABEL_59;
        *(_OWORD *)v21 = *(_OWORD *)&v31[1];
        if ((v18 & 8) != 0)
        {
          if (v15 >= v31[1])
          {
            if (v21 + 16 <= v29 && v14 >= v15 && *((_QWORD *)v21 + 1) <= v14 - v15)
            {
              *(_QWORD *)v21 = v15;
              return 3;
            }
            goto LABEL_59;
          }
          if (v21 + 16 > v29)
            goto LABEL_59;
          v23 = *((_QWORD *)v21 + 1);
          v24 = v23 + v31[1] - v15;
          if (__CFADD__(v23, v31[1] - v15))
          {
            __break(0x5500u);
            return result;
          }
          if (v14 < v15 || v24 > v14 - v15)
            goto LABEL_59;
          *(_QWORD *)v21 = v15;
          *((_QWORD *)v21 + 1) = v24;
        }
      }
      ++v13;
      if (a2 == (unsigned __int16)(v17 + 1))
      {
        if (!__CFADD__(v31[1], v31[2]))
        {
          v28 = a1[1];
          if (!__CFADD__(*a1, v28))
          {
            v10 = v31[1] + v31[2];
            v12 = *a1 + v28;
            goto LABEL_47;
          }
        }
LABEL_58:
        __break(0x5513u);
        goto LABEL_59;
      }
      if (a2 <= (unsigned __int16)(v17 + 1))
      {
        v10 = v32;
        v12 = v33;
        goto LABEL_47;
      }
    }
    if ((_DWORD)result == 1)
    {
      if (a2 <= v13)
      {
        return 0;
      }
      else
      {
        v25 = (__int16 *)(a3 + 24 * v13 + 16);
        v26 = a2 - (unint64_t)v13;
        result = 0;
        while (1)
        {
          v27 = *v25;
          v25 += 12;
          if ((v27 & 1) == 0)
            break;
          if (!--v26)
            return result;
        }
        return 5;
      }
    }
  }
  else
  {
LABEL_47:
    if (v10 == v12)
      return 0;
    else
      return 3;
  }
  return result;
}

uint64_t DERParseSequence(uint64_t result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return DERParseSequenceToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

unint64_t *DERParseSequenceContent(unint64_t *result, unsigned int a2, uint64_t a3, unint64_t a4, size_t a5)
{
  if ((a4 | 0x7FFFFFFFFFFFFFFFLL) >= a4)
    return (unint64_t *)DERParseSequenceContentToObject(result, a2, a3, a4, ~a4 & 0x7FFFFFFFFFFFFFFFLL, a5);
  __break(0x5519u);
  return result;
}

uint64_t AMAuthInstallCreate(const __CFAllocator *a1)
{
  CFMutableDictionaryRef v2;
  CFMutableDictionaryRef v3;
  CFMutableDictionaryRef v4;
  CFMutableDictionaryRef v5;
  CFMutableDictionaryRef v6;
  CFMutableDictionaryRef v7;
  CFMutableDictionaryRef v8;
  CFMutableDictionaryRef v9;
  uint64_t Instance;
  uint64_t v11;
  void *v12;
  CFTypeRef v13;
  uint64_t v14;
  CFMutableDictionaryRef Mutable;
  CFMutableDictionaryRef v17;
  CFURLRef v18;
  CFURLRef v19;
  CFURLRef cf;

  pthread_once(&stru_1001A7828, (void (*)(void))sub_10009F964);
  Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable || (cf = CFURLCreateWithString(a1, CFSTR("https://gs.apple.com:443/"), 0)) == 0)
  {
    v11 = 0;
    cf = 0;
LABEL_21:
    v19 = 0;
LABEL_23:
    v18 = 0;
LABEL_25:
    v17 = 0;
    v2 = 0;
LABEL_26:
    v3 = 0;
LABEL_27:
    v4 = 0;
LABEL_28:
    v5 = 0;
LABEL_29:
    v6 = 0;
LABEL_30:
    v7 = 0;
LABEL_31:
    v8 = 0;
LABEL_32:
    v9 = 0;
    goto LABEL_18;
  }
  v19 = CFURLCreateWithString(a1, CFSTR("http://vega-dr.apple.com:8080/vegads/fuser"), 0);
  if (!v19)
  {
    v11 = 0;
    goto LABEL_21;
  }
  v18 = CFURLCreateWithString(a1, CFSTR("http://treecko-dr.apple.com:8080/TREECKO/controller"), 0);
  if (!v18)
  {
    v11 = 0;
    goto LABEL_23;
  }
  v17 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v17)
  {
    v11 = 0;
    goto LABEL_25;
  }
  v2 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v2)
  {
    v11 = 0;
    goto LABEL_26;
  }
  v3 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v3)
  {
    v11 = 0;
    goto LABEL_27;
  }
  v4 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v4)
  {
    v11 = 0;
    goto LABEL_28;
  }
  v5 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v5)
  {
    v11 = 0;
    goto LABEL_29;
  }
  v6 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v6)
  {
    v11 = 0;
    goto LABEL_30;
  }
  v7 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v7)
  {
    v11 = 0;
    goto LABEL_31;
  }
  v8 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v8)
  {
    v11 = 0;
    goto LABEL_32;
  }
  v9 = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (v9)
  {
    Instance = _CFRuntimeCreateInstance(a1, qword_1001A8220, 512, 0);
    v11 = Instance;
    if (Instance)
    {
      *(_OWORD *)(Instance + 496) = 0u;
      *(_OWORD *)(Instance + 512) = 0u;
      *(_OWORD *)(Instance + 464) = 0u;
      *(_OWORD *)(Instance + 480) = 0u;
      *(_OWORD *)(Instance + 432) = 0u;
      *(_OWORD *)(Instance + 448) = 0u;
      *(_OWORD *)(Instance + 400) = 0u;
      *(_OWORD *)(Instance + 416) = 0u;
      *(_OWORD *)(Instance + 368) = 0u;
      *(_OWORD *)(Instance + 384) = 0u;
      *(_OWORD *)(Instance + 336) = 0u;
      *(_OWORD *)(Instance + 352) = 0u;
      *(_OWORD *)(Instance + 304) = 0u;
      *(_OWORD *)(Instance + 320) = 0u;
      *(_OWORD *)(Instance + 272) = 0u;
      *(_OWORD *)(Instance + 288) = 0u;
      *(_OWORD *)(Instance + 240) = 0u;
      *(_OWORD *)(Instance + 256) = 0u;
      *(_OWORD *)(Instance + 208) = 0u;
      *(_OWORD *)(Instance + 224) = 0u;
      *(_OWORD *)(Instance + 176) = 0u;
      *(_OWORD *)(Instance + 192) = 0u;
      *(_OWORD *)(Instance + 144) = 0u;
      *(_OWORD *)(Instance + 160) = 0u;
      *(_OWORD *)(Instance + 112) = 0u;
      *(_OWORD *)(Instance + 128) = 0u;
      *(_OWORD *)(Instance + 80) = 0u;
      *(_OWORD *)(Instance + 96) = 0u;
      *(_OWORD *)(Instance + 48) = 0u;
      *(_OWORD *)(Instance + 64) = 0u;
      *(_OWORD *)(Instance + 16) = 0u;
      *(_OWORD *)(Instance + 32) = 0u;
      *(_BYTE *)(Instance + 520) = 0;
      *(_WORD *)(Instance + 57) = 257;
      *(_QWORD *)(Instance + 72) = CFRetain(cf);
      *(_DWORD *)(v11 + 80) = 3;
      *(_QWORD *)(v11 + 352) = CFRetain(Mutable);
      *(_QWORD *)(v11 + 376) = CFRetain(v17);
      *(_QWORD *)(v11 + 384) = CFRetain(v2);
      *(_QWORD *)(v11 + 416) = CFRetain(v3);
      *(_QWORD *)(v11 + 160) = CFRetain(v19);
      *(_QWORD *)(v11 + 296) = CFRetain(v18);
      *(_QWORD *)(v11 + 88) = CFSTR("ApImg4Ticket");
      *(_QWORD *)(v11 + 200) = CFRetain(v4);
      *(_QWORD *)(v11 + 208) = CFRetain(v5);
      *(_QWORD *)(v11 + 216) = CFRetain(v6);
      v12 = calloc(1uLL, 0x30uLL);
      *(_QWORD *)(v11 + 128) = v12;
      if (v12)
      {
        v13 = CFRetain(v7);
        v14 = *(_QWORD *)(v11 + 128);
        *(_QWORD *)v14 = v13;
        *(_QWORD *)(v14 + 40) = 0;
        *(_OWORD *)(v14 + 24) = 0u;
        *(_OWORD *)(v14 + 8) = 0u;
        *(_QWORD *)(v11 + 496) = 0;
        *(_BYTE *)(v11 + 504) = 0;
        *(_QWORD *)(v11 + 440) = sub_10009F694;
        *(_QWORD *)(v11 + 448) = sub_10009F69C;
        *(_QWORD *)(v11 + 456) = CFRetain(v8);
        *(_QWORD *)(v11 + 464) = CFRetain(v9);
        *(_QWORD *)(v11 + 488) = 0;
        *(_QWORD *)(v11 + 512) = 0;
        *(_QWORD *)(v11 + 360) = AMAuthInstallLockCreate((uint64_t)a1);
      }
      else
      {
        sub_10009F54C(v11);
      }
    }
  }
  else
  {
    v11 = 0;
  }
LABEL_18:
  SafeRelease(Mutable);
  SafeRelease(cf);
  SafeRelease(v19);
  SafeRelease(v18);
  SafeRelease(v17);
  SafeRelease(v2);
  SafeRelease(v3);
  SafeRelease(0);
  SafeRelease(v4);
  SafeRelease(v5);
  SafeRelease(v6);
  SafeRelease(v7);
  SafeRelease(v8);
  SafeRelease(v9);
  return v11;
}

double sub_10009F54C(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double result;

  if (!a1)
    sub_1000F9F64();
  if (!*(_BYTE *)(a1 + 520))
  {
    *(_BYTE *)(a1 + 520) = 1;
    AMAuthInstallApFinalize(a1);
    AMAuthInstallBasebandFinalize(a1, v2, v3, v4, v5, v6, v7, v8);
    AMAuthInstallBundleFinalize(a1);
    SafeRelease(*(CFTypeRef *)(a1 + 120));
    SafeRelease(*(CFTypeRef *)(a1 + 376));
    SafeRelease(*(CFTypeRef *)(a1 + 384));
    SafeRelease(*(CFTypeRef *)(a1 + 416));
    SafeRelease(*(CFTypeRef *)(a1 + 336));
    SafeRelease(*(CFTypeRef *)(a1 + 96));
    SafeRelease(*(CFTypeRef *)(a1 + 72));
    SafeRelease(*(CFTypeRef *)(a1 + 88));
    SafeRelease(*(CFTypeRef *)(a1 + 64));
    SafeRelease(*(CFTypeRef *)(a1 + 352));
    SafeRelease(*(CFTypeRef *)(a1 + 296));
    SafeRelease(*(CFTypeRef *)(a1 + 312));
    SafeRelease(*(CFTypeRef *)(a1 + 320));
    SafeRelease(*(CFTypeRef *)(a1 + 424));
    SafeRelease(*(CFTypeRef *)(a1 + 456));
    SafeRelease(*(CFTypeRef *)(a1 + 464));
    SafeRelease(*(CFTypeRef *)(a1 + 472));
    SafeRelease(*(CFTypeRef *)(a1 + 480));
    SafeRelease(*(CFTypeRef *)(a1 + 496));
    SafeRelease(*(CFTypeRef *)(a1 + 40));
    SafeRelease(*(CFTypeRef *)(a1 + 512));
    SafeRelease(*(CFTypeRef *)(a1 + 360));
    SafeRelease(*(CFTypeRef *)(a1 + 488));
    result = 0.0;
    *(_OWORD *)(a1 + 496) = 0u;
    *(_OWORD *)(a1 + 512) = 0u;
    *(_OWORD *)(a1 + 464) = 0u;
    *(_OWORD *)(a1 + 480) = 0u;
    *(_OWORD *)(a1 + 432) = 0u;
    *(_OWORD *)(a1 + 448) = 0u;
    *(_OWORD *)(a1 + 400) = 0u;
    *(_OWORD *)(a1 + 416) = 0u;
    *(_OWORD *)(a1 + 368) = 0u;
    *(_OWORD *)(a1 + 384) = 0u;
    *(_OWORD *)(a1 + 336) = 0u;
    *(_OWORD *)(a1 + 352) = 0u;
    *(_OWORD *)(a1 + 304) = 0u;
    *(_OWORD *)(a1 + 320) = 0u;
    *(_OWORD *)(a1 + 272) = 0u;
    *(_OWORD *)(a1 + 288) = 0u;
    *(_OWORD *)(a1 + 240) = 0u;
    *(_OWORD *)(a1 + 256) = 0u;
    *(_OWORD *)(a1 + 208) = 0u;
    *(_OWORD *)(a1 + 224) = 0u;
    *(_OWORD *)(a1 + 176) = 0u;
    *(_OWORD *)(a1 + 192) = 0u;
    *(_OWORD *)(a1 + 144) = 0u;
    *(_OWORD *)(a1 + 160) = 0u;
    *(_OWORD *)(a1 + 112) = 0u;
    *(_OWORD *)(a1 + 128) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 96) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
  }
  return result;
}

uint64_t sub_10009F694()
{
  return 1;
}

uint64_t sub_10009F69C()
{
  return 1;
}

const __CFString *AMAuthInstallGetLocalizedStatusString(CFDictionaryRef *cf, int a2)
{
  const __CFString *Value;
  const __CFAllocator *v4;
  CFNumberRef v5;
  CFNumberRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int valuePtr;

  valuePtr = a2;
  if (a2 > 98)
  {
    switch(a2)
    {
      case 3500:
        Value = CFSTR("The signing server returned an internal error");
        break;
      case 3501:
        Value = CFSTR("You must authorize with the signing server before making this request");
        break;
      case 3502:
      case 3505:
      case 3506:
        goto LABEL_34;
      case 3503:
        Value = CFSTR("You are not authorized to make this request. Please check your device or credentials");
        break;
      case 3504:
        Value = CFSTR("The signing server could not find the resource requested");
        break;
      case 3507:
        Value = CFSTR("You must authorize with a proxy server before making this request");
        break;
      default:
        if (a2 == 99)
        {
          Value = CFSTR("Generic");
        }
        else if (a2 == 3194)
        {
          Value = CFSTR("Declined to authorize this image on this device for this user.");
        }
        else
        {
LABEL_34:
          Value = &stru_1001856C8;
          if (cf)
          {
            if ((a2 - 3100) <= 0x383)
            {
              v4 = CFGetAllocator(cf);
              v5 = CFNumberCreate(v4, kCFNumberIntType, &valuePtr);
              if (v5)
              {
                v6 = v5;
                Value = (const __CFString *)CFDictionaryGetValue(cf[44], v5);
                CFRelease(v6);
                if (!Value)
                  AMAuthInstallLog(7, "AMAuthInstallGetLocalizedStatusString", "no cached text for tss error code %d", v7, v8, v9, v10, v11, valuePtr);
              }
            }
          }
        }
        break;
    }
  }
  else
  {
    Value = CFSTR("No error");
    switch(a2)
    {
      case 0:
        return Value;
      case 1:
        Value = CFSTR("Bad parameter");
        break;
      case 2:
        Value = CFSTR("Allocation error");
        break;
      case 3:
        Value = CFSTR("Conversion error");
        break;
      case 4:
        Value = CFSTR("File error");
        break;
      case 5:
        Value = CFSTR("Hash error");
        break;
      case 6:
        Value = CFSTR("Crypto error");
        break;
      case 7:
        Value = CFSTR("Bad build identity");
        break;
      case 8:
        Value = CFSTR("Entry not found");
        break;
      case 9:
        Value = CFSTR("Invalid img3 object");
        break;
      case 10:
        Value = CFSTR("Invalid bbfw object");
        break;
      case 11:
        Value = CFSTR("Server not reachable");
        break;
      case 12:
        Value = CFSTR("Server timed out");
        break;
      case 13:
        Value = CFSTR("Unimplemented");
        break;
      case 14:
        Value = CFSTR("Internal error");
        break;
      case 15:
        Value = CFSTR("Invalid bbfw file");
        break;
      case 16:
        Value = CFSTR("Network error");
        break;
      case 17:
        Value = CFSTR("Bad response");
        break;
      case 18:
        Value = CFSTR("Fusing failed");
        break;
      case 19:
        Value = CFSTR("Baseband provisioning failed");
        break;
      case 20:
        Value = CFSTR("AppleConnect not found");
        break;
      case 21:
        Value = CFSTR("AppleConnect user canceled");
        break;
      case 22:
        Value = CFSTR("AppleConnect bad credentials");
        break;
      default:
        goto LABEL_34;
    }
  }
  return Value;
}

uint64_t AMAuthInstallSetSigningServerURL(uint64_t a1, const void *a2)
{
  uint64_t result;
  const void *v5;
  CFTypeRef v6;

  result = 1;
  if (a1 && a2)
  {
    v5 = *(const void **)(a1 + 72);
    if (v5 == a2)
    {
      return 0;
    }
    else
    {
      SafeRelease(v5);
      v6 = CFRetain(a2);
      result = 0;
      *(_QWORD *)(a1 + 72) = v6;
    }
  }
  return result;
}

uint64_t sub_10009F964()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100181888);
  qword_1001A8220 = result;
  return result;
}

CFStringRef sub_10009F988(uint64_t a1, const __CFDictionary *a2)
{
  __CFString *v4;
  __CFString *v5;
  const __CFAllocator *v6;
  uint64_t v7;
  const __CFString *v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *LibraryVersionString;
  uint64_t PlatformInfoString;
  CFStringRef v13;

  if (!a1)
    sub_1000F9F8C();
  v4 = AMAuthInstallApCopyDescription(a1);
  v5 = AMAuthInstallBasebandCopyDescription(a1);
  v6 = CFGetAllocator((CFTypeRef)a1);
  v7 = *(_QWORD *)(a1 + 72);
  if (*(_QWORD *)(a1 + 64))
    v8 = *(const __CFString **)(a1 + 64);
  else
    v8 = CFSTR("default");
  if (*(_BYTE *)(a1 + 56))
    v9 = CFSTR("YES");
  else
    v9 = CFSTR("NO");
  if (*(_QWORD *)(a1 + 104))
    v10 = CFSTR("YES");
  else
    v10 = CFSTR("NO");
  LibraryVersionString = AMAuthInstallSupportGetLibraryVersionString();
  PlatformInfoString = AMAuthInstallPlatformGetPlatformInfoString();
  v13 = CFStringCreateWithFormat(v6, a2, CFSTR("<AMAuthInstall %p>{ap=%@, bp=%@, UserAuth=%@, iTunes=%@, server=\"%@\", locale=%@, version=\"%@\", platform=%@}"), a1, v4, v5, v10, v9, v7, v8, LibraryVersionString, PlatformInfoString);
  SafeRelease(v4);
  SafeRelease(v5);
  return v13;
}

CFStringRef sub_10009FA80(uint64_t a1)
{
  return sub_10009F988(a1, 0);
}

uint64_t AMAuthInstallApSupportsLocalSigning(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v11;
  char v12;
  char v13;

  result = 1;
  if (a1 && a2)
  {
    v11 = *(_QWORD *)(a1 + 16);
    if (v11)
    {
      if (*(_BYTE *)(v11 + 96))
      {
        v12 = AMAuthInstallApImg4SupportsLocalSigning(a1);
LABEL_8:
        v13 = v12;
        result = 0;
        *a2 = v13;
        return result;
      }
    }
    else
    {
      AMAuthInstallLog(3, "AMAuthInstallApIsImg4", "%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    }
    v12 = AMAuthInstallApImg3SupportsLocalSigning();
    goto LABEL_8;
  }
  return result;
}

uint64_t AMAuthInstallApSupportsGlobalSigning(uint64_t a1, BOOL *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v11;
  BOOL v12;

  result = 1;
  if (a1 && a2)
  {
    v11 = *(_QWORD *)(a1 + 16);
    if (v11)
    {
      if (*(_BYTE *)(v11 + 96))
      {
        v12 = AMAuthInstallApImg4SupportsGlobalSigning(a1);
        result = 0;
        *a2 = v12;
        return result;
      }
    }
    else
    {
      AMAuthInstallLog(3, "AMAuthInstallApIsImg4", "%s: apParameters is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApIsImg4");
    }
    return 13;
  }
  return result;
}

__CFString *AMAuthInstallApCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  const char *v5;
  const char *v6;
  const char *v7;
  const char *v8;
  const char *v9;
  const char *v10;
  const char *v11;
  const char *v12;
  uint64_t v13;
  const __CFAllocator *v14;
  const char *v15;
  const __CFAllocator *v16;
  const char *v17;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 64);
  CFStringAppend(Mutable, CFSTR("("));
  v4 = *(_QWORD *)(a1 + 16);
  if (v4)
  {
    v5 = "YES";
    if (*(_BYTE *)(a1 + 57))
      v6 = "YES";
    else
      v6 = "NO";
    if (*(_BYTE *)(v4 + 20))
      v7 = "YES";
    else
      v7 = "NO";
    if (*(_BYTE *)(v4 + 81))
      v8 = "YES";
    else
      v8 = "NO";
    if (*(_BYTE *)(v4 + 72))
      v9 = "YES";
    else
      v9 = "NO";
    if (*(_BYTE *)(v4 + 82))
      v10 = "YES";
    else
      v10 = "NO";
    if (*(_BYTE *)(v4 + 96))
      v11 = "YES";
    else
      v11 = "NO";
    if (*(_QWORD *)(v4 + 120))
      v12 = "YES";
    else
      v12 = "NO";
    if (!*(_QWORD *)(v4 + 128))
      v5 = "NO";
    CFStringAppendFormat(Mutable, 0, CFSTR("personalize=%s %@ ecid=0x%llx, chipid=0x%x, boardid=0x%x, secDom=%d, isProduction=%s, EPRO=%s, isSecure=%s, ESEC=%s, img4=%s, demotionPolicy=%@, managedBaaCert=%s, slowRollBaaCert=%s, dpoc=%@"), v6, *(_QWORD *)(v4 + 104), *(_QWORD *)v4, *(unsigned int *)(v4 + 8), *(unsigned int *)(v4 + 12), *(unsigned int *)(v4 + 16), v7, v8, v9, v10, v11, *(_QWORD *)(v4 + 88), v12, v5, *(_QWORD *)(v4 + 192));
    v13 = *(_QWORD *)(a1 + 16);
    if (*(_QWORD *)(v13 + 24))
    {
      v14 = CFGetAllocator((CFTypeRef)a1);
      v15 = _CopyHexStringFromData(v14, *(CFDataRef *)(*(_QWORD *)(a1 + 16) + 24));
      CFStringAppendFormat(Mutable, 0, CFSTR(", nonce=0x%@"), v15);
      CFRelease(v15);
      v13 = *(_QWORD *)(a1 + 16);
    }
    if (*(_QWORD *)(v13 + 48))
    {
      v16 = CFGetAllocator((CFTypeRef)a1);
      v17 = _CopyHexStringFromData(v16, *(CFDataRef *)(*(_QWORD *)(a1 + 16) + 48));
      CFStringAppendFormat(Mutable, 0, CFSTR(", sepNonce=0x%@"), v17);
      CFRelease(v17);
    }
  }
  CFStringAppend(Mutable, CFSTR(")"));
  return Mutable;
}

void AMAuthInstallApFinalize(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 16);
  if (v2)
  {
    SafeRelease(*(CFTypeRef *)(v2 + 24));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 32));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 48));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 56));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 88));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 104));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 120));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 128));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 136));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 160));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 168));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 176));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 184));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 16) + 192));
    SafeFree(*(void **)(a1 + 16));
    *(_QWORD *)(a1 + 16) = 0;
  }
  SafeRelease(*(CFTypeRef *)(a1 + 24));
  *(_QWORD *)(a1 + 24) = 0;
}

uint64_t AMAuthInstallApRemoveInfoDict(const __CFAllocator *a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  const __CFDictionary *v3;
  uint64_t v4;
  const void **v6;
  const void **v7;
  const __CFDictionary *MutableCopy;
  CFIndex Count;
  const void **v10;
  uint64_t v11;
  const void *v12;
  CFTypeID v13;

  v3 = 0;
  v4 = 1;
  if (theDict)
  {
    v6 = 0;
    v7 = 0;
    if (a3)
    {
      MutableCopy = CFDictionaryCreateMutableCopy(a1, 0, theDict);
      v3 = MutableCopy;
      if (MutableCopy)
      {
        Count = CFDictionaryGetCount(MutableCopy);
        v6 = (const void **)malloc(8 * Count);
        v10 = (const void **)malloc(8 * Count);
        v7 = v10;
        v4 = 2;
        if (v6 && v10)
        {
          CFDictionaryGetKeysAndValues(v3, v6, v10);
          if (Count < 1)
          {
LABEL_14:
            v4 = 0;
            *a3 = CFRetain(v3);
          }
          else
          {
            v11 = 0;
            while (v6[v11])
            {
              v12 = v7[v11];
              if (!v12)
                break;
              v13 = CFGetTypeID(v12);
              if (v13 == CFDictionaryGetTypeID() && CFDictionaryGetValue((CFDictionaryRef)v7[v11], CFSTR("Info")))
                CFDictionaryRemoveValue((CFMutableDictionaryRef)v7[v11], CFSTR("Info"));
              if (Count == ++v11)
                goto LABEL_14;
            }
            v4 = 1;
          }
        }
      }
      else
      {
        v6 = 0;
        v7 = 0;
        v4 = 2;
      }
    }
  }
  else
  {
    v6 = 0;
    v7 = 0;
  }
  SafeRelease(v3);
  SafeFree(v6);
  SafeFree(v7);
  return v4;
}

uint64_t AMAuthInstallApCreatePersonalizedResponse(uint64_t a1, CFDictionaryRef theDict, CFTypeRef *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  __CFDictionary *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL4 v29;
  _BYTE *v30;
  uint64_t SignedManifest;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  const __CFAllocator *v37;
  __CFDictionary *v38;
  char v39;
  const __CFAllocator *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v48;
  const void *v49;
  const __CFAllocator *v50;
  __CFDictionary *Mutable;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  const char *v57;
  const char *v58;
  const char *v59;
  char LocalizedStatusString;
  CFTypeRef v61;
  void *value;
  __int16 v63;

  v6 = CFDictionaryContainsKey(theDict, CFSTR("Ap,LocalPolicy"));
  v13 = 0;
  v63 = 0;
  v61 = 0;
  value = 0;
  v14 = 1;
  if (a1 && theDict && a3)
  {
    v15 = v6;
    if (AMAuthInstallApSupportsLocalSigning(a1, (_BYTE *)&v63 + 1, v7, v8, v9, v10, v11, v12))
      goto LABEL_30;
    v22 = AMAuthInstallApSupportsGlobalSigning(a1, (BOOL *)&v63, v16, v17, v18, v19, v20, v21);
    if ((_DWORD)v22 != 13)
    {
      v14 = v22;
      if ((_DWORD)v22)
        goto LABEL_30;
    }
    v28 = *(_QWORD *)(a1 + 16);
    if (v28)
    {
      v29 = *(_BYTE *)(v28 + 78) != 0;
      if (HIBYTE(v63) && *(_BYTE *)(v28 + 78))
      {
        AMAuthInstallLog(6, "_AMAuthInstallApCreatePersonalizedResponseInternal", "Forcing server signing\n", v23, v24, v25, v26, v27, LocalizedStatusString);
        LOBYTE(v29) = 1;
        goto LABEL_16;
      }
    }
    else
    {
      v29 = 0;
    }
    if (HIBYTE(v63) && !v29)
    {
      v30 = (_BYTE *)(a1 + 505);
      if (!*(_BYTE *)(a1 + 505))
        goto LABEL_20;
      goto LABEL_19;
    }
LABEL_16:
    if (!v15 || !*(_BYTE *)(a1 + 505))
    {
      if ((_BYTE)v63)
        v39 = v29;
      else
        v39 = 1;
      if ((v39 & 1) == 0)
      {
        v48 = (void *)CFRetain(*(CFTypeRef *)(a1 + 40));
        value = v48;
        if (v48)
        {
          v49 = v48;
          v50 = CFGetAllocator((CFTypeRef)a1);
          Mutable = CFDictionaryCreateMutable(v50, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          v13 = Mutable;
          if (Mutable)
          {
            CFDictionaryAddValue(Mutable, *(const void **)(a1 + 88), v49);
            *a3 = CFRetain(v13);
            AMAuthInstallLog(6, "_AMAuthInstallApCreatePersonalizedResponseInternal", "Using global signing", v52, v53, v54, v55, v56, LocalizedStatusString);
            v14 = 0;
            goto LABEL_31;
          }
          goto LABEL_46;
        }
        v58 = "global ticketData is NULL";
LABEL_45:
        AMAuthInstallLog(3, "_AMAuthInstallApCreatePersonalizedResponseInternal", v58, v32, v33, v34, v35, v36, LocalizedStatusString);
        v13 = 0;
        goto LABEL_46;
      }
      v40 = CFGetAllocator((CFTypeRef)a1);
      v41 = AMAuthInstallApRemoveInfoDict(v40, theDict, &v61);
      if ((_DWORD)v41)
      {
        v14 = v41;
        v59 = "could not remove info dicts from request";
      }
      else
      {
        v14 = AMAuthInstallRequestSendSync(a1, v61, a3);
        if (!(_DWORD)v14)
          goto LABEL_30;
        LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v14);
        v59 = "server request error: %@";
      }
      AMAuthInstallLog(3, "_AMAuthInstallApCreatePersonalizedResponseInternal", v59, v42, v43, v44, v45, v46, LocalizedStatusString);
      goto LABEL_30;
    }
    v30 = (_BYTE *)(a1 + 505);
    v28 = *(_QWORD *)(a1 + 16);
LABEL_19:
    *(_DWORD *)(v28 + 68) = 1;
    *(_DWORD *)(v28 + 112) = 384;
LABEL_20:
    SignedManifest = AMAuthInstallApImg4LocalCreateSignedManifest((_QWORD *)a1, theDict, 0, 0, 0, (CFTypeRef *)&value, v26, v27);
    if (!(_DWORD)SignedManifest)
    {
      if (value)
      {
        v37 = CFGetAllocator((CFTypeRef)a1);
        v38 = CFDictionaryCreateMutable(v37, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v13 = v38;
        if (v38)
        {
          CFDictionaryAddValue(v38, *(const void **)(a1 + 88), value);
          v14 = 0;
          *a3 = CFRetain(v13);
          goto LABEL_31;
        }
LABEL_46:
        v14 = 2;
        goto LABEL_31;
      }
      v58 = "ticketData is NULL";
      goto LABEL_45;
    }
    v14 = SignedManifest;
    if (*v30)
      v57 = "hacktivated";
    else
      v57 = "local";
    AMAuthInstallLog(3, "_AMAuthInstallApCreatePersonalizedResponseInternal", "failed to create a %s Img4 ticket", v32, v33, v34, v35, v36, (char)v57);
LABEL_30:
    v13 = 0;
  }
LABEL_31:
  SafeRelease(v13);
  SafeRelease(value);
  SafeRelease(v61);
  return v14;
}

uint64_t AMAuthInstallApImg3SupportsLocalSigning()
{
  return 0;
}

CFStringRef AMAuthInstallApImg4GetTypeForEntryName(CFStringRef theString1)
{
  uint64_t v2;
  __CFString *v3;

  v2 = 0;
  while (CFStringCompare(theString1, off_100181938[v2], 0))
  {
    v2 += 2;
    if (v2 == 200)
    {
      v3 = 0;
      goto LABEL_6;
    }
  }
  v3 = off_100181938[v2 + 1];
LABEL_6:
  if (v3)
    return v3;
  else
    return theString1;
}

uint64_t AMAuthInstallApImg4EncodeRestoreInfo(const __CFData *a1, CFDictionaryRef theDict, CFDataRef *a3)
{
  CFIndex Count;
  unsigned __int8 *BytePtr;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int EncodingWithTag;
  __CFDictionary *Mutable;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const char *v22;
  __CFData *v23;
  __CFData *v24;
  uint64_t v25;
  uint64_t v26;
  const UInt8 *v27;
  CFIndex v28;
  CFDataRef v29;
  const char *v31;
  char v32;
  const __CFDictionary *v33;
  UInt8 *v34;
  UInt8 *v35;
  CFMutableDictionaryRef v36;
  CFIndex v37;
  CFIndex length;
  uint64_t v39;
  UInt8 *bytes;
  int v41;
  unsigned int v42;
  _QWORD v43[2];

  v43[0] = 0;
  v43[1] = 0;
  v42 = 0;
  v41 = 0;
  v39 = 0;
  bytes = 0;
  v37 = 0;
  length = 0;
  v35 = 0;
  v36 = 0;
  v34 = 0;
  if (!a1 || !theDict || (Count = CFDictionaryGetCount(theDict), !a3) || Count < 1)
  {
    Mutable = 0;
    if (!a3)
    {
      v21 = 3;
      v26 = 0;
      v24 = 0;
      goto LABEL_21;
    }
    v24 = 0;
    v26 = 0;
    goto LABEL_32;
  }
  v42 = CFDataGetLength(a1);
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(a1);
  if (DERDecoderInitialize((uint64_t)v43, BytePtr, &v42, v42))
  {
    v31 = "DERDecoderInitialize top level failed";
LABEL_31:
    AMAuthInstallLog(3, "AMAuthInstallApImg4EncodeRestoreInfo", v31, v8, v9, v10, v11, v12, v32);
    Mutable = 0;
    v24 = 0;
    v26 = 0;
    goto LABEL_32;
  }
  if (DERDecoderGetDataWithTag((uint64_t)v43, 0, 0x10u, 1, &bytes, (_DWORD *)&length + 1, &v41))
  {
    v31 = "could not find im4p top level sequence";
    goto LABEL_31;
  }
  if (DERDecoderInitialize((uint64_t)v43, bytes, (unsigned int *)&length + 1, HIDWORD(length)))
  {
    v31 = "DERDecoderInitialize sequence failed";
    goto LABEL_31;
  }
  v41 = 3;
  EncodingWithTag = DERDecoderGetEncodingWithTag((uint64_t)v43, 2u, 1u, 1, &v39, &length, &v41);
  if (!EncodingWithTag)
  {
    HIDWORD(length) -= length;
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v36 = Mutable;
    if (AMAuthInstallApImg4DecodeRestoreInfo(a1, &v36))
    {
      v15 = AMAuthInstallApImg4EncodeRestoreDict(theDict, (uint64_t)&v35, (uint64_t)&v37 + 4);
      if (!(_DWORD)v15)
        goto LABEL_16;
      v21 = v15;
      v22 = "AMAuthInstallApImg4EncodeRestoreDict legacy failed";
    }
    else
    {
      v33 = 0;
      AMSupportCreateMergedDictionary(kCFAllocatorDefault, Mutable, theDict, &v33);
      if (v33)
      {
        v21 = AMAuthInstallApImg4EncodeRestoreDict(v33, (uint64_t)&v35, (uint64_t)&v37 + 4);
        SafeRelease(v33);
        if (!(_DWORD)v21)
          goto LABEL_16;
        v22 = "AMAuthInstallApImg4EncodeRestoreDict merged restoreInfo failed";
      }
      else
      {
        v21 = 0;
        v22 = "failed to create merged restore Info dictionary";
      }
    }
    AMAuthInstallLog(3, "AMAuthInstallApImg4EncodeRestoreInfo", v22, v16, v17, v18, v19, v20, v32);
    v26 = 0;
    v24 = 0;
    goto LABEL_21;
  }
  if (AMAuthInstallApImg4EncodeRestoreDict(theDict, (uint64_t)&v35, (uint64_t)&v37 + 4))
  {
    v31 = "AMAuthInstallApImg4EncodeRestoreDict failed";
    goto LABEL_31;
  }
  Mutable = 0;
LABEL_16:
  v23 = CFDataCreateMutable(0, 0);
  v24 = v23;
  if (!v23
    || (CFDataAppendBytes(v23, bytes, HIDWORD(length)),
        CFDataAppendBytes(v24, v35, HIDWORD(v37)),
        (v25 = DEREncoderCreate(0)) == 0))
  {
    v26 = 0;
    if (!EncodingWithTag)
    {
      v21 = 2;
      goto LABEL_21;
    }
LABEL_32:
    *a3 = 0;
    v21 = 3;
    goto LABEL_21;
  }
  v26 = v25;
  v27 = CFDataGetBytePtr(v24);
  v28 = CFDataGetLength(v24);
  if (DEREncoderAddData(v26, 0, 16, v27, v28, 1)
    || DEREncoderCreateEncodedBuffer(v26, &v34, &v37))
  {
    goto LABEL_32;
  }
  v29 = CFDataCreate(0, v34, v37);
  *a3 = v29;
  v21 = 2 * (v29 == 0);
LABEL_21:
  SafeRelease(Mutable);
  SafeFree(v35);
  SafeFree(v34);
  SafeRelease(v24);
  DEREncoderDestroy(v26);
  return v21;
}

BOOL AMAuthInstallApImg4SupportsLocalSigning(uint64_t a1)
{
  uint64_t v1;
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 16);
    if (v1)
    {
      if (*(_BYTE *)(v1 + 76))
        return 1;
    }
  }
  return result;
}

BOOL AMAuthInstallApImg4SupportsGlobalSigning(uint64_t a1)
{
  return a1 && *(_QWORD *)(a1 + 40);
}

uint64_t AMAuthInstallApImg4GetTagAsInteger(CFStringRef theString)
{
  CFIndex i;
  unsigned int v4;

  v4 = 0;
  if (!theString)
    return 0xFFFFFFFFLL;
  for (i = 0; i != 4; ++i)
  {
    if (i == CFStringGetLength(theString))
      break;
    *((_BYTE *)&v4 + i) = CFStringGetCharacterAtIndex(theString, i);
  }
  return bswap32(v4);
}

uint64_t AMAuthInstallApImg4AddInteger32Property(uint64_t a1, const __CFString *a2, const __CFNumber *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int CString;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t TagAsInteger;
  uint64_t v30;
  const char *v32;
  char v33;
  unsigned int valuePtr;
  char buffer[256];

  v8 = 0;
  valuePtr = 0;
  if (!a1)
    goto LABEL_18;
  if (!a2)
    goto LABEL_18;
  if (!a3)
    goto LABEL_18;
  v8 = DEREncoderCreate(0);
  if (!v8)
    goto LABEL_18;
  CString = CFStringGetCString(a2, buffer, 256, 0x8000100u);
  if (CString)
  {
    v13 = strlen(buffer);
    if (DEREncoderAddData(v8, 0, 22, buffer, v13, 0))
    {
      v33 = (char)a2;
      v32 = "failed to add %@ string";
      goto LABEL_17;
    }
  }
  if (!CFNumberGetValue(a3, kCFNumberSInt32Type, &valuePtr))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger32Property", "%s: invalid datatype", v19, v20, v21, v22, v23, (char)"AMAuthInstallApImg4AddInteger32Property");
    if (CString)
    {
      v30 = 1;
      goto LABEL_11;
    }
LABEL_18:
    v30 = 3;
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger32Property", "%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddInteger32Property");
    goto LABEL_11;
  }
  if (DEREncoderAddUInt32(v8, 0, 2, valuePtr))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger32Property", "failed to add %@ value", v24, v25, v26, v27, v28, (char)a2);
    goto LABEL_18;
  }
  TagAsInteger = AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder(v8, a1, TagAsInteger))
  {
    v32 = "failed to sequence tag";
LABEL_17:
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger32Property", v32, v14, v15, v16, v17, v18, v33);
    goto LABEL_18;
  }
  v30 = 0;
LABEL_11:
  DEREncoderDestroy(v8);
  return v30;
}

uint64_t AMAuthInstallApImg4AddInteger64Property(uint64_t a1, const __CFString *a2, const __CFNumber *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  int CString;
  size_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t TagAsInteger;
  uint64_t v30;
  const char *v32;
  char v33;
  uint64_t valuePtr;
  char buffer[256];

  v8 = 0;
  valuePtr = 0;
  if (!a1)
    goto LABEL_18;
  if (!a2)
    goto LABEL_18;
  if (!a3)
    goto LABEL_18;
  v8 = DEREncoderCreate(0);
  if (!v8)
    goto LABEL_18;
  CString = CFStringGetCString(a2, buffer, 256, 0x8000100u);
  if (CString)
  {
    v13 = strlen(buffer);
    if (DEREncoderAddData(v8, 0, 22, buffer, v13, 0))
    {
      v33 = (char)a2;
      v32 = "failed to add %@ string";
      goto LABEL_17;
    }
  }
  if (!CFNumberGetValue(a3, kCFNumberSInt64Type, &valuePtr))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger64Property", "%s: invalid datatype", v19, v20, v21, v22, v23, (char)"AMAuthInstallApImg4AddInteger64Property");
    if (CString)
    {
      v30 = 1;
      goto LABEL_11;
    }
LABEL_18:
    v30 = 3;
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger64Property", "%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddInteger64Property");
    goto LABEL_11;
  }
  if (DEREncoderAddUInt64(v8, 0, 2, valuePtr))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger64Property", "failed to add %@ value", v24, v25, v26, v27, v28, (char)a2);
    goto LABEL_18;
  }
  TagAsInteger = AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder(v8, a1, TagAsInteger))
  {
    v32 = "failed to sequence tag";
LABEL_17:
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddInteger64Property", v32, v14, v15, v16, v17, v18, v33);
    goto LABEL_18;
  }
  v30 = 0;
LABEL_11:
  DEREncoderDestroy(v8);
  return v30;
}

uint64_t AMAuthInstallApImg4AddBooleanProperty(uint64_t a1, const __CFString *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  char v9;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t TagAsInteger;
  uint64_t v24;
  const char *v26;
  char v27;
  char v28;
  char buffer[256];

  v8 = 0;
  if (a3)
    v9 = -1;
  else
    v9 = 0;
  v28 = v9;
  if (!a1)
    goto LABEL_17;
  if (!a2)
    goto LABEL_17;
  v8 = DEREncoderCreate(0);
  if (!v8)
    goto LABEL_17;
  if (CFStringGetCString(a2, buffer, 256, 0x8000100u))
  {
    v12 = strlen(buffer);
    if (DEREncoderAddData(v8, 0, 22, buffer, v12, 0))
    {
      v27 = (char)a2;
      v26 = "failed to add %@ string";
      goto LABEL_16;
    }
  }
  if (DEREncoderAddData(v8, 0, 1, &v28, 1, 0))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddBooleanProperty", "%s: failed to add data", v18, v19, v20, v21, v22, (char)"AMAuthInstallApImg4AddBooleanProperty");
LABEL_17:
    v24 = 3;
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddBooleanProperty", "%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddBooleanProperty");
    goto LABEL_12;
  }
  TagAsInteger = AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder(v8, a1, TagAsInteger))
  {
    v26 = "failed to sequence tag";
LABEL_16:
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddBooleanProperty", v26, v13, v14, v15, v16, v17, v27);
    goto LABEL_17;
  }
  v24 = 0;
LABEL_12:
  DEREncoderDestroy(v8);
  return v24;
}

uint64_t AMAuthInstallApImg4AddDataProperty(uint64_t a1, const __CFString *a2, const __CFData *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t TagAsInteger;
  uint64_t v26;
  const char *v28;
  char v29;
  char buffer[256];

  v8 = 0;
  if (!a1)
    goto LABEL_15;
  if (!a2)
    goto LABEL_15;
  if (!a3)
    goto LABEL_15;
  v8 = DEREncoderCreate(0);
  if (!v8)
    goto LABEL_15;
  if (CFStringGetCString(a2, buffer, 256, 0x8000100u))
  {
    v12 = strlen(buffer);
    if (DEREncoderAddData(v8, 0, 22, buffer, v12, 0))
    {
      v29 = (char)a2;
      v28 = "failed to add %@ string";
      goto LABEL_14;
    }
  }
  BytePtr = CFDataGetBytePtr(a3);
  Length = CFDataGetLength(a3);
  if (DEREncoderAddData(v8, 0, 4, BytePtr, Length, 0))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddDataProperty", "failed to add %@ data", v20, v21, v22, v23, v24, (char)a2);
LABEL_15:
    v26 = 3;
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddDataProperty", "%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddDataProperty");
    goto LABEL_10;
  }
  TagAsInteger = AMAuthInstallApImg4GetTagAsInteger(a2);
  if (DEREncoderAddPrivateFromEncoder(v8, a1, TagAsInteger))
  {
    v28 = "failed to sequence tag";
LABEL_14:
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddDataProperty", v28, v13, v14, v15, v16, v17, v29);
    goto LABEL_15;
  }
  v26 = 0;
LABEL_10:
  DEREncoderDestroy(v8);
  return v26;
}

uint64_t AMAuthInstallApImg4AddDictionaryProperty(uint64_t a1, uint64_t a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  size_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t TagAsInteger;
  uint64_t v19;
  const char *v21;
  char v22;
  char buffer[256];

  v8 = 0;
  if (!a1)
    goto LABEL_15;
  if (!a2)
    goto LABEL_15;
  if (!a3)
    goto LABEL_15;
  v8 = DEREncoderCreate(0);
  if (!v8)
    goto LABEL_15;
  if (CFStringGetCString(a3, buffer, 256, 0x8000100u))
  {
    v12 = strlen(buffer);
    if (DEREncoderAddData(v8, 0, 22, buffer, v12, 0))
    {
      v22 = (char)a3;
      v21 = "failed to add %@ string";
      goto LABEL_14;
    }
  }
  if (DEREncoderAddSetFromEncoder(a1, v8))
  {
    v21 = "failed to add set";
LABEL_14:
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddDictionaryProperty", v21, v13, v14, v15, v16, v17, v22);
LABEL_15:
    v19 = 3;
    AMAuthInstallLog(3, "AMAuthInstallApImg4AddDictionaryProperty", "%s failed to create DER file", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4AddDictionaryProperty");
    goto LABEL_10;
  }
  TagAsInteger = AMAuthInstallApImg4GetTagAsInteger(a3);
  if (DEREncoderAddPrivateFromEncoder(v8, a2, TagAsInteger))
  {
    v21 = "failed to add private";
    goto LABEL_14;
  }
  v19 = 0;
LABEL_10:
  DEREncoderDestroy(v8);
  return v19;
}

uint64_t AMAuthInstallApImg4DecodeRestoreInfo(const __CFData *a1, CFMutableDictionaryRef *a2)
{
  const UInt8 *BytePtr;
  unsigned int Length;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  CFStringRef v12;
  CFNumberRef v13;
  CFBooleanRef v14;
  const void *v15;
  const void *v16;
  const void *v17;
  unint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  CFIndex v22;
  unint64_t v23[2];
  unint64_t v24;
  unint64_t v25[2];
  unint64_t v26;
  _QWORD v27[2];
  unint64_t v28[2];
  _OWORD v29[27];
  __int128 v30;
  uint64_t v31;

  if (!a1 || !*a2)
    return 1;
  v31 = 0;
  v30 = 0u;
  memset(v29, 0, sizeof(v29));
  v28[0] = 0;
  v28[1] = 0;
  v27[0] = 0;
  v27[1] = 0;
  v26 = 0;
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  if (Img4DecodeInit(BytePtr, Length, v29))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4DecodeRestoreInfo", "Img4DecodeInit img4 decode failed.", v6, v7, v8, v9, v10, v19);
  }
  else
  {
    if (!DERDecodeSeqContentInit((unint64_t *)&v30 + 1, v28))
    {
      while (1)
      {
        do
        {
          while (1)
          {
            v11 = DERDecodeSeqNext(v28, &v26);
            if (!v11)
              break;
            if (v11 == 1)
              return 0;
          }
          v24 = 0;
          v25[0] = 0;
          v25[1] = 0;
          v23[0] = 0;
          v23[1] = 0;
          v20 = 0;
          v21 = 0;
          v22 = 0;
        }
        while (DERDecodeItem((uint64_t)v27, &v24)
             || DERDecodeSeqContentInit(v25, v23)
             || DERDecodeSeqNext(v23, (unint64_t *)&v20)
             || v20 != 22);
        v12 = CFStringCreateWithBytes(kCFAllocatorDefault, v21, v22, 0x8000100u, 0);
        if (v12)
        {
          if (!DERDecodeSeqNext(v23, (unint64_t *)&v20))
            break;
        }
LABEL_35:
        SafeRelease(v12);
      }
      if (v20 > 3)
      {
        if (v20 == 4)
        {
          v15 = CFDataCreate(kCFAllocatorDefault, v21, v22);
        }
        else
        {
          if (v20 != 22)
            goto LABEL_35;
          v15 = CFStringCreateWithBytes(kCFAllocatorDefault, v21, v22, 0x8000100u, 0);
        }
        v17 = v15;
        if (v15)
          CFDictionarySetValue(*a2, v12, v15);
        v16 = v17;
        goto LABEL_34;
      }
      if (v20 == 1)
      {
        LOBYTE(v19) = 0;
        if (DERParseBoolean(&v21, (BOOL *)&v19))
          return 23;
        if ((_BYTE)v19)
          v14 = kCFBooleanFalse;
        else
          v14 = kCFBooleanTrue;
        if (!v14)
          goto LABEL_29;
      }
      else
      {
        if (v20 != 2)
          goto LABEL_35;
        v19 = 0;
        if (DERParseInteger64((char **)&v21, &v19))
          return 23;
        v13 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &v19);
        if (!v13)
          goto LABEL_29;
        v14 = v13;
      }
      CFDictionarySetValue(*a2, v12, v14);
LABEL_29:
      v16 = 0;
LABEL_34:
      SafeRelease(v16);
      goto LABEL_35;
    }
    AMSupportLogInternal(3, "AMAuthInstallApImg4DecodeRestoreInfo", "can't parse top-level restoreinfo sequence");
  }
  return 99;
}

uint64_t AMAuthInstallApImg4EncodeRestoreDict(const __CFDictionary *a1, uint64_t a2, uint64_t a3)
{
  const void **v3;
  const void **v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int Count;
  size_t v13;
  const void **v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  const char *v22;
  const __CFString *v23;
  CFTypeID v24;
  const void *v25;
  CFTypeID v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  CFTypeID v32;
  CFTypeID TypeID;
  const __CFBoolean *v34;
  int Value;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  CFTypeID v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const __CFNumber *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  size_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  const char *v69;
  const char *v70;
  const __CFString *v71;
  void *v72;
  unsigned int v73;
  char buffer[256];

  v3 = 0;
  v73 = 0;
  v72 = 0;
  if (!a1 || !a2)
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 0;
    goto LABEL_43;
  }
  v6 = 0;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  v10 = 0;
  if (!a3)
  {
LABEL_43:
    v67 = 3;
    goto LABEL_36;
  }
  v7 = DEREncoderCreate(1);
  if (!v7)
  {
    v3 = 0;
    v6 = 0;
LABEL_41:
    v8 = 0;
    goto LABEL_42;
  }
  Count = CFDictionaryGetCount(a1);
  v13 = 8 * Count;
  v3 = (const void **)malloc(v13);
  v14 = (const void **)malloc(v13);
  v6 = v14;
  v8 = 0;
  if (!v3 || !v14)
  {
    v9 = 0;
    v10 = 0;
    goto LABEL_43;
  }
  CFDictionaryGetKeysAndValues(a1, v3, v14);
  if (Count)
  {
    v20 = 0;
    v21 = 8 * Count;
    v22 = "%s: unexpected restore property type";
    while (1)
    {
      v23 = (const __CFString *)v3[v20 / 8];
      if (!v23 || (v24 = CFGetTypeID(v3[v20 / 8]), v24 != CFStringGetTypeID()))
      {
        v69 = "invalid overridesKey";
        goto LABEL_40;
      }
      v25 = v6[v20 / 8];
      if (!v25)
        break;
      v26 = CFGetTypeID(v25);
      if (v26 == CFDataGetTypeID())
      {
        if (AMAuthInstallApImg4AddDataProperty(v7, v23, (const __CFData *)v6[v20 / 8], v27, v28, v29, v30, v31))goto LABEL_39;
      }
      else
      {
        v32 = CFGetTypeID(v6[v20 / 8]);
        TypeID = CFBooleanGetTypeID();
        v34 = (const __CFBoolean *)v6[v20 / 8];
        if (v32 == TypeID)
        {
          Value = CFBooleanGetValue(v34);
          if (AMAuthInstallApImg4AddBooleanProperty(v7, v23, Value, v36, v37, v38, v39, v40))
            goto LABEL_39;
        }
        else
        {
          v41 = CFGetTypeID(v34);
          if (v41 != CFNumberGetTypeID())
            goto LABEL_38;
          v47 = (const __CFNumber *)v6[v20 / 8];
          if (CFNumberGetType(v47) == kCFNumberSInt32Type)
          {
            if (AMAuthInstallApImg4AddInteger32Property(v7, v23, v47, v48, v49, v50, v51, v52))
              goto LABEL_39;
          }
          else
          {
            if (CFNumberGetType(v47) != kCFNumberSInt64Type)
            {
              v22 = "%s: unexpected integer type";
LABEL_38:
              AMAuthInstallLog(3, "AMAuthInstallApImg4EncodeRestoreDict", v22, v42, v43, v44, v45, v46, (char)"AMAuthInstallApImg4EncodeRestoreDict");
LABEL_39:
              v69 = "failed to encode restore property";
              goto LABEL_40;
            }
            if (AMAuthInstallApImg4AddInteger64Property(v7, (const __CFString *)v3[v20 / 8], v47, v42, v43, v44, v45, v46))goto LABEL_39;
          }
        }
      }
      v20 += 8;
      if (v21 == v20)
        goto LABEL_25;
    }
    v69 = "invalid overridesValue";
LABEL_40:
    AMAuthInstallLog(3, "AMAuthInstallApImg4EncodeRestoreDict", v69, v15, v16, v17, v18, v19, (char)v71);
    goto LABEL_41;
  }
LABEL_25:
  v8 = DEREncoderCreate(0);
  if (!v8)
  {
LABEL_42:
    v9 = 0;
    v10 = 0;
    goto LABEL_43;
  }
  if (CFStringGetCString(CFSTR("IM4R"), buffer, 256, 0x8000100u))
  {
    v53 = strlen(buffer);
    if (DEREncoderAddData(v8, 0, 22, buffer, v53, 0))
    {
      v71 = CFSTR("IM4M");
      v70 = "failed to add %@ string";
      goto LABEL_55;
    }
  }
  v59 = DEREncoderAddSetFromEncoder(v7, v8);
  if ((_DWORD)v59)
  {
    v70 = "failed to encode restore info properties as set";
LABEL_55:
    AMAuthInstallLog(3, "AMAuthInstallApImg4EncodeRestoreDict", v70, v54, v55, v56, v57, v58, (char)v71);
    goto LABEL_42;
  }
  v10 = DEREncoderCreate(v59);
  if (!v10)
  {
    v9 = 0;
    goto LABEL_51;
  }
  if (DEREncoderAddSequenceFromEncoder(v8, v10))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4EncodeRestoreDict", "failed to encode restore info sequence", v60, v61, v62, v63, v64, (char)v71);
    goto LABEL_53;
  }
  v65 = DEREncoderCreateEncodedBuffer(v10, &v72, &v73);
  if ((_DWORD)v65)
  {
LABEL_53:
    v9 = 0;
    goto LABEL_43;
  }
  v66 = DEREncoderCreate(v65);
  v9 = v66;
  if (!v66)
  {
LABEL_51:
    v67 = 2;
    goto LABEL_36;
  }
  if (DEREncoderAddData(v66, 2, 1, v72, v73, 1)
    || DEREncoderCreateEncodedBuffer(v9, a2, a3))
  {
    goto LABEL_43;
  }
  v67 = 0;
LABEL_36:
  SafeFree(v3);
  SafeFree(v6);
  SafeFree(v72);
  DEREncoderDestroy(v7);
  DEREncoderDestroy(v8);
  DEREncoderDestroy(v9);
  DEREncoderDestroy(v10);
  return v67;
}

uint64_t AMAuthInstallApImg4LocalCreateManifestBody(uint64_t a1, CFTypeRef a2, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const __CFAllocator *v17;
  const __CFNumber *v18;
  const __CFNumber *Value;
  const __CFNumber *v20;
  CFTypeID v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const __CFNumber *v27;
  const __CFNumber *v28;
  CFTypeID v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFNumber *v35;
  const __CFNumber *v36;
  CFTypeID v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  const __CFNumber *v49;
  const __CFNumber *v50;
  CFTypeID v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const __CFBoolean *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const __CFBoolean *v64;
  CFTypeID v65;
  int v66;
  const __CFBoolean *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  const __CFBoolean *v73;
  CFTypeID v74;
  int v75;
  const __CFData *v76;
  const __CFData *v77;
  CFTypeID v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  const __CFData *v84;
  const __CFData *v85;
  CFTypeID v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  const __CFData *v92;
  const __CFData *v93;
  CFTypeID v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  const __CFBoolean *v100;
  const __CFBoolean *v101;
  CFTypeID v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  const __CFData *v108;
  const __CFData *v109;
  CFTypeID v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const __CFData *v116;
  const __CFData *v117;
  CFTypeID v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  const __CFData *v124;
  const __CFData *v125;
  CFTypeID v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  const __CFBoolean *v132;
  const __CFBoolean *v133;
  CFTypeID v134;
  int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  const __CFAllocator *v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  const __CFAllocator *v159;
  CFDataRef v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  const char *v168;
  char v169;
  UInt8 *bytes;
  CFIndex length;

  LODWORD(length) = 0;
  bytes = 0;
  if (!a1 || !a2 || !a3)
  {
    v166 = 3;
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateManifestBody", "%s DER operation failed", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4LocalCreateManifestBody");
    v157 = 0;
    if (!a3)
    {
      v155 = 0;
      v141 = 0;
      v16 = 0;
      v18 = 0;
      goto LABEL_68;
    }
    v18 = 0;
    v16 = 0;
    v141 = 0;
    v155 = 0;
LABEL_90:
    SafeRelease(*a3);
    v166 = 3;
    goto LABEL_68;
  }
  AMAuthInstallDebugWriteObject((char *)a1, a2, (uint64_t)CFSTR("tss-request"), 2);
  v16 = DEREncoderCreate(1);
  if (!v16)
  {
    v18 = 0;
    goto LABEL_88;
  }
  v17 = CFGetAllocator((CFTypeRef)a1);
  v18 = CFNumberCreate(v17, kCFNumberIntType, (const void *)(*(_QWORD *)(a1 + 16) + 68));
  if (!v18)
    goto LABEL_88;
  if (AMAuthInstallApImg4AddInteger32Property(v16, CFSTR("CEPO"), v18, v11, v12, v13, v14, v15))
    goto LABEL_88;
  Value = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApChipID"));
  if (Value)
  {
    v20 = Value;
    v21 = CFGetTypeID(Value);
    if (v21 == CFNumberGetTypeID())
    {
      if (AMAuthInstallApImg4AddInteger32Property(v16, CFSTR("CHIP"), v20, v22, v23, v24, v25, v26))
        goto LABEL_88;
    }
  }
  v27 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApBoardID"));
  if (v27)
  {
    v28 = v27;
    v29 = CFGetTypeID(v27);
    if (v29 == CFNumberGetTypeID())
    {
      if (AMAuthInstallApImg4AddInteger32Property(v16, CFSTR("BORD"), v28, v30, v31, v32, v33, v34))
        goto LABEL_88;
    }
  }
  v35 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApECID"));
  if (v35)
  {
    v36 = v35;
    v37 = CFGetTypeID(v35);
    if (v37 == CFNumberGetTypeID())
    {
      if (!AMAuthInstallApImg4AddInteger64Property(v16, CFSTR("ECID"), v36, v38, v39, v40, v41, v42))
      {
        v48 = 1;
        goto LABEL_18;
      }
      AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateManifestBody", "failed to add ApEcid", v43, v44, v45, v46, v47, v169);
LABEL_88:
      v141 = 0;
      v155 = 0;
      v157 = 0;
      goto LABEL_89;
    }
  }
  v48 = 0;
LABEL_18:
  v49 = (const __CFNumber *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApSecurityDomain"));
  if (v49)
  {
    v50 = v49;
    v51 = CFGetTypeID(v49);
    if (v51 == CFNumberGetTypeID())
    {
      v57 = AMAuthInstallApImg4AddInteger32Property(v16, CFSTR("SDOM"), v50, v52, v53, v54, v55, v56);
      if ((_DWORD)v57)
        goto LABEL_69;
    }
  }
  v58 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApProductionMode"));
  v66 = 0;
  if (v58)
  {
    v64 = v58;
    v65 = CFGetTypeID(v58);
    if (v65 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v64))
        v66 = 1;
    }
  }
  v57 = AMAuthInstallApImg4AddBooleanProperty(v16, CFSTR("CPRO"), v66, v59, v60, v61, v62, v63);
  if ((_DWORD)v57)
    goto LABEL_69;
  v67 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApSecurityMode"));
  v75 = 0;
  if (v67)
  {
    v73 = v67;
    v74 = CFGetTypeID(v67);
    if (v74 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v73))
        v75 = 1;
    }
  }
  v57 = AMAuthInstallApImg4AddBooleanProperty(v16, CFSTR("CSEC"), v75, v68, v69, v70, v71, v72);
  if ((_DWORD)v57)
    goto LABEL_69;
  v76 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApLocalNonceHash"));
  if (v76)
  {
    v77 = v76;
    v78 = CFGetTypeID(v76);
    if (v78 == CFDataGetTypeID())
    {
      v57 = AMAuthInstallApImg4AddDataProperty(v16, CFSTR("LNCH"), v77, v79, v80, v81, v82, v83);
      if ((_DWORD)v57)
        goto LABEL_69;
    }
  }
  v84 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApNonce"));
  if (v84)
  {
    v85 = v84;
    v86 = CFGetTypeID(v84);
    if (v86 == CFDataGetTypeID())
    {
      v57 = AMAuthInstallApImg4AddDataProperty(v16, CFSTR("BNCH"), v85, v87, v88, v89, v90, v91);
      if ((_DWORD)v57)
        goto LABEL_69;
    }
  }
  v92 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("SepNonce"));
  if (v92)
  {
    v93 = v92;
    v94 = CFGetTypeID(v92);
    if (v94 == CFDataGetTypeID())
    {
      v57 = AMAuthInstallApImg4AddDataProperty(v16, CFSTR("snon"), v93, v95, v96, v97, v98, v99);
      if ((_DWORD)v57)
        goto LABEL_69;
    }
  }
  v100 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("ApAllowMixAndMatch"));
  if (v100)
  {
    v101 = v100;
    v102 = CFGetTypeID(v100);
    if (v102 == CFBooleanGetTypeID())
    {
      if (CFBooleanGetValue(v101))
      {
        v57 = AMAuthInstallApImg4AddBooleanProperty(v16, CFSTR("AMNM"), 1, v103, v104, v105, v106, v107);
        if ((_DWORD)v57)
          goto LABEL_69;
      }
    }
  }
  v108 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Ap,NextStageIM4MHash"));
  if (v108)
  {
    v109 = v108;
    v110 = CFGetTypeID(v108);
    if (v110 == CFDataGetTypeID())
    {
      v57 = AMAuthInstallApImg4AddDataProperty(v16, CFSTR("nsih"), v109, v111, v112, v113, v114, v115);
      if ((_DWORD)v57)
        goto LABEL_69;
    }
  }
  v116 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Ap,RecoveryOSPolicyNonceHash"));
  if (v116)
  {
    v117 = v116;
    v118 = CFGetTypeID(v116);
    if (v118 == CFDataGetTypeID())
    {
      v57 = AMAuthInstallApImg4AddDataProperty(v16, CFSTR("ronh"), v117, v119, v120, v121, v122, v123);
      if ((_DWORD)v57)
        goto LABEL_69;
    }
  }
  v124 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Ap,VolumeUUID"));
  if (v124)
  {
    v125 = v124;
    v126 = CFGetTypeID(v124);
    if (v126 == CFDataGetTypeID())
    {
      v57 = AMAuthInstallApImg4AddDataProperty(v16, CFSTR("vuid"), v125, v127, v128, v129, v130, v131);
      if ((_DWORD)v57)
        goto LABEL_69;
    }
  }
  v132 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)a2, CFSTR("Ap,LocalBoot"));
  if (v132)
  {
    v133 = v132;
    v134 = CFGetTypeID(v132);
    if (v134 == CFBooleanGetTypeID())
    {
      v135 = CFBooleanGetValue(v133);
      v57 = AMAuthInstallApImg4AddBooleanProperty(v16, CFSTR("lobo"), v135, v136, v137, v138, v139, v140);
      if ((_DWORD)v57)
      {
LABEL_69:
        v166 = v57;
        v141 = 0;
LABEL_70:
        v155 = 0;
LABEL_82:
        v157 = 0;
        goto LABEL_83;
      }
    }
  }
  v141 = DEREncoderCreate(1);
  if (!v141)
  {
    v155 = 0;
    goto LABEL_76;
  }
  v142 = AMAuthInstallApImg4AddDictionaryProperty(v16, v141, CFSTR("MANP"), v11, v12, v13, v14, v15);
  if ((_DWORD)v142)
  {
    v166 = v142;
    goto LABEL_70;
  }
  v143 = CFGetAllocator((CFTypeRef)a1);
  v149 = AMAuthInstallApImg4LocalAddImages(v143, (CFDictionaryRef)a2, v141, v144, v145, v146, v147, v148);
  if ((_DWORD)v149)
  {
    v166 = v149;
    v155 = 0;
    v168 = "failed to add img objects to the manifest body";
LABEL_81:
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateManifestBody", v168, v150, v151, v152, v153, v154, v169);
    goto LABEL_82;
  }
  v155 = DEREncoderCreate(v149);
  if (!v155)
  {
LABEL_76:
    v157 = 0;
    goto LABEL_77;
  }
  v156 = AMAuthInstallApImg4AddDictionaryProperty(v141, v155, CFSTR("MANB"), v11, v12, v13, v14, v15);
  if ((_DWORD)v156)
  {
    v166 = v156;
    v168 = "failed to create the signed section";
    goto LABEL_81;
  }
  v157 = DEREncoderCreate(v156);
  if (!v157)
  {
LABEL_77:
    v166 = 2;
    goto LABEL_83;
  }
  v158 = DEREncoderAddSetFromEncoder(v155, v157);
  if ((_DWORD)v158)
  {
    v166 = v158;
LABEL_83:
    if ((v48 & 1) != 0)
      goto LABEL_68;
    goto LABEL_89;
  }
  if (DEREncoderCreateEncodedBuffer(v157, &bytes, &length))
  {
LABEL_89:
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateManifestBody", "%s DER operation failed", v11, v12, v13, v14, v15, (char)"AMAuthInstallApImg4LocalCreateManifestBody");
    goto LABEL_90;
  }
  v159 = CFGetAllocator((CFTypeRef)a1);
  v160 = CFDataCreate(v159, bytes, length);
  *a3 = v160;
  if (v160)
  {
    v166 = 0;
  }
  else
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateManifestBody", "failed to create manifest data", v161, v162, v163, v164, v165, v169);
    v166 = 2;
  }
LABEL_68:
  SafeFree(bytes);
  DEREncoderDestroy(v16);
  DEREncoderDestroy(v141);
  DEREncoderDestroy(v155);
  DEREncoderDestroy(v157);
  SafeRelease(v18);
  return v166;
}

uint64_t AMAuthInstallApImg4LocalAddImages(const __CFAllocator *a1, CFDictionaryRef theDict, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFIndex Count;
  const void **v12;
  const void **v13;
  const __CFArray *Mutable;
  uint64_t v15;
  const __CFString *v16;
  const void *v17;
  CFTypeID v18;
  CFTypeID v20;
  const __CFString *TypeForEntryName;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  const char *v35;
  char v36;
  CFRange v37;

  if (!theDict)
  {
    v35 = "requestDict cannot be NULL";
LABEL_23:
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImages", v35, a4, a5, a6, a7, a8, v36);
    v12 = 0;
    v13 = 0;
    Mutable = 0;
LABEL_24:
    v33 = 1;
    goto LABEL_18;
  }
  if (!a3)
  {
    v35 = "dstEncoder cannot be NULL";
    goto LABEL_23;
  }
  Count = CFDictionaryGetCount(theDict);
  v12 = (const void **)malloc(8 * Count);
  v13 = (const void **)malloc(8 * Count);
  CFDictionaryGetKeysAndValues(theDict, v12, v13);
  Mutable = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    v33 = 2;
    goto LABEL_18;
  }
  if (Count >= 1)
  {
    v15 = 0;
    do
    {
      v16 = (const __CFString *)v12[v15];
      if (!v16)
        goto LABEL_24;
      v17 = v13[v15];
      v18 = CFGetTypeID(v12[v15]);
      if (v18 != CFStringGetTypeID() || v17 == 0)
        goto LABEL_24;
      v20 = CFGetTypeID(v17);
      if (v20 == CFDictionaryGetTypeID())
      {
        if (CFDictionaryGetValue((CFDictionaryRef)v17, CFSTR("Digest")))
        {
          v37.length = CFArrayGetCount(Mutable);
          v37.location = 0;
          if (CFArrayGetFirstIndexOfValue(Mutable, v37, v16) == -1)
          {
            CFArrayAppendValue(Mutable, v16);
            TypeForEntryName = AMAuthInstallApImg4GetTypeForEntryName(v16);
            if (!TypeForEntryName)
            {
              AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImages", "did not find a matching tag for requestTag %@", v22, v23, v24, v25, v26, (char)v16);
              goto LABEL_24;
            }
            v27 = AMAuthInstallApImg4LocalAddImageProperties((uint64_t)TypeForEntryName, a3, TypeForEntryName, (const __CFDictionary *)v17, v23, v24, v25, v26);
            if ((_DWORD)v27)
            {
              v33 = v27;
              AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImages", "failed to add %@ image to the ticket body", v28, v29, v30, v31, v32, (char)v16);
              goto LABEL_18;
            }
          }
        }
      }
    }
    while (Count != ++v15);
  }
  v33 = 0;
LABEL_18:
  SafeFree(v12);
  SafeFree(v13);
  SafeRelease(Mutable);
  return v33;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedTag(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFDataRef v26;
  UInt8 *bytes;
  unsigned int length;
  char length_4[256];

  length = 0;
  bytes = 0;
  if (!a1)
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedTag", "%s: tagStr is NULL", a4, a5, a6, a7, a8, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_8;
  }
  v8 = (char)a1;
  if (!CFStringGetCString(a1, length_4, 256, 0x8000100u))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedTag", "%s: cannot convert tagStr", v9, v10, v11, v12, v13, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
LABEL_8:
    v14 = 0;
    goto LABEL_9;
  }
  v14 = DEREncoderCreate(0);
  if (!v14)
  {
LABEL_9:
    SafeRelease(0);
    v26 = 0;
    goto LABEL_10;
  }
  v15 = strlen(length_4);
  if (DEREncoderAddData(v14, 0, 22, length_4, v15, 0))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedTag", "failed to add %@ string", v16, v17, v18, v19, v20, v8);
    goto LABEL_9;
  }
  if (DEREncoderCreateEncodedBuffer(v14, &bytes, &length))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedTag", "%s: failed to create buffer", v21, v22, v23, v24, v25, (char)"AMAuthInstallApImg4LocalCreateEncodedTag");
    goto LABEL_9;
  }
  v26 = CFDataCreate(0, bytes, length);
LABEL_10:
  SafeFree(bytes);
  DEREncoderDestroy(v14);
  return v26;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedVersion(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFDataRef v9;
  const char *v11;
  const char *v12;
  UInt8 *bytes;
  unsigned int v14;

  v14 = 0;
  bytes = 0;
  v2 = DEREncoderCreate(0);
  v3 = v2;
  if (!v2)
    goto LABEL_9;
  if (DEREncoderAddUInt32(v2, 0, 2, a1))
  {
    v11 = "failed to add manifest version";
LABEL_8:
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedVersion", v11, v4, v5, v6, v7, v8, (char)v12);
LABEL_9:
    SafeRelease(0);
    v9 = 0;
    goto LABEL_5;
  }
  if (DEREncoderCreateEncodedBuffer(v3, &bytes, &v14))
  {
    v12 = "AMAuthInstallApImg4LocalCreateEncodedVersion";
    v11 = "%s: failed to create buffer";
    goto LABEL_8;
  }
  v9 = CFDataCreate(0, bytes, v14);
LABEL_5:
  SafeFree(bytes);
  DEREncoderDestroy(v3);
  return v9;
}

CFDataRef AMAuthInstallApImg4LocalCreateEncodedData(const __CFData *a1)
{
  uint64_t v2;
  const UInt8 *BytePtr;
  CFIndex v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  CFDataRef v15;
  UInt8 *bytes;
  CFIndex length;

  LODWORD(length) = 0;
  bytes = 0;
  v2 = DEREncoderCreate(0);
  if (!v2)
    goto LABEL_8;
  BytePtr = CFDataGetBytePtr(a1);
  v4 = CFDataGetLength(a1);
  if (DEREncoderAddData(v2, 0, 4, BytePtr, v4, 0))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedData", "%s: failed to encode data", v5, v6, v7, v8, v9, (char)"AMAuthInstallApImg4LocalCreateEncodedData");
LABEL_8:
    SafeRelease(0);
    v15 = 0;
    goto LABEL_5;
  }
  if (DEREncoderCreateEncodedBuffer(v2, &bytes, &length))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedData", "%s: failed to create buffer", v10, v11, v12, v13, v14, (char)"AMAuthInstallApImg4LocalCreateEncodedData");
    goto LABEL_8;
  }
  v15 = CFDataCreate(0, bytes, length);
LABEL_5:
  SafeFree(bytes);
  DEREncoderDestroy(v2);
  return v15;
}

uint64_t _AMAuthInstallApImg4LocalCreateSignedManifest(_QWORD *a1, const void *a2, const void *a3, const void *a4, const void *a5, CFTypeRef *a6, uint64_t a7, uint64_t a8)
{
  int v10;
  const __CFAllocator *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __CFData *Mutable;
  const __CFData *EncodedTag;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  const __CFData *v30;
  const UInt8 *BytePtr;
  CFIndex v32;
  const __CFData *EncodedVersion;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFData *v39;
  const UInt8 *v40;
  CFIndex v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  const __CFData *v47;
  uint64_t v48;
  const UInt8 *v49;
  CFIndex v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const __CFData *v58;
  const char *v59;
  CFTypeRef v60;
  const __CFData *EncodedData;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const UInt8 *v67;
  CFIndex v68;
  const __CFData *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  const UInt8 *v75;
  CFIndex v76;
  uint64_t v77;
  const UInt8 *v78;
  CFIndex v79;
  const __CFAllocator *v80;
  CFDataRef v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v88;
  const char *v89;
  int v90;
  UInt8 *bytes;
  CFDataRef v93;
  CFTypeRef v94;
  CFDataRef theData;
  CFIndex length;

  LODWORD(length) = 0;
  v94 = 0;
  theData = 0;
  bytes = 0;
  v93 = 0;
  if (!a1 || !a2 || !a6)
  {
    v48 = 3;
    AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", "%s failed to create DER file", (uint64_t)a4, (uint64_t)a5, (uint64_t)a6, a7, a8, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    v77 = 0;
    v58 = 0;
    v39 = 0;
    v30 = 0;
    Mutable = 0;
    if (!a6)
      goto LABEL_26;
    goto LABEL_44;
  }
  v10 = a7;
  v15 = CFGetAllocator(a1);
  Mutable = CFDataCreateMutable(v15, 0);
  if (!Mutable)
  {
    v30 = 0;
LABEL_49:
    v39 = 0;
    goto LABEL_41;
  }
  EncodedTag = AMAuthInstallApImg4LocalCreateEncodedTag(CFSTR("IM4M"), v16, v17, v18, v19, v20, v21, v22);
  v30 = EncodedTag;
  if (!EncodedTag)
  {
    AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", "%s failed to encode tag", v25, v26, v27, v28, v29, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    goto LABEL_49;
  }
  BytePtr = CFDataGetBytePtr(EncodedTag);
  v32 = CFDataGetLength(v30);
  CFDataAppendBytes(Mutable, BytePtr, v32);
  EncodedVersion = AMAuthInstallApImg4LocalCreateEncodedVersion(0);
  v39 = EncodedVersion;
  if (!EncodedVersion)
  {
    AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", "%s failed to encode version", v34, v35, v36, v37, v38, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
    goto LABEL_41;
  }
  v40 = CFDataGetBytePtr(EncodedVersion);
  v41 = CFDataGetLength(v39);
  CFDataAppendBytes(Mutable, v40, v41);
  if (a3)
  {
    v47 = (const __CFData *)CFRetain(a3);
    theData = v47;
    v48 = 99;
    if (v47)
      goto LABEL_9;
LABEL_13:
    v59 = "manifest not found";
LABEL_40:
    AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", v59, v18, v19, v20, v21, v22, v90);
    goto LABEL_41;
  }
  if (AMAuthInstallApImg4LocalCreateManifestBody((uint64_t)a1, a2, (CFTypeRef *)&theData, v42, v43, v44, v45, v46))
  {
    v59 = "failed to create unsigned manifest";
    goto LABEL_40;
  }
  v48 = 0;
  v47 = theData;
  if (!theData)
    goto LABEL_13;
LABEL_9:
  v49 = CFDataGetBytePtr(v47);
  v50 = CFDataGetLength(theData);
  CFDataAppendBytes(Mutable, v49, v50);
  if (!v10)
  {
    if (!AMAuthInstallApImg4LocalRegisterKeys((uint64_t)a1, v51, v52, v53, v54, v55, v56, v57))
    {
      if (a4)
      {
        v60 = CFRetain(a4);
        v94 = v60;
        if (v60)
        {
          EncodedData = AMAuthInstallApImg4LocalCreateEncodedData((const __CFData *)v60);
          v58 = EncodedData;
          if (EncodedData)
          {
            v67 = CFDataGetBytePtr(EncodedData);
            v68 = CFDataGetLength(v58);
            CFDataAppendBytes(Mutable, v67, v68);
            if (a5)
            {
              v69 = (const __CFData *)CFRetain(a5);
              v93 = v69;
              if (v69)
              {
LABEL_20:
                v75 = CFDataGetBytePtr(v69);
                v76 = CFDataGetLength(v93);
                CFDataAppendBytes(Mutable, v75, v76);
                v48 = 0;
                goto LABEL_21;
              }
            }
            else
            {
              if (AMAuthInstallApImg4LocalCreateEncodedCertificateChain((uint64_t)a1, (CFTypeRef *)&v93))
              {
                v89 = "failed to add certificate";
                goto LABEL_54;
              }
              v69 = v93;
              if (v93)
                goto LABEL_20;
            }
            v89 = "certificate not found";
LABEL_54:
            AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", v89, v70, v71, v72, v73, v74, v90);
            goto LABEL_42;
          }
          AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", "%s failed to encode signature", v62, v63, v64, v65, v66, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
LABEL_42:
          v77 = 0;
LABEL_43:
          AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", "%s failed to create DER file", v18, v19, v20, v21, v22, (char)"_AMAuthInstallApImg4LocalCreateSignedManifest");
LABEL_44:
          SafeRelease(*a6);
          *a6 = 0;
          v48 = 3;
          goto LABEL_26;
        }
        goto LABEL_38;
      }
      v88 = *(_DWORD *)(a1[2] + 112);
      if (v88 == 384)
      {
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (AMAuthInstallCryptoCreateRsaSignature_SHA384())
          goto LABEL_41;
        goto LABEL_38;
      }
      if (v88 != 256)
      {
        if (v88 != 1)
        {
          v90 = *(_DWORD *)(a1[2] + 112);
          v59 = "Unsupported digest type: %d";
          goto LABEL_40;
        }
        CFDataGetBytePtr(theData);
        CFDataGetLength(theData);
        if (AMAuthInstallCryptoCreateRsaSignature())
          goto LABEL_41;
        goto LABEL_38;
      }
      CFDataGetBytePtr(theData);
      CFDataGetLength(theData);
      if (!AMAuthInstallCryptoCreateRsaSignature_SHA256())
      {
LABEL_38:
        v59 = "signature not found";
        goto LABEL_40;
      }
    }
LABEL_41:
    v58 = 0;
    goto LABEL_42;
  }
  v58 = 0;
LABEL_21:
  v77 = DEREncoderCreate(0);
  if (!v77)
    goto LABEL_43;
  v78 = CFDataGetBytePtr(Mutable);
  v79 = CFDataGetLength(Mutable);
  if (DEREncoderAddData(v77, 0, 16, v78, v79, 1)
    || DEREncoderCreateEncodedBuffer(v77, &bytes, &length))
  {
    goto LABEL_43;
  }
  v80 = CFGetAllocator(a1);
  v81 = CFDataCreate(v80, bytes, length);
  *a6 = v81;
  if (!v81)
  {
    AMAuthInstallLog(3, "_AMAuthInstallApImg4LocalCreateSignedManifest", "failed to create manifest data", v82, v83, v84, v85, v86, v90);
    v48 = 2;
  }
LABEL_26:
  SafeRelease(Mutable);
  SafeRelease(v30);
  SafeRelease(v39);
  SafeRelease(theData);
  SafeRelease(v94);
  SafeRelease(v58);
  SafeRelease(v93);
  SafeFree(bytes);
  DEREncoderDestroy(v77);
  return v48;
}

uint64_t AMAuthInstallApImg4LocalRegisterKeys(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t result;
  int v10;
  const __CFString *v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  char v26;
  int v27;
  int v28;

  if (!a1)
    return 1;
  v8 = *(_QWORD *)(a1 + 16);
  if (*(_BYTE *)(v8 + 20))
  {
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalRegisterKeys", "local signing is not available for production fused devices.", a4, a5, a6, a7, a8, v26);
    return 14;
  }
  if (!*(_QWORD *)(a1 + 392))
  {
    if (*(_BYTE *)(v8 + 72) || *(_DWORD *)(v8 + 16))
    {
      if (*(_BYTE *)(v8 + 73))
      {
        v10 = *(_DWORD *)(v8 + 8);
        if (v10 == 32784)
        {
          v11 = CFSTR("ap.ticket.insec.rsa4k.key.private");
        }
        else
        {
          if (v10 != 35168)
          {
            AMAuthInstallLog(3, "AMAuthInstallApImg4LocalRegisterKeys", "unrecognized chipid: 0x%08X", a4, a5, a6, a7, a8, v10);
            return 1;
          }
          v11 = CFSTR("ap.ticket.insec.rsa1k.key.private");
        }
      }
      else
      {
        v11 = CFSTR("ap.ticket.dev.key.private");
        if (*(_BYTE *)(a1 + 505))
          v11 = CFSTR("ap.ticket.localpolicy.hacktivation.key.private");
      }
    }
    else
    {
      v11 = CFSTR("ap.ticket.unfused.key.private");
    }
    *(_QWORD *)(a1 + 392) = v11;
  }
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 376), CFSTR("ap.ticket.dev.key.private")))
    return 0;
  v28 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  v27 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  v12 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  v13 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  v14 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  v15 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  v16 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  v17 = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  v18 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  v19 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  v20 = AMAuthInstallCryptoRegisterCertFromPEMBuffer();
  result = AMAuthInstallCryptoRegisterKeysFromPEMBuffer();
  if ((!v28 || !v27 || !v15 || !v17 || !(_DWORD)result) && (!v12 || !v13 || !v14 || !v16 || !v18 || !v19 || !v20))
  {
    AMAuthInstallLog(6, "AMAuthInstallApImg4LocalRegisterKeys", "ap local signing keys available", v21, v22, v23, v24, v25, v26);
    return 0;
  }
  return result;
}

uint64_t AMAuthInstallApImg4LocalCreateEncodedCertificateChain(uint64_t a1, CFTypeRef *a2)
{
  const __CFAllocator *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  __CFData *Mutable;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t CertData;
  const UInt8 *v17;
  CFIndex v18;
  const UInt8 *v19;
  CFIndex v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v27;
  int v28;
  const UInt8 *BytePtr;
  CFIndex v30;
  char v31;
  UInt8 *bytes;
  _DWORD length[3];

  memset(length, 0, sizeof(length));
  bytes = 0;
  if (!a1 || !a2)
  {
    v12 = 0;
    Mutable = 0;
    v13 = 1;
    if (!a2)
      goto LABEL_18;
    goto LABEL_6;
  }
  v4 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFDataCreateMutable(v4, 0);
  if (!Mutable)
  {
    v12 = 0;
    v13 = 2;
    goto LABEL_6;
  }
  v11 = *(_QWORD *)(a1 + 16);
  if (!*(_BYTE *)(v11 + 20))
  {
    if (!*(_QWORD *)(a1 + 400))
    {
      if (*(_BYTE *)(a1 + 505))
      {
        v14 = CFSTR("ap.ticket.localpolicy.hacktivation.leaf.cert");
      }
      else if (*(_BYTE *)(v11 + 72) || *(_DWORD *)(v11 + 16))
      {
        if (*(_BYTE *)(v11 + 73))
        {
          v27 = *(_DWORD *)(v11 + 8);
          switch(v27)
          {
            case 32770:
              v14 = CFSTR("ap.ticket.8002.insec.cert");
              break;
            case 35168:
              if (!*(_QWORD *)(a1 + 408))
                *(_QWORD *)(a1 + 408) = CFSTR("ap.ticket.ca.cert");
              CertData = AMAuthInstallCryptoGetCertData();
              if ((_DWORD)CertData)
                goto LABEL_45;
              BytePtr = CFDataGetBytePtr(*(CFDataRef *)&length[1]);
              v30 = CFDataGetLength(*(CFDataRef *)&length[1]);
              CFDataAppendBytes(Mutable, BytePtr, v30);
              v14 = CFSTR("ap.ticket.8960.insec.cert");
              break;
            case 32784:
              v14 = CFSTR("ap.ticket.8010.insec.cert");
              break;
            default:
              AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedCertificateChain", "unrecognized chipid: 0x%08X", v5, v6, v7, v8, v9, v27);
              goto LABEL_38;
          }
        }
        else
        {
          v14 = CFSTR("ap.ticket.8960.dev.cert");
        }
      }
      else
      {
        v14 = CFSTR("ap.ticket.8960.unfused.cert");
      }
      *(_QWORD *)(a1 + 400) = v14;
    }
    if (!*(_BYTE *)(a1 + 505))
    {
      v15 = *(_QWORD *)(a1 + 16);
      if (!*(_BYTE *)(v15 + 77))
      {
        v28 = *(_DWORD *)(v15 + 8);
        if (v28 != 32770 && v28 != 35168 && v28 != 32784)
        {
          AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedCertificateChain", "chipid: 0x%08X unsupported for img4 local signing", v5, v6, v7, v8, v9, v28);
LABEL_38:
          v12 = 0;
          v13 = 1;
          goto LABEL_6;
        }
      }
    }
    CertData = AMAuthInstallCryptoGetCertData();
    if (!(_DWORD)CertData)
    {
      v17 = CFDataGetBytePtr(*(CFDataRef *)&length[1]);
      v18 = CFDataGetLength(*(CFDataRef *)&length[1]);
      CFDataAppendBytes(Mutable, v17, v18);
      v12 = DEREncoderCreate(0);
      if (v12)
      {
        v19 = CFDataGetBytePtr(Mutable);
        v20 = CFDataGetLength(Mutable);
        if (DEREncoderAddData(v12, 0, 16, v19, v20, 1))
        {
          v13 = 3;
          goto LABEL_6;
        }
        if (!DEREncoderCreateEncodedBuffer(v12, &bytes, length))
        {
          v13 = 0;
          *a2 = CFDataCreate(0, bytes, length[0]);
          goto LABEL_18;
        }
        AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedCertificateChain", "%s: failed to create buffer", v21, v22, v23, v24, v25, (char)"AMAuthInstallApImg4LocalCreateEncodedCertificateChain");
      }
      v13 = 0;
      goto LABEL_18;
    }
LABEL_45:
    v13 = CertData;
    v12 = 0;
    goto LABEL_6;
  }
  AMAuthInstallLog(3, "AMAuthInstallApImg4LocalCreateEncodedCertificateChain", "local signing is not available for production fused devices.", v5, v6, v7, v8, v9, v31);
  v12 = 0;
  v13 = 14;
LABEL_6:
  SafeRelease(*a2);
LABEL_18:
  SafeRelease(Mutable);
  SafeFree(bytes);
  DEREncoderDestroy(v12);
  return v13;
}

uint64_t AMAuthInstallApImg4LocalCreateSignedManifest(_QWORD *a1, const void *a2, const void *a3, const void *a4, const void *a5, CFTypeRef *a6, uint64_t a7, uint64_t a8)
{
  return _AMAuthInstallApImg4LocalCreateSignedManifest(a1, a2, a3, a4, a5, a6, 0, a8);
}

uint64_t AMAuthInstallApImg4LocalAddImageProperties(uint64_t a1, uint64_t a2, const __CFString *a3, const __CFDictionary *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  const __CFData *Value;
  const __CFData *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFBoolean *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const __CFBoolean *v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const __CFBoolean *v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  const __CFBoolean *v65;
  int v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  const __CFBoolean *v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  const __CFData *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  const char *v104;
  char v105;

  if (!a2)
  {
    v104 = "toEncoder cannot be NULL";
LABEL_28:
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", v104, (uint64_t)a4, a5, a6, a7, a8, v105);
    v11 = 0;
    v25 = 1;
    goto LABEL_24;
  }
  if (!a3)
  {
    v104 = "imageTag cannot be NULL";
    goto LABEL_28;
  }
  if (!a4)
  {
    v104 = "requestDict cannot be NULL";
    goto LABEL_28;
  }
  v11 = DEREncoderCreate(1);
  if (!v11)
  {
    v25 = 2;
    goto LABEL_24;
  }
  Value = (const __CFData *)CFDictionaryGetValue(a4, CFSTR("Digest"));
  if (Value)
  {
    v13 = Value;
    if (CFDataGetLength(Value) < 1)
    {
      AMAuthInstallLog(6, "AMAuthInstallApImg4LocalAddImageProperties", "'%@' has zero length digest - skipping digest", v14, v15, v16, v17, v18, (char)a3);
    }
    else
    {
      v19 = AMAuthInstallApImg4AddDataProperty(v11, CFSTR("DGST"), v13, v14, v15, v16, v17, v18);
      if ((_DWORD)v19)
      {
        v25 = v19;
        AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "failed to add Digest property for '%@'", v20, v21, v22, v23, v24, (char)a3);
        goto LABEL_24;
      }
    }
  }
  v26 = (const __CFBoolean *)CFDictionaryGetValue(a4, CFSTR("Trusted"));
  if (v26
    && (v27 = CFBooleanGetValue(v26),
        v33 = AMAuthInstallApImg4AddBooleanProperty(v11, CFSTR("EKEY"), v27, v28, v29, v30, v31, v32),
        (_DWORD)v33))
  {
    v25 = v33;
    AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "failed to add EKEY property for '%@'", v34, v35, v36, v37, v38, (char)a3);
  }
  else
  {
    v39 = (const __CFBoolean *)CFDictionaryGetValue(a4, CFSTR("DPRO"));
    if (v39
      && (v40 = CFBooleanGetValue(v39),
          v46 = AMAuthInstallApImg4AddBooleanProperty(v11, CFSTR("DPRO"), v40, v41, v42, v43, v44, v45),
          (_DWORD)v46))
    {
      v25 = v46;
      AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "failed to add DPRO property for '%@'", v47, v48, v49, v50, v51, (char)a3);
    }
    else
    {
      v52 = (const __CFBoolean *)CFDictionaryGetValue(a4, CFSTR("DSEC"));
      if (v52
        && (v53 = CFBooleanGetValue(v52),
            v59 = AMAuthInstallApImg4AddBooleanProperty(v11, CFSTR("DSEC"), v53, v54, v55, v56, v57, v58),
            (_DWORD)v59))
      {
        v25 = v59;
        AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "failed to add DSEC property for '%@'", v60, v61, v62, v63, v64, (char)a3);
      }
      else
      {
        v65 = (const __CFBoolean *)CFDictionaryGetValue(a4, CFSTR("ESEC"));
        if (v65
          && (v66 = CFBooleanGetValue(v65),
              v72 = AMAuthInstallApImg4AddBooleanProperty(v11, CFSTR("ESEC"), v66, v67, v68, v69, v70, v71),
              (_DWORD)v72))
        {
          v25 = v72;
          AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "failed to add ESEC property for '%@'", v73, v74, v75, v76, v77, (char)a3);
        }
        else
        {
          v78 = (const __CFBoolean *)CFDictionaryGetValue(a4, CFSTR("EPRO"));
          if (v78
            && (v79 = CFBooleanGetValue(v78),
                v85 = AMAuthInstallApImg4AddBooleanProperty(v11, CFSTR("EPRO"), v79, v80, v81, v82, v83, v84),
                (_DWORD)v85))
          {
            v25 = v85;
            AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "failed to add EPRO property for '%@'", v86, v87, v88, v89, v90, (char)a3);
          }
          else
          {
            v91 = (const __CFData *)CFDictionaryGetValue(a4, CFSTR("TBMDigests"));
            if (v91
              && (v97 = AMAuthInstallApImg4AddDataProperty(v11, CFSTR("tbms"), v91, v92, v93, v94, v95, v96), (_DWORD)v97))
            {
              v25 = v97;
              AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "failed to add %@ property for '%@'", v92, v93, v94, v95, v96, (char)CFSTR("tbms"));
            }
            else
            {
              v25 = AMAuthInstallApImg4AddDictionaryProperty(v11, a2, a3, v92, v93, v94, v95, v96);
              if ((_DWORD)v25)
                AMAuthInstallLog(3, "AMAuthInstallApImg4LocalAddImageProperties", "AMAuthInstallApImg4LocalAddDictionaryProperty failed for '%@'", v98, v99, v100, v101, v102, (char)a3);
            }
          }
        }
      }
    }
  }
LABEL_24:
  DEREncoderDestroy(v11);
  return v25;
}

void _AMAuthInstallBasebandParametersFinalize(CFTypeRef *a1)
{
  if (a1)
  {
    SafeRelease(a1[2]);
    SafeRelease(a1[3]);
    SafeRelease(a1[4]);
    SafeRelease(a1[5]);
    SafeRelease(a1[8]);
    SafeRelease(a1[9]);
    SafeRelease(a1[13]);
    SafeRelease(a1[14]);
    SafeRelease(a1[15]);
    SafeRelease(a1[16]);
    SafeRelease(a1[17]);
    SafeRelease(a1[18]);
    SafeRelease(a1[19]);
    SafeRelease(a1[21]);
    free(a1);
  }
}

__CFString *AMAuthInstallBasebandCopyDescription(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  const char *v4;
  const __CFAllocator *v5;
  const char *v6;
  const char *v7;
  const __CFAllocator *v8;
  const char *v9;
  const char *v10;

  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 256);
  CFStringAppend(Mutable, CFSTR("("));
  if (*(_BYTE *)(a1 + 58))
    v4 = "YES";
  else
    v4 = "NO";
  CFStringAppendFormat(Mutable, 0, CFSTR("personalize=%s"), v4);
  if (*(_QWORD *)(a1 + 48))
  {
    CFStringAppendFormat(Mutable, 0, CFSTR(", "));
    if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 16))
    {
      v5 = CFGetAllocator((CFTypeRef)a1);
      v6 = _CopyHexStringFromData(v5, *(CFDataRef *)(*(_QWORD *)(a1 + 48) + 16));
      if (v6)
      {
        v7 = v6;
        CFStringAppendFormat(Mutable, 0, CFSTR("snum=0x%@, "), v6);
        CFRelease(v7);
      }
    }
    CFStringAppendFormat(Mutable, 0, CFSTR("chipid=0x%x, certid=0x%x"), *(unsigned int *)(*(_QWORD *)(a1 + 48) + 4), *(unsigned int *)(*(_QWORD *)(a1 + 48) + 8));
    if (*(_QWORD *)(*(_QWORD *)(a1 + 48) + 24))
    {
      v8 = CFGetAllocator((CFTypeRef)a1);
      v9 = _CopyHexStringFromData(v8, *(CFDataRef *)(*(_QWORD *)(a1 + 48) + 24));
      if (v9)
      {
        v10 = v9;
        CFStringAppendFormat(Mutable, 0, CFSTR(", nonce=0x%@"), v9);
        CFRelease(v10);
      }
    }
  }
  CFStringAppend(Mutable, CFSTR(")"));
  return Mutable;
}

uint64_t AMAuthInstallBasebandLocalSetSigningParameters(void *cf, uint64_t a2, const void *a3, const void *a4, const void *a5, const void *a6)
{
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  char LocalizedStatusString;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;

  if (cf)
  {
    if (a2 && a3 && a4 || (v12 = 1, !a2) && !a3 && !a4 && !a5 && !a6)
    {
      v13 = (_QWORD *)*((_QWORD *)cf + 46);
      if (v13)
      {
        AMAuthInstallReleaseRsaKeyData(*v13);
        SafeRelease(*(CFTypeRef *)(*((_QWORD *)cf + 46) + 8));
        SafeRelease(*(CFTypeRef *)(*((_QWORD *)cf + 46) + 16));
        SafeRelease(*(CFTypeRef *)(*((_QWORD *)cf + 46) + 24));
        SafeRelease(*(CFTypeRef *)(*((_QWORD *)cf + 46) + 32));
        free(*((void **)cf + 46));
        *((_QWORD *)cf + 46) = 0;
      }
      if (a2)
      {
        CFGetAllocator(cf);
        v14 = AMAuthInstallCopyRsaKeyDataForKey();
        if ((_DWORD)v14)
        {
          v12 = v14;
          LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)cf, v14);
          AMAuthInstallLog(3, "AMAuthInstallBasebandLocalSetSigningParameters", "bad local signing key: %@", v16, v17, v18, v19, v20, LocalizedStatusString);
        }
        else
        {
          v21 = calloc(1uLL, 0x28uLL);
          *((_QWORD *)cf + 46) = v21;
          if (v21)
          {
            **((_QWORD **)cf + 46) = CFRetain(0);
            *(_QWORD *)(*((_QWORD *)cf + 46) + 8) = CFRetain(a3);
            *(_QWORD *)(*((_QWORD *)cf + 46) + 16) = CFRetain(a4);
            *(_QWORD *)(*((_QWORD *)cf + 46) + 32) = CFRetain(a6);
            v12 = 0;
            *(_QWORD *)(*((_QWORD *)cf + 46) + 24) = SafeRetain(a5);
          }
          else
          {
            v12 = 2;
          }
        }
      }
      else
      {
        v12 = 0;
      }
    }
  }
  else
  {
    v12 = 1;
  }
  SafeRelease(0);
  SafeRelease(0);
  return v12;
}

void AMAuthInstallBasebandFinalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char v19;
  char v20;
  char v21;

  if (*(_QWORD *)(a1 + 176))
  {
    AMAuthInstallLog(3, "AMAuthInstallBasebandFinalize", "*********************************", a4, a5, a6, a7, a8, v19);
    AMAuthInstallLog(3, "AMAuthInstallBasebandFinalize", "* unacknowledged fusing program *", v9, v10, v11, v12, v13, v20);
    AMAuthInstallLog(3, "AMAuthInstallBasebandFinalize", "*********************************", v14, v15, v16, v17, v18, v21);
  }
  _AMAuthInstallBasebandParametersFinalize(*(CFTypeRef **)(a1 + 48));
  AMAuthInstallBasebandLocalSetSigningParameters((void *)a1, 0, 0, 0, 0, 0);
  SafeRelease(*(CFTypeRef *)(a1 + 160));
  SafeRelease(*(CFTypeRef *)(a1 + 168));
  SafeRelease(*(CFTypeRef *)(a1 + 176));
  SafeRelease(*(CFTypeRef *)(a1 + 192));
  SafeRelease(*(CFTypeRef *)(a1 + 200));
  SafeRelease(*(CFTypeRef *)(a1 + 208));
  SafeRelease(*(CFTypeRef *)(a1 + 216));
  SafeRelease(*(CFTypeRef *)(a1 + 136));
  SafeRelease(*(CFTypeRef *)(a1 + 240));
  SafeRelease(*(CFTypeRef *)(a1 + 264));
  SafeRelease(*(CFTypeRef *)(a1 + 248));
  SafeRelease(*(CFTypeRef *)(a1 + 232));
  SafeRelease(*(CFTypeRef *)(a1 + 272));
  SafeRelease(*(CFTypeRef *)(a1 + 280));
}

__CFDictionary *AMAuthInstallUpdaterCryptex1LocalPolicyGetTags(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableArrayRef Mutable;
  __CFArray *v6;
  __CFArray *v7;
  __CFDictionary *v8;
  __CFDictionary *v9;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: buildIdentityTags is NULL"));
    v7 = 0;
LABEL_8:
    v9 = 0;
    goto LABEL_5;
  }
  v6 = CFArrayCreateMutable(kCFAllocatorDefault, 1, &kCFTypeArrayCallBacks);
  v7 = v6;
  if (!v6)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: responseTags is NULL"));
    goto LABEL_8;
  }
  CFArrayAppendValue(v6, CFSTR("ApImg4Ticket"));
  v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v9 = v8;
  if (v8)
  {
    CFDictionaryAddValue(v8, CFSTR("BuildIdentityTags"), Mutable);
    CFDictionaryAddValue(v9, CFSTR("ResponseTags"), v7);
  }
  else
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: dict is NULL"));
  }
LABEL_5:
  AMSupportSafeRelease(Mutable);
  AMSupportSafeRelease(v7);
  return v9;
}

CFMutableDictionaryRef AMAuthInstallUpdaterCryptex1LocalPolicyCopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableDictionaryRef Mutable;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: dict is NULL"));
  return Mutable;
}

__CFDictionary *AMAuthInstallUpdaterCryptex1LocalPolicyCreateRequest(const __CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFDictionary *Mutable;
  const __CFDictionary *Value;
  const __CFDictionary *v8;
  __CFArray *v9;
  CFIndex v10;
  const void *ValueAtIndex;
  const void *v12;
  __CFDictionary *v13;
  CFDataRef v14;
  CFDataRef v15;
  const __CFString *v17;
  uint64_t v18;
  uint64_t v19;
  const __CFString *v20;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v17 = CFSTR("%s: request is NULL");
    v18 = a4;
    v19 = 2;
LABEL_14:
    AMSupportCreateErrorInternal(v18, CFSTR("AuthInstallErrorDomain"), v19, 0, v17);
    v9 = 0;
    v13 = 0;
LABEL_18:
    AMSupportSafeRelease(0);
    AMSupportSafeRelease(v13);
    AMSupportSafeRelease(v9);
    v9 = Mutable;
    Mutable = 0;
    goto LABEL_11;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  if (!Value)
  {
    v17 = CFSTR("%s: deviceInfo is NULL");
    v18 = a4;
    v19 = 14;
    goto LABEL_14;
  }
  v8 = Value;
  v9 = CFArrayCreateMutable(kCFAllocatorDefault, 13, &kCFTypeArrayCallBacks);
  CFArrayAppendValue(v9, CFSTR("ApBoardID"));
  CFArrayAppendValue(v9, CFSTR("ApChipID"));
  CFArrayAppendValue(v9, CFSTR("ApECID"));
  CFArrayAppendValue(v9, CFSTR("ApProductionMode"));
  CFArrayAppendValue(v9, CFSTR("ApSecurityDomain"));
  CFArrayAppendValue(v9, CFSTR("ApSecurityMode"));
  CFArrayAppendValue(v9, CFSTR("Ap,RecoveryOSPolicyNonceHash"));
  CFArrayAppendValue(v9, CFSTR("Ap,NextStageIM4MHash"));
  CFArrayAppendValue(v9, CFSTR("Ap,NextStageCryptex1IM4MHash"));
  CFArrayAppendValue(v9, CFSTR("Ap,VolumeUUID"));
  if (CFArrayGetCount(v9) >= 1)
  {
    v10 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v9, v10);
      v12 = CFDictionaryGetValue(v8, ValueAtIndex);
      if (v12)
        CFDictionarySetValue(Mutable, ValueAtIndex, v12);
      ++v10;
    }
    while (v10 < CFArrayGetCount(v9));
  }
  CFDictionarySetValue(Mutable, CFSTR("@ApImg4Ticket"), kCFBooleanTrue);
  CFDictionarySetValue(Mutable, CFSTR("Ap,LocalBoot"), kCFBooleanTrue);
  v13 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v13)
  {
    v20 = CFSTR("%s: localPolicyMeasurements is NULL");
LABEL_17:
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, v20);
    goto LABEL_18;
  }
  v14 = AMAuthInstallLocalPolicyCopyPayloadDigestSHA384();
  if (!v14)
  {
    v20 = CFSTR("%s: localPolicyDigest is NULL");
    goto LABEL_17;
  }
  v15 = v14;
  CFDictionarySetValue(v13, CFSTR("Digest"), v14);
  CFDictionarySetValue(v13, CFSTR("Trusted"), kCFBooleanTrue);
  CFDictionarySetValue(Mutable, CFSTR("Ap,LocalPolicy"), v13);
  AMSupportSafeRelease(v15);
  AMSupportSafeRelease(v13);
LABEL_11:
  AMSupportSafeRelease(v9);
  return Mutable;
}

void AMAuthInstallBundleFinalize(uint64_t a1)
{
  CFTypeRef *v1;

  v1 = *(CFTypeRef **)(a1 + 128);
  if (v1)
  {
    SafeRelease(*v1);
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 128) + 8));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 128) + 16));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 128) + 24));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 128) + 32));
    SafeRelease(*(CFTypeRef *)(*(_QWORD *)(a1 + 128) + 40));
    SafeFree(*(void **)(a1 + 128));
    *(_QWORD *)(a1 + 128) = 0;
  }
}

uint64_t AMAuthInstallCopyRsaKeyDataForKey()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterKeysFromPEMBuffer()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature_SHA256()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateRsaSignature_SHA384()
{
  return 13;
}

uint64_t AMAuthInstallCryptoCreateDigestForData(const __CFAllocator *a1, const __CFData *a2, CFTypeRef *a3)
{
  __CFData *Mutable;
  __CFData *v6;
  const UInt8 *BytePtr;
  CC_LONG Length;
  unsigned __int8 *MutableBytePtr;
  uint64_t v10;
  CC_SHA1_CTX v12;

  memset(&v12, 0, sizeof(v12));
  Mutable = CFDataCreateMutable(a1, 20);
  v6 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, 20);
    CC_SHA1_Init(&v12);
    BytePtr = CFDataGetBytePtr(a2);
    Length = CFDataGetLength(a2);
    CC_SHA1_Update(&v12, BytePtr, Length);
    MutableBytePtr = CFDataGetMutableBytePtr(v6);
    CC_SHA1_Final(MutableBytePtr, &v12);
    v10 = 0;
    *a3 = CFRetain(v6);
  }
  else
  {
    v10 = 2;
  }
  SafeRelease(v6);
  return v10;
}

uint64_t AMAuthInstallCryptoGetCertData()
{
  return 13;
}

uint64_t AMAuthInstallCryptoRegisterCertFromPEMBuffer()
{
  return 13;
}

uint64_t AMAuthInstallHttpMessageSendSyncNew(CFAllocatorRef allocator, uint64_t a2, CFTypeRef *a3, _DWORD *a4, CFDictionaryRef theDict, double a6)
{
  CFIndex Count;
  const __CFDictionary *MutableCopy;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFNumberRef v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v36;
  uint64_t v37;
  uint64_t v38;
  CFTypeRef cf;
  double valuePtr;

  valuePtr = a6;
  v38 = 0;
  cf = 0;
  v37 = -1;
  if (theDict)
  {
    Count = CFDictionaryGetCount(theDict);
    MutableCopy = CFDictionaryCreateMutableCopy(allocator, Count, theDict);
    if (CFDictionaryContainsKey(MutableCopy, kAMSupportHttpOptionSocksProxySettings))
      AMAuthInstallLog(7, "AMAuthInstallHttpMessageSendSyncNew", "Options dictionary contains proxy information. Will attempt to use a proxy.", v13, v14, v15, v16, v17, v36);
    if (CFDictionaryContainsKey(MutableCopy, kAMSupportHttpOptionTrustedServerCAs))
      AMAuthInstallLog(7, "AMAuthInstallHttpMessageSendSyncNew", "Options dictionary contains trusted server CAs. Will authenticate SSL against CAs.", v18, v19, v20, v21, v22, v36);
  }
  else
  {
    MutableCopy = CFDictionaryCreateMutable(allocator, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  }
  if (!MutableCopy)
  {
    AMAuthInstallLog(3, "AMAuthInstallHttpMessageSendSyncNew", "CFDictionaryCreateMutable failed to allocate", v18, v19, v20, v21, v22, v36);
    v28 = 0;
LABEL_18:
    v34 = 2;
    goto LABEL_15;
  }
  v28 = CFNumberCreate(allocator, kCFNumberDoubleType, &valuePtr);
  if (!v28)
  {
    AMAuthInstallLog(3, "AMAuthInstallHttpMessageSendSyncNew", "timeout failed to allocate", v23, v24, v25, v26, v27, v36);
    goto LABEL_18;
  }
  CFDictionarySetValue(MutableCopy, kAMSupportHttpOptionTimeout, v28);
  AMSupportHttpSendSync(a2, MutableCopy, &cf, 0, &v37, &v38);
  if (v38)
  {
    AMAuthInstallLog(3, "AMAuthInstallHttpMessageSendSyncNew", "HTTP request failed with error %@", v29, v30, v31, v32, v33, v38);
LABEL_21:
    v34 = 16;
    goto LABEL_15;
  }
  if (!cf)
  {
    AMAuthInstallLog(3, "AMAuthInstallHttpMessageSendSyncNew", "HTTP request provided no response data", v29, v30, v31, v32, v33, v36);
    goto LABEL_21;
  }
  if (a3)
    *a3 = CFRetain(cf);
  v34 = 0;
  if (a4)
    *a4 = v37;
LABEL_15:
  AMSupportSafeRelease(cf);
  AMSupportSafeRelease(MutableCopy);
  AMSupportSafeRelease(v28);
  return v34;
}

uint64_t AMAuthInstallLockCreate(uint64_t a1)
{
  uint64_t result;

  pthread_once(&stru_1001A7838, (void (*)(void))sub_1000A3EFC);
  result = _CFRuntimeCreateInstance(a1, qword_1001A8228, 8, 0);
  if (result)
    *(_DWORD *)(result + 16) = 0;
  return result;
}

uint64_t sub_1000A3EFC()
{
  uint64_t result;

  result = _CFRuntimeRegisterClass(&unk_100181FE8);
  qword_1001A8228 = result;
  return result;
}

CFDataRef AMAuthInstallLocalPolicyCopyPayloadDigestSHA384()
{
  return CFDataCreate(kCFAllocatorDefault, byte_10016708E, 48);
}

void (*AMAuthInstallLogSetHandler(void (*result)(int a1, uint64_t a2)))(int a1, uint64_t a2)
{
  void (*v1)(int, uint64_t);

  v1 = sub_1000A3F5C;
  if (result)
    v1 = result;
  off_1001A7848 = (uint64_t (*)(_QWORD, _QWORD))v1;
  return result;
}

void sub_1000A3F5C(int a1, uint64_t a2)
{
  uint64_t v4;
  NSObject *v5;
  os_log_type_t v6;
  uint64_t v7;
  _BOOL4 v8;
  int v9;
  uint64_t v10;

  if (qword_1001A8238 != -1)
    dispatch_once(&qword_1001A8238, &stru_100182068);
  if (a1 <= 2)
  {
    if (os_log_type_enabled((os_log_t)qword_1001A8230, OS_LOG_TYPE_FAULT))
      sub_1000F9FB4();
    return;
  }
  if (a1 == 3)
  {
    if (os_log_type_enabled((os_log_t)qword_1001A8230, OS_LOG_TYPE_ERROR))
      sub_1000FA020();
    return;
  }
  if (a1 <= 5)
  {
    v4 = qword_1001A8230;
    if (!os_log_type_enabled((os_log_t)qword_1001A8230, OS_LOG_TYPE_DEFAULT))
      return;
    v9 = 136446210;
    v10 = a2;
    v5 = v4;
    v6 = OS_LOG_TYPE_DEFAULT;
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v5, v6, "%{public}s", (uint8_t *)&v9, 0xCu);
    return;
  }
  if (a1 == 6)
  {
    v7 = qword_1001A8230;
    if (!os_log_type_enabled((os_log_t)qword_1001A8230, OS_LOG_TYPE_INFO))
      return;
    v9 = 136446210;
    v10 = a2;
    v5 = v7;
    v6 = OS_LOG_TYPE_INFO;
    goto LABEL_15;
  }
  v8 = os_log_type_enabled((os_log_t)qword_1001A8230, OS_LOG_TYPE_DEBUG);
  if (a1 > 7)
  {
    if (v8)
      sub_1000FA0EC();
  }
  else if (v8)
  {
    sub_1000FA08C();
  }
}

void AMAuthInstallLog(uint64_t a1, const char *a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const char *v11;
  unsigned int v12;
  const __CFString *v13;
  const __CFString *v14;
  const __CFString *v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int Length;
  unsigned int v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  const char *v24;
  char __str[4096];

  v11 = "";
  if (a2)
    v11 = a2;
  v12 = snprintf(__str, 0x1000uLL, "%s: ", v11);
  v13 = CFStringCreateWithCStringNoCopy(kCFAllocatorDefault, a3, 0x8000100u, kCFAllocatorNull);
  if (!v13)
  {
    v15 = 0;
    goto LABEL_9;
  }
  v14 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, v13, &a9);
  v15 = v14;
  if (!v14)
  {
LABEL_9:
    v23 = 0;
    v22 = 0;
    goto LABEL_14;
  }
  v16 = v12;
  v17 = 4096 - v12;
  Length = CFStringGetLength(v14);
  v19 = Length;
  if (4096 - v12 < Length && (v20 = (char *)malloc(v12 + Length + 1)) != 0)
  {
    v21 = v20;
    v17 = v19 + 1;
    memcpy(v20, __str, v12);
    v22 = v21;
  }
  else
  {
    v22 = 0;
    v21 = __str;
  }
  if (CFStringGetCString(v15, &v21[v16], v17, 0x8000100u))
    v23 = v21;
  else
    v23 = 0;
LABEL_14:
  if (v23)
    v24 = v23;
  else
    v24 = "failed to format log message";
  off_1001A7848(a1, v24);
  SafeRelease(v13);
  SafeRelease(v15);
  SafeFree(v22);
}

uint64_t AMAuthInstallDebugWriteObject(char *cf, CFTypeRef a2, uint64_t a3, int a4)
{
  CFTypeID v7;
  const __CFData *Data;
  const char *v9;
  const __CFAllocator *v10;
  CFStringRef v11;
  const __CFString *v12;
  const __CFAllocator *v13;
  uint64_t v14;
  const __CFAllocator *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  CFAllocatorRef v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  CFTypeID v28;
  CFTypeID v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFAllocator *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  char v42;
  CFTypeRef cfa;

  cfa = 0;
  if (!cf)
    goto LABEL_19;
  if ((*((_DWORD *)cf + 86) & a4) == 0)
  {
    v14 = 0;
LABEL_12:
    Data = 0;
    goto LABEL_20;
  }
  if (!*((_QWORD *)cf + 42))
  {
    v21 = CFGetAllocator(cf);
    v22 = AMAuthInstallSupportCopyURLToNewTempDirectory(v21, "amai-debug.XXXXXX", cf + 336);
    if ((_DWORD)v22)
    {
      v14 = v22;
      AMAuthInstallLog(3, "AMAuthInstallDebugWriteObject", "failed to create debug output directory", v23, v24, v25, v26, v27, v42);
      goto LABEL_12;
    }
  }
  v7 = CFGetTypeID(a2);
  if (v7 == CFDataGetTypeID())
  {
    Data = (const __CFData *)CFRetain(a2);
    v9 = "";
    if (Data)
      goto LABEL_6;
LABEL_16:
    v14 = 0;
    goto LABEL_20;
  }
  v28 = CFGetTypeID(a2);
  if (v28 != CFDictionaryGetTypeID())
  {
    v29 = CFGetTypeID(a2);
    if (v29 != CFArrayGetTypeID())
    {
      AMAuthInstallLog(3, "AMAuthInstallDebugWriteObject", "can't prepare data for output to file", v30, v31, v32, v33, v34, v42);
      AMAuthInstallLog(7, "AMAuthInstallDebugWriteObject", "%@", v36, v37, v38, v39, v40, (char)a2);
LABEL_19:
      Data = 0;
      v14 = 1;
      goto LABEL_20;
    }
  }
  v35 = CFGetAllocator(cf);
  Data = CFPropertyListCreateData(v35, a2, kCFPropertyListXMLFormat_v1_0, 0, 0);
  v9 = ".plist";
  if (!Data)
    goto LABEL_16;
LABEL_6:
  v10 = CFGetAllocator(cf);
  v11 = CFStringCreateWithFormat(v10, 0, CFSTR("%@%s"), a3, v9);
  if (v11)
  {
    v12 = v11;
    v13 = CFGetAllocator(cf);
    v14 = AMAuthInstallSupportCopyURLWithAppendedComponent(v13, *((const void **)cf + 42), v12, 0, (CFURLRef *)&cfa);
    CFRelease(v12);
    if (!(_DWORD)v14)
    {
      v15 = CFGetAllocator(cf);
      v14 = AMAuthInstallSupportWriteDataToFileURL(v15, Data, (const __CFURL *)cfa, 0);
      AMAuthInstallLog(7, "AMAuthInstallDebugWriteObject", "debug object written: %@", v16, v17, v18, v19, v20, (char)cfa);
    }
  }
  else
  {
    v14 = 2;
  }
LABEL_20:
  SafeRelease(Data);
  SafeRelease(cfa);
  return v14;
}

void sub_1000A4504(id a1)
{
  qword_1001A8230 = (uint64_t)os_log_create("com.apple.libauthinstall", "AMAuthInstallLog");
}

void sub_1000A4530(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_debug_impl(a1, a2, OS_LOG_TYPE_DEBUG, a4, &a9, 0xCu);
}

uint64_t AMAuthInstallPlatformRemoveFile(const __CFURL *a1)
{
  char v1;
  std::error_code *v2;
  uint64_t result;
  int *v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  std::__fs::filesystem::path buffer[42];

  v1 = (char)a1;
  if (!CFURLGetFileSystemRepresentation(a1, 1u, (UInt8 *)buffer, 1024))
    return 3;
  result = remove(buffer, v2);
  if ((_DWORD)result)
  {
    v4 = __error();
    v5 = strerror(*v4);
    AMAuthInstallLog(3, "AMAuthInstallPlatformRemoveFile", "failed to file: %s", v6, v7, v8, v9, v10, v5);
    AMAuthInstallLog(7, "AMAuthInstallPlatformRemoveFile", "url=%@, path=%s", v11, v12, v13, v14, v15, v1);
    return 4;
  }
  return result;
}

uint64_t AMAuthInstallPlatformCopyURLToNewTempDirectory(const __CFAllocator *a1, const char *a2, CFURLRef *a3)
{
  uint64_t result;
  char v6;
  size_t v7;
  CFURLRef v8;
  CFURLRef v9;
  int *v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char __str[1024];

  result = 1;
  if (a2 && a3)
  {
    v6 = (char)a2;
    snprintf(__str, 0x400uLL, "/tmp/%s", a2);
    if (mkdtemp(__str))
    {
      v7 = strlen(__str);
      v8 = CFURLCreateFromFileSystemRepresentation(a1, (const UInt8 *)__str, v7, 1u);
      if (v8)
      {
        v9 = v8;
        result = 0;
        *a3 = v9;
      }
      else
      {
        unlink(__str);
        return 2;
      }
    }
    else
    {
      v10 = __error();
      v11 = strerror(*v10);
      AMAuthInstallLog(3, "AMAuthInstallPlatformCopyURLToNewTempDirectory", "failed to create tmp dir: %s", v12, v13, v14, v15, v16, v11);
      AMAuthInstallLog(8, "AMAuthInstallPlatformCopyURLToNewTempDirectory", "tmp dir template: %s", v17, v18, v19, v20, v21, v6);
      return 4;
    }
  }
  return result;
}

uint64_t AMAuthInstallPlatformWriteBufferToNativeFilePath(char *a1, int a2, char *a3)
{
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int *v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v6 = open(a3, 1537, 420);
  if ((v6 & 0x80000000) == 0)
  {
    v7 = v6;
    if (a2 < 1)
    {
LABEL_6:
      close(v7);
      return 0;
    }
    v8 = 0;
    v9 = a2;
    while (1)
    {
      v10 = write(v7, a1, v9);
      if (v10 <= 0)
        break;
      a1 += v10;
      v9 -= v10;
      v8 += v10;
      if (v8 >= a2)
        goto LABEL_6;
    }
    close(v7);
    unlink(a3);
  }
  v12 = __error();
  v13 = strerror(*v12);
  AMAuthInstallLog(3, "AMAuthInstallPlatformWriteBufferToNativeFilePath", "failed to open file for writing: %s", v14, v15, v16, v17, v18, v13);
  AMAuthInstallLog(7, "AMAuthInstallPlatformWriteBufferToNativeFilePath", "path: %s", v19, v20, v21, v22, v23, (char)a3);
  return 4;
}

uint64_t AMAuthInstallPlatformWriteDataToFileURL(const __CFData *a1, CFURLRef url)
{
  char *BytePtr;
  int Length;
  UInt8 buffer[1024];

  if (!CFURLGetFileSystemRepresentation(url, 1u, buffer, 1024))
    return 3;
  BytePtr = (char *)CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  return AMAuthInstallPlatformWriteBufferToNativeFilePath(BytePtr, Length, (char *)buffer);
}

uint64_t AMAuthInstallPlatformCopyURLWithAppendedComponent(const __CFAllocator *a1, CFTypeRef cf, const __CFString *a3, Boolean a4, CFURLRef *a5)
{
  CFTypeID v10;
  CFTypeID v11;
  uint64_t result;
  CFURLRef v13;
  CFURLRef v14;

  if (!cf)
    return 1;
  v10 = CFGetTypeID(cf);
  v11 = CFURLGetTypeID();
  result = 1;
  if (a5 && a3 && v10 == v11)
  {
    v13 = CFURLCreateCopyAppendingPathComponent(a1, (CFURLRef)cf, a3, a4);
    if (v13)
    {
      v14 = v13;
      result = 0;
      *a5 = v14;
    }
    else
    {
      return 2;
    }
  }
  return result;
}

uint64_t AMAuthInstallPlatformFileURLExists(const __CFURL *a1, BOOL *a2)
{
  uint64_t v2;
  int v4;
  stat v6;
  UInt8 buffer[1024];

  v2 = 1;
  if (a1 && a2)
  {
    memset(&v6, 0, sizeof(v6));
    if (CFURLGetFileSystemRepresentation(a1, 1u, buffer, 1024))
    {
      v4 = stat((const char *)buffer, &v6);
      v2 = 0;
      *a2 = v4 == 0;
    }
    else
    {
      return 3;
    }
  }
  return v2;
}

const __CFString *sub_1000A4A1C()
{
  const __CFString *result;
  size_t v1;
  _BYTE v2[32];
  _BYTE v3[32];

  qword_1001A8240 = (uint64_t)CFURLCreateWithFileSystemPath(kCFAllocatorDefault, CFSTR("/tmp"), kCFURLPOSIXPathStyle, 1u);
  if (!qword_1001A8240)
    sub_1000FA14C();
  v1 = 32;
  result = (const __CFString *)sysctlbyname("kern.osversion", v3, &v1, 0, 0);
  if (!(_DWORD)result)
  {
    v1 = 32;
    if (!sysctlbyname("hw.product", v2, &v1, 0, 0)
      || (result = (const __CFString *)sysctlbyname("hw.machine", v2, &v1, 0, 0), !(_DWORD)result))
    {
      result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("mac/%s/%s"), v3, v2);
      if (result)
        goto LABEL_6;
    }
  }
  if (!qword_1001A8248)
  {
    result = CFSTR("???");
LABEL_6:
    qword_1001A8248 = (uint64_t)result;
  }
  return result;
}

uint64_t AMAuthInstallPlatformGetPlatformInfoString()
{
  pthread_once(&stru_1001A7850, (void (*)(void))sub_1000A4A1C);
  return qword_1001A8248;
}

const __CFString *AMAuthInstallPlatformGetSimplePlatformInfoString()
{
  return CFSTR("iOS");
}

uint64_t AMAuthInstallRequestSendSyncWithHeader(uint64_t a1, const void *a2, uint64_t a3, CFTypeRef *a4)
{
  const __CFAllocator *v8;
  uint64_t v9;
  __CFDictionary *DeepCopy;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void *v16;
  const void **v17;
  const __CFData *v18;
  const __CFData *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t (*v25)(uint64_t, CFAllocatorRef, uint64_t, uint64_t *);
  CFAllocatorRef v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const __CFData *Data;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  const __CFDictionary *v41;
  __CFDictionary *v42;
  const __CFString *SimplePlatformInfoString;
  __CFDictionary *v44;
  const __CFString *LibraryVersionString;
  uint64_t v46;
  const void *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *session;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  const void *v77;
  const __CFAllocator *v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  CFNumberRef v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  char LocalizedStatusString;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  const __CFAllocator *v96;
  const __CFAllocator *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const void *Value;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  const __CFString *v125;
  char v126;
  char v127;
  char v128;
  uint64_t context;
  __CFDictionary *MutableCopy;
  CFMutableDictionaryRef theDict;
  uint64_t v132;
  CFTypeRef v133;
  CFTypeRef cf;

  v133 = 0;
  cf = 0;
  v132 = 0;
  v8 = CFGetAllocator((CFTypeRef)a1);
  v9 = 2;
  DeepCopy = (__CFDictionary *)CFPropertyListCreateDeepCopy(v8, a2, 2uLL);
  theDict = DeepCopy;
  if (!DeepCopy)
    goto LABEL_28;
  v16 = *(const void **)(a1 + 64);
  if (v16)
    CFDictionarySetValue(DeepCopy, CFSTR("@Locality"), v16);
  v17 = (const void **)(a1 + 120);
  v18 = *(const __CFData **)(a1 + 120);
  v19 = v18;
  if (!v18)
  {
    if (!*(_QWORD *)(a1 + 104))
    {
      AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "SSO function returned NULL and no SSO token was provided, SSO disabled.", v11, v12, v13, v14, v15, v126);
      goto LABEL_15;
    }
    AMAuthInstallLog(5, "AMAuthInstallRequestSendSyncWithHeader", "using SSO.", v11, v12, v13, v14, v15, v126);
    v19 = (const __CFData *)*v17;
    if (!*v17)
    {
      v25 = *(uint64_t (**)(uint64_t, CFAllocatorRef, uint64_t, uint64_t *))(a1 + 104);
      v26 = CFGetAllocator((CFTypeRef)a1);
      v27 = v25(a1, v26, a1 + 120, &v132);
      if ((_DWORD)v27)
      {
        v9 = v27;
        AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "failed to create sso data %@", v28, v29, v30, v31, v32, v132);
        goto LABEL_13;
      }
      v19 = (const __CFData *)*v17;
      if (!*v17)
      {
        AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "SSO failed to authenticate.", v28, v29, v30, v31, v32, v126);
        Data = 0;
        v34 = 0;
        v9 = 22;
        goto LABEL_29;
      }
    }
  }
  AMAuthInstallCryptoCreateDigestForData(kCFAllocatorDefault, v19, &cf);
  if (cf)
  {
    AMAuthInstallLog(7, "AMAuthInstallRequestSendSyncWithHeader", "AuthUserId Hash: %@", v20, v21, v22, v23, v24, (char)cf);
    CFRelease(cf);
  }
  CFDictionarySetValue(theDict, CFSTR("AuthUserId"), *v17);
  if (!v18)
  {
    SafeRelease(*v17);
    *v17 = 0;
  }
LABEL_15:
  v35 = *(_QWORD *)(a1 + 16);
  if (!v35)
    goto LABEL_21;
  if (*(_QWORD *)(v35 + 144))
  {
    context = a1;
    MutableCopy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    if (MutableCopy)
    {
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1000A51AC, &context);
      SafeRelease(theDict);
      theDict = MutableCopy;
      v35 = *(_QWORD *)(a1 + 16);
      if (!v35)
        goto LABEL_21;
      goto LABEL_19;
    }
    AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "fullrequest copy allocation failure", v36, v37, v38, v39, v40, v126);
    v9 = 0;
LABEL_13:
    Data = 0;
    v34 = 0;
    goto LABEL_29;
  }
LABEL_19:
  v41 = *(const __CFDictionary **)(v35 + 136);
  if (v41)
    CFDictionaryApplyFunction(v41, (CFDictionaryApplierFunction)sub_1000A5338, theDict);
LABEL_21:
  v42 = theDict;
  SimplePlatformInfoString = AMAuthInstallPlatformGetSimplePlatformInfoString();
  CFDictionarySetValue(v42, CFSTR("@HostPlatformInfo"), SimplePlatformInfoString);
  v44 = theDict;
  LibraryVersionString = AMAuthInstallSupportGetLibraryVersionString();
  CFDictionarySetValue(v44, CFSTR("@VersionInfo"), LibraryVersionString);
  v46 = *(_QWORD *)(a1 + 16);
  if (!v46 || !*(_BYTE *)(v46 + 116))
    CFDictionarySetValue(theDict, CFSTR("@BBTicket"), kCFBooleanTrue);
  v47 = *(const void **)(a1 + 96);
  if (v47)
    CFDictionarySetValue(theDict, CFSTR("@UUID"), v47);
  v48 = AMAuthInstallVinylRemoveFirmwareLoaderVersionTag((const void *)a1, &theDict);
  if ((_DWORD)v48)
  {
    v9 = v48;
    AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "AMAuthInstallVinylRemoveFirmwareLoaderVersionTag %d", v49, v50, v51, v52, v53, v48);
LABEL_28:
    Data = 0;
    v34 = 0;
    goto LABEL_29;
  }
  v9 = 2;
  AMAuthInstallDebugWriteObject((char *)a1, theDict, (uint64_t)CFSTR("tss-request"), 2);
  session = tss_create_session(&stru_1001856C8, *(const void **)(a1 + 72));
  v34 = (uint64_t)session;
  if (!session)
  {
    Data = 0;
    goto LABEL_29;
  }
  CFRelease((CFTypeRef)session[3]);
  *(_QWORD *)(v34 + 24) = CFRetain(theDict);
  *(_DWORD *)(v34 + 16) = *(_DWORD *)(a1 + 80);
  *(_QWORD *)(v34 + 80) = *(_QWORD *)(a1 + 488);
  *(_QWORD *)(v34 + 88) = *(_QWORD *)(a1 + 512);
  *(_QWORD *)(v34 + 32) = a3;
  v70 = tss_submit(v34, v63, v64, v65, v66, v67, v68, v69);
  v76 = v70;
  if (!v70)
  {
    v9 = 0;
    goto LABEL_52;
  }
  if (v70 <= 0x2710)
  {
    v77 = *(const void **)(v34 + 72);
    if (v77)
    {
      v9 = v70 + 3100;
      LODWORD(context) = v70 + 3100;
      if (v70 < 0x384)
      {
        v78 = CFGetAllocator((CFTypeRef)a1);
        v84 = CFNumberCreate(v78, kCFNumberIntType, &context);
        if (v84)
        {
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 352), v84, v77);
          AMAuthInstallLog(7, "kAMAuthInstallRequestCacheLocalizedTssError", "cached server error text: (%d) %@", v85, v86, v87, v88, v89, context);
        }
        else
        {
          AMAuthInstallLog(3, "kAMAuthInstallRequestCacheLocalizedTssError", "failed to cache server error text: (%d) %@", v79, v80, v81, v82, v83, context);
        }
        SafeRelease(v84);
        goto LABEL_51;
      }
      AMAuthInstallLog(3, "kAMAuthInstallRequestCacheLocalizedTssError", "tss error code out of bounds (%d)", v71, v72, v73, v74, v75, v70 + 28);
    }
  }
  SafeRelease(0);
  if (v76 > 9999)
  {
    if ((v76 - 10000) > 0xC)
      v9 = 14;
    else
      v9 = dword_1001670C8[v76 - 10000];
  }
  else
  {
    v9 = (v76 + 3100);
  }
LABEL_51:
  LocalizedStatusString = AMAuthInstallGetLocalizedStatusString((CFDictionaryRef *)a1, v9);
  AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "failed tss submission: %@", v91, v92, v93, v94, v95, LocalizedStatusString);
LABEL_52:
  v96 = CFGetAllocator((CFTypeRef)a1);
  Data = CFPropertyListCreateData(v96, theDict, kCFPropertyListXMLFormat_v1_0, 0, 0);
  if (Data)
  {
    v97 = CFGetAllocator((CFTypeRef)a1);
    v103 = AMAuthInstallSupportBase64Encode(v97, Data, &v133, v98, v99, v100, v101, v102);
    if (v76)
    {
      if (!v103)
      {
        AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "failed tss request:<<<<<<<<<<\n%@", v104, v105, v106, v107, v108, (char)v133);
        AMAuthInstallLog(3, "AMAuthInstallRequestSendSyncWithHeader", "failed tss request:>>>>>>>>>>", v109, v110, v111, v112, v113, v127);
      }
    }
    else
    {
      if (!v103)
      {
        AMAuthInstallLog(8, "AMAuthInstallRequestSendSyncWithHeader", "successful tss request:<<<<<<<<<<\n%@", v104, v105, v106, v107, v108, (char)v133);
        AMAuthInstallLog(8, "AMAuthInstallRequestSendSyncWithHeader", "successful tss request:>>>>>>>>>>", v114, v115, v116, v117, v118, v128);
      }
      Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v34 + 40), CFSTR("@ServerVersion"));
      v125 = CFSTR("unavailable");
      if (Value)
        LOBYTE(v125) = (_BYTE)Value;
      AMAuthInstallLog(5, "AMAuthInstallRequestSendSyncWithHeader", "received tss response (server version: %@)", v120, v121, v122, v123, v124, (char)v125);
      AMAuthInstallDebugWriteObject((char *)a1, *(CFTypeRef *)(v34 + 40), (uint64_t)CFSTR("tss-response"), 2);
      v9 = 0;
      if (a4)
        *a4 = CFRetain(*(CFTypeRef *)(v34 + 40));
    }
  }
LABEL_29:
  SafeRelease(0);
  SafeRelease(0);
  SafeRelease(theDict);
  SafeRelease(0);
  SafeRelease(Data);
  SafeRelease(v133);
  SafeRelease(0);
  if (v34)
    tss_close_session((void *)v34, v54, v55, v56, v57, v58, v59, v60);
  return v9;
}

void sub_1000A51AC(const __CFString *a1, const void *a2, CFMutableDictionaryRef *a3)
{
  __CFString *MutableCopy;
  const __CFString *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFStringRef v13;
  __CFString *v14;
  CFRange v15;
  __CFDictionary *v16;
  CFStringRef v17;
  uint64_t v18;

  MutableCopy = (__CFString *)kCFAllocatorDefault;
  v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@,"), *(_QWORD *)(*((_QWORD *)*a3 + 2) + 144));
  v18 = *((_QWORD *)*a3 + 11);
  v13 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("@%@"));
  if (!v13 || (MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, a1)) == 0)
  {
    AMAuthInstallLog(3, "_ApplyTagPrefix", "Failed allocation", v8, v9, v10, v11, v12, v18);
    goto LABEL_9;
  }
  if (CFStringHasPrefix(a1, CFSTR("Ap,")))
  {
    v14 = MutableCopy;
    v15.location = 0;
    v15.length = 3;
LABEL_7:
    CFStringReplace(v14, v15, v7);
    v16 = a3[1];
    v17 = MutableCopy;
    goto LABEL_8;
  }
  if (CFStringHasPrefix(a1, CFSTR("Ap")))
  {
    v14 = MutableCopy;
    v15.location = 0;
    v15.length = 2;
    goto LABEL_7;
  }
  if (CFStringCompare(a1, CFSTR("@ApImg4Ticket"), 0))
    goto LABEL_9;
  v16 = a3[1];
  v17 = v13;
LABEL_8:
  CFDictionarySetValue(v16, v17, a2);
  CFDictionaryRemoveValue(a3[1], a1);
LABEL_9:
  SafeRelease(v7);
  SafeRelease(v13);
  SafeRelease(MutableCopy);
}

void sub_1000A5338(void *key, const void *a2, CFDictionaryRef theDict)
{
  const void *Value;

  if (CFDictionaryContainsKey(theDict, key))
  {
    Value = CFDictionaryGetValue(theDict, key);
    CFDictionarySetValue(theDict, a2, Value);
    CFDictionaryRemoveValue(theDict, key);
  }
}

uint64_t AMAuthInstallRequestSendSync(uint64_t a1, const void *a2, CFTypeRef *a3)
{
  return AMAuthInstallRequestSendSyncWithHeader(a1, a2, 0, a3);
}

__CFDictionary *AMAuthInstallUpdaterCryptex1GetTags(uint64_t a1, void (*a2)(uint64_t, const char *), uint64_t a3, _QWORD *a4)
{
  __CFArray *Mutable;
  __CFArray *v8;
  __CFArray *v9;
  __CFArray *v10;
  __CFArray *v11;
  __CFDictionary *v12;
  __CFDictionary *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  CFRange v21;
  CFRange v22;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 28, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: buildIdentityTags is NULL"));
    v11 = 0;
    v13 = 0;
    v9 = 0;
    v8 = 0;
    goto LABEL_7;
  }
  v8 = sub_1000A566C();
  if (!v8)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: manifestProperties is NULL"));
    v11 = 0;
    v13 = 0;
    v9 = 0;
    goto LABEL_7;
  }
  v9 = sub_1000A57D8();
  if (!v9)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: objectTags is NULL"));
    v11 = 0;
LABEL_16:
    v13 = 0;
    goto LABEL_7;
  }
  v21.length = CFArrayGetCount(v8);
  v21.location = 0;
  CFArrayAppendArray(Mutable, v8, v21);
  v22.length = CFArrayGetCount(v9);
  v22.location = 0;
  CFArrayAppendArray(Mutable, v9, v22);
  v10 = CFArrayCreateMutable(kCFAllocatorDefault, 1, &kCFTypeArrayCallBacks);
  v11 = v10;
  if (!v10)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: responseTags is NULL"));
    goto LABEL_16;
  }
  CFArrayAppendValue(v10, CFSTR("Cryptex1,Ticket"));
  v12 = CFDictionaryCreateMutable(kCFAllocatorDefault, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v13 = v12;
  if (v12)
  {
    CFDictionaryAddValue(v12, CFSTR("BuildIdentityTags"), Mutable);
    CFDictionaryAddValue(v13, CFSTR("ResponseTags"), v11);
  }
  else
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: dict is NULL"));
  }
LABEL_7:
  if (a4 && *a4)
  {
    sub_1000A5930(a2, a3, v14, v15, v16, v17, v18, v19, (char)"AMAuthInstallUpdaterCryptex1GetTags");
    return 0;
  }
  else
  {
    AMSupportSafeRelease(v8);
    AMSupportSafeRelease(v9);
    AMSupportSafeRelease(Mutable);
    AMSupportSafeRelease(v11);
  }
  return v13;
}

__CFArray *sub_1000A566C()
{
  __CFArray *Mutable;
  __CFArray *v1;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 15, &kCFTypeArrayCallBacks);
  v1 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, CFSTR("ApSecurityDomain"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,ChipID"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,Type"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,SubType"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,ProductClass"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,UseProductClass"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,NonceDomain"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,LiveNonceDomain"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,ExclaveNonceDomain"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,ExclaveLiveNonceDomain"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,Version"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,PreauthorizationVersion"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,FakeRoot"));
    CFArrayAppendValue(v1, CFSTR("UniqueBuildID"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,DataOnly"));
  }
  return v1;
}

__CFArray *sub_1000A57D8()
{
  __CFArray *Mutable;
  __CFArray *v1;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 14, &kCFTypeArrayCallBacks);
  v1 = Mutable;
  if (Mutable)
  {
    CFArrayAppendValue(Mutable, CFSTR("Cryptex1,SystemOS"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,SystemVolume"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,SystemTrustCache"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,AppOS"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,AppVolume"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,AppTrustCache"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,MobileAssetBrainOS"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,MobileAssetBrainVolume"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,MobileAssetBrainTrustCache"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,CryptexInfoPlist"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,GenericDmg"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,GenericTrustCache"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,GenericVolume"));
    CFArrayAppendValue(v1, CFSTR("Cryptex1,GenericIntegrityCatalog"));
  }
  return v1;
}

uint64_t sub_1000A5930(void (*a1)(uint64_t, const char *), uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  const __CFString *v11;
  const __CFString *v12;
  const __CFString *v13;
  const char *CStringPtr;

  v11 = CFStringCreateWithCString(kCFAllocatorDefault, "%s failed: %@", 0x8000100u);
  if (v11)
  {
    v12 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, v11, &a9);
    v13 = v12;
    if (v12)
    {
      CStringPtr = CFStringGetCStringPtr(v12, 0x8000100u);
      a1(a2, CStringPtr);
    }
  }
  else
  {
    v13 = 0;
  }
  AMSupportSafeRelease(v11);
  return AMSupportSafeRelease(v13);
}

CFMutableDictionaryRef AMAuthInstallUpdaterCryptex1CopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableDictionaryRef Mutable;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: dict is NULL"));
  return Mutable;
}

__CFDictionary *AMAuthInstallUpdaterCryptex1CreateRequest(const __CFDictionary *a1, void (*a2)(uint64_t, const char *), uint64_t a3, _QWORD *a4)
{
  __CFDictionary *Mutable;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  const __CFDictionary *v11;
  const __CFDictionary *v12;
  __CFArray *v13;
  const __CFArray *v14;
  CFIndex v15;
  const void *ValueAtIndex;
  const void *v17;
  __CFArray *v18;
  const __CFArray *v19;
  CFIndex i;
  const void *v21;
  const __CFDictionary *v22;
  const __CFDictionary *v23;
  CFTypeID v24;
  const void *v25;
  const void *v26;
  CFTypeID v27;
  __CFDictionary *v28;
  __CFDictionary *v29;
  const __CFNumber *v30;
  const __CFNumber *v31;
  CFTypeID v32;
  int Boolean;
  _QWORD *v34;
  CFTypeID TypeID;
  const __CFNumber *v36;
  const __CFNumber *v37;
  CFTypeID v38;
  const __CFNumber *v39;
  const __CFNumber *v40;
  CFDataRef v41;
  CFTypeID v42;
  const void *v43;
  CFTypeID v44;
  const void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  const __CFString *v53;
  const __CFString *v54;
  _QWORD *v55;
  uint64_t v56;
  void (*v57)(uint64_t, const char *);
  uint64_t v58;
  const __CFDictionary *v59;
  uint64_t v60;
  int valuePtr;
  UInt8 bytes[8];
  unint64_t v63;

  valuePtr = -1;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v57 = a2;
  v58 = a3;
  if (!Mutable)
  {
    v54 = CFSTR("%s: request is NULL");
    v55 = a4;
    v56 = 2;
LABEL_52:
    AMSupportCreateErrorInternal(v55, CFSTR("AuthInstallErrorDomain"), v56, 0, v54);
    v14 = 0;
LABEL_54:
    v19 = 0;
    goto LABEL_57;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("BuildIdentity"));
  if (!Value)
  {
    v54 = CFSTR("%s: buildIdentity is NULL");
LABEL_51:
    v55 = a4;
    v56 = 14;
    goto LABEL_52;
  }
  v10 = Value;
  v11 = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  if (!v11)
  {
    v54 = CFSTR("%s: deviceInfo is NULL");
    goto LABEL_51;
  }
  v12 = v11;
  v13 = sub_1000A566C();
  v14 = v13;
  if (!v13)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: manifestProperties is NULL"));
    goto LABEL_54;
  }
  if (CFArrayGetCount(v13) >= 1)
  {
    v15 = 0;
    do
    {
      ValueAtIndex = CFArrayGetValueAtIndex(v14, v15);
      v17 = CFDictionaryGetValue(v10, ValueAtIndex);
      if (v17)
        CFDictionarySetValue(Mutable, ValueAtIndex, v17);
      ++v15;
    }
    while (v15 < CFArrayGetCount(v14));
  }
  v18 = sub_1000A57D8();
  v19 = v18;
  if (!v18)
  {
    v53 = CFSTR("%s: objectTags is NULL");
LABEL_56:
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, v53);
    goto LABEL_57;
  }
  v59 = v12;
  v60 = (uint64_t)a4;
  if (CFArrayGetCount(v18) >= 1)
  {
    for (i = 0; i < CFArrayGetCount(v19); ++i)
    {
      v21 = CFArrayGetValueAtIndex(v19, i);
      v22 = (const __CFDictionary *)CFDictionaryGetValue(v10, v21);
      if (v22)
      {
        v23 = v22;
        v24 = CFGetTypeID(v22);
        if (v24 == CFDictionaryGetTypeID())
        {
          v25 = CFDictionaryGetValue(v23, CFSTR("Digest"));
          if (v25)
          {
            v26 = v25;
            v27 = CFGetTypeID(v25);
            if (v27 == CFDataGetTypeID())
            {
              v28 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (!v28)
              {
                v53 = CFSTR("%s: requestEntry is NULL");
                a4 = (_QWORD *)v60;
                goto LABEL_56;
              }
              v29 = v28;
              CFDictionarySetValue(v28, CFSTR("Digest"), v26);
              CFDictionarySetValue(Mutable, v21, v29);
              AMSupportSafeRelease(v29);
            }
          }
        }
      }
    }
  }
  AMSupportCFDictionarySetBoolean(Mutable, CFSTR("@Cryptex1,Ticket"), 1);
  v30 = (const __CFNumber *)CFDictionaryGetValue(v10, CFSTR("Cryptex1,Type"));
  if (v30)
  {
    v31 = v30;
    v32 = CFGetTypeID(v30);
    if (v32 == CFNumberGetTypeID())
      CFNumberGetValue(v31, kCFNumberIntType, &valuePtr);
  }
  Boolean = AMSupportCFDictionaryGetBoolean(v59, CFSTR("UseGlobalSigning"), 0);
  a4 = (_QWORD *)v60;
  if (!Boolean)
  {
    TypeID = CFNumberGetTypeID();
    v36 = (const __CFNumber *)sub_1000A6118(v59, CFSTR("ApChipId"), TypeID, v60);
    if (v36)
    {
      v37 = v36;
      v38 = CFNumberGetTypeID();
      v39 = (const __CFNumber *)sub_1000A6118(v59, CFSTR("ApECID"), v38, v60);
      if (v39)
      {
        v40 = v39;
        *(_QWORD *)bytes = 0;
        v63 = 0;
        CFNumberGetValue(v37, kCFNumberSInt32Type, &bytes[4]);
        CFNumberGetValue(v40, kCFNumberSInt64Type, &v63);
        *(_DWORD *)&bytes[4] = bswap32(*(unsigned int *)&bytes[4]);
        v63 = bswap64(v63);
        v41 = CFDataCreate(kCFAllocatorDefault, bytes, 16);
        if (!v41)
        {
          AMSupportCreateErrorInternal(v60, CFSTR("AuthInstallErrorDomain"), 14, 0, CFSTR("%s: udid is missing or invalid"));
          goto LABEL_43;
        }
        CFDictionarySetValue(Mutable, CFSTR("Cryptex1,UDID"), v41);
        goto LABEL_34;
      }
    }
LABEL_57:
    v41 = 0;
    goto LABEL_43;
  }
  AMSupportCFDictionarySetInteger32(Mutable, CFSTR("Cryptex1,UseGlobalSigning"), 1);
  CFDictionaryRemoveValue(Mutable, CFSTR("Cryptex1,NonceDomain"));
  CFDictionaryRemoveValue(Mutable, CFSTR("Cryptex1,LiveNonceDomain"));
  CFDictionaryRemoveValue(Mutable, CFSTR("Cryptex1,ExclaveNonceDomain"));
  CFDictionaryRemoveValue(Mutable, CFSTR("Cryptex1,ExclaveLiveNonceDomain"));
  if (valuePtr == 1)
  {
    if (AMSupportCFDictionaryGetBoolean(v59, CFSTR("IsX86"), 0))
      v34 = &kAMAuthInstallTagX86UseGlobalSigning;
    else
      v34 = &kAMAuthInstallTagApUseGlobalSigning;
    AMSupportCFDictionarySetInteger32(Mutable, *v34, 1);
  }
  v41 = 0;
LABEL_34:
  v42 = CFBooleanGetTypeID();
  v43 = sub_1000A6118(v59, CFSTR("ApProductionMode"), v42, v60);
  if (v43)
  {
    CFDictionarySetValue(Mutable, CFSTR("Cryptex1,ProductionMode"), v43);
    if (!Boolean)
    {
      if (sub_1000A61AC(Mutable, CFSTR("Cryptex1,Nonce"), v59, CFSTR("Nonce"), v60))
      {
        if (valuePtr == 4)
        {
          if (sub_1000A61AC(Mutable, CFSTR("Cryptex1,LiveNonce"), v59, CFSTR("LiveNonce"), v60))
          {
            if (sub_1000A61AC(Mutable, CFSTR("Cryptex1,ExclaveNonce"), v59, CFSTR("ExclaveNonce"), v60))
            {
              if (sub_1000A61AC(Mutable, CFSTR("Cryptex1,ExclaveLiveNonce"), v59, CFSTR("ExclaveLiveNonce"), v60))
              {
                v44 = CFDataGetTypeID();
                v45 = sub_1000A6118(v59, CFSTR("BootUUID"), v44, v60);
                if (v45)
                  CFDictionarySetValue(Mutable, CFSTR("Cryptex1,BootUUID"), v45);
              }
            }
          }
        }
      }
    }
  }
LABEL_43:
  AMSupportSafeRelease(v14);
  AMSupportSafeRelease(v19);
  AMSupportSafeRelease(v41);
  if (a4 && *a4)
  {
    sub_1000A5930(v57, v58, v46, v47, v48, v49, v50, v51, (char)"AMAuthInstallUpdaterCryptex1CreateRequest");
    return 0;
  }
  return Mutable;
}

const void *sub_1000A6118(const __CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4)
{
  const void *Value;
  const void *v7;
  const __CFString *v9;

  Value = CFDictionaryGetValue(a1, a2);
  if (!Value)
  {
    v9 = CFSTR("%s: %@ in deviceInfo is NULL");
LABEL_6:
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 1, 0, v9);
    return 0;
  }
  v7 = Value;
  if (CFGetTypeID(Value) != a3)
  {
    v9 = CFSTR("%s: %@ in deviceInfo is invalid");
    goto LABEL_6;
  }
  return v7;
}

uint64_t sub_1000A61AC(__CFDictionary *a1, const void *a2, CFDictionaryRef theDict, void *key, uint64_t a5)
{
  const void *Value;
  const void *v10;
  CFTypeID v11;
  CFDataRef v12;
  CFDataRef v13;
  const __CFString *v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD __buf[3];

  Value = CFDictionaryGetValue(theDict, key);
  if (!Value)
  {
    AMSupportLogInternal(4, "_AMAuthInstallCryptex1RequestSetNonce", "No %@ provided, generating random value for %@", key, a2);
    memset(__buf, 0, sizeof(__buf));
    arc4random_buf(__buf, 0x30uLL);
    v12 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)__buf, 48);
    if (v12)
    {
      v13 = v12;
      CFDictionarySetValue(a1, a2, v12);
      AMSupportSafeRelease(v13);
      return 1;
    }
    v15 = CFSTR("%s: randomNonce is NULL");
    v16 = a5;
    v17 = 2;
LABEL_10:
    AMSupportCreateErrorInternal(v16, CFSTR("AuthInstallErrorDomain"), v17, 0, v15);
    return 0;
  }
  v10 = Value;
  v11 = CFGetTypeID(Value);
  if (v11 != CFDataGetTypeID())
  {
    v15 = CFSTR("%s: %@ in deviceInfo isn't data");
    v16 = a5;
    v17 = 1;
    goto LABEL_10;
  }
  CFDictionarySetValue(a1, a2, v10);
  return 1;
}

void SafeRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

CFTypeRef SafeRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void SafeFree(void *a1)
{
  if (a1)
    free(a1);
}

const char *_CopyHexStringFromData(const __CFAllocator *a1, CFDataRef theData)
{
  const UInt8 *BytePtr;
  unsigned int Length;
  const char *result;
  char *v7;
  uint64_t v8;
  unsigned int v9;
  CFStringRef v10;

  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  result = (const char *)calloc(1uLL, (2 * Length) | 1);
  if (result)
  {
    v7 = (char *)result;
    if (Length)
    {
      v8 = 0;
      do
      {
        v9 = *BytePtr++;
        result[v8] = a0123456789abcd[(unint64_t)v9 >> 4];
        result[(v8 + 1)] = a0123456789abcd[v9 & 0xF];
        v8 += 2;
      }
      while (2 * Length != v8);
    }
    v10 = CFStringCreateWithCString(a1, result, 0x8000100u);
    free(v7);
    return (const char *)v10;
  }
  return result;
}

uint64_t AMAuthInstallSupportRemoveFile(const __CFURL *a1)
{
  uint64_t result;
  BOOL v3;

  v3 = 0;
  result = AMAuthInstallPlatformFileURLExists(a1, &v3);
  if (!(_DWORD)result)
  {
    if (!v3)
      return 0;
    result = AMAuthInstallPlatformRemoveFile(a1);
    if (!(_DWORD)result)
      return 0;
  }
  return result;
}

uint64_t AMAuthInstallSupportCopyURLWithAppendedComponent(const __CFAllocator *a1, const void *a2, const __CFString *a3, Boolean a4, CFURLRef *a5)
{
  if (a2 && a3 && a5)
    return AMAuthInstallPlatformCopyURLWithAppendedComponent(a1, a2, a3, a4, a5);
  else
    return 1;
}

uint64_t AMAuthInstallSupportCopyPreserveFileURL(const __CFAllocator *a1, CFTypeRef cf, CFTypeRef *a3, int a4)
{
  uint64_t v4;
  const __CFURL *v7;
  CFTypeRef v8;
  CFStringRef v9;
  CFMutableStringRef Mutable;
  CFStringRef v11;
  uint64_t v12;
  uint64_t v13;
  CFURLRef v14;
  BOOL v15;
  const __CFURL *v16;
  char v20;

  v4 = 1;
  v20 = 1;
  if (cf && a3)
  {
    v7 = (const __CFURL *)CFRetain(cf);
    v8 = CFRetain(cf);
    v9 = 0;
    Mutable = 0;
    v11 = 0;
    v12 = 1;
    while (1)
    {
      v13 = AMAuthInstallPlatformFileURLExists(v7, (BOOL *)&v20);
      if ((_DWORD)v13)
      {
        v4 = v13;
        goto LABEL_25;
      }
      if (!v20)
        goto LABEL_21;
      if (v11)
        CFRelease(v11);
      v11 = CFStringCreateWithFormat(a1, 0, CFSTR("~%d"), v12);
      if (!v11)
        goto LABEL_38;
      if (Mutable)
        CFRelease(Mutable);
      if (v9)
        CFRelease(v9);
      Mutable = CFStringCreateMutable(a1, 0);
      if (!Mutable)
        break;
      v9 = CFURLCopyFileSystemPath((CFURLRef)cf, kCFURLPOSIXPathStyle);
      if (!v9)
        goto LABEL_38;
      CFStringAppend(Mutable, v9);
      CFStringAppend(Mutable, v11);
      if (v8)
        CFRelease(v8);
      v8 = CFRetain(v7);
      CFRelease(v7);
      v14 = CFURLCreateWithFileSystemPath(a1, Mutable, kCFURLPOSIXPathStyle, 0);
      if (!v14)
      {
        v4 = 2;
LABEL_28:
        CFRelease(v11);
        goto LABEL_29;
      }
      v7 = v14;
      if (v20)
      {
        v15 = v12 > 0x1E;
        v12 = (v12 + 1);
        if (!v15)
          continue;
      }
LABEL_21:
      if (a4)
        v16 = v7;
      else
        v16 = (const __CFURL *)v8;
      v4 = 0;
      *a3 = CFRetain(v16);
      goto LABEL_25;
    }
    v9 = 0;
LABEL_38:
    v4 = 2;
LABEL_25:
    if (v7)
      CFRelease(v7);
    if (v11)
      goto LABEL_28;
LABEL_29:
    if (Mutable)
      CFRelease(Mutable);
    if (v9)
      CFRelease(v9);
    if (v8)
      CFRelease(v8);
  }
  return v4;
}

const __CFString *AMAuthInstallSupportGetLibraryVersionString()
{
  return CFSTR("libauthinstall_device-1033.0.6");
}

uint64_t AMAuthInstallSupportBase64Encode(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *BytePtr;
  unsigned int Length;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  UInt8 *v19;
  int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  CFStringRef v26;
  CFStringRef v27;
  const char *v29;
  const char *v30;
  char v31;

  if (!theData)
  {
    v29 = "value == NULL";
LABEL_11:
    AMAuthInstallLog(3, "AMAuthInstallSupportBase64Encode", v29, a4, a5, a6, a7, a8, v31);
    return 1;
  }
  if (!CFDataGetLength(theData))
  {
    AMAuthInstallLog(3, "AMAuthInstallSupportBase64Encode", "value length == 0: '%@'", a4, a5, a6, a7, a8, (char)theData);
    return 1;
  }
  if (!a3)
  {
    v29 = "outEncodedValue == NULL";
    goto LABEL_11;
  }
  BytePtr = (unsigned __int8 *)CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  v13 = b64encode(BytePtr, Length);
  if (v13)
  {
    v19 = (UInt8 *)v13;
    v20 = strlen(v13);
    if (v20)
    {
      v26 = CFStringCreateWithBytes(a1, v19, v20, 0x8000100u, 0);
      if (v26)
      {
        v27 = v26;
        *a3 = CFRetain(v26);
        free(v19);
        CFRelease(v27);
        return 0;
      }
      v30 = "encodedValue == NULL: '%@'";
    }
    else
    {
      v30 = "encodedLength == 0: '%@'";
    }
    AMAuthInstallLog(3, "AMAuthInstallSupportBase64Encode", v30, v21, v22, v23, v24, v25, (char)theData);
    free(v19);
  }
  else
  {
    AMAuthInstallLog(3, "AMAuthInstallSupportBase64Encode", "encodedBuffer == NULL: '%@'", v14, v15, v16, v17, v18, (char)theData);
  }
  return 99;
}

uint64_t AMAuthInstallSupportWriteDataToFileURL(const __CFAllocator *a1, const __CFData *a2, const __CFURL *cf, int a4)
{
  uint64_t v4;
  uint64_t v7;
  const __CFURL *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const __CFURL *v15;
  char v17;
  CFTypeRef cfa;

  cfa = 0;
  v4 = 1;
  if (!a2 || !cf)
    return v4;
  if (a4)
  {
    v7 = AMAuthInstallSupportRemoveFile(cf);
    if ((_DWORD)v7)
    {
LABEL_12:
      v4 = v7;
      goto LABEL_13;
    }
    v8 = 0;
LABEL_8:
    if (v8)
      v15 = v8;
    else
      v15 = cf;
    v7 = AMAuthInstallPlatformWriteDataToFileURL(a2, v15);
    goto LABEL_12;
  }
  v9 = AMAuthInstallSupportCopyPreserveFileURL(a1, cf, &cfa, 1);
  if (!(_DWORD)v9)
  {
    v8 = (const __CFURL *)cfa;
    goto LABEL_8;
  }
  v4 = v9;
  AMAuthInstallLog(3, "AMAuthInstallSupportWriteDataToFileURL", "AMAuthInstallSupportCopyPreserveFileURL failed.", v10, v11, v12, v13, v14, v17);
LABEL_13:
  if (cfa)
    CFRelease(cfa);
  return v4;
}

uint64_t sub_1000A6880(CFStringRef theString1)
{
  uint64_t v2;
  const char *v3;
  const __CFString *v4;

  if (theString1)
  {
    v2 = 0;
    v3 = "Updater entry is NULL";
    while (1)
    {
      v4 = *(const __CFString **)((char *)&off_100182228 + v2);
      if (!v4)
        break;
      if (CFStringCompare(theString1, v4, 0) == kCFCompareEqualTo)
        return (uint64_t)&off_100182228 + v2;
      v2 += 48;
      if (v2 == 624)
        return 0;
    }
  }
  else
  {
    v3 = "updaterName is NULL";
  }
  AMSupportLogInternal(3, "_updater_named", v3);
  return 0;
}

uint64_t AMAuthInstallUpdaterTwoStageEnabled(const __CFString *a1)
{
  uint64_t result;

  result = sub_1000A6880(a1);
  if (result)
    return *(unsigned __int8 *)(result + 41);
  return result;
}

__CFDictionary *sub_1000A6928(const __CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFArray *Mutable;
  __CFArray *v7;
  __CFDictionary *v8;
  const __CFDictionary *Value;
  const __CFDictionary *v10;
  const __CFString *v11;
  const __CFString *v13;
  uint64_t v14;
  uint64_t v15;

  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: buildTags is NULL"));
    v8 = 0;
    v7 = 0;
    goto LABEL_9;
  }
  v7 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!v7)
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 2, 0, CFSTR("%s: responseTags is NULL"));
    v8 = 0;
    goto LABEL_9;
  }
  v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!v8)
  {
    v13 = CFSTR("%s: outTags is NULL");
    v14 = a4;
    v15 = 2;
LABEL_14:
    AMSupportCreateErrorInternal(v14, CFSTR("AuthInstallErrorDomain"), v15, 0, v13);
    goto LABEL_9;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  if (!Value)
  {
    v13 = CFSTR("%s: deviceInfo is NULL");
    v14 = a4;
    v15 = 1;
    goto LABEL_14;
  }
  v10 = Value;
  CFArrayAppendValue(Mutable, CFSTR("TestFirmware"));
  CFArrayAppendValue(v7, CFSTR("Test,Ticket,1"));
  CFArrayAppendValue(v7, CFSTR("Test,Ticket,2"));
  if (CFDictionaryGetValue(v10, CFSTR("QueryLoop0")) == kCFBooleanTrue)
    v11 = CFSTR("InstanceA");
  else
    v11 = CFSTR("InstanceB");
  CFDictionarySetValue(v8, CFSTR("LoopInstance"), v11);
  CFDictionarySetValue(v8, CFSTR("BuildIdentityTags"), Mutable);
  CFDictionarySetValue(v8, CFSTR("ResponseTags"), v7);
LABEL_9:
  AMSupportSafeRelease(Mutable);
  AMSupportSafeRelease(v7);
  return v8;
}

__CFDictionary *sub_1000A6B64(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFDictionary *Mutable;
  __CFDictionary *v6;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = Mutable;
  if (Mutable)
  {
    CFDictionaryAddValue(Mutable, CFSTR("FirmwareEntry1"), CFSTR("PlaceholderData"));
    CFDictionaryAddValue(v6, CFSTR("FirmwareEntry2"), CFSTR("PlaceholderData"));
  }
  else
  {
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 1, 0, CFSTR("%s: outFirmware is NULL"));
  }
  return v6;
}

__CFDictionary *sub_1000A6C1C(const __CFDictionary *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __CFDictionary *Mutable;
  const __CFDictionary *Value;
  const void *v8;
  const __CFString *v10;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    v10 = CFSTR("%s: outRequest is NULL");
LABEL_8:
    AMSupportCreateErrorInternal(a4, CFSTR("AuthInstallErrorDomain"), 1, 0, v10);
    return Mutable;
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  if (!Value)
  {
    v10 = CFSTR("%s: deviceInfo is NULL");
    goto LABEL_8;
  }
  v8 = CFDictionaryGetValue(Value, CFSTR("QueryLoop0"));
  if (v8)
    CFDictionarySetValue(Mutable, CFSTR("QueryLoop0"), v8);
  return Mutable;
}

uint64_t AMAuthInstallVinylRemoveFirmwareLoaderVersionTag(const void *a1, CFDictionaryRef *a2)
{
  __CFDictionary *v2;
  uint64_t v3;
  const __CFAllocator *v5;
  __CFDictionary *MutableCopy;

  v2 = 0;
  v3 = 1;
  if (a1 && a2)
  {
    if (*a2)
    {
      v5 = CFGetAllocator(a1);
      MutableCopy = CFDictionaryCreateMutableCopy(v5, 0, *a2);
      v2 = MutableCopy;
      if (MutableCopy)
      {
        CFDictionaryRemoveValue(MutableCopy, CFSTR("EUICCFirmwareLoaderVersion"));
        SafeRelease(*a2);
        v3 = 0;
        *a2 = (CFDictionaryRef)CFRetain(v2);
      }
      else
      {
        v3 = 2;
      }
    }
    else
    {
      v2 = 0;
    }
  }
  SafeRelease(v2);
  return v3;
}

uint64_t DERDecoderInitialize(uint64_t a1, unsigned __int8 *a2, unsigned int *a3, unsigned int a4)
{
  unsigned int v8;
  uint64_t result;
  int v10;
  unsigned int v11;
  int v13;
  uint64_t v14;
  uint64_t v15;

  if (!a1)
    sub_1000FA174();
  if (!a2)
    sub_1000FA19C();
  if (!a3)
    sub_1000FA1C4();
  v8 = *a3;
  if (*a3)
  {
LABEL_5:
    if (v8 > a4)
      return 2;
    result = 0;
    *a3 = v8;
    *(_QWORD *)a1 = a2;
    *(_DWORD *)(a1 + 8) = v8;
    return result;
  }
  v14 = 0;
  v15 = 0;
  v13 = 0;
  result = sub_1000A6E94(a2, a4, (unsigned int *)&v15, (int *)&v14 + 1, (int *)&v14, &v13);
  if (!(_DWORD)result)
  {
    v10 = a4 - v13;
    result = sub_1000A6F84(&a2[v13], a4 - v13, (int *)&v15 + 1, &v13);
    if (!(_DWORD)result)
    {
      v11 = v13 - v10 + a4;
      v8 = v11 + HIDWORD(v15);
      if (v11 + HIDWORD(v15) < HIDWORD(v15) || v8 < v11)
        return 6;
      goto LABEL_5;
    }
  }
  return result;
}

uint64_t sub_1000A6E94(unsigned __int8 *a1, int a2, unsigned int *a3, int *a4, int *a5, _DWORD *a6)
{
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  char *v12;
  char v13;
  int v14;
  uint64_t result;

  if (!a1)
    sub_1000FA1EC();
  if (!a3)
    sub_1000FA214();
  if (!a4)
    sub_1000FA23C();
  if (!a5)
    sub_1000FA264();
  if (!a6)
    sub_1000FA28C();
  if (!a2)
    return 3;
  v6 = *a1;
  *a3 = v6 >> 6;
  v7 = *a1;
  if ((~v6 & 0x1F) == 0)
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    *a5 = (v7 >> 5) & 1;
    v11 = a2 - 1;
    v12 = (char *)(a1 + 1);
    while (v11)
    {
      v13 = *v12;
      v14 = *v12 & 0x7F | (v8 << 7);
      v10 |= v14 != 0;
      if ((v10 & 1) != 0)
      {
        v9 += 7;
        if (v9 > 0x20)
          return 6;
      }
      --v11;
      ++v12;
      v8 = v14;
      if ((v13 & 0x80000000) == 0)
      {
        *a4 = v14;
        goto LABEL_16;
      }
    }
    return 3;
  }
  *a4 = v7 & 0x1F;
  *a5 = (*a1 >> 5) & 1;
  v11 = a2 - 1;
LABEL_16:
  result = 0;
  *a6 = a2 - v11;
  return result;
}

uint64_t sub_1000A6F84(unsigned __int8 *a1, int a2, int *a3, _DWORD *a4)
{
  int v4;
  unsigned int v5;
  uint64_t result;
  unsigned int v7;
  BOOL v8;
  int v9;
  unsigned int v10;
  unsigned __int8 *v11;
  int v12;

  if (!a1)
    sub_1000FA2B4();
  if (!a3)
    sub_1000FA2DC();
  if (!a4)
    sub_1000FA304();
  if (!a2)
    return 4;
  v4 = *a1;
  v5 = a2 - 1;
  if (((char)*a1 & 0x80000000) == 0)
  {
LABEL_6:
    result = 0;
    *a3 = v4;
    *a4 = a2 - v5;
    return result;
  }
  v7 = v4 & 0x7F;
  v8 = v5 >= v7;
  v5 -= v7;
  if (!v8)
    return 4;
  if ((v4 & 0x7F) == 0)
  {
    v4 = 0;
    goto LABEL_6;
  }
  v9 = 0;
  v10 = 0;
  v4 = 0;
  v11 = a1 + 1;
  while (1)
  {
    v12 = *v11++;
    v4 = v12 | (v4 << 8);
    v9 |= v4 != 0;
    if ((v9 & 1) != 0)
    {
      v10 += 8;
      if (v10 > 0x20)
        return 6;
    }
    if (!--v7)
      goto LABEL_6;
  }
}

uint64_t DERDecoderGetDataWithTag(uint64_t a1, unsigned int a2, unsigned int a3, int a4, _QWORD *a5, _DWORD *a6, int *a7)
{
  int v10;
  uint64_t result;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  if (!a1)
    sub_1000FA32C();
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  *(_QWORD *)((char *)&v13 + 4) = __PAIR64__(a3, a2);
  HIDWORD(v14) = a4;
  if (a7)
    v10 = *a7;
  else
    v10 = 0;
  DWORD1(v12) = v10;
  result = sub_1000A70DC(a1, (uint64_t (*)(unsigned __int8 **, uint64_t))sub_1000A7210, (uint64_t)&v12);
  if (!(_DWORD)result)
  {
    if (!(_QWORD)v14)
      sub_1000FA354();
    if (a5)
      *a5 = v14;
    if (a6)
      *a6 = DWORD2(v14);
    if (a7)
      *a7 = v12;
  }
  return result;
}

uint64_t sub_1000A70DC(uint64_t a1, uint64_t (*a2)(unsigned __int8 **, uint64_t), uint64_t a3)
{
  int v3;
  unsigned __int8 *v6;
  uint64_t result;
  int v8;
  unsigned __int8 *v9;
  unsigned int v10;
  unsigned __int8 *v11;
  int v12;
  unsigned __int8 *v13;
  __int128 v14;
  __int128 v15;

  if (!a1)
    sub_1000FA37C();
  v3 = *(_DWORD *)(a1 + 8);
  if (!v3)
    return 1;
  v6 = *(unsigned __int8 **)a1;
  while (1)
  {
    v12 = 0;
    v14 = 0u;
    v15 = 0u;
    v13 = v6;
    result = sub_1000A6E94(v6, v3, (unsigned int *)&v14 + 1, (int *)&v14 + 2, (int *)&v15 + 3, &v12);
    if ((_DWORD)result)
      break;
    if (!v12)
      sub_1000FA3A4();
    v8 = v3 - v12;
    v9 = &v6[v12];
    result = sub_1000A6F84(v9, v8, (int *)&v15 + 2, &v12);
    if ((_DWORD)result)
      break;
    if (!v12)
      sub_1000FA3CC();
    v10 = v8 - v12;
    if (v10 < DWORD2(v15))
      return 2;
    v11 = &v9[v12];
    *(_QWORD *)&v15 = v11;
    LODWORD(v14) = DWORD2(v15) + (_DWORD)v11 - (_DWORD)v13;
    result = a2(&v13, a3);
    if ((_DWORD)result != 1)
      return result;
    v6 = &v11[DWORD2(v15)];
    v3 = v10 - DWORD2(v15);
    if (v10 == DWORD2(v15))
      return 1;
  }
  return result;
}

uint64_t sub_1000A7210(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  if (*(_DWORD *)(a1 + 12) == *(_DWORD *)(a2 + 20)
    && *(_DWORD *)(a1 + 16) == *(_DWORD *)(a2 + 24)
    && *(_DWORD *)(a1 + 36) == *(_DWORD *)(a2 + 44)
    && *(_DWORD *)a2 >= *(_DWORD *)(a2 + 4))
  {
    v2 = 0;
    *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 24);
    *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 32);
    *(_QWORD *)(a2 + 8) = *(_QWORD *)a1;
    *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 8);
  }
  else
  {
    ++*(_DWORD *)a2;
    return 1;
  }
  return v2;
}

uint64_t DERDecoderGetEncodingWithTag(uint64_t a1, unsigned int a2, unsigned int a3, int a4, _QWORD *a5, _DWORD *a6, int *a7)
{
  int v10;
  uint64_t result;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  if (!a1)
    sub_1000FA3F4();
  v13 = 0u;
  v14 = 0u;
  v12 = 0u;
  *(_QWORD *)((char *)&v13 + 4) = __PAIR64__(a3, a2);
  HIDWORD(v14) = a4;
  if (a7)
    v10 = *a7;
  else
    v10 = 0;
  DWORD1(v12) = v10;
  result = sub_1000A70DC(a1, (uint64_t (*)(unsigned __int8 **, uint64_t))sub_1000A7210, (uint64_t)&v12);
  if (!(_DWORD)result)
  {
    if (!*((_QWORD *)&v12 + 1))
      sub_1000FA41C();
    if (a5)
      *a5 = *((_QWORD *)&v12 + 1);
    if (a6)
      *a6 = v13;
    if (a7)
      *a7 = v12;
  }
  return result;
}

unint64_t b64_ntop(unsigned __int8 *a1, unint64_t a2, _BYTE *a3, unint64_t a4)
{
  unint64_t v5;
  unint64_t result;
  unint64_t v7;
  unint64_t v8;
  unsigned int v9;
  _BYTE *v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  unint64_t v14;
  unint64_t v15;
  char v16;
  __int16 v17;
  unsigned __int8 v18;

  *a3 = 0;
  if (a2 >= 3)
  {
    v5 = 0;
    while (1)
    {
      result = v5 + 4;
      if (v5 + 4 > a4)
        goto LABEL_16;
      v7 = a1[2];
      v8 = a1[1];
      v9 = *a1;
      a1 += 3;
      a2 -= 3;
      v10 = &a3[v5];
      *v10 = aAbcdefghijklmn[(unint64_t)v9 >> 2];
      v10[1] = aAbcdefghijklmn[(v8 >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v9 & 3))];
      v10[2] = aAbcdefghijklmn[(v7 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v8 & 0xF))];
      v10[3] = aAbcdefghijklmn[v7 & 0x3F];
      v5 = result;
      if (a2 <= 2)
      {
        if (a2)
          goto LABEL_8;
        goto LABEL_14;
      }
    }
  }
  result = 0;
  if (a2)
  {
LABEL_8:
    v11 = 0;
    v12 = 0;
    v18 = 0;
    v17 = 0;
    do
    {
      *((_BYTE *)&v17 + v12) = a1[v11++];
      v12 = v11;
    }
    while (a2 > v11);
    if (result + 4 > a4)
      goto LABEL_16;
    v13 = HIBYTE(v17);
    v14 = ((unint64_t)HIBYTE(v17) >> 4) & 0xFFFFFFFFFFFFFFCFLL | (16 * (v17 & 3));
    a3[result] = aAbcdefghijklmn[(unint64_t)v17 >> 2];
    v15 = v18;
    a3[result | 1] = aAbcdefghijklmn[v14];
    v16 = 61;
    if (a2 != 1)
      v16 = aAbcdefghijklmn[(v15 >> 6) & 0xFFFFFFFFFFFFFFC3 | (4 * (v13 & 0xF))];
    a3[result | 2] = v16;
    a3[result | 3] = 61;
    result += 4;
  }
LABEL_14:
  if (result < a4)
  {
    a3[result] = 0;
    return result;
  }
LABEL_16:
  a3[a4 - 1] = 0;
  *a3 = 0;
  return 0xFFFFFFFFLL;
}

_BYTE *b64encode(unsigned __int8 *a1, unsigned int a2)
{
  _BYTE *v2;
  unsigned int v5;
  size_t v6;

  v2 = 0;
  if (a1 && (int)a2 >= 1)
  {
    v5 = a2 / 3;
    if (a2 != 3 * (a2 / 3))
      ++v5;
    v6 = (4 * v5) | 1;
    v2 = malloc(v6);
    if (v2)
      b64_ntop(a1, a2, v2, v6);
  }
  return v2;
}

const __CFString *tss_lookup_error(int a1)
{
  const char *v1;
  const char **i;
  int v3;

  v1 = off_1001A7868;
  if (off_1001A7868)
  {
    if (tss_err_map == a1)
      return CFStringCreateWithCString(kCFAllocatorDefault, v1, 0x8000100u);
    for (i = (const char **)&off_1001A7878; ; i += 2)
    {
      v1 = *i;
      if (!*i)
        break;
      v3 = *((_DWORD *)i - 2);
      if (v3 == a1)
        return CFStringCreateWithCString(kCFAllocatorDefault, v1, 0x8000100u);
    }
  }
  return CFSTR("Unknown");
}

_QWORD *tss_create_session(const void *a1, const void *a2)
{
  _OWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  CFTypeID v11;
  CFMutableDictionaryRef Mutable;
  const char *v13;
  char v15;

  v4 = malloc(0x60uLL);
  v10 = v4;
  if (!v4)
    goto LABEL_7;
  v4[4] = 0u;
  v4[5] = 0u;
  v4[2] = 0u;
  v4[3] = 0u;
  *v4 = 0u;
  v4[1] = 0u;
  if (!a2)
  {
    v13 = "signingServerURL is NULL";
    goto LABEL_10;
  }
  v11 = CFGetTypeID(a2);
  if (v11 != CFURLGetTypeID())
  {
    v13 = "signingServerURL is malformed";
    goto LABEL_10;
  }
  v10[1] = CFRetain(a2);
  *((_WORD *)v10 + 10) = 256;
  if (a1)
    CFRetain(a1);
  *v10 = a1;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10[3] = Mutable;
  if (!Mutable)
  {
LABEL_7:
    v13 = "out of memory";
LABEL_10:
    AMAuthInstallLog(3, "tss_create_session", v13, v5, v6, v7, v8, v9, v15);
    free(v10);
    return 0;
  }
  return v10;
}

uint64_t tss_close_session(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  v9 = tss_reset_session((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  if (!(_DWORD)v9)
    free(a1);
  return v9;
}

uint64_t tss_reset_session(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const void *v9;
  const void *v10;
  const void *v11;
  const void *v12;
  const void *v13;
  void *v14;
  uint64_t result;
  char v16;

  if (a1)
  {
    v9 = *(const void **)a1;
    if (v9)
      CFRelease(v9);
    v10 = *(const void **)(a1 + 24);
    if (v10)
      CFRelease(v10);
    v11 = *(const void **)(a1 + 40);
    if (v11)
      CFRelease(v11);
    v12 = *(const void **)(a1 + 8);
    if (v12)
      CFRelease(v12);
    v13 = *(const void **)(a1 + 72);
    if (v13)
    {
      CFRelease(v13);
      *(_QWORD *)(a1 + 72) = 0;
    }
    v14 = *(void **)(a1 + 56);
    if (v14)
      free(v14);
    result = 0;
    *(_OWORD *)(a1 + 64) = 0u;
    *(_OWORD *)(a1 + 80) = 0u;
    *(_OWORD *)(a1 + 32) = 0u;
    *(_OWORD *)(a1 + 48) = 0u;
    *(_OWORD *)a1 = 0u;
    *(_OWORD *)(a1 + 16) = 0u;
  }
  else
  {
    AMAuthInstallLog(3, "tss_reset_session", "NULL session", a4, a5, a6, a7, a8, v16);
    return 10009;
  }
  return result;
}

uint64_t tss_submit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  pthread_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFString *v16;
  int v17;
  char v19;

  if (!a1)
  {
    AMAuthInstallLog(3, "tss_submit", "NULL session", a4, a5, a6, a7, a8, v19);
    return 10009;
  }
  if (!*(_QWORD *)(a1 + 24))
  {
    AMAuthInstallLog(3, "tss_submit", "NULL request in session", a4, a5, a6, a7, a8, v19);
    v15 = 10008;
    v16 = (const __CFString *)a1;
    v17 = 10008;
LABEL_10:
    sub_1000A7814(v16, v17);
    return v15;
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    sub_1000A7854(a1);
    return *(unsigned int *)(a1 + 64);
  }
  v9 = (pthread_t *)malloc(8uLL);
  *(_QWORD *)(a1 + 56) = v9;
  if (!v9)
  {
    AMAuthInstallLog(3, "tss_submit_non_block", "out of memory", v10, v11, v12, v13, v14, v19);
    v15 = 10006;
    v16 = (const __CFString *)a1;
    v17 = 10006;
    goto LABEL_10;
  }
  pthread_create(v9, 0, (void *(__cdecl *)(void *))sub_1000A7854, (void *)a1);
  return 0;
}

const __CFString *sub_1000A7814(const __CFString *result, int a2)
{
  const __CFString *v3;
  const void *info;

  if (result)
  {
    v3 = result;
    LODWORD(result[2].isa) = a2;
    info = (const void *)result[2].info;
    if (info)
      CFRelease(info);
    result = tss_lookup_error(a2);
    v3[2].info = (uint64_t)result;
  }
  return result;
}

uint64_t sub_1000A7854(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  const __CFAllocator *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const __CFData *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFData *v22;
  char Length;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  const __CFURL *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  __CFHTTPMessage *Request;
  const __CFString *v36;
  const __CFDictionary *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const __CFDictionary *v43;
  const __CFString *Value;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __CFDictionary *Mutable;
  __CFDictionary *v51;
  const void *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  const __CFString *v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  const __CFString *v70;
  const char *v71;
  int v72;
  const __CFString *v73;
  const __CFDictionary *v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const __CFString *v81;
  int v82;
  void (*v83)(uint64_t);
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  const __CFString *v89;
  int v90;
  const UInt8 *BytePtr;
  CFIndex v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  const char *v99;
  const char *v100;
  const char *v101;
  int v102;
  const char *v103;
  uint64_t v104;
  int v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  int v144;
  const void *v145;
  size_t v146;
  CFStringRef v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  const __CFString *v153;
  int v154;
  CFIndex v155;
  CFDataRef v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const __CFData *v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  CFDictionaryRef Copy;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  int v174;
  char v176;
  char v177;
  char v178;
  char v179;
  char v180;
  char v181;
  char v182;
  int v183;
  const char *v184;
  const char *v185;
  const char *v186;
  const char *v187;
  const char *v188;
  const char *cf;
  const char *cfa;
  const __CFData *cfb;
  void *key;
  CFErrorRef error;
  char __s[16];
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  __int128 v202;
  __int128 v203;
  __int128 v204;
  __int128 v205;
  __int128 v206;
  __int128 v207;
  __int128 v208;
  __int128 v209;
  char v210[8];
  CFDataRef theData[12800];
  _BYTE v212[102400];

  v1 = __chkstk_darwin(a1);
  v7 = v1;
  if (v1)
  {
    if (*(_DWORD *)(v1 + 16) <= 1u)
      v8 = 1;
    else
      v8 = *(_DWORD *)(v1 + 16);
  }
  else
  {
    v8 = 1;
  }
  v9 = 0;
  v10 = kCFAllocatorDefault;
  key = (void *)_kCFSystemVersionBuildVersionKey;
  do
  {
    AMAuthInstallLog(6, "tss_submit_job_with_retry", "TSS Connection attempt %d of %d.  (Will retry if TSS_ERR_SERVER_NOT_REACHABLE.)", v2, v3, v4, v5, v6, ++v9);
    error = 0;
    bzero(v212, 0x19000uLL);
    if (!*(_QWORD *)(v7 + 8))
    {
      AMAuthInstallLog(3, "tss_submit_job", "no server URL", v11, v12, v13, v14, v15, v176);
      v72 = 10008;
LABEL_25:
      sub_1000A7814((const __CFString *)v7, v72);
      v29 = 0;
      Request = 0;
      v73 = 0;
      v36 = 0;
      v74 = 0;
      v51 = 0;
      *(_DWORD *)(v7 + 64) = v72;
      goto LABEL_36;
    }
    v16 = CFPropertyListCreateData(v10, *(CFPropertyListRef *)(v7 + 24), kCFPropertyListXMLFormat_v1_0, 0, &error);
    if (!v16)
    {
      AMAuthInstallLog(3, "tss_submit_job", "CFPropertyListCreateXMLData failed %@", v17, v18, v19, v20, v21, (char)error);
      v72 = 10036;
      goto LABEL_25;
    }
    v22 = v16;
    Length = CFDataGetLength(v16);
    v29 = CFURLCreateWithString(v10, CFSTR("TSS/controller?action=2"), *(CFURLRef *)(v7 + 8));
    if (!v29)
    {
      AMAuthInstallLog(3, "tss_submit_job", "CFURLCreateCopyAppendingPathComponent() failed", v24, v25, v26, v27, v28, v176);
      v75 = 10041;
      sub_1000A7814((const __CFString *)v7, 10041);
      Request = 0;
LABEL_28:
      v73 = 0;
      v36 = 0;
      v51 = 0;
LABEL_35:
      *(_DWORD *)(v7 + 64) = v75;
      CFRelease(v22);
      v74 = 0;
      goto LABEL_36;
    }
    Request = CFHTTPMessageCreateRequest(v10, CFSTR("POST"), v29, kCFHTTPVersion1_1);
    if (!Request)
    {
      AMAuthInstallLog(3, "tss_submit_job", "CFHTTPMessageCreateRequest failed", v30, v31, v32, v33, v34, v176);
      v75 = 10041;
      sub_1000A7814((const __CFString *)v7, 10041);
      goto LABEL_28;
    }
    v177 = Length;
    v36 = CFStringCreateWithFormat(v10, 0, CFSTR("%d"));
    CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Proxy-Connection"), CFSTR("Keep-Alive"));
    CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Pragma"), CFSTR("no-cache"));
    CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Content-Type"), CFSTR("text/xml; charset=\"utf-8\""));
    CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("Content-Length"), v36);
    v37 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (v37)
    {
      v43 = v37;
      Value = (const __CFString *)CFDictionaryGetValue(v37, key);
      CFHTTPMessageSetHeaderFieldValue(Request, CFSTR("X-OS-Version"), Value);
      CFRelease(v43);
    }
    if (*(_QWORD *)(v7 + 32))
    {
      AMAuthInstallLog(7, "tss_submit_job", "Attempting to add additional entries to HTTP header", v38, v39, v40, v41, v42, v177);
      CFDictionaryApplyFunction(*(CFDictionaryRef *)(v7 + 32), (CFDictionaryApplierFunction)sub_1000A8354, Request);
      AMAuthInstallLog(7, "tss_submit_job", "Done adding additional fields to HTTP header", v45, v46, v47, v48, v49, v178);
    }
    CFHTTPMessageSetBody(Request, v22);
    Mutable = CFDictionaryCreateMutable(v10, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    v51 = Mutable;
    v52 = *(const void **)(v7 + 80);
    if (v52)
    {
      CFDictionaryAddValue(Mutable, CFSTR("SocksProxySettings"), v52);
      AMAuthInstallLog(7, "tss_submit_job", "Found a SOCKS proxy setting. Will attempt to use it.", v53, v54, v55, v56, v57, v177);
    }
    v58 = *(const void **)(v7 + 88);
    if (v58)
    {
      CFDictionaryAddValue(v51, CFSTR("TrustedServerCAs"), v58);
      AMAuthInstallLog(7, "tss_submit_job", "Found a trusted server CA. Will attempt to use it.", v59, v60, v61, v62, v63, v177);
    }
    theData[0] = 0;
    v64 = CFURLCopyScheme(*(CFURLRef *)(v7 + 8));
    if (!v64)
    {
      v71 = "Invalid scheme in url";
      goto LABEL_32;
    }
    v70 = v64;
    *(_DWORD *)__s = 10000;
    if (CFStringCompare(v64, CFSTR("https"), 1uLL) && CFStringCompare(v70, CFSTR("http"), 1uLL))
    {
      CFRelease(v70);
      v71 = "unsupported URL scheme";
LABEL_32:
      AMAuthInstallLog(3, "tss_submit_job", v71, v65, v66, v67, v68, v69, v177);
      v75 = 10008;
      v81 = (const __CFString *)v7;
      v82 = 10008;
      goto LABEL_33;
    }
    CFRelease(v70);
    if (AMAuthInstallHttpMessageSendSyncNew(v10, (uint64_t)Request, (CFTypeRef *)theData, __s, v51, 300.0))
    {
      AMAuthInstallLog(3, "tss_submit_job", "failed to send http request", v76, v77, v78, v79, v80, v177);
      v75 = 10002;
      v81 = (const __CFString *)v7;
      v82 = 10002;
LABEL_33:
      sub_1000A7814(v81, v82);
LABEL_34:
      v73 = CFSTR("Content-Length");
      goto LABEL_35;
    }
    v75 = *(_DWORD *)__s;
    if (*(_DWORD *)__s != 200)
    {
      AMAuthInstallLog(3, "tss_submit_job", "SendHttpRequest failed %d", v76, v77, v78, v79, v80, __s[0]);
      if (*(_DWORD *)__s == -1)
        v75 = 10002;
      v89 = (const __CFString *)v7;
      v90 = v75;
      goto LABEL_62;
    }
    if ((unint64_t)CFDataGetLength(theData[0]) > 0x19000)
    {
      AMAuthInstallLog(3, "tss_submit_job", "Response too large", v84, v85, v86, v87, v88, v177);
      v75 = 10052;
      v89 = (const __CFString *)v7;
      v90 = 10052;
LABEL_62:
      sub_1000A7814(v89, v90);
      CFRelease(theData[0]);
      goto LABEL_34;
    }
    BytePtr = CFDataGetBytePtr(theData[0]);
    v92 = CFDataGetLength(theData[0]);
    __memcpy_chk(v212, BytePtr, v92, 102400);
    LODWORD(BytePtr) = CFDataGetLength(theData[0]);
    CFRelease(theData[0]);
    v98 = (int)BytePtr;
    *(_QWORD *)v210 = 0;
    *(_OWORD *)__s = 0u;
    v195 = 0u;
    v196 = 0u;
    v197 = 0u;
    v198 = 0u;
    v199 = 0u;
    v200 = 0u;
    v201 = 0u;
    v202 = 0u;
    v203 = 0u;
    v204 = 0u;
    v205 = 0u;
    v206 = 0u;
    v207 = 0u;
    v208 = 0u;
    v209 = 0u;
    v183 = (int)BytePtr;
    if ((int)BytePtr < 1)
    {
      v102 = 0;
      v187 = 0;
      cf = 0;
      v186 = 0;
      goto LABEL_101;
    }
    v99 = 0;
    v100 = 0;
    v101 = 0;
    v102 = 0;
    v103 = v212;
    do
    {
      if (v101)
      {
        if (v100)
          goto LABEL_67;
      }
      else if (v102 + 7 >= v98)
      {
        v101 = 0;
        if (v100)
          goto LABEL_67;
      }
      else
      {
        v184 = v99;
        v188 = v100;
        if (!strncmp(v103, "STATUS", 6uLL))
        {
          v104 = 0;
          v101 = v103 + 7;
          v99 = v184;
          do
          {
            v105 = v103[v104 + 7];
            if (v105 == 38)
              break;
            v210[v104++] = v105;
          }
          while (v104 != 8);
          v210[7] = 0;
          v98 = v183;
        }
        else
        {
          v101 = 0;
          v98 = v183;
          v99 = v184;
        }
        v100 = v188;
        if (v188)
        {
LABEL_67:
          if (v99)
            goto LABEL_98;
          goto LABEL_68;
        }
      }
      if (v102 + 8 >= v98)
      {
        v100 = 0;
        if (v99)
          goto LABEL_98;
      }
      else
      {
        cfa = v101;
        v185 = v99;
        if (!strncmp(v103, "MESSAGE", 7uLL))
        {
          v106 = 0;
          v100 = v103 + 8;
          v99 = v185;
          v101 = cfa;
          do
          {
            v107 = v103[v106 + 8];
            if (v107 == 10)
              break;
            if (v107 == 38)
              break;
            __s[v106++] = v107;
          }
          while (v106 != 256);
          HIBYTE(v209) = 0;
          v98 = v183;
          if (v185)
            goto LABEL_98;
        }
        else
        {
          v100 = 0;
          v98 = v183;
          v99 = v185;
          v101 = cfa;
          if (v185)
            goto LABEL_98;
        }
      }
LABEL_68:
      if (v102 + 15 >= v98)
      {
        v99 = 0;
      }
      else
      {
        v187 = v100;
        cf = v101;
        if (!strncmp(v103, "REQUEST_STRING", 0xEuLL))
        {
          v99 = v103 + 15;
          v101 = cf;
          if (cf)
          {
            v98 = v183;
            v100 = v187;
            if (v187)
            {
              v186 = v103 + 15;
              goto LABEL_101;
            }
          }
          else
          {
            v98 = v183;
            v100 = v187;
          }
        }
        else
        {
          v99 = 0;
          v98 = v183;
          v100 = v187;
          v101 = cf;
        }
      }
LABEL_98:
      ++v103;
      ++v102;
    }
    while (v102 != v98);
    v186 = v99;
    v187 = v100;
    v102 = v98;
    cf = v101;
LABEL_101:
    AMAuthInstallLog(8, "tss_submit_job", "----Begin request", v93, v94, v95, v96, v97, v177);
    AMAuthInstallLog(8, "tss_submit_job", "%@", v108, v109, v110, v111, v112, *(_QWORD *)(v7 + 24));
    AMAuthInstallLog(8, "tss_submit_job", "----End request", v113, v114, v115, v116, v117, v179);
    AMAuthInstallLog(8, "tss_submit_job", "----Begin response", v118, v119, v120, v121, v122, v180);
    AMAuthInstallLog(8, "tss_submit_job", "%s", v123, v124, v125, v126, v127, (char)v212);
    AMAuthInstallLog(8, "tss_submit_job", "----End response", v128, v129, v130, v131, v132, v181);
    if (!cf || !v187)
    {
      AMAuthInstallLog(3, "tss_submit_job", "invalid response", v133, v134, v135, v136, v137, v182);
      v144 = 10052;
      v153 = (const __CFString *)v7;
      v154 = 10052;
      goto LABEL_109;
    }
    v138 = atoi(v210);
    if (!v138)
    {
      if (v186)
      {
        v155 = v183 - v102 - 15;
        __memcpy_chk(theData, v186, v155, 102400);
        v156 = CFDataCreate(kCFAllocatorDefault, (const UInt8 *)theData, v155);
        if (v156)
        {
          v162 = v156;
          if (error)
            CFRelease(error);
          cfb = v162;
          v74 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, v162, 0, 0, &error);
          if (v74)
          {
            Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, v74);
            *(_QWORD *)(v7 + 40) = Copy;
            if (Copy)
            {
              v174 = 0;
LABEL_124:
              *(_DWORD *)(v7 + 64) = v174;
              CFRelease(v22);
              CFRelease(cfb);
              goto LABEL_111;
            }
            AMAuthInstallLog(3, "tss_submit_job", "CFDictionaryCreateCopy failed", v169, v170, v171, v172, v173, v182);
            v174 = 10056;
          }
          else
          {
            AMAuthInstallLog(3, "tss_submit_job", "CFPropertyListCreateFromXMLData failed (%@)", v163, v164, v165, v166, v167, (char)error);
            v174 = 10055;
          }
          sub_1000A7814((const __CFString *)v7, v174);
          goto LABEL_124;
        }
        AMAuthInstallLog(3, "tss_submit_job", "CFDataCreate failed", v157, v158, v159, v160, v161, v182);
        v144 = 10054;
        v153 = (const __CFString *)v7;
        v154 = 10054;
      }
      else
      {
        AMAuthInstallLog(3, "tss_submit_job", "no data in response", v139, v140, v141, v142, v143, v182);
        v144 = 10053;
        v153 = (const __CFString *)v7;
        v154 = 10053;
      }
LABEL_109:
      sub_1000A7814(v153, v154);
      goto LABEL_110;
    }
    v144 = v138;
    AMAuthInstallLog(3, "tss_submit_job", "error from server=%d (%s)", v139, v140, v141, v142, v143, v138);
    v145 = *(const void **)(v7 + 72);
    if (v145)
      CFRelease(v145);
    v146 = strlen(__s);
    v147 = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)__s, v146, 0x8000100u, 0);
    *(_QWORD *)(v7 + 72) = v147;
    if (!v147)
      AMAuthInstallLog(3, "tss_submit_job", "Server message failed to convert: %d", v148, v149, v150, v151, v152, v144);
LABEL_110:
    *(_DWORD *)(v7 + 64) = v144;
    CFRelease(v22);
    v74 = 0;
LABEL_111:
    v73 = CFSTR("Content-Length");
LABEL_36:
    if (error)
      CFRelease(error);
    if (v29)
      CFRelease(v29);
    if (Request)
      CFRelease(Request);
    if (v73)
      CFRelease(v73);
    if (v36)
      CFRelease(v36);
    v10 = kCFAllocatorDefault;
    if (v74)
      CFRelease(v74);
    if (v51)
      CFRelease(v51);
    v83 = *(void (**)(uint64_t))(v7 + 48);
    if (v83)
      v83(v7);
  }
  while (v7 && v9 < v8 && *(_DWORD *)(v7 + 64) == 10002);
  return 0;
}

void sub_1000A8354(const __CFString *a1, const __CFString *a2, __CFHTTPMessage *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char v11[16];
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  char buffer[16];
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;

  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v69 = 0u;
  v70 = 0u;
  v67 = 0u;
  v68 = 0u;
  v65 = 0u;
  v66 = 0u;
  v63 = 0u;
  v64 = 0u;
  v61 = 0u;
  v62 = 0u;
  v59 = 0u;
  v60 = 0u;
  v57 = 0u;
  v58 = 0u;
  v55 = 0u;
  v56 = 0u;
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  *(_OWORD *)buffer = 0u;
  v44 = 0u;
  v41 = 0u;
  v42 = 0u;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v13 = 0u;
  v14 = 0u;
  *(_OWORD *)v11 = 0u;
  v12 = 0u;
  CFStringGetCString(a1, buffer, 511, 0x8000100u);
  CFStringGetCString(a2, v11, 511, 0x8000100u);
  AMAuthInstallLog(7, "_AMAuthInstallUpdateHTTPHeaderWithEntry", "Appending {%s : %s} to http header", v6, v7, v8, v9, v10, (char)buffer);
  CFHTTPMessageSetHeaderFieldValue(a3, a1, a2);
}

void YonkersAddEntitlementsToTATSURequestDict(const __CFDictionary *a1, __CFDictionary *a2)
{
  const __CFBoolean *Value;
  const __CFBoolean *v5;
  CFTypeID v6;
  int v7;
  const void **v8;
  const __CFBoolean *v9;
  const __CFBoolean *v10;
  CFTypeID v11;
  int v12;
  const void **v13;
  const __CFBoolean *v14;
  const __CFBoolean *v15;
  CFTypeID v16;
  int v17;
  const void **v18;
  const __CFBoolean *v19;
  const __CFBoolean *v20;
  CFTypeID v21;
  int v22;
  const void **v23;
  const __CFBoolean *v24;
  const __CFBoolean *v25;
  CFTypeID v26;
  int v27;
  const void **v28;
  const __CFBoolean *v29;
  const __CFBoolean *v30;
  CFTypeID v31;
  int v32;
  const void **v33;
  const __CFBoolean *v34;
  const __CFBoolean *v35;
  CFTypeID v36;
  int v37;
  const void **v38;
  const __CFBoolean *v39;
  const __CFBoolean *v40;
  CFTypeID v41;
  int v42;
  const void **v43;
  const __CFBoolean *v44;
  const __CFBoolean *v45;
  CFTypeID v46;
  int v47;
  const void **v48;
  const __CFBoolean *v49;
  const __CFBoolean *v50;
  CFTypeID v51;
  int v52;
  const void **v53;
  const __CFBoolean *v54;
  const __CFBoolean *v55;
  CFTypeID v56;
  int v57;
  const void **v58;
  const __CFBoolean *v59;
  const __CFBoolean *v60;
  CFTypeID v61;
  int v62;
  const void **v63;
  const __CFBoolean *v64;
  const __CFBoolean *v65;
  CFTypeID v66;
  int v67;
  const void **v68;

  Value = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,ReadECKey"));
  if (Value)
  {
    v5 = Value;
    v6 = CFGetTypeID(Value);
    if (v6 == CFBooleanGetTypeID())
    {
      v7 = CFBooleanGetValue(v5);
      v8 = (const void **)&kCFBooleanTrue;
      if (!v7)
        v8 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,ReadECKey"), *v8);
    }
  }
  v9 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,WriteECKey"));
  if (v9)
  {
    v10 = v9;
    v11 = CFGetTypeID(v9);
    if (v11 == CFBooleanGetTypeID())
    {
      v12 = CFBooleanGetValue(v10);
      v13 = (const void **)&kCFBooleanTrue;
      if (!v12)
        v13 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,WriteECKey"), *v13);
    }
  }
  v14 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,WriteECID"));
  if (v14)
  {
    v15 = v14;
    v16 = CFGetTypeID(v14);
    if (v16 == CFBooleanGetTypeID())
    {
      v17 = CFBooleanGetValue(v15);
      v18 = (const void **)&kCFBooleanTrue;
      if (!v17)
        v18 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,WriteECID"), *v18);
    }
  }
  v19 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,WriteEpoch"));
  if (v19)
  {
    v20 = v19;
    v21 = CFGetTypeID(v19);
    if (v21 == CFBooleanGetTypeID())
    {
      v22 = CFBooleanGetValue(v20);
      v23 = (const void **)&kCFBooleanTrue;
      if (!v22)
        v23 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,WriteEpoch"), *v23);
    }
  }
  v24 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,ReadGID"));
  if (v24)
  {
    v25 = v24;
    v26 = CFGetTypeID(v24);
    if (v26 == CFBooleanGetTypeID())
    {
      v27 = CFBooleanGetValue(v25);
      v28 = (const void **)&kCFBooleanTrue;
      if (!v27)
        v28 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,ReadGID"), *v28);
    }
  }
  v29 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,ReadFWKey"));
  if (v29)
  {
    v30 = v29;
    v31 = CFGetTypeID(v29);
    if (v31 == CFBooleanGetTypeID())
    {
      v32 = CFBooleanGetValue(v30);
      v33 = (const void **)&kCFBooleanTrue;
      if (!v32)
        v33 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,ReadFWKey"), *v33);
    }
  }
  v34 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,AllowOfflineBoot"));
  if (v34)
  {
    v35 = v34;
    v36 = CFGetTypeID(v34);
    if (v36 == CFBooleanGetTypeID())
    {
      v37 = CFBooleanGetValue(v35);
      v38 = (const void **)&kCFBooleanTrue;
      if (!v37)
        v38 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,AllowOfflineBoot"), *v38);
    }
  }
  v39 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,TempDemote"));
  if (v39)
  {
    v40 = v39;
    v41 = CFGetTypeID(v39);
    if (v41 == CFBooleanGetTypeID())
    {
      v42 = CFBooleanGetValue(v40);
      v43 = (const void **)&kCFBooleanTrue;
      if (!v42)
        v43 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,TempDemote"), *v43);
    }
  }
  v44 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,AccessSensor"));
  if (v44)
  {
    v45 = v44;
    v46 = CFGetTypeID(v44);
    if (v46 == CFBooleanGetTypeID())
    {
      v47 = CFBooleanGetValue(v45);
      v48 = (const void **)&kCFBooleanTrue;
      if (!v47)
        v48 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,AccessSensor"), *v48);
    }
  }
  v49 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,AccessSecurity"));
  if (v49)
  {
    v50 = v49;
    v51 = CFGetTypeID(v49);
    if (v51 == CFBooleanGetTypeID())
    {
      v52 = CFBooleanGetValue(v50);
      v53 = (const void **)&kCFBooleanTrue;
      if (!v52)
        v53 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,AccessSecurity"), *v53);
    }
  }
  v54 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,FADemote"));
  if (v54)
  {
    v55 = v54;
    v56 = CFGetTypeID(v54);
    if (v56 == CFBooleanGetTypeID())
    {
      v57 = CFBooleanGetValue(v55);
      v58 = (const void **)&kCFBooleanTrue;
      if (!v57)
        v58 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,FADemote"), *v58);
    }
  }
  v59 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,DebugStatus"));
  if (v59)
  {
    v60 = v59;
    v61 = CFGetTypeID(v59);
    if (v61 == CFBooleanGetTypeID())
    {
      v62 = CFBooleanGetValue(v60);
      v63 = (const void **)&kCFBooleanTrue;
      if (!v62)
        v63 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,DebugStatus"), *v63);
    }
  }
  v64 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,Provisioning"));
  if (v64)
  {
    v65 = v64;
    v66 = CFGetTypeID(v64);
    if (v66 == CFBooleanGetTypeID())
    {
      v67 = CFBooleanGetValue(v65);
      v68 = (const void **)&kCFBooleanTrue;
      if (!v67)
        v68 = (const void **)&kCFBooleanFalse;
      CFDictionaryAddValue(a2, CFSTR("Yonkers,Provisioning"), *v68);
    }
  }
}

uint64_t CreateYonkersMeasurementDict(const __CFData *a1, CFTypeRef *a2)
{
  __CFDictionary *Mutable;
  __CFDictionary *v5;
  UInt8 *v6;
  BOOL v7;
  uint64_t v8;
  unint64_t Length;
  CFDataRef v10;
  CFDataRef v11;
  CC_SHA256_CTX c;
  unsigned __int8 md[16];
  __int128 v15;
  CFRange v16;

  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_OWORD *)md = 0u;
  v15 = 0u;
  v5 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = 0;
  if (v5)
    v7 = Mutable == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = 2;
    if (a1 && a2)
    {
      Length = CFDataGetLength(a1);
      v6 = (UInt8 *)calloc(Length, 1uLL);
      if (v6)
      {
        v16.location = 0;
        v16.length = Length;
        CFDataGetBytes(a1, v16, v6);
        if (!(Length >> 20))
        {
          CC_SHA256_Init(&c);
          CC_SHA256_Update(&c, v6, Length);
          CC_SHA256_Final(md, &c);
        }
        v10 = CFDataCreate(kCFAllocatorDefault, md, 32);
        if (v10)
        {
          v11 = v10;
          CFDictionarySetValue(Mutable, CFSTR("Digest"), v10);
          CFDictionarySetValue(v5, CFSTR("MeasurementDictPatch"), Mutable);
          *a2 = SavageSafeRetain(v5);
          CFRelease(v11);
          v8 = 0;
        }
        else
        {
          v8 = 8;
        }
      }
      else
      {
        v8 = 3;
      }
    }
    goto LABEL_12;
  }
  v8 = 3;
  if (Mutable)
LABEL_12:
    CFRelease(Mutable);
  if (v5)
    CFRelease(v5);
  if (v6)
    free(v6);
  return v8;
}

uint64_t CreateYonkersRequestDictForTATSU(const __CFDictionary *a1, const __CFDictionary *a2, CFDictionaryRef theDict, uint64_t a4, CFTypeRef *a5)
{
  CFMutableDictionaryRef Mutable;
  uint64_t v6;
  __CFDictionary *v10;
  __CFDictionary *v11;
  const void *v12;
  const void *v13;
  CFTypeID v14;
  const void *v15;
  const void *v16;
  CFTypeID v17;
  const void *v18;
  const void *v19;
  CFTypeID v20;
  const __CFBoolean *v21;
  const __CFBoolean *v22;
  CFTypeID v23;
  CFBooleanRef v24;
  const __CFBoolean *v25;
  const __CFBoolean *v26;
  CFTypeID v27;
  int v28;
  const __CFBoolean *v29;
  const __CFBoolean *v30;
  CFTypeID v31;
  const __CFBoolean *v32;
  const __CFBoolean *v33;
  CFTypeID v34;
  int v35;
  const void *v36;
  const void *v37;
  CFTypeID v38;
  const void *v39;
  const void *v40;
  CFTypeID v41;
  int YonkersMeasurementTags;
  void *v43;
  const void *v44;
  __CFDictionary *v45;
  __CFDictionary *v46;
  CFTypeID v47;
  const void *v48;
  uint64_t v49;
  unint64_t v50;
  int v51;
  CFMutableDictionaryRef v53;
  CFTypeID v54;
  uint64_t v55;
  unint64_t v56;
  int v57;
  CFMutableDictionaryRef MutableCopy;
  CFTypeID v60;
  int v62;
  CFTypeRef *v63;
  __CFDictionary *v64;
  int v66;
  const __CFDictionary *Value;
  int valuePtr;
  CFTypeRef v69;
  void *key;

  Mutable = 0;
  v69 = 0;
  key = 0;
  valuePtr = 0;
  v6 = 2;
  if (!a1 || !a2 || !theDict || !a4)
  {
    v10 = 0;
    goto LABEL_66;
  }
  v10 = 0;
  if (!a5)
    goto LABEL_66;
  Value = (const __CFDictionary *)CFDictionaryGetValue(theDict, CFSTR("MeasurementDictPatch"));
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v11 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v10 = v11;
  v6 = 3;
  if (!v11 || !Mutable || !Value)
    goto LABEL_66;
  CFDictionaryAddValue(v11, CFSTR("@Yonkers,Ticket"), kCFBooleanTrue);
  v12 = CFDictionaryGetValue(a2, CFSTR("Yonkers,BoardID"));
  if (!v12)
    goto LABEL_77;
  v13 = v12;
  v14 = CFGetTypeID(v12);
  if (v14 != CFNumberGetTypeID())
    goto LABEL_77;
  CFDictionaryAddValue(v10, CFSTR("Yonkers,BoardID"), v13);
  v15 = CFDictionaryGetValue(a2, CFSTR("Yonkers,PatchEpoch"));
  if (!v15)
    goto LABEL_77;
  v16 = v15;
  v17 = CFGetTypeID(v15);
  if (v17 != CFNumberGetTypeID())
    goto LABEL_77;
  CFDictionaryAddValue(v10, CFSTR("Yonkers,PatchEpoch"), v16);
  v18 = CFDictionaryGetValue(a1, CFSTR("Yonkers,ChipID"));
  if (!v18)
    goto LABEL_77;
  v19 = v18;
  v20 = CFGetTypeID(v18);
  if (v20 != CFNumberGetTypeID())
    goto LABEL_77;
  CFDictionaryAddValue(v10, CFSTR("Yonkers,ChipID"), v19);
  CFNumberGetValue((CFNumberRef)v19, kCFNumberSInt32Type, &valuePtr);
  v21 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,ProductionMode"));
  if (!v21)
    goto LABEL_77;
  v22 = v21;
  v23 = CFGetTypeID(v21);
  if (v23 != CFBooleanGetTypeID())
    goto LABEL_77;
  v66 = CFBooleanGetValue(v22);
  v24 = v66 ? kCFBooleanTrue : kCFBooleanFalse;
  CFDictionaryAddValue(v10, CFSTR("Yonkers,ProductionMode"), v24);
  v25 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("YonkersIsProvisioned"));
  if (v25 && (v26 = v25, v27 = CFGetTypeID(v25), v27 == CFBooleanGetTypeID()))
    v28 = CFBooleanGetValue(v26);
  else
    v28 = 1;
  v29 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("YonkersIsYmgt"));
  if (v29 && (v30 = v29, v31 = CFGetTypeID(v29), v31 == CFBooleanGetTypeID()))
    v62 = CFBooleanGetValue(v30);
  else
    v62 = 0;
  v32 = (const __CFBoolean *)CFDictionaryGetValue(a1, CFSTR("Yonkers,WriteECID"));
  if (v32 && (v33 = v32, v34 = CFGetTypeID(v32), v34 == CFBooleanGetTypeID()))
    v35 = CFBooleanGetValue(v33);
  else
    v35 = 0;
  v36 = CFDictionaryGetValue(a1, CFSTR("Yonkers,ECID"));
  if (!v36)
    goto LABEL_77;
  v37 = v36;
  v38 = CFGetTypeID(v36);
  if (v38 != CFDataGetTypeID())
    goto LABEL_77;
  CFDictionaryAddValue(v10, CFSTR("Yonkers,ECID"), v37);
  v39 = CFDictionaryGetValue(a1, CFSTR("Yonkers,Nonce"));
  if (!v39)
    goto LABEL_77;
  v40 = v39;
  v41 = CFGetTypeID(v39);
  if (v41 != CFDataGetTypeID())
    goto LABEL_77;
  CFDictionaryAddValue(v10, CFSTR("Yonkers,Nonce"), v40);
  YonkersMeasurementTags = GetYonkersMeasurementTags(a1, (CFTypeRef *)&key, &v69);
  v43 = key;
  v6 = 17;
  if (!YonkersMeasurementTags && key)
  {
    v44 = CFDictionaryGetValue(theDict, CFSTR("MeasurementDictPatch"));
    v45 = (__CFDictionary *)SavageSafeRetain(v44);
    if (!v45)
    {
LABEL_66:
      v43 = key;
      goto LABEL_67;
    }
    v46 = v45;
    v47 = CFGetTypeID(v45);
    if (v47 == CFDictionaryGetTypeID())
    {
      v63 = a5;
      v64 = Mutable;
      CFDictionaryAddValue(v46, CFSTR("EPRO"), v24);
      v48 = CFDictionaryGetValue(a1, CFSTR("Yonkers,FabRevision"));
      CFDictionaryAddValue(v46, CFSTR("FabRevision"), v48);
      CFDictionaryAddValue(v10, key, v46);
      CFRelease(v46);
      if (!(v28 | v35))
      {
        CFDictionaryRemoveValue(v10, key);
        if (valuePtr == 1300)
        {
          v55 = 4 * (v62 != 0);
          if (v62)
            v56 = 8;
          else
            v56 = 4;
          while (1)
          {
            v57 = dword_100167168[v55];
            if (GetYonkersFabRevisionTags(v57, v66, (CFTypeRef *)&key, 0) || key == 0)
              goto LABEL_74;
            MutableCopy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
            if (!MutableCopy)
              goto LABEL_74;
            v46 = MutableCopy;
            v60 = CFGetTypeID(MutableCopy);
            if (v60 != CFDictionaryGetTypeID())
            {
LABEL_75:
              Mutable = v64;
              goto LABEL_76;
            }
            CFDictionarySetValue(v46, CFSTR("EPRO"), v24);
            SavageCFDictionarySetInteger32(v46, CFSTR("FabRevision"), v57);
            CFDictionarySetValue(v10, key, v46);
            CFRelease(v46);
            if (++v55 >= v56)
              goto LABEL_64;
          }
        }
        if (valuePtr == 1044)
        {
          v49 = 4 * (v62 != 0);
          if (v62)
            v50 = 6;
          else
            v50 = 4;
          while (1)
          {
            v51 = dword_100167150[v49];
            if (GetYonkersFabRevisionTags(v51, v66, (CFTypeRef *)&key, 0) || key == 0)
              break;
            v53 = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, Value);
            if (!v53)
              break;
            v46 = v53;
            v54 = CFGetTypeID(v53);
            if (v54 != CFDictionaryGetTypeID())
              goto LABEL_75;
            CFDictionarySetValue(v46, CFSTR("EPRO"), v24);
            SavageCFDictionarySetInteger32(v46, CFSTR("FabRevision"), v51);
            CFDictionarySetValue(v10, key, v46);
            CFRelease(v46);
            if (++v49 >= v50)
              goto LABEL_64;
          }
LABEL_74:
          v6 = 17;
          goto LABEL_65;
        }
      }
LABEL_64:
      YonkersAddEntitlementsToTATSURequestDict(a1, v10);
      v6 = 0;
      *v63 = SavageSafeRetain(v10);
LABEL_65:
      Mutable = v64;
      goto LABEL_66;
    }
LABEL_76:
    CFRelease(v46);
LABEL_77:
    v6 = 17;
    goto LABEL_66;
  }
LABEL_67:
  if (v43)
  {
    CFRelease(v43);
    key = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
  if (v10)
    CFRelease(v10);
  return v6;
}

__CFDictionary *SavageUpdaterGetTagsWithLogging(const __CFDictionary *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3, CFTypeRef *a4)
{
  off_1001A8250 = a2;
  qword_1001A8258 = a3;
  return SavageUpdaterGetTags(a1, a4);
}

__CFDictionary *SavageUpdaterGetTags(const __CFDictionary *a1, CFTypeRef *a2)
{
  __CFDictionary *Mutable;
  __CFArray *v5;
  __CFArray *v6;
  const void *v7;
  const void *v8;
  CFTypeID v9;
  const __CFString *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const char *v18;
  const __CFString *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  const void *v27;
  CFTypeRef v28;
  CFTypeID v29;
  unsigned int YonkersMeasurementTags;
  const __CFData *v31;
  const __CFData *v32;
  const __CFString *v33;
  BOOL v34;
  const __CFString *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  const __CFString *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v52;
  unsigned int v53;
  uint64_t v54;
  CFErrorRef CFErrorWithDomain;
  const __CFString *v56;
  const char *v57;
  uint64_t v58;
  const __CFString *v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  const __CFString *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  UInt8 buffer[4];
  void *v76;
  void *value;
  void *v78;
  void *v79;
  CFRange v80;

  v78 = 0;
  v79 = 0;
  v76 = 0;
  value = 0;
  *(_DWORD *)buffer = 0;
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable)
  {
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterGetTags: Cannot allocate memory for outputDict", 3u, 0, CFSTR("SavageErrorDomain"));
    v28 = 0;
    v5 = 0;
    goto LABEL_45;
  }
  if (a1)
  {
    v5 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v5)
    {
      v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v6)
      {
        v7 = CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
        if (v7)
        {
          v8 = v7;
          v9 = CFGetTypeID(v7);
          if (v9 == CFDictionaryGetTypeID())
          {
            v10 = CFCopyDescription(v8);
            v18 = "SavageUpdaterGetTags";
            if (v10)
            {
              v19 = v10;
              CFStringGetCString(v10, logString, 4096, 0);
              sub_1000AAFF4("%s [input]: DeviceInfo %s \n", v20, v21, v22, v23, v24, v25, v26, (char)"SavageUpdaterGetTags");
              CFRelease(v19);
            }
            else
            {
              sub_1000AAFF4("%s [input]: DeviceInfo %s \n", v11, v12, v13, v14, v15, v16, v17, (char)"SavageUpdaterGetTags");
            }
            a1 = (const __CFDictionary *)SavageSafeRetain(v8);
            v27 = CFDictionaryGetValue(a1, CFSTR("YonkersDeviceInfo"));
            v28 = v27;
            if (v27)
            {
              v29 = CFGetTypeID(v27);
              if (v29 == CFDictionaryGetTypeID())
              {
                v28 = SavageSafeRetain(v28);
                YonkersMeasurementTags = GetYonkersMeasurementTags((CFDictionaryRef)v28, (CFTypeRef *)&value, (CFTypeRef *)&v76);
                if (YonkersMeasurementTags || !value)
                {
                  v56 = CFSTR("YonkersErrorDomain");
                  v57 = "SavageUpdaterGetTags: Unable to get kYonkersTagMeasurementPatch";
                  v58 = (uint64_t)v28;
LABEL_52:
                  CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v57, YonkersMeasurementTags, v58, v56);
                  goto LABEL_53;
                }
                CFArrayAppendValue(v5, CFSTR("SEP"));
                CFArrayAppendValue(v5, CFSTR("Yonkers,BoardID"));
                CFArrayAppendValue(v5, CFSTR("Yonkers,ChipID"));
                CFArrayAppendValue(v5, CFSTR("Yonkers,PatchEpoch"));
                CFArrayAppendValue(v5, value);
                CFArrayAppendValue(v5, v76);
                CFArrayAppendValue(v6, CFSTR("Yonkers,Ticket"));
                if (v28 && CFDictionaryGetCount(a1) == 1)
                {
LABEL_28:
                  CFDictionaryAddValue(Mutable, CFSTR("BuildIdentityTags"), v5);
                  CFDictionaryAddValue(Mutable, CFSTR("ResponseTags"), v6);
                  v35 = CFCopyDescription(Mutable);
                  if (v35)
                  {
                    v43 = v35;
                    CFStringGetCString(v35, logString, 4096, 0);
                    sub_1000AAFF4("%s [output]: %s \n", v44, v45, v46, v47, v48, v49, v50, (char)v18);
                    CFRelease(v43);
                  }
                  else
                  {
                    sub_1000AAFF4("%s [output]: %s \n", v36, v37, v38, v39, v40, v41, v42, (char)v18);
                  }
                  goto LABEL_31;
                }
              }
              else
              {
                v28 = 0;
              }
            }
            YonkersMeasurementTags = GetRelevantMeasurementTags(a1, (__CFString **)&v79, (__CFString **)&v78);
            if (v79)
            {
              if (v78)
              {
                CFArrayAppendValue(v5, CFSTR("Savage,ChipID"));
                CFArrayAppendValue(v5, CFSTR("Savage,PatchEpoch"));
                CFArrayAppendValue(v5, v79);
                CFArrayAppendValue(v5, v78);
                v31 = (const __CFData *)CFDictionaryGetValue(a1, CFSTR("Savage,ChipID"));
                if (v31)
                {
                  v32 = v31;
                  v18 = (const char *)CFGetTypeID(v31);
                  v33 = CFSTR("Savage,Ticket");
                  v34 = v18 == (const char *)CFDataGetTypeID();
                  LOBYTE(v18) = "SavageUpdaterGetTags";
                  if (v34)
                  {
                    v80.location = 0;
                    v80.length = 4;
                    CFDataGetBytes(v32, v80, buffer);
                    *(_DWORD *)buffer = bswap32(*(unsigned int *)buffer);
                    if (*(_DWORD *)buffer > 0x5064u)
                      v33 = CFSTR("Brunor,Ticket");
                  }
                }
                else
                {
                  v33 = CFSTR("Savage,Ticket");
                }
                CFArrayAppendValue(v6, v33);
                goto LABEL_28;
              }
              v56 = CFSTR("SavageErrorDomain");
              v57 = "SavageUpdaterGetTags: Unable to get kSavageTagMeasurementPatchRepair";
            }
            else
            {
              v56 = CFSTR("SavageErrorDomain");
              v57 = "SavageUpdaterGetTags: Unable to get kSavageTagMeasurementPatch";
            }
            v58 = (uint64_t)a1;
            goto LABEL_52;
          }
        }
        v52 = "SavageUpdaterGetTags: DeviceInfo is NULL?";
        v53 = 17;
        v54 = (uint64_t)a1;
      }
      else
      {
        v52 = "SavageUpdaterGetTags: Cannot allocate memory for tagsInTssResponse";
        v53 = 3;
        v54 = 0;
      }
      CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v52, v53, v54, CFSTR("SavageErrorDomain"));
      v28 = 0;
      goto LABEL_48;
    }
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterGetTags: Cannot allocate memory for tagsInBI", 3u, 0, CFSTR("SavageErrorDomain"));
    v28 = 0;
LABEL_45:
    v6 = 0;
LABEL_48:
    a1 = 0;
    goto LABEL_53;
  }
  CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterGetTags: options is NULL", 2u, 0, CFSTR("SavageErrorDomain"));
  v28 = 0;
  v5 = 0;
  v6 = 0;
LABEL_53:
  if (a2 && CFErrorWithDomain)
  {
    *a2 = SavageSafeRetain(CFErrorWithDomain);
    v59 = CFErrorCopyDescription(CFErrorWithDomain);
    if (v59)
    {
      v67 = v59;
      CFStringGetCString(v59, logString, 4096, 0);
      sub_1000AAFF4("%s [error]: %s \n", v68, v69, v70, v71, v72, v73, v74, (char)"SavageUpdaterGetTags");
      CFRelease(v67);
    }
    else
    {
      sub_1000AAFF4("%s [error]: %s \n", v60, v61, v62, v63, v64, v65, v66, (char)"SavageUpdaterGetTags");
    }
    if (Mutable)
    {
      CFRelease(Mutable);
      Mutable = 0;
    }
    goto LABEL_62;
  }
  if (CFErrorWithDomain)
LABEL_62:
    CFRelease(CFErrorWithDomain);
  if (v6)
LABEL_31:
    CFRelease(v6);
  if (v5)
    CFRelease(v5);
  if (v28)
    CFRelease(v28);
  if (a1)
    CFRelease(a1);
  if (value)
    CFRelease(value);
  return Mutable;
}

__CFDictionary *SavageUpdaterCopyFirmwareWithLogging(const __CFDictionary *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3, CFTypeRef *a4)
{
  off_1001A8250 = a2;
  qword_1001A8258 = a3;
  return SavageUpdaterCopyFirmware(a1, a4);
}

__CFDictionary *SavageUpdaterCopyFirmware(const __CFDictionary *a1, CFTypeRef *a2)
{
  const void *Value;
  const void *v4;
  CFTypeID v5;
  const __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const __CFDictionary *v22;
  const __CFData *v23;
  const __CFData *v24;
  CFTypeID v25;
  const __CFDictionary *v26;
  unsigned int YonkersMeasurementTags;
  const __CFData *v28;
  const __CFData *v29;
  const __CFData *v30;
  __CFDictionary *Mutable;
  __CFDictionary *v32;
  __CFData *v33;
  const __CFData *v34;
  const __CFData *v35;
  unsigned int RelevantMeasurementTags;
  const __CFData *v37;
  const UInt8 *BytePtr;
  CFIndex Length;
  const UInt8 *v40;
  CFIndex v41;
  const __CFString *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  const __CFString *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  const __CFString *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  const __CFString *v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  const __CFString *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  const __CFString *v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  const char *v91;
  uint64_t v92;
  __CFError *CFErrorWithDomain;
  unsigned int v94;
  const char *v95;
  uint64_t v96;
  UInt8 bytes[8];
  uint64_t v99;
  CFErrorRef err;
  __CFString *v101;
  __CFString *v102;
  CFTypeRef v103;
  CFTypeRef cf;
  CFRange v105;

  *(_QWORD *)bytes = 0;
  v103 = 0;
  cf = 0;
  v101 = 0;
  v102 = 0;
  v99 = 0;
  err = 0;
  if (!a1)
  {
    v91 = "SavageUpdaterCopyFirmware: options is NULL";
    v92 = 0;
    goto LABEL_69;
  }
  Value = CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
  if (!Value || (v4 = Value, v5 = CFGetTypeID(Value), v5 != CFDictionaryGetTypeID()))
  {
    v91 = "SavageUpdaterCopyFirmware: Missing device info";
    v92 = (uint64_t)a1;
LABEL_69:
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v91, 2u, v92, CFSTR("SavageErrorDomain"));
    v32 = 0;
    v24 = 0;
    v30 = 0;
    v22 = 0;
    v33 = 0;
    v34 = 0;
    v35 = 0;
    v26 = 0;
    goto LABEL_86;
  }
  v6 = CFCopyDescription(v4);
  if (v6)
  {
    v14 = v6;
    CFStringGetCString(v6, logString, 4096, 0);
    sub_1000AAFF4("%s [input]: DeviceInfo %s \n", v15, v16, v17, v18, v19, v20, v21, (char)"SavageUpdaterCopyFirmware");
    CFRelease(v14);
  }
  else
  {
    sub_1000AAFF4("%s [input]: DeviceInfo %s \n", v7, v8, v9, v10, v11, v12, v13, (char)"SavageUpdaterCopyFirmware");
  }
  v22 = (const __CFDictionary *)SavageSafeRetain(v4);
  v23 = (const __CFData *)CFDictionaryGetValue(v22, CFSTR("YonkersDeviceInfo"));
  v24 = v23;
  if (!v23)
  {
    v26 = 0;
    v30 = 0;
LABEL_22:
    v32 = 0;
    goto LABEL_23;
  }
  v25 = CFGetTypeID(v23);
  if (v25 != CFDictionaryGetTypeID())
  {
    v26 = 0;
    v30 = 0;
    v24 = 0;
    goto LABEL_22;
  }
  v26 = (const __CFDictionary *)SavageSafeRetain(v24);
  YonkersMeasurementTags = GetYonkersMeasurementTags(v26, &cf, &v103);
  if (YonkersMeasurementTags)
  {
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Didn't get yonkers patch measurement tags", YonkersMeasurementTags, (uint64_t)v26, CFSTR("YonkersErrorDomain"));
    v32 = 0;
    v24 = 0;
    goto LABEL_77;
  }
  v28 = (const __CFData *)sub_1000AB094(a1, (const __CFString *)cf, (CFTypeRef *)&err);
  v24 = v28;
  if (err)
  {
    v32 = 0;
    v30 = 0;
LABEL_80:
    v33 = 0;
    v34 = 0;
    goto LABEL_81;
  }
  if (!v28 || !CFDataGetLength(v28))
  {
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Empty Yonkers firmware file?", 4u, (uint64_t)a1, CFSTR("YonkersErrorDomain"));
    v32 = 0;
LABEL_77:
    v30 = 0;
    goto LABEL_84;
  }
  v29 = (const __CFData *)sub_1000AB094(a1, (const __CFString *)v103, (CFTypeRef *)&err);
  v30 = v29;
  if (err)
  {
    v32 = 0;
    goto LABEL_80;
  }
  if (!v29 || !CFDataGetLength(v29))
  {
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Empty Yonkers alt firmware file?", 4u, (uint64_t)a1, CFSTR("YonkersErrorDomain"));
    v32 = 0;
LABEL_84:
    v33 = 0;
    v34 = 0;
    goto LABEL_85;
  }
  Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v32 = Mutable;
  if (!Mutable)
  {
    v95 = "SavageUpdaterCopyFirmware: Cannot allocate memory for outputDict";
    v94 = 3;
    v96 = (uint64_t)a1;
LABEL_83:
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v95, v94, v96, CFSTR("SavageErrorDomain"));
    goto LABEL_84;
  }
  CFDictionaryAddValue(Mutable, CFSTR("YonkersFirmware"), v24);
  CFDictionaryAddValue(v32, CFSTR("YonkersFirmwareAlt"), v30);
  if (!v26 || CFDictionaryGetCount(v22) != 1)
  {
LABEL_23:
    RelevantMeasurementTags = GetRelevantMeasurementTags(v22, &v102, &v101);
    if (!RelevantMeasurementTags)
    {
      v37 = (const __CFData *)sub_1000AB094(a1, v102, (CFTypeRef *)&err);
      v34 = v37;
      if (!err)
      {
        if (v37 && CFDataGetLength(v37))
        {
          v35 = (const __CFData *)sub_1000AB094(a1, v101, (CFTypeRef *)&err);
          if (err && CFErrorGetCode(err) == 19)
          {
            v33 = 0;
            goto LABEL_40;
          }
          v33 = CFDataCreateMutable(0, 0);
          if (v33)
          {
            *(_DWORD *)&bytes[4] = CFDataGetLength(v34);
            CFDataAppendBytes(v33, bytes, 16);
            BytePtr = CFDataGetBytePtr(v34);
            Length = CFDataGetLength(v34);
            CFDataAppendBytes(v33, BytePtr, Length);
            if (v35)
            {
              LODWORD(v99) = CFDataGetLength(v35);
              v105.location = 0;
              v105.length = 16;
              CFDataReplaceBytes(v33, v105, bytes, 16);
              v40 = CFDataGetBytePtr(v35);
              v41 = CFDataGetLength(v35);
              CFDataAppendBytes(v33, v40, v41);
            }
            if (v32)
            {
              CFDictionaryAddValue(v32, CFSTR("SavageFirmware"), v33);
              CFRelease(v33);
              v33 = 0;
            }
            goto LABEL_34;
          }
          CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Cannot allocate memory for savageFirmwareData", 3u, (uint64_t)a1, CFSTR("SavageErrorDomain"));
LABEL_86:
          err = CFErrorWithDomain;
          goto LABEL_40;
        }
        CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCopyFirmware: Empty Savage firmware file", 4u, (uint64_t)a1, CFSTR("SavageErrorDomain"));
        v33 = 0;
LABEL_85:
        v35 = 0;
        goto LABEL_86;
      }
      v33 = 0;
LABEL_81:
      v35 = 0;
      goto LABEL_40;
    }
    v94 = RelevantMeasurementTags;
    v95 = "SavageUpdaterCopyFirmware: Unable to get savage patch measurement tags";
    v96 = (uint64_t)v22;
    goto LABEL_83;
  }
  v33 = 0;
  v34 = 0;
  v35 = 0;
LABEL_34:
  v42 = CFCopyDescription(v32);
  if (v42)
  {
    v50 = v42;
    CFStringGetCString(v42, logString, 4096, 0);
    sub_1000AAFF4("%s [output]: %s \n", v51, v52, v53, v54, v55, v56, v57, (char)"SavageUpdaterCopyFirmware");
    CFRelease(v50);
  }
  else
  {
    sub_1000AAFF4("%s [output]: %s \n", v43, v44, v45, v46, v47, v48, v49, (char)"SavageUpdaterCopyFirmware");
  }
  v58 = CFCopyDescription(v33);
  if (v58)
  {
    v66 = v58;
    CFStringGetCString(v58, logString, 4096, 0);
    sub_1000AAFF4("%s [output]: %s \n", v67, v68, v69, v70, v71, v72, v73, (char)"SavageUpdaterCopyFirmware");
    CFRelease(v66);
  }
  else
  {
    sub_1000AAFF4("%s [output]: %s \n", v59, v60, v61, v62, v63, v64, v65, (char)"SavageUpdaterCopyFirmware");
  }
LABEL_40:
  if (a2 && err)
  {
    *a2 = SavageSafeRetain(err);
    v74 = CFErrorCopyDescription(err);
    if (v74)
    {
      v82 = v74;
      CFStringGetCString(v74, logString, 4096, 0);
      sub_1000AAFF4("%s [error]: %s \n", v83, v84, v85, v86, v87, v88, v89, (char)"SavageUpdaterCopyFirmware");
      CFRelease(v82);
    }
    else
    {
      sub_1000AAFF4("%s [error]: %s \n", v75, v76, v77, v78, v79, v80, v81, (char)"SavageUpdaterCopyFirmware");
    }
  }
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v103)
  {
    CFRelease(v103);
    v103 = 0;
  }
  if (err)
  {
    CFRelease(err);
    err = 0;
  }
  if (v26)
    CFRelease(v26);
  if (v22)
    CFRelease(v22);
  if (v34)
    CFRelease(v34);
  if (v35)
    CFRelease(v35);
  if (v24)
    CFRelease(v24);
  if (v30)
    CFRelease(v30);
  if (v32)
    return v32;
  else
    return v33;
}

CFAllocatorRef SavageUpdaterCreateRequestWithLogging(const __CFDictionary *a1, uint64_t (*a2)(_QWORD, _QWORD), uint64_t a3, CFTypeRef *a4)
{
  off_1001A8250 = a2;
  qword_1001A8258 = a3;
  return SavageUpdaterCreateRequest(a1, a4);
}

CFAllocatorRef SavageUpdaterCreateRequest(const __CFDictionary *a1, CFTypeRef *a2)
{
  const void *Value;
  CFTypeRef v5;
  const __CFString *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const __CFString *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  const void *v22;
  CFTypeRef v23;
  const __CFString *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  const __CFString *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  const void *v40;
  const __CFString *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  const __CFString *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  CFTypeID v57;
  const void *v58;
  const __CFData *v59;
  const __CFData *v60;
  unsigned int v61;
  const void *v62;
  const __CFData *v63;
  const __CFData *v64;
  const __CFString *v65;
  const char *v66;
  const char *v67;
  uint64_t v68;
  CFErrorRef CFErrorWithDomain;
  const __CFDictionary *v70;
  CFTypeID v71;
  const __CFData *v72;
  const __CFString *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  const __CFString *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  const __CFString *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  const __CFString *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  const void *v105;
  const __CFDictionary *v106;
  const __CFDictionary *v107;
  CFTypeID v108;
  const void *v109;
  const __CFString *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  const __CFString *v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  const void *v126;
  unsigned int YonkersRequestDictForTATSU;
  CFAllocatorRef v128;
  unsigned int v129;
  uint64_t v130;
  const __CFString *v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  const __CFString *v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  const __CFDictionary *v147;
  CFMutableDataRef Mutable;
  CFMutableDictionaryRef v149;
  __CFDictionary *v150;
  const __CFString *v151;
  const __CFString *v152;
  CFTypeID v153;
  const __CFString *v154;
  const __CFString *v155;
  CFTypeID v156;
  const __CFData *v157;
  const __CFData *v158;
  CFTypeID v159;
  CFBooleanRef v160;
  const __CFString *v161;
  __CFDictionary *v162;
  CFMutableDataRef v163;
  const __CFBoolean *v164;
  const __CFBoolean *v165;
  CFTypeID v166;
  CFBooleanRef v167;
  const void *v168;
  const void *v169;
  CFTypeID v170;
  const void *v171;
  const void *v172;
  CFTypeID v173;
  unsigned int RelevantMeasurementTags;
  unsigned int v175;
  const void *v176;
  const void *v177;
  CFTypeID v178;
  const __CFDictionary *v179;
  const __CFDictionary *v180;
  CFTypeID v181;
  const void *v182;
  const void *v183;
  CFTypeID v184;
  const __CFBoolean *v185;
  const __CFBoolean *v186;
  CFTypeID v187;
  CFBooleanRef v188;
  const __CFBoolean *v189;
  unsigned int v190;
  const __CFBoolean *v191;
  CFTypeID v192;
  CFBooleanRef v193;
  const __CFBoolean *v194;
  const __CFBoolean *v195;
  CFTypeID v196;
  CFBooleanRef v197;
  const __CFBoolean *v198;
  const __CFBoolean *v199;
  CFTypeID v200;
  CFBooleanRef v201;
  const __CFBoolean *v202;
  const __CFBoolean *v203;
  CFTypeID v204;
  CFBooleanRef v205;
  const __CFBoolean *v206;
  const __CFBoolean *v207;
  CFTypeID v208;
  CFBooleanRef v209;
  const __CFBoolean *v210;
  const __CFBoolean *v211;
  CFTypeID v212;
  CFBooleanRef v213;
  const __CFBoolean *v214;
  const __CFBoolean *v215;
  CFTypeID v216;
  CFBooleanRef v217;
  const __CFBoolean *v218;
  const __CFBoolean *v219;
  CFTypeID v220;
  CFBooleanRef v221;
  const __CFBoolean *v222;
  const __CFBoolean *v223;
  CFTypeID v224;
  CFBooleanRef v225;
  const __CFBoolean *v226;
  const __CFBoolean *v227;
  CFTypeID v228;
  CFBooleanRef v229;
  const __CFBoolean *v230;
  const __CFBoolean *v231;
  CFTypeID v232;
  CFBooleanRef v233;
  const __CFBoolean *v234;
  const __CFBoolean *v235;
  CFTypeID v236;
  CFBooleanRef v237;
  const __CFBoolean *v238;
  const __CFBoolean *v239;
  CFTypeID v240;
  CFBooleanRef v241;
  const __CFBoolean *v242;
  const __CFBoolean *v243;
  CFTypeID v244;
  CFBooleanRef v245;
  const __CFBoolean *v246;
  const __CFBoolean *v247;
  CFTypeID v248;
  CFBooleanRef v249;
  const __CFString *v250;
  uint64_t v251;
  uint64_t v252;
  uint64_t v253;
  uint64_t v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  const __CFString *v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  CFTypeRef *v267;
  const __CFDictionary *v268;
  __CFData *v269;
  __CFDictionary *theDict;
  CFAllocatorRef allocator;
  CFTypeRef v272;
  CFTypeRef cf;
  __CFString *v274;
  void *key;
  UInt8 buffer[4];
  CFRange v277;

  v272 = 0;
  cf = 0;
  allocator = 0;
  if (a1)
  {
    if (CFDictionaryContainsKey(a1, CFSTR("BuildIdentity")))
    {
      Value = CFDictionaryGetValue(a1, CFSTR("BuildIdentity"));
      v5 = SavageSafeRetain(Value);
      v6 = CFCopyDescription(v5);
      if (v6)
      {
        v14 = v6;
        CFStringGetCString(v6, logString, 4096, 0);
        sub_1000AAFF4("%s [input]: BuildIdentity %s \n", v15, v16, v17, v18, v19, v20, v21, (char)"SavageUpdaterCreateRequest");
        CFRelease(v14);
        if (v5)
          goto LABEL_5;
      }
      else
      {
        sub_1000AAFF4("%s [input]: BuildIdentity %s \n", v7, v8, v9, v10, v11, v12, v13, (char)"SavageUpdaterCreateRequest");
        if (v5)
        {
LABEL_5:
          if (CFDictionaryContainsKey(a1, CFSTR("DeviceInfo")))
          {
            v22 = CFDictionaryGetValue(a1, CFSTR("DeviceInfo"));
            v23 = SavageSafeRetain(v22);
            v24 = CFCopyDescription(v23);
            if (v24)
            {
              v32 = v24;
              CFStringGetCString(v24, logString, 4096, 0);
              sub_1000AAFF4("%s [input]: DeviceInfo %s \n", v33, v34, v35, v36, v37, v38, v39, (char)"SavageUpdaterCreateRequest");
              CFRelease(v32);
              if (v23)
              {
LABEL_8:
                if (!CFDictionaryContainsKey(a1, CFSTR("FirmwareData")))
                  goto LABEL_34;
                v40 = CFDictionaryGetValue(a1, CFSTR("FirmwareData"));
                v41 = CFCopyDescription(v40);
                if (v41)
                {
                  v49 = v41;
                  CFStringGetCString(v41, logString, 4096, 0);
                  sub_1000AAFF4("%s [input]: FirmwareData %s \n", v50, v51, v52, v53, v54, v55, v56, (char)"SavageUpdaterCreateRequest");
                  CFRelease(v49);
                  if (v40)
                  {
LABEL_11:
                    v57 = CFGetTypeID(v40);
                    if (v57 == CFDictionaryGetTypeID())
                    {
                      v58 = CFDictionaryGetValue((CFDictionaryRef)v40, CFSTR("SavageFirmware"));
                      v59 = (const __CFData *)SavageSafeRetain(v58);
                      if (v59)
                      {
                        v60 = v59;
                        v61 = sub_1000AB624(v59, &cf);
                        CFRelease(v60);
                        if (v61)
                        {
                          v65 = CFSTR("SavageErrorDomain");
                          v66 = "SavageUpdaterCreateRequest: CreateMeasurementDict fails for Savage.";
                          goto LABEL_233;
                        }
                      }
                      v62 = CFDictionaryGetValue((CFDictionaryRef)v40, CFSTR("YonkersFirmware"));
                      v63 = (const __CFData *)SavageSafeRetain(v62);
                      if (v63)
                      {
                        v64 = v63;
                        v61 = CreateYonkersMeasurementDict(v63, &v272);
                        CFRelease(v64);
                        if (v61)
                        {
                          v65 = CFSTR("YonkersErrorDomain");
                          v66 = "SavageUpdaterCreateRequest: CreateMeasurementDict fails for Yonkers.";
LABEL_233:
                          v129 = v61;
                          v130 = (uint64_t)v40;
                          goto LABEL_48;
                        }
                      }
                    }
                    else
                    {
                      v71 = CFGetTypeID(v40);
                      if (v71 == CFDataGetTypeID())
                      {
                        v72 = (const __CFData *)SavageSafeRetain(v40);
                        v61 = sub_1000AB624(v72, &cf);
                        if (v72)
                          CFRelease(v72);
                        if (v61)
                        {
                          v65 = CFSTR("SavageErrorDomain");
                          v66 = "SavageUpdaterCreateRequest: CreateMeasurementDict fails for Savage (Old way).";
                          goto LABEL_233;
                        }
                      }
                    }
                    v73 = CFCopyDescription(cf);
                    if (v73)
                    {
                      v81 = v73;
                      CFStringGetCString(v73, logString, 4096, 0);
                      sub_1000AAFF4("%s [input]: SavageMeasurementDict - %s \n", v82, v83, v84, v85, v86, v87, v88, (char)"SavageUpdaterCreateRequest");
                      CFRelease(v81);
                    }
                    else
                    {
                      sub_1000AAFF4("%s [input]: SavageMeasurementDict - %s \n", v74, v75, v76, v77, v78, v79, v80, (char)"SavageUpdaterCreateRequest");
                    }
                    v89 = CFCopyDescription(v272);
                    if (v89)
                    {
                      v97 = v89;
                      CFStringGetCString(v89, logString, 4096, 0);
                      sub_1000AAFF4("%s [input]: YonkersMeasurementDict - %s \n", v98, v99, v100, v101, v102, v103, v104, (char)"SavageUpdaterCreateRequest");
                      CFRelease(v97);
                    }
                    else
                    {
                      sub_1000AAFF4("%s [input]: YonkersMeasurementDict - %s \n", v90, v91, v92, v93, v94, v95, v96, (char)"SavageUpdaterCreateRequest");
                    }
LABEL_34:
                    if (!CFDictionaryContainsKey(a1, CFSTR("ReceiptManifest")))
                      goto LABEL_47;
                    v105 = CFDictionaryGetValue(a1, CFSTR("ReceiptManifest"));
                    v40 = SavageSafeRetain(v105);
                    v106 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v40, CFSTR("SEP"));
                    if (v106)
                    {
                      v107 = v106;
                      v108 = CFGetTypeID(v106);
                      if (v108 == CFDictionaryGetTypeID())
                      {
                        v109 = CFDictionaryGetValue(v107, CFSTR("Digest"));
                        v110 = CFCopyDescription(v109);
                        if (v110)
                        {
                          v118 = v110;
                          CFStringGetCString(v110, logString, 4096, 0);
                          sub_1000AAFF4("%s [input]: SEP Digest from ReceiptManifest - %s \n", v119, v120, v121, v122, v123, v124, v125, (char)"SavageUpdaterCreateRequest");
                          CFRelease(v118);
                        }
                        else
                        {
                          sub_1000AAFF4("%s [input]: SEP Digest from ReceiptManifest - %s \n", v111, v112, v113, v114, v115, v116, v117, (char)"SavageUpdaterCreateRequest");
                        }
                      }
                    }
                    if (!v40)
                    {
LABEL_47:
                      v65 = CFSTR("SavageErrorDomain");
                      v66 = "SavageUpdaterCreateRequest: ReceiptManifest is missing in input options";
                      v129 = 6;
                      v130 = (uint64_t)a1;
LABEL_48:
                      CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v66, v129, v130, v65);
                      v40 = 0;
                      goto LABEL_49;
                    }
                    if (CFDictionaryContainsKey((CFDictionaryRef)v23, CFSTR("YonkersDeviceInfo")))
                    {
                      v126 = CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("YonkersDeviceInfo"));
                      v70 = (const __CFDictionary *)SavageSafeRetain(v126);
                      YonkersRequestDictForTATSU = CreateYonkersRequestDictForTATSU(v70, (const __CFDictionary *)v5, (CFDictionaryRef)v272, (uint64_t)v40, (CFTypeRef *)&allocator);
                      if (YonkersRequestDictForTATSU || !allocator)
                      {
                        CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: CreateYonkersRequestDictForTATSU fails.", YonkersRequestDictForTATSU, (uint64_t)a1, CFSTR("YonkersErrorDomain"));
                        goto LABEL_50;
                      }
                      if (v70 && CFDictionaryGetCount((CFDictionaryRef)v23) == 1)
                      {
                        v128 = allocator;
                        goto LABEL_204;
                      }
                      v267 = a2;
                    }
                    else
                    {
                      v267 = a2;
                      v70 = 0;
                    }
                    v147 = (const __CFDictionary *)cf;
                    *(_DWORD *)buffer = 0;
                    v274 = 0;
                    key = 0;
                    Mutable = CFDataCreateMutable(0, 0);
                    v149 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                    if (!v147)
                    {
                      v150 = 0;
                      v190 = 2;
                      goto LABEL_196;
                    }
                    if (allocator)
                    {
                      v150 = (__CFDictionary *)SavageSafeRetain(allocator);
                    }
                    else
                    {
                      v150 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      if (!v150)
                      {
                        v190 = 3;
                        goto LABEL_196;
                      }
                    }
                    v151 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("Savage,ChipID"));
                    if (!v151)
                    {
                      v190 = 17;
                      goto LABEL_196;
                    }
                    v152 = v151;
                    theDict = v149;
                    v153 = CFGetTypeID(v151);
                    if (v153 != CFStringGetTypeID())
                    {
LABEL_222:
                      v190 = 17;
                      goto LABEL_195;
                    }
                    if (!SavageCFStringToUInt32(v152, buffer, 0))
                      goto LABEL_223;
                    SavageCFDictionarySetInteger32(v150, CFSTR("Savage,ChipID"), *(int *)buffer);
                    v154 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v5, CFSTR("Savage,PatchEpoch"));
                    if (!v154)
                      goto LABEL_222;
                    v155 = v154;
                    v156 = CFGetTypeID(v154);
                    if (v156 != CFStringGetTypeID())
                      goto LABEL_222;
                    if (!SavageCFStringToUInt32(v155, buffer, 0))
                    {
LABEL_223:
                      v190 = 11;
                      goto LABEL_195;
                    }
                    SavageCFDictionarySetInteger32(v150, CFSTR("Savage,PatchEpoch"), *(int *)buffer);
                    v157 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,ChipID"));
                    if (v157 && (v158 = v157, v159 = CFGetTypeID(v157), v159 == CFDataGetTypeID()))
                    {
                      v277.location = 0;
                      v277.length = 4;
                      CFDataGetBytes(v158, v277, buffer);
                      *(_DWORD *)buffer = bswap32(*(unsigned int *)buffer);
                      v160 = kCFBooleanTrue;
                      if (*(_DWORD *)buffer >= 0x5065u)
                      {
                        CFDictionaryAddValue(v150, CFSTR("@Brunor,Ticket"), kCFBooleanTrue);
                        v161 = CFSTR("Brunor,FdrRootCaDigest");
                        v162 = v150;
                        v163 = Mutable;
                        goto LABEL_78;
                      }
                    }
                    else
                    {
                      v160 = kCFBooleanTrue;
                    }
                    v161 = CFSTR("@Savage,Ticket");
                    v162 = v150;
                    v163 = v160;
LABEL_78:
                    CFDictionaryAddValue(v162, v161, v163);
                    v164 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,ProductionMode"));
                    if (v164)
                    {
                      v165 = v164;
                      v269 = Mutable;
                      v166 = CFGetTypeID(v164);
                      if (v166 != CFBooleanGetTypeID())
                        goto LABEL_221;
                      v167 = CFBooleanGetValue(v165) ? v160 : kCFBooleanFalse;
                      CFDictionaryAddValue(v150, CFSTR("Savage,ProductionMode"), v167);
                      v168 = CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,UID"));
                      if (!v168
                        || (v169 = v168, v170 = CFGetTypeID(v168), v170 != CFDataGetTypeID())
                        || (CFDictionaryAddValue(v150, CFSTR("Savage,UID"), v169),
                            (v171 = CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,Nonce"))) == 0)
                        || (v172 = v171, v173 = CFGetTypeID(v171), v173 != CFDataGetTypeID()))
                      {
LABEL_221:
                        v190 = 17;
LABEL_194:
                        Mutable = v269;
LABEL_195:
                        v149 = theDict;
                        goto LABEL_196;
                      }
                      v268 = v70;
                      CFDictionaryAddValue(v150, CFSTR("Savage,Nonce"), v172);
                      RelevantMeasurementTags = GetRelevantMeasurementTags((CFDictionaryRef)v23, (__CFString **)&key, &v274);
                      v175 = RelevantMeasurementTags;
                      if (key && v274)
                      {
                        v176 = CFDictionaryGetValue(v147, CFSTR("MeasurementDictPatch"));
                        if (v176)
                        {
                          v177 = v176;
                          v178 = CFGetTypeID(v176);
                          if (v178 == CFDictionaryGetTypeID())
                          {
                            CFDictionaryAddValue(v150, key, v177);
                            v179 = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)v40, CFSTR("SEP"));
                            if (v179)
                            {
                              v180 = v179;
                              v181 = CFGetTypeID(v179);
                              if (v181 == CFDictionaryGetTypeID())
                              {
                                v182 = CFDictionaryGetValue(v180, CFSTR("Digest"));
                                if (v182)
                                {
                                  v183 = v182;
                                  v184 = CFGetTypeID(v182);
                                  if (v184 == CFDataGetTypeID())
                                  {
                                    CFDictionarySetValue(theDict, CFSTR("Digest"), v183);
                                    CFDictionaryAddValue(v150, CFSTR("SEP"), theDict);
                                  }
                                }
                              }
                            }
                            v185 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Brunor,HarvestWrap"));
                            if (v185)
                            {
                              v186 = v185;
                              v187 = CFGetTypeID(v185);
                              if (v187 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v186))
                                  v188 = v160;
                                else
                                  v188 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Brunor,HarvestWrap"), v188);
                              }
                            }
                            v189 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Brunor,HarvestUnwrap"));
                            v190 = v175;
                            if (v189)
                            {
                              v191 = v189;
                              v192 = CFGetTypeID(v189);
                              if (v192 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v191))
                                  v193 = v160;
                                else
                                  v193 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Brunor,HarvestUnwrap"), v193);
                              }
                            }
                            v194 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Brunor,Authenticate"));
                            v70 = v268;
                            if (v194)
                            {
                              v195 = v194;
                              v196 = CFGetTypeID(v194);
                              if (v196 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v195))
                                  v197 = v160;
                                else
                                  v197 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Brunor,Authenticate"), v197);
                              }
                            }
                            v198 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,ReadECKey"));
                            if (v198)
                            {
                              v199 = v198;
                              v200 = CFGetTypeID(v198);
                              if (v200 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v199))
                                  v201 = v160;
                                else
                                  v201 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,ReadECKey"), v201);
                              }
                            }
                            v202 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,WriteECKey"));
                            if (v202)
                            {
                              v203 = v202;
                              v204 = CFGetTypeID(v202);
                              if (v204 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v203))
                                  v205 = v160;
                                else
                                  v205 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,WriteECKey"), v205);
                              }
                            }
                            v206 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,WriteUID"));
                            if (v206)
                            {
                              v207 = v206;
                              v208 = CFGetTypeID(v206);
                              if (v208 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v207))
                                  v209 = v160;
                                else
                                  v209 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,WriteUID"), v209);
                              }
                            }
                            v210 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,WriteEpoch"));
                            if (v210)
                            {
                              v211 = v210;
                              v212 = CFGetTypeID(v210);
                              if (v212 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v211))
                                  v213 = v160;
                                else
                                  v213 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,WriteEpoch"), v213);
                              }
                            }
                            v214 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,ReadGID"));
                            if (v214)
                            {
                              v215 = v214;
                              v216 = CFGetTypeID(v214);
                              if (v216 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v215))
                                  v217 = v160;
                                else
                                  v217 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,ReadGID"), v217);
                              }
                            }
                            v218 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,ReadFWKey"));
                            if (v218)
                            {
                              v219 = v218;
                              v220 = CFGetTypeID(v218);
                              if (v220 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v219))
                                  v221 = v160;
                                else
                                  v221 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,ReadFWKey"), v221);
                              }
                            }
                            v222 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,AllowOfflineBoot"));
                            if (v222)
                            {
                              v223 = v222;
                              v224 = CFGetTypeID(v222);
                              if (v224 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v223))
                                  v225 = v160;
                                else
                                  v225 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,AllowOfflineBoot"), v225);
                              }
                            }
                            v226 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,TempDemote"));
                            if (v226)
                            {
                              v227 = v226;
                              v228 = CFGetTypeID(v226);
                              if (v228 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v227))
                                  v229 = v160;
                                else
                                  v229 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,TempDemote"), v229);
                              }
                            }
                            v230 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,AccessSensor"));
                            if (v230)
                            {
                              v231 = v230;
                              v232 = CFGetTypeID(v230);
                              if (v232 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v231))
                                  v233 = v160;
                                else
                                  v233 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,AccessSensor"), v233);
                              }
                            }
                            v234 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,AccessSecurity"));
                            if (v234)
                            {
                              v235 = v234;
                              v236 = CFGetTypeID(v234);
                              if (v236 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v235))
                                  v237 = v160;
                                else
                                  v237 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,AccessSecurity"), v237);
                              }
                            }
                            v238 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,FADemote"));
                            if (v238)
                            {
                              v239 = v238;
                              v240 = CFGetTypeID(v238);
                              if (v240 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v239))
                                  v241 = v160;
                                else
                                  v241 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,FADemote"), v241);
                              }
                            }
                            v242 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,DebugStatus"));
                            if (v242)
                            {
                              v243 = v242;
                              v244 = CFGetTypeID(v242);
                              if (v244 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v243))
                                  v245 = v160;
                                else
                                  v245 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,DebugStatus"), v245);
                              }
                            }
                            v246 = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)v23, CFSTR("Savage,Provisioning"));
                            if (v246)
                            {
                              v247 = v246;
                              v248 = CFGetTypeID(v246);
                              if (v248 == CFBooleanGetTypeID())
                              {
                                if (CFBooleanGetValue(v247))
                                  v249 = v160;
                                else
                                  v249 = kCFBooleanFalse;
                                CFDictionaryAddValue(v150, CFSTR("Savage,Provisioning"), v249);
                              }
                            }
                            if (!allocator)
                              allocator = (CFAllocatorRef)SavageSafeRetain(v150);
                            goto LABEL_194;
                          }
                        }
                        v190 = 17;
                        Mutable = v269;
                        v149 = theDict;
                      }
                      else
                      {
                        Mutable = v269;
                        v149 = theDict;
                        v190 = RelevantMeasurementTags;
                      }
                      v70 = v268;
LABEL_196:
                      if (Mutable)
                        CFRelease(Mutable);
                      if (v149)
                        CFRelease(v149);
                      if (v150)
                        CFRelease(v150);
                      if (v190 || (v128 = allocator) == 0)
                      {
                        CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: CreateRequestDictForTATSU fails.", v190, (uint64_t)a1, CFSTR("SavageErrorDomain"));
                        a2 = v267;
                        goto LABEL_50;
                      }
LABEL_204:
                      v250 = CFCopyDescription(v128);
                      if (v250)
                      {
                        v258 = v250;
                        CFStringGetCString(v250, logString, 4096, 0);
                        sub_1000AAFF4("%s [output]: %s \n", v259, v260, v261, v262, v263, v264, v265, (char)"SavageUpdaterCreateRequest");
                        CFRelease(v258);
                      }
                      else
                      {
                        sub_1000AAFF4("%s [output]: %s \n", v251, v252, v253, v254, v255, v256, v257, (char)"SavageUpdaterCreateRequest");
                      }
                      goto LABEL_207;
                    }
                    goto LABEL_222;
                  }
                }
                else
                {
                  sub_1000AAFF4("%s [input]: FirmwareData %s \n", v42, v43, v44, v45, v46, v47, v48, (char)"SavageUpdaterCreateRequest");
                  if (v40)
                    goto LABEL_11;
                }
                CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: kSavageOptionFirmwareData is NULL in input options", 2u, (uint64_t)a1, CFSTR("SavageErrorDomain"));
LABEL_49:
                v70 = 0;
                goto LABEL_50;
              }
            }
            else
            {
              sub_1000AAFF4("%s [input]: DeviceInfo %s \n", v25, v26, v27, v28, v29, v30, v31, (char)"SavageUpdaterCreateRequest");
              if (v23)
                goto LABEL_8;
            }
          }
          CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"SavageUpdaterCreateRequest: Cannot get DeviceInfo", 2u, (uint64_t)a1, CFSTR("SavageErrorDomain"));
          v40 = 0;
          v23 = 0;
          goto LABEL_49;
        }
      }
    }
    v67 = "SavageUpdaterCreateRequest: BuildIdentity is NULL in input options";
    v68 = (uint64_t)a1;
  }
  else
  {
    v67 = "SavageUpdaterCreateRequest: options is NULL";
    v68 = 0;
  }
  CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v67, 2u, v68, CFSTR("SavageErrorDomain"));
  v40 = 0;
  v23 = 0;
  v70 = 0;
  v5 = 0;
LABEL_50:
  if (a2 && CFErrorWithDomain)
  {
    *a2 = SavageSafeRetain(CFErrorWithDomain);
    v131 = CFErrorCopyDescription(CFErrorWithDomain);
    if (v131)
    {
      v139 = v131;
      CFStringGetCString(v131, logString, 4096, 0);
      sub_1000AAFF4("%s [error]: %s \n", v140, v141, v142, v143, v144, v145, v146, (char)"SavageUpdaterCreateRequest");
      CFRelease(v139);
    }
    else
    {
      sub_1000AAFF4("%s [error]: %s \n", v132, v133, v134, v135, v136, v137, v138, (char)"SavageUpdaterCreateRequest");
    }
  }
  else if (!CFErrorWithDomain)
  {
    if (!v40)
      goto LABEL_208;
LABEL_207:
    CFRelease(v40);
    goto LABEL_208;
  }
  CFRelease(CFErrorWithDomain);
  if (v40)
    goto LABEL_207;
LABEL_208:
  if (cf)
  {
    CFRelease(cf);
    cf = 0;
  }
  if (v272)
  {
    CFRelease(v272);
    v272 = 0;
  }
  if (v5)
    CFRelease(v5);
  if (v23)
    CFRelease(v23);
  if (v70)
    CFRelease(v70);
  return allocator;
}

const char *sub_1000AAFF4(const char *result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char __str[4096];

  if (off_1001A8250)
  {
    vsnprintf(__str, 0x1000uLL, result, &a9);
    return (const char *)off_1001A8250(qword_1001A8258, __str);
  }
  return result;
}

CFTypeRef sub_1000AB094(const void *a1, const __CFString *a2, CFTypeRef *a3)
{
  const __CFString *v6;
  const __CFString *v7;
  CFIndex Length;
  CFIndex MaximumSizeForEncoding;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  const __CFDictionary *Value;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const __CFDictionary *v26;
  const void *v27;
  const __CFDictionary *v28;
  const __CFDictionary *v29;
  const __CFDictionary *v30;
  CFTypeRef v31;
  CFTypeRef v32;
  CFTypeRef v33;
  const void *v34;
  const __CFDictionary *v35;
  const void *v36;
  const __CFDictionary *v37;
  const void *v38;
  const __CFDictionary *v39;
  const void *v40;
  const void *v41;
  unsigned int v42;
  const void *v43;
  uint64_t v44;
  int Directory;
  int v46;
  const __CFString *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  const __CFString *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  CFErrorRef v63;
  CFErrorRef CFErrorWithDomain;
  const char *CStringPtr;
  const char *v67;
  const char *v68;
  const __CFString *v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  const __CFString *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  char v85;
  CFTypeRef v86;
  CFTypeRef cf;
  CFTypeRef v88;

  cf = 0;
  v88 = 0;
  v86 = 0;
  v85 = 0;
  v6 = CFCopyDescription(a1);
  if (v6)
  {
    v7 = v6;
    Length = CFStringGetLength(v6);
    MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
    v10 = (char *)malloc(MaximumSizeForEncoding + 1);
    CFStringGetCString(v7, v10, MaximumSizeForEncoding, 0x8000100u);
    sub_1000AAFF4("%s [input]: Input Options - %s \n", v11, v12, v13, v14, v15, v16, v17, (char)"CreateFileData");
    CFRelease(v7);
    if (v10)
      free(v10);
  }
  Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("BundleDataDict"));
  if (!Value)
  {
    sub_1000AAFF4("%s: Host side restoreInfo path \n", v19, v20, v21, v22, v23, v24, v25, (char)"CreateFileData");
    v34 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("BuildIdentity"));
    v35 = (const __CFDictionary *)SavageSafeRetain(v34);
    v28 = v35;
    if (v35)
    {
      v36 = CFDictionaryGetValue(v35, a2);
      v37 = (const __CFDictionary *)SavageSafeRetain(v36);
      v30 = v37;
      if (v37)
      {
        v38 = CFDictionaryGetValue(v37, CFSTR("Info"));
        v39 = (const __CFDictionary *)SavageSafeRetain(v38);
        v29 = v39;
        if (v39)
        {
          v40 = CFDictionaryGetValue(v39, CFSTR("Path"));
          v32 = SavageSafeRetain(v40);
          if (v32)
          {
            v41 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("BundlePath"));
            v31 = SavageSafeRetain(v41);
            if (v31)
            {
              v42 = AMSupportPlatformCopyURLWithAppendedComponent(0, v31, v32, 0, &v88);
              if (v42 || !v88)
              {
                v67 = "CreateFileData: Fail to run AMSupportPlatformCopyURLWithAppendedComponent with srcBundleURL";
              }
              else
              {
                v42 = AMSupportCreateDataFromFileURL(0, &cf);
                if (!v42 && cf)
                {
                  v43 = CFDictionaryGetValue((CFDictionaryRef)a1, CFSTR("DestBundlePath"));
                  v33 = SavageSafeRetain(v43);
                  if (!v33)
                    goto LABEL_22;
                  v44 = AMSupportPlatformCopyURLWithAppendedComponent(0, v33, v32, 0, &v86);
                  if ((_DWORD)v44 || !v86)
                  {
                    v68 = "CreateFileData: Fail to run AMSupportPlatformCopyURLWithAppendedComponent with dstBundleURL";
                  }
                  else
                  {
                    Directory = AMSupportMakeDirectory(v86, v44);
                    if (Directory)
                    {
                      LODWORD(v44) = Directory;
                      v68 = "CreateFileData: Fail to run AMSupportMakeDirectory with dstFilePathURL";
                    }
                    else
                    {
                      v46 = AMSupportWriteDataToFileURL(kCFAllocatorDefault, cf, v86, 1);
                      if (v46)
                      {
                        LODWORD(v44) = v46;
                        v68 = "CreateFileData: Fail to run AMSupportWriteDataToFileURL with dstFilePathURL";
                      }
                      else
                      {
                        AMSupportPlatformFileURLExists(v86, &v85);
                        if (v85)
                          goto LABEL_22;
                        v68 = "CreateFileData: AMSupportPlatformFileURLExists returned FALSE";
                        LODWORD(v44) = 5;
                      }
                    }
                  }
                  CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v68, v44, (uint64_t)a1, CFSTR("SavageErrorDomain"));
LABEL_60:
                  if (a3 && CFErrorWithDomain)
                  {
                    *a3 = SavageSafeRetain(CFErrorWithDomain);
                    v69 = CFErrorCopyDescription(CFErrorWithDomain);
                    if (v69)
                    {
                      v77 = v69;
                      CFStringGetCString(v69, logString, 4096, 0);
                      sub_1000AAFF4("%s [error]: %s \n", v78, v79, v80, v81, v82, v83, v84, (char)"CreateFileData");
                      CFRelease(v77);
                    }
                    else
                    {
                      sub_1000AAFF4("%s [error]: %s \n", v70, v71, v72, v73, v74, v75, v76, (char)"CreateFileData");
                    }
                  }
                  else if (!CFErrorWithDomain)
                  {
                    goto LABEL_26;
                  }
                  v63 = CFErrorWithDomain;
                  goto LABEL_24;
                }
                v67 = "CreateFileData: Fail to run AMSupportCreateDataFromFileURL";
              }
            }
            else
            {
              v67 = "CreateFileData: Missing kSavageOptionSourceBundlePath";
              v42 = 10;
            }
            CFErrorWithDomain = createCFErrorWithDomain((uint64_t)v67, v42, (uint64_t)a1, CFSTR("SavageErrorDomain"));
          }
          else
          {
            CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: Missing kSavageBuildIdentityPathKey", 0xCu, (uint64_t)a1, CFSTR("SavageErrorDomain"));
            v31 = 0;
          }
LABEL_54:
          v33 = 0;
          goto LABEL_60;
        }
        CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: Missing kSavageBuildIdentityInfoKey", 0xCu, (uint64_t)a1, CFSTR("SavageErrorDomain"));
      }
      else
      {
        CStringPtr = CFStringGetCStringPtr(a2, 0x600u);
        CFErrorWithDomain = createCFErrorWithDomain((uint64_t)CStringPtr, 0xAu, (uint64_t)a1, CFSTR("SavageErrorDomain"));
        v29 = 0;
      }
LABEL_48:
      v31 = 0;
      v32 = 0;
      goto LABEL_54;
    }
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: Missing kSavageOptionBuildIdentity", 0xAu, (uint64_t)a1, CFSTR("SavageErrorDomain"));
LABEL_45:
    v29 = 0;
    v30 = 0;
    goto LABEL_48;
  }
  v26 = Value;
  sub_1000AAFF4("%s: Device side restoreInfo path \n", v19, v20, v21, v22, v23, v24, v25, (char)"CreateFileData");
  v27 = CFDictionaryGetValue(v26, a2);
  cf = SavageSafeRetain(v27);
  if (!cf)
  {
    CFErrorWithDomain = createCFErrorWithDomain((uint64_t)"CreateFileData: bundleDataDict missing expected tag", 0x13u, (uint64_t)a1, CFSTR("SavageErrorDomain"));
    v28 = 0;
    goto LABEL_45;
  }
  v28 = 0;
  v29 = 0;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v33 = 0;
LABEL_22:
  v47 = CFCopyDescription(cf);
  if (v47)
  {
    v55 = v47;
    CFStringGetCString(v47, logString, 4096, 0);
    sub_1000AAFF4("%s [output]: %s \n", v56, v57, v58, v59, v60, v61, v62, (char)"CreateFileData");
    v63 = (CFErrorRef)v55;
LABEL_24:
    CFRelease(v63);
    goto LABEL_26;
  }
  sub_1000AAFF4("%s [output]: %s \n", v48, v49, v50, v51, v52, v53, v54, (char)"CreateFileData");
LABEL_26:
  if (v86)
  {
    CFRelease(v86);
    v86 = 0;
  }
  if (v33)
    CFRelease(v33);
  if (v88)
  {
    CFRelease(v88);
    v88 = 0;
  }
  if (v31)
    CFRelease(v31);
  if (v32)
    CFRelease(v32);
  if (v29)
    CFRelease(v29);
  if (v30)
    CFRelease(v30);
  if (v28)
    CFRelease(v28);
  return cf;
}

uint64_t sub_1000AB624(const __CFData *a1, CFTypeRef *a2)
{
  __CFDictionary *Mutable;
  __CFDictionary *v5;
  UInt8 *v6;
  BOOL v7;
  uint64_t v8;
  CC_LONG v9;
  CFDataRef v10;
  CFDataRef v11;
  UInt8 buffer[8];
  uint64_t v14;
  CC_SHA256_CTX c;
  unsigned __int8 md[16];
  __int128 v17;
  CFRange v18;
  CFRange v19;

  *(_QWORD *)buffer = 0;
  v14 = 0;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_OWORD *)md = 0u;
  v17 = 0u;
  v5 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v6 = 0;
  if (v5)
    v7 = Mutable == 0;
  else
    v7 = 1;
  if (!v7)
  {
    v8 = 2;
    if (a1 && a2)
    {
      v18.location = 0;
      v18.length = 16;
      CFDataGetBytes(a1, v18, buffer);
      if (*(_DWORD *)&buffer[4])
      {
        v6 = (UInt8 *)calloc(*(unsigned int *)&buffer[4], 1uLL);
        if (v6)
        {
          v19.length = *(unsigned int *)&buffer[4];
          v19.location = 16;
          CFDataGetBytes(a1, v19, v6);
          v9 = *(_DWORD *)&buffer[4];
          if (!(*(_DWORD *)&buffer[4] >> 20))
          {
            CC_SHA256_Init(&c);
            CC_SHA256_Update(&c, v6, v9);
            CC_SHA256_Final(md, &c);
          }
          v10 = CFDataCreate(kCFAllocatorDefault, md, 32);
          if (v10)
          {
            v11 = v10;
            CFDictionarySetValue(Mutable, CFSTR("Digest"), v10);
            CFDictionarySetValue(v5, CFSTR("MeasurementDictPatch"), Mutable);
            *a2 = SavageSafeRetain(v5);
            CFRelease(v11);
            v8 = 0;
          }
          else
          {
            v8 = 8;
          }
        }
        else
        {
          v8 = 3;
        }
      }
      else
      {
        v6 = 0;
        v8 = 4;
      }
    }
    goto LABEL_13;
  }
  v8 = 3;
  if (Mutable)
LABEL_13:
    CFRelease(Mutable);
  if (v5)
    CFRelease(v5);
  if (v6)
    free(v6);
  return v8;
}

CFTypeRef SavageSafeRetain(CFTypeRef cf)
{
  if (cf)
    return CFRetain(cf);
  return cf;
}

void SavageCFDictionarySetInteger32(__CFDictionary *a1, const void *a2, int a3)
{
  CFNumberRef v5;
  CFNumberRef v6;
  int valuePtr;

  valuePtr = a3;
  v5 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
  if (!v5)
    sub_1000ABE88();
  v6 = v5;
  CFDictionarySetValue(a1, a2, v5);
  CFRelease(v6);
}

uint64_t SavageCFStringToUInt32(const __CFString *a1, _DWORD *a2, int a3)
{
  uint64_t result;
  char buffer[32];

  result = CFStringGetCString(a1, buffer, 32, 0x600u);
  if ((_DWORD)result)
  {
    *__error() = 0;
    *a2 = strtol(buffer, 0, a3);
    return *__error() == 0;
  }
  return result;
}

CFErrorRef createCFErrorWithDomain(uint64_t a1, unsigned int a2, uint64_t a3, const __CFString *a4)
{
  CFStringRef v7;
  const void *v8;
  CFStringRef v9;
  CFStringRef v10;
  __CFDictionary *Mutable;
  CFErrorRef v12;

  v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@: %s"), a4, a1);
  if (!v7)
    return 0;
  v8 = v7;
  v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("%@: Input Options: %@"), v7, a3);
  if (!v9)
  {
    v12 = 0;
    goto LABEL_4;
  }
  v10 = v9;
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(Mutable, kCFErrorLocalizedDescriptionKey, v8);
  v12 = CFErrorCreate(kCFAllocatorDefault, a4, a2, Mutable);
  CFRelease(v10);
  CFRelease(v8);
  v8 = Mutable;
  if (Mutable)
LABEL_4:
    CFRelease(v8);
  return v12;
}

uint64_t GetRelevantMeasurementTags(CFDictionaryRef theDict, __CFString **a2, __CFString **a3)
{
  uint64_t result;
  const __CFBoolean *Value;
  const __CFBoolean *v8;
  CFTypeID v9;
  int v10;
  const __CFData *v11;
  const __CFData *v12;
  CFTypeID v13;
  const UInt8 *BytePtr;
  unsigned int v15;
  int v16;
  __CFString **v17;
  __CFString **v18;
  __CFString **v19;
  __CFString **v20;
  __CFString **v21;
  BOOL v22;
  __CFString **v23;
  __CFString **v24;
  __CFString *v25;

  result = 2;
  if (theDict && a2 && a3)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("Savage,ProductionMode"));
    if (!Value)
      return 17;
    v8 = Value;
    v9 = CFGetTypeID(Value);
    if (v9 != CFBooleanGetTypeID())
      return 17;
    v10 = CFBooleanGetValue(v8);
    v11 = (const __CFData *)CFDictionaryGetValue(theDict, CFSTR("Savage,Revision"));
    if (!v11)
      return 17;
    v12 = v11;
    v13 = CFGetTypeID(v11);
    if (v13 != CFDataGetTypeID())
      return 17;
    BytePtr = CFDataGetBytePtr(v12);
    if (BytePtr)
    {
      v15 = *BytePtr;
      v16 = ((v15 & 0xF0) + 96) >> 4;
      if ((v16 - 8) < 2)
      {
        v19 = &kSavageTagMeasurementB2ProdPatch;
        v20 = &kSavageTagMeasurementB2DevPatch;
LABEL_23:
        v22 = v10 == 0;
        if (!v10)
          v19 = v20;
        *a2 = *v19;
        v23 = &kSavageTagMeasurementBFProdPatch;
        v24 = &kSavageTagMeasurementBFDevPatch;
LABEL_26:
        if (v22)
          v23 = v24;
        v25 = *v23;
        goto LABEL_29;
      }
      if (!(((v15 & 0xF0) + 96) >> 4))
      {
        v21 = &kSavageTagMeasurementBAProdPatch;
        v22 = v10 == 0;
        if (!v10)
          v21 = &kSavageTagMeasurementBADevPatch;
        *a2 = *v21;
        v23 = &kSavageTagMeasurementBEProdPatch;
        v24 = &kSavageTagMeasurementBEDevPatch;
        goto LABEL_26;
      }
      if (v16 == 4)
      {
        v17 = &kSavageTagMeasurementBEProdPatch;
        v18 = &kSavageTagMeasurementBEDevPatch;
LABEL_19:
        if (!v10)
          v17 = v18;
        v25 = *v17;
        *a2 = v25;
LABEL_29:
        result = 0;
        *a3 = v25;
        return result;
      }
      if (v15 >= 0xF0)
      {
        v17 = &kSavageTagMeasurementBFProdPatch;
        v18 = &kSavageTagMeasurementBFDevPatch;
        goto LABEL_19;
      }
    }
    v19 = &kSavageTagMeasurementB0ProdPatch;
    v20 = &kSavageTagMeasurementB0DevPatch;
    goto LABEL_23;
  }
  return result;
}

uint64_t GetYonkersMeasurementTags(CFDictionaryRef theDict, CFTypeRef *a2, CFTypeRef *a3)
{
  uint64_t result;
  const __CFBoolean *Value;
  const __CFBoolean *v8;
  CFTypeID v9;
  _BOOL4 v10;
  const __CFNumber *v11;
  const __CFNumber *v12;
  CFTypeID v13;
  int valuePtr;

  valuePtr = 0;
  result = 2;
  if (theDict && a2)
  {
    Value = (const __CFBoolean *)CFDictionaryGetValue(theDict, CFSTR("Yonkers,ProductionMode"));
    if (Value
      && (v8 = Value, v9 = CFGetTypeID(Value), v9 == CFBooleanGetTypeID())
      && (v10 = CFBooleanGetValue(v8) != 0,
          (v11 = (const __CFNumber *)CFDictionaryGetValue(theDict, CFSTR("Yonkers,FabRevision"))) != 0)
      && (v12 = v11, v13 = CFGetTypeID(v11), v13 == CFNumberGetTypeID()))
    {
      CFNumberGetValue(v12, kCFNumberSInt32Type, &valuePtr);
      return GetYonkersFabRevisionTags(valuePtr, v10, a2, a3);
    }
    else
    {
      return 17;
    }
  }
  return result;
}

uint64_t GetYonkersFabRevisionTags(int a1, int a2, CFTypeRef *a3, CFTypeRef *a4)
{
  int v8;
  uint64_t v9;
  CFStringRef v10;
  CFStringRef v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  int *v16;
  int v17;
  _BOOL8 v18;
  int v19;
  uint64_t v20;

  v8 = 0;
  v9 = 0;
  while (dword_100167188[v9] != a1)
  {
    ++v9;
    v8 -= 2;
    if (v9 == 6)
    {
      v10 = 0;
      v11 = 0;
      v12 = 2;
      goto LABEL_6;
    }
  }
  v13 = a2 != 0;
  v14 = v13 | (8 * (v9 < 4));
  v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Yonkers,SysTopPatch%X"), (v13 - v8));
  v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Yonkers,SysTopPatch%X"), v14);
  v12 = 0;
LABEL_6:
  v15 = 0;
  v16 = &dword_1001671A0;
  while (1)
  {
    v17 = *v16++;
    if (v17 == a1)
      break;
    v15 -= 2;
    if (v15 == -16)
    {
      if (!a3)
        goto LABEL_17;
      goto LABEL_15;
    }
  }
  v18 = a2 != 0;
  if ((v18 - v15) < 8)
    v19 = 8;
  else
    v19 = -8;
  v20 = (v19 | v18) - v15;
  v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Yonkers,SysTopPatch%X"), v18 - v15);
  v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, CFSTR("Yonkers,SysTopPatch%X"), v20);
  v12 = 0;
  if (!a3)
    goto LABEL_17;
LABEL_15:
  if (v10)
    *a3 = CFRetain(v10);
LABEL_17:
  if (a4 && v11)
    *a4 = CFRetain(v11);
  if (v10)
    CFRelease(v10);
  if (v11)
    CFRelease(v11);
  return v12;
}

void sub_1000ABE88()
{
  __assert_rtn("SavageCFDictionarySetInteger32", "SavagePrivateHelper.cpp", 35, "num != NULL");
}

uint64_t uarpSuperBinaryHeaderEndianSwap(unsigned int *a1, _DWORD *a2)
{
  uint64_t result;

  *a2 = uarpHtonl(*a1);
  a2[1] = uarpHtonl(a1[1]);
  a2[2] = uarpHtonl(a1[2]);
  a2[3] = uarpHtonl(a1[3]);
  a2[4] = uarpHtonl(a1[4]);
  a2[5] = uarpHtonl(a1[5]);
  a2[6] = uarpHtonl(a1[6]);
  a2[7] = uarpHtonl(a1[7]);
  a2[8] = uarpHtonl(a1[8]);
  a2[9] = uarpHtonl(a1[9]);
  result = uarpHtonl(a1[10]);
  a2[10] = result;
  return result;
}

uint64_t uarpPayloadHeaderEndianSwap(unsigned int *a1, _DWORD *a2)
{
  uint64_t result;

  *a2 = uarpHtonl(*a1);
  a2[2] = uarpHtonl(a1[2]);
  a2[3] = uarpHtonl(a1[3]);
  a2[4] = uarpHtonl(a1[4]);
  a2[5] = uarpHtonl(a1[5]);
  a2[6] = uarpHtonl(a1[6]);
  a2[7] = uarpHtonl(a1[7]);
  a2[8] = uarpHtonl(a1[8]);
  result = uarpHtonl(a1[9]);
  a2[9] = result;
  return result;
}

uint64_t uarpPayloadTagPack(unsigned int *a1)
{
  return *a1;
}

unint64_t uarpHtonll(unint64_t a1)
{
  return bswap64(a1);
}

unint64_t uarpNtohll(unint64_t a1)
{
  return bswap64(a1);
}

uint64_t uarpHtonl(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t uarpNtohl(unsigned int a1)
{
  return bswap32(a1);
}

uint64_t uarpHtons(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t uarpNtohs(unsigned int a1)
{
  return __rev16(a1);
}

uint64_t SoCUpdaterExecCommandDynamic(void *a1, void (*a2)(uint64_t, id), uint64_t a3, uint64_t a4, const __CFDictionary *a5, CFErrorRef *a6)
{
  id v11;
  id v12;
  const __CFDictionary *Value;
  const void *v14;
  const void *v15;
  id v16;
  void *v17;
  id v18;
  void *v19;
  uint64_t (*v20)(const void *, uint64_t, const __CFDictionary *, uint64_t *, CFErrorRef *);
  uint64_t (*v21)(const void *, uint64_t, const __CFDictionary *, uint64_t *, CFErrorRef *);
  unsigned int v22;
  id v23;
  uint64_t v24;
  CFIndex v25;
  uint64_t v27;

  v11 = a1;
  v27 = 0;
  v12 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s: Dylib Path: %@\n"), "CFDictionaryRef  _Nullable SoCUpdaterExecCommandDynamic(NSString *__strong _Nullable, SoCUpdaterLogSinkFunction _Nonnull, void * _Nonnull, CFStringRef _Nonnull, CFDictionaryRef _Nonnull, CFErrorRef * _Nullable)", v11)));
  a2(a3, objc_msgSend(v12, "UTF8String"));

  Value = (const __CFDictionary *)CFDictionaryGetValue(a5, CFSTR("DeviceInfo"));
  v14 = CFDictionaryGetValue(Value, CFSTR("UpdaterRef"));
  if (!v14)
    goto LABEL_14;
  v15 = v14;
  v16 = v11;
  v17 = v16;
  if (!v16)
  {
    if (!a6)
      goto LABEL_13;
    v25 = 5;
LABEL_12:
    *a6 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, v25, 0);
    goto LABEL_13;
  }
  v18 = objc_retainAutorelease(v16);
  v19 = dlopen((const char *)objc_msgSend(v18, "UTF8String"), 1);
  if (!v19)
  {
    if (!a6)
      goto LABEL_13;
    v25 = 9;
    goto LABEL_12;
  }
  v20 = (uint64_t (*)(const void *, uint64_t, const __CFDictionary *, uint64_t *, CFErrorRef *))dlsym(v19, "UARPSoCUpdaterExecCommand");
  if (!v20)
  {
    if (a6)
    {
      v25 = 14;
      goto LABEL_12;
    }
LABEL_13:

LABEL_14:
    v24 = 0;
    goto LABEL_15;
  }
  v21 = v20;

  v22 = v21(v15, a4, a5, &v27, a6);
  v23 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("result:%d output:%@ updater:%@"), v22, v27, v15)));
  a2(a3, objc_msgSend(v23, "UTF8String"));

  v24 = v27;
LABEL_15:

  return v24;
}

CFTypeRef Ace3RestoreInfoGetTags(const __CFDictionary *a1, void (*a2)(uint64_t, id), uint64_t a3, CFErrorRef *a4)
{
  CFTypeRef result;

  result = (CFTypeRef)SoCUpdaterExecCommandDynamic(CFSTR("/usr/lib/updaters/libAce3Updater.dylib"), a2, a3, (uint64_t)CFSTR("queryTags"), a1, a4);
  if (result)
    return CFRetain(result);
  return result;
}

void *Ace3RestoreInfoCopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  Ace3RestoreInfoFirmwareCopierBackDeploy *v5;
  unsigned __int8 v6;
  id v7;
  void *v8;
  void *v9;
  id v10;
  void *v11;
  id v12;
  id v14;
  id v15;

  v5 = -[Ace3SoCRestoreInfoFirmwareCopierBackDeploy initWithOptions:logFunction:logContext:]([Ace3RestoreInfoFirmwareCopierBackDeploy alloc], "initWithOptions:logFunction:logContext:", a1, a2, a3);
  v15 = 0;
  v6 = -[Ace3SoCRestoreInfoFirmwareCopierBackDeploy copyFirmwareToDestinationBundleWithError:](v5, "copyFirmwareToDestinationBundleWithError:", &v15);
  v7 = v15;
  v8 = v7;
  if ((v6 & 1) != 0)
  {
    v14 = 0;
    v9 = (void *)objc_claimAutoreleasedReturnValue(-[Ace3SoCRestoreInfoFirmwareCopierBackDeploy readFirmwareFileDataWithError:](v5, "readFirmwareFileDataWithError:", &v14));
    v10 = v14;
    v11 = v10;
    if (v9)
    {
      v12 = v9;
    }
    else if (a4)
    {
      *a4 = v10;
    }

  }
  else
  {
    v9 = 0;
    if (a4)
      *a4 = v7;
  }

  return v9;
}

CFTypeRef Ace3RestoreInfoCreateRequest(const __CFDictionary *a1, void (*a2)(uint64_t, id), uint64_t a3, CFErrorRef *a4)
{
  void *v6;
  unsigned int v7;
  unsigned int v8;
  id v9;
  uint64_t v10;
  id v11;
  void *v12;
  void *v13;
  id v14;
  __CFData *v15;
  id v16;
  BOOL v18;

  v6 = (void *)SoCUpdaterExecCommandDynamic(CFSTR("/usr/lib/updaters/libAce3Updater.dylib"), a2, a3, (uint64_t)CFSTR("generateMeasurements"), a1, a4);
  if (v6)
  {
    v18 = 0;
    v7 = queryNumUpdatableUSBCPortControllers(&v18, (uint64_t (*)(_QWORD, _QWORD))a2, a3);
    if (v18)
    {
      return CFRetain(v6);
    }
    else
    {
      v8 = v7;
      v9 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Number of updatable USBPortControllers = %u\n"), v7)));
      a2(a3, objc_msgSend(v9, "UTF8String"));

      v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableDictionary dictionaryWithDictionary:](NSMutableDictionary, "dictionaryWithDictionary:", v6));
      if (v8)
      {
        LODWORD(v10) = 0;
        do
        {
          v10 = (v10 + 1);
          v11 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("Checking LUN%d\n"), v10)));
          a2(a3, objc_msgSend(v11, "UTF8String"));

          v12 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("%s%d,%s"), "USBPortController", v10, "Nonce"));
          v13 = (void *)objc_claimAutoreleasedReturnValue(objc_msgSend(v6, "objectForKeyedSubscript:", v12));
          if (v13)
          {
            v14 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("old nonce %@\n"), v13)));
            a2(a3, objc_msgSend(v14, "UTF8String"));

            v15 = (__CFData *)objc_claimAutoreleasedReturnValue(+[NSMutableData dataWithData:](NSMutableData, "dataWithData:", v13));
            verifyUSBCPortControllerNonceHash(v15, v10, (uint64_t (*)(_QWORD, _QWORD))a2, a3);
            v16 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue(+[NSString stringWithFormat:](NSString, "stringWithFormat:", CFSTR("new nonce %@\n"), v15)));
            a2(a3, objc_msgSend(v16, "UTF8String"));

            objc_msgSend(v6, "setObject:forKeyedSubscript:", v15, v12);
          }

        }
        while (v8 != (_DWORD)v10);
      }
    }
  }
  return v6;
}

BOOL sub_1000ACDB8(NSError *self, SEL a2)
{
  void *v3;
  BOOL v4;

  v3 = (void *)objc_claimAutoreleasedReturnValue(-[NSError domain](self, "domain"));
  if (objc_msgSend(v3, "isEqualToString:", NSPOSIXErrorDomain))
    v4 = (id)-[NSError code](self, "code") == (id)17;
  else
    v4 = 0;

  return v4;
}

uint64_t AppleTconUARPRestoreInfoGetTags(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4)
    *a4 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, 102, 0);
  return 0;
}

uint64_t AppleTconUARPRestoreInfoCopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4)
    *a4 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, 102, 0);
  return 0;
}

uint64_t AppleTconUARPRestoreInfoCreateRequest(uint64_t a1, uint64_t a2, uint64_t a3, CFErrorRef *a4)
{
  if (a4)
    *a4 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainPOSIX, 102, 0);
  return 0;
}

id UARPPersonalizationTSSRequestWithSigningServer(void *a1, void *a2)
{
  id v3;
  id v4;
  NSObject *v5;
  id v6;
  NSObject *v7;
  _BOOL4 v8;
  id v9;

  v3 = a1;
  v4 = a2;
  v5 = sub_1000AD278();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    sub_1000AD894();

  v6 = sub_1000AD2B8(v3, v4, 0);
  v7 = sub_1000AD278();
  v8 = os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  if (v6)
  {
    if (v8)
      sub_1000AD868();

    v9 = v6;
  }
  else
  {
    if (v8)
      sub_1000AD83C();

  }
  return v6;
}

id sub_1000AD278()
{
  if (qword_1001A8260 != -1)
    dispatch_once(&qword_1001A8260, &stru_1001825C0);
  return (id)qword_1001A8268;
}

id sub_1000AD2B8(void *a1, void *a2, int a3)
{
  const __CFDictionary *v5;
  id v6;
  NSObject *v7;
  uint64_t v8;
  const void *v9;
  int v10;
  NSObject *v11;
  NSObject *v12;
  NSObject *v13;
  void *v14;
  const __CFString *v15;
  NSObject *v16;
  int v17;
  NSObject *v18;
  const __CFString *v19;
  NSObject *v20;
  NSObject *v21;
  CFTypeRef v23;
  uint8_t buf[4];
  CFTypeRef v25;
  __int16 v26;
  const __CFString *v27;

  v5 = a1;
  v6 = a2;
  v7 = sub_1000AD278();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "UARP: TSS request to signing server %{public}@", buf, 0xCu);
  }

  AMAuthInstallLogSetHandler((void (*)(int, uint64_t))sub_1000AD744);
  v8 = AMAuthInstallCreate(kCFAllocatorDefault);
  if (!v8)
  {
    v13 = sub_1000AD278();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      sub_1000AD8F8();

    goto LABEL_11;
  }
  v9 = (const void *)v8;
  v10 = AMAuthInstallSetSigningServerURL(v8, v6);
  v11 = sub_1000AD278();
  v12 = v11;
  if (v10)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      sub_1000AD994();

    CFRelease(v9);
LABEL_11:
    v14 = 0;
    goto LABEL_32;
  }
  if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
  {
    if (a3)
      v15 = CFSTR(" <AppleConnect>");
    else
      v15 = CFSTR(" ");
    *(_DWORD *)buf = 138543618;
    v25 = v6;
    v26 = 2114;
    v27 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_INFO, "UARP: TSS Request %{public}@%{public}@ is ", buf, 0x16u);
  }

  v16 = sub_1000AD278();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    v25 = v6;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_INFO, "UARP: %{public}@", buf, 0xCu);
  }

  v23 = 0;
  v17 = AMAuthInstallApCreatePersonalizedResponse((uint64_t)v9, v5, &v23);
  v18 = sub_1000AD278();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_INFO))
  {
    if (a3)
      v19 = CFSTR(" <AppleConnect>");
    else
      v19 = CFSTR(" ");
    *(_DWORD *)buf = 138543618;
    v25 = v6;
    v26 = 2114;
    v27 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_INFO, "UARP: TSS Response %{public}@%{public}@ is ", buf, 0x16u);
  }

  v20 = sub_1000AD278();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 138543362;
    v25 = v23;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_INFO, "UARP: %{public}@", buf, 0xCu);
  }

  if (v17)
  {
    v21 = sub_1000AD278();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      sub_1000AD924(v17, v21);

    v14 = 0;
  }
  else
  {
    v14 = (void *)v23;
  }
  CFRelease(v9);
LABEL_32:

  return v14;
}

id UARPPersonalizationTSSRequestWithSigningServerSSO(void *a1, void *a2)
{
  id v3;
  id v4;
  NSObject *v5;
  id v6;
  NSObject *v7;

  v3 = a1;
  v4 = a2;
  v5 = sub_1000AD278();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    sub_1000AD9EC();

  v6 = sub_1000AD2B8(v3, v4, 1);
  if (!v6)
  {
    v7 = sub_1000AD278();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
      sub_1000AD9C0();

  }
  return v6;
}

void sub_1000AD710(id a1)
{
  os_log_t v1;
  void *v2;

  v1 = os_log_create("com.apple.accessoryupdater.uarp", "personalization");
  v2 = (void *)qword_1001A8268;
  qword_1001A8268 = (uint64_t)v1;

}

void sub_1000AD744(uint64_t a1, uint64_t a2)
{
  NSObject *v3;
  int v4;
  uint64_t v5;

  v3 = sub_1000AD278();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
  {
    v4 = 136446210;
    v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "UARP: Personalization Message >> %{public}s", (uint8_t *)&v4, 0xCu);
  }

}

void sub_1000AD7EC(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 2u);
}

void sub_1000AD804(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x16u);
}

void sub_1000AD83C()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000AD830();
  sub_1000AD7EC((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request failed customer path / auth listed", v2, v3, v4, v5, v6);
  sub_1000AD7FC();
}

void sub_1000AD868()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000AD830();
  sub_1000AD7EC((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request passed customer path / auth listed", v2, v3, v4, v5, v6);
  sub_1000AD7FC();
}

void sub_1000AD894()
{
  uint64_t v0;
  os_log_t v1;

  sub_1000AD818();
  sub_1000AD804((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request to server %{public}@ with options %{public}@");
}

void sub_1000AD8F8()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000AD830();
  sub_1000AD7EC((void *)&_mh_execute_header, v0, v1, "UARP: Failed to create authinstall reference", v2, v3, v4, v5, v6);
  sub_1000AD7FC();
}

void sub_1000AD924(int a1, NSObject *a2)
{
  _DWORD v2[2];

  v2[0] = 67109120;
  v2[1] = a1;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "UARP: Failed personalization response, error = %u", (uint8_t *)v2, 8u);
  sub_1000AD7FC();
}

void sub_1000AD994()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000AD830();
  sub_1000AD7EC((void *)&_mh_execute_header, v0, v1, "UARP: Failed to set signing server", v2, v3, v4, v5, v6);
  sub_1000AD7FC();
}

void sub_1000AD9C0()
{
  NSObject *v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint8_t v6;

  sub_1000AD830();
  sub_1000AD7EC((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request failed sso modes", v2, v3, v4, v5, v6);
  sub_1000AD7FC();
}

void sub_1000AD9EC()
{
  uint64_t v0;
  os_log_t v1;

  sub_1000AD818();
  sub_1000AD804((void *)&_mh_execute_header, v0, v1, "UARP: TSS Request to server %{public}@ with SSO and options %{public}@");
}

void sub_1000ADAF0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000AE9DC(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000AFC38(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000B3E9C(uint64_t a1)
{
  id WeakRetained;

  WeakRetained = objc_loadWeakRetained((id *)(*(_QWORD *)(a1 + 32) + 8));
  objc_msgSend(WeakRetained, "superbinary:logString:", *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40));

}

id sub_1000B3ED4(uint64_t a1, uint64_t a2)
{
  id v3;

  v3 = *(id *)(a2 + 32);
  return *(id *)(a2 + 40);
}

void sub_1000B3EFC(uint64_t a1)
{

}

void sub_1000B7360(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000B98B0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000BA18C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1000BA4D4(NSFileHandle *self, SEL a2, const void *a3, unint64_t a4)
{
  NSData *v5;

  v5 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", a3, a4);
  LOBYTE(self) = -[NSFileHandle uarpWriteData:error:](self, "uarpWriteData:error:", v5, 0);

  return (char)self;
}

void sub_1000BBD90(void *a1, uint64_t a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  NSObject *v9;

  _os_log_error_impl(a1, v9, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

void sub_1000BBDA4(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, a5, 0xCu);
}

void sub_1000BBDC4(void *a1, uint64_t a2, os_log_t log, const char *a4, ...)
{
  va_list va;

  va_start(va, a4);
  _os_log_error_impl(a1, log, OS_LOG_TYPE_ERROR, a4, (uint8_t *)va, 0x20u);
}

void sub_1000BBDF4()
{
  void *v0;

}

void sub_1000BBE20()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136315650;
  sub_1000BBDD8();
  sub_1000BBDC4((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
  sub_1000BBDBC();
}

void sub_1000BBE8C(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "-[FTABFileBackDeploy parseFileData]";
  sub_1000BBDA4((void *)&_mh_execute_header, a1, a3, "%s: File too short", (uint8_t *)&v3);
  sub_1000A4540();
}

void sub_1000BBF00(unsigned __int8 *a1, NSObject *a2)
{
  int v2;
  int v3;
  int v4;
  int v5;
  int v6;
  const char *v7;
  __int16 v8;
  int v9;
  __int16 v10;
  int v11;
  __int16 v12;
  int v13;
  __int16 v14;
  int v15;

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = a1[3];
  v6 = 136316162;
  v7 = "-[FTABFileBackDeploy parseFileData]";
  v8 = 1024;
  v9 = v2;
  v10 = 1024;
  v11 = v3;
  v12 = 1024;
  v13 = v4;
  v14 = 1024;
  v15 = v5;
  _os_log_error_impl((void *)&_mh_execute_header, a2, OS_LOG_TYPE_ERROR, "%s: File tag parse error (%02x %02x %02x %02x)", (uint8_t *)&v6, 0x24u);
  sub_1000BBDBC();
}

void sub_1000BBFAC()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_1000BBE0C();
  sub_1000BBDFC();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x18u);
  sub_1000A4540();
}

void sub_1000BC028()
{
  os_log_t v0;
  int v1[4];
  __int16 v2;
  uint64_t v3;

  v1[0] = 136315650;
  sub_1000BBE0C();
  v2 = 2048;
  v3 = 16;
  _os_log_error_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%s: Error parsing file offset list (offset=%u, length=%lu)", (uint8_t *)v1, 0x1Cu);
  sub_1000BBDBC();
}

void sub_1000BC0B0(NSObject *a1, uint64_t a2, uint64_t a3)
{
  int v3;
  const char *v4;

  v3 = 136315138;
  v4 = "-[FTABFileBackDeploy parseFileData]";
  sub_1000BBDA4((void *)&_mh_execute_header, a1, a3, "%s: Manifest parameters are invalid", (uint8_t *)&v3);
  sub_1000A4540();
}

void sub_1000BC124()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_1000BBDFC();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x3Cu);
}

void sub_1000BC200()
{
  uint64_t v0;
  os_log_t v1;
  int v2;

  v2 = 136315650;
  sub_1000BBDD8();
  sub_1000BBDC4((void *)&_mh_execute_header, v0, v1, "%s: Unable to open file at %@ (%@)", v2);
  sub_1000BBDBC();
}

void sub_1000BC26C()
{
  void *v0;
  os_log_t v1;
  os_log_type_t v2;
  const char *v3;
  uint8_t *v4;

  sub_1000A4548();
  sub_1000BBDFC();
  _os_log_error_impl(v0, v1, v2, v3, v4, 0x16u);
  sub_1000A4540();
}

void sub_1000BC2E0(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = objc_msgSend(a1, "path");
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Unable to create file at %@", v4, v5, v6, v7, v8);
  sub_1000BBDF4();
  sub_1000BBDB0();
}

void sub_1000BC35C(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = objc_msgSend(a1, "path");
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Unable to delete file at %@", v4, v5, v6, v7, v8);
  sub_1000BBDF4();
  sub_1000BBDB0();
}

void sub_1000BC3D8(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = objc_msgSend(a1, "tag");
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Failed to write '%@'", v4, v5, v6, v7, v8);
  sub_1000BBDF4();
  sub_1000BBDB0();
}

void sub_1000BC454(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000AD7EC((void *)&_mh_execute_header, a1, a3, "Failed to write manifest", a5, a6, a7, a8, 0);
}

void sub_1000BC488(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = objc_msgSend(a1, "tag");
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Failed to write '%@' header", v4, v5, v6, v7, v8);
  sub_1000BBDF4();
  sub_1000BBDB0();
}

void sub_1000BC504(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  sub_1000AD7EC((void *)&_mh_execute_header, a1, a3, "Failed to write FTAB header", a5, a6, a7, a8, 0);
}

void sub_1000BC538(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t v8;

  v1 = objc_msgSend(a1, "absoluteString");
  sub_1000A4548();
  sub_1000BBD90((void *)&_mh_execute_header, v2, v3, "Failed to open file handle for writing to '%@'", v4, v5, v6, v7, v8);
  sub_1000BBDF4();
  sub_1000BBDB0();
}

void sub_1000BC5B4()
{
  NSObject *v0;
  uint64_t v1;
  uint8_t v2[24];

  sub_1000A4548();
  sub_1000BBDA4((void *)&_mh_execute_header, v0, v1, "Unable to locate subfile with tag '%@'", v2);
  sub_1000A4540();
}

void sub_1000BE1E4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000BE6A0(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000BEA50(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000BEE44(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000BF1F4(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

NSDictionary *AppleTypeCRetimerRestoreInfoGetTags(void *a1)
{
  id v1;
  id v2;
  id v3;
  id v4;
  id v5;
  uint64_t v6;
  void *i;
  void *v8;
  id v9;
  id v10;
  NSString *v11;
  NSArray *v12;
  id v13;
  NSArray *v14;
  NSDictionary *v15;
  NSArray *v16;
  id v18;
  id v19;
  id obj;
  id v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  id v26;
  NSArray *v27;
  _QWORD v28[2];
  _QWORD v29[2];
  _QWORD v30[2];
  _QWORD v31[2];
  _BYTE v32[128];

  v1 = objc_msgSend(a1, "objectForKeyedSubscript:", CFSTR("DeviceInfo"));
  v2 = objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("InfoArray"));
  if (v2)
  {
    v19 = v1;
    v3 = +[NSMutableArray array](NSMutableArray, "array");
    v21 = +[NSMutableArray array](NSMutableArray, "array");
    v22 = 0u;
    v23 = 0u;
    v24 = 0u;
    v25 = 0u;
    v18 = v2;
    obj = v2;
    v4 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v22, v32, 16);
    if (v4)
    {
      v5 = v4;
      v6 = *(_QWORD *)v23;
      do
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(_QWORD *)v23 != v6)
            objc_enumerationMutation(obj);
          v8 = *(void **)(*((_QWORD *)&v22 + 1) + 8 * (_QWORD)i);
          v9 = objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("TicketName"));
          v10 = objc_msgSend(v8, "objectForKeyedSubscript:", CFSTR("TagNumber"));
          v11 = +[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", CFSTR("Timer,RTKitOS,%u"), CFSTR("%u"), 0, objc_msgSend(v10, "unsignedCharValue"));
          objc_msgSend(v3, "addObject:", v11);
          objc_msgSend(v21, "addObject:", v9);

        }
        v5 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v22, v32, 16);
      }
      while (v5);
    }

    v30[0] = CFSTR("BuildIdentityTags");
    v12 = +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v3);
    v31[0] = v12;
    v30[1] = CFSTR("ResponseTags");
    v13 = v21;
    v14 = +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v21);
    v31[1] = v14;
    v15 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v31, v30, 2);
    v2 = v18;
    v1 = v19;
  }
  else
  {
    v3 = objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("TicketName"));
    v13 = objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("TagNumber"));
    v12 = +[NSString stringWithValidatedFormat:validFormatSpecifiers:error:](NSString, "stringWithValidatedFormat:validFormatSpecifiers:error:", CFSTR("Timer,RTKitOS,%u"), CFSTR("%u"), 0, objc_msgSend(v13, "unsignedCharValue"));
    v27 = v12;
    v28[0] = CFSTR("BuildIdentityTags");
    v14 = +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v27, 1);
    v29[0] = v14;
    v28[1] = CFSTR("ResponseTags");
    v26 = v3;
    v16 = +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", &v26, 1);
    v29[1] = v16;
    v15 = +[NSDictionary dictionaryWithObjects:forKeys:count:](NSDictionary, "dictionaryWithObjects:forKeys:count:", v29, v28, 2);

  }
  return v15;
}

id AppleTypeCRetimerRestoreInfoCopyFirmware(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  AppleTypeCRetimerFirmwareCopierBackDeploy *v5;
  unsigned __int8 v6;
  id v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  id v12;
  id v14;
  id v15;

  v5 = -[AppleTypeCRetimerFirmwareCopierBackDeploy initWithOptions:logFunction:logContext:]([AppleTypeCRetimerFirmwareCopierBackDeploy alloc], "initWithOptions:logFunction:logContext:", a1, a2, a3);
  v15 = 0;
  v6 = -[AppleTypeCRetimerFirmwareCopierBackDeploy copyFirmwareToDestinationBundleWithError:](v5, "copyFirmwareToDestinationBundleWithError:", &v15);
  v7 = v15;
  v8 = v7;
  if ((v6 & 1) != 0)
  {
    v14 = 0;
    v9 = -[AppleTypeCRetimerFirmwareCopierBackDeploy readFirmwareFileDataWithError:](v5, "readFirmwareFileDataWithError:", &v14);
    v10 = v14;
    v11 = v10;
    if (v9)
    {
      v12 = v9;
    }
    else if (a4)
    {
      *a4 = v10;
    }

  }
  else
  {
    v9 = 0;
    if (a4)
      *a4 = v7;
  }

  return v9;
}

id AppleTypeCRetimerRestoreInfoCreateRequest(void *a1, uint64_t a2, uint64_t a3)
{
  id v5;
  id v6;
  id v7;
  __objc2_class *v8;
  id v9;
  id v10;
  id v11;

  v5 = a1;
  v6 = objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("DeviceInfo"));
  v7 = objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("InfoArray"));

  if (v7)
    v8 = AppleTypeCRetimerFirmwareAggregateRequestCreatorBackDeploy;
  else
    v8 = AppleTypeCRetimerFirmwareRequestCreatorBackDeploy;
  v9 = objc_msgSend([v8 alloc], "initWithOptions:logFunction:logContext:", v5, a2, a3);

  if (v9)
    v10 = objc_msgSend(v9, "requestDictionary");
  else
    v10 = 0;

  if (v10)
    v11 = v10;

  return v10;
}

void sub_1000C06A4(id a1)
{
  NSMutableArray *v1;
  id v2;
  id v3;
  id v4;
  id v5;
  id v6;
  id v7;
  id v8;
  id v9;
  id v10;
  id v11;
  id v12;
  id v13;
  id v14;
  id v15;
  id v16;
  id v17;
  id v18;
  id v19;
  id v20;
  id v21;
  id v22;
  id v23;
  id v24;
  id v25;
  id v26;
  id v27;
  id v28;
  id v29;
  id v30;
  id v31;
  id v32;
  id v33;
  id v34;
  id v35;
  id v36;
  id v37;
  id v38;
  NSArray *v39;
  void *v40;

  v1 = objc_opt_new(NSMutableArray);
  v2 = +[UARPTLVPersonalizationRequiredBackDeploy metaDataTableEntry](UARPTLVPersonalizationRequiredBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v2);

  v3 = +[UARPTLVPersonalizationPayloadTagBackDeploy metaDataTableEntry](UARPTLVPersonalizationPayloadTagBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v3);

  v4 = +[UARPTLVPersonalizationSuperBinaryAssetIDBackDeploy metaDataTableEntry](UARPTLVPersonalizationSuperBinaryAssetIDBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v4);

  v5 = +[UARPTLVPersonalizationManifestPrefixBackDeploy metaDataTableEntry](UARPTLVPersonalizationManifestPrefixBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v5);

  v6 = +[UARPTLVPersonalizationBoardIDBackDeploy metaDataTableEntry](UARPTLVPersonalizationBoardIDBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v6);

  v7 = +[UARPTLVPersonalizationChipIDBackDeploy metaDataTableEntry](UARPTLVPersonalizationChipIDBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v7);

  v8 = +[UARPTLVPersonalizationECIDBackDeploy metaDataTableEntry](UARPTLVPersonalizationECIDBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v8);

  v9 = +[UARPTLVPersonalizationECIDDataBackDeploy metaDataTableEntry](UARPTLVPersonalizationECIDDataBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v9);

  v10 = +[UARPTLVPersonalizationNonceBackDeploy metaDataTableEntry](UARPTLVPersonalizationNonceBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v10);

  v11 = +[UARPTLVPersonalizationNonceHashBackDeploy metaDataTableEntry](UARPTLVPersonalizationNonceHashBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v11);

  v12 = +[UARPTLVPersonalizationSecurityDomainBackDeploy metaDataTableEntry](UARPTLVPersonalizationSecurityDomainBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v12);

  v13 = +[UARPTLVPersonalizationSecurityModeBackDeploy metaDataTableEntry](UARPTLVPersonalizationSecurityModeBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v13);

  v14 = +[UARPTLVPersonalizationProductionModeBackDeploy metaDataTableEntry](UARPTLVPersonalizationProductionModeBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v14);

  v15 = +[UARPTLVPersonalizationChipEpochBackDeploy metaDataTableEntry](UARPTLVPersonalizationChipEpochBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v15);

  v16 = +[UARPTLVPersonalizationEnableMixMatchBackDeploy metaDataTableEntry](UARPTLVPersonalizationEnableMixMatchBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v16);

  v17 = +[UARPTLVPersonalizationSuperBinaryPayloadIndexBackDeploy metaDataTableEntry](UARPTLVPersonalizationSuperBinaryPayloadIndexBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v17);

  v18 = +[UARPTLVPersonalizationChipRevisionBackDeploy metaDataTableEntry](UARPTLVPersonalizationChipRevisionBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v18);

  v19 = +[UARPTLVPersonalizationFTABSubfileTagBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABSubfileTagBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v19);

  v20 = +[UARPTLVPersonalizationFTABSubfileLongnameBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABSubfileLongnameBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v20);

  v21 = +[UARPTLVPersonalizationFTABSubfileDigestBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABSubfileDigestBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v21);

  v22 = +[UARPTLVPersonalizationFTABSubfileHashAlgorithmBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABSubfileHashAlgorithmBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v22);

  v23 = +[UARPTLVPersonalizationFTABSubfileESECBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABSubfileESECBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v23);

  v24 = +[UARPTLVPersonalizationFTABSubfileEPROBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABSubfileEPROBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v24);

  v25 = +[UARPTLVPersonalizationFTABSubfileTrustedBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABSubfileTrustedBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v25);

  v26 = +[UARPTLVPersonalizationSoCLiveNonceBackDeploy metaDataTableEntry](UARPTLVPersonalizationSoCLiveNonceBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v26);

  v27 = +[UARPTLVPersonalizationPrefixNeedsLogicalUnitNumberBackDeploy metaDataTableEntry](UARPTLVPersonalizationPrefixNeedsLogicalUnitNumberBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v27);

  v28 = +[UARPTLVPersonalizationSuffixNeedsLogicalUnitNumberBackDeploy metaDataTableEntry](UARPTLVPersonalizationSuffixNeedsLogicalUnitNumberBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v28);

  v29 = +[UARPTLVPersonalizationLogicalUnitNumberBackDeploy metaDataTableEntry](UARPTLVPersonalizationLogicalUnitNumberBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v29);

  v30 = +[UARPTLVPersonalizationTicketNeedsLogicalUnitNumberBackDeploy metaDataTableEntry](UARPTLVPersonalizationTicketNeedsLogicalUnitNumberBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v30);

  v31 = +[UARPTLVHostPersonalizationRequiredBackDeploy metaDataTableEntry](UARPTLVHostPersonalizationRequiredBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v31);

  v32 = +[UARPTLVRequiredPersonalizationOptionBackDeploy metaDataTableEntry](UARPTLVRequiredPersonalizationOptionBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v32);

  v33 = +[UARPTLVPersonalizationFTABPayloadBackDeploy metaDataTableEntry](UARPTLVPersonalizationFTABPayloadBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v33);

  v34 = +[UARPTLVPersonalizedManifestBackDeploy metaDataTableEntry](UARPTLVPersonalizedManifestBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v34);

  v35 = +[UARPTLVPersonalizationLifeBackDeploy metaDataTableEntry](UARPTLVPersonalizationLifeBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v35);

  v36 = +[UARPTLVPersonalizationProvisioningBackDeploy metaDataTableEntry](UARPTLVPersonalizationProvisioningBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v36);

  v37 = +[UARPTLVPersonalizationManifestEpochBackDeploy metaDataTableEntry](UARPTLVPersonalizationManifestEpochBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v37);

  v38 = +[UARPTLVPersonalizationManifestSuffixBackDeploy metaDataTableEntry](UARPTLVPersonalizationManifestSuffixBackDeploy, "metaDataTableEntry");
  -[NSMutableArray addObject:](v1, "addObject:", v38);

  v39 = +[NSArray arrayWithArray:](NSArray, "arrayWithArray:", v1);
  v40 = (void *)qword_1001A8270;
  qword_1001A8270 = (uint64_t)v39;

}

id FormatHex(uint64_t a1, unint64_t a2, int a3)
{
  void *v6;
  void *v7;
  const __CFString *v8;
  unint64_t v9;
  const char *v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  int v20;
  void *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  int v31;
  void *v32;
  uint64_t v33;
  int v34;
  void *v35;
  char *__format;
  char __str[32];
  uint64_t v39;
  char v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  char v44;

  v6 = (void *)objc_claimAutoreleasedReturnValue(+[NSMutableString stringWithCapacity:](NSMutableString, "stringWithCapacity:", 0));
  v7 = v6;
  v44 = 0;
  v43 = 0;
  if (a3)
    v8 = CFSTR("00000000  ");
  else
    v8 = CFSTR("0000  ");
  objc_msgSend(v6, "appendFormat:", v8);
  if (a2)
  {
    v9 = 0;
    v10 = "%s %s\n%04x  ";
    if (a3)
      v10 = "%s %s\n%08x  ";
    __format = (char *)v10;
    do
    {
      if (v9)
      {
        v11 = v9 & 0xF;
        if ((v9 & 0xF) == 0)
        {
          v42 = 0;
          v41 = *(_QWORD *)(v9 + a1 - 16);
          do
          {
            v12 = *((char *)&v41 + v11);
            if (v12 < 32 || v12 == 127 || *((_BYTE *)&v41 + v11) == 32)
              *((_BYTE *)&v41 + v11) = 46;
            ++v11;
          }
          while (v11 != 8);
          v13 = 0;
          v40 = 0;
          v39 = *(_QWORD *)(v9 + a1 - 8);
          do
          {
            v14 = *((char *)&v39 + v13);
            if (v14 < 32 || v14 == 127 || *((_BYTE *)&v39 + v13) == 32)
              *((_BYTE *)&v39 + v13) = 46;
            ++v13;
          }
          while (v13 != 8);
          snprintf(__str, 0x20uLL, __format, &v41, &v39, v9);
          objc_msgSend(v7, "appendFormat:", CFSTR("%s"), __str);
        }
      }
      if (v9 + 8 >= a2)
      {
        objc_msgSend(v7, "appendFormat:", CFSTR("%02x "), *(unsigned __int8 *)(a1 + v9++));
      }
      else
      {
        v15 = *(unsigned __int8 *)(a1 + v9);
        v16 = *(unsigned __int8 *)(a1 + v9 + 1);
        if ((((_BYTE)v9 + 8) & 0xF) != 0)
          snprintf(__str, 0x20uLL, "%02x %02x %02x %02x %02x %02x %02x %02x  ", v15, v16);
        else
          snprintf(__str, 0x20uLL, "%02x %02x %02x %02x %02x %02x %02x %02x    ", v15, v16);
        objc_msgSend(v7, "appendFormat:", CFSTR("%s"), __str);
        v9 += 8;
      }
    }
    while (v9 < a2);
    v17 = 16;
    if ((a2 & 0xF) != 0)
      v17 = a2 & 0xF;
    if (a2 <= 0xF)
      v18 = a2;
    else
      v18 = v17;
    if (a2 >= 0x10 && (a2 & 0xF) == 0)
    {
      objc_msgSend(v7, "appendString:", CFSTR("   "));
      v19 = 0;
      v43 = *(_QWORD *)(v9 + a1 - 16);
      do
      {
        v20 = *((char *)&v43 + v19);
        if (v20 < 32 || v20 == 127 || *((_BYTE *)&v43 + v19) == 32)
          *((_BYTE *)&v43 + v19) = 46;
        ++v19;
      }
      while (v19 != 8);
      v21 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", &v43));
      objc_msgSend(v7, "appendString:", v21);

      objc_msgSend(v7, "appendString:", CFSTR(" "));
      v22 = 0;
      v43 = *(_QWORD *)(v9 + a1 - 8);
      do
      {
        v23 = *((char *)&v43 + v22);
        if (v23 < 32 || v23 == 127 || *((_BYTE *)&v43 + v22) == 32)
          *((_BYTE *)&v43 + v22) = 46;
        ++v22;
      }
      while (v22 != 8);
LABEL_77:
      v35 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", &v43));
      objc_msgSend(v7, "appendString:", v35);

      return v7;
    }
  }
  else
  {
    v18 = 0;
    v9 = 0;
  }
  v24 = 3;
  if (v18 < 9)
    v24 = 4;
  v25 = 3 * (16 - v18) + v24;
  do
  {
    objc_msgSend(v7, "appendString:", CFSTR(" "));
    --v25;
  }
  while (v25);
  v26 = (uint64_t *)(a1 + v9 - v18);
  v27 = v18 - 8;
  if (v18 >= 8)
  {
    v30 = 0;
    v43 = *v26;
    do
    {
      v31 = *((char *)&v43 + v30);
      if (v31 < 32 || v31 == 127 || *((_BYTE *)&v43 + v30) == 32)
        *((_BYTE *)&v43 + v30) = 46;
      ++v30;
    }
    while (v30 != 8);
  }
  else
  {
    __memcpy_chk(&v43, v26, v18, 9);
    *((_BYTE *)&v43 + v18) = 0;
    if (v18)
    {
      v28 = 0;
      do
      {
        v29 = *((char *)&v43 + v28);
        if (v29 < 32 || v29 == 127 || *((_BYTE *)&v43 + v28) == 32)
          *((_BYTE *)&v43 + v28) = 46;
        ++v28;
      }
      while (v28 < v18);
    }
    v27 = 0;
  }
  v32 = (void *)objc_claimAutoreleasedReturnValue(+[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", &v43));
  objc_msgSend(v7, "appendString:", v32);

  if (v27)
  {
    objc_msgSend(v7, "appendString:", CFSTR(" "));
    __memcpy_chk(&v43, a1 + v9 - v27, v27, 9);
    v33 = 0;
    *((_BYTE *)&v43 + v27) = 0;
    do
    {
      v34 = *((char *)&v43 + v33);
      if (v34 < 32 || v34 == 127 || *((_BYTE *)&v43 + v33) == 32)
        *((_BYTE *)&v43 + v33) = 46;
      ++v33;
    }
    while (v27 > v33);
    goto LABEL_77;
  }
  return v7;
}

